<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/clang/include/clang-c/Index.h", "content": "/*===-- clang-c/Index.h - Indexing Public C Interface -------------*- C -*-===*\\\n|*                                                                            *|\n|* Part of the LLVM Project, under the Apache License v2.0 with LLVM          *|\n|* Exceptions.                                                                *|\n|* See https://llvm.org/LICENSE.txt for license information.                  *|\n|* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception                    *|\n|*                                                                            *|\n|*===----------------------------------------------------------------------===*|\n|*                                                                            *|\n|* This header provides a public interface to a Clang library for extracting  *|\n|* high-level symbol information from source files without exposing the full  *|\n|* Clang C++ API.                                                             *|\n|*                                                                            *|\n\\*===----------------------------------------------------------------------===*/\n\n#ifndef LLVM_CLANG_C_INDEX_H\n#define LLVM_CLANG_C_INDEX_H\n\n#include <time.h>\n\n#include \"clang-c/BuildSystem.h\"\n#include \"clang-c/CXErrorCode.h\"\n#include \"clang-c/CXString.h\"\n#include \"clang-c/ExternC.h\"\n#include \"clang-c/Platform.h\"\n\n/**\n * The version constants for the libclang API.\n * CINDEX_VERSION_MINOR should increase when there are API additions.\n * CINDEX_VERSION_MAJOR is intended for \"major\" source/ABI breaking changes.\n *\n * The policy about the libclang API was always to keep it source and ABI\n * compatible, thus CINDEX_VERSION_MAJOR is expected to remain stable.\n */\n#define CINDEX_VERSION_MAJOR 0\n#define CINDEX_VERSION_MINOR 61\n\n#define CINDEX_VERSION_ENCODE(major, minor) (((major)*10000) + ((minor)*1))\n\n#define CINDEX_VERSION                                                         \\\n  CINDEX_VERSION_ENCODE(CINDEX_VERSION_MAJOR, CINDEX_VERSION_MINOR)\n\n#define CINDEX_VERSION_STRINGIZE_(major, minor) #major \".\" #minor\n#define CINDEX_VERSION_STRINGIZE(major, minor)                                 \\\n  CINDEX_VERSION_STRINGIZE_(major, minor)\n\n#define CINDEX_VERSION_STRING                                                  \\\n  CINDEX_VERSION_STRINGIZE(CINDEX_VERSION_MAJOR, CINDEX_VERSION_MINOR)\n\nLLVM_CLANG_C_EXTERN_C_BEGIN\n\n/** \\defgroup CINDEX libclang: C Interface to Clang\n *\n * The C Interface to Clang provides a relatively small API that exposes\n * facilities for parsing source code into an abstract syntax tree (AST),\n * loading already-parsed ASTs, traversing the AST, associating\n * physical source locations with elements within the AST, and other\n * facilities that support Clang-based development tools.\n *\n * This C interface to Clang will never provide all of the information\n * representation stored in Clang's C++ AST, nor should it: the intent is to\n * maintain an API that is relatively stable from one release to the next,\n * providing only the basic functionality needed to support development tools.\n *\n * To avoid namespace pollution, data types are prefixed with \"CX\" and\n * functions are prefixed with \"clang_\".\n *\n * @{\n */\n\n/**\n * An \"index\" that consists of a set of translation units that would\n * typically be linked together into an executable or library.\n */\ntypedef void *CXIndex;\n\n/**\n * An opaque type representing target information for a given translation\n * unit.\n */\ntypedef struct CXTargetInfoImpl *CXTargetInfo;\n\n/**\n * A single translation unit, which resides in an index.\n */\ntypedef struct CXTranslationUnitImpl *CXTranslationUnit;\n\n/**\n * Opaque pointer representing client data that will be passed through\n * to various callbacks and visitors.\n */\ntypedef void *CXClientData;\n\n/**\n * Provides the contents of a file that has not yet been saved to disk.\n *\n * Each CXUnsavedFile instance provides the name of a file on the\n * system along with the current contents of that file that have not\n * yet been saved to disk.\n */\nstruct CXUnsavedFile {\n  /**\n   * The file whose contents have not yet been saved.\n   *\n   * This file must already exist in the file system.\n   */\n  const char *Filename;\n\n  /**\n   * A buffer containing the unsaved contents of this file.\n   */\n  const char *Contents;\n\n  /**\n   * The length of the unsaved contents of this buffer.\n   */\n  unsigned long Length;\n};\n\n/**\n * Describes the availability of a particular entity, which indicates\n * whether the use of this entity will result in a warning or error due to\n * it being deprecated or unavailable.\n */\nenum CXAvailabilityKind {\n  /**\n   * The entity is available.\n   */\n  CXAvailability_Available,\n  /**\n   * The entity is available, but has been deprecated (and its use is\n   * not recommended).\n   */\n  CXAvailability_Deprecated,\n  /**\n   * The entity is not available; any use of it will be an error.\n   */\n  CXAvailability_NotAvailable,\n  /**\n   * The entity is available, but not accessible; any use of it will be\n   * an error.\n   */\n  CXAvailability_NotAccessible\n};\n\n/**\n * Describes a version number of the form major.minor.subminor.\n */\ntypedef struct CXVersion {\n  /**\n   * The major version number, e.g., the '10' in '10.7.3'. A negative\n   * value indicates that there is no version number at all.\n   */\n  int Major;\n  /**\n   * The minor version number, e.g., the '7' in '10.7.3'. This value\n   * will be negative if no minor version number was provided, e.g., for\n   * version '10'.\n   */\n  int Minor;\n  /**\n   * The subminor version number, e.g., the '3' in '10.7.3'. This value\n   * will be negative if no minor or subminor version number was provided,\n   * e.g., in version '10' or '10.7'.\n   */\n  int Subminor;\n} CXVersion;\n\n/**\n * Describes the exception specification of a cursor.\n *\n * A negative value indicates that the cursor is not a function declaration.\n */\nenum CXCursor_ExceptionSpecificationKind {\n  /**\n   * The cursor has no exception specification.\n   */\n  CXCursor_ExceptionSpecificationKind_None,\n\n  /**\n   * The cursor has exception specification throw()\n   */\n  CXCursor_ExceptionSpecificationKind_DynamicNone,\n\n  /**\n   * The cursor has exception specification throw(T1, T2)\n   */\n  CXCursor_ExceptionSpecificationKind_Dynamic,\n\n  /**\n   * The cursor has exception specification throw(...).\n   */\n  CXCursor_ExceptionSpecificationKind_MSAny,\n\n  /**\n   * The cursor has exception specification basic noexcept.\n   */\n  CXCursor_ExceptionSpecificationKind_BasicNoexcept,\n\n  /**\n   * The cursor has exception specification computed noexcept.\n   */\n  CXCursor_ExceptionSpecificationKind_ComputedNoexcept,\n\n  /**\n   * The exception specification has not yet been evaluated.\n   */\n  CXCursor_ExceptionSpecificationKind_Unevaluated,\n\n  /**\n   * The exception specification has not yet been instantiated.\n   */\n  CXCursor_ExceptionSpecificationKind_Uninstantiated,\n\n  /**\n   * The exception specification has not been parsed yet.\n   */\n  CXCursor_ExceptionSpecificationKind_Unparsed,\n\n  /**\n   * The cursor has a __declspec(nothrow) exception specification.\n   */\n  CXCursor_ExceptionSpecificationKind_NoThrow\n};\n\n/**\n * Provides a shared context for creating translation units.\n *\n * It provides two options:\n *\n * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of \"local\"\n * declarations (when loading any new translation units). A \"local\" declaration\n * is one that belongs in the translation unit itself and not in a precompiled\n * header that was used by the translation unit. If zero, all declarations\n * will be enumerated.\n *\n * Here is an example:\n *\n * \\code\n *   // excludeDeclsFromPCH = 1, displayDiagnostics=1\n *   Idx = clang_createIndex(1, 1);\n *\n *   // IndexTest.pch was produced with the following command:\n *   // \"clang -x c IndexTest.h -emit-ast -o IndexTest.pch\"\n *   TU = clang_createTranslationUnit(Idx, \"IndexTest.pch\");\n *\n *   // This will load all the symbols from 'IndexTest.pch'\n *   clang_visitChildren(clang_getTranslationUnitCursor(TU),\n *                       TranslationUnitVisitor, 0);\n *   clang_disposeTranslationUnit(TU);\n *\n *   // This will load all the symbols from 'IndexTest.c', excluding symbols\n *   // from 'IndexTest.pch'.\n *   char *args[] = { \"-Xclang\", \"-include-pch=IndexTest.pch\" };\n *   TU = clang_createTranslationUnitFromSourceFile(Idx, \"IndexTest.c\", 2, args,\n *                                                  0, 0);\n *   clang_visitChildren(clang_getTranslationUnitCursor(TU),\n *                       TranslationUnitVisitor, 0);\n *   clang_disposeTranslationUnit(TU);\n * \\endcode\n *\n * This process of creating the 'pch', loading it separately, and using it (via\n * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks\n * (which gives the indexer the same performance benefit as the compiler).\n */\nCINDEX_LINKAGE CXIndex clang_createIndex(int excludeDeclarationsFromPCH,\n                                         int displayDiagnostics);\n\n/**\n * Destroy the given index.\n *\n * The index must not be destroyed until all of the translation units created\n * within that index have been destroyed.\n */\nCINDEX_LINKAGE void clang_disposeIndex(CXIndex index);\n\ntypedef enum {\n  /**\n   * Used to indicate that no special CXIndex options are needed.\n   */\n  CXGlobalOpt_None = 0x0,\n\n  /**\n   * Used to indicate that threads that libclang creates for indexing\n   * purposes should use background priority.\n   *\n   * Affects #clang_indexSourceFile, #clang_indexTranslationUnit,\n   * #clang_parseTranslationUnit, #clang_saveTranslationUnit.\n   */\n  CXGlobalOpt_ThreadBackgroundPriorityForIndexing = 0x1,\n\n  /**\n   * Used to indicate that threads that libclang creates for editing\n   * purposes should use background priority.\n   *\n   * Affects #clang_reparseTranslationUnit, #clang_codeCompleteAt,\n   * #clang_annotateTokens\n   */\n  CXGlobalOpt_ThreadBackgroundPriorityForEditing = 0x2,\n\n  /**\n   * Used to indicate that all threads that libclang creates should use\n   * background priority.\n   */\n  CXGlobalOpt_ThreadBackgroundPriorityForAll =\n      CXGlobalOpt_ThreadBackgroundPriorityForIndexing |\n      CXGlobalOpt_ThreadBackgroundPriorityForEditing\n\n} CXGlobalOptFlags;\n\n/**\n * Sets general options associated with a CXIndex.\n *\n * For example:\n * \\code\n * CXIndex idx = ...;\n * clang_CXIndex_setGlobalOptions(idx,\n *     clang_CXIndex_getGlobalOptions(idx) |\n *     CXGlobalOpt_ThreadBackgroundPriorityForIndexing);\n * \\endcode\n *\n * \\param options A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags.\n */\nCINDEX_LINKAGE void clang_CXIndex_setGlobalOptions(CXIndex, unsigned options);\n\n/**\n * Gets the general options associated with a CXIndex.\n *\n * \\returns A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags that\n * are associated with the given CXIndex object.\n */\nCINDEX_LINKAGE unsigned clang_CXIndex_getGlobalOptions(CXIndex);\n\n/**\n * Sets the invocation emission path option in a CXIndex.\n *\n * The invocation emission path specifies a path which will contain log\n * files for certain libclang invocations. A null value (default) implies that\n * libclang invocations are not logged..\n */\nCINDEX_LINKAGE void\nclang_CXIndex_setInvocationEmissionPathOption(CXIndex, const char *Path);\n\n/**\n * \\defgroup CINDEX_FILES File manipulation routines\n *\n * @{\n */\n\n/**\n * A particular source file that is part of a translation unit.\n */\ntypedef void *CXFile;\n\n/**\n * Retrieve the complete file and path name of the given file.\n */\nCINDEX_LINKAGE CXString clang_getFileName(CXFile SFile);\n\n/**\n * Retrieve the last modification time of the given file.\n */\nCINDEX_LINKAGE time_t clang_getFileTime(CXFile SFile);\n\n/**\n * Uniquely identifies a CXFile, that refers to the same underlying file,\n * across an indexing session.\n */\ntypedef struct {\n  unsigned long long data[3];\n} CXFileUniqueID;\n\n/**\n * Retrieve the unique ID for the given \\c file.\n *\n * \\param file the file to get the ID for.\n * \\param outID stores the returned CXFileUniqueID.\n * \\returns If there was a failure getting the unique ID, returns non-zero,\n * otherwise returns 0.\n */\nCINDEX_LINKAGE int clang_getFileUniqueID(CXFile file, CXFileUniqueID *outID);\n\n/**\n * Determine whether the given header is guarded against\n * multiple inclusions, either with the conventional\n * \\#ifndef/\\#define/\\#endif macro guards or with \\#pragma once.\n */\nCINDEX_LINKAGE unsigned clang_isFileMultipleIncludeGuarded(CXTranslationUnit tu,\n                                                           CXFile file);\n\n/**\n * Retrieve a file handle within the given translation unit.\n *\n * \\param tu the translation unit\n *\n * \\param file_name the name of the file.\n *\n * \\returns the file handle for the named file in the translation unit \\p tu,\n * or a NULL file handle if the file was not a part of this translation unit.\n */\nCINDEX_LINKAGE CXFile clang_getFile(CXTranslationUnit tu,\n                                    const char *file_name);\n\n/**\n * Retrieve the buffer associated with the given file.\n *\n * \\param tu the translation unit\n *\n * \\param file the file for which to retrieve the buffer.\n *\n * \\param size [out] if non-NULL, will be set to the size of the buffer.\n *\n * \\returns a pointer to the buffer in memory that holds the contents of\n * \\p file, or a NULL pointer when the file is not loaded.\n */\nCINDEX_LINKAGE const char *clang_getFileContents(CXTranslationUnit tu,\n                                                 CXFile file, size_t *size);\n\n/**\n * Returns non-zero if the \\c file1 and \\c file2 point to the same file,\n * or they are both NULL.\n */\nCINDEX_LINKAGE int clang_File_isEqual(CXFile file1, CXFile file2);\n\n/**\n * Returns the real path name of \\c file.\n *\n * An empty string may be returned. Use \\c clang_getFileName() in that case.\n */\nCINDEX_LINKAGE CXString clang_File_tryGetRealPathName(CXFile file);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_LOCATIONS Physical source locations\n *\n * Clang represents physical source locations in its abstract syntax tree in\n * great detail, with file, line, and column information for the majority of\n * the tokens parsed in the source code. These data types and functions are\n * used to represent source location information, either for a particular\n * point in the program or for a range of points in the program, and extract\n * specific location information from those data types.\n *\n * @{\n */\n\n/**\n * Identifies a specific source location within a translation\n * unit.\n *\n * Use clang_getExpansionLocation() or clang_getSpellingLocation()\n * to map a source location to a particular file, line, and column.\n */\ntypedef struct {\n  const void *ptr_data[2];\n  unsigned int_data;\n} CXSourceLocation;\n\n/**\n * Identifies a half-open character range in the source code.\n *\n * Use clang_getRangeStart() and clang_getRangeEnd() to retrieve the\n * starting and end locations from a source range, respectively.\n */\ntypedef struct {\n  const void *ptr_data[2];\n  unsigned begin_int_data;\n  unsigned end_int_data;\n} CXSourceRange;\n\n/**\n * Retrieve a NULL (invalid) source location.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getNullLocation(void);\n\n/**\n * Determine whether two source locations, which must refer into\n * the same translation unit, refer to exactly the same point in the source\n * code.\n *\n * \\returns non-zero if the source locations refer to the same location, zero\n * if they refer to different locations.\n */\nCINDEX_LINKAGE unsigned clang_equalLocations(CXSourceLocation loc1,\n                                             CXSourceLocation loc2);\n\n/**\n * Retrieves the source location associated with a given file/line/column\n * in a particular translation unit.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getLocation(CXTranslationUnit tu,\n                                                  CXFile file, unsigned line,\n                                                  unsigned column);\n/**\n * Retrieves the source location associated with a given character offset\n * in a particular translation unit.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getLocationForOffset(CXTranslationUnit tu,\n                                                           CXFile file,\n                                                           unsigned offset);\n\n/**\n * Returns non-zero if the given source location is in a system header.\n */\nCINDEX_LINKAGE int clang_Location_isInSystemHeader(CXSourceLocation location);\n\n/**\n * Returns non-zero if the given source location is in the main file of\n * the corresponding translation unit.\n */\nCINDEX_LINKAGE int clang_Location_isFromMainFile(CXSourceLocation location);\n\n/**\n * Retrieve a NULL (invalid) source range.\n */\nCINDEX_LINKAGE CXSourceRange clang_getNullRange(void);\n\n/**\n * Retrieve a source range given the beginning and ending source\n * locations.\n */\nCINDEX_LINKAGE CXSourceRange clang_getRange(CXSourceLocation begin,\n                                            CXSourceLocation end);\n\n/**\n * Determine whether two ranges are equivalent.\n *\n * \\returns non-zero if the ranges are the same, zero if they differ.\n */\nCINDEX_LINKAGE unsigned clang_equalRanges(CXSourceRange range1,\n                                          CXSourceRange range2);\n\n/**\n * Returns non-zero if \\p range is null.\n */\nCINDEX_LINKAGE int clang_Range_isNull(CXSourceRange range);\n\n/**\n * Retrieve the file, line, column, and offset represented by\n * the given source location.\n *\n * If the location refers into a macro expansion, retrieves the\n * location of the macro expansion.\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param file [out] if non-NULL, will be set to the file to which the given\n * source location points.\n *\n * \\param line [out] if non-NULL, will be set to the line to which the given\n * source location points.\n *\n * \\param column [out] if non-NULL, will be set to the column to which the given\n * source location points.\n *\n * \\param offset [out] if non-NULL, will be set to the offset into the\n * buffer to which the given source location points.\n */\nCINDEX_LINKAGE void clang_getExpansionLocation(CXSourceLocation location,\n                                               CXFile *file, unsigned *line,\n                                               unsigned *column,\n                                               unsigned *offset);\n\n/**\n * Retrieve the file, line and column represented by the given source\n * location, as specified in a # line directive.\n *\n * Example: given the following source code in a file somefile.c\n *\n * \\code\n * #123 \"dummy.c\" 1\n *\n * static int func(void)\n * {\n *     return 0;\n * }\n * \\endcode\n *\n * the location information returned by this function would be\n *\n * File: dummy.c Line: 124 Column: 12\n *\n * whereas clang_getExpansionLocation would have returned\n *\n * File: somefile.c Line: 3 Column: 12\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param filename [out] if non-NULL, will be set to the filename of the\n * source location. Note that filenames returned will be for \"virtual\" files,\n * which don't necessarily exist on the machine running clang - e.g. when\n * parsing preprocessed output obtained from a different environment. If\n * a non-NULL value is passed in, remember to dispose of the returned value\n * using \\c clang_disposeString() once you've finished with it. For an invalid\n * source location, an empty string is returned.\n *\n * \\param line [out] if non-NULL, will be set to the line number of the\n * source location. For an invalid source location, zero is returned.\n *\n * \\param column [out] if non-NULL, will be set to the column number of the\n * source location. For an invalid source location, zero is returned.\n */\nCINDEX_LINKAGE void clang_getPresumedLocation(CXSourceLocation location,\n                                              CXString *filename,\n                                              unsigned *line, unsigned *column);\n\n/**\n * Legacy API to retrieve the file, line, column, and offset represented\n * by the given source location.\n *\n * This interface has been replaced by the newer interface\n * #clang_getExpansionLocation(). See that interface's documentation for\n * details.\n */\nCINDEX_LINKAGE void clang_getInstantiationLocation(CXSourceLocation location,\n                                                   CXFile *file, unsigned *line,\n                                                   unsigned *column,\n                                                   unsigned *offset);\n\n/**\n * Retrieve the file, line, column, and offset represented by\n * the given source location.\n *\n * If the location refers into a macro instantiation, return where the\n * location was originally spelled in the source file.\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param file [out] if non-NULL, will be set to the file to which the given\n * source location points.\n *\n * \\param line [out] if non-NULL, will be set to the line to which the given\n * source location points.\n *\n * \\param column [out] if non-NULL, will be set to the column to which the given\n * source location points.\n *\n * \\param offset [out] if non-NULL, will be set to the offset into the\n * buffer to which the given source location points.\n */\nCINDEX_LINKAGE void clang_getSpellingLocation(CXSourceLocation location,\n                                              CXFile *file, unsigned *line,\n                                              unsigned *column,\n                                              unsigned *offset);\n\n/**\n * Retrieve the file, line, column, and offset represented by\n * the given source location.\n *\n * If the location refers into a macro expansion, return where the macro was\n * expanded or where the macro argument was written, if the location points at\n * a macro argument.\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param file [out] if non-NULL, will be set to the file to which the given\n * source location points.\n *\n * \\param line [out] if non-NULL, will be set to the line to which the given\n * source location points.\n *\n * \\param column [out] if non-NULL, will be set to the column to which the given\n * source location points.\n *\n * \\param offset [out] if non-NULL, will be set to the offset into the\n * buffer to which the given source location points.\n */\nCINDEX_LINKAGE void clang_getFileLocation(CXSourceLocation location,\n                                          CXFile *file, unsigned *line,\n                                          unsigned *column, unsigned *offset);\n\n/**\n * Retrieve a source location representing the first character within a\n * source range.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getRangeStart(CXSourceRange range);\n\n/**\n * Retrieve a source location representing the last character within a\n * source range.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getRangeEnd(CXSourceRange range);\n\n/**\n * Identifies an array of ranges.\n */\ntypedef struct {\n  /** The number of ranges in the \\c ranges array. */\n  unsigned count;\n  /**\n   * An array of \\c CXSourceRanges.\n   */\n  CXSourceRange *ranges;\n} CXSourceRangeList;\n\n/**\n * Retrieve all ranges that were skipped by the preprocessor.\n *\n * The preprocessor will skip lines when they are surrounded by an\n * if/ifdef/ifndef directive whose condition does not evaluate to true.\n */\nCINDEX_LINKAGE CXSourceRangeList *clang_getSkippedRanges(CXTranslationUnit tu,\n                                                         CXFile file);\n\n/**\n * Retrieve all ranges from all files that were skipped by the\n * preprocessor.\n *\n * The preprocessor will skip lines when they are surrounded by an\n * if/ifdef/ifndef directive whose condition does not evaluate to true.\n */\nCINDEX_LINKAGE CXSourceRangeList *\nclang_getAllSkippedRanges(CXTranslationUnit tu);\n\n/**\n * Destroy the given \\c CXSourceRangeList.\n */\nCINDEX_LINKAGE void clang_disposeSourceRangeList(CXSourceRangeList *ranges);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_DIAG Diagnostic reporting\n *\n * @{\n */\n\n/**\n * Describes the severity of a particular diagnostic.\n */\nenum CXDiagnosticSeverity {\n  /**\n   * A diagnostic that has been suppressed, e.g., by a command-line\n   * option.\n   */\n  CXDiagnostic_Ignored = 0,\n\n  /**\n   * This diagnostic is a note that should be attached to the\n   * previous (non-note) diagnostic.\n   */\n  CXDiagnostic_Note = 1,\n\n  /**\n   * This diagnostic indicates suspicious code that may not be\n   * wrong.\n   */\n  CXDiagnostic_Warning = 2,\n\n  /**\n   * This diagnostic indicates that the code is ill-formed.\n   */\n  CXDiagnostic_Error = 3,\n\n  /**\n   * This diagnostic indicates that the code is ill-formed such\n   * that future parser recovery is unlikely to produce useful\n   * results.\n   */\n  CXDiagnostic_Fatal = 4\n};\n\n/**\n * A single diagnostic, containing the diagnostic's severity,\n * location, text, source ranges, and fix-it hints.\n */\ntypedef void *CXDiagnostic;\n\n/**\n * A group of CXDiagnostics.\n */\ntypedef void *CXDiagnosticSet;\n\n/**\n * Determine the number of diagnostics in a CXDiagnosticSet.\n */\nCINDEX_LINKAGE unsigned clang_getNumDiagnosticsInSet(CXDiagnosticSet Diags);\n\n/**\n * Retrieve a diagnostic associated with the given CXDiagnosticSet.\n *\n * \\param Diags the CXDiagnosticSet to query.\n * \\param Index the zero-based diagnostic number to retrieve.\n *\n * \\returns the requested diagnostic. This diagnostic must be freed\n * via a call to \\c clang_disposeDiagnostic().\n */\nCINDEX_LINKAGE CXDiagnostic clang_getDiagnosticInSet(CXDiagnosticSet Diags,\n                                                     unsigned Index);\n\n/**\n * Describes the kind of error that occurred (if any) in a call to\n * \\c clang_loadDiagnostics.\n */\nenum CXLoadDiag_Error {\n  /**\n   * Indicates that no error occurred.\n   */\n  CXLoadDiag_None = 0,\n\n  /**\n   * Indicates that an unknown error occurred while attempting to\n   * deserialize diagnostics.\n   */\n  CXLoadDiag_Unknown = 1,\n\n  /**\n   * Indicates that the file containing the serialized diagnostics\n   * could not be opened.\n   */\n  CXLoadDiag_CannotLoad = 2,\n\n  /**\n   * Indicates that the serialized diagnostics file is invalid or\n   * corrupt.\n   */\n  CXLoadDiag_InvalidFile = 3\n};\n\n/**\n * Deserialize a set of diagnostics from a Clang diagnostics bitcode\n * file.\n *\n * \\param file The name of the file to deserialize.\n * \\param error A pointer to a enum value recording if there was a problem\n *        deserializing the diagnostics.\n * \\param errorString A pointer to a CXString for recording the error string\n *        if the file was not successfully loaded.\n *\n * \\returns A loaded CXDiagnosticSet if successful, and NULL otherwise.  These\n * diagnostics should be released using clang_disposeDiagnosticSet().\n */\nCINDEX_LINKAGE CXDiagnosticSet clang_loadDiagnostics(\n    const char *file, enum CXLoadDiag_Error *error, CXString *errorString);\n\n/**\n * Release a CXDiagnosticSet and all of its contained diagnostics.\n */\nCINDEX_LINKAGE void clang_disposeDiagnosticSet(CXDiagnosticSet Diags);\n\n/**\n * Retrieve the child diagnostics of a CXDiagnostic.\n *\n * This CXDiagnosticSet does not need to be released by\n * clang_disposeDiagnosticSet.\n */\nCINDEX_LINKAGE CXDiagnosticSet clang_getChildDiagnostics(CXDiagnostic D);\n\n/**\n * Determine the number of diagnostics produced for the given\n * translation unit.\n */\nCINDEX_LINKAGE unsigned clang_getNumDiagnostics(CXTranslationUnit Unit);\n\n/**\n * Retrieve a diagnostic associated with the given translation unit.\n *\n * \\param Unit the translation unit to query.\n * \\param Index the zero-based diagnostic number to retrieve.\n *\n * \\returns the requested diagnostic. This diagnostic must be freed\n * via a call to \\c clang_disposeDiagnostic().\n */\nCINDEX_LINKAGE CXDiagnostic clang_getDiagnostic(CXTranslationUnit Unit,\n                                                unsigned Index);\n\n/**\n * Retrieve the complete set of diagnostics associated with a\n *        translation unit.\n *\n * \\param Unit the translation unit to query.\n */\nCINDEX_LINKAGE CXDiagnosticSet\nclang_getDiagnosticSetFromTU(CXTranslationUnit Unit);\n\n/**\n * Destroy a diagnostic.\n */\nCINDEX_LINKAGE void clang_disposeDiagnostic(CXDiagnostic Diagnostic);\n\n/**\n * Options to control the display of diagnostics.\n *\n * The values in this enum are meant to be combined to customize the\n * behavior of \\c clang_formatDiagnostic().\n */\nenum CXDiagnosticDisplayOptions {\n  /**\n   * Display the source-location information where the\n   * diagnostic was located.\n   *\n   * When set, diagnostics will be prefixed by the file, line, and\n   * (optionally) column to which the diagnostic refers. For example,\n   *\n   * \\code\n   * test.c:28: warning: extra tokens at end of #endif directive\n   * \\endcode\n   *\n   * This option corresponds to the clang flag \\c -fshow-source-location.\n   */\n  CXDiagnostic_DisplaySourceLocation = 0x01,\n\n  /**\n   * If displaying the source-location information of the\n   * diagnostic, also include the column number.\n   *\n   * This option corresponds to the clang flag \\c -fshow-column.\n   */\n  CXDiagnostic_DisplayColumn = 0x02,\n\n  /**\n   * If displaying the source-location information of the\n   * diagnostic, also include information about source ranges in a\n   * machine-parsable format.\n   *\n   * This option corresponds to the clang flag\n   * \\c -fdiagnostics-print-source-range-info.\n   */\n  CXDiagnostic_DisplaySourceRanges = 0x04,\n\n  /**\n   * Display the option name associated with this diagnostic, if any.\n   *\n   * The option name displayed (e.g., -Wconversion) will be placed in brackets\n   * after the diagnostic text. This option corresponds to the clang flag\n   * \\c -fdiagnostics-show-option.\n   */\n  CXDiagnostic_DisplayOption = 0x08,\n\n  /**\n   * Display the category number associated with this diagnostic, if any.\n   *\n   * The category number is displayed within brackets after the diagnostic text.\n   * This option corresponds to the clang flag\n   * \\c -fdiagnostics-show-category=id.\n   */\n  CXDiagnostic_DisplayCategoryId = 0x10,\n\n  /**\n   * Display the category name associated with this diagnostic, if any.\n   *\n   * The category name is displayed within brackets after the diagnostic text.\n   * This option corresponds to the clang flag\n   * \\c -fdiagnostics-show-category=name.\n   */\n  CXDiagnostic_DisplayCategoryName = 0x20\n};\n\n/**\n * Format the given diagnostic in a manner that is suitable for display.\n *\n * This routine will format the given diagnostic to a string, rendering\n * the diagnostic according to the various options given. The\n * \\c clang_defaultDiagnosticDisplayOptions() function returns the set of\n * options that most closely mimics the behavior of the clang compiler.\n *\n * \\param Diagnostic The diagnostic to print.\n *\n * \\param Options A set of options that control the diagnostic display,\n * created by combining \\c CXDiagnosticDisplayOptions values.\n *\n * \\returns A new string containing for formatted diagnostic.\n */\nCINDEX_LINKAGE CXString clang_formatDiagnostic(CXDiagnostic Diagnostic,\n                                               unsigned Options);\n\n/**\n * Retrieve the set of display options most similar to the\n * default behavior of the clang compiler.\n *\n * \\returns A set of display options suitable for use with \\c\n * clang_formatDiagnostic().\n */\nCINDEX_LINKAGE unsigned clang_defaultDiagnosticDisplayOptions(void);\n\n/**\n * Determine the severity of the given diagnostic.\n */\nCINDEX_LINKAGE enum CXDiagnosticSeverity\n    clang_getDiagnosticSeverity(CXDiagnostic);\n\n/**\n * Retrieve the source location of the given diagnostic.\n *\n * This location is where Clang would print the caret ('^') when\n * displaying the diagnostic on the command line.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getDiagnosticLocation(CXDiagnostic);\n\n/**\n * Retrieve the text of the given diagnostic.\n */\nCINDEX_LINKAGE CXString clang_getDiagnosticSpelling(CXDiagnostic);\n\n/**\n * Retrieve the name of the command-line option that enabled this\n * diagnostic.\n *\n * \\param Diag The diagnostic to be queried.\n *\n * \\param Disable If non-NULL, will be set to the option that disables this\n * diagnostic (if any).\n *\n * \\returns A string that contains the command-line option used to enable this\n * warning, such as \"-Wconversion\" or \"-pedantic\".\n */\nCINDEX_LINKAGE CXString clang_getDiagnosticOption(CXDiagnostic Diag,\n                                                  CXString *Disable);\n\n/**\n * Retrieve the category number for this diagnostic.\n *\n * Diagnostics can be categorized into groups along with other, related\n * diagnostics (e.g., diagnostics under the same warning flag). This routine\n * retrieves the category number for the given diagnostic.\n *\n * \\returns The number of the category that contains this diagnostic, or zero\n * if this diagnostic is uncategorized.\n */\nCINDEX_LINKAGE unsigned clang_getDiagnosticCategory(CXDiagnostic);\n\n/**\n * Retrieve the name of a particular diagnostic category.  This\n *  is now deprecated.  Use clang_getDiagnosticCategoryText()\n *  instead.\n *\n * \\param Category A diagnostic category number, as returned by\n * \\c clang_getDiagnosticCategory().\n *\n * \\returns The name of the given diagnostic category.\n */\nCINDEX_DEPRECATED CINDEX_LINKAGE CXString\nclang_getDiagnosticCategoryName(unsigned Category);\n\n/**\n * Retrieve the diagnostic category text for a given diagnostic.\n *\n * \\returns The text of the given diagnostic category.\n */\nCINDEX_LINKAGE CXString clang_getDiagnosticCategoryText(CXDiagnostic);\n\n/**\n * Determine the number of source ranges associated with the given\n * diagnostic.\n */\nCINDEX_LINKAGE unsigned clang_getDiagnosticNumRanges(CXDiagnostic);\n\n/**\n * Retrieve a source range associated with the diagnostic.\n *\n * A diagnostic's source ranges highlight important elements in the source\n * code. On the command line, Clang displays source ranges by\n * underlining them with '~' characters.\n *\n * \\param Diagnostic the diagnostic whose range is being extracted.\n *\n * \\param Range the zero-based index specifying which range to\n *\n * \\returns the requested source range.\n */\nCINDEX_LINKAGE CXSourceRange clang_getDiagnosticRange(CXDiagnostic Diagnostic,\n                                                      unsigned Range);\n\n/**\n * Determine the number of fix-it hints associated with the\n * given diagnostic.\n */\nCINDEX_LINKAGE unsigned clang_getDiagnosticNumFixIts(CXDiagnostic Diagnostic);\n\n/**\n * Retrieve the replacement information for a given fix-it.\n *\n * Fix-its are described in terms of a source range whose contents\n * should be replaced by a string. This approach generalizes over\n * three kinds of operations: removal of source code (the range covers\n * the code to be removed and the replacement string is empty),\n * replacement of source code (the range covers the code to be\n * replaced and the replacement string provides the new code), and\n * insertion (both the start and end of the range point at the\n * insertion location, and the replacement string provides the text to\n * insert).\n *\n * \\param Diagnostic The diagnostic whose fix-its are being queried.\n *\n * \\param FixIt The zero-based index of the fix-it.\n *\n * \\param ReplacementRange The source range whose contents will be\n * replaced with the returned replacement string. Note that source\n * ranges are half-open ranges [a, b), so the source code should be\n * replaced from a and up to (but not including) b.\n *\n * \\returns A string containing text that should be replace the source\n * code indicated by the \\c ReplacementRange.\n */\nCINDEX_LINKAGE CXString clang_getDiagnosticFixIt(\n    CXDiagnostic Diagnostic, unsigned FixIt, CXSourceRange *ReplacementRange);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_TRANSLATION_UNIT Translation unit manipulation\n *\n * The routines in this group provide the ability to create and destroy\n * translation units from files, either by parsing the contents of the files or\n * by reading in a serialized representation of a translation unit.\n *\n * @{\n */\n\n/**\n * Get the original translation unit source file name.\n */\nCINDEX_LINKAGE CXString\nclang_getTranslationUnitSpelling(CXTranslationUnit CTUnit);\n\n/**\n * Return the CXTranslationUnit for a given source file and the provided\n * command line arguments one would pass to the compiler.\n *\n * Note: The 'source_filename' argument is optional.  If the caller provides a\n * NULL pointer, the name of the source file is expected to reside in the\n * specified command line arguments.\n *\n * Note: When encountered in 'clang_command_line_args', the following options\n * are ignored:\n *\n *   '-c'\n *   '-emit-ast'\n *   '-fsyntax-only'\n *   '-o \\<output file>'  (both '-o' and '\\<output file>' are ignored)\n *\n * \\param CIdx The index object with which the translation unit will be\n * associated.\n *\n * \\param source_filename The name of the source file to load, or NULL if the\n * source file is included in \\p clang_command_line_args.\n *\n * \\param num_clang_command_line_args The number of command-line arguments in\n * \\p clang_command_line_args.\n *\n * \\param clang_command_line_args The command-line arguments that would be\n * passed to the \\c clang executable if it were being invoked out-of-process.\n * These command-line options will be parsed and will affect how the translation\n * unit is parsed. Note that the following options are ignored: '-c',\n * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \\<output file>'.\n *\n * \\param num_unsaved_files the number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param unsaved_files the files that have not yet been saved to disk\n * but may be required for code completion, including the contents of\n * those files.  The contents and name of these files (as specified by\n * CXUnsavedFile) are copied when necessary, so the client only needs to\n * guarantee their validity until the call to this function returns.\n */\nCINDEX_LINKAGE CXTranslationUnit clang_createTranslationUnitFromSourceFile(\n    CXIndex CIdx, const char *source_filename, int num_clang_command_line_args,\n    const char *const *clang_command_line_args, unsigned num_unsaved_files,\n    struct CXUnsavedFile *unsaved_files);\n\n/**\n * Same as \\c clang_createTranslationUnit2, but returns\n * the \\c CXTranslationUnit instead of an error code.  In case of an error this\n * routine returns a \\c NULL \\c CXTranslationUnit, without further detailed\n * error codes.\n */\nCINDEX_LINKAGE CXTranslationUnit\nclang_createTranslationUnit(CXIndex CIdx, const char *ast_filename);\n\n/**\n * Create a translation unit from an AST file (\\c -emit-ast).\n *\n * \\param[out] out_TU A non-NULL pointer to store the created\n * \\c CXTranslationUnit.\n *\n * \\returns Zero on success, otherwise returns an error code.\n */\nCINDEX_LINKAGE enum CXErrorCode\nclang_createTranslationUnit2(CXIndex CIdx, const char *ast_filename,\n                             CXTranslationUnit *out_TU);\n\n/**\n * Flags that control the creation of translation units.\n *\n * The enumerators in this enumeration type are meant to be bitwise\n * ORed together to specify which options should be used when\n * constructing the translation unit.\n */\nenum CXTranslationUnit_Flags {\n  /**\n   * Used to indicate that no special translation-unit options are\n   * needed.\n   */\n  CXTranslationUnit_None = 0x0,\n\n  /**\n   * Used to indicate that the parser should construct a \"detailed\"\n   * preprocessing record, including all macro definitions and instantiations.\n   *\n   * Constructing a detailed preprocessing record requires more memory\n   * and time to parse, since the information contained in the record\n   * is usually not retained. However, it can be useful for\n   * applications that require more detailed information about the\n   * behavior of the preprocessor.\n   */\n  CXTranslationUnit_DetailedPreprocessingRecord = 0x01,\n\n  /**\n   * Used to indicate that the translation unit is incomplete.\n   *\n   * When a translation unit is considered \"incomplete\", semantic\n   * analysis that is typically performed at the end of the\n   * translation unit will be suppressed. For example, this suppresses\n   * the completion of tentative declarations in C and of\n   * instantiation of implicitly-instantiation function templates in\n   * C++. This option is typically used when parsing a header with the\n   * intent of producing a precompiled header.\n   */\n  CXTranslationUnit_Incomplete = 0x02,\n\n  /**\n   * Used to indicate that the translation unit should be built with an\n   * implicit precompiled header for the preamble.\n   *\n   * An implicit precompiled header is used as an optimization when a\n   * particular translation unit is likely to be reparsed many times\n   * when the sources aren't changing that often. In this case, an\n   * implicit precompiled header will be built containing all of the\n   * initial includes at the top of the main file (what we refer to as\n   * the \"preamble\" of the file). In subsequent parses, if the\n   * preamble or the files in it have not changed, \\c\n   * clang_reparseTranslationUnit() will re-use the implicit\n   * precompiled header to improve parsing performance.\n   */\n  CXTranslationUnit_PrecompiledPreamble = 0x04,\n\n  /**\n   * Used to indicate that the translation unit should cache some\n   * code-completion results with each reparse of the source file.\n   *\n   * Caching of code-completion results is a performance optimization that\n   * introduces some overhead to reparsing but improves the performance of\n   * code-completion operations.\n   */\n  CXTranslationUnit_CacheCompletionResults = 0x08,\n\n  /**\n   * Used to indicate that the translation unit will be serialized with\n   * \\c clang_saveTranslationUnit.\n   *\n   * This option is typically used when parsing a header with the intent of\n   * producing a precompiled header.\n   */\n  CXTranslationUnit_ForSerialization = 0x10,\n\n  /**\n   * DEPRECATED: Enabled chained precompiled preambles in C++.\n   *\n   * Note: this is a *temporary* option that is available only while\n   * we are testing C++ precompiled preamble support. It is deprecated.\n   */\n  CXTranslationUnit_CXXChainedPCH = 0x20,\n\n  /**\n   * Used to indicate that function/method bodies should be skipped while\n   * parsing.\n   *\n   * This option can be used to search for declarations/definitions while\n   * ignoring the usages.\n   */\n  CXTranslationUnit_SkipFunctionBodies = 0x40,\n\n  /**\n   * Used to indicate that brief documentation comments should be\n   * included into the set of code completions returned from this translation\n   * unit.\n   */\n  CXTranslationUnit_IncludeBriefCommentsInCodeCompletion = 0x80,\n\n  /**\n   * Used to indicate that the precompiled preamble should be created on\n   * the first parse. Otherwise it will be created on the first reparse. This\n   * trades runtime on the first parse (serializing the preamble takes time) for\n   * reduced runtime on the second parse (can now reuse the preamble).\n   */\n  CXTranslationUnit_CreatePreambleOnFirstParse = 0x100,\n\n  /**\n   * Do not stop processing when fatal errors are encountered.\n   *\n   * When fatal errors are encountered while parsing a translation unit,\n   * semantic analysis is typically stopped early when compiling code. A common\n   * source for fatal errors are unresolvable include files. For the\n   * purposes of an IDE, this is undesirable behavior and as much information\n   * as possible should be reported. Use this flag to enable this behavior.\n   */\n  CXTranslationUnit_KeepGoing = 0x200,\n\n  /**\n   * Sets the preprocessor in a mode for parsing a single file only.\n   */\n  CXTranslationUnit_SingleFileParse = 0x400,\n\n  /**\n   * Used in combination with CXTranslationUnit_SkipFunctionBodies to\n   * constrain the skipping of function bodies to the preamble.\n   *\n   * The function bodies of the main file are not skipped.\n   */\n  CXTranslationUnit_LimitSkipFunctionBodiesToPreamble = 0x800,\n\n  /**\n   * Used to indicate that attributed types should be included in CXType.\n   */\n  CXTranslationUnit_IncludeAttributedTypes = 0x1000,\n\n  /**\n   * Used to indicate that implicit attributes should be visited.\n   */\n  CXTranslationUnit_VisitImplicitAttributes = 0x2000,\n\n  /**\n   * Used to indicate that non-errors from included files should be ignored.\n   *\n   * If set, clang_getDiagnosticSetFromTU() will not report e.g. warnings from\n   * included files anymore. This speeds up clang_getDiagnosticSetFromTU() for\n   * the case where these warnings are not of interest, as for an IDE for\n   * example, which typically shows only the diagnostics in the main file.\n   */\n  CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles = 0x4000,\n\n  /**\n   * Tells the preprocessor not to skip excluded conditional blocks.\n   */\n  CXTranslationUnit_RetainExcludedConditionalBlocks = 0x8000\n};\n\n/**\n * Returns the set of flags that is suitable for parsing a translation\n * unit that is being edited.\n *\n * The set of flags returned provide options for \\c clang_parseTranslationUnit()\n * to indicate that the translation unit is likely to be reparsed many times,\n * either explicitly (via \\c clang_reparseTranslationUnit()) or implicitly\n * (e.g., by code completion (\\c clang_codeCompletionAt())). The returned flag\n * set contains an unspecified set of optimizations (e.g., the precompiled\n * preamble) geared toward improving the performance of these routines. The\n * set of optimizations enabled may change from one version to the next.\n */\nCINDEX_LINKAGE unsigned clang_defaultEditingTranslationUnitOptions(void);\n\n/**\n * Same as \\c clang_parseTranslationUnit2, but returns\n * the \\c CXTranslationUnit instead of an error code.  In case of an error this\n * routine returns a \\c NULL \\c CXTranslationUnit, without further detailed\n * error codes.\n */\nCINDEX_LINKAGE CXTranslationUnit clang_parseTranslationUnit(\n    CXIndex CIdx, const char *source_filename,\n    const char *const *command_line_args, int num_command_line_args,\n    struct CXUnsavedFile *unsaved_files, unsigned num_unsaved_files,\n    unsigned options);\n\n/**\n * Parse the given source file and the translation unit corresponding\n * to that file.\n *\n * This routine is the main entry point for the Clang C API, providing the\n * ability to parse a source file into a translation unit that can then be\n * queried by other functions in the API. This routine accepts a set of\n * command-line arguments so that the compilation can be configured in the same\n * way that the compiler is configured on the command line.\n *\n * \\param CIdx The index object with which the translation unit will be\n * associated.\n *\n * \\param source_filename The name of the source file to load, or NULL if the\n * source file is included in \\c command_line_args.\n *\n * \\param command_line_args The command-line arguments that would be\n * passed to the \\c clang executable if it were being invoked out-of-process.\n * These command-line options will be parsed and will affect how the translation\n * unit is parsed. Note that the following options are ignored: '-c',\n * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \\<output file>'.\n *\n * \\param num_command_line_args The number of command-line arguments in\n * \\c command_line_args.\n *\n * \\param unsaved_files the files that have not yet been saved to disk\n * but may be required for parsing, including the contents of\n * those files.  The contents and name of these files (as specified by\n * CXUnsavedFile) are copied when necessary, so the client only needs to\n * guarantee their validity until the call to this function returns.\n *\n * \\param num_unsaved_files the number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param options A bitmask of options that affects how the translation unit\n * is managed but not its compilation. This should be a bitwise OR of the\n * CXTranslationUnit_XXX flags.\n *\n * \\param[out] out_TU A non-NULL pointer to store the created\n * \\c CXTranslationUnit, describing the parsed code and containing any\n * diagnostics produced by the compiler.\n *\n * \\returns Zero on success, otherwise returns an error code.\n */\nCINDEX_LINKAGE enum CXErrorCode clang_parseTranslationUnit2(\n    CXIndex CIdx, const char *source_filename,\n    const char *const *command_line_args, int num_command_line_args,\n    struct CXUnsavedFile *unsaved_files, unsigned num_unsaved_files,\n    unsigned options, CXTranslationUnit *out_TU);\n\n/**\n * Same as clang_parseTranslationUnit2 but requires a full command line\n * for \\c command_line_args including argv[0]. This is useful if the standard\n * library paths are relative to the binary.\n */\nCINDEX_LINKAGE enum CXErrorCode clang_parseTranslationUnit2FullArgv(\n    CXIndex CIdx, const char *source_filename,\n    const char *const *command_line_args, int num_command_line_args,\n    struct CXUnsavedFile *unsaved_files, unsigned num_unsaved_files,\n    unsigned options, CXTranslationUnit *out_TU);\n\n/**\n * Flags that control how translation units are saved.\n *\n * The enumerators in this enumeration type are meant to be bitwise\n * ORed together to specify which options should be used when\n * saving the translation unit.\n */\nenum CXSaveTranslationUnit_Flags {\n  /**\n   * Used to indicate that no special saving options are needed.\n   */\n  CXSaveTranslationUnit_None = 0x0\n};\n\n/**\n * Returns the set of flags that is suitable for saving a translation\n * unit.\n *\n * The set of flags returned provide options for\n * \\c clang_saveTranslationUnit() by default. The returned flag\n * set contains an unspecified set of options that save translation units with\n * the most commonly-requested data.\n */\nCINDEX_LINKAGE unsigned clang_defaultSaveOptions(CXTranslationUnit TU);\n\n/**\n * Describes the kind of error that occurred (if any) in a call to\n * \\c clang_saveTranslationUnit().\n */\nenum CXSaveError {\n  /**\n   * Indicates that no error occurred while saving a translation unit.\n   */\n  CXSaveError_None = 0,\n\n  /**\n   * Indicates that an unknown error occurred while attempting to save\n   * the file.\n   *\n   * This error typically indicates that file I/O failed when attempting to\n   * write the file.\n   */\n  CXSaveError_Unknown = 1,\n\n  /**\n   * Indicates that errors during translation prevented this attempt\n   * to save the translation unit.\n   *\n   * Errors that prevent the translation unit from being saved can be\n   * extracted using \\c clang_getNumDiagnostics() and \\c clang_getDiagnostic().\n   */\n  CXSaveError_TranslationErrors = 2,\n\n  /**\n   * Indicates that the translation unit to be saved was somehow\n   * invalid (e.g., NULL).\n   */\n  CXSaveError_InvalidTU = 3\n};\n\n/**\n * Saves a translation unit into a serialized representation of\n * that translation unit on disk.\n *\n * Any translation unit that was parsed without error can be saved\n * into a file. The translation unit can then be deserialized into a\n * new \\c CXTranslationUnit with \\c clang_createTranslationUnit() or,\n * if it is an incomplete translation unit that corresponds to a\n * header, used as a precompiled header when parsing other translation\n * units.\n *\n * \\param TU The translation unit to save.\n *\n * \\param FileName The file to which the translation unit will be saved.\n *\n * \\param options A bitmask of options that affects how the translation unit\n * is saved. This should be a bitwise OR of the\n * CXSaveTranslationUnit_XXX flags.\n *\n * \\returns A value that will match one of the enumerators of the CXSaveError\n * enumeration. Zero (CXSaveError_None) indicates that the translation unit was\n * saved successfully, while a non-zero value indicates that a problem occurred.\n */\nCINDEX_LINKAGE int clang_saveTranslationUnit(CXTranslationUnit TU,\n                                             const char *FileName,\n                                             unsigned options);\n\n/**\n * Suspend a translation unit in order to free memory associated with it.\n *\n * A suspended translation unit uses significantly less memory but on the other\n * side does not support any other calls than \\c clang_reparseTranslationUnit\n * to resume it or \\c clang_disposeTranslationUnit to dispose it completely.\n */\nCINDEX_LINKAGE unsigned clang_suspendTranslationUnit(CXTranslationUnit);\n\n/**\n * Destroy the specified CXTranslationUnit object.\n */\nCINDEX_LINKAGE void clang_disposeTranslationUnit(CXTranslationUnit);\n\n/**\n * Flags that control the reparsing of translation units.\n *\n * The enumerators in this enumeration type are meant to be bitwise\n * ORed together to specify which options should be used when\n * reparsing the translation unit.\n */\nenum CXReparse_Flags {\n  /**\n   * Used to indicate that no special reparsing options are needed.\n   */\n  CXReparse_None = 0x0\n};\n\n/**\n * Returns the set of flags that is suitable for reparsing a translation\n * unit.\n *\n * The set of flags returned provide options for\n * \\c clang_reparseTranslationUnit() by default. The returned flag\n * set contains an unspecified set of optimizations geared toward common uses\n * of reparsing. The set of optimizations enabled may change from one version\n * to the next.\n */\nCINDEX_LINKAGE unsigned clang_defaultReparseOptions(CXTranslationUnit TU);\n\n/**\n * Reparse the source files that produced this translation unit.\n *\n * This routine can be used to re-parse the source files that originally\n * created the given translation unit, for example because those source files\n * have changed (either on disk or as passed via \\p unsaved_files). The\n * source code will be reparsed with the same command-line options as it\n * was originally parsed.\n *\n * Reparsing a translation unit invalidates all cursors and source locations\n * that refer into that translation unit. This makes reparsing a translation\n * unit semantically equivalent to destroying the translation unit and then\n * creating a new translation unit with the same command-line arguments.\n * However, it may be more efficient to reparse a translation\n * unit using this routine.\n *\n * \\param TU The translation unit whose contents will be re-parsed. The\n * translation unit must originally have been built with\n * \\c clang_createTranslationUnitFromSourceFile().\n *\n * \\param num_unsaved_files The number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param unsaved_files The files that have not yet been saved to disk\n * but may be required for parsing, including the contents of\n * those files.  The contents and name of these files (as specified by\n * CXUnsavedFile) are copied when necessary, so the client only needs to\n * guarantee their validity until the call to this function returns.\n *\n * \\param options A bitset of options composed of the flags in CXReparse_Flags.\n * The function \\c clang_defaultReparseOptions() produces a default set of\n * options recommended for most uses, based on the translation unit.\n *\n * \\returns 0 if the sources could be reparsed.  A non-zero error code will be\n * returned if reparsing was impossible, such that the translation unit is\n * invalid. In such cases, the only valid call for \\c TU is\n * \\c clang_disposeTranslationUnit(TU).  The error codes returned by this\n * routine are described by the \\c CXErrorCode enum.\n */\nCINDEX_LINKAGE int\nclang_reparseTranslationUnit(CXTranslationUnit TU, unsigned num_unsaved_files,\n                             struct CXUnsavedFile *unsaved_files,\n                             unsigned options);\n\n/**\n * Categorizes how memory is being used by a translation unit.\n */\nenum CXTUResourceUsageKind {\n  CXTUResourceUsage_AST = 1,\n  CXTUResourceUsage_Identifiers = 2,\n  CXTUResourceUsage_Selectors = 3,\n  CXTUResourceUsage_GlobalCompletionResults = 4,\n  CXTUResourceUsage_SourceManagerContentCache = 5,\n  CXTUResourceUsage_AST_SideTables = 6,\n  CXTUResourceUsage_SourceManager_Membuffer_Malloc = 7,\n  CXTUResourceUsage_SourceManager_Membuffer_MMap = 8,\n  CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc = 9,\n  CXTUResourceUsage_ExternalASTSource_Membuffer_MMap = 10,\n  CXTUResourceUsage_Preprocessor = 11,\n  CXTUResourceUsage_PreprocessingRecord = 12,\n  CXTUResourceUsage_SourceManager_DataStructures = 13,\n  CXTUResourceUsage_Preprocessor_HeaderSearch = 14,\n  CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN = CXTUResourceUsage_AST,\n  CXTUResourceUsage_MEMORY_IN_BYTES_END =\n      CXTUResourceUsage_Preprocessor_HeaderSearch,\n\n  CXTUResourceUsage_First = CXTUResourceUsage_AST,\n  CXTUResourceUsage_Last = CXTUResourceUsage_Preprocessor_HeaderSearch\n};\n\n/**\n * Returns the human-readable null-terminated C string that represents\n *  the name of the memory category.  This string should never be freed.\n */\nCINDEX_LINKAGE\nconst char *clang_getTUResourceUsageName(enum CXTUResourceUsageKind kind);\n\ntypedef struct CXTUResourceUsageEntry {\n  /* The memory usage category. */\n  enum CXTUResourceUsageKind kind;\n  /* Amount of resources used.\n      The units will depend on the resource kind. */\n  unsigned long amount;\n} CXTUResourceUsageEntry;\n\n/**\n * The memory usage of a CXTranslationUnit, broken into categories.\n */\ntypedef struct CXTUResourceUsage {\n  /* Private data member, used for queries. */\n  void *data;\n\n  /* The number of entries in the 'entries' array. */\n  unsigned numEntries;\n\n  /* An array of key-value pairs, representing the breakdown of memory\n            usage. */\n  CXTUResourceUsageEntry *entries;\n\n} CXTUResourceUsage;\n\n/**\n * Return the memory usage of a translation unit.  This object\n *  should be released with clang_disposeCXTUResourceUsage().\n */\nCINDEX_LINKAGE CXTUResourceUsage\nclang_getCXTUResourceUsage(CXTranslationUnit TU);\n\nCINDEX_LINKAGE void clang_disposeCXTUResourceUsage(CXTUResourceUsage usage);\n\n/**\n * Get target information for this translation unit.\n *\n * The CXTargetInfo object cannot outlive the CXTranslationUnit object.\n */\nCINDEX_LINKAGE CXTargetInfo\nclang_getTranslationUnitTargetInfo(CXTranslationUnit CTUnit);\n\n/**\n * Destroy the CXTargetInfo object.\n */\nCINDEX_LINKAGE void clang_TargetInfo_dispose(CXTargetInfo Info);\n\n/**\n * Get the normalized target triple as a string.\n *\n * Returns the empty string in case of any error.\n */\nCINDEX_LINKAGE CXString clang_TargetInfo_getTriple(CXTargetInfo Info);\n\n/**\n * Get the pointer width of the target in bits.\n *\n * Returns -1 in case of error.\n */\nCINDEX_LINKAGE int clang_TargetInfo_getPointerWidth(CXTargetInfo Info);\n\n/**\n * @}\n */\n\n/**\n * Describes the kind of entity that a cursor refers to.\n */\nenum CXCursorKind {\n  /* Declarations */\n  /**\n   * A declaration whose specific kind is not exposed via this\n   * interface.\n   *\n   * Unexposed declarations have the same operations as any other kind\n   * of declaration; one can extract their location information,\n   * spelling, find their definitions, etc. However, the specific kind\n   * of the declaration is not reported.\n   */\n  CXCursor_UnexposedDecl = 1,\n  /** A C or C++ struct. */\n  CXCursor_StructDecl = 2,\n  /** A C or C++ union. */\n  CXCursor_UnionDecl = 3,\n  /** A C++ class. */\n  CXCursor_ClassDecl = 4,\n  /** An enumeration. */\n  CXCursor_EnumDecl = 5,\n  /**\n   * A field (in C) or non-static data member (in C++) in a\n   * struct, union, or C++ class.\n   */\n  CXCursor_FieldDecl = 6,\n  /** An enumerator constant. */\n  CXCursor_EnumConstantDecl = 7,\n  /** A function. */\n  CXCursor_FunctionDecl = 8,\n  /** A variable. */\n  CXCursor_VarDecl = 9,\n  /** A function or method parameter. */\n  CXCursor_ParmDecl = 10,\n  /** An Objective-C \\@interface. */\n  CXCursor_ObjCInterfaceDecl = 11,\n  /** An Objective-C \\@interface for a category. */\n  CXCursor_ObjCCategoryDecl = 12,\n  /** An Objective-C \\@protocol declaration. */\n  CXCursor_ObjCProtocolDecl = 13,\n  /** An Objective-C \\@property declaration. */\n  CXCursor_ObjCPropertyDecl = 14,\n  /** An Objective-C instance variable. */\n  CXCursor_ObjCIvarDecl = 15,\n  /** An Objective-C instance method. */\n  CXCursor_ObjCInstanceMethodDecl = 16,\n  /** An Objective-C class method. */\n  CXCursor_ObjCClassMethodDecl = 17,\n  /** An Objective-C \\@implementation. */\n  CXCursor_ObjCImplementationDecl = 18,\n  /** An Objective-C \\@implementation for a category. */\n  CXCursor_ObjCCategoryImplDecl = 19,\n  /** A typedef. */\n  CXCursor_TypedefDecl = 20,\n  /** A C++ class method. */\n  CXCursor_CXXMethod = 21,\n  /** A C++ namespace. */\n  CXCursor_Namespace = 22,\n  /** A linkage specification, e.g. 'extern \"C\"'. */\n  CXCursor_LinkageSpec = 23,\n  /** A C++ constructor. */\n  CXCursor_Constructor = 24,\n  /** A C++ destructor. */\n  CXCursor_Destructor = 25,\n  /** A C++ conversion function. */\n  CXCursor_ConversionFunction = 26,\n  /** A C++ template type parameter. */\n  CXCursor_TemplateTypeParameter = 27,\n  /** A C++ non-type template parameter. */\n  CXCursor_NonTypeTemplateParameter = 28,\n  /** A C++ template template parameter. */\n  CXCursor_TemplateTemplateParameter = 29,\n  /** A C++ function template. */\n  CXCursor_FunctionTemplate = 30,\n  /** A C++ class template. */\n  CXCursor_ClassTemplate = 31,\n  /** A C++ class template partial specialization. */\n  CXCursor_ClassTemplatePartialSpecialization = 32,\n  /** A C++ namespace alias declaration. */\n  CXCursor_NamespaceAlias = 33,\n  /** A C++ using directive. */\n  CXCursor_UsingDirective = 34,\n  /** A C++ using declaration. */\n  CXCursor_UsingDeclaration = 35,\n  /** A C++ alias declaration */\n  CXCursor_TypeAliasDecl = 36,\n  /** An Objective-C \\@synthesize definition. */\n  CXCursor_ObjCSynthesizeDecl = 37,\n  /** An Objective-C \\@dynamic definition. */\n  CXCursor_ObjCDynamicDecl = 38,\n  /** An access specifier. */\n  CXCursor_CXXAccessSpecifier = 39,\n\n  CXCursor_FirstDecl = CXCursor_UnexposedDecl,\n  CXCursor_LastDecl = CXCursor_CXXAccessSpecifier,\n\n  /* References */\n  CXCursor_FirstRef = 40, /* Decl references */\n  CXCursor_ObjCSuperClassRef = 40,\n  CXCursor_ObjCProtocolRef = 41,\n  CXCursor_ObjCClassRef = 42,\n  /**\n   * A reference to a type declaration.\n   *\n   * A type reference occurs anywhere where a type is named but not\n   * declared. For example, given:\n   *\n   * \\code\n   * typedef unsigned size_type;\n   * size_type size;\n   * \\endcode\n   *\n   * The typedef is a declaration of size_type (CXCursor_TypedefDecl),\n   * while the type of the variable \"size\" is referenced. The cursor\n   * referenced by the type of size is the typedef for size_type.\n   */\n  CXCursor_TypeRef = 43,\n  CXCursor_CXXBaseSpecifier = 44,\n  /**\n   * A reference to a class template, function template, template\n   * template parameter, or class template partial specialization.\n   */\n  CXCursor_TemplateRef = 45,\n  /**\n   * A reference to a namespace or namespace alias.\n   */\n  CXCursor_NamespaceRef = 46,\n  /**\n   * A reference to a member of a struct, union, or class that occurs in\n   * some non-expression context, e.g., a designated initializer.\n   */\n  CXCursor_MemberRef = 47,\n  /**\n   * A reference to a labeled statement.\n   *\n   * This cursor kind is used to describe the jump to \"start_over\" in the\n   * goto statement in the following example:\n   *\n   * \\code\n   *   start_over:\n   *     ++counter;\n   *\n   *     goto start_over;\n   * \\endcode\n   *\n   * A label reference cursor refers to a label statement.\n   */\n  CXCursor_LabelRef = 48,\n\n  /**\n   * A reference to a set of overloaded functions or function templates\n   * that has not yet been resolved to a specific function or function template.\n   *\n   * An overloaded declaration reference cursor occurs in C++ templates where\n   * a dependent name refers to a function. For example:\n   *\n   * \\code\n   * template<typename T> void swap(T&, T&);\n   *\n   * struct X { ... };\n   * void swap(X&, X&);\n   *\n   * template<typename T>\n   * void reverse(T* first, T* last) {\n   *   while (first < last - 1) {\n   *     swap(*first, *--last);\n   *     ++first;\n   *   }\n   * }\n   *\n   * struct Y { };\n   * void swap(Y&, Y&);\n   * \\endcode\n   *\n   * Here, the identifier \"swap\" is associated with an overloaded declaration\n   * reference. In the template definition, \"swap\" refers to either of the two\n   * \"swap\" functions declared above, so both results will be available. At\n   * instantiation time, \"swap\" may also refer to other functions found via\n   * argument-dependent lookup (e.g., the \"swap\" function at the end of the\n   * example).\n   *\n   * The functions \\c clang_getNumOverloadedDecls() and\n   * \\c clang_getOverloadedDecl() can be used to retrieve the definitions\n   * referenced by this cursor.\n   */\n  CXCursor_OverloadedDeclRef = 49,\n\n  /**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */\n  CXCursor_VariableRef = 50,\n\n  CXCursor_LastRef = CXCursor_VariableRef,\n\n  /* Error conditions */\n  CXCursor_FirstInvalid = 70,\n  CXCursor_InvalidFile = 70,\n  CXCursor_NoDeclFound = 71,\n  CXCursor_NotImplemented = 72,\n  CXCursor_InvalidCode = 73,\n  CXCursor_LastInvalid = CXCursor_InvalidCode,\n\n  /* Expressions */\n  CXCursor_FirstExpr = 100,\n\n  /**\n   * An expression whose specific kind is not exposed via this\n   * interface.\n   *\n   * Unexposed expressions have the same operations as any other kind\n   * of expression; one can extract their location information,\n   * spelling, children, etc. However, the specific kind of the\n   * expression is not reported.\n   */\n  CXCursor_UnexposedExpr = 100,\n\n  /**\n   * An expression that refers to some value declaration, such\n   * as a function, variable, or enumerator.\n   */\n  CXCursor_DeclRefExpr = 101,\n\n  /**\n   * An expression that refers to a member of a struct, union,\n   * class, Objective-C class, etc.\n   */\n  CXCursor_MemberRefExpr = 102,\n\n  /** An expression that calls a function. */\n  CXCursor_CallExpr = 103,\n\n  /** An expression that sends a message to an Objective-C\n   object or class. */\n  CXCursor_ObjCMessageExpr = 104,\n\n  /** An expression that represents a block literal. */\n  CXCursor_BlockExpr = 105,\n\n  /** An integer literal.\n   */\n  CXCursor_IntegerLiteral = 106,\n\n  /** A floating point number literal.\n   */\n  CXCursor_FloatingLiteral = 107,\n\n  /** An imaginary number literal.\n   */\n  CXCursor_ImaginaryLiteral = 108,\n\n  /** A string literal.\n   */\n  CXCursor_StringLiteral = 109,\n\n  /** A character literal.\n   */\n  CXCursor_CharacterLiteral = 110,\n\n  /** A parenthesized expression, e.g. \"(1)\".\n   *\n   * This AST node is only formed if full location information is requested.\n   */\n  CXCursor_ParenExpr = 111,\n\n  /** This represents the unary-expression's (except sizeof and\n   * alignof).\n   */\n  CXCursor_UnaryOperator = 112,\n\n  /** [C99 6.5.2.1] Array Subscripting.\n   */\n  CXCursor_ArraySubscriptExpr = 113,\n\n  /** A builtin binary operation expression such as \"x + y\" or\n   * \"x <= y\".\n   */\n  CXCursor_BinaryOperator = 114,\n\n  /** Compound assignment such as \"+=\".\n   */\n  CXCursor_CompoundAssignOperator = 115,\n\n  /** The ?: ternary operator.\n   */\n  CXCursor_ConditionalOperator = 116,\n\n  /** An explicit cast in C (C99 6.5.4) or a C-style cast in C++\n   * (C++ [expr.cast]), which uses the syntax (Type)expr.\n   *\n   * For example: (int)f.\n   */\n  CXCursor_CStyleCastExpr = 117,\n\n  /** [C99 6.5.2.5]\n   */\n  CXCursor_CompoundLiteralExpr = 118,\n\n  /** Describes an C or C++ initializer list.\n   */\n  CXCursor_InitListExpr = 119,\n\n  /** The GNU address of label extension, representing &&label.\n   */\n  CXCursor_AddrLabelExpr = 120,\n\n  /** This is the GNU Statement Expression extension: ({int X=4; X;})\n   */\n  CXCursor_StmtExpr = 121,\n\n  /** Represents a C11 generic selection.\n   */\n  CXCursor_GenericSelectionExpr = 122,\n\n  /** Implements the GNU __null extension, which is a name for a null\n   * pointer constant that has integral type (e.g., int or long) and is the same\n   * size and alignment as a pointer.\n   *\n   * The __null extension is typically only used by system headers, which define\n   * NULL as __null in C++ rather than using 0 (which is an integer that may not\n   * match the size of a pointer).\n   */\n  CXCursor_GNUNullExpr = 123,\n\n  /** C++'s static_cast<> expression.\n   */\n  CXCursor_CXXStaticCastExpr = 124,\n\n  /** C++'s dynamic_cast<> expression.\n   */\n  CXCursor_CXXDynamicCastExpr = 125,\n\n  /** C++'s reinterpret_cast<> expression.\n   */\n  CXCursor_CXXReinterpretCastExpr = 126,\n\n  /** C++'s const_cast<> expression.\n   */\n  CXCursor_CXXConstCastExpr = 127,\n\n  /** Represents an explicit C++ type conversion that uses \"functional\"\n   * notion (C++ [expr.type.conv]).\n   *\n   * Example:\n   * \\code\n   *   x = int(0.5);\n   * \\endcode\n   */\n  CXCursor_CXXFunctionalCastExpr = 128,\n\n  /** A C++ typeid expression (C++ [expr.typeid]).\n   */\n  CXCursor_CXXTypeidExpr = 129,\n\n  /** [C++ 2.13.5] C++ Boolean Literal.\n   */\n  CXCursor_CXXBoolLiteralExpr = 130,\n\n  /** [C++0x 2.14.7] C++ Pointer Literal.\n   */\n  CXCursor_CXXNullPtrLiteralExpr = 131,\n\n  /** Represents the \"this\" expression in C++\n   */\n  CXCursor_CXXThisExpr = 132,\n\n  /** [C++ 15] C++ Throw Expression.\n   *\n   * This handles 'throw' and 'throw' assignment-expression. When\n   * assignment-expression isn't present, Op will be null.\n   */\n  CXCursor_CXXThrowExpr = 133,\n\n  /** A new expression for memory allocation and constructor calls, e.g:\n   * \"new CXXNewExpr(foo)\".\n   */\n  CXCursor_CXXNewExpr = 134,\n\n  /** A delete expression for memory deallocation and destructor calls,\n   * e.g. \"delete[] pArray\".\n   */\n  CXCursor_CXXDeleteExpr = 135,\n\n  /** A unary expression. (noexcept, sizeof, or other traits)\n   */\n  CXCursor_UnaryExpr = 136,\n\n  /** An Objective-C string literal i.e. @\"foo\".\n   */\n  CXCursor_ObjCStringLiteral = 137,\n\n  /** An Objective-C \\@encode expression.\n   */\n  CXCursor_ObjCEncodeExpr = 138,\n\n  /** An Objective-C \\@selector expression.\n   */\n  CXCursor_ObjCSelectorExpr = 139,\n\n  /** An Objective-C \\@protocol expression.\n   */\n  CXCursor_ObjCProtocolExpr = 140,\n\n  /** An Objective-C \"bridged\" cast expression, which casts between\n   * Objective-C pointers and C pointers, transferring ownership in the process.\n   *\n   * \\code\n   *   NSString *str = (__bridge_transfer NSString *)CFCreateString();\n   * \\endcode\n   */\n  CXCursor_ObjCBridgedCastExpr = 141,\n\n  /** Represents a C++0x pack expansion that produces a sequence of\n   * expressions.\n   *\n   * A pack expansion expression contains a pattern (which itself is an\n   * expression) followed by an ellipsis. For example:\n   *\n   * \\code\n   * template<typename F, typename ...Types>\n   * void forward(F f, Types &&...args) {\n   *  f(static_cast<Types&&>(args)...);\n   * }\n   * \\endcode\n   */\n  CXCursor_PackExpansionExpr = 142,\n\n  /** Represents an expression that computes the length of a parameter\n   * pack.\n   *\n   * \\code\n   * template<typename ...Types>\n   * struct count {\n   *   static const unsigned value = sizeof...(Types);\n   * };\n   * \\endcode\n   */\n  CXCursor_SizeOfPackExpr = 143,\n\n  /* Represents a C++ lambda expression that produces a local function\n   * object.\n   *\n   * \\code\n   * void abssort(float *x, unsigned N) {\n   *   std::sort(x, x + N,\n   *             [](float a, float b) {\n   *               return std::abs(a) < std::abs(b);\n   *             });\n   * }\n   * \\endcode\n   */\n  CXCursor_LambdaExpr = 144,\n\n  /** Objective-c Boolean Literal.\n   */\n  CXCursor_ObjCBoolLiteralExpr = 145,\n\n  /** Represents the \"self\" expression in an Objective-C method.\n   */\n  CXCursor_ObjCSelfExpr = 146,\n\n  /** OpenMP 5.0 [2.1.5, Array Section].\n   */\n  CXCursor_OMPArraySectionExpr = 147,\n\n  /** Represents an @available(...) check.\n   */\n  CXCursor_ObjCAvailabilityCheckExpr = 148,\n\n  /**\n   * Fixed point literal\n   */\n  CXCursor_FixedPointLiteral = 149,\n\n  /** OpenMP 5.0 [2.1.4, Array Shaping].\n   */\n  CXCursor_OMPArrayShapingExpr = 150,\n\n  /**\n   * OpenMP 5.0 [2.1.6 Iterators]\n   */\n  CXCursor_OMPIteratorExpr = 151,\n\n  /** OpenCL's addrspace_cast<> expression.\n   */\n  CXCursor_CXXAddrspaceCastExpr = 152,\n\n  CXCursor_LastExpr = CXCursor_CXXAddrspaceCastExpr,\n\n  /* Statements */\n  CXCursor_FirstStmt = 200,\n  /**\n   * A statement whose specific kind is not exposed via this\n   * interface.\n   *\n   * Unexposed statements have the same operations as any other kind of\n   * statement; one can extract their location information, spelling,\n   * children, etc. However, the specific kind of the statement is not\n   * reported.\n   */\n  CXCursor_UnexposedStmt = 200,\n\n  /** A labelled statement in a function.\n   *\n   * This cursor kind is used to describe the \"start_over:\" label statement in\n   * the following example:\n   *\n   * \\code\n   *   start_over:\n   *     ++counter;\n   * \\endcode\n   *\n   */\n  CXCursor_LabelStmt = 201,\n\n  /** A group of statements like { stmt stmt }.\n   *\n   * This cursor kind is used to describe compound statements, e.g. function\n   * bodies.\n   */\n  CXCursor_CompoundStmt = 202,\n\n  /** A case statement.\n   */\n  CXCursor_CaseStmt = 203,\n\n  /** A default statement.\n   */\n  CXCursor_DefaultStmt = 204,\n\n  /** An if statement\n   */\n  CXCursor_IfStmt = 205,\n\n  /** A switch statement.\n   */\n  CXCursor_SwitchStmt = 206,\n\n  /** A while statement.\n   */\n  CXCursor_WhileStmt = 207,\n\n  /** A do statement.\n   */\n  CXCursor_DoStmt = 208,\n\n  /** A for statement.\n   */\n  CXCursor_ForStmt = 209,\n\n  /** A goto statement.\n   */\n  CXCursor_GotoStmt = 210,\n\n  /** An indirect goto statement.\n   */\n  CXCursor_IndirectGotoStmt = 211,\n\n  /** A continue statement.\n   */\n  CXCursor_ContinueStmt = 212,\n\n  /** A break statement.\n   */\n  CXCursor_BreakStmt = 213,\n\n  /** A return statement.\n   */\n  CXCursor_ReturnStmt = 214,\n\n  /** A GCC inline assembly statement extension.\n   */\n  CXCursor_GCCAsmStmt = 215,\n  CXCursor_AsmStmt = CXCursor_GCCAsmStmt,\n\n  /** Objective-C's overall \\@try-\\@catch-\\@finally statement.\n   */\n  CXCursor_ObjCAtTryStmt = 216,\n\n  /** Objective-C's \\@catch statement.\n   */\n  CXCursor_ObjCAtCatchStmt = 217,\n\n  /** Objective-C's \\@finally statement.\n   */\n  CXCursor_ObjCAtFinallyStmt = 218,\n\n  /** Objective-C's \\@throw statement.\n   */\n  CXCursor_ObjCAtThrowStmt = 219,\n\n  /** Objective-C's \\@synchronized statement.\n   */\n  CXCursor_ObjCAtSynchronizedStmt = 220,\n\n  /** Objective-C's autorelease pool statement.\n   */\n  CXCursor_ObjCAutoreleasePoolStmt = 221,\n\n  /** Objective-C's collection statement.\n   */\n  CXCursor_ObjCForCollectionStmt = 222,\n\n  /** C++'s catch statement.\n   */\n  CXCursor_CXXCatchStmt = 223,\n\n  /** C++'s try statement.\n   */\n  CXCursor_CXXTryStmt = 224,\n\n  /** C++'s for (* : *) statement.\n   */\n  CXCursor_CXXForRangeStmt = 225,\n\n  /** Windows Structured Exception Handling's try statement.\n   */\n  CXCursor_SEHTryStmt = 226,\n\n  /** Windows Structured Exception Handling's except statement.\n   */\n  CXCursor_SEHExceptStmt = 227,\n\n  /** Windows Structured Exception Handling's finally statement.\n   */\n  CXCursor_SEHFinallyStmt = 228,\n\n  /** A MS inline assembly statement extension.\n   */\n  CXCursor_MSAsmStmt = 229,\n\n  /** The null statement \";\": C99 6.8.3p3.\n   *\n   * This cursor kind is used to describe the null statement.\n   */\n  CXCursor_NullStmt = 230,\n\n  /** Adaptor class for mixing declarations with statements and\n   * expressions.\n   */\n  CXCursor_DeclStmt = 231,\n\n  /** OpenMP parallel directive.\n   */\n  CXCursor_OMPParallelDirective = 232,\n\n  /** OpenMP SIMD directive.\n   */\n  CXCursor_OMPSimdDirective = 233,\n\n  /** OpenMP for directive.\n   */\n  CXCursor_OMPForDirective = 234,\n\n  /** OpenMP sections directive.\n   */\n  CXCursor_OMPSectionsDirective = 235,\n\n  /** OpenMP section directive.\n   */\n  CXCursor_OMPSectionDirective = 236,\n\n  /** OpenMP single directive.\n   */\n  CXCursor_OMPSingleDirective = 237,\n\n  /** OpenMP parallel for directive.\n   */\n  CXCursor_OMPParallelForDirective = 238,\n\n  /** OpenMP parallel sections directive.\n   */\n  CXCursor_OMPParallelSectionsDirective = 239,\n\n  /** OpenMP task directive.\n   */\n  CXCursor_OMPTaskDirective = 240,\n\n  /** OpenMP master directive.\n   */\n  CXCursor_OMPMasterDirective = 241,\n\n  /** OpenMP critical directive.\n   */\n  CXCursor_OMPCriticalDirective = 242,\n\n  /** OpenMP taskyield directive.\n   */\n  CXCursor_OMPTaskyieldDirective = 243,\n\n  /** OpenMP barrier directive.\n   */\n  CXCursor_OMPBarrierDirective = 244,\n\n  /** OpenMP taskwait directive.\n   */\n  CXCursor_OMPTaskwaitDirective = 245,\n\n  /** OpenMP flush directive.\n   */\n  CXCursor_OMPFlushDirective = 246,\n\n  /** Windows Structured Exception Handling's leave statement.\n   */\n  CXCursor_SEHLeaveStmt = 247,\n\n  /** OpenMP ordered directive.\n   */\n  CXCursor_OMPOrderedDirective = 248,\n\n  /** OpenMP atomic directive.\n   */\n  CXCursor_OMPAtomicDirective = 249,\n\n  /** OpenMP for SIMD directive.\n   */\n  CXCursor_OMPForSimdDirective = 250,\n\n  /** OpenMP parallel for SIMD directive.\n   */\n  CXCursor_OMPParallelForSimdDirective = 251,\n\n  /** OpenMP target directive.\n   */\n  CXCursor_OMPTargetDirective = 252,\n\n  /** OpenMP teams directive.\n   */\n  CXCursor_OMPTeamsDirective = 253,\n\n  /** OpenMP taskgroup directive.\n   */\n  CXCursor_OMPTaskgroupDirective = 254,\n\n  /** OpenMP cancellation point directive.\n   */\n  CXCursor_OMPCancellationPointDirective = 255,\n\n  /** OpenMP cancel directive.\n   */\n  CXCursor_OMPCancelDirective = 256,\n\n  /** OpenMP target data directive.\n   */\n  CXCursor_OMPTargetDataDirective = 257,\n\n  /** OpenMP taskloop directive.\n   */\n  CXCursor_OMPTaskLoopDirective = 258,\n\n  /** OpenMP taskloop simd directive.\n   */\n  CXCursor_OMPTaskLoopSimdDirective = 259,\n\n  /** OpenMP distribute directive.\n   */\n  CXCursor_OMPDistributeDirective = 260,\n\n  /** OpenMP target enter data directive.\n   */\n  CXCursor_OMPTargetEnterDataDirective = 261,\n\n  /** OpenMP target exit data directive.\n   */\n  CXCursor_OMPTargetExitDataDirective = 262,\n\n  /** OpenMP target parallel directive.\n   */\n  CXCursor_OMPTargetParallelDirective = 263,\n\n  /** OpenMP target parallel for directive.\n   */\n  CXCursor_OMPTargetParallelForDirective = 264,\n\n  /** OpenMP target update directive.\n   */\n  CXCursor_OMPTargetUpdateDirective = 265,\n\n  /** OpenMP distribute parallel for directive.\n   */\n  CXCursor_OMPDistributeParallelForDirective = 266,\n\n  /** OpenMP distribute parallel for simd directive.\n   */\n  CXCursor_OMPDistributeParallelForSimdDirective = 267,\n\n  /** OpenMP distribute simd directive.\n   */\n  CXCursor_OMPDistributeSimdDirective = 268,\n\n  /** OpenMP target parallel for simd directive.\n   */\n  CXCursor_OMPTargetParallelForSimdDirective = 269,\n\n  /** OpenMP target simd directive.\n   */\n  CXCursor_OMPTargetSimdDirective = 270,\n\n  /** OpenMP teams distribute directive.\n   */\n  CXCursor_OMPTeamsDistributeDirective = 271,\n\n  /** OpenMP teams distribute simd directive.\n   */\n  CXCursor_OMPTeamsDistributeSimdDirective = 272,\n\n  /** OpenMP teams distribute parallel for simd directive.\n   */\n  CXCursor_OMPTeamsDistributeParallelForSimdDirective = 273,\n\n  /** OpenMP teams distribute parallel for directive.\n   */\n  CXCursor_OMPTeamsDistributeParallelForDirective = 274,\n\n  /** OpenMP target teams directive.\n   */\n  CXCursor_OMPTargetTeamsDirective = 275,\n\n  /** OpenMP target teams distribute directive.\n   */\n  CXCursor_OMPTargetTeamsDistributeDirective = 276,\n\n  /** OpenMP target teams distribute parallel for directive.\n   */\n  CXCursor_OMPTargetTeamsDistributeParallelForDirective = 277,\n\n  /** OpenMP target teams distribute parallel for simd directive.\n   */\n  CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective = 278,\n\n  /** OpenMP target teams distribute simd directive.\n   */\n  CXCursor_OMPTargetTeamsDistributeSimdDirective = 279,\n\n  /** C++2a std::bit_cast expression.\n   */\n  CXCursor_BuiltinBitCastExpr = 280,\n\n  /** OpenMP master taskloop directive.\n   */\n  CXCursor_OMPMasterTaskLoopDirective = 281,\n\n  /** OpenMP parallel master taskloop directive.\n   */\n  CXCursor_OMPParallelMasterTaskLoopDirective = 282,\n\n  /** OpenMP master taskloop simd directive.\n   */\n  CXCursor_OMPMasterTaskLoopSimdDirective = 283,\n\n  /** OpenMP parallel master taskloop simd directive.\n   */\n  CXCursor_OMPParallelMasterTaskLoopSimdDirective = 284,\n\n  /** OpenMP parallel master directive.\n   */\n  CXCursor_OMPParallelMasterDirective = 285,\n\n  /** OpenMP depobj directive.\n   */\n  CXCursor_OMPDepobjDirective = 286,\n\n  /** OpenMP scan directive.\n   */\n  CXCursor_OMPScanDirective = 287,\n\n  /** OpenMP tile directive.\n   */\n  CXCursor_OMPTileDirective = 288,\n\n  /** OpenMP canonical loop.\n   */\n  CXCursor_OMPCanonicalLoop = 289,\n\n  CXCursor_LastStmt = CXCursor_OMPCanonicalLoop,\n\n  /**\n   * Cursor that represents the translation unit itself.\n   *\n   * The translation unit cursor exists primarily to act as the root\n   * cursor for traversing the contents of a translation unit.\n   */\n  CXCursor_TranslationUnit = 300,\n\n  /* Attributes */\n  CXCursor_FirstAttr = 400,\n  /**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */\n  CXCursor_UnexposedAttr = 400,\n\n  CXCursor_IBActionAttr = 401,\n  CXCursor_IBOutletAttr = 402,\n  CXCursor_IBOutletCollectionAttr = 403,\n  CXCursor_CXXFinalAttr = 404,\n  CXCursor_CXXOverrideAttr = 405,\n  CXCursor_AnnotateAttr = 406,\n  CXCursor_AsmLabelAttr = 407,\n  CXCursor_PackedAttr = 408,\n  CXCursor_PureAttr = 409,\n  CXCursor_ConstAttr = 410,\n  CXCursor_NoDuplicateAttr = 411,\n  CXCursor_CUDAConstantAttr = 412,\n  CXCursor_CUDADeviceAttr = 413,\n  CXCursor_CUDAGlobalAttr = 414,\n  CXCursor_CUDAHostAttr = 415,\n  CXCursor_CUDASharedAttr = 416,\n  CXCursor_VisibilityAttr = 417,\n  CXCursor_DLLExport = 418,\n  CXCursor_DLLImport = 419,\n  CXCursor_NSReturnsRetained = 420,\n  CXCursor_NSReturnsNotRetained = 421,\n  CXCursor_NSReturnsAutoreleased = 422,\n  CXCursor_NSConsumesSelf = 423,\n  CXCursor_NSConsumed = 424,\n  CXCursor_ObjCException = 425,\n  CXCursor_ObjCNSObject = 426,\n  CXCursor_ObjCIndependentClass = 427,\n  CXCursor_ObjCPreciseLifetime = 428,\n  CXCursor_ObjCReturnsInnerPointer = 429,\n  CXCursor_ObjCRequiresSuper = 430,\n  CXCursor_ObjCRootClass = 431,\n  CXCursor_ObjCSubclassingRestricted = 432,\n  CXCursor_ObjCExplicitProtocolImpl = 433,\n  CXCursor_ObjCDesignatedInitializer = 434,\n  CXCursor_ObjCRuntimeVisible = 435,\n  CXCursor_ObjCBoxable = 436,\n  CXCursor_FlagEnum = 437,\n  CXCursor_ConvergentAttr = 438,\n  CXCursor_WarnUnusedAttr = 439,\n  CXCursor_WarnUnusedResultAttr = 440,\n  CXCursor_AlignedAttr = 441,\n  CXCursor_LastAttr = CXCursor_AlignedAttr,\n\n  /* Preprocessing */\n  CXCursor_PreprocessingDirective = 500,\n  CXCursor_MacroDefinition = 501,\n  CXCursor_MacroExpansion = 502,\n  CXCursor_MacroInstantiation = CXCursor_MacroExpansion,\n  CXCursor_InclusionDirective = 503,\n  CXCursor_FirstPreprocessing = CXCursor_PreprocessingDirective,\n  CXCursor_LastPreprocessing = CXCursor_InclusionDirective,\n\n  /* Extra Declarations */\n  /**\n   * A module import declaration.\n   */\n  CXCursor_ModuleImportDecl = 600,\n  CXCursor_TypeAliasTemplateDecl = 601,\n  /**\n   * A static_assert or _Static_assert node\n   */\n  CXCursor_StaticAssert = 602,\n  /**\n   * a friend declaration.\n   */\n  CXCursor_FriendDecl = 603,\n  CXCursor_FirstExtraDecl = CXCursor_ModuleImportDecl,\n  CXCursor_LastExtraDecl = CXCursor_FriendDecl,\n\n  /**\n   * A code completion overload candidate.\n   */\n  CXCursor_OverloadCandidate = 700\n};\n\n/**\n * A cursor representing some element in the abstract syntax tree for\n * a translation unit.\n *\n * The cursor abstraction unifies the different kinds of entities in a\n * program--declaration, statements, expressions, references to declarations,\n * etc.--under a single \"cursor\" abstraction with a common set of operations.\n * Common operation for a cursor include: getting the physical location in\n * a source file where the cursor points, getting the name associated with a\n * cursor, and retrieving cursors for any child nodes of a particular cursor.\n *\n * Cursors can be produced in two specific ways.\n * clang_getTranslationUnitCursor() produces a cursor for a translation unit,\n * from which one can use clang_visitChildren() to explore the rest of the\n * translation unit. clang_getCursor() maps from a physical source location\n * to the entity that resides at that location, allowing one to map from the\n * source code into the AST.\n */\ntypedef struct {\n  enum CXCursorKind kind;\n  int xdata;\n  const void *data[3];\n} CXCursor;\n\n/**\n * \\defgroup CINDEX_CURSOR_MANIP Cursor manipulations\n *\n * @{\n */\n\n/**\n * Retrieve the NULL cursor, which represents no entity.\n */\nCINDEX_LINKAGE CXCursor clang_getNullCursor(void);\n\n/**\n * Retrieve the cursor that represents the given translation unit.\n *\n * The translation unit cursor can be used to start traversing the\n * various declarations within the given translation unit.\n */\nCINDEX_LINKAGE CXCursor clang_getTranslationUnitCursor(CXTranslationUnit);\n\n/**\n * Determine whether two cursors are equivalent.\n */\nCINDEX_LINKAGE unsigned clang_equalCursors(CXCursor, CXCursor);\n\n/**\n * Returns non-zero if \\p cursor is null.\n */\nCINDEX_LINKAGE int clang_Cursor_isNull(CXCursor cursor);\n\n/**\n * Compute a hash value for the given cursor.\n */\nCINDEX_LINKAGE unsigned clang_hashCursor(CXCursor);\n\n/**\n * Retrieve the kind of the given cursor.\n */\nCINDEX_LINKAGE enum CXCursorKind clang_getCursorKind(CXCursor);\n\n/**\n * Determine whether the given cursor kind represents a declaration.\n */\nCINDEX_LINKAGE unsigned clang_isDeclaration(enum CXCursorKind);\n\n/**\n * Determine whether the given declaration is invalid.\n *\n * A declaration is invalid if it could not be parsed successfully.\n *\n * \\returns non-zero if the cursor represents a declaration and it is\n * invalid, otherwise NULL.\n */\nCINDEX_LINKAGE unsigned clang_isInvalidDeclaration(CXCursor);\n\n/**\n * Determine whether the given cursor kind represents a simple\n * reference.\n *\n * Note that other kinds of cursors (such as expressions) can also refer to\n * other cursors. Use clang_getCursorReferenced() to determine whether a\n * particular cursor refers to another entity.\n */\nCINDEX_LINKAGE unsigned clang_isReference(enum CXCursorKind);\n\n/**\n * Determine whether the given cursor kind represents an expression.\n */\nCINDEX_LINKAGE unsigned clang_isExpression(enum CXCursorKind);\n\n/**\n * Determine whether the given cursor kind represents a statement.\n */\nCINDEX_LINKAGE unsigned clang_isStatement(enum CXCursorKind);\n\n/**\n * Determine whether the given cursor kind represents an attribute.\n */\nCINDEX_LINKAGE unsigned clang_isAttribute(enum CXCursorKind);\n\n/**\n * Determine whether the given cursor has any attributes.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_hasAttrs(CXCursor C);\n\n/**\n * Determine whether the given cursor kind represents an invalid\n * cursor.\n */\nCINDEX_LINKAGE unsigned clang_isInvalid(enum CXCursorKind);\n\n/**\n * Determine whether the given cursor kind represents a translation\n * unit.\n */\nCINDEX_LINKAGE unsigned clang_isTranslationUnit(enum CXCursorKind);\n\n/***\n * Determine whether the given cursor represents a preprocessing\n * element, such as a preprocessor directive or macro instantiation.\n */\nCINDEX_LINKAGE unsigned clang_isPreprocessing(enum CXCursorKind);\n\n/***\n * Determine whether the given cursor represents a currently\n *  unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).\n */\nCINDEX_LINKAGE unsigned clang_isUnexposed(enum CXCursorKind);\n\n/**\n * Describe the linkage of the entity referred to by a cursor.\n */\nenum CXLinkageKind {\n  /** This value indicates that no linkage information is available\n   * for a provided CXCursor. */\n  CXLinkage_Invalid,\n  /**\n   * This is the linkage for variables, parameters, and so on that\n   *  have automatic storage.  This covers normal (non-extern) local variables.\n   */\n  CXLinkage_NoLinkage,\n  /** This is the linkage for static variables and static functions. */\n  CXLinkage_Internal,\n  /** This is the linkage for entities with external linkage that live\n   * in C++ anonymous namespaces.*/\n  CXLinkage_UniqueExternal,\n  /** This is the linkage for entities with true, external linkage. */\n  CXLinkage_External\n};\n\n/**\n * Determine the linkage of the entity referred to by a given cursor.\n */\nCINDEX_LINKAGE enum CXLinkageKind clang_getCursorLinkage(CXCursor cursor);\n\nenum CXVisibilityKind {\n  /** This value indicates that no visibility information is available\n   * for a provided CXCursor. */\n  CXVisibility_Invalid,\n\n  /** Symbol not seen by the linker. */\n  CXVisibility_Hidden,\n  /** Symbol seen by the linker but resolves to a symbol inside this object. */\n  CXVisibility_Protected,\n  /** Symbol seen by the linker and acts like a normal symbol. */\n  CXVisibility_Default\n};\n\n/**\n * Describe the visibility of the entity referred to by a cursor.\n *\n * This returns the default visibility if not explicitly specified by\n * a visibility attribute. The default visibility may be changed by\n * commandline arguments.\n *\n * \\param cursor The cursor to query.\n *\n * \\returns The visibility of the cursor.\n */\nCINDEX_LINKAGE enum CXVisibilityKind clang_getCursorVisibility(CXCursor cursor);\n\n/**\n * Determine the availability of the entity that this cursor refers to,\n * taking the current target platform into account.\n *\n * \\param cursor The cursor to query.\n *\n * \\returns The availability of the cursor.\n */\nCINDEX_LINKAGE enum CXAvailabilityKind\nclang_getCursorAvailability(CXCursor cursor);\n\n/**\n * Describes the availability of a given entity on a particular platform, e.g.,\n * a particular class might only be available on Mac OS 10.7 or newer.\n */\ntypedef struct CXPlatformAvailability {\n  /**\n   * A string that describes the platform for which this structure\n   * provides availability information.\n   *\n   * Possible values are \"ios\" or \"macos\".\n   */\n  CXString Platform;\n  /**\n   * The version number in which this entity was introduced.\n   */\n  CXVersion Introduced;\n  /**\n   * The version number in which this entity was deprecated (but is\n   * still available).\n   */\n  CXVersion Deprecated;\n  /**\n   * The version number in which this entity was obsoleted, and therefore\n   * is no longer available.\n   */\n  CXVersion Obsoleted;\n  /**\n   * Whether the entity is unconditionally unavailable on this platform.\n   */\n  int Unavailable;\n  /**\n   * An optional message to provide to a user of this API, e.g., to\n   * suggest replacement APIs.\n   */\n  CXString Message;\n} CXPlatformAvailability;\n\n/**\n * Determine the availability of the entity that this cursor refers to\n * on any platforms for which availability information is known.\n *\n * \\param cursor The cursor to query.\n *\n * \\param always_deprecated If non-NULL, will be set to indicate whether the\n * entity is deprecated on all platforms.\n *\n * \\param deprecated_message If non-NULL, will be set to the message text\n * provided along with the unconditional deprecation of this entity. The client\n * is responsible for deallocating this string.\n *\n * \\param always_unavailable If non-NULL, will be set to indicate whether the\n * entity is unavailable on all platforms.\n *\n * \\param unavailable_message If non-NULL, will be set to the message text\n * provided along with the unconditional unavailability of this entity. The\n * client is responsible for deallocating this string.\n *\n * \\param availability If non-NULL, an array of CXPlatformAvailability instances\n * that will be populated with platform availability information, up to either\n * the number of platforms for which availability information is available (as\n * returned by this function) or \\c availability_size, whichever is smaller.\n *\n * \\param availability_size The number of elements available in the\n * \\c availability array.\n *\n * \\returns The number of platforms (N) for which availability information is\n * available (which is unrelated to \\c availability_size).\n *\n * Note that the client is responsible for calling\n * \\c clang_disposeCXPlatformAvailability to free each of the\n * platform-availability structures returned. There are\n * \\c min(N, availability_size) such structures.\n */\nCINDEX_LINKAGE int clang_getCursorPlatformAvailability(\n    CXCursor cursor, int *always_deprecated, CXString *deprecated_message,\n    int *always_unavailable, CXString *unavailable_message,\n    CXPlatformAvailability *availability, int availability_size);\n\n/**\n * Free the memory associated with a \\c CXPlatformAvailability structure.\n */\nCINDEX_LINKAGE void\nclang_disposeCXPlatformAvailability(CXPlatformAvailability *availability);\n\n/**\n * If cursor refers to a variable declaration and it has initializer returns\n * cursor referring to the initializer otherwise return null cursor.\n */\nCINDEX_LINKAGE CXCursor clang_Cursor_getVarDeclInitializer(CXCursor cursor);\n\n/**\n * If cursor refers to a variable declaration that has global storage returns 1.\n * If cursor refers to a variable declaration that doesn't have global storage\n * returns 0. Otherwise returns -1.\n */\nCINDEX_LINKAGE int clang_Cursor_hasVarDeclGlobalStorage(CXCursor cursor);\n\n/**\n * If cursor refers to a variable declaration that has external storage\n * returns 1. If cursor refers to a variable declaration that doesn't have\n * external storage returns 0. Otherwise returns -1.\n */\nCINDEX_LINKAGE int clang_Cursor_hasVarDeclExternalStorage(CXCursor cursor);\n\n/**\n * Describe the \"language\" of the entity referred to by a cursor.\n */\nenum CXLanguageKind {\n  CXLanguage_Invalid = 0,\n  CXLanguage_C,\n  CXLanguage_ObjC,\n  CXLanguage_CPlusPlus\n};\n\n/**\n * Determine the \"language\" of the entity referred to by a given cursor.\n */\nCINDEX_LINKAGE enum CXLanguageKind clang_getCursorLanguage(CXCursor cursor);\n\n/**\n * Describe the \"thread-local storage (TLS) kind\" of the declaration\n * referred to by a cursor.\n */\nenum CXTLSKind { CXTLS_None = 0, CXTLS_Dynamic, CXTLS_Static };\n\n/**\n * Determine the \"thread-local storage (TLS) kind\" of the declaration\n * referred to by a cursor.\n */\nCINDEX_LINKAGE enum CXTLSKind clang_getCursorTLSKind(CXCursor cursor);\n\n/**\n * Returns the translation unit that a cursor originated from.\n */\nCINDEX_LINKAGE CXTranslationUnit clang_Cursor_getTranslationUnit(CXCursor);\n\n/**\n * A fast container representing a set of CXCursors.\n */\ntypedef struct CXCursorSetImpl *CXCursorSet;\n\n/**\n * Creates an empty CXCursorSet.\n */\nCINDEX_LINKAGE CXCursorSet clang_createCXCursorSet(void);\n\n/**\n * Disposes a CXCursorSet and releases its associated memory.\n */\nCINDEX_LINKAGE void clang_disposeCXCursorSet(CXCursorSet cset);\n\n/**\n * Queries a CXCursorSet to see if it contains a specific CXCursor.\n *\n * \\returns non-zero if the set contains the specified cursor.\n */\nCINDEX_LINKAGE unsigned clang_CXCursorSet_contains(CXCursorSet cset,\n                                                   CXCursor cursor);\n\n/**\n * Inserts a CXCursor into a CXCursorSet.\n *\n * \\returns zero if the CXCursor was already in the set, and non-zero otherwise.\n */\nCINDEX_LINKAGE unsigned clang_CXCursorSet_insert(CXCursorSet cset,\n                                                 CXCursor cursor);\n\n/**\n * Determine the semantic parent of the given cursor.\n *\n * The semantic parent of a cursor is the cursor that semantically contains\n * the given \\p cursor. For many declarations, the lexical and semantic parents\n * are equivalent (the lexical parent is returned by\n * \\c clang_getCursorLexicalParent()). They diverge when declarations or\n * definitions are provided out-of-line. For example:\n *\n * \\code\n * class C {\n *  void f();\n * };\n *\n * void C::f() { }\n * \\endcode\n *\n * In the out-of-line definition of \\c C::f, the semantic parent is\n * the class \\c C, of which this function is a member. The lexical parent is\n * the place where the declaration actually occurs in the source code; in this\n * case, the definition occurs in the translation unit. In general, the\n * lexical parent for a given entity can change without affecting the semantics\n * of the program, and the lexical parent of different declarations of the\n * same entity may be different. Changing the semantic parent of a declaration,\n * on the other hand, can have a major impact on semantics, and redeclarations\n * of a particular entity should all have the same semantic context.\n *\n * In the example above, both declarations of \\c C::f have \\c C as their\n * semantic context, while the lexical context of the first \\c C::f is \\c C\n * and the lexical context of the second \\c C::f is the translation unit.\n *\n * For global declarations, the semantic parent is the translation unit.\n */\nCINDEX_LINKAGE CXCursor clang_getCursorSemanticParent(CXCursor cursor);\n\n/**\n * Determine the lexical parent of the given cursor.\n *\n * The lexical parent of a cursor is the cursor in which the given \\p cursor\n * was actually written. For many declarations, the lexical and semantic parents\n * are equivalent (the semantic parent is returned by\n * \\c clang_getCursorSemanticParent()). They diverge when declarations or\n * definitions are provided out-of-line. For example:\n *\n * \\code\n * class C {\n *  void f();\n * };\n *\n * void C::f() { }\n * \\endcode\n *\n * In the out-of-line definition of \\c C::f, the semantic parent is\n * the class \\c C, of which this function is a member. The lexical parent is\n * the place where the declaration actually occurs in the source code; in this\n * case, the definition occurs in the translation unit. In general, the\n * lexical parent for a given entity can change without affecting the semantics\n * of the program, and the lexical parent of different declarations of the\n * same entity may be different. Changing the semantic parent of a declaration,\n * on the other hand, can have a major impact on semantics, and redeclarations\n * of a particular entity should all have the same semantic context.\n *\n * In the example above, both declarations of \\c C::f have \\c C as their\n * semantic context, while the lexical context of the first \\c C::f is \\c C\n * and the lexical context of the second \\c C::f is the translation unit.\n *\n * For declarations written in the global scope, the lexical parent is\n * the translation unit.\n */\nCINDEX_LINKAGE CXCursor clang_getCursorLexicalParent(CXCursor cursor);\n\n/**\n * Determine the set of methods that are overridden by the given\n * method.\n *\n * In both Objective-C and C++, a method (aka virtual member function,\n * in C++) can override a virtual method in a base class. For\n * Objective-C, a method is said to override any method in the class's\n * base class, its protocols, or its categories' protocols, that has the same\n * selector and is of the same kind (class or instance).\n * If no such method exists, the search continues to the class's superclass,\n * its protocols, and its categories, and so on. A method from an Objective-C\n * implementation is considered to override the same methods as its\n * corresponding method in the interface.\n *\n * For C++, a virtual member function overrides any virtual member\n * function with the same signature that occurs in its base\n * classes. With multiple inheritance, a virtual member function can\n * override several virtual member functions coming from different\n * base classes.\n *\n * In all cases, this function determines the immediate overridden\n * method, rather than all of the overridden methods. For example, if\n * a method is originally declared in a class A, then overridden in B\n * (which in inherits from A) and also in C (which inherited from B),\n * then the only overridden method returned from this function when\n * invoked on C's method will be B's method. The client may then\n * invoke this function again, given the previously-found overridden\n * methods, to map out the complete method-override set.\n *\n * \\param cursor A cursor representing an Objective-C or C++\n * method. This routine will compute the set of methods that this\n * method overrides.\n *\n * \\param overridden A pointer whose pointee will be replaced with a\n * pointer to an array of cursors, representing the set of overridden\n * methods. If there are no overridden methods, the pointee will be\n * set to NULL. The pointee must be freed via a call to\n * \\c clang_disposeOverriddenCursors().\n *\n * \\param num_overridden A pointer to the number of overridden\n * functions, will be set to the number of overridden functions in the\n * array pointed to by \\p overridden.\n */\nCINDEX_LINKAGE void clang_getOverriddenCursors(CXCursor cursor,\n                                               CXCursor **overridden,\n                                               unsigned *num_overridden);\n\n/**\n * Free the set of overridden cursors returned by \\c\n * clang_getOverriddenCursors().\n */\nCINDEX_LINKAGE void clang_disposeOverriddenCursors(CXCursor *overridden);\n\n/**\n * Retrieve the file that is included by the given inclusion directive\n * cursor.\n */\nCINDEX_LINKAGE CXFile clang_getIncludedFile(CXCursor cursor);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_CURSOR_SOURCE Mapping between cursors and source code\n *\n * Cursors represent a location within the Abstract Syntax Tree (AST). These\n * routines help map between cursors and the physical locations where the\n * described entities occur in the source code. The mapping is provided in\n * both directions, so one can map from source code to the AST and back.\n *\n * @{\n */\n\n/**\n * Map a source location to the cursor that describes the entity at that\n * location in the source code.\n *\n * clang_getCursor() maps an arbitrary source location within a translation\n * unit down to the most specific cursor that describes the entity at that\n * location. For example, given an expression \\c x + y, invoking\n * clang_getCursor() with a source location pointing to \"x\" will return the\n * cursor for \"x\"; similarly for \"y\". If the cursor points anywhere between\n * \"x\" or \"y\" (e.g., on the + or the whitespace around it), clang_getCursor()\n * will return a cursor referring to the \"+\" expression.\n *\n * \\returns a cursor representing the entity at the given source location, or\n * a NULL cursor if no such entity can be found.\n */\nCINDEX_LINKAGE CXCursor clang_getCursor(CXTranslationUnit, CXSourceLocation);\n\n/**\n * Retrieve the physical location of the source constructor referenced\n * by the given cursor.\n *\n * The location of a declaration is typically the location of the name of that\n * declaration, where the name of that declaration would occur if it is\n * unnamed, or some keyword that introduces that particular declaration.\n * The location of a reference is where that reference occurs within the\n * source code.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getCursorLocation(CXCursor);\n\n/**\n * Retrieve the physical extent of the source construct referenced by\n * the given cursor.\n *\n * The extent of a cursor starts with the file/line/column pointing at the\n * first character within the source construct that the cursor refers to and\n * ends with the last character within that source construct. For a\n * declaration, the extent covers the declaration itself. For a reference,\n * the extent covers the location of the reference (e.g., where the referenced\n * entity was actually used).\n */\nCINDEX_LINKAGE CXSourceRange clang_getCursorExtent(CXCursor);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_TYPES Type information for CXCursors\n *\n * @{\n */\n\n/**\n * Describes the kind of type\n */\nenum CXTypeKind {\n  /**\n   * Represents an invalid type (e.g., where no type is available).\n   */\n  CXType_Invalid = 0,\n\n  /**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */\n  CXType_Unexposed = 1,\n\n  /* Builtin types */\n  CXType_Void = 2,\n  CXType_Bool = 3,\n  CXType_Char_U = 4,\n  CXType_UChar = 5,\n  CXType_Char16 = 6,\n  CXType_Char32 = 7,\n  CXType_UShort = 8,\n  CXType_UInt = 9,\n  CXType_ULong = 10,\n  CXType_ULongLong = 11,\n  CXType_UInt128 = 12,\n  CXType_Char_S = 13,\n  CXType_SChar = 14,\n  CXType_WChar = 15,\n  CXType_Short = 16,\n  CXType_Int = 17,\n  CXType_Long = 18,\n  CXType_LongLong = 19,\n  CXType_Int128 = 20,\n  CXType_Float = 21,\n  CXType_Double = 22,\n  CXType_LongDouble = 23,\n  CXType_NullPtr = 24,\n  CXType_Overload = 25,\n  CXType_Dependent = 26,\n  CXType_ObjCId = 27,\n  CXType_ObjCClass = 28,\n  CXType_ObjCSel = 29,\n  CXType_Float128 = 30,\n  CXType_Half = 31,\n  CXType_Float16 = 32,\n  CXType_ShortAccum = 33,\n  CXType_Accum = 34,\n  CXType_LongAccum = 35,\n  CXType_UShortAccum = 36,\n  CXType_UAccum = 37,\n  CXType_ULongAccum = 38,\n  CXType_BFloat16 = 39,\n  CXType_FirstBuiltin = CXType_Void,\n  CXType_LastBuiltin = CXType_BFloat16,\n\n  CXType_Complex = 100,\n  CXType_Pointer = 101,\n  CXType_BlockPointer = 102,\n  CXType_LValueReference = 103,\n  CXType_RValueReference = 104,\n  CXType_Record = 105,\n  CXType_Enum = 106,\n  CXType_Typedef = 107,\n  CXType_ObjCInterface = 108,\n  CXType_ObjCObjectPointer = 109,\n  CXType_FunctionNoProto = 110,\n  CXType_FunctionProto = 111,\n  CXType_ConstantArray = 112,\n  CXType_Vector = 113,\n  CXType_IncompleteArray = 114,\n  CXType_VariableArray = 115,\n  CXType_DependentSizedArray = 116,\n  CXType_MemberPointer = 117,\n  CXType_Auto = 118,\n\n  /**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */\n  CXType_Elaborated = 119,\n\n  /* OpenCL PipeType. */\n  CXType_Pipe = 120,\n\n  /* OpenCL builtin types. */\n  CXType_OCLImage1dRO = 121,\n  CXType_OCLImage1dArrayRO = 122,\n  CXType_OCLImage1dBufferRO = 123,\n  CXType_OCLImage2dRO = 124,\n  CXType_OCLImage2dArrayRO = 125,\n  CXType_OCLImage2dDepthRO = 126,\n  CXType_OCLImage2dArrayDepthRO = 127,\n  CXType_OCLImage2dMSAARO = 128,\n  CXType_OCLImage2dArrayMSAARO = 129,\n  CXType_OCLImage2dMSAADepthRO = 130,\n  CXType_OCLImage2dArrayMSAADepthRO = 131,\n  CXType_OCLImage3dRO = 132,\n  CXType_OCLImage1dWO = 133,\n  CXType_OCLImage1dArrayWO = 134,\n  CXType_OCLImage1dBufferWO = 135,\n  CXType_OCLImage2dWO = 136,\n  CXType_OCLImage2dArrayWO = 137,\n  CXType_OCLImage2dDepthWO = 138,\n  CXType_OCLImage2dArrayDepthWO = 139,\n  CXType_OCLImage2dMSAAWO = 140,\n  CXType_OCLImage2dArrayMSAAWO = 141,\n  CXType_OCLImage2dMSAADepthWO = 142,\n  CXType_OCLImage2dArrayMSAADepthWO = 143,\n  CXType_OCLImage3dWO = 144,\n  CXType_OCLImage1dRW = 145,\n  CXType_OCLImage1dArrayRW = 146,\n  CXType_OCLImage1dBufferRW = 147,\n  CXType_OCLImage2dRW = 148,\n  CXType_OCLImage2dArrayRW = 149,\n  CXType_OCLImage2dDepthRW = 150,\n  CXType_OCLImage2dArrayDepthRW = 151,\n  CXType_OCLImage2dMSAARW = 152,\n  CXType_OCLImage2dArrayMSAARW = 153,\n  CXType_OCLImage2dMSAADepthRW = 154,\n  CXType_OCLImage2dArrayMSAADepthRW = 155,\n  CXType_OCLImage3dRW = 156,\n  CXType_OCLSampler = 157,\n  CXType_OCLEvent = 158,\n  CXType_OCLQueue = 159,\n  CXType_OCLReserveID = 160,\n\n  CXType_ObjCObject = 161,\n  CXType_ObjCTypeParam = 162,\n  CXType_Attributed = 163,\n\n  CXType_OCLIntelSubgroupAVCMcePayload = 164,\n  CXType_OCLIntelSubgroupAVCImePayload = 165,\n  CXType_OCLIntelSubgroupAVCRefPayload = 166,\n  CXType_OCLIntelSubgroupAVCSicPayload = 167,\n  CXType_OCLIntelSubgroupAVCMceResult = 168,\n  CXType_OCLIntelSubgroupAVCImeResult = 169,\n  CXType_OCLIntelSubgroupAVCRefResult = 170,\n  CXType_OCLIntelSubgroupAVCSicResult = 171,\n  CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout = 172,\n  CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout = 173,\n  CXType_OCLIntelSubgroupAVCImeSingleRefStreamin = 174,\n\n  CXType_OCLIntelSubgroupAVCImeDualRefStreamin = 175,\n\n  CXType_ExtVector = 176,\n  CXType_Atomic = 177\n};\n\n/**\n * Describes the calling convention of a function type\n */\nenum CXCallingConv {\n  CXCallingConv_Default = 0,\n  CXCallingConv_C = 1,\n  CXCallingConv_X86StdCall = 2,\n  CXCallingConv_X86FastCall = 3,\n  CXCallingConv_X86ThisCall = 4,\n  CXCallingConv_X86Pascal = 5,\n  CXCallingConv_AAPCS = 6,\n  CXCallingConv_AAPCS_VFP = 7,\n  CXCallingConv_X86RegCall = 8,\n  CXCallingConv_IntelOclBicc = 9,\n  CXCallingConv_Win64 = 10,\n  /* Alias for compatibility with older versions of API. */\n  CXCallingConv_X86_64Win64 = CXCallingConv_Win64,\n  CXCallingConv_X86_64SysV = 11,\n  CXCallingConv_X86VectorCall = 12,\n  CXCallingConv_Swift = 13,\n  CXCallingConv_PreserveMost = 14,\n  CXCallingConv_PreserveAll = 15,\n  CXCallingConv_AArch64VectorCall = 16,\n\n  CXCallingConv_Invalid = 100,\n  CXCallingConv_Unexposed = 200\n};\n\n/**\n * The type of an element in the abstract syntax tree.\n *\n */\ntypedef struct {\n  enum CXTypeKind kind;\n  void *data[2];\n} CXType;\n\n/**\n * Retrieve the type of a CXCursor (if any).\n */\nCINDEX_LINKAGE CXType clang_getCursorType(CXCursor C);\n\n/**\n * Pretty-print the underlying type using the rules of the\n * language of the translation unit from which it came.\n *\n * If the type is invalid, an empty string is returned.\n */\nCINDEX_LINKAGE CXString clang_getTypeSpelling(CXType CT);\n\n/**\n * Retrieve the underlying type of a typedef declaration.\n *\n * If the cursor does not reference a typedef declaration, an invalid type is\n * returned.\n */\nCINDEX_LINKAGE CXType clang_getTypedefDeclUnderlyingType(CXCursor C);\n\n/**\n * Retrieve the integer type of an enum declaration.\n *\n * If the cursor does not reference an enum declaration, an invalid type is\n * returned.\n */\nCINDEX_LINKAGE CXType clang_getEnumDeclIntegerType(CXCursor C);\n\n/**\n * Retrieve the integer value of an enum constant declaration as a signed\n *  long long.\n *\n * If the cursor does not reference an enum constant declaration, LLONG_MIN is\n * returned. Since this is also potentially a valid constant value, the kind of\n * the cursor must be verified before calling this function.\n */\nCINDEX_LINKAGE long long clang_getEnumConstantDeclValue(CXCursor C);\n\n/**\n * Retrieve the integer value of an enum constant declaration as an unsigned\n *  long long.\n *\n * If the cursor does not reference an enum constant declaration, ULLONG_MAX is\n * returned. Since this is also potentially a valid constant value, the kind of\n * the cursor must be verified before calling this function.\n */\nCINDEX_LINKAGE unsigned long long\nclang_getEnumConstantDeclUnsignedValue(CXCursor C);\n\n/**\n * Retrieve the bit width of a bit field declaration as an integer.\n *\n * If a cursor that is not a bit field declaration is passed in, -1 is returned.\n */\nCINDEX_LINKAGE int clang_getFieldDeclBitWidth(CXCursor C);\n\n/**\n * Retrieve the number of non-variadic arguments associated with a given\n * cursor.\n *\n * The number of arguments can be determined for calls as well as for\n * declarations of functions or methods. For other cursors -1 is returned.\n */\nCINDEX_LINKAGE int clang_Cursor_getNumArguments(CXCursor C);\n\n/**\n * Retrieve the argument cursor of a function or method.\n *\n * The argument cursor can be determined for calls as well as for declarations\n * of functions or methods. For other cursors and for invalid indices, an\n * invalid cursor is returned.\n */\nCINDEX_LINKAGE CXCursor clang_Cursor_getArgument(CXCursor C, unsigned i);\n\n/**\n * Describes the kind of a template argument.\n *\n * See the definition of llvm::clang::TemplateArgument::ArgKind for full\n * element descriptions.\n */\nenum CXTemplateArgumentKind {\n  CXTemplateArgumentKind_Null,\n  CXTemplateArgumentKind_Type,\n  CXTemplateArgumentKind_Declaration,\n  CXTemplateArgumentKind_NullPtr,\n  CXTemplateArgumentKind_Integral,\n  CXTemplateArgumentKind_Template,\n  CXTemplateArgumentKind_TemplateExpansion,\n  CXTemplateArgumentKind_Expression,\n  CXTemplateArgumentKind_Pack,\n  /* Indicates an error case, preventing the kind from being deduced. */\n  CXTemplateArgumentKind_Invalid\n};\n\n/**\n *Returns the number of template args of a function decl representing a\n * template specialization.\n *\n * If the argument cursor cannot be converted into a template function\n * declaration, -1 is returned.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * The value 3 would be returned from this call.\n */\nCINDEX_LINKAGE int clang_Cursor_getNumTemplateArguments(CXCursor C);\n\n/**\n * Retrieve the kind of the I'th template argument of the CXCursor C.\n *\n * If the argument CXCursor does not represent a FunctionDecl, an invalid\n * template argument kind is returned.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * For I = 0, 1, and 2, Type, Integral, and Integral will be returned,\n * respectively.\n */\nCINDEX_LINKAGE enum CXTemplateArgumentKind\nclang_Cursor_getTemplateArgumentKind(CXCursor C, unsigned I);\n\n/**\n * Retrieve a CXType representing the type of a TemplateArgument of a\n *  function decl representing a template specialization.\n *\n * If the argument CXCursor does not represent a FunctionDecl whose I'th\n * template argument has a kind of CXTemplateArgKind_Integral, an invalid type\n * is returned.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * If called with I = 0, \"float\", will be returned.\n * Invalid types will be returned for I == 1 or 2.\n */\nCINDEX_LINKAGE CXType clang_Cursor_getTemplateArgumentType(CXCursor C,\n                                                           unsigned I);\n\n/**\n * Retrieve the value of an Integral TemplateArgument (of a function\n *  decl representing a template specialization) as a signed long long.\n *\n * It is undefined to call this function on a CXCursor that does not represent a\n * FunctionDecl or whose I'th template argument is not an integral value.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * If called with I = 1 or 2, -7 or true will be returned, respectively.\n * For I == 0, this function's behavior is undefined.\n */\nCINDEX_LINKAGE long long clang_Cursor_getTemplateArgumentValue(CXCursor C,\n                                                               unsigned I);\n\n/**\n * Retrieve the value of an Integral TemplateArgument (of a function\n *  decl representing a template specialization) as an unsigned long long.\n *\n * It is undefined to call this function on a CXCursor that does not represent a\n * FunctionDecl or whose I'th template argument is not an integral value.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, 2147483649, true>();\n *\n * If called with I = 1 or 2, 2147483649 or true will be returned, respectively.\n * For I == 0, this function's behavior is undefined.\n */\nCINDEX_LINKAGE unsigned long long\nclang_Cursor_getTemplateArgumentUnsignedValue(CXCursor C, unsigned I);\n\n/**\n * Determine whether two CXTypes represent the same type.\n *\n * \\returns non-zero if the CXTypes represent the same type and\n *          zero otherwise.\n */\nCINDEX_LINKAGE unsigned clang_equalTypes(CXType A, CXType B);\n\n/**\n * Return the canonical type for a CXType.\n *\n * Clang's type system explicitly models typedefs and all the ways\n * a specific type can be represented.  The canonical type is the underlying\n * type with all the \"sugar\" removed.  For example, if 'T' is a typedef\n * for 'int', the canonical type for 'T' would be 'int'.\n */\nCINDEX_LINKAGE CXType clang_getCanonicalType(CXType T);\n\n/**\n * Determine whether a CXType has the \"const\" qualifier set,\n * without looking through typedefs that may have added \"const\" at a\n * different level.\n */\nCINDEX_LINKAGE unsigned clang_isConstQualifiedType(CXType T);\n\n/**\n * Determine whether a  CXCursor that is a macro, is\n * function like.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isMacroFunctionLike(CXCursor C);\n\n/**\n * Determine whether a  CXCursor that is a macro, is a\n * builtin one.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isMacroBuiltin(CXCursor C);\n\n/**\n * Determine whether a  CXCursor that is a function declaration, is an\n * inline declaration.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isFunctionInlined(CXCursor C);\n\n/**\n * Determine whether a CXType has the \"volatile\" qualifier set,\n * without looking through typedefs that may have added \"volatile\" at\n * a different level.\n */\nCINDEX_LINKAGE unsigned clang_isVolatileQualifiedType(CXType T);\n\n/**\n * Determine whether a CXType has the \"restrict\" qualifier set,\n * without looking through typedefs that may have added \"restrict\" at a\n * different level.\n */\nCINDEX_LINKAGE unsigned clang_isRestrictQualifiedType(CXType T);\n\n/**\n * Returns the address space of the given type.\n */\nCINDEX_LINKAGE unsigned clang_getAddressSpace(CXType T);\n\n/**\n * Returns the typedef name of the given type.\n */\nCINDEX_LINKAGE CXString clang_getTypedefName(CXType CT);\n\n/**\n * For pointer types, returns the type of the pointee.\n */\nCINDEX_LINKAGE CXType clang_getPointeeType(CXType T);\n\n/**\n * Return the cursor for the declaration of the given type.\n */\nCINDEX_LINKAGE CXCursor clang_getTypeDeclaration(CXType T);\n\n/**\n * Returns the Objective-C type encoding for the specified declaration.\n */\nCINDEX_LINKAGE CXString clang_getDeclObjCTypeEncoding(CXCursor C);\n\n/**\n * Returns the Objective-C type encoding for the specified CXType.\n */\nCINDEX_LINKAGE CXString clang_Type_getObjCEncoding(CXType type);\n\n/**\n * Retrieve the spelling of a given CXTypeKind.\n */\nCINDEX_LINKAGE CXString clang_getTypeKindSpelling(enum CXTypeKind K);\n\n/**\n * Retrieve the calling convention associated with a function type.\n *\n * If a non-function type is passed in, CXCallingConv_Invalid is returned.\n */\nCINDEX_LINKAGE enum CXCallingConv clang_getFunctionTypeCallingConv(CXType T);\n\n/**\n * Retrieve the return type associated with a function type.\n *\n * If a non-function type is passed in, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_getResultType(CXType T);\n\n/**\n * Retrieve the exception specification type associated with a function type.\n * This is a value of type CXCursor_ExceptionSpecificationKind.\n *\n * If a non-function type is passed in, an error code of -1 is returned.\n */\nCINDEX_LINKAGE int clang_getExceptionSpecificationType(CXType T);\n\n/**\n * Retrieve the number of non-variadic parameters associated with a\n * function type.\n *\n * If a non-function type is passed in, -1 is returned.\n */\nCINDEX_LINKAGE int clang_getNumArgTypes(CXType T);\n\n/**\n * Retrieve the type of a parameter of a function type.\n *\n * If a non-function type is passed in or the function does not have enough\n * parameters, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_getArgType(CXType T, unsigned i);\n\n/**\n * Retrieves the base type of the ObjCObjectType.\n *\n * If the type is not an ObjC object, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getObjCObjectBaseType(CXType T);\n\n/**\n * Retrieve the number of protocol references associated with an ObjC object/id.\n *\n * If the type is not an ObjC object, 0 is returned.\n */\nCINDEX_LINKAGE unsigned clang_Type_getNumObjCProtocolRefs(CXType T);\n\n/**\n * Retrieve the decl for a protocol reference for an ObjC object/id.\n *\n * If the type is not an ObjC object or there are not enough protocol\n * references, an invalid cursor is returned.\n */\nCINDEX_LINKAGE CXCursor clang_Type_getObjCProtocolDecl(CXType T, unsigned i);\n\n/**\n * Retrieve the number of type arguments associated with an ObjC object.\n *\n * If the type is not an ObjC object, 0 is returned.\n */\nCINDEX_LINKAGE unsigned clang_Type_getNumObjCTypeArgs(CXType T);\n\n/**\n * Retrieve a type argument associated with an ObjC object.\n *\n * If the type is not an ObjC or the index is not valid,\n * an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getObjCTypeArg(CXType T, unsigned i);\n\n/**\n * Return 1 if the CXType is a variadic function type, and 0 otherwise.\n */\nCINDEX_LINKAGE unsigned clang_isFunctionTypeVariadic(CXType T);\n\n/**\n * Retrieve the return type associated with a given cursor.\n *\n * This only returns a valid type if the cursor refers to a function or method.\n */\nCINDEX_LINKAGE CXType clang_getCursorResultType(CXCursor C);\n\n/**\n * Retrieve the exception specification type associated with a given cursor.\n * This is a value of type CXCursor_ExceptionSpecificationKind.\n *\n * This only returns a valid result if the cursor refers to a function or\n * method.\n */\nCINDEX_LINKAGE int clang_getCursorExceptionSpecificationType(CXCursor C);\n\n/**\n * Return 1 if the CXType is a POD (plain old data) type, and 0\n *  otherwise.\n */\nCINDEX_LINKAGE unsigned clang_isPODType(CXType T);\n\n/**\n * Return the element type of an array, complex, or vector type.\n *\n * If a type is passed in that is not an array, complex, or vector type,\n * an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_getElementType(CXType T);\n\n/**\n * Return the number of elements of an array or vector type.\n *\n * If a type is passed in that is not an array or vector type,\n * -1 is returned.\n */\nCINDEX_LINKAGE long long clang_getNumElements(CXType T);\n\n/**\n * Return the element type of an array type.\n *\n * If a non-array type is passed in, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_getArrayElementType(CXType T);\n\n/**\n * Return the array size of a constant array.\n *\n * If a non-array type is passed in, -1 is returned.\n */\nCINDEX_LINKAGE long long clang_getArraySize(CXType T);\n\n/**\n * Retrieve the type named by the qualified-id.\n *\n * If a non-elaborated type is passed in, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getNamedType(CXType T);\n\n/**\n * Determine if a typedef is 'transparent' tag.\n *\n * A typedef is considered 'transparent' if it shares a name and spelling\n * location with its underlying tag type, as is the case with the NS_ENUM macro.\n *\n * \\returns non-zero if transparent and zero otherwise.\n */\nCINDEX_LINKAGE unsigned clang_Type_isTransparentTagTypedef(CXType T);\n\nenum CXTypeNullabilityKind {\n  /**\n   * Values of this type can never be null.\n   */\n  CXTypeNullability_NonNull = 0,\n  /**\n   * Values of this type can be null.\n   */\n  CXTypeNullability_Nullable = 1,\n  /**\n   * Whether values of this type can be null is (explicitly)\n   * unspecified. This captures a (fairly rare) case where we\n   * can't conclude anything about the nullability of the type even\n   * though it has been considered.\n   */\n  CXTypeNullability_Unspecified = 2,\n  /**\n   * Nullability is not applicable to this type.\n   */\n  CXTypeNullability_Invalid = 3,\n\n  /**\n   * Generally behaves like Nullable, except when used in a block parameter that\n   * was imported into a swift async method. There, swift will assume that the\n   * parameter can get null even if no error occured. _Nullable parameters are\n   * assumed to only get null on error.\n   */\n  CXTypeNullability_NullableResult = 4\n};\n\n/**\n * Retrieve the nullability kind of a pointer type.\n */\nCINDEX_LINKAGE enum CXTypeNullabilityKind clang_Type_getNullability(CXType T);\n\n/**\n * List the possible error codes for \\c clang_Type_getSizeOf,\n *   \\c clang_Type_getAlignOf, \\c clang_Type_getOffsetOf and\n *   \\c clang_Cursor_getOffsetOf.\n *\n * A value of this enumeration type can be returned if the target type is not\n * a valid argument to sizeof, alignof or offsetof.\n */\nenum CXTypeLayoutError {\n  /**\n   * Type is of kind CXType_Invalid.\n   */\n  CXTypeLayoutError_Invalid = -1,\n  /**\n   * The type is an incomplete Type.\n   */\n  CXTypeLayoutError_Incomplete = -2,\n  /**\n   * The type is a dependent Type.\n   */\n  CXTypeLayoutError_Dependent = -3,\n  /**\n   * The type is not a constant size type.\n   */\n  CXTypeLayoutError_NotConstantSize = -4,\n  /**\n   * The Field name is not valid for this record.\n   */\n  CXTypeLayoutError_InvalidFieldName = -5,\n  /**\n   * The type is undeduced.\n   */\n  CXTypeLayoutError_Undeduced = -6\n};\n\n/**\n * Return the alignment of a type in bytes as per C++[expr.alignof]\n *   standard.\n *\n * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.\n * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete\n *   is returned.\n * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is\n *   returned.\n * If the type declaration is not a constant size type,\n *   CXTypeLayoutError_NotConstantSize is returned.\n */\nCINDEX_LINKAGE long long clang_Type_getAlignOf(CXType T);\n\n/**\n * Return the class type of an member pointer type.\n *\n * If a non-member-pointer type is passed in, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getClassType(CXType T);\n\n/**\n * Return the size of a type in bytes as per C++[expr.sizeof] standard.\n *\n * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.\n * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete\n *   is returned.\n * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is\n *   returned.\n */\nCINDEX_LINKAGE long long clang_Type_getSizeOf(CXType T);\n\n/**\n * Return the offset of a field named S in a record of type T in bits\n *   as it would be returned by __offsetof__ as per C++11[18.2p4]\n *\n * If the cursor is not a record field declaration, CXTypeLayoutError_Invalid\n *   is returned.\n * If the field's type declaration is an incomplete type,\n *   CXTypeLayoutError_Incomplete is returned.\n * If the field's type declaration is a dependent type,\n *   CXTypeLayoutError_Dependent is returned.\n * If the field's name S is not found,\n *   CXTypeLayoutError_InvalidFieldName is returned.\n */\nCINDEX_LINKAGE long long clang_Type_getOffsetOf(CXType T, const char *S);\n\n/**\n * Return the type that was modified by this attributed type.\n *\n * If the type is not an attributed type, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getModifiedType(CXType T);\n\n/**\n * Gets the type contained by this atomic type.\n *\n * If a non-atomic type is passed in, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getValueType(CXType CT);\n\n/**\n * Return the offset of the field represented by the Cursor.\n *\n * If the cursor is not a field declaration, -1 is returned.\n * If the cursor semantic parent is not a record field declaration,\n *   CXTypeLayoutError_Invalid is returned.\n * If the field's type declaration is an incomplete type,\n *   CXTypeLayoutError_Incomplete is returned.\n * If the field's type declaration is a dependent type,\n *   CXTypeLayoutError_Dependent is returned.\n * If the field's name S is not found,\n *   CXTypeLayoutError_InvalidFieldName is returned.\n */\nCINDEX_LINKAGE long long clang_Cursor_getOffsetOfField(CXCursor C);\n\n/**\n * Determine whether the given cursor represents an anonymous\n * tag or namespace\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isAnonymous(CXCursor C);\n\n/**\n * Determine whether the given cursor represents an anonymous record\n * declaration.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isAnonymousRecordDecl(CXCursor C);\n\n/**\n * Determine whether the given cursor represents an inline namespace\n * declaration.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isInlineNamespace(CXCursor C);\n\nenum CXRefQualifierKind {\n  /** No ref-qualifier was provided. */\n  CXRefQualifier_None = 0,\n  /** An lvalue ref-qualifier was provided (\\c &). */\n  CXRefQualifier_LValue,\n  /** An rvalue ref-qualifier was provided (\\c &&). */\n  CXRefQualifier_RValue\n};\n\n/**\n * Returns the number of template arguments for given template\n * specialization, or -1 if type \\c T is not a template specialization.\n */\nCINDEX_LINKAGE int clang_Type_getNumTemplateArguments(CXType T);\n\n/**\n * Returns the type template argument of a template class specialization\n * at given index.\n *\n * This function only returns template type arguments and does not handle\n * template template arguments or variadic packs.\n */\nCINDEX_LINKAGE CXType clang_Type_getTemplateArgumentAsType(CXType T,\n                                                           unsigned i);\n\n/**\n * Retrieve the ref-qualifier kind of a function or method.\n *\n * The ref-qualifier is returned for C++ functions or methods. For other types\n * or non-C++ declarations, CXRefQualifier_None is returned.\n */\nCINDEX_LINKAGE enum CXRefQualifierKind clang_Type_getCXXRefQualifier(CXType T);\n\n/**\n * Returns non-zero if the cursor specifies a Record member that is a\n *   bitfield.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isBitField(CXCursor C);\n\n/**\n * Returns 1 if the base class specified by the cursor with kind\n *   CX_CXXBaseSpecifier is virtual.\n */\nCINDEX_LINKAGE unsigned clang_isVirtualBase(CXCursor);\n\n/**\n * Represents the C++ access control level to a base class for a\n * cursor with kind CX_CXXBaseSpecifier.\n */\nenum CX_CXXAccessSpecifier {\n  CX_CXXInvalidAccessSpecifier,\n  CX_CXXPublic,\n  CX_CXXProtected,\n  CX_CXXPrivate\n};\n\n/**\n * Returns the access control level for the referenced object.\n *\n * If the cursor refers to a C++ declaration, its access control level within\n * its parent scope is returned. Otherwise, if the cursor refers to a base\n * specifier or access specifier, the specifier itself is returned.\n */\nCINDEX_LINKAGE enum CX_CXXAccessSpecifier clang_getCXXAccessSpecifier(CXCursor);\n\n/**\n * Represents the storage classes as declared in the source. CX_SC_Invalid\n * was added for the case that the passed cursor in not a declaration.\n */\nenum CX_StorageClass {\n  CX_SC_Invalid,\n  CX_SC_None,\n  CX_SC_Extern,\n  CX_SC_Static,\n  CX_SC_PrivateExtern,\n  CX_SC_OpenCLWorkGroupLocal,\n  CX_SC_Auto,\n  CX_SC_Register\n};\n\n/**\n * Returns the storage class for a function or variable declaration.\n *\n * If the passed in Cursor is not a function or variable declaration,\n * CX_SC_Invalid is returned else the storage class.\n */\nCINDEX_LINKAGE enum CX_StorageClass clang_Cursor_getStorageClass(CXCursor);\n\n/**\n * Determine the number of overloaded declarations referenced by a\n * \\c CXCursor_OverloadedDeclRef cursor.\n *\n * \\param cursor The cursor whose overloaded declarations are being queried.\n *\n * \\returns The number of overloaded declarations referenced by \\c cursor. If it\n * is not a \\c CXCursor_OverloadedDeclRef cursor, returns 0.\n */\nCINDEX_LINKAGE unsigned clang_getNumOverloadedDecls(CXCursor cursor);\n\n/**\n * Retrieve a cursor for one of the overloaded declarations referenced\n * by a \\c CXCursor_OverloadedDeclRef cursor.\n *\n * \\param cursor The cursor whose overloaded declarations are being queried.\n *\n * \\param index The zero-based index into the set of overloaded declarations in\n * the cursor.\n *\n * \\returns A cursor representing the declaration referenced by the given\n * \\c cursor at the specified \\c index. If the cursor does not have an\n * associated set of overloaded declarations, or if the index is out of bounds,\n * returns \\c clang_getNullCursor();\n */\nCINDEX_LINKAGE CXCursor clang_getOverloadedDecl(CXCursor cursor,\n                                                unsigned index);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_ATTRIBUTES Information for attributes\n *\n * @{\n */\n\n/**\n * For cursors representing an iboutletcollection attribute,\n *  this function returns the collection element type.\n *\n */\nCINDEX_LINKAGE CXType clang_getIBOutletCollectionType(CXCursor);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_CURSOR_TRAVERSAL Traversing the AST with cursors\n *\n * These routines provide the ability to traverse the abstract syntax tree\n * using cursors.\n *\n * @{\n */\n\n/**\n * Describes how the traversal of the children of a particular\n * cursor should proceed after visiting a particular child cursor.\n *\n * A value of this enumeration type should be returned by each\n * \\c CXCursorVisitor to indicate how clang_visitChildren() proceed.\n */\nenum CXChildVisitResult {\n  /**\n   * Terminates the cursor traversal.\n   */\n  CXChildVisit_Break,\n  /**\n   * Continues the cursor traversal with the next sibling of\n   * the cursor just visited, without visiting its children.\n   */\n  CXChildVisit_Continue,\n  /**\n   * Recursively traverse the children of this cursor, using\n   * the same visitor and client data.\n   */\n  CXChildVisit_Recurse\n};\n\n/**\n * Visitor invoked for each cursor found by a traversal.\n *\n * This visitor function will be invoked for each cursor found by\n * clang_visitCursorChildren(). Its first argument is the cursor being\n * visited, its second argument is the parent visitor for that cursor,\n * and its third argument is the client data provided to\n * clang_visitCursorChildren().\n *\n * The visitor should return one of the \\c CXChildVisitResult values\n * to direct clang_visitCursorChildren().\n */\ntypedef enum CXChildVisitResult (*CXCursorVisitor)(CXCursor cursor,\n                                                   CXCursor parent,\n                                                   CXClientData client_data);\n\n/**\n * Visit the children of a particular cursor.\n *\n * This function visits all the direct children of the given cursor,\n * invoking the given \\p visitor function with the cursors of each\n * visited child. The traversal may be recursive, if the visitor returns\n * \\c CXChildVisit_Recurse. The traversal may also be ended prematurely, if\n * the visitor returns \\c CXChildVisit_Break.\n *\n * \\param parent the cursor whose child may be visited. All kinds of\n * cursors can be visited, including invalid cursors (which, by\n * definition, have no children).\n *\n * \\param visitor the visitor function that will be invoked for each\n * child of \\p parent.\n *\n * \\param client_data pointer data supplied by the client, which will\n * be passed to the visitor each time it is invoked.\n *\n * \\returns a non-zero value if the traversal was terminated\n * prematurely by the visitor returning \\c CXChildVisit_Break.\n */\nCINDEX_LINKAGE unsigned clang_visitChildren(CXCursor parent,\n                                            CXCursorVisitor visitor,\n                                            CXClientData client_data);\n#ifdef __has_feature\n#if __has_feature(blocks)\n/**\n * Visitor invoked for each cursor found by a traversal.\n *\n * This visitor block will be invoked for each cursor found by\n * clang_visitChildrenWithBlock(). Its first argument is the cursor being\n * visited, its second argument is the parent visitor for that cursor.\n *\n * The visitor should return one of the \\c CXChildVisitResult values\n * to direct clang_visitChildrenWithBlock().\n */\ntypedef enum CXChildVisitResult (^CXCursorVisitorBlock)(CXCursor cursor,\n                                                        CXCursor parent);\n\n/**\n * Visits the children of a cursor using the specified block.  Behaves\n * identically to clang_visitChildren() in all other respects.\n */\nCINDEX_LINKAGE unsigned\nclang_visitChildrenWithBlock(CXCursor parent, CXCursorVisitorBlock block);\n#endif\n#endif\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_CURSOR_XREF Cross-referencing in the AST\n *\n * These routines provide the ability to determine references within and\n * across translation units, by providing the names of the entities referenced\n * by cursors, follow reference cursors to the declarations they reference,\n * and associate declarations with their definitions.\n *\n * @{\n */\n\n/**\n * Retrieve a Unified Symbol Resolution (USR) for the entity referenced\n * by the given cursor.\n *\n * A Unified Symbol Resolution (USR) is a string that identifies a particular\n * entity (function, class, variable, etc.) within a program. USRs can be\n * compared across translation units to determine, e.g., when references in\n * one translation refer to an entity defined in another translation unit.\n */\nCINDEX_LINKAGE CXString clang_getCursorUSR(CXCursor);\n\n/**\n * Construct a USR for a specified Objective-C class.\n */\nCINDEX_LINKAGE CXString clang_constructUSR_ObjCClass(const char *class_name);\n\n/**\n * Construct a USR for a specified Objective-C category.\n */\nCINDEX_LINKAGE CXString clang_constructUSR_ObjCCategory(\n    const char *class_name, const char *category_name);\n\n/**\n * Construct a USR for a specified Objective-C protocol.\n */\nCINDEX_LINKAGE CXString\nclang_constructUSR_ObjCProtocol(const char *protocol_name);\n\n/**\n * Construct a USR for a specified Objective-C instance variable and\n *   the USR for its containing class.\n */\nCINDEX_LINKAGE CXString clang_constructUSR_ObjCIvar(const char *name,\n                                                    CXString classUSR);\n\n/**\n * Construct a USR for a specified Objective-C method and\n *   the USR for its containing class.\n */\nCINDEX_LINKAGE CXString clang_constructUSR_ObjCMethod(const char *name,\n                                                      unsigned isInstanceMethod,\n                                                      CXString classUSR);\n\n/**\n * Construct a USR for a specified Objective-C property and the USR\n *  for its containing class.\n */\nCINDEX_LINKAGE CXString clang_constructUSR_ObjCProperty(const char *property,\n                                                        CXString classUSR);\n\n/**\n * Retrieve a name for the entity referenced by this cursor.\n */\nCINDEX_LINKAGE CXString clang_getCursorSpelling(CXCursor);\n\n/**\n * Retrieve a range for a piece that forms the cursors spelling name.\n * Most of the times there is only one range for the complete spelling but for\n * Objective-C methods and Objective-C message expressions, there are multiple\n * pieces for each selector identifier.\n *\n * \\param pieceIndex the index of the spelling name piece. If this is greater\n * than the actual number of pieces, it will return a NULL (invalid) range.\n *\n * \\param options Reserved.\n */\nCINDEX_LINKAGE CXSourceRange clang_Cursor_getSpellingNameRange(\n    CXCursor, unsigned pieceIndex, unsigned options);\n\n/**\n * Opaque pointer representing a policy that controls pretty printing\n * for \\c clang_getCursorPrettyPrinted.\n */\ntypedef void *CXPrintingPolicy;\n\n/**\n * Properties for the printing policy.\n *\n * See \\c clang::PrintingPolicy for more information.\n */\nenum CXPrintingPolicyProperty {\n  CXPrintingPolicy_Indentation,\n  CXPrintingPolicy_SuppressSpecifiers,\n  CXPrintingPolicy_SuppressTagKeyword,\n  CXPrintingPolicy_IncludeTagDefinition,\n  CXPrintingPolicy_SuppressScope,\n  CXPrintingPolicy_SuppressUnwrittenScope,\n  CXPrintingPolicy_SuppressInitializers,\n  CXPrintingPolicy_ConstantArraySizeAsWritten,\n  CXPrintingPolicy_AnonymousTagLocations,\n  CXPrintingPolicy_SuppressStrongLifetime,\n  CXPrintingPolicy_SuppressLifetimeQualifiers,\n  CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors,\n  CXPrintingPolicy_Bool,\n  CXPrintingPolicy_Restrict,\n  CXPrintingPolicy_Alignof,\n  CXPrintingPolicy_UnderscoreAlignof,\n  CXPrintingPolicy_UseVoidForZeroParams,\n  CXPrintingPolicy_TerseOutput,\n  CXPrintingPolicy_PolishForDeclaration,\n  CXPrintingPolicy_Half,\n  CXPrintingPolicy_MSWChar,\n  CXPrintingPolicy_IncludeNewlines,\n  CXPrintingPolicy_MSVCFormatting,\n  CXPrintingPolicy_ConstantsAsWritten,\n  CXPrintingPolicy_SuppressImplicitBase,\n  CXPrintingPolicy_FullyQualifiedName,\n\n  CXPrintingPolicy_LastProperty = CXPrintingPolicy_FullyQualifiedName\n};\n\n/**\n * Get a property value for the given printing policy.\n */\nCINDEX_LINKAGE unsigned\nclang_PrintingPolicy_getProperty(CXPrintingPolicy Policy,\n                                 enum CXPrintingPolicyProperty Property);\n\n/**\n * Set a property value for the given printing policy.\n */\nCINDEX_LINKAGE void\nclang_PrintingPolicy_setProperty(CXPrintingPolicy Policy,\n                                 enum CXPrintingPolicyProperty Property,\n                                 unsigned Value);\n\n/**\n * Retrieve the default policy for the cursor.\n *\n * The policy should be released after use with \\c\n * clang_PrintingPolicy_dispose.\n */\nCINDEX_LINKAGE CXPrintingPolicy clang_getCursorPrintingPolicy(CXCursor);\n\n/**\n * Release a printing policy.\n */\nCINDEX_LINKAGE void clang_PrintingPolicy_dispose(CXPrintingPolicy Policy);\n\n/**\n * Pretty print declarations.\n *\n * \\param Cursor The cursor representing a declaration.\n *\n * \\param Policy The policy to control the entities being printed. If\n * NULL, a default policy is used.\n *\n * \\returns The pretty printed declaration or the empty string for\n * other cursors.\n */\nCINDEX_LINKAGE CXString clang_getCursorPrettyPrinted(CXCursor Cursor,\n                                                     CXPrintingPolicy Policy);\n\n/**\n * Retrieve the display name for the entity referenced by this cursor.\n *\n * The display name contains extra information that helps identify the cursor,\n * such as the parameters of a function or template or the arguments of a\n * class template specialization.\n */\nCINDEX_LINKAGE CXString clang_getCursorDisplayName(CXCursor);\n\n/** For a cursor that is a reference, retrieve a cursor representing the\n * entity that it references.\n *\n * Reference cursors refer to other entities in the AST. For example, an\n * Objective-C superclass reference cursor refers to an Objective-C class.\n * This function produces the cursor for the Objective-C class from the\n * cursor for the superclass reference. If the input cursor is a declaration or\n * definition, it returns that declaration or definition unchanged.\n * Otherwise, returns the NULL cursor.\n */\nCINDEX_LINKAGE CXCursor clang_getCursorReferenced(CXCursor);\n\n/**\n *  For a cursor that is either a reference to or a declaration\n *  of some entity, retrieve a cursor that describes the definition of\n *  that entity.\n *\n *  Some entities can be declared multiple times within a translation\n *  unit, but only one of those declarations can also be a\n *  definition. For example, given:\n *\n *  \\code\n *  int f(int, int);\n *  int g(int x, int y) { return f(x, y); }\n *  int f(int a, int b) { return a + b; }\n *  int f(int, int);\n *  \\endcode\n *\n *  there are three declarations of the function \"f\", but only the\n *  second one is a definition. The clang_getCursorDefinition()\n *  function will take any cursor pointing to a declaration of \"f\"\n *  (the first or fourth lines of the example) or a cursor referenced\n *  that uses \"f\" (the call to \"f' inside \"g\") and will return a\n *  declaration cursor pointing to the definition (the second \"f\"\n *  declaration).\n *\n *  If given a cursor for which there is no corresponding definition,\n *  e.g., because there is no definition of that entity within this\n *  translation unit, returns a NULL cursor.\n */\nCINDEX_LINKAGE CXCursor clang_getCursorDefinition(CXCursor);\n\n/**\n * Determine whether the declaration pointed to by this cursor\n * is also a definition of that entity.\n */\nCINDEX_LINKAGE unsigned clang_isCursorDefinition(CXCursor);\n\n/**\n * Retrieve the canonical cursor corresponding to the given cursor.\n *\n * In the C family of languages, many kinds of entities can be declared several\n * times within a single translation unit. For example, a structure type can\n * be forward-declared (possibly multiple times) and later defined:\n *\n * \\code\n * struct X;\n * struct X;\n * struct X {\n *   int member;\n * };\n * \\endcode\n *\n * The declarations and the definition of \\c X are represented by three\n * different cursors, all of which are declarations of the same underlying\n * entity. One of these cursor is considered the \"canonical\" cursor, which\n * is effectively the representative for the underlying entity. One can\n * determine if two cursors are declarations of the same underlying entity by\n * comparing their canonical cursors.\n *\n * \\returns The canonical cursor for the entity referred to by the given cursor.\n */\nCINDEX_LINKAGE CXCursor clang_getCanonicalCursor(CXCursor);\n\n/**\n * If the cursor points to a selector identifier in an Objective-C\n * method or message expression, this returns the selector index.\n *\n * After getting a cursor with #clang_getCursor, this can be called to\n * determine if the location points to a selector identifier.\n *\n * \\returns The selector index if the cursor is an Objective-C method or message\n * expression and the cursor is pointing to a selector identifier, or -1\n * otherwise.\n */\nCINDEX_LINKAGE int clang_Cursor_getObjCSelectorIndex(CXCursor);\n\n/**\n * Given a cursor pointing to a C++ method call or an Objective-C\n * message, returns non-zero if the method/message is \"dynamic\", meaning:\n *\n * For a C++ method: the call is virtual.\n * For an Objective-C message: the receiver is an object instance, not 'super'\n * or a specific class.\n *\n * If the method/message is \"static\" or the cursor does not point to a\n * method/message, it will return zero.\n */\nCINDEX_LINKAGE int clang_Cursor_isDynamicCall(CXCursor C);\n\n/**\n * Given a cursor pointing to an Objective-C message or property\n * reference, or C++ method call, returns the CXType of the receiver.\n */\nCINDEX_LINKAGE CXType clang_Cursor_getReceiverType(CXCursor C);\n\n/**\n * Property attributes for a \\c CXCursor_ObjCPropertyDecl.\n */\ntypedef enum {\n  CXObjCPropertyAttr_noattr = 0x00,\n  CXObjCPropertyAttr_readonly = 0x01,\n  CXObjCPropertyAttr_getter = 0x02,\n  CXObjCPropertyAttr_assign = 0x04,\n  CXObjCPropertyAttr_readwrite = 0x08,\n  CXObjCPropertyAttr_retain = 0x10,\n  CXObjCPropertyAttr_copy = 0x20,\n  CXObjCPropertyAttr_nonatomic = 0x40,\n  CXObjCPropertyAttr_setter = 0x80,\n  CXObjCPropertyAttr_atomic = 0x100,\n  CXObjCPropertyAttr_weak = 0x200,\n  CXObjCPropertyAttr_strong = 0x400,\n  CXObjCPropertyAttr_unsafe_unretained = 0x800,\n  CXObjCPropertyAttr_class = 0x1000\n} CXObjCPropertyAttrKind;\n\n/**\n * Given a cursor that represents a property declaration, return the\n * associated property attributes. The bits are formed from\n * \\c CXObjCPropertyAttrKind.\n *\n * \\param reserved Reserved for future use, pass 0.\n */\nCINDEX_LINKAGE unsigned\nclang_Cursor_getObjCPropertyAttributes(CXCursor C, unsigned reserved);\n\n/**\n * Given a cursor that represents a property declaration, return the\n * name of the method that implements the getter.\n */\nCINDEX_LINKAGE CXString clang_Cursor_getObjCPropertyGetterName(CXCursor C);\n\n/**\n * Given a cursor that represents a property declaration, return the\n * name of the method that implements the setter, if any.\n */\nCINDEX_LINKAGE CXString clang_Cursor_getObjCPropertySetterName(CXCursor C);\n\n/**\n * 'Qualifiers' written next to the return and parameter types in\n * Objective-C method declarations.\n */\ntypedef enum {\n  CXObjCDeclQualifier_None = 0x0,\n  CXObjCDeclQualifier_In = 0x1,\n  CXObjCDeclQualifier_Inout = 0x2,\n  CXObjCDeclQualifier_Out = 0x4,\n  CXObjCDeclQualifier_Bycopy = 0x8,\n  CXObjCDeclQualifier_Byref = 0x10,\n  CXObjCDeclQualifier_Oneway = 0x20\n} CXObjCDeclQualifierKind;\n\n/**\n * Given a cursor that represents an Objective-C method or parameter\n * declaration, return the associated Objective-C qualifiers for the return\n * type or the parameter respectively. The bits are formed from\n * CXObjCDeclQualifierKind.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_getObjCDeclQualifiers(CXCursor C);\n\n/**\n * Given a cursor that represents an Objective-C method or property\n * declaration, return non-zero if the declaration was affected by \"\\@optional\".\n * Returns zero if the cursor is not such a declaration or it is \"\\@required\".\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isObjCOptional(CXCursor C);\n\n/**\n * Returns non-zero if the given cursor is a variadic function or method.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isVariadic(CXCursor C);\n\n/**\n * Returns non-zero if the given cursor points to a symbol marked with\n * external_source_symbol attribute.\n *\n * \\param language If non-NULL, and the attribute is present, will be set to\n * the 'language' string from the attribute.\n *\n * \\param definedIn If non-NULL, and the attribute is present, will be set to\n * the 'definedIn' string from the attribute.\n *\n * \\param isGenerated If non-NULL, and the attribute is present, will be set to\n * non-zero if the 'generated_declaration' is set in the attribute.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isExternalSymbol(CXCursor C,\n                                                      CXString *language,\n                                                      CXString *definedIn,\n                                                      unsigned *isGenerated);\n\n/**\n * Given a cursor that represents a declaration, return the associated\n * comment's source range.  The range may include multiple consecutive comments\n * with whitespace in between.\n */\nCINDEX_LINKAGE CXSourceRange clang_Cursor_getCommentRange(CXCursor C);\n\n/**\n * Given a cursor that represents a declaration, return the associated\n * comment text, including comment markers.\n */\nCINDEX_LINKAGE CXString clang_Cursor_getRawCommentText(CXCursor C);\n\n/**\n * Given a cursor that represents a documentable entity (e.g.,\n * declaration), return the associated \\paragraph; otherwise return the\n * first paragraph.\n */\nCINDEX_LINKAGE CXString clang_Cursor_getBriefCommentText(CXCursor C);\n\n/**\n * @}\n */\n\n/** \\defgroup CINDEX_MANGLE Name Mangling API Functions\n *\n * @{\n */\n\n/**\n * Retrieve the CXString representing the mangled name of the cursor.\n */\nCINDEX_LINKAGE CXString clang_Cursor_getMangling(CXCursor);\n\n/**\n * Retrieve the CXStrings representing the mangled symbols of the C++\n * constructor or destructor at the cursor.\n */\nCINDEX_LINKAGE CXStringSet *clang_Cursor_getCXXManglings(CXCursor);\n\n/**\n * Retrieve the CXStrings representing the mangled symbols of the ObjC\n * class interface or implementation at the cursor.\n */\nCINDEX_LINKAGE CXStringSet *clang_Cursor_getObjCManglings(CXCursor);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_MODULE Module introspection\n *\n * The functions in this group provide access to information about modules.\n *\n * @{\n */\n\ntypedef void *CXModule;\n\n/**\n * Given a CXCursor_ModuleImportDecl cursor, return the associated module.\n */\nCINDEX_LINKAGE CXModule clang_Cursor_getModule(CXCursor C);\n\n/**\n * Given a CXFile header file, return the module that contains it, if one\n * exists.\n */\nCINDEX_LINKAGE CXModule clang_getModuleForFile(CXTranslationUnit, CXFile);\n\n/**\n * \\param Module a module object.\n *\n * \\returns the module file where the provided module object came from.\n */\nCINDEX_LINKAGE CXFile clang_Module_getASTFile(CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\returns the parent of a sub-module or NULL if the given module is top-level,\n * e.g. for 'std.vector' it will return the 'std' module.\n */\nCINDEX_LINKAGE CXModule clang_Module_getParent(CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\returns the name of the module, e.g. for the 'std.vector' sub-module it\n * will return \"vector\".\n */\nCINDEX_LINKAGE CXString clang_Module_getName(CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\returns the full name of the module, e.g. \"std.vector\".\n */\nCINDEX_LINKAGE CXString clang_Module_getFullName(CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\returns non-zero if the module is a system one.\n */\nCINDEX_LINKAGE int clang_Module_isSystem(CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\returns the number of top level headers associated with this module.\n */\nCINDEX_LINKAGE unsigned clang_Module_getNumTopLevelHeaders(CXTranslationUnit,\n                                                           CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\param Index top level header index (zero-based).\n *\n * \\returns the specified top level header associated with the module.\n */\nCINDEX_LINKAGE\nCXFile clang_Module_getTopLevelHeader(CXTranslationUnit, CXModule Module,\n                                      unsigned Index);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_CPP C++ AST introspection\n *\n * The routines in this group provide access information in the ASTs specific\n * to C++ language features.\n *\n * @{\n */\n\n/**\n * Determine if a C++ constructor is a converting constructor.\n */\nCINDEX_LINKAGE unsigned\nclang_CXXConstructor_isConvertingConstructor(CXCursor C);\n\n/**\n * Determine if a C++ constructor is a copy constructor.\n */\nCINDEX_LINKAGE unsigned clang_CXXConstructor_isCopyConstructor(CXCursor C);\n\n/**\n * Determine if a C++ constructor is the default constructor.\n */\nCINDEX_LINKAGE unsigned clang_CXXConstructor_isDefaultConstructor(CXCursor C);\n\n/**\n * Determine if a C++ constructor is a move constructor.\n */\nCINDEX_LINKAGE unsigned clang_CXXConstructor_isMoveConstructor(CXCursor C);\n\n/**\n * Determine if a C++ field is declared 'mutable'.\n */\nCINDEX_LINKAGE unsigned clang_CXXField_isMutable(CXCursor C);\n\n/**\n * Determine if a C++ method is declared '= default'.\n */\nCINDEX_LINKAGE unsigned clang_CXXMethod_isDefaulted(CXCursor C);\n\n/**\n * Determine if a C++ member function or member function template is\n * pure virtual.\n */\nCINDEX_LINKAGE unsigned clang_CXXMethod_isPureVirtual(CXCursor C);\n\n/**\n * Determine if a C++ member function or member function template is\n * declared 'static'.\n */\nCINDEX_LINKAGE unsigned clang_CXXMethod_isStatic(CXCursor C);\n\n/**\n * Determine if a C++ member function or member function template is\n * explicitly declared 'virtual' or if it overrides a virtual method from\n * one of the base classes.\n */\nCINDEX_LINKAGE unsigned clang_CXXMethod_isVirtual(CXCursor C);\n\n/**\n * Determine if a C++ record is abstract, i.e. whether a class or struct\n * has a pure virtual member function.\n */\nCINDEX_LINKAGE unsigned clang_CXXRecord_isAbstract(CXCursor C);\n\n/**\n * Determine if an enum declaration refers to a scoped enum.\n */\nCINDEX_LINKAGE unsigned clang_EnumDecl_isScoped(CXCursor C);\n\n/**\n * Determine if a C++ member function or member function template is\n * declared 'const'.\n */\nCINDEX_LINKAGE unsigned clang_CXXMethod_isConst(CXCursor C);\n\n/**\n * Given a cursor that represents a template, determine\n * the cursor kind of the specializations would be generated by instantiating\n * the template.\n *\n * This routine can be used to determine what flavor of function template,\n * class template, or class template partial specialization is stored in the\n * cursor. For example, it can describe whether a class template cursor is\n * declared with \"struct\", \"class\" or \"union\".\n *\n * \\param C The cursor to query. This cursor should represent a template\n * declaration.\n *\n * \\returns The cursor kind of the specializations that would be generated\n * by instantiating the template \\p C. If \\p C is not a template, returns\n * \\c CXCursor_NoDeclFound.\n */\nCINDEX_LINKAGE enum CXCursorKind clang_getTemplateCursorKind(CXCursor C);\n\n/**\n * Given a cursor that may represent a specialization or instantiation\n * of a template, retrieve the cursor that represents the template that it\n * specializes or from which it was instantiated.\n *\n * This routine determines the template involved both for explicit\n * specializations of templates and for implicit instantiations of the template,\n * both of which are referred to as \"specializations\". For a class template\n * specialization (e.g., \\c std::vector<bool>), this routine will return\n * either the primary template (\\c std::vector) or, if the specialization was\n * instantiated from a class template partial specialization, the class template\n * partial specialization. For a class template partial specialization and a\n * function template specialization (including instantiations), this\n * this routine will return the specialized template.\n *\n * For members of a class template (e.g., member functions, member classes, or\n * static data members), returns the specialized or instantiated member.\n * Although not strictly \"templates\" in the C++ language, members of class\n * templates have the same notions of specializations and instantiations that\n * templates do, so this routine treats them similarly.\n *\n * \\param C A cursor that may be a specialization of a template or a member\n * of a template.\n *\n * \\returns If the given cursor is a specialization or instantiation of a\n * template or a member thereof, the template or member that it specializes or\n * from which it was instantiated. Otherwise, returns a NULL cursor.\n */\nCINDEX_LINKAGE CXCursor clang_getSpecializedCursorTemplate(CXCursor C);\n\n/**\n * Given a cursor that references something else, return the source range\n * covering that reference.\n *\n * \\param C A cursor pointing to a member reference, a declaration reference, or\n * an operator call.\n * \\param NameFlags A bitset with three independent flags:\n * CXNameRange_WantQualifier, CXNameRange_WantTemplateArgs, and\n * CXNameRange_WantSinglePiece.\n * \\param PieceIndex For contiguous names or when passing the flag\n * CXNameRange_WantSinglePiece, only one piece with index 0 is\n * available. When the CXNameRange_WantSinglePiece flag is not passed for a\n * non-contiguous names, this index can be used to retrieve the individual\n * pieces of the name. See also CXNameRange_WantSinglePiece.\n *\n * \\returns The piece of the name pointed to by the given cursor. If there is no\n * name, or if the PieceIndex is out-of-range, a null-cursor will be returned.\n */\nCINDEX_LINKAGE CXSourceRange clang_getCursorReferenceNameRange(\n    CXCursor C, unsigned NameFlags, unsigned PieceIndex);\n\nenum CXNameRefFlags {\n  /**\n   * Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the\n   * range.\n   */\n  CXNameRange_WantQualifier = 0x1,\n\n  /**\n   * Include the explicit template arguments, e.g. \\<int> in x.f<int>,\n   * in the range.\n   */\n  CXNameRange_WantTemplateArgs = 0x2,\n\n  /**\n   * If the name is non-contiguous, return the full spanning range.\n   *\n   * Non-contiguous names occur in Objective-C when a selector with two or more\n   * parameters is used, or in C++ when using an operator:\n   * \\code\n   * [object doSomething:here withValue:there]; // Objective-C\n   * return some_vector[1]; // C++\n   * \\endcode\n   */\n  CXNameRange_WantSinglePiece = 0x4\n};\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_LEX Token extraction and manipulation\n *\n * The routines in this group provide access to the tokens within a\n * translation unit, along with a semantic mapping of those tokens to\n * their corresponding cursors.\n *\n * @{\n */\n\n/**\n * Describes a kind of token.\n */\ntypedef enum CXTokenKind {\n  /**\n   * A token that contains some kind of punctuation.\n   */\n  CXToken_Punctuation,\n\n  /**\n   * A language keyword.\n   */\n  CXToken_Keyword,\n\n  /**\n   * An identifier (that is not a keyword).\n   */\n  CXToken_Identifier,\n\n  /**\n   * A numeric, string, or character literal.\n   */\n  CXToken_Literal,\n\n  /**\n   * A comment.\n   */\n  CXToken_Comment\n} CXTokenKind;\n\n/**\n * Describes a single preprocessing token.\n */\ntypedef struct {\n  unsigned int_data[4];\n  void *ptr_data;\n} CXToken;\n\n/**\n * Get the raw lexical token starting with the given location.\n *\n * \\param TU the translation unit whose text is being tokenized.\n *\n * \\param Location the source location with which the token starts.\n *\n * \\returns The token starting with the given location or NULL if no such token\n * exist. The returned pointer must be freed with clang_disposeTokens before the\n * translation unit is destroyed.\n */\nCINDEX_LINKAGE CXToken *clang_getToken(CXTranslationUnit TU,\n                                       CXSourceLocation Location);\n\n/**\n * Determine the kind of the given token.\n */\nCINDEX_LINKAGE CXTokenKind clang_getTokenKind(CXToken);\n\n/**\n * Determine the spelling of the given token.\n *\n * The spelling of a token is the textual representation of that token, e.g.,\n * the text of an identifier or keyword.\n */\nCINDEX_LINKAGE CXString clang_getTokenSpelling(CXTranslationUnit, CXToken);\n\n/**\n * Retrieve the source location of the given token.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getTokenLocation(CXTranslationUnit,\n                                                       CXToken);\n\n/**\n * Retrieve a source range that covers the given token.\n */\nCINDEX_LINKAGE CXSourceRange clang_getTokenExtent(CXTranslationUnit, CXToken);\n\n/**\n * Tokenize the source code described by the given range into raw\n * lexical tokens.\n *\n * \\param TU the translation unit whose text is being tokenized.\n *\n * \\param Range the source range in which text should be tokenized. All of the\n * tokens produced by tokenization will fall within this source range,\n *\n * \\param Tokens this pointer will be set to point to the array of tokens\n * that occur within the given source range. The returned pointer must be\n * freed with clang_disposeTokens() before the translation unit is destroyed.\n *\n * \\param NumTokens will be set to the number of tokens in the \\c *Tokens\n * array.\n *\n */\nCINDEX_LINKAGE void clang_tokenize(CXTranslationUnit TU, CXSourceRange Range,\n                                   CXToken **Tokens, unsigned *NumTokens);\n\n/**\n * Annotate the given set of tokens by providing cursors for each token\n * that can be mapped to a specific entity within the abstract syntax tree.\n *\n * This token-annotation routine is equivalent to invoking\n * clang_getCursor() for the source locations of each of the\n * tokens. The cursors provided are filtered, so that only those\n * cursors that have a direct correspondence to the token are\n * accepted. For example, given a function call \\c f(x),\n * clang_getCursor() would provide the following cursors:\n *\n *   * when the cursor is over the 'f', a DeclRefExpr cursor referring to 'f'.\n *   * when the cursor is over the '(' or the ')', a CallExpr referring to 'f'.\n *   * when the cursor is over the 'x', a DeclRefExpr cursor referring to 'x'.\n *\n * Only the first and last of these cursors will occur within the\n * annotate, since the tokens \"f\" and \"x' directly refer to a function\n * and a variable, respectively, but the parentheses are just a small\n * part of the full syntax of the function call expression, which is\n * not provided as an annotation.\n *\n * \\param TU the translation unit that owns the given tokens.\n *\n * \\param Tokens the set of tokens to annotate.\n *\n * \\param NumTokens the number of tokens in \\p Tokens.\n *\n * \\param Cursors an array of \\p NumTokens cursors, whose contents will be\n * replaced with the cursors corresponding to each token.\n */\nCINDEX_LINKAGE void clang_annotateTokens(CXTranslationUnit TU, CXToken *Tokens,\n                                         unsigned NumTokens, CXCursor *Cursors);\n\n/**\n * Free the given set of tokens.\n */\nCINDEX_LINKAGE void clang_disposeTokens(CXTranslationUnit TU, CXToken *Tokens,\n                                        unsigned NumTokens);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_DEBUG Debugging facilities\n *\n * These routines are used for testing and debugging, only, and should not\n * be relied upon.\n *\n * @{\n */\n\n/* for debug/testing */\nCINDEX_LINKAGE CXString clang_getCursorKindSpelling(enum CXCursorKind Kind);\nCINDEX_LINKAGE void clang_getDefinitionSpellingAndExtent(\n    CXCursor, const char **startBuf, const char **endBuf, unsigned *startLine,\n    unsigned *startColumn, unsigned *endLine, unsigned *endColumn);\nCINDEX_LINKAGE void clang_enableStackTraces(void);\nCINDEX_LINKAGE void clang_executeOnThread(void (*fn)(void *), void *user_data,\n                                          unsigned stack_size);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_CODE_COMPLET Code completion\n *\n * Code completion involves taking an (incomplete) source file, along with\n * knowledge of where the user is actively editing that file, and suggesting\n * syntactically- and semantically-valid constructs that the user might want to\n * use at that particular point in the source code. These data structures and\n * routines provide support for code completion.\n *\n * @{\n */\n\n/**\n * A semantic string that describes a code-completion result.\n *\n * A semantic string that describes the formatting of a code-completion\n * result as a single \"template\" of text that should be inserted into the\n * source buffer when a particular code-completion result is selected.\n * Each semantic string is made up of some number of \"chunks\", each of which\n * contains some text along with a description of what that text means, e.g.,\n * the name of the entity being referenced, whether the text chunk is part of\n * the template, or whether it is a \"placeholder\" that the user should replace\n * with actual code,of a specific kind. See \\c CXCompletionChunkKind for a\n * description of the different kinds of chunks.\n */\ntypedef void *CXCompletionString;\n\n/**\n * A single result of code completion.\n */\ntypedef struct {\n  /**\n   * The kind of entity that this completion refers to.\n   *\n   * The cursor kind will be a macro, keyword, or a declaration (one of the\n   * *Decl cursor kinds), describing the entity that the completion is\n   * referring to.\n   *\n   * \\todo In the future, we would like to provide a full cursor, to allow\n   * the client to extract additional information from declaration.\n   */\n  enum CXCursorKind CursorKind;\n\n  /**\n   * The code-completion string that describes how to insert this\n   * code-completion result into the editing buffer.\n   */\n  CXCompletionString CompletionString;\n} CXCompletionResult;\n\n/**\n * Describes a single piece of text within a code-completion string.\n *\n * Each \"chunk\" within a code-completion string (\\c CXCompletionString) is\n * either a piece of text with a specific \"kind\" that describes how that text\n * should be interpreted by the client or is another completion string.\n */\nenum CXCompletionChunkKind {\n  /**\n   * A code-completion string that describes \"optional\" text that\n   * could be a part of the template (but is not required).\n   *\n   * The Optional chunk is the only kind of chunk that has a code-completion\n   * string for its representation, which is accessible via\n   * \\c clang_getCompletionChunkCompletionString(). The code-completion string\n   * describes an additional part of the template that is completely optional.\n   * For example, optional chunks can be used to describe the placeholders for\n   * arguments that match up with defaulted function parameters, e.g. given:\n   *\n   * \\code\n   * void f(int x, float y = 3.14, double z = 2.71828);\n   * \\endcode\n   *\n   * The code-completion string for this function would contain:\n   *   - a TypedText chunk for \"f\".\n   *   - a LeftParen chunk for \"(\".\n   *   - a Placeholder chunk for \"int x\"\n   *   - an Optional chunk containing the remaining defaulted arguments, e.g.,\n   *       - a Comma chunk for \",\"\n   *       - a Placeholder chunk for \"float y\"\n   *       - an Optional chunk containing the last defaulted argument:\n   *           - a Comma chunk for \",\"\n   *           - a Placeholder chunk for \"double z\"\n   *   - a RightParen chunk for \")\"\n   *\n   * There are many ways to handle Optional chunks. Two simple approaches are:\n   *   - Completely ignore optional chunks, in which case the template for the\n   *     function \"f\" would only include the first parameter (\"int x\").\n   *   - Fully expand all optional chunks, in which case the template for the\n   *     function \"f\" would have all of the parameters.\n   */\n  CXCompletionChunk_Optional,\n  /**\n   * Text that a user would be expected to type to get this\n   * code-completion result.\n   *\n   * There will be exactly one \"typed text\" chunk in a semantic string, which\n   * will typically provide the spelling of a keyword or the name of a\n   * declaration that could be used at the current code point. Clients are\n   * expected to filter the code-completion results based on the text in this\n   * chunk.\n   */\n  CXCompletionChunk_TypedText,\n  /**\n   * Text that should be inserted as part of a code-completion result.\n   *\n   * A \"text\" chunk represents text that is part of the template to be\n   * inserted into user code should this particular code-completion result\n   * be selected.\n   */\n  CXCompletionChunk_Text,\n  /**\n   * Placeholder text that should be replaced by the user.\n   *\n   * A \"placeholder\" chunk marks a place where the user should insert text\n   * into the code-completion template. For example, placeholders might mark\n   * the function parameters for a function declaration, to indicate that the\n   * user should provide arguments for each of those parameters. The actual\n   * text in a placeholder is a suggestion for the text to display before\n   * the user replaces the placeholder with real code.\n   */\n  CXCompletionChunk_Placeholder,\n  /**\n   * Informative text that should be displayed but never inserted as\n   * part of the template.\n   *\n   * An \"informative\" chunk contains annotations that can be displayed to\n   * help the user decide whether a particular code-completion result is the\n   * right option, but which is not part of the actual template to be inserted\n   * by code completion.\n   */\n  CXCompletionChunk_Informative,\n  /**\n   * Text that describes the current parameter when code-completion is\n   * referring to function call, message send, or template specialization.\n   *\n   * A \"current parameter\" chunk occurs when code-completion is providing\n   * information about a parameter corresponding to the argument at the\n   * code-completion point. For example, given a function\n   *\n   * \\code\n   * int add(int x, int y);\n   * \\endcode\n   *\n   * and the source code \\c add(, where the code-completion point is after the\n   * \"(\", the code-completion string will contain a \"current parameter\" chunk\n   * for \"int x\", indicating that the current argument will initialize that\n   * parameter. After typing further, to \\c add(17, (where the code-completion\n   * point is after the \",\"), the code-completion string will contain a\n   * \"current parameter\" chunk to \"int y\".\n   */\n  CXCompletionChunk_CurrentParameter,\n  /**\n   * A left parenthesis ('('), used to initiate a function call or\n   * signal the beginning of a function parameter list.\n   */\n  CXCompletionChunk_LeftParen,\n  /**\n   * A right parenthesis (')'), used to finish a function call or\n   * signal the end of a function parameter list.\n   */\n  CXCompletionChunk_RightParen,\n  /**\n   * A left bracket ('[').\n   */\n  CXCompletionChunk_LeftBracket,\n  /**\n   * A right bracket (']').\n   */\n  CXCompletionChunk_RightBracket,\n  /**\n   * A left brace ('{').\n   */\n  CXCompletionChunk_LeftBrace,\n  /**\n   * A right brace ('}').\n   */\n  CXCompletionChunk_RightBrace,\n  /**\n   * A left angle bracket ('<').\n   */\n  CXCompletionChunk_LeftAngle,\n  /**\n   * A right angle bracket ('>').\n   */\n  CXCompletionChunk_RightAngle,\n  /**\n   * A comma separator (',').\n   */\n  CXCompletionChunk_Comma,\n  /**\n   * Text that specifies the result type of a given result.\n   *\n   * This special kind of informative chunk is not meant to be inserted into\n   * the text buffer. Rather, it is meant to illustrate the type that an\n   * expression using the given completion string would have.\n   */\n  CXCompletionChunk_ResultType,\n  /**\n   * A colon (':').\n   */\n  CXCompletionChunk_Colon,\n  /**\n   * A semicolon (';').\n   */\n  CXCompletionChunk_SemiColon,\n  /**\n   * An '=' sign.\n   */\n  CXCompletionChunk_Equal,\n  /**\n   * Horizontal space (' ').\n   */\n  CXCompletionChunk_HorizontalSpace,\n  /**\n   * Vertical space ('\\\\n'), after which it is generally a good idea to\n   * perform indentation.\n   */\n  CXCompletionChunk_VerticalSpace\n};\n\n/**\n * Determine the kind of a particular chunk within a completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param chunk_number the 0-based index of the chunk in the completion string.\n *\n * \\returns the kind of the chunk at the index \\c chunk_number.\n */\nCINDEX_LINKAGE enum CXCompletionChunkKind\nclang_getCompletionChunkKind(CXCompletionString completion_string,\n                             unsigned chunk_number);\n\n/**\n * Retrieve the text associated with a particular chunk within a\n * completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param chunk_number the 0-based index of the chunk in the completion string.\n *\n * \\returns the text associated with the chunk at index \\c chunk_number.\n */\nCINDEX_LINKAGE CXString clang_getCompletionChunkText(\n    CXCompletionString completion_string, unsigned chunk_number);\n\n/**\n * Retrieve the completion string associated with a particular chunk\n * within a completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param chunk_number the 0-based index of the chunk in the completion string.\n *\n * \\returns the completion string associated with the chunk at index\n * \\c chunk_number.\n */\nCINDEX_LINKAGE CXCompletionString clang_getCompletionChunkCompletionString(\n    CXCompletionString completion_string, unsigned chunk_number);\n\n/**\n * Retrieve the number of chunks in the given code-completion string.\n */\nCINDEX_LINKAGE unsigned\nclang_getNumCompletionChunks(CXCompletionString completion_string);\n\n/**\n * Determine the priority of this code completion.\n *\n * The priority of a code completion indicates how likely it is that this\n * particular completion is the completion that the user will select. The\n * priority is selected by various internal heuristics.\n *\n * \\param completion_string The completion string to query.\n *\n * \\returns The priority of this completion string. Smaller values indicate\n * higher-priority (more likely) completions.\n */\nCINDEX_LINKAGE unsigned\nclang_getCompletionPriority(CXCompletionString completion_string);\n\n/**\n * Determine the availability of the entity that this code-completion\n * string refers to.\n *\n * \\param completion_string The completion string to query.\n *\n * \\returns The availability of the completion string.\n */\nCINDEX_LINKAGE enum CXAvailabilityKind\nclang_getCompletionAvailability(CXCompletionString completion_string);\n\n/**\n * Retrieve the number of annotations associated with the given\n * completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\returns the number of annotations associated with the given completion\n * string.\n */\nCINDEX_LINKAGE unsigned\nclang_getCompletionNumAnnotations(CXCompletionString completion_string);\n\n/**\n * Retrieve the annotation associated with the given completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param annotation_number the 0-based index of the annotation of the\n * completion string.\n *\n * \\returns annotation string associated with the completion at index\n * \\c annotation_number, or a NULL string if that annotation is not available.\n */\nCINDEX_LINKAGE CXString clang_getCompletionAnnotation(\n    CXCompletionString completion_string, unsigned annotation_number);\n\n/**\n * Retrieve the parent context of the given completion string.\n *\n * The parent context of a completion string is the semantic parent of\n * the declaration (if any) that the code completion represents. For example,\n * a code completion for an Objective-C method would have the method's class\n * or protocol as its context.\n *\n * \\param completion_string The code completion string whose parent is\n * being queried.\n *\n * \\param kind DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.\n *\n * \\returns The name of the completion parent, e.g., \"NSObject\" if\n * the completion string represents a method in the NSObject class.\n */\nCINDEX_LINKAGE CXString clang_getCompletionParent(\n    CXCompletionString completion_string, enum CXCursorKind *kind);\n\n/**\n * Retrieve the brief documentation comment attached to the declaration\n * that corresponds to the given completion string.\n */\nCINDEX_LINKAGE CXString\nclang_getCompletionBriefComment(CXCompletionString completion_string);\n\n/**\n * Retrieve a completion string for an arbitrary declaration or macro\n * definition cursor.\n *\n * \\param cursor The cursor to query.\n *\n * \\returns A non-context-sensitive completion string for declaration and macro\n * definition cursors, or NULL for other kinds of cursors.\n */\nCINDEX_LINKAGE CXCompletionString\nclang_getCursorCompletionString(CXCursor cursor);\n\n/**\n * Contains the results of code-completion.\n *\n * This data structure contains the results of code completion, as\n * produced by \\c clang_codeCompleteAt(). Its contents must be freed by\n * \\c clang_disposeCodeCompleteResults.\n */\ntypedef struct {\n  /**\n   * The code-completion results.\n   */\n  CXCompletionResult *Results;\n\n  /**\n   * The number of code-completion results stored in the\n   * \\c Results array.\n   */\n  unsigned NumResults;\n} CXCodeCompleteResults;\n\n/**\n * Retrieve the number of fix-its for the given completion index.\n *\n * Calling this makes sense only if CXCodeComplete_IncludeCompletionsWithFixIts\n * option was set.\n *\n * \\param results The structure keeping all completion results\n *\n * \\param completion_index The index of the completion\n *\n * \\return The number of fix-its which must be applied before the completion at\n * completion_index can be applied\n */\nCINDEX_LINKAGE unsigned\nclang_getCompletionNumFixIts(CXCodeCompleteResults *results,\n                             unsigned completion_index);\n\n/**\n * Fix-its that *must* be applied before inserting the text for the\n * corresponding completion.\n *\n * By default, clang_codeCompleteAt() only returns completions with empty\n * fix-its. Extra completions with non-empty fix-its should be explicitly\n * requested by setting CXCodeComplete_IncludeCompletionsWithFixIts.\n *\n * For the clients to be able to compute position of the cursor after applying\n * fix-its, the following conditions are guaranteed to hold for\n * replacement_range of the stored fix-its:\n *  - Ranges in the fix-its are guaranteed to never contain the completion\n *  point (or identifier under completion point, if any) inside them, except\n *  at the start or at the end of the range.\n *  - If a fix-it range starts or ends with completion point (or starts or\n *  ends after the identifier under completion point), it will contain at\n *  least one character. It allows to unambiguously recompute completion\n *  point after applying the fix-it.\n *\n * The intuition is that provided fix-its change code around the identifier we\n * complete, but are not allowed to touch the identifier itself or the\n * completion point. One example of completions with corrections are the ones\n * replacing '.' with '->' and vice versa:\n *\n * std::unique_ptr<std::vector<int>> vec_ptr;\n * In 'vec_ptr.^', one of the completions is 'push_back', it requires\n * replacing '.' with '->'.\n * In 'vec_ptr->^', one of the completions is 'release', it requires\n * replacing '->' with '.'.\n *\n * \\param results The structure keeping all completion results\n *\n * \\param completion_index The index of the completion\n *\n * \\param fixit_index The index of the fix-it for the completion at\n * completion_index\n *\n * \\param replacement_range The fix-it range that must be replaced before the\n * completion at completion_index can be applied\n *\n * \\returns The fix-it string that must replace the code at replacement_range\n * before the completion at completion_index can be applied\n */\nCINDEX_LINKAGE CXString clang_getCompletionFixIt(\n    CXCodeCompleteResults *results, unsigned completion_index,\n    unsigned fixit_index, CXSourceRange *replacement_range);\n\n/**\n * Flags that can be passed to \\c clang_codeCompleteAt() to\n * modify its behavior.\n *\n * The enumerators in this enumeration can be bitwise-OR'd together to\n * provide multiple options to \\c clang_codeCompleteAt().\n */\nenum CXCodeComplete_Flags {\n  /**\n   * Whether to include macros within the set of code\n   * completions returned.\n   */\n  CXCodeComplete_IncludeMacros = 0x01,\n\n  /**\n   * Whether to include code patterns for language constructs\n   * within the set of code completions, e.g., for loops.\n   */\n  CXCodeComplete_IncludeCodePatterns = 0x02,\n\n  /**\n   * Whether to include brief documentation within the set of code\n   * completions returned.\n   */\n  CXCodeComplete_IncludeBriefComments = 0x04,\n\n  /**\n   * Whether to speed up completion by omitting top- or namespace-level entities\n   * defined in the preamble. There's no guarantee any particular entity is\n   * omitted. This may be useful if the headers are indexed externally.\n   */\n  CXCodeComplete_SkipPreamble = 0x08,\n\n  /**\n   * Whether to include completions with small\n   * fix-its, e.g. change '.' to '->' on member access, etc.\n   */\n  CXCodeComplete_IncludeCompletionsWithFixIts = 0x10\n};\n\n/**\n * Bits that represent the context under which completion is occurring.\n *\n * The enumerators in this enumeration may be bitwise-OR'd together if multiple\n * contexts are occurring simultaneously.\n */\nenum CXCompletionContext {\n  /**\n   * The context for completions is unexposed, as only Clang results\n   * should be included. (This is equivalent to having no context bits set.)\n   */\n  CXCompletionContext_Unexposed = 0,\n\n  /**\n   * Completions for any possible type should be included in the results.\n   */\n  CXCompletionContext_AnyType = 1 << 0,\n\n  /**\n   * Completions for any possible value (variables, function calls, etc.)\n   * should be included in the results.\n   */\n  CXCompletionContext_AnyValue = 1 << 1,\n  /**\n   * Completions for values that resolve to an Objective-C object should\n   * be included in the results.\n   */\n  CXCompletionContext_ObjCObjectValue = 1 << 2,\n  /**\n   * Completions for values that resolve to an Objective-C selector\n   * should be included in the results.\n   */\n  CXCompletionContext_ObjCSelectorValue = 1 << 3,\n  /**\n   * Completions for values that resolve to a C++ class type should be\n   * included in the results.\n   */\n  CXCompletionContext_CXXClassTypeValue = 1 << 4,\n\n  /**\n   * Completions for fields of the member being accessed using the dot\n   * operator should be included in the results.\n   */\n  CXCompletionContext_DotMemberAccess = 1 << 5,\n  /**\n   * Completions for fields of the member being accessed using the arrow\n   * operator should be included in the results.\n   */\n  CXCompletionContext_ArrowMemberAccess = 1 << 6,\n  /**\n   * Completions for properties of the Objective-C object being accessed\n   * using the dot operator should be included in the results.\n   */\n  CXCompletionContext_ObjCPropertyAccess = 1 << 7,\n\n  /**\n   * Completions for enum tags should be included in the results.\n   */\n  CXCompletionContext_EnumTag = 1 << 8,\n  /**\n   * Completions for union tags should be included in the results.\n   */\n  CXCompletionContext_UnionTag = 1 << 9,\n  /**\n   * Completions for struct tags should be included in the results.\n   */\n  CXCompletionContext_StructTag = 1 << 10,\n\n  /**\n   * Completions for C++ class names should be included in the results.\n   */\n  CXCompletionContext_ClassTag = 1 << 11,\n  /**\n   * Completions for C++ namespaces and namespace aliases should be\n   * included in the results.\n   */\n  CXCompletionContext_Namespace = 1 << 12,\n  /**\n   * Completions for C++ nested name specifiers should be included in\n   * the results.\n   */\n  CXCompletionContext_NestedNameSpecifier = 1 << 13,\n\n  /**\n   * Completions for Objective-C interfaces (classes) should be included\n   * in the results.\n   */\n  CXCompletionContext_ObjCInterface = 1 << 14,\n  /**\n   * Completions for Objective-C protocols should be included in\n   * the results.\n   */\n  CXCompletionContext_ObjCProtocol = 1 << 15,\n  /**\n   * Completions for Objective-C categories should be included in\n   * the results.\n   */\n  CXCompletionContext_ObjCCategory = 1 << 16,\n  /**\n   * Completions for Objective-C instance messages should be included\n   * in the results.\n   */\n  CXCompletionContext_ObjCInstanceMessage = 1 << 17,\n  /**\n   * Completions for Objective-C class messages should be included in\n   * the results.\n   */\n  CXCompletionContext_ObjCClassMessage = 1 << 18,\n  /**\n   * Completions for Objective-C selector names should be included in\n   * the results.\n   */\n  CXCompletionContext_ObjCSelectorName = 1 << 19,\n\n  /**\n   * Completions for preprocessor macro names should be included in\n   * the results.\n   */\n  CXCompletionContext_MacroName = 1 << 20,\n\n  /**\n   * Natural language completions should be included in the results.\n   */\n  CXCompletionContext_NaturalLanguage = 1 << 21,\n\n  /**\n   * #include file completions should be included in the results.\n   */\n  CXCompletionContext_IncludedFile = 1 << 22,\n\n  /**\n   * The current context is unknown, so set all contexts.\n   */\n  CXCompletionContext_Unknown = ((1 << 23) - 1)\n};\n\n/**\n * Returns a default set of code-completion options that can be\n * passed to\\c clang_codeCompleteAt().\n */\nCINDEX_LINKAGE unsigned clang_defaultCodeCompleteOptions(void);\n\n/**\n * Perform code completion at a given location in a translation unit.\n *\n * This function performs code completion at a particular file, line, and\n * column within source code, providing results that suggest potential\n * code snippets based on the context of the completion. The basic model\n * for code completion is that Clang will parse a complete source file,\n * performing syntax checking up to the location where code-completion has\n * been requested. At that point, a special code-completion token is passed\n * to the parser, which recognizes this token and determines, based on the\n * current location in the C/Objective-C/C++ grammar and the state of\n * semantic analysis, what completions to provide. These completions are\n * returned via a new \\c CXCodeCompleteResults structure.\n *\n * Code completion itself is meant to be triggered by the client when the\n * user types punctuation characters or whitespace, at which point the\n * code-completion location will coincide with the cursor. For example, if \\c p\n * is a pointer, code-completion might be triggered after the \"-\" and then\n * after the \">\" in \\c p->. When the code-completion location is after the \">\",\n * the completion results will provide, e.g., the members of the struct that\n * \"p\" points to. The client is responsible for placing the cursor at the\n * beginning of the token currently being typed, then filtering the results\n * based on the contents of the token. For example, when code-completing for\n * the expression \\c p->get, the client should provide the location just after\n * the \">\" (e.g., pointing at the \"g\") to this code-completion hook. Then, the\n * client can filter the results based on the current token text (\"get\"), only\n * showing those results that start with \"get\". The intent of this interface\n * is to separate the relatively high-latency acquisition of code-completion\n * results from the filtering of results on a per-character basis, which must\n * have a lower latency.\n *\n * \\param TU The translation unit in which code-completion should\n * occur. The source files for this translation unit need not be\n * completely up-to-date (and the contents of those source files may\n * be overridden via \\p unsaved_files). Cursors referring into the\n * translation unit may be invalidated by this invocation.\n *\n * \\param complete_filename The name of the source file where code\n * completion should be performed. This filename may be any file\n * included in the translation unit.\n *\n * \\param complete_line The line at which code-completion should occur.\n *\n * \\param complete_column The column at which code-completion should occur.\n * Note that the column should point just after the syntactic construct that\n * initiated code completion, and not in the middle of a lexical token.\n *\n * \\param unsaved_files the Files that have not yet been saved to disk\n * but may be required for parsing or code completion, including the\n * contents of those files.  The contents and name of these files (as\n * specified by CXUnsavedFile) are copied when necessary, so the\n * client only needs to guarantee their validity until the call to\n * this function returns.\n *\n * \\param num_unsaved_files The number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param options Extra options that control the behavior of code\n * completion, expressed as a bitwise OR of the enumerators of the\n * CXCodeComplete_Flags enumeration. The\n * \\c clang_defaultCodeCompleteOptions() function returns a default set\n * of code-completion options.\n *\n * \\returns If successful, a new \\c CXCodeCompleteResults structure\n * containing code-completion results, which should eventually be\n * freed with \\c clang_disposeCodeCompleteResults(). If code\n * completion fails, returns NULL.\n */\nCINDEX_LINKAGE\nCXCodeCompleteResults *\nclang_codeCompleteAt(CXTranslationUnit TU, const char *complete_filename,\n                     unsigned complete_line, unsigned complete_column,\n                     struct CXUnsavedFile *unsaved_files,\n                     unsigned num_unsaved_files, unsigned options);\n\n/**\n * Sort the code-completion results in case-insensitive alphabetical\n * order.\n *\n * \\param Results The set of results to sort.\n * \\param NumResults The number of results in \\p Results.\n */\nCINDEX_LINKAGE\nvoid clang_sortCodeCompletionResults(CXCompletionResult *Results,\n                                     unsigned NumResults);\n\n/**\n * Free the given set of code-completion results.\n */\nCINDEX_LINKAGE\nvoid clang_disposeCodeCompleteResults(CXCodeCompleteResults *Results);\n\n/**\n * Determine the number of diagnostics produced prior to the\n * location where code completion was performed.\n */\nCINDEX_LINKAGE\nunsigned clang_codeCompleteGetNumDiagnostics(CXCodeCompleteResults *Results);\n\n/**\n * Retrieve a diagnostic associated with the given code completion.\n *\n * \\param Results the code completion results to query.\n * \\param Index the zero-based diagnostic number to retrieve.\n *\n * \\returns the requested diagnostic. This diagnostic must be freed\n * via a call to \\c clang_disposeDiagnostic().\n */\nCINDEX_LINKAGE\nCXDiagnostic clang_codeCompleteGetDiagnostic(CXCodeCompleteResults *Results,\n                                             unsigned Index);\n\n/**\n * Determines what completions are appropriate for the context\n * the given code completion.\n *\n * \\param Results the code completion results to query\n *\n * \\returns the kinds of completions that are appropriate for use\n * along with the given code completion results.\n */\nCINDEX_LINKAGE\nunsigned long long\nclang_codeCompleteGetContexts(CXCodeCompleteResults *Results);\n\n/**\n * Returns the cursor kind for the container for the current code\n * completion context. The container is only guaranteed to be set for\n * contexts where a container exists (i.e. member accesses or Objective-C\n * message sends); if there is not a container, this function will return\n * CXCursor_InvalidCode.\n *\n * \\param Results the code completion results to query\n *\n * \\param IsIncomplete on return, this value will be false if Clang has complete\n * information about the container. If Clang does not have complete\n * information, this value will be true.\n *\n * \\returns the container kind, or CXCursor_InvalidCode if there is not a\n * container\n */\nCINDEX_LINKAGE\nenum CXCursorKind\nclang_codeCompleteGetContainerKind(CXCodeCompleteResults *Results,\n                                   unsigned *IsIncomplete);\n\n/**\n * Returns the USR for the container for the current code completion\n * context. If there is not a container for the current context, this\n * function will return the empty string.\n *\n * \\param Results the code completion results to query\n *\n * \\returns the USR for the container\n */\nCINDEX_LINKAGE\nCXString clang_codeCompleteGetContainerUSR(CXCodeCompleteResults *Results);\n\n/**\n * Returns the currently-entered selector for an Objective-C message\n * send, formatted like \"initWithFoo:bar:\". Only guaranteed to return a\n * non-empty string for CXCompletionContext_ObjCInstanceMessage and\n * CXCompletionContext_ObjCClassMessage.\n *\n * \\param Results the code completion results to query\n *\n * \\returns the selector (or partial selector) that has been entered thus far\n * for an Objective-C message send.\n */\nCINDEX_LINKAGE\nCXString clang_codeCompleteGetObjCSelector(CXCodeCompleteResults *Results);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_MISC Miscellaneous utility functions\n *\n * @{\n */\n\n/**\n * Return a version string, suitable for showing to a user, but not\n *        intended to be parsed (the format is not guaranteed to be stable).\n */\nCINDEX_LINKAGE CXString clang_getClangVersion(void);\n\n/**\n * Enable/disable crash recovery.\n *\n * \\param isEnabled Flag to indicate if crash recovery is enabled.  A non-zero\n *        value enables crash recovery, while 0 disables it.\n */\nCINDEX_LINKAGE void clang_toggleCrashRecovery(unsigned isEnabled);\n\n/**\n * Visitor invoked for each file in a translation unit\n *        (used with clang_getInclusions()).\n *\n * This visitor function will be invoked by clang_getInclusions() for each\n * file included (either at the top-level or by \\#include directives) within\n * a translation unit.  The first argument is the file being included, and\n * the second and third arguments provide the inclusion stack.  The\n * array is sorted in order of immediate inclusion.  For example,\n * the first element refers to the location that included 'included_file'.\n */\ntypedef void (*CXInclusionVisitor)(CXFile included_file,\n                                   CXSourceLocation *inclusion_stack,\n                                   unsigned include_len,\n                                   CXClientData client_data);\n\n/**\n * Visit the set of preprocessor inclusions in a translation unit.\n *   The visitor function is called with the provided data for every included\n *   file.  This does not include headers included by the PCH file (unless one\n *   is inspecting the inclusions in the PCH file itself).\n */\nCINDEX_LINKAGE void clang_getInclusions(CXTranslationUnit tu,\n                                        CXInclusionVisitor visitor,\n                                        CXClientData client_data);\n\ntypedef enum {\n  CXEval_Int = 1,\n  CXEval_Float = 2,\n  CXEval_ObjCStrLiteral = 3,\n  CXEval_StrLiteral = 4,\n  CXEval_CFStr = 5,\n  CXEval_Other = 6,\n\n  CXEval_UnExposed = 0\n\n} CXEvalResultKind;\n\n/**\n * Evaluation result of a cursor\n */\ntypedef void *CXEvalResult;\n\n/**\n * If cursor is a statement declaration tries to evaluate the\n * statement and if its variable, tries to evaluate its initializer,\n * into its corresponding type.\n * If it's an expression, tries to evaluate the expression.\n */\nCINDEX_LINKAGE CXEvalResult clang_Cursor_Evaluate(CXCursor C);\n\n/**\n * Returns the kind of the evaluated result.\n */\nCINDEX_LINKAGE CXEvalResultKind clang_EvalResult_getKind(CXEvalResult E);\n\n/**\n * Returns the evaluation result as integer if the\n * kind is Int.\n */\nCINDEX_LINKAGE int clang_EvalResult_getAsInt(CXEvalResult E);\n\n/**\n * Returns the evaluation result as a long long integer if the\n * kind is Int. This prevents overflows that may happen if the result is\n * returned with clang_EvalResult_getAsInt.\n */\nCINDEX_LINKAGE long long clang_EvalResult_getAsLongLong(CXEvalResult E);\n\n/**\n * Returns a non-zero value if the kind is Int and the evaluation\n * result resulted in an unsigned integer.\n */\nCINDEX_LINKAGE unsigned clang_EvalResult_isUnsignedInt(CXEvalResult E);\n\n/**\n * Returns the evaluation result as an unsigned integer if\n * the kind is Int and clang_EvalResult_isUnsignedInt is non-zero.\n */\nCINDEX_LINKAGE unsigned long long\nclang_EvalResult_getAsUnsigned(CXEvalResult E);\n\n/**\n * Returns the evaluation result as double if the\n * kind is double.\n */\nCINDEX_LINKAGE double clang_EvalResult_getAsDouble(CXEvalResult E);\n\n/**\n * Returns the evaluation result as a constant string if the\n * kind is other than Int or float. User must not free this pointer,\n * instead call clang_EvalResult_dispose on the CXEvalResult returned\n * by clang_Cursor_Evaluate.\n */\nCINDEX_LINKAGE const char *clang_EvalResult_getAsStr(CXEvalResult E);\n\n/**\n * Disposes the created Eval memory.\n */\nCINDEX_LINKAGE void clang_EvalResult_dispose(CXEvalResult E);\n/**\n * @}\n */\n\n/** \\defgroup CINDEX_REMAPPING Remapping functions\n *\n * @{\n */\n\n/**\n * A remapping of original source files and their translated files.\n */\ntypedef void *CXRemapping;\n\n/**\n * Retrieve a remapping.\n *\n * \\param path the path that contains metadata about remappings.\n *\n * \\returns the requested remapping. This remapping must be freed\n * via a call to \\c clang_remap_dispose(). Can return NULL if an error occurred.\n */\nCINDEX_LINKAGE CXRemapping clang_getRemappings(const char *path);\n\n/**\n * Retrieve a remapping.\n *\n * \\param filePaths pointer to an array of file paths containing remapping info.\n *\n * \\param numFiles number of file paths.\n *\n * \\returns the requested remapping. This remapping must be freed\n * via a call to \\c clang_remap_dispose(). Can return NULL if an error occurred.\n */\nCINDEX_LINKAGE\nCXRemapping clang_getRemappingsFromFileList(const char **filePaths,\n                                            unsigned numFiles);\n\n/**\n * Determine the number of remappings.\n */\nCINDEX_LINKAGE unsigned clang_remap_getNumFiles(CXRemapping);\n\n/**\n * Get the original and the associated filename from the remapping.\n *\n * \\param original If non-NULL, will be set to the original filename.\n *\n * \\param transformed If non-NULL, will be set to the filename that the original\n * is associated with.\n */\nCINDEX_LINKAGE void clang_remap_getFilenames(CXRemapping, unsigned index,\n                                             CXString *original,\n                                             CXString *transformed);\n\n/**\n * Dispose the remapping.\n */\nCINDEX_LINKAGE void clang_remap_dispose(CXRemapping);\n\n/**\n * @}\n */\n\n/** \\defgroup CINDEX_HIGH Higher level API functions\n *\n * @{\n */\n\nenum CXVisitorResult { CXVisit_Break, CXVisit_Continue };\n\ntypedef struct CXCursorAndRangeVisitor {\n  void *context;\n  enum CXVisitorResult (*visit)(void *context, CXCursor, CXSourceRange);\n} CXCursorAndRangeVisitor;\n\ntypedef enum {\n  /**\n   * Function returned successfully.\n   */\n  CXResult_Success = 0,\n  /**\n   * One of the parameters was invalid for the function.\n   */\n  CXResult_Invalid = 1,\n  /**\n   * The function was terminated by a callback (e.g. it returned\n   * CXVisit_Break)\n   */\n  CXResult_VisitBreak = 2\n\n} CXResult;\n\n/**\n * Find references of a declaration in a specific file.\n *\n * \\param cursor pointing to a declaration or a reference of one.\n *\n * \\param file to search for references.\n *\n * \\param visitor callback that will receive pairs of CXCursor/CXSourceRange for\n * each reference found.\n * The CXSourceRange will point inside the file; if the reference is inside\n * a macro (and not a macro argument) the CXSourceRange will be invalid.\n *\n * \\returns one of the CXResult enumerators.\n */\nCINDEX_LINKAGE CXResult clang_findReferencesInFile(\n    CXCursor cursor, CXFile file, CXCursorAndRangeVisitor visitor);\n\n/**\n * Find #import/#include directives in a specific file.\n *\n * \\param TU translation unit containing the file to query.\n *\n * \\param file to search for #import/#include directives.\n *\n * \\param visitor callback that will receive pairs of CXCursor/CXSourceRange for\n * each directive found.\n *\n * \\returns one of the CXResult enumerators.\n */\nCINDEX_LINKAGE CXResult clang_findIncludesInFile(\n    CXTranslationUnit TU, CXFile file, CXCursorAndRangeVisitor visitor);\n\n#ifdef __has_feature\n#if __has_feature(blocks)\n\ntypedef enum CXVisitorResult (^CXCursorAndRangeVisitorBlock)(CXCursor,\n                                                             CXSourceRange);\n\nCINDEX_LINKAGE\nCXResult clang_findReferencesInFileWithBlock(CXCursor, CXFile,\n                                             CXCursorAndRangeVisitorBlock);\n\nCINDEX_LINKAGE\nCXResult clang_findIncludesInFileWithBlock(CXTranslationUnit, CXFile,\n                                           CXCursorAndRangeVisitorBlock);\n\n#endif\n#endif\n\n/**\n * The client's data object that is associated with a CXFile.\n */\ntypedef void *CXIdxClientFile;\n\n/**\n * The client's data object that is associated with a semantic entity.\n */\ntypedef void *CXIdxClientEntity;\n\n/**\n * The client's data object that is associated with a semantic container\n * of entities.\n */\ntypedef void *CXIdxClientContainer;\n\n/**\n * The client's data object that is associated with an AST file (PCH\n * or module).\n */\ntypedef void *CXIdxClientASTFile;\n\n/**\n * Source location passed to index callbacks.\n */\ntypedef struct {\n  void *ptr_data[2];\n  unsigned int_data;\n} CXIdxLoc;\n\n/**\n * Data for ppIncludedFile callback.\n */\ntypedef struct {\n  /**\n   * Location of '#' in the \\#include/\\#import directive.\n   */\n  CXIdxLoc hashLoc;\n  /**\n   * Filename as written in the \\#include/\\#import directive.\n   */\n  const char *filename;\n  /**\n   * The actual file that the \\#include/\\#import directive resolved to.\n   */\n  CXFile file;\n  int isImport;\n  int isAngled;\n  /**\n   * Non-zero if the directive was automatically turned into a module\n   * import.\n   */\n  int isModuleImport;\n} CXIdxIncludedFileInfo;\n\n/**\n * Data for IndexerCallbacks#importedASTFile.\n */\ntypedef struct {\n  /**\n   * Top level AST file containing the imported PCH, module or submodule.\n   */\n  CXFile file;\n  /**\n   * The imported module or NULL if the AST file is a PCH.\n   */\n  CXModule module;\n  /**\n   * Location where the file is imported. Applicable only for modules.\n   */\n  CXIdxLoc loc;\n  /**\n   * Non-zero if an inclusion directive was automatically turned into\n   * a module import. Applicable only for modules.\n   */\n  int isImplicit;\n\n} CXIdxImportedASTFileInfo;\n\ntypedef enum {\n  CXIdxEntity_Unexposed = 0,\n  CXIdxEntity_Typedef = 1,\n  CXIdxEntity_Function = 2,\n  CXIdxEntity_Variable = 3,\n  CXIdxEntity_Field = 4,\n  CXIdxEntity_EnumConstant = 5,\n\n  CXIdxEntity_ObjCClass = 6,\n  CXIdxEntity_ObjCProtocol = 7,\n  CXIdxEntity_ObjCCategory = 8,\n\n  CXIdxEntity_ObjCInstanceMethod = 9,\n  CXIdxEntity_ObjCClassMethod = 10,\n  CXIdxEntity_ObjCProperty = 11,\n  CXIdxEntity_ObjCIvar = 12,\n\n  CXIdxEntity_Enum = 13,\n  CXIdxEntity_Struct = 14,\n  CXIdxEntity_Union = 15,\n\n  CXIdxEntity_CXXClass = 16,\n  CXIdxEntity_CXXNamespace = 17,\n  CXIdxEntity_CXXNamespaceAlias = 18,\n  CXIdxEntity_CXXStaticVariable = 19,\n  CXIdxEntity_CXXStaticMethod = 20,\n  CXIdxEntity_CXXInstanceMethod = 21,\n  CXIdxEntity_CXXConstructor = 22,\n  CXIdxEntity_CXXDestructor = 23,\n  CXIdxEntity_CXXConversionFunction = 24,\n  CXIdxEntity_CXXTypeAlias = 25,\n  CXIdxEntity_CXXInterface = 26\n\n} CXIdxEntityKind;\n\ntypedef enum {\n  CXIdxEntityLang_None = 0,\n  CXIdxEntityLang_C = 1,\n  CXIdxEntityLang_ObjC = 2,\n  CXIdxEntityLang_CXX = 3,\n  CXIdxEntityLang_Swift = 4\n} CXIdxEntityLanguage;\n\n/**\n * Extra C++ template information for an entity. This can apply to:\n * CXIdxEntity_Function\n * CXIdxEntity_CXXClass\n * CXIdxEntity_CXXStaticMethod\n * CXIdxEntity_CXXInstanceMethod\n * CXIdxEntity_CXXConstructor\n * CXIdxEntity_CXXConversionFunction\n * CXIdxEntity_CXXTypeAlias\n */\ntypedef enum {\n  CXIdxEntity_NonTemplate = 0,\n  CXIdxEntity_Template = 1,\n  CXIdxEntity_TemplatePartialSpecialization = 2,\n  CXIdxEntity_TemplateSpecialization = 3\n} CXIdxEntityCXXTemplateKind;\n\ntypedef enum {\n  CXIdxAttr_Unexposed = 0,\n  CXIdxAttr_IBAction = 1,\n  CXIdxAttr_IBOutlet = 2,\n  CXIdxAttr_IBOutletCollection = 3\n} CXIdxAttrKind;\n\ntypedef struct {\n  CXIdxAttrKind kind;\n  CXCursor cursor;\n  CXIdxLoc loc;\n} CXIdxAttrInfo;\n\ntypedef struct {\n  CXIdxEntityKind kind;\n  CXIdxEntityCXXTemplateKind templateKind;\n  CXIdxEntityLanguage lang;\n  const char *name;\n  const char *USR;\n  CXCursor cursor;\n  const CXIdxAttrInfo *const *attributes;\n  unsigned numAttributes;\n} CXIdxEntityInfo;\n\ntypedef struct {\n  CXCursor cursor;\n} CXIdxContainerInfo;\n\ntypedef struct {\n  const CXIdxAttrInfo *attrInfo;\n  const CXIdxEntityInfo *objcClass;\n  CXCursor classCursor;\n  CXIdxLoc classLoc;\n} CXIdxIBOutletCollectionAttrInfo;\n\ntypedef enum { CXIdxDeclFlag_Skipped = 0x1 } CXIdxDeclInfoFlags;\n\ntypedef struct {\n  const CXIdxEntityInfo *entityInfo;\n  CXCursor cursor;\n  CXIdxLoc loc;\n  const CXIdxContainerInfo *semanticContainer;\n  /**\n   * Generally same as #semanticContainer but can be different in\n   * cases like out-of-line C++ member functions.\n   */\n  const CXIdxContainerInfo *lexicalContainer;\n  int isRedeclaration;\n  int isDefinition;\n  int isContainer;\n  const CXIdxContainerInfo *declAsContainer;\n  /**\n   * Whether the declaration exists in code or was created implicitly\n   * by the compiler, e.g. implicit Objective-C methods for properties.\n   */\n  int isImplicit;\n  const CXIdxAttrInfo *const *attributes;\n  unsigned numAttributes;\n\n  unsigned flags;\n\n} CXIdxDeclInfo;\n\ntypedef enum {\n  CXIdxObjCContainer_ForwardRef = 0,\n  CXIdxObjCContainer_Interface = 1,\n  CXIdxObjCContainer_Implementation = 2\n} CXIdxObjCContainerKind;\n\ntypedef struct {\n  const CXIdxDeclInfo *declInfo;\n  CXIdxObjCContainerKind kind;\n} CXIdxObjCContainerDeclInfo;\n\ntypedef struct {\n  const CXIdxEntityInfo *base;\n  CXCursor cursor;\n  CXIdxLoc loc;\n} CXIdxBaseClassInfo;\n\ntypedef struct {\n  const CXIdxEntityInfo *protocol;\n  CXCursor cursor;\n  CXIdxLoc loc;\n} CXIdxObjCProtocolRefInfo;\n\ntypedef struct {\n  const CXIdxObjCProtocolRefInfo *const *protocols;\n  unsigned numProtocols;\n} CXIdxObjCProtocolRefListInfo;\n\ntypedef struct {\n  const CXIdxObjCContainerDeclInfo *containerInfo;\n  const CXIdxBaseClassInfo *superInfo;\n  const CXIdxObjCProtocolRefListInfo *protocols;\n} CXIdxObjCInterfaceDeclInfo;\n\ntypedef struct {\n  const CXIdxObjCContainerDeclInfo *containerInfo;\n  const CXIdxEntityInfo *objcClass;\n  CXCursor classCursor;\n  CXIdxLoc classLoc;\n  const CXIdxObjCProtocolRefListInfo *protocols;\n} CXIdxObjCCategoryDeclInfo;\n\ntypedef struct {\n  const CXIdxDeclInfo *declInfo;\n  const CXIdxEntityInfo *getter;\n  const CXIdxEntityInfo *setter;\n} CXIdxObjCPropertyDeclInfo;\n\ntypedef struct {\n  const CXIdxDeclInfo *declInfo;\n  const CXIdxBaseClassInfo *const *bases;\n  unsigned numBases;\n} CXIdxCXXClassDeclInfo;\n\n/**\n * Data for IndexerCallbacks#indexEntityReference.\n *\n * This may be deprecated in a future version as this duplicates\n * the \\c CXSymbolRole_Implicit bit in \\c CXSymbolRole.\n */\ntypedef enum {\n  /**\n   * The entity is referenced directly in user's code.\n   */\n  CXIdxEntityRef_Direct = 1,\n  /**\n   * An implicit reference, e.g. a reference of an Objective-C method\n   * via the dot syntax.\n   */\n  CXIdxEntityRef_Implicit = 2\n} CXIdxEntityRefKind;\n\n/**\n * Roles that are attributed to symbol occurrences.\n *\n * Internal: this currently mirrors low 9 bits of clang::index::SymbolRole with\n * higher bits zeroed. These high bits may be exposed in the future.\n */\ntypedef enum {\n  CXSymbolRole_None = 0,\n  CXSymbolRole_Declaration = 1 << 0,\n  CXSymbolRole_Definition = 1 << 1,\n  CXSymbolRole_Reference = 1 << 2,\n  CXSymbolRole_Read = 1 << 3,\n  CXSymbolRole_Write = 1 << 4,\n  CXSymbolRole_Call = 1 << 5,\n  CXSymbolRole_Dynamic = 1 << 6,\n  CXSymbolRole_AddressOf = 1 << 7,\n  CXSymbolRole_Implicit = 1 << 8\n} CXSymbolRole;\n\n/**\n * Data for IndexerCallbacks#indexEntityReference.\n */\ntypedef struct {\n  CXIdxEntityRefKind kind;\n  /**\n   * Reference cursor.\n   */\n  CXCursor cursor;\n  CXIdxLoc loc;\n  /**\n   * The entity that gets referenced.\n   */\n  const CXIdxEntityInfo *referencedEntity;\n  /**\n   * Immediate \"parent\" of the reference. For example:\n   *\n   * \\code\n   * Foo *var;\n   * \\endcode\n   *\n   * The parent of reference of type 'Foo' is the variable 'var'.\n   * For references inside statement bodies of functions/methods,\n   * the parentEntity will be the function/method.\n   */\n  const CXIdxEntityInfo *parentEntity;\n  /**\n   * Lexical container context of the reference.\n   */\n  const CXIdxContainerInfo *container;\n  /**\n   * Sets of symbol roles of the reference.\n   */\n  CXSymbolRole role;\n} CXIdxEntityRefInfo;\n\n/**\n * A group of callbacks used by #clang_indexSourceFile and\n * #clang_indexTranslationUnit.\n */\ntypedef struct {\n  /**\n   * Called periodically to check whether indexing should be aborted.\n   * Should return 0 to continue, and non-zero to abort.\n   */\n  int (*abortQuery)(CXClientData client_data, void *reserved);\n\n  /**\n   * Called at the end of indexing; passes the complete diagnostic set.\n   */\n  void (*diagnostic)(CXClientData client_data, CXDiagnosticSet, void *reserved);\n\n  CXIdxClientFile (*enteredMainFile)(CXClientData client_data, CXFile mainFile,\n                                     void *reserved);\n\n  /**\n   * Called when a file gets \\#included/\\#imported.\n   */\n  CXIdxClientFile (*ppIncludedFile)(CXClientData client_data,\n                                    const CXIdxIncludedFileInfo *);\n\n  /**\n   * Called when a AST file (PCH or module) gets imported.\n   *\n   * AST files will not get indexed (there will not be callbacks to index all\n   * the entities in an AST file). The recommended action is that, if the AST\n   * file is not already indexed, to initiate a new indexing job specific to\n   * the AST file.\n   */\n  CXIdxClientASTFile (*importedASTFile)(CXClientData client_data,\n                                        const CXIdxImportedASTFileInfo *);\n\n  /**\n   * Called at the beginning of indexing a translation unit.\n   */\n  CXIdxClientContainer (*startedTranslationUnit)(CXClientData client_data,\n                                                 void *reserved);\n\n  void (*indexDeclaration)(CXClientData client_data, const CXIdxDeclInfo *);\n\n  /**\n   * Called to index a reference of an entity.\n   */\n  void (*indexEntityReference)(CXClientData client_data,\n                               const CXIdxEntityRefInfo *);\n\n} IndexerCallbacks;\n\nCINDEX_LINKAGE int clang_index_isEntityObjCContainerKind(CXIdxEntityKind);\nCINDEX_LINKAGE const CXIdxObjCContainerDeclInfo *\nclang_index_getObjCContainerDeclInfo(const CXIdxDeclInfo *);\n\nCINDEX_LINKAGE const CXIdxObjCInterfaceDeclInfo *\nclang_index_getObjCInterfaceDeclInfo(const CXIdxDeclInfo *);\n\nCINDEX_LINKAGE\nconst CXIdxObjCCategoryDeclInfo *\nclang_index_getObjCCategoryDeclInfo(const CXIdxDeclInfo *);\n\nCINDEX_LINKAGE const CXIdxObjCProtocolRefListInfo *\nclang_index_getObjCProtocolRefListInfo(const CXIdxDeclInfo *);\n\nCINDEX_LINKAGE const CXIdxObjCPropertyDeclInfo *\nclang_index_getObjCPropertyDeclInfo(const CXIdxDeclInfo *);\n\nCINDEX_LINKAGE const CXIdxIBOutletCollectionAttrInfo *\nclang_index_getIBOutletCollectionAttrInfo(const CXIdxAttrInfo *);\n\nCINDEX_LINKAGE const CXIdxCXXClassDeclInfo *\nclang_index_getCXXClassDeclInfo(const CXIdxDeclInfo *);\n\n/**\n * For retrieving a custom CXIdxClientContainer attached to a\n * container.\n */\nCINDEX_LINKAGE CXIdxClientContainer\nclang_index_getClientContainer(const CXIdxContainerInfo *);\n\n/**\n * For setting a custom CXIdxClientContainer attached to a\n * container.\n */\nCINDEX_LINKAGE void clang_index_setClientContainer(const CXIdxContainerInfo *,\n                                                   CXIdxClientContainer);\n\n/**\n * For retrieving a custom CXIdxClientEntity attached to an entity.\n */\nCINDEX_LINKAGE CXIdxClientEntity\nclang_index_getClientEntity(const CXIdxEntityInfo *);\n\n/**\n * For setting a custom CXIdxClientEntity attached to an entity.\n */\nCINDEX_LINKAGE void clang_index_setClientEntity(const CXIdxEntityInfo *,\n                                                CXIdxClientEntity);\n\n/**\n * An indexing action/session, to be applied to one or multiple\n * translation units.\n */\ntypedef void *CXIndexAction;\n\n/**\n * An indexing action/session, to be applied to one or multiple\n * translation units.\n *\n * \\param CIdx The index object with which the index action will be associated.\n */\nCINDEX_LINKAGE CXIndexAction clang_IndexAction_create(CXIndex CIdx);\n\n/**\n * Destroy the given index action.\n *\n * The index action must not be destroyed until all of the translation units\n * created within that index action have been destroyed.\n */\nCINDEX_LINKAGE void clang_IndexAction_dispose(CXIndexAction);\n\ntypedef enum {\n  /**\n   * Used to indicate that no special indexing options are needed.\n   */\n  CXIndexOpt_None = 0x0,\n\n  /**\n   * Used to indicate that IndexerCallbacks#indexEntityReference should\n   * be invoked for only one reference of an entity per source file that does\n   * not also include a declaration/definition of the entity.\n   */\n  CXIndexOpt_SuppressRedundantRefs = 0x1,\n\n  /**\n   * Function-local symbols should be indexed. If this is not set\n   * function-local symbols will be ignored.\n   */\n  CXIndexOpt_IndexFunctionLocalSymbols = 0x2,\n\n  /**\n   * Implicit function/class template instantiations should be indexed.\n   * If this is not set, implicit instantiations will be ignored.\n   */\n  CXIndexOpt_IndexImplicitTemplateInstantiations = 0x4,\n\n  /**\n   * Suppress all compiler warnings when parsing for indexing.\n   */\n  CXIndexOpt_SuppressWarnings = 0x8,\n\n  /**\n   * Skip a function/method body that was already parsed during an\n   * indexing session associated with a \\c CXIndexAction object.\n   * Bodies in system headers are always skipped.\n   */\n  CXIndexOpt_SkipParsedBodiesInSession = 0x10\n\n} CXIndexOptFlags;\n\n/**\n * Index the given source file and the translation unit corresponding\n * to that file via callbacks implemented through #IndexerCallbacks.\n *\n * \\param client_data pointer data supplied by the client, which will\n * be passed to the invoked callbacks.\n *\n * \\param index_callbacks Pointer to indexing callbacks that the client\n * implements.\n *\n * \\param index_callbacks_size Size of #IndexerCallbacks structure that gets\n * passed in index_callbacks.\n *\n * \\param index_options A bitmask of options that affects how indexing is\n * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.\n *\n * \\param[out] out_TU pointer to store a \\c CXTranslationUnit that can be\n * reused after indexing is finished. Set to \\c NULL if you do not require it.\n *\n * \\returns 0 on success or if there were errors from which the compiler could\n * recover.  If there is a failure from which there is no recovery, returns\n * a non-zero \\c CXErrorCode.\n *\n * The rest of the parameters are the same as #clang_parseTranslationUnit.\n */\nCINDEX_LINKAGE int clang_indexSourceFile(\n    CXIndexAction, CXClientData client_data, IndexerCallbacks *index_callbacks,\n    unsigned index_callbacks_size, unsigned index_options,\n    const char *source_filename, const char *const *command_line_args,\n    int num_command_line_args, struct CXUnsavedFile *unsaved_files,\n    unsigned num_unsaved_files, CXTranslationUnit *out_TU, unsigned TU_options);\n\n/**\n * Same as clang_indexSourceFile but requires a full command line\n * for \\c command_line_args including argv[0]. This is useful if the standard\n * library paths are relative to the binary.\n */\nCINDEX_LINKAGE int clang_indexSourceFileFullArgv(\n    CXIndexAction, CXClientData client_data, IndexerCallbacks *index_callbacks,\n    unsigned index_callbacks_size, unsigned index_options,\n    const char *source_filename, const char *const *command_line_args,\n    int num_command_line_args, struct CXUnsavedFile *unsaved_files,\n    unsigned num_unsaved_files, CXTranslationUnit *out_TU, unsigned TU_options);\n\n/**\n * Index the given translation unit via callbacks implemented through\n * #IndexerCallbacks.\n *\n * The order of callback invocations is not guaranteed to be the same as\n * when indexing a source file. The high level order will be:\n *\n *   -Preprocessor callbacks invocations\n *   -Declaration/reference callbacks invocations\n *   -Diagnostic callback invocations\n *\n * The parameters are the same as #clang_indexSourceFile.\n *\n * \\returns If there is a failure from which there is no recovery, returns\n * non-zero, otherwise returns 0.\n */\nCINDEX_LINKAGE int clang_indexTranslationUnit(\n    CXIndexAction, CXClientData client_data, IndexerCallbacks *index_callbacks,\n    unsigned index_callbacks_size, unsigned index_options, CXTranslationUnit);\n\n/**\n * Retrieve the CXIdxFile, file, line, column, and offset represented by\n * the given CXIdxLoc.\n *\n * If the location refers into a macro expansion, retrieves the\n * location of the macro expansion and if it refers into a macro argument\n * retrieves the location of the argument.\n */\nCINDEX_LINKAGE void clang_indexLoc_getFileLocation(CXIdxLoc loc,\n                                                   CXIdxClientFile *indexFile,\n                                                   CXFile *file, unsigned *line,\n                                                   unsigned *column,\n                                                   unsigned *offset);\n\n/**\n * Retrieve the CXSourceLocation represented by the given CXIdxLoc.\n */\nCINDEX_LINKAGE\nCXSourceLocation clang_indexLoc_getCXSourceLocation(CXIdxLoc loc);\n\n/**\n * Visitor invoked for each field found by a traversal.\n *\n * This visitor function will be invoked for each field found by\n * \\c clang_Type_visitFields. Its first argument is the cursor being\n * visited, its second argument is the client data provided to\n * \\c clang_Type_visitFields.\n *\n * The visitor should return one of the \\c CXVisitorResult values\n * to direct \\c clang_Type_visitFields.\n */\ntypedef enum CXVisitorResult (*CXFieldVisitor)(CXCursor C,\n                                               CXClientData client_data);\n\n/**\n * Visit the fields of a particular type.\n *\n * This function visits all the direct fields of the given cursor,\n * invoking the given \\p visitor function with the cursors of each\n * visited field. The traversal may be ended prematurely, if\n * the visitor returns \\c CXFieldVisit_Break.\n *\n * \\param T the record type whose field may be visited.\n *\n * \\param visitor the visitor function that will be invoked for each\n * field of \\p T.\n *\n * \\param client_data pointer data supplied by the client, which will\n * be passed to the visitor each time it is invoked.\n *\n * \\returns a non-zero value if the traversal was terminated\n * prematurely by the visitor returning \\c CXFieldVisit_Break.\n */\nCINDEX_LINKAGE unsigned clang_Type_visitFields(CXType T, CXFieldVisitor visitor,\n                                               CXClientData client_data);\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n\nLLVM_CLANG_C_EXTERN_C_END\n\n#endif\n"}, "72": {"id": 72, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Sema.h", "content": "//===--- Sema.h - Semantic Analysis & AST Building --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the Sema class, which performs semantic analysis and\n// builds ASTs.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_SEMA_H\n#define LLVM_CLANG_SEMA_SEMA_H\n\n#include \"clang/AST/ASTConcept.h\"\n#include \"clang/AST/ASTFwd.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/Availability.h\"\n#include \"clang/AST/ComparisonCategories.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprConcepts.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/ExprOpenMP.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/LocInfoType.h\"\n#include \"clang/AST/MangleNumberingContext.h\"\n#include \"clang/AST/NSAPI.h\"\n#include \"clang/AST/PrettyPrinter.h\"\n#include \"clang/AST/StmtCXX.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/AST/TypeOrdering.h\"\n#include \"clang/Basic/BitmaskEnum.h\"\n#include \"clang/Basic/ExpressionTraits.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/OpenCLOptions.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/PragmaKinds.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/TemplateKinds.h\"\n#include \"clang/Basic/TypeTraits.h\"\n#include \"clang/Sema/AnalysisBasedWarnings.h\"\n#include \"clang/Sema/CleanupInfo.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"clang/Sema/ExternalSemaSource.h\"\n#include \"clang/Sema/IdentifierResolver.h\"\n#include \"clang/Sema/ObjCMethodList.h\"\n#include \"clang/Sema/Ownership.h\"\n#include \"clang/Sema/Scope.h\"\n#include \"clang/Sema/SemaConcept.h\"\n#include \"clang/Sema/TypoCorrection.h\"\n#include \"clang/Sema/Weak.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/Frontend/OpenMP/OMPConstants.h\"\n#include <deque>\n#include <memory>\n#include <string>\n#include <tuple>\n#include <vector>\n\nnamespace llvm {\n  class APSInt;\n  template <typename ValueT> struct DenseMapInfo;\n  template <typename ValueT, typename ValueInfoT> class DenseSet;\n  class SmallBitVector;\n  struct InlineAsmIdentifierInfo;\n}\n\nnamespace clang {\n  class ADLResult;\n  class ASTConsumer;\n  class ASTContext;\n  class ASTMutationListener;\n  class ASTReader;\n  class ASTWriter;\n  class ArrayType;\n  class ParsedAttr;\n  class BindingDecl;\n  class BlockDecl;\n  class CapturedDecl;\n  class CXXBasePath;\n  class CXXBasePaths;\n  class CXXBindTemporaryExpr;\n  typedef SmallVector<CXXBaseSpecifier*, 4> CXXCastPath;\n  class CXXConstructorDecl;\n  class CXXConversionDecl;\n  class CXXDeleteExpr;\n  class CXXDestructorDecl;\n  class CXXFieldCollector;\n  class CXXMemberCallExpr;\n  class CXXMethodDecl;\n  class CXXScopeSpec;\n  class CXXTemporary;\n  class CXXTryStmt;\n  class CallExpr;\n  class ClassTemplateDecl;\n  class ClassTemplatePartialSpecializationDecl;\n  class ClassTemplateSpecializationDecl;\n  class VarTemplatePartialSpecializationDecl;\n  class CodeCompleteConsumer;\n  class CodeCompletionAllocator;\n  class CodeCompletionTUInfo;\n  class CodeCompletionResult;\n  class CoroutineBodyStmt;\n  class Decl;\n  class DeclAccessPair;\n  class DeclContext;\n  class DeclRefExpr;\n  class DeclaratorDecl;\n  class DeducedTemplateArgument;\n  class DependentDiagnostic;\n  class DesignatedInitExpr;\n  class Designation;\n  class EnableIfAttr;\n  class EnumConstantDecl;\n  class Expr;\n  class ExtVectorType;\n  class FormatAttr;\n  class FriendDecl;\n  class FunctionDecl;\n  class FunctionProtoType;\n  class FunctionTemplateDecl;\n  class ImplicitConversionSequence;\n  typedef MutableArrayRef<ImplicitConversionSequence> ConversionSequenceList;\n  class InitListExpr;\n  class InitializationKind;\n  class InitializationSequence;\n  class InitializedEntity;\n  class IntegerLiteral;\n  class LabelStmt;\n  class LambdaExpr;\n  class LangOptions;\n  class LocalInstantiationScope;\n  class LookupResult;\n  class MacroInfo;\n  typedef ArrayRef<std::pair<IdentifierInfo *, SourceLocation>> ModuleIdPath;\n  class ModuleLoader;\n  class MultiLevelTemplateArgumentList;\n  class NamedDecl;\n  class ObjCCategoryDecl;\n  class ObjCCategoryImplDecl;\n  class ObjCCompatibleAliasDecl;\n  class ObjCContainerDecl;\n  class ObjCImplDecl;\n  class ObjCImplementationDecl;\n  class ObjCInterfaceDecl;\n  class ObjCIvarDecl;\n  template <class T> class ObjCList;\n  class ObjCMessageExpr;\n  class ObjCMethodDecl;\n  class ObjCPropertyDecl;\n  class ObjCProtocolDecl;\n  class OMPThreadPrivateDecl;\n  class OMPRequiresDecl;\n  class OMPDeclareReductionDecl;\n  class OMPDeclareSimdDecl;\n  class OMPClause;\n  struct OMPVarListLocTy;\n  struct OverloadCandidate;\n  enum class OverloadCandidateParamOrder : char;\n  enum OverloadCandidateRewriteKind : unsigned;\n  class OverloadCandidateSet;\n  class OverloadExpr;\n  class ParenListExpr;\n  class ParmVarDecl;\n  class Preprocessor;\n  class PseudoDestructorTypeStorage;\n  class PseudoObjectExpr;\n  class QualType;\n  class StandardConversionSequence;\n  class Stmt;\n  class StringLiteral;\n  class SwitchStmt;\n  class TemplateArgument;\n  class TemplateArgumentList;\n  class TemplateArgumentLoc;\n  class TemplateDecl;\n  class TemplateInstantiationCallback;\n  class TemplateParameterList;\n  class TemplatePartialOrderingContext;\n  class TemplateTemplateParmDecl;\n  class Token;\n  class TypeAliasDecl;\n  class TypedefDecl;\n  class TypedefNameDecl;\n  class TypeLoc;\n  class TypoCorrectionConsumer;\n  class UnqualifiedId;\n  class UnresolvedLookupExpr;\n  class UnresolvedMemberExpr;\n  class UnresolvedSetImpl;\n  class UnresolvedSetIterator;\n  class UsingDecl;\n  class UsingShadowDecl;\n  class ValueDecl;\n  class VarDecl;\n  class VarTemplateSpecializationDecl;\n  class VisibilityAttr;\n  class VisibleDeclConsumer;\n  class IndirectFieldDecl;\n  struct DeductionFailureInfo;\n  class TemplateSpecCandidateSet;\n\nnamespace sema {\n  class AccessedEntity;\n  class BlockScopeInfo;\n  class Capture;\n  class CapturedRegionScopeInfo;\n  class CapturingScopeInfo;\n  class CompoundScopeInfo;\n  class DelayedDiagnostic;\n  class DelayedDiagnosticPool;\n  class FunctionScopeInfo;\n  class LambdaScopeInfo;\n  class PossiblyUnreachableDiag;\n  class SemaPPCallbacks;\n  class TemplateDeductionInfo;\n}\n\nnamespace threadSafety {\n  class BeforeSet;\n  void threadSafetyCleanup(BeforeSet* Cache);\n}\n\n// FIXME: No way to easily map from TemplateTypeParmTypes to\n// TemplateTypeParmDecls, so we have this horrible PointerUnion.\ntypedef std::pair<llvm::PointerUnion<const TemplateTypeParmType*, NamedDecl*>,\n                  SourceLocation> UnexpandedParameterPack;\n\n/// Describes whether we've seen any nullability information for the given\n/// file.\nstruct FileNullability {\n  /// The first pointer declarator (of any pointer kind) in the file that does\n  /// not have a corresponding nullability annotation.\n  SourceLocation PointerLoc;\n\n  /// The end location for the first pointer declarator in the file. Used for\n  /// placing fix-its.\n  SourceLocation PointerEndLoc;\n\n  /// Which kind of pointer declarator we saw.\n  uint8_t PointerKind;\n\n  /// Whether we saw any type nullability annotations in the given file.\n  bool SawTypeNullability = false;\n};\n\n/// A mapping from file IDs to a record of whether we've seen nullability\n/// information in that file.\nclass FileNullabilityMap {\n  /// A mapping from file IDs to the nullability information for each file ID.\n  llvm::DenseMap<FileID, FileNullability> Map;\n\n  /// A single-element cache based on the file ID.\n  struct {\n    FileID File;\n    FileNullability Nullability;\n  } Cache;\n\npublic:\n  FileNullability &operator[](FileID file) {\n    // Check the single-element cache.\n    if (file == Cache.File)\n      return Cache.Nullability;\n\n    // It's not in the single-element cache; flush the cache if we have one.\n    if (!Cache.File.isInvalid()) {\n      Map[Cache.File] = Cache.Nullability;\n    }\n\n    // Pull this entry into the cache.\n    Cache.File = file;\n    Cache.Nullability = Map[file];\n    return Cache.Nullability;\n  }\n};\n\n/// Keeps track of expected type during expression parsing. The type is tied to\n/// a particular token, all functions that update or consume the type take a\n/// start location of the token they are looking at as a parameter. This allows\n/// to avoid updating the type on hot paths in the parser.\nclass PreferredTypeBuilder {\npublic:\n  PreferredTypeBuilder() = default;\n  explicit PreferredTypeBuilder(QualType Type) : Type(Type) {}\n\n  void enterCondition(Sema &S, SourceLocation Tok);\n  void enterReturn(Sema &S, SourceLocation Tok);\n  void enterVariableInit(SourceLocation Tok, Decl *D);\n  /// Handles e.g. BaseType{ .D = Tok...\n  void enterDesignatedInitializer(SourceLocation Tok, QualType BaseType,\n                                  const Designation &D);\n  /// Computing a type for the function argument may require running\n  /// overloading, so we postpone its computation until it is actually needed.\n  ///\n  /// Clients should be very careful when using this funciton, as it stores a\n  /// function_ref, clients should make sure all calls to get() with the same\n  /// location happen while function_ref is alive.\n  void enterFunctionArgument(SourceLocation Tok,\n                             llvm::function_ref<QualType()> ComputeType);\n\n  void enterParenExpr(SourceLocation Tok, SourceLocation LParLoc);\n  void enterUnary(Sema &S, SourceLocation Tok, tok::TokenKind OpKind,\n                  SourceLocation OpLoc);\n  void enterBinary(Sema &S, SourceLocation Tok, Expr *LHS, tok::TokenKind Op);\n  void enterMemAccess(Sema &S, SourceLocation Tok, Expr *Base);\n  void enterSubscript(Sema &S, SourceLocation Tok, Expr *LHS);\n  /// Handles all type casts, including C-style cast, C++ casts, etc.\n  void enterTypeCast(SourceLocation Tok, QualType CastType);\n\n  QualType get(SourceLocation Tok) const {\n    if (Tok != ExpectedLoc)\n      return QualType();\n    if (!Type.isNull())\n      return Type;\n    if (ComputeType)\n      return ComputeType();\n    return QualType();\n  }\n\nprivate:\n  /// Start position of a token for which we store expected type.\n  SourceLocation ExpectedLoc;\n  /// Expected type for a token starting at ExpectedLoc.\n  QualType Type;\n  /// A function to compute expected type at ExpectedLoc. It is only considered\n  /// if Type is null.\n  llvm::function_ref<QualType()> ComputeType;\n};\n\n/// Sema - This implements semantic analysis and AST building for C.\nclass Sema final {\n  Sema(const Sema &) = delete;\n  void operator=(const Sema &) = delete;\n\n  /// A key method to reduce duplicate debug info from Sema.\n  virtual void anchor();\n\n  ///Source of additional semantic information.\n  ExternalSemaSource *ExternalSource;\n\n  ///Whether Sema has generated a multiplexer and has to delete it.\n  bool isMultiplexExternalSource;\n\n  static bool mightHaveNonExternalLinkage(const DeclaratorDecl *FD);\n\n  bool isVisibleSlow(const NamedDecl *D);\n\n  /// Determine whether two declarations should be linked together, given that\n  /// the old declaration might not be visible and the new declaration might\n  /// not have external linkage.\n  bool shouldLinkPossiblyHiddenDecl(const NamedDecl *Old,\n                                    const NamedDecl *New) {\n    if (isVisible(Old))\n     return true;\n    // See comment in below overload for why it's safe to compute the linkage\n    // of the new declaration here.\n    if (New->isExternallyDeclarable()) {\n      assert(Old->isExternallyDeclarable() &&\n             \"should not have found a non-externally-declarable previous decl\");\n      return true;\n    }\n    return false;\n  }\n  bool shouldLinkPossiblyHiddenDecl(LookupResult &Old, const NamedDecl *New);\n\n  void setupImplicitSpecialMemberType(CXXMethodDecl *SpecialMem,\n                                      QualType ResultTy,\n                                      ArrayRef<QualType> Args);\n\npublic:\n  /// The maximum alignment, same as in llvm::Value. We duplicate them here\n  /// because that allows us not to duplicate the constants in clang code,\n  /// which we must to since we can't directly use the llvm constants.\n  /// The value is verified against llvm here: lib/CodeGen/CGDecl.cpp\n  ///\n  /// This is the greatest alignment value supported by load, store, and alloca\n  /// instructions, and global values.\n  static const unsigned MaxAlignmentExponent = 29;\n  static const unsigned MaximumAlignment = 1u << MaxAlignmentExponent;\n\n  typedef OpaquePtr<DeclGroupRef> DeclGroupPtrTy;\n  typedef OpaquePtr<TemplateName> TemplateTy;\n  typedef OpaquePtr<QualType> TypeTy;\n\n  OpenCLOptions OpenCLFeatures;\n  FPOptions CurFPFeatures;\n\n  const LangOptions &LangOpts;\n  Preprocessor &PP;\n  ASTContext &Context;\n  ASTConsumer &Consumer;\n  DiagnosticsEngine &Diags;\n  SourceManager &SourceMgr;\n\n  /// Flag indicating whether or not to collect detailed statistics.\n  bool CollectStats;\n\n  /// Code-completion consumer.\n  CodeCompleteConsumer *CodeCompleter;\n\n  /// CurContext - This is the current declaration context of parsing.\n  DeclContext *CurContext;\n\n  /// Generally null except when we temporarily switch decl contexts,\n  /// like in \\see ActOnObjCTemporaryExitContainerContext.\n  DeclContext *OriginalLexicalContext;\n\n  /// VAListTagName - The declaration name corresponding to __va_list_tag.\n  /// This is used as part of a hack to omit that class from ADL results.\n  DeclarationName VAListTagName;\n\n  bool MSStructPragmaOn; // True when \\#pragma ms_struct on\n\n  /// Controls member pointer representation format under the MS ABI.\n  LangOptions::PragmaMSPointersToMembersKind\n      MSPointerToMemberRepresentationMethod;\n\n  /// Stack of active SEH __finally scopes.  Can be empty.\n  SmallVector<Scope*, 2> CurrentSEHFinally;\n\n  /// Source location for newly created implicit MSInheritanceAttrs\n  SourceLocation ImplicitMSInheritanceAttrLoc;\n\n  /// Holds TypoExprs that are created from `createDelayedTypo`. This is used by\n  /// `TransformTypos` in order to keep track of any TypoExprs that are created\n  /// recursively during typo correction and wipe them away if the correction\n  /// fails.\n  llvm::SmallVector<TypoExpr *, 2> TypoExprs;\n\n  /// pragma clang section kind\n  enum PragmaClangSectionKind {\n    PCSK_Invalid      = 0,\n    PCSK_BSS          = 1,\n    PCSK_Data         = 2,\n    PCSK_Rodata       = 3,\n    PCSK_Text         = 4,\n    PCSK_Relro        = 5\n   };\n\n  enum PragmaClangSectionAction {\n    PCSA_Set     = 0,\n    PCSA_Clear   = 1\n  };\n\n  struct PragmaClangSection {\n    std::string SectionName;\n    bool Valid = false;\n    SourceLocation PragmaLocation;\n  };\n\n   PragmaClangSection PragmaClangBSSSection;\n   PragmaClangSection PragmaClangDataSection;\n   PragmaClangSection PragmaClangRodataSection;\n   PragmaClangSection PragmaClangRelroSection;\n   PragmaClangSection PragmaClangTextSection;\n\n  enum PragmaMsStackAction {\n    PSK_Reset     = 0x0,                // #pragma ()\n    PSK_Set       = 0x1,                // #pragma (value)\n    PSK_Push      = 0x2,                // #pragma (push[, id])\n    PSK_Pop       = 0x4,                // #pragma (pop[, id])\n    PSK_Show      = 0x8,                // #pragma (show) -- only for \"pack\"!\n    PSK_Push_Set  = PSK_Push | PSK_Set, // #pragma (push[, id], value)\n    PSK_Pop_Set   = PSK_Pop | PSK_Set,  // #pragma (pop[, id], value)\n  };\n\n  // #pragma pack and align.\n  class AlignPackInfo {\n  public:\n    // `Native` represents default align mode, which may vary based on the\n    // platform.\n    enum Mode : unsigned char { Native, Natural, Packed, Mac68k };\n\n    // #pragma pack info constructor\n    AlignPackInfo(AlignPackInfo::Mode M, unsigned Num, bool IsXL)\n        : PackAttr(true), AlignMode(M), PackNumber(Num), XLStack(IsXL) {\n      assert(Num == PackNumber && \"The pack number has been truncated.\");\n    }\n\n    // #pragma align info constructor\n    AlignPackInfo(AlignPackInfo::Mode M, bool IsXL)\n        : PackAttr(false), AlignMode(M),\n          PackNumber(M == Packed ? 1 : UninitPackVal), XLStack(IsXL) {}\n\n    explicit AlignPackInfo(bool IsXL) : AlignPackInfo(Native, IsXL) {}\n\n    AlignPackInfo() : AlignPackInfo(Native, false) {}\n\n    // When a AlignPackInfo itself cannot be used, this returns an 32-bit\n    // integer encoding for it. This should only be passed to\n    // AlignPackInfo::getFromRawEncoding, it should not be inspected directly.\n    static uint32_t getRawEncoding(const AlignPackInfo &Info) {\n      std::uint32_t Encoding{};\n      if (Info.IsXLStack())\n        Encoding |= IsXLMask;\n\n      Encoding |= static_cast<uint32_t>(Info.getAlignMode()) << 1;\n\n      if (Info.IsPackAttr())\n        Encoding |= PackAttrMask;\n\n      Encoding |= static_cast<uint32_t>(Info.getPackNumber()) << 4;\n\n      return Encoding;\n    }\n\n    static AlignPackInfo getFromRawEncoding(unsigned Encoding) {\n      bool IsXL = static_cast<bool>(Encoding & IsXLMask);\n      AlignPackInfo::Mode M =\n          static_cast<AlignPackInfo::Mode>((Encoding & AlignModeMask) >> 1);\n      int PackNumber = (Encoding & PackNumMask) >> 4;\n\n      if (Encoding & PackAttrMask)\n        return AlignPackInfo(M, PackNumber, IsXL);\n\n      return AlignPackInfo(M, IsXL);\n    }\n\n    bool IsPackAttr() const { return PackAttr; }\n\n    bool IsAlignAttr() const { return !PackAttr; }\n\n    Mode getAlignMode() const { return AlignMode; }\n\n    unsigned getPackNumber() const { return PackNumber; }\n\n    bool IsPackSet() const {\n      // #pragma align, #pragma pack(), and #pragma pack(0) do not set the pack\n      // attriute on a decl.\n      return PackNumber != UninitPackVal && PackNumber != 0;\n    }\n\n    bool IsXLStack() const { return XLStack; }\n\n    bool operator==(const AlignPackInfo &Info) const {\n      return std::tie(AlignMode, PackNumber, PackAttr, XLStack) ==\n             std::tie(Info.AlignMode, Info.PackNumber, Info.PackAttr,\n                      Info.XLStack);\n    }\n\n    bool operator!=(const AlignPackInfo &Info) const {\n      return !(*this == Info);\n    }\n\n  private:\n    /// \\brief True if this is a pragma pack attribute,\n    ///         not a pragma align attribute.\n    bool PackAttr;\n\n    /// \\brief The alignment mode that is in effect.\n    Mode AlignMode;\n\n    /// \\brief The pack number of the stack.\n    unsigned char PackNumber;\n\n    /// \\brief True if it is a XL #pragma align/pack stack.\n    bool XLStack;\n\n    /// \\brief Uninitialized pack value.\n    static constexpr unsigned char UninitPackVal = -1;\n\n    // Masks to encode and decode an AlignPackInfo.\n    static constexpr uint32_t IsXLMask{0x0000'0001};\n    static constexpr uint32_t AlignModeMask{0x0000'0006};\n    static constexpr uint32_t PackAttrMask{0x00000'0008};\n    static constexpr uint32_t PackNumMask{0x0000'01F0};\n  };\n\n  template<typename ValueType>\n  struct PragmaStack {\n    struct Slot {\n      llvm::StringRef StackSlotLabel;\n      ValueType Value;\n      SourceLocation PragmaLocation;\n      SourceLocation PragmaPushLocation;\n      Slot(llvm::StringRef StackSlotLabel, ValueType Value,\n           SourceLocation PragmaLocation, SourceLocation PragmaPushLocation)\n          : StackSlotLabel(StackSlotLabel), Value(Value),\n            PragmaLocation(PragmaLocation),\n            PragmaPushLocation(PragmaPushLocation) {}\n    };\n\n    void Act(SourceLocation PragmaLocation, PragmaMsStackAction Action,\n             llvm::StringRef StackSlotLabel, ValueType Value) {\n      if (Action == PSK_Reset) {\n        CurrentValue = DefaultValue;\n        CurrentPragmaLocation = PragmaLocation;\n        return;\n      }\n      if (Action & PSK_Push)\n        Stack.emplace_back(StackSlotLabel, CurrentValue, CurrentPragmaLocation,\n                           PragmaLocation);\n      else if (Action & PSK_Pop) {\n        if (!StackSlotLabel.empty()) {\n          // If we've got a label, try to find it and jump there.\n          auto I = llvm::find_if(llvm::reverse(Stack), [&](const Slot &x) {\n            return x.StackSlotLabel == StackSlotLabel;\n          });\n          // If we found the label so pop from there.\n          if (I != Stack.rend()) {\n            CurrentValue = I->Value;\n            CurrentPragmaLocation = I->PragmaLocation;\n            Stack.erase(std::prev(I.base()), Stack.end());\n          }\n        } else if (!Stack.empty()) {\n          // We do not have a label, just pop the last entry.\n          CurrentValue = Stack.back().Value;\n          CurrentPragmaLocation = Stack.back().PragmaLocation;\n          Stack.pop_back();\n        }\n      }\n      if (Action & PSK_Set) {\n        CurrentValue = Value;\n        CurrentPragmaLocation = PragmaLocation;\n      }\n    }\n\n    // MSVC seems to add artificial slots to #pragma stacks on entering a C++\n    // method body to restore the stacks on exit, so it works like this:\n    //\n    //   struct S {\n    //     #pragma <name>(push, InternalPragmaSlot, <current_pragma_value>)\n    //     void Method {}\n    //     #pragma <name>(pop, InternalPragmaSlot)\n    //   };\n    //\n    // It works even with #pragma vtordisp, although MSVC doesn't support\n    //   #pragma vtordisp(push [, id], n)\n    // syntax.\n    //\n    // Push / pop a named sentinel slot.\n    void SentinelAction(PragmaMsStackAction Action, StringRef Label) {\n      assert((Action == PSK_Push || Action == PSK_Pop) &&\n             \"Can only push / pop #pragma stack sentinels!\");\n      Act(CurrentPragmaLocation, Action, Label, CurrentValue);\n    }\n\n    // Constructors.\n    explicit PragmaStack(const ValueType &Default)\n        : DefaultValue(Default), CurrentValue(Default) {}\n\n    bool hasValue() const { return CurrentValue != DefaultValue; }\n\n    SmallVector<Slot, 2> Stack;\n    ValueType DefaultValue; // Value used for PSK_Reset action.\n    ValueType CurrentValue;\n    SourceLocation CurrentPragmaLocation;\n  };\n  // FIXME: We should serialize / deserialize these if they occur in a PCH (but\n  // we shouldn't do so if they're in a module).\n\n  /// Whether to insert vtordisps prior to virtual bases in the Microsoft\n  /// C++ ABI.  Possible values are 0, 1, and 2, which mean:\n  ///\n  /// 0: Suppress all vtordisps\n  /// 1: Insert vtordisps in the presence of vbase overrides and non-trivial\n  ///    structors\n  /// 2: Always insert vtordisps to support RTTI on partially constructed\n  ///    objects\n  PragmaStack<MSVtorDispMode> VtorDispStack;\n  PragmaStack<AlignPackInfo> AlignPackStack;\n  // The current #pragma align/pack values and locations at each #include.\n  struct AlignPackIncludeState {\n    AlignPackInfo CurrentValue;\n    SourceLocation CurrentPragmaLocation;\n    bool HasNonDefaultValue, ShouldWarnOnInclude;\n  };\n  SmallVector<AlignPackIncludeState, 8> AlignPackIncludeStack;\n  // Segment #pragmas.\n  PragmaStack<StringLiteral *> DataSegStack;\n  PragmaStack<StringLiteral *> BSSSegStack;\n  PragmaStack<StringLiteral *> ConstSegStack;\n  PragmaStack<StringLiteral *> CodeSegStack;\n\n  // This stack tracks the current state of Sema.CurFPFeatures.\n  PragmaStack<FPOptionsOverride> FpPragmaStack;\n  FPOptionsOverride CurFPFeatureOverrides() {\n    FPOptionsOverride result;\n    if (!FpPragmaStack.hasValue()) {\n      result = FPOptionsOverride();\n    } else {\n      result = FpPragmaStack.CurrentValue;\n    }\n    return result;\n  }\n\n  // RAII object to push / pop sentinel slots for all MS #pragma stacks.\n  // Actions should be performed only if we enter / exit a C++ method body.\n  class PragmaStackSentinelRAII {\n  public:\n    PragmaStackSentinelRAII(Sema &S, StringRef SlotLabel, bool ShouldAct);\n    ~PragmaStackSentinelRAII();\n\n  private:\n    Sema &S;\n    StringRef SlotLabel;\n    bool ShouldAct;\n  };\n\n  /// A mapping that describes the nullability we've seen in each header file.\n  FileNullabilityMap NullabilityMap;\n\n  /// Last section used with #pragma init_seg.\n  StringLiteral *CurInitSeg;\n  SourceLocation CurInitSegLoc;\n\n  /// VisContext - Manages the stack for \\#pragma GCC visibility.\n  void *VisContext; // Really a \"PragmaVisStack*\"\n\n  /// This an attribute introduced by \\#pragma clang attribute.\n  struct PragmaAttributeEntry {\n    SourceLocation Loc;\n    ParsedAttr *Attribute;\n    SmallVector<attr::SubjectMatchRule, 4> MatchRules;\n    bool IsUsed;\n  };\n\n  /// A push'd group of PragmaAttributeEntries.\n  struct PragmaAttributeGroup {\n    /// The location of the push attribute.\n    SourceLocation Loc;\n    /// The namespace of this push group.\n    const IdentifierInfo *Namespace;\n    SmallVector<PragmaAttributeEntry, 2> Entries;\n  };\n\n  SmallVector<PragmaAttributeGroup, 2> PragmaAttributeStack;\n\n  /// The declaration that is currently receiving an attribute from the\n  /// #pragma attribute stack.\n  const Decl *PragmaAttributeCurrentTargetDecl;\n\n  /// This represents the last location of a \"#pragma clang optimize off\"\n  /// directive if such a directive has not been closed by an \"on\" yet. If\n  /// optimizations are currently \"on\", this is set to an invalid location.\n  SourceLocation OptimizeOffPragmaLocation;\n\n  /// Flag indicating if Sema is building a recovery call expression.\n  ///\n  /// This flag is used to avoid building recovery call expressions\n  /// if Sema is already doing so, which would cause infinite recursions.\n  bool IsBuildingRecoveryCallExpr;\n\n  /// Used to control the generation of ExprWithCleanups.\n  CleanupInfo Cleanup;\n\n  /// ExprCleanupObjects - This is the stack of objects requiring\n  /// cleanup that are created by the current full expression.\n  SmallVector<ExprWithCleanups::CleanupObject, 8> ExprCleanupObjects;\n\n  /// Store a set of either DeclRefExprs or MemberExprs that contain a reference\n  /// to a variable (constant) that may or may not be odr-used in this Expr, and\n  /// we won't know until all lvalue-to-rvalue and discarded value conversions\n  /// have been applied to all subexpressions of the enclosing full expression.\n  /// This is cleared at the end of each full expression.\n  using MaybeODRUseExprSet = llvm::SetVector<Expr *, SmallVector<Expr *, 4>,\n                                             llvm::SmallPtrSet<Expr *, 4>>;\n  MaybeODRUseExprSet MaybeODRUseExprs;\n\n  std::unique_ptr<sema::FunctionScopeInfo> CachedFunctionScope;\n\n  /// Stack containing information about each of the nested\n  /// function, block, and method scopes that are currently active.\n  SmallVector<sema::FunctionScopeInfo *, 4> FunctionScopes;\n\n  /// The index of the first FunctionScope that corresponds to the current\n  /// context.\n  unsigned FunctionScopesStart = 0;\n\n  ArrayRef<sema::FunctionScopeInfo*> getFunctionScopes() const {\n    return llvm::makeArrayRef(FunctionScopes.begin() + FunctionScopesStart,\n                              FunctionScopes.end());\n  }\n\n  /// Stack containing information needed when in C++2a an 'auto' is encountered\n  /// in a function declaration parameter type specifier in order to invent a\n  /// corresponding template parameter in the enclosing abbreviated function\n  /// template. This information is also present in LambdaScopeInfo, stored in\n  /// the FunctionScopes stack.\n  SmallVector<InventedTemplateParameterInfo, 4> InventedParameterInfos;\n\n  /// The index of the first InventedParameterInfo that refers to the current\n  /// context.\n  unsigned InventedParameterInfosStart = 0;\n\n  ArrayRef<InventedTemplateParameterInfo> getInventedParameterInfos() const {\n    return llvm::makeArrayRef(InventedParameterInfos.begin() +\n                                  InventedParameterInfosStart,\n                              InventedParameterInfos.end());\n  }\n\n  typedef LazyVector<TypedefNameDecl *, ExternalSemaSource,\n                     &ExternalSemaSource::ReadExtVectorDecls, 2, 2>\n    ExtVectorDeclsType;\n\n  /// ExtVectorDecls - This is a list all the extended vector types. This allows\n  /// us to associate a raw vector type with one of the ext_vector type names.\n  /// This is only necessary for issuing pretty diagnostics.\n  ExtVectorDeclsType ExtVectorDecls;\n\n  /// FieldCollector - Collects CXXFieldDecls during parsing of C++ classes.\n  std::unique_ptr<CXXFieldCollector> FieldCollector;\n\n  typedef llvm::SmallSetVector<NamedDecl *, 16> NamedDeclSetType;\n\n  /// Set containing all declared private fields that are not used.\n  NamedDeclSetType UnusedPrivateFields;\n\n  /// Set containing all typedefs that are likely unused.\n  llvm::SmallSetVector<const TypedefNameDecl *, 4>\n      UnusedLocalTypedefNameCandidates;\n\n  /// Delete-expressions to be analyzed at the end of translation unit\n  ///\n  /// This list contains class members, and locations of delete-expressions\n  /// that could not be proven as to whether they mismatch with new-expression\n  /// used in initializer of the field.\n  typedef std::pair<SourceLocation, bool> DeleteExprLoc;\n  typedef llvm::SmallVector<DeleteExprLoc, 4> DeleteLocs;\n  llvm::MapVector<FieldDecl *, DeleteLocs> DeleteExprs;\n\n  typedef llvm::SmallPtrSet<const CXXRecordDecl*, 8> RecordDeclSetTy;\n\n  /// PureVirtualClassDiagSet - a set of class declarations which we have\n  /// emitted a list of pure virtual functions. Used to prevent emitting the\n  /// same list more than once.\n  std::unique_ptr<RecordDeclSetTy> PureVirtualClassDiagSet;\n\n  /// ParsingInitForAutoVars - a set of declarations with auto types for which\n  /// we are currently parsing the initializer.\n  llvm::SmallPtrSet<const Decl*, 4> ParsingInitForAutoVars;\n\n  /// Look for a locally scoped extern \"C\" declaration by the given name.\n  NamedDecl *findLocallyScopedExternCDecl(DeclarationName Name);\n\n  typedef LazyVector<VarDecl *, ExternalSemaSource,\n                     &ExternalSemaSource::ReadTentativeDefinitions, 2, 2>\n    TentativeDefinitionsType;\n\n  /// All the tentative definitions encountered in the TU.\n  TentativeDefinitionsType TentativeDefinitions;\n\n  /// All the external declarations encoutered and used in the TU.\n  SmallVector<VarDecl *, 4> ExternalDeclarations;\n\n  typedef LazyVector<const DeclaratorDecl *, ExternalSemaSource,\n                     &ExternalSemaSource::ReadUnusedFileScopedDecls, 2, 2>\n    UnusedFileScopedDeclsType;\n\n  /// The set of file scoped decls seen so far that have not been used\n  /// and must warn if not used. Only contains the first declaration.\n  UnusedFileScopedDeclsType UnusedFileScopedDecls;\n\n  typedef LazyVector<CXXConstructorDecl *, ExternalSemaSource,\n                     &ExternalSemaSource::ReadDelegatingConstructors, 2, 2>\n    DelegatingCtorDeclsType;\n\n  /// All the delegating constructors seen so far in the file, used for\n  /// cycle detection at the end of the TU.\n  DelegatingCtorDeclsType DelegatingCtorDecls;\n\n  /// All the overriding functions seen during a class definition\n  /// that had their exception spec checks delayed, plus the overridden\n  /// function.\n  SmallVector<std::pair<const CXXMethodDecl*, const CXXMethodDecl*>, 2>\n    DelayedOverridingExceptionSpecChecks;\n\n  /// All the function redeclarations seen during a class definition that had\n  /// their exception spec checks delayed, plus the prior declaration they\n  /// should be checked against. Except during error recovery, the new decl\n  /// should always be a friend declaration, as that's the only valid way to\n  /// redeclare a special member before its class is complete.\n  SmallVector<std::pair<FunctionDecl*, FunctionDecl*>, 2>\n    DelayedEquivalentExceptionSpecChecks;\n\n  typedef llvm::MapVector<const FunctionDecl *,\n                          std::unique_ptr<LateParsedTemplate>>\n      LateParsedTemplateMapT;\n  LateParsedTemplateMapT LateParsedTemplateMap;\n\n  /// Callback to the parser to parse templated functions when needed.\n  typedef void LateTemplateParserCB(void *P, LateParsedTemplate &LPT);\n  typedef void LateTemplateParserCleanupCB(void *P);\n  LateTemplateParserCB *LateTemplateParser;\n  LateTemplateParserCleanupCB *LateTemplateParserCleanup;\n  void *OpaqueParser;\n\n  void SetLateTemplateParser(LateTemplateParserCB *LTP,\n                             LateTemplateParserCleanupCB *LTPCleanup,\n                             void *P) {\n    LateTemplateParser = LTP;\n    LateTemplateParserCleanup = LTPCleanup;\n    OpaqueParser = P;\n  }\n\n  class DelayedDiagnostics;\n\n  class DelayedDiagnosticsState {\n    sema::DelayedDiagnosticPool *SavedPool;\n    friend class Sema::DelayedDiagnostics;\n  };\n  typedef DelayedDiagnosticsState ParsingDeclState;\n  typedef DelayedDiagnosticsState ProcessingContextState;\n\n  /// A class which encapsulates the logic for delaying diagnostics\n  /// during parsing and other processing.\n  class DelayedDiagnostics {\n    /// The current pool of diagnostics into which delayed\n    /// diagnostics should go.\n    sema::DelayedDiagnosticPool *CurPool;\n\n  public:\n    DelayedDiagnostics() : CurPool(nullptr) {}\n\n    /// Adds a delayed diagnostic.\n    void add(const sema::DelayedDiagnostic &diag); // in DelayedDiagnostic.h\n\n    /// Determines whether diagnostics should be delayed.\n    bool shouldDelayDiagnostics() { return CurPool != nullptr; }\n\n    /// Returns the current delayed-diagnostics pool.\n    sema::DelayedDiagnosticPool *getCurrentPool() const {\n      return CurPool;\n    }\n\n    /// Enter a new scope.  Access and deprecation diagnostics will be\n    /// collected in this pool.\n    DelayedDiagnosticsState push(sema::DelayedDiagnosticPool &pool) {\n      DelayedDiagnosticsState state;\n      state.SavedPool = CurPool;\n      CurPool = &pool;\n      return state;\n    }\n\n    /// Leave a delayed-diagnostic state that was previously pushed.\n    /// Do not emit any of the diagnostics.  This is performed as part\n    /// of the bookkeeping of popping a pool \"properly\".\n    void popWithoutEmitting(DelayedDiagnosticsState state) {\n      CurPool = state.SavedPool;\n    }\n\n    /// Enter a new scope where access and deprecation diagnostics are\n    /// not delayed.\n    DelayedDiagnosticsState pushUndelayed() {\n      DelayedDiagnosticsState state;\n      state.SavedPool = CurPool;\n      CurPool = nullptr;\n      return state;\n    }\n\n    /// Undo a previous pushUndelayed().\n    void popUndelayed(DelayedDiagnosticsState state) {\n      assert(CurPool == nullptr);\n      CurPool = state.SavedPool;\n    }\n  } DelayedDiagnostics;\n\n  /// A RAII object to temporarily push a declaration context.\n  class ContextRAII {\n  private:\n    Sema &S;\n    DeclContext *SavedContext;\n    ProcessingContextState SavedContextState;\n    QualType SavedCXXThisTypeOverride;\n    unsigned SavedFunctionScopesStart;\n    unsigned SavedInventedParameterInfosStart;\n\n  public:\n    ContextRAII(Sema &S, DeclContext *ContextToPush, bool NewThisContext = true)\n      : S(S), SavedContext(S.CurContext),\n        SavedContextState(S.DelayedDiagnostics.pushUndelayed()),\n        SavedCXXThisTypeOverride(S.CXXThisTypeOverride),\n        SavedFunctionScopesStart(S.FunctionScopesStart),\n        SavedInventedParameterInfosStart(S.InventedParameterInfosStart)\n    {\n      assert(ContextToPush && \"pushing null context\");\n      S.CurContext = ContextToPush;\n      if (NewThisContext)\n        S.CXXThisTypeOverride = QualType();\n      // Any saved FunctionScopes do not refer to this context.\n      S.FunctionScopesStart = S.FunctionScopes.size();\n      S.InventedParameterInfosStart = S.InventedParameterInfos.size();\n    }\n\n    void pop() {\n      if (!SavedContext) return;\n      S.CurContext = SavedContext;\n      S.DelayedDiagnostics.popUndelayed(SavedContextState);\n      S.CXXThisTypeOverride = SavedCXXThisTypeOverride;\n      S.FunctionScopesStart = SavedFunctionScopesStart;\n      S.InventedParameterInfosStart = SavedInventedParameterInfosStart;\n      SavedContext = nullptr;\n    }\n\n    ~ContextRAII() {\n      pop();\n    }\n  };\n\n  /// Whether the AST is currently being rebuilt to correct immediate\n  /// invocations. Immediate invocation candidates and references to consteval\n  /// functions aren't tracked when this is set.\n  bool RebuildingImmediateInvocation = false;\n\n  /// Used to change context to isConstantEvaluated without pushing a heavy\n  /// ExpressionEvaluationContextRecord object.\n  bool isConstantEvaluatedOverride;\n\n  bool isConstantEvaluated() {\n    return ExprEvalContexts.back().isConstantEvaluated() ||\n           isConstantEvaluatedOverride;\n  }\n\n  /// RAII object to handle the state changes required to synthesize\n  /// a function body.\n  class SynthesizedFunctionScope {\n    Sema &S;\n    Sema::ContextRAII SavedContext;\n    bool PushedCodeSynthesisContext = false;\n\n  public:\n    SynthesizedFunctionScope(Sema &S, DeclContext *DC)\n        : S(S), SavedContext(S, DC) {\n      S.PushFunctionScope();\n      S.PushExpressionEvaluationContext(\n          Sema::ExpressionEvaluationContext::PotentiallyEvaluated);\n      if (auto *FD = dyn_cast<FunctionDecl>(DC))\n        FD->setWillHaveBody(true);\n      else\n        assert(isa<ObjCMethodDecl>(DC));\n    }\n\n    void addContextNote(SourceLocation UseLoc) {\n      assert(!PushedCodeSynthesisContext);\n\n      Sema::CodeSynthesisContext Ctx;\n      Ctx.Kind = Sema::CodeSynthesisContext::DefiningSynthesizedFunction;\n      Ctx.PointOfInstantiation = UseLoc;\n      Ctx.Entity = cast<Decl>(S.CurContext);\n      S.pushCodeSynthesisContext(Ctx);\n\n      PushedCodeSynthesisContext = true;\n    }\n\n    ~SynthesizedFunctionScope() {\n      if (PushedCodeSynthesisContext)\n        S.popCodeSynthesisContext();\n      if (auto *FD = dyn_cast<FunctionDecl>(S.CurContext))\n        FD->setWillHaveBody(false);\n      S.PopExpressionEvaluationContext();\n      S.PopFunctionScopeInfo();\n    }\n  };\n\n  /// WeakUndeclaredIdentifiers - Identifiers contained in\n  /// \\#pragma weak before declared. rare. may alias another\n  /// identifier, declared or undeclared\n  llvm::MapVector<IdentifierInfo *, WeakInfo> WeakUndeclaredIdentifiers;\n\n  /// ExtnameUndeclaredIdentifiers - Identifiers contained in\n  /// \\#pragma redefine_extname before declared.  Used in Solaris system headers\n  /// to define functions that occur in multiple standards to call the version\n  /// in the currently selected standard.\n  llvm::DenseMap<IdentifierInfo*,AsmLabelAttr*> ExtnameUndeclaredIdentifiers;\n\n\n  /// Load weak undeclared identifiers from the external source.\n  void LoadExternalWeakUndeclaredIdentifiers();\n\n  /// WeakTopLevelDecl - Translation-unit scoped declarations generated by\n  /// \\#pragma weak during processing of other Decls.\n  /// I couldn't figure out a clean way to generate these in-line, so\n  /// we store them here and handle separately -- which is a hack.\n  /// It would be best to refactor this.\n  SmallVector<Decl*,2> WeakTopLevelDecl;\n\n  IdentifierResolver IdResolver;\n\n  /// Translation Unit Scope - useful to Objective-C actions that need\n  /// to lookup file scope declarations in the \"ordinary\" C decl namespace.\n  /// For example, user-defined classes, built-in \"id\" type, etc.\n  Scope *TUScope;\n\n  /// The C++ \"std\" namespace, where the standard library resides.\n  LazyDeclPtr StdNamespace;\n\n  /// The C++ \"std::bad_alloc\" class, which is defined by the C++\n  /// standard library.\n  LazyDeclPtr StdBadAlloc;\n\n  /// The C++ \"std::align_val_t\" enum class, which is defined by the C++\n  /// standard library.\n  LazyDeclPtr StdAlignValT;\n\n  /// The C++ \"std::experimental\" namespace, where the experimental parts\n  /// of the standard library resides.\n  NamespaceDecl *StdExperimentalNamespaceCache;\n\n  /// The C++ \"std::initializer_list\" template, which is defined in\n  /// \\<initializer_list>.\n  ClassTemplateDecl *StdInitializerList;\n\n  /// The C++ \"std::coroutine_traits\" template, which is defined in\n  /// \\<coroutine_traits>\n  ClassTemplateDecl *StdCoroutineTraitsCache;\n\n  /// The C++ \"type_info\" declaration, which is defined in \\<typeinfo>.\n  RecordDecl *CXXTypeInfoDecl;\n\n  /// The MSVC \"_GUID\" struct, which is defined in MSVC header files.\n  RecordDecl *MSVCGuidDecl;\n\n  /// Caches identifiers/selectors for NSFoundation APIs.\n  std::unique_ptr<NSAPI> NSAPIObj;\n\n  /// The declaration of the Objective-C NSNumber class.\n  ObjCInterfaceDecl *NSNumberDecl;\n\n  /// The declaration of the Objective-C NSValue class.\n  ObjCInterfaceDecl *NSValueDecl;\n\n  /// Pointer to NSNumber type (NSNumber *).\n  QualType NSNumberPointer;\n\n  /// Pointer to NSValue type (NSValue *).\n  QualType NSValuePointer;\n\n  /// The Objective-C NSNumber methods used to create NSNumber literals.\n  ObjCMethodDecl *NSNumberLiteralMethods[NSAPI::NumNSNumberLiteralMethods];\n\n  /// The declaration of the Objective-C NSString class.\n  ObjCInterfaceDecl *NSStringDecl;\n\n  /// Pointer to NSString type (NSString *).\n  QualType NSStringPointer;\n\n  /// The declaration of the stringWithUTF8String: method.\n  ObjCMethodDecl *StringWithUTF8StringMethod;\n\n  /// The declaration of the valueWithBytes:objCType: method.\n  ObjCMethodDecl *ValueWithBytesObjCTypeMethod;\n\n  /// The declaration of the Objective-C NSArray class.\n  ObjCInterfaceDecl *NSArrayDecl;\n\n  /// The declaration of the arrayWithObjects:count: method.\n  ObjCMethodDecl *ArrayWithObjectsMethod;\n\n  /// The declaration of the Objective-C NSDictionary class.\n  ObjCInterfaceDecl *NSDictionaryDecl;\n\n  /// The declaration of the dictionaryWithObjects:forKeys:count: method.\n  ObjCMethodDecl *DictionaryWithObjectsMethod;\n\n  /// id<NSCopying> type.\n  QualType QIDNSCopying;\n\n  /// will hold 'respondsToSelector:'\n  Selector RespondsToSelectorSel;\n\n  /// A flag to remember whether the implicit forms of operator new and delete\n  /// have been declared.\n  bool GlobalNewDeleteDeclared;\n\n  /// Describes how the expressions currently being parsed are\n  /// evaluated at run-time, if at all.\n  enum class ExpressionEvaluationContext {\n    /// The current expression and its subexpressions occur within an\n    /// unevaluated operand (C++11 [expr]p7), such as the subexpression of\n    /// \\c sizeof, where the type of the expression may be significant but\n    /// no code will be generated to evaluate the value of the expression at\n    /// run time.\n    Unevaluated,\n\n    /// The current expression occurs within a braced-init-list within\n    /// an unevaluated operand. This is mostly like a regular unevaluated\n    /// context, except that we still instantiate constexpr functions that are\n    /// referenced here so that we can perform narrowing checks correctly.\n    UnevaluatedList,\n\n    /// The current expression occurs within a discarded statement.\n    /// This behaves largely similarly to an unevaluated operand in preventing\n    /// definitions from being required, but not in other ways.\n    DiscardedStatement,\n\n    /// The current expression occurs within an unevaluated\n    /// operand that unconditionally permits abstract references to\n    /// fields, such as a SIZE operator in MS-style inline assembly.\n    UnevaluatedAbstract,\n\n    /// The current context is \"potentially evaluated\" in C++11 terms,\n    /// but the expression is evaluated at compile-time (like the values of\n    /// cases in a switch statement).\n    ConstantEvaluated,\n\n    /// The current expression is potentially evaluated at run time,\n    /// which means that code may be generated to evaluate the value of the\n    /// expression at run time.\n    PotentiallyEvaluated,\n\n    /// The current expression is potentially evaluated, but any\n    /// declarations referenced inside that expression are only used if\n    /// in fact the current expression is used.\n    ///\n    /// This value is used when parsing default function arguments, for which\n    /// we would like to provide diagnostics (e.g., passing non-POD arguments\n    /// through varargs) but do not want to mark declarations as \"referenced\"\n    /// until the default argument is used.\n    PotentiallyEvaluatedIfUsed\n  };\n\n  using ImmediateInvocationCandidate = llvm::PointerIntPair<ConstantExpr *, 1>;\n\n  /// Data structure used to record current or nested\n  /// expression evaluation contexts.\n  struct ExpressionEvaluationContextRecord {\n    /// The expression evaluation context.\n    ExpressionEvaluationContext Context;\n\n    /// Whether the enclosing context needed a cleanup.\n    CleanupInfo ParentCleanup;\n\n    /// The number of active cleanup objects when we entered\n    /// this expression evaluation context.\n    unsigned NumCleanupObjects;\n\n    /// The number of typos encountered during this expression evaluation\n    /// context (i.e. the number of TypoExprs created).\n    unsigned NumTypos;\n\n    MaybeODRUseExprSet SavedMaybeODRUseExprs;\n\n    /// The lambdas that are present within this context, if it\n    /// is indeed an unevaluated context.\n    SmallVector<LambdaExpr *, 2> Lambdas;\n\n    /// The declaration that provides context for lambda expressions\n    /// and block literals if the normal declaration context does not\n    /// suffice, e.g., in a default function argument.\n    Decl *ManglingContextDecl;\n\n    /// If we are processing a decltype type, a set of call expressions\n    /// for which we have deferred checking the completeness of the return type.\n    SmallVector<CallExpr *, 8> DelayedDecltypeCalls;\n\n    /// If we are processing a decltype type, a set of temporary binding\n    /// expressions for which we have deferred checking the destructor.\n    SmallVector<CXXBindTemporaryExpr *, 8> DelayedDecltypeBinds;\n\n    llvm::SmallPtrSet<const Expr *, 8> PossibleDerefs;\n\n    /// Expressions appearing as the LHS of a volatile assignment in this\n    /// context. We produce a warning for these when popping the context if\n    /// they are not discarded-value expressions nor unevaluated operands.\n    SmallVector<Expr*, 2> VolatileAssignmentLHSs;\n\n    /// Set of candidates for starting an immediate invocation.\n    llvm::SmallVector<ImmediateInvocationCandidate, 4> ImmediateInvocationCandidates;\n\n    /// Set of DeclRefExprs referencing a consteval function when used in a\n    /// context not already known to be immediately invoked.\n    llvm::SmallPtrSet<DeclRefExpr *, 4> ReferenceToConsteval;\n\n    /// \\brief Describes whether we are in an expression constext which we have\n    /// to handle differently.\n    enum ExpressionKind {\n      EK_Decltype, EK_TemplateArgument, EK_Other\n    } ExprContext;\n\n    ExpressionEvaluationContextRecord(ExpressionEvaluationContext Context,\n                                      unsigned NumCleanupObjects,\n                                      CleanupInfo ParentCleanup,\n                                      Decl *ManglingContextDecl,\n                                      ExpressionKind ExprContext)\n        : Context(Context), ParentCleanup(ParentCleanup),\n          NumCleanupObjects(NumCleanupObjects), NumTypos(0),\n          ManglingContextDecl(ManglingContextDecl), ExprContext(ExprContext) {}\n\n    bool isUnevaluated() const {\n      return Context == ExpressionEvaluationContext::Unevaluated ||\n             Context == ExpressionEvaluationContext::UnevaluatedAbstract ||\n             Context == ExpressionEvaluationContext::UnevaluatedList;\n    }\n    bool isConstantEvaluated() const {\n      return Context == ExpressionEvaluationContext::ConstantEvaluated;\n    }\n  };\n\n  /// A stack of expression evaluation contexts.\n  SmallVector<ExpressionEvaluationContextRecord, 8> ExprEvalContexts;\n\n  /// Emit a warning for all pending noderef expressions that we recorded.\n  void WarnOnPendingNoDerefs(ExpressionEvaluationContextRecord &Rec);\n\n  /// Compute the mangling number context for a lambda expression or\n  /// block literal. Also return the extra mangling decl if any.\n  ///\n  /// \\param DC - The DeclContext containing the lambda expression or\n  /// block literal.\n  std::tuple<MangleNumberingContext *, Decl *>\n  getCurrentMangleNumberContext(const DeclContext *DC);\n\n\n  /// SpecialMemberOverloadResult - The overloading result for a special member\n  /// function.\n  ///\n  /// This is basically a wrapper around PointerIntPair. The lowest bits of the\n  /// integer are used to determine whether overload resolution succeeded.\n  class SpecialMemberOverloadResult {\n  public:\n    enum Kind {\n      NoMemberOrDeleted,\n      Ambiguous,\n      Success\n    };\n\n  private:\n    llvm::PointerIntPair<CXXMethodDecl*, 2> Pair;\n\n  public:\n    SpecialMemberOverloadResult() : Pair() {}\n    SpecialMemberOverloadResult(CXXMethodDecl *MD)\n        : Pair(MD, MD->isDeleted() ? NoMemberOrDeleted : Success) {}\n\n    CXXMethodDecl *getMethod() const { return Pair.getPointer(); }\n    void setMethod(CXXMethodDecl *MD) { Pair.setPointer(MD); }\n\n    Kind getKind() const { return static_cast<Kind>(Pair.getInt()); }\n    void setKind(Kind K) { Pair.setInt(K); }\n  };\n\n  class SpecialMemberOverloadResultEntry\n      : public llvm::FastFoldingSetNode,\n        public SpecialMemberOverloadResult {\n  public:\n    SpecialMemberOverloadResultEntry(const llvm::FoldingSetNodeID &ID)\n      : FastFoldingSetNode(ID)\n    {}\n  };\n\n  /// A cache of special member function overload resolution results\n  /// for C++ records.\n  llvm::FoldingSet<SpecialMemberOverloadResultEntry> SpecialMemberCache;\n\n  /// A cache of the flags available in enumerations with the flag_bits\n  /// attribute.\n  mutable llvm::DenseMap<const EnumDecl*, llvm::APInt> FlagBitsCache;\n\n  /// The kind of translation unit we are processing.\n  ///\n  /// When we're processing a complete translation unit, Sema will perform\n  /// end-of-translation-unit semantic tasks (such as creating\n  /// initializers for tentative definitions in C) once parsing has\n  /// completed. Modules and precompiled headers perform different kinds of\n  /// checks.\n  TranslationUnitKind TUKind;\n\n  llvm::BumpPtrAllocator BumpAlloc;\n\n  /// The number of SFINAE diagnostics that have been trapped.\n  unsigned NumSFINAEErrors;\n\n  typedef llvm::DenseMap<ParmVarDecl *, llvm::TinyPtrVector<ParmVarDecl *>>\n    UnparsedDefaultArgInstantiationsMap;\n\n  /// A mapping from parameters with unparsed default arguments to the\n  /// set of instantiations of each parameter.\n  ///\n  /// This mapping is a temporary data structure used when parsing\n  /// nested class templates or nested classes of class templates,\n  /// where we might end up instantiating an inner class before the\n  /// default arguments of its methods have been parsed.\n  UnparsedDefaultArgInstantiationsMap UnparsedDefaultArgInstantiations;\n\n  // Contains the locations of the beginning of unparsed default\n  // argument locations.\n  llvm::DenseMap<ParmVarDecl *, SourceLocation> UnparsedDefaultArgLocs;\n\n  /// UndefinedInternals - all the used, undefined objects which require a\n  /// definition in this translation unit.\n  llvm::MapVector<NamedDecl *, SourceLocation> UndefinedButUsed;\n\n  /// Determine if VD, which must be a variable or function, is an external\n  /// symbol that nonetheless can't be referenced from outside this translation\n  /// unit because its type has no linkage and it's not extern \"C\".\n  bool isExternalWithNoLinkageType(ValueDecl *VD);\n\n  /// Obtain a sorted list of functions that are undefined but ODR-used.\n  void getUndefinedButUsed(\n      SmallVectorImpl<std::pair<NamedDecl *, SourceLocation> > &Undefined);\n\n  /// Retrieves list of suspicious delete-expressions that will be checked at\n  /// the end of translation unit.\n  const llvm::MapVector<FieldDecl *, DeleteLocs> &\n  getMismatchingDeleteExpressions() const;\n\n  typedef std::pair<ObjCMethodList, ObjCMethodList> GlobalMethods;\n  typedef llvm::DenseMap<Selector, GlobalMethods> GlobalMethodPool;\n\n  /// Method Pool - allows efficient lookup when typechecking messages to \"id\".\n  /// We need to maintain a list, since selectors can have differing signatures\n  /// across classes. In Cocoa, this happens to be extremely uncommon (only 1%\n  /// of selectors are \"overloaded\").\n  /// At the head of the list it is recorded whether there were 0, 1, or >= 2\n  /// methods inside categories with a particular selector.\n  GlobalMethodPool MethodPool;\n\n  /// Method selectors used in a \\@selector expression. Used for implementation\n  /// of -Wselector.\n  llvm::MapVector<Selector, SourceLocation> ReferencedSelectors;\n\n  /// List of SourceLocations where 'self' is implicitly retained inside a\n  /// block.\n  llvm::SmallVector<std::pair<SourceLocation, const BlockDecl *>, 1>\n      ImplicitlyRetainedSelfLocs;\n\n  /// Kinds of C++ special members.\n  enum CXXSpecialMember {\n    CXXDefaultConstructor,\n    CXXCopyConstructor,\n    CXXMoveConstructor,\n    CXXCopyAssignment,\n    CXXMoveAssignment,\n    CXXDestructor,\n    CXXInvalid\n  };\n\n  typedef llvm::PointerIntPair<CXXRecordDecl *, 3, CXXSpecialMember>\n      SpecialMemberDecl;\n\n  /// The C++ special members which we are currently in the process of\n  /// declaring. If this process recursively triggers the declaration of the\n  /// same special member, we should act as if it is not yet declared.\n  llvm::SmallPtrSet<SpecialMemberDecl, 4> SpecialMembersBeingDeclared;\n\n  /// Kinds of defaulted comparison operator functions.\n  enum class DefaultedComparisonKind : unsigned char {\n    /// This is not a defaultable comparison operator.\n    None,\n    /// This is an operator== that should be implemented as a series of\n    /// subobject comparisons.\n    Equal,\n    /// This is an operator<=> that should be implemented as a series of\n    /// subobject comparisons.\n    ThreeWay,\n    /// This is an operator!= that should be implemented as a rewrite in terms\n    /// of a == comparison.\n    NotEqual,\n    /// This is an <, <=, >, or >= that should be implemented as a rewrite in\n    /// terms of a <=> comparison.\n    Relational,\n  };\n\n  /// The function definitions which were renamed as part of typo-correction\n  /// to match their respective declarations. We want to keep track of them\n  /// to ensure that we don't emit a \"redefinition\" error if we encounter a\n  /// correctly named definition after the renamed definition.\n  llvm::SmallPtrSet<const NamedDecl *, 4> TypoCorrectedFunctionDefinitions;\n\n  /// Stack of types that correspond to the parameter entities that are\n  /// currently being copy-initialized. Can be empty.\n  llvm::SmallVector<QualType, 4> CurrentParameterCopyTypes;\n\n  void ReadMethodPool(Selector Sel);\n  void updateOutOfDateSelector(Selector Sel);\n\n  /// Private Helper predicate to check for 'self'.\n  bool isSelfExpr(Expr *RExpr);\n  bool isSelfExpr(Expr *RExpr, const ObjCMethodDecl *Method);\n\n  /// Cause the active diagnostic on the DiagosticsEngine to be\n  /// emitted. This is closely coupled to the SemaDiagnosticBuilder class and\n  /// should not be used elsewhere.\n  void EmitCurrentDiagnostic(unsigned DiagID);\n\n  /// Records and restores the CurFPFeatures state on entry/exit of compound\n  /// statements.\n  class FPFeaturesStateRAII {\n  public:\n    FPFeaturesStateRAII(Sema &S) : S(S), OldFPFeaturesState(S.CurFPFeatures) {\n      OldOverrides = S.FpPragmaStack.CurrentValue;\n    }\n    ~FPFeaturesStateRAII() {\n      S.CurFPFeatures = OldFPFeaturesState;\n      S.FpPragmaStack.CurrentValue = OldOverrides;\n    }\n    FPOptionsOverride getOverrides() { return OldOverrides; }\n\n  private:\n    Sema& S;\n    FPOptions OldFPFeaturesState;\n    FPOptionsOverride OldOverrides;\n  };\n\n  void addImplicitTypedef(StringRef Name, QualType T);\n\n  bool WarnedStackExhausted = false;\n\npublic:\n  Sema(Preprocessor &pp, ASTContext &ctxt, ASTConsumer &consumer,\n       TranslationUnitKind TUKind = TU_Complete,\n       CodeCompleteConsumer *CompletionConsumer = nullptr);\n  ~Sema();\n\n  /// Perform initialization that occurs after the parser has been\n  /// initialized but before it parses anything.\n  void Initialize();\n\n  const LangOptions &getLangOpts() const { return LangOpts; }\n  OpenCLOptions &getOpenCLOptions() { return OpenCLFeatures; }\n  FPOptions     &getCurFPFeatures() { return CurFPFeatures; }\n\n  DiagnosticsEngine &getDiagnostics() const { return Diags; }\n  SourceManager &getSourceManager() const { return SourceMgr; }\n  Preprocessor &getPreprocessor() const { return PP; }\n  ASTContext &getASTContext() const { return Context; }\n  ASTConsumer &getASTConsumer() const { return Consumer; }\n  ASTMutationListener *getASTMutationListener() const;\n  ExternalSemaSource* getExternalSource() const { return ExternalSource; }\n\n  ///Registers an external source. If an external source already exists,\n  /// creates a multiplex external source and appends to it.\n  ///\n  ///\\param[in] E - A non-null external sema source.\n  ///\n  void addExternalSource(ExternalSemaSource *E);\n\n  void PrintStats() const;\n\n  /// Warn that the stack is nearly exhausted.\n  void warnStackExhausted(SourceLocation Loc);\n\n  /// Run some code with \"sufficient\" stack space. (Currently, at least 256K is\n  /// guaranteed). Produces a warning if we're low on stack space and allocates\n  /// more in that case. Use this in code that may recurse deeply (for example,\n  /// in template instantiation) to avoid stack overflow.\n  void runWithSufficientStackSpace(SourceLocation Loc,\n                                   llvm::function_ref<void()> Fn);\n\n  /// Helper class that creates diagnostics with optional\n  /// template instantiation stacks.\n  ///\n  /// This class provides a wrapper around the basic DiagnosticBuilder\n  /// class that emits diagnostics. ImmediateDiagBuilder is\n  /// responsible for emitting the diagnostic (as DiagnosticBuilder\n  /// does) and, if the diagnostic comes from inside a template\n  /// instantiation, printing the template instantiation stack as\n  /// well.\n  class ImmediateDiagBuilder : public DiagnosticBuilder {\n    Sema &SemaRef;\n    unsigned DiagID;\n\n  public:\n    ImmediateDiagBuilder(DiagnosticBuilder &DB, Sema &SemaRef, unsigned DiagID)\n        : DiagnosticBuilder(DB), SemaRef(SemaRef), DiagID(DiagID) {}\n    ImmediateDiagBuilder(DiagnosticBuilder &&DB, Sema &SemaRef, unsigned DiagID)\n        : DiagnosticBuilder(DB), SemaRef(SemaRef), DiagID(DiagID) {}\n\n    // This is a cunning lie. DiagnosticBuilder actually performs move\n    // construction in its copy constructor (but due to varied uses, it's not\n    // possible to conveniently express this as actual move construction). So\n    // the default copy ctor here is fine, because the base class disables the\n    // source anyway, so the user-defined ~ImmediateDiagBuilder is a safe no-op\n    // in that case anwyay.\n    ImmediateDiagBuilder(const ImmediateDiagBuilder &) = default;\n\n    ~ImmediateDiagBuilder() {\n      // If we aren't active, there is nothing to do.\n      if (!isActive()) return;\n\n      // Otherwise, we need to emit the diagnostic. First clear the diagnostic\n      // builder itself so it won't emit the diagnostic in its own destructor.\n      //\n      // This seems wasteful, in that as written the DiagnosticBuilder dtor will\n      // do its own needless checks to see if the diagnostic needs to be\n      // emitted. However, because we take care to ensure that the builder\n      // objects never escape, a sufficiently smart compiler will be able to\n      // eliminate that code.\n      Clear();\n\n      // Dispatch to Sema to emit the diagnostic.\n      SemaRef.EmitCurrentDiagnostic(DiagID);\n    }\n\n    /// Teach operator<< to produce an object of the correct type.\n    template <typename T>\n    friend const ImmediateDiagBuilder &\n    operator<<(const ImmediateDiagBuilder &Diag, const T &Value) {\n      const DiagnosticBuilder &BaseDiag = Diag;\n      BaseDiag << Value;\n      return Diag;\n    }\n\n    // It is necessary to limit this to rvalue reference to avoid calling this\n    // function with a bitfield lvalue argument since non-const reference to\n    // bitfield is not allowed.\n    template <typename T, typename = typename std::enable_if<\n                              !std::is_lvalue_reference<T>::value>::type>\n    const ImmediateDiagBuilder &operator<<(T &&V) const {\n      const DiagnosticBuilder &BaseDiag = *this;\n      BaseDiag << std::move(V);\n      return *this;\n    }\n  };\n\n  /// A generic diagnostic builder for errors which may or may not be deferred.\n  ///\n  /// In CUDA, there exist constructs (e.g. variable-length arrays, try/catch)\n  /// which are not allowed to appear inside __device__ functions and are\n  /// allowed to appear in __host__ __device__ functions only if the host+device\n  /// function is never codegen'ed.\n  ///\n  /// To handle this, we use the notion of \"deferred diagnostics\", where we\n  /// attach a diagnostic to a FunctionDecl that's emitted iff it's codegen'ed.\n  ///\n  /// This class lets you emit either a regular diagnostic, a deferred\n  /// diagnostic, or no diagnostic at all, according to an argument you pass to\n  /// its constructor, thus simplifying the process of creating these \"maybe\n  /// deferred\" diagnostics.\n  class SemaDiagnosticBuilder {\n  public:\n    enum Kind {\n      /// Emit no diagnostics.\n      K_Nop,\n      /// Emit the diagnostic immediately (i.e., behave like Sema::Diag()).\n      K_Immediate,\n      /// Emit the diagnostic immediately, and, if it's a warning or error, also\n      /// emit a call stack showing how this function can be reached by an a\n      /// priori known-emitted function.\n      K_ImmediateWithCallStack,\n      /// Create a deferred diagnostic, which is emitted only if the function\n      /// it's attached to is codegen'ed.  Also emit a call stack as with\n      /// K_ImmediateWithCallStack.\n      K_Deferred\n    };\n\n    SemaDiagnosticBuilder(Kind K, SourceLocation Loc, unsigned DiagID,\n                          FunctionDecl *Fn, Sema &S);\n    SemaDiagnosticBuilder(SemaDiagnosticBuilder &&D);\n    SemaDiagnosticBuilder(const SemaDiagnosticBuilder &) = default;\n    ~SemaDiagnosticBuilder();\n\n    bool isImmediate() const { return ImmediateDiag.hasValue(); }\n\n    /// Convertible to bool: True if we immediately emitted an error, false if\n    /// we didn't emit an error or we created a deferred error.\n    ///\n    /// Example usage:\n    ///\n    ///   if (SemaDiagnosticBuilder(...) << foo << bar)\n    ///     return ExprError();\n    ///\n    /// But see CUDADiagIfDeviceCode() and CUDADiagIfHostCode() -- you probably\n    /// want to use these instead of creating a SemaDiagnosticBuilder yourself.\n    operator bool() const { return isImmediate(); }\n\n    template <typename T>\n    friend const SemaDiagnosticBuilder &\n    operator<<(const SemaDiagnosticBuilder &Diag, const T &Value) {\n      if (Diag.ImmediateDiag.hasValue())\n        *Diag.ImmediateDiag << Value;\n      else if (Diag.PartialDiagId.hasValue())\n        Diag.S.DeviceDeferredDiags[Diag.Fn][*Diag.PartialDiagId].second\n            << Value;\n      return Diag;\n    }\n\n    // It is necessary to limit this to rvalue reference to avoid calling this\n    // function with a bitfield lvalue argument since non-const reference to\n    // bitfield is not allowed.\n    template <typename T, typename = typename std::enable_if<\n                              !std::is_lvalue_reference<T>::value>::type>\n    const SemaDiagnosticBuilder &operator<<(T &&V) const {\n      if (ImmediateDiag.hasValue())\n        *ImmediateDiag << std::move(V);\n      else if (PartialDiagId.hasValue())\n        S.DeviceDeferredDiags[Fn][*PartialDiagId].second << std::move(V);\n      return *this;\n    }\n\n    friend const SemaDiagnosticBuilder &\n    operator<<(const SemaDiagnosticBuilder &Diag, const PartialDiagnostic &PD) {\n      if (Diag.ImmediateDiag.hasValue())\n        PD.Emit(*Diag.ImmediateDiag);\n      else if (Diag.PartialDiagId.hasValue())\n        Diag.S.DeviceDeferredDiags[Diag.Fn][*Diag.PartialDiagId].second = PD;\n      return Diag;\n    }\n\n    void AddFixItHint(const FixItHint &Hint) const {\n      if (ImmediateDiag.hasValue())\n        ImmediateDiag->AddFixItHint(Hint);\n      else if (PartialDiagId.hasValue())\n        S.DeviceDeferredDiags[Fn][*PartialDiagId].second.AddFixItHint(Hint);\n    }\n\n    friend ExprResult ExprError(const SemaDiagnosticBuilder &) {\n      return ExprError();\n    }\n    friend StmtResult StmtError(const SemaDiagnosticBuilder &) {\n      return StmtError();\n    }\n    operator ExprResult() const { return ExprError(); }\n    operator StmtResult() const { return StmtError(); }\n    operator TypeResult() const { return TypeError(); }\n    operator DeclResult() const { return DeclResult(true); }\n    operator MemInitResult() const { return MemInitResult(true); }\n\n  private:\n    Sema &S;\n    SourceLocation Loc;\n    unsigned DiagID;\n    FunctionDecl *Fn;\n    bool ShowCallStack;\n\n    // Invariant: At most one of these Optionals has a value.\n    // FIXME: Switch these to a Variant once that exists.\n    llvm::Optional<ImmediateDiagBuilder> ImmediateDiag;\n    llvm::Optional<unsigned> PartialDiagId;\n  };\n\n  /// Is the last error level diagnostic immediate. This is used to determined\n  /// whether the next info diagnostic should be immediate.\n  bool IsLastErrorImmediate = true;\n\n  /// Emit a diagnostic.\n  SemaDiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID,\n                             bool DeferHint = false);\n\n  /// Emit a partial diagnostic.\n  SemaDiagnosticBuilder Diag(SourceLocation Loc, const PartialDiagnostic &PD,\n                             bool DeferHint = false);\n\n  /// Build a partial diagnostic.\n  PartialDiagnostic PDiag(unsigned DiagID = 0); // in SemaInternal.h\n\n  /// Whether uncompilable error has occurred. This includes error happens\n  /// in deferred diagnostics.\n  bool hasUncompilableErrorOccurred() const;\n\n  bool findMacroSpelling(SourceLocation &loc, StringRef name);\n\n  /// Get a string to suggest for zero-initialization of a type.\n  std::string\n  getFixItZeroInitializerForType(QualType T, SourceLocation Loc) const;\n  std::string getFixItZeroLiteralForType(QualType T, SourceLocation Loc) const;\n\n  /// Calls \\c Lexer::getLocForEndOfToken()\n  SourceLocation getLocForEndOfToken(SourceLocation Loc, unsigned Offset = 0);\n\n  /// Retrieve the module loader associated with the preprocessor.\n  ModuleLoader &getModuleLoader() const;\n\n  /// Invent a new identifier for parameters of abbreviated templates.\n  IdentifierInfo *\n  InventAbbreviatedTemplateParameterTypeName(IdentifierInfo *ParamName,\n                                             unsigned Index);\n\n  void emitAndClearUnusedLocalTypedefWarnings();\n\n  private:\n    /// Function or variable declarations to be checked for whether the deferred\n    /// diagnostics should be emitted.\n    SmallVector<Decl *, 4> DeclsToCheckForDeferredDiags;\n\n  public:\n  // Emit all deferred diagnostics.\n  void emitDeferredDiags();\n\n  enum TUFragmentKind {\n    /// The global module fragment, between 'module;' and a module-declaration.\n    Global,\n    /// A normal translation unit fragment. For a non-module unit, this is the\n    /// entire translation unit. Otherwise, it runs from the module-declaration\n    /// to the private-module-fragment (if any) or the end of the TU (if not).\n    Normal,\n    /// The private module fragment, between 'module :private;' and the end of\n    /// the translation unit.\n    Private\n  };\n\n  void ActOnStartOfTranslationUnit();\n  void ActOnEndOfTranslationUnit();\n  void ActOnEndOfTranslationUnitFragment(TUFragmentKind Kind);\n\n  void CheckDelegatingCtorCycles();\n\n  Scope *getScopeForContext(DeclContext *Ctx);\n\n  void PushFunctionScope();\n  void PushBlockScope(Scope *BlockScope, BlockDecl *Block);\n  sema::LambdaScopeInfo *PushLambdaScope();\n\n  /// This is used to inform Sema what the current TemplateParameterDepth\n  /// is during Parsing.  Currently it is used to pass on the depth\n  /// when parsing generic lambda 'auto' parameters.\n  void RecordParsingTemplateParameterDepth(unsigned Depth);\n\n  void PushCapturedRegionScope(Scope *RegionScope, CapturedDecl *CD,\n                               RecordDecl *RD, CapturedRegionKind K,\n                               unsigned OpenMPCaptureLevel = 0);\n\n  /// Custom deleter to allow FunctionScopeInfos to be kept alive for a short\n  /// time after they've been popped.\n  class PoppedFunctionScopeDeleter {\n    Sema *Self;\n\n  public:\n    explicit PoppedFunctionScopeDeleter(Sema *Self) : Self(Self) {}\n    void operator()(sema::FunctionScopeInfo *Scope) const;\n  };\n\n  using PoppedFunctionScopePtr =\n      std::unique_ptr<sema::FunctionScopeInfo, PoppedFunctionScopeDeleter>;\n\n  PoppedFunctionScopePtr\n  PopFunctionScopeInfo(const sema::AnalysisBasedWarnings::Policy *WP = nullptr,\n                       const Decl *D = nullptr,\n                       QualType BlockType = QualType());\n\n  sema::FunctionScopeInfo *getCurFunction() const {\n    return FunctionScopes.empty() ? nullptr : FunctionScopes.back();\n  }\n\n  sema::FunctionScopeInfo *getEnclosingFunction() const;\n\n  void setFunctionHasBranchIntoScope();\n  void setFunctionHasBranchProtectedScope();\n  void setFunctionHasIndirectGoto();\n\n  void PushCompoundScope(bool IsStmtExpr);\n  void PopCompoundScope();\n\n  sema::CompoundScopeInfo &getCurCompoundScope() const;\n\n  bool hasAnyUnrecoverableErrorsInThisFunction() const;\n\n  /// Retrieve the current block, if any.\n  sema::BlockScopeInfo *getCurBlock();\n\n  /// Get the innermost lambda enclosing the current location, if any. This\n  /// looks through intervening non-lambda scopes such as local functions and\n  /// blocks.\n  sema::LambdaScopeInfo *getEnclosingLambda() const;\n\n  /// Retrieve the current lambda scope info, if any.\n  /// \\param IgnoreNonLambdaCapturingScope true if should find the top-most\n  /// lambda scope info ignoring all inner capturing scopes that are not\n  /// lambda scopes.\n  sema::LambdaScopeInfo *\n  getCurLambda(bool IgnoreNonLambdaCapturingScope = false);\n\n  /// Retrieve the current generic lambda info, if any.\n  sema::LambdaScopeInfo *getCurGenericLambda();\n\n  /// Retrieve the current captured region, if any.\n  sema::CapturedRegionScopeInfo *getCurCapturedRegion();\n\n  /// WeakTopLevelDeclDecls - access to \\#pragma weak-generated Decls\n  SmallVectorImpl<Decl *> &WeakTopLevelDecls() { return WeakTopLevelDecl; }\n\n  /// Called before parsing a function declarator belonging to a function\n  /// declaration.\n  void ActOnStartFunctionDeclarationDeclarator(Declarator &D,\n                                               unsigned TemplateParameterDepth);\n\n  /// Called after parsing a function declarator belonging to a function\n  /// declaration.\n  void ActOnFinishFunctionDeclarationDeclarator(Declarator &D);\n\n  void ActOnComment(SourceRange Comment);\n\n  //===--------------------------------------------------------------------===//\n  // Type Analysis / Processing: SemaType.cpp.\n  //\n\n  QualType BuildQualifiedType(QualType T, SourceLocation Loc, Qualifiers Qs,\n                              const DeclSpec *DS = nullptr);\n  QualType BuildQualifiedType(QualType T, SourceLocation Loc, unsigned CVRA,\n                              const DeclSpec *DS = nullptr);\n  QualType BuildPointerType(QualType T,\n                            SourceLocation Loc, DeclarationName Entity);\n  QualType BuildReferenceType(QualType T, bool LValueRef,\n                              SourceLocation Loc, DeclarationName Entity);\n  QualType BuildArrayType(QualType T, ArrayType::ArraySizeModifier ASM,\n                          Expr *ArraySize, unsigned Quals,\n                          SourceRange Brackets, DeclarationName Entity);\n  QualType BuildVectorType(QualType T, Expr *VecSize, SourceLocation AttrLoc);\n  QualType BuildExtVectorType(QualType T, Expr *ArraySize,\n                              SourceLocation AttrLoc);\n  QualType BuildMatrixType(QualType T, Expr *NumRows, Expr *NumColumns,\n                           SourceLocation AttrLoc);\n\n  QualType BuildAddressSpaceAttr(QualType &T, LangAS ASIdx, Expr *AddrSpace,\n                                 SourceLocation AttrLoc);\n\n  /// Same as above, but constructs the AddressSpace index if not provided.\n  QualType BuildAddressSpaceAttr(QualType &T, Expr *AddrSpace,\n                                 SourceLocation AttrLoc);\n\n  bool CheckQualifiedFunctionForTypeId(QualType T, SourceLocation Loc);\n\n  bool CheckFunctionReturnType(QualType T, SourceLocation Loc);\n\n  /// Build a function type.\n  ///\n  /// This routine checks the function type according to C++ rules and\n  /// under the assumption that the result type and parameter types have\n  /// just been instantiated from a template. It therefore duplicates\n  /// some of the behavior of GetTypeForDeclarator, but in a much\n  /// simpler form that is only suitable for this narrow use case.\n  ///\n  /// \\param T The return type of the function.\n  ///\n  /// \\param ParamTypes The parameter types of the function. This array\n  /// will be modified to account for adjustments to the types of the\n  /// function parameters.\n  ///\n  /// \\param Loc The location of the entity whose type involves this\n  /// function type or, if there is no such entity, the location of the\n  /// type that will have function type.\n  ///\n  /// \\param Entity The name of the entity that involves the function\n  /// type, if known.\n  ///\n  /// \\param EPI Extra information about the function type. Usually this will\n  /// be taken from an existing function with the same prototype.\n  ///\n  /// \\returns A suitable function type, if there are no errors. The\n  /// unqualified type will always be a FunctionProtoType.\n  /// Otherwise, returns a NULL type.\n  QualType BuildFunctionType(QualType T,\n                             MutableArrayRef<QualType> ParamTypes,\n                             SourceLocation Loc, DeclarationName Entity,\n                             const FunctionProtoType::ExtProtoInfo &EPI);\n\n  QualType BuildMemberPointerType(QualType T, QualType Class,\n                                  SourceLocation Loc,\n                                  DeclarationName Entity);\n  QualType BuildBlockPointerType(QualType T,\n                                 SourceLocation Loc, DeclarationName Entity);\n  QualType BuildParenType(QualType T);\n  QualType BuildAtomicType(QualType T, SourceLocation Loc);\n  QualType BuildReadPipeType(QualType T,\n                         SourceLocation Loc);\n  QualType BuildWritePipeType(QualType T,\n                         SourceLocation Loc);\n  QualType BuildExtIntType(bool IsUnsigned, Expr *BitWidth, SourceLocation Loc);\n\n  TypeSourceInfo *GetTypeForDeclarator(Declarator &D, Scope *S);\n  TypeSourceInfo *GetTypeForDeclaratorCast(Declarator &D, QualType FromTy);\n\n  /// Package the given type and TSI into a ParsedType.\n  ParsedType CreateParsedType(QualType T, TypeSourceInfo *TInfo);\n  DeclarationNameInfo GetNameForDeclarator(Declarator &D);\n  DeclarationNameInfo GetNameFromUnqualifiedId(const UnqualifiedId &Name);\n  static QualType GetTypeFromParser(ParsedType Ty,\n                                    TypeSourceInfo **TInfo = nullptr);\n  CanThrowResult canThrow(const Stmt *E);\n  /// Determine whether the callee of a particular function call can throw.\n  /// E, D and Loc are all optional.\n  static CanThrowResult canCalleeThrow(Sema &S, const Expr *E, const Decl *D,\n                                       SourceLocation Loc = SourceLocation());\n  const FunctionProtoType *ResolveExceptionSpec(SourceLocation Loc,\n                                                const FunctionProtoType *FPT);\n  void UpdateExceptionSpec(FunctionDecl *FD,\n                           const FunctionProtoType::ExceptionSpecInfo &ESI);\n  bool CheckSpecifiedExceptionType(QualType &T, SourceRange Range);\n  bool CheckDistantExceptionSpec(QualType T);\n  bool CheckEquivalentExceptionSpec(FunctionDecl *Old, FunctionDecl *New);\n  bool CheckEquivalentExceptionSpec(\n      const FunctionProtoType *Old, SourceLocation OldLoc,\n      const FunctionProtoType *New, SourceLocation NewLoc);\n  bool CheckEquivalentExceptionSpec(\n      const PartialDiagnostic &DiagID, const PartialDiagnostic & NoteID,\n      const FunctionProtoType *Old, SourceLocation OldLoc,\n      const FunctionProtoType *New, SourceLocation NewLoc);\n  bool handlerCanCatch(QualType HandlerType, QualType ExceptionType);\n  bool CheckExceptionSpecSubset(const PartialDiagnostic &DiagID,\n                                const PartialDiagnostic &NestedDiagID,\n                                const PartialDiagnostic &NoteID,\n                                const PartialDiagnostic &NoThrowDiagID,\n                                const FunctionProtoType *Superset,\n                                SourceLocation SuperLoc,\n                                const FunctionProtoType *Subset,\n                                SourceLocation SubLoc);\n  bool CheckParamExceptionSpec(const PartialDiagnostic &NestedDiagID,\n                               const PartialDiagnostic &NoteID,\n                               const FunctionProtoType *Target,\n                               SourceLocation TargetLoc,\n                               const FunctionProtoType *Source,\n                               SourceLocation SourceLoc);\n\n  TypeResult ActOnTypeName(Scope *S, Declarator &D);\n\n  /// The parser has parsed the context-sensitive type 'instancetype'\n  /// in an Objective-C message declaration. Return the appropriate type.\n  ParsedType ActOnObjCInstanceType(SourceLocation Loc);\n\n  /// Abstract class used to diagnose incomplete types.\n  struct TypeDiagnoser {\n    TypeDiagnoser() {}\n\n    virtual void diagnose(Sema &S, SourceLocation Loc, QualType T) = 0;\n    virtual ~TypeDiagnoser() {}\n  };\n\n  static int getPrintable(int I) { return I; }\n  static unsigned getPrintable(unsigned I) { return I; }\n  static bool getPrintable(bool B) { return B; }\n  static const char * getPrintable(const char *S) { return S; }\n  static StringRef getPrintable(StringRef S) { return S; }\n  static const std::string &getPrintable(const std::string &S) { return S; }\n  static const IdentifierInfo *getPrintable(const IdentifierInfo *II) {\n    return II;\n  }\n  static DeclarationName getPrintable(DeclarationName N) { return N; }\n  static QualType getPrintable(QualType T) { return T; }\n  static SourceRange getPrintable(SourceRange R) { return R; }\n  static SourceRange getPrintable(SourceLocation L) { return L; }\n  static SourceRange getPrintable(const Expr *E) { return E->getSourceRange(); }\n  static SourceRange getPrintable(TypeLoc TL) { return TL.getSourceRange();}\n\n  template <typename... Ts> class BoundTypeDiagnoser : public TypeDiagnoser {\n  protected:\n    unsigned DiagID;\n    std::tuple<const Ts &...> Args;\n\n    template <std::size_t... Is>\n    void emit(const SemaDiagnosticBuilder &DB,\n              std::index_sequence<Is...>) const {\n      // Apply all tuple elements to the builder in order.\n      bool Dummy[] = {false, (DB << getPrintable(std::get<Is>(Args)))...};\n      (void)Dummy;\n    }\n\n  public:\n    BoundTypeDiagnoser(unsigned DiagID, const Ts &...Args)\n        : TypeDiagnoser(), DiagID(DiagID), Args(Args...) {\n      assert(DiagID != 0 && \"no diagnostic for type diagnoser\");\n    }\n\n    void diagnose(Sema &S, SourceLocation Loc, QualType T) override {\n      const SemaDiagnosticBuilder &DB = S.Diag(Loc, DiagID);\n      emit(DB, std::index_sequence_for<Ts...>());\n      DB << T;\n    }\n  };\n\n  /// Do a check to make sure \\p Name looks like a legal argument for the\n  /// swift_name attribute applied to decl \\p D.  Raise a diagnostic if the name\n  /// is invalid for the given declaration.\n  ///\n  /// \\p AL is used to provide caret diagnostics in case of a malformed name.\n  ///\n  /// \\returns true if the name is a valid swift name for \\p D, false otherwise.\n  bool DiagnoseSwiftName(Decl *D, StringRef Name, SourceLocation Loc,\n                         const ParsedAttr &AL, bool IsAsync);\n\n  /// A derivative of BoundTypeDiagnoser for which the diagnostic's type\n  /// parameter is preceded by a 0/1 enum that is 1 if the type is sizeless.\n  /// For example, a diagnostic with no other parameters would generally have\n  /// the form \"...%select{incomplete|sizeless}0 type %1...\".\n  template <typename... Ts>\n  class SizelessTypeDiagnoser : public BoundTypeDiagnoser<Ts...> {\n  public:\n    SizelessTypeDiagnoser(unsigned DiagID, const Ts &... Args)\n        : BoundTypeDiagnoser<Ts...>(DiagID, Args...) {}\n\n    void diagnose(Sema &S, SourceLocation Loc, QualType T) override {\n      const SemaDiagnosticBuilder &DB = S.Diag(Loc, this->DiagID);\n      this->emit(DB, std::index_sequence_for<Ts...>());\n      DB << T->isSizelessType() << T;\n    }\n  };\n\n  enum class CompleteTypeKind {\n    /// Apply the normal rules for complete types.  In particular,\n    /// treat all sizeless types as incomplete.\n    Normal,\n\n    /// Relax the normal rules for complete types so that they include\n    /// sizeless built-in types.\n    AcceptSizeless,\n\n    // FIXME: Eventually we should flip the default to Normal and opt in\n    // to AcceptSizeless rather than opt out of it.\n    Default = AcceptSizeless\n  };\n\nprivate:\n  /// Methods for marking which expressions involve dereferencing a pointer\n  /// marked with the 'noderef' attribute. Expressions are checked bottom up as\n  /// they are parsed, meaning that a noderef pointer may not be accessed. For\n  /// example, in `&*p` where `p` is a noderef pointer, we will first parse the\n  /// `*p`, but need to check that `address of` is called on it. This requires\n  /// keeping a container of all pending expressions and checking if the address\n  /// of them are eventually taken.\n  void CheckSubscriptAccessOfNoDeref(const ArraySubscriptExpr *E);\n  void CheckAddressOfNoDeref(const Expr *E);\n  void CheckMemberAccessOfNoDeref(const MemberExpr *E);\n\n  bool RequireCompleteTypeImpl(SourceLocation Loc, QualType T,\n                               CompleteTypeKind Kind, TypeDiagnoser *Diagnoser);\n\n  struct ModuleScope {\n    SourceLocation BeginLoc;\n    clang::Module *Module = nullptr;\n    bool ModuleInterface = false;\n    bool ImplicitGlobalModuleFragment = false;\n    VisibleModuleSet OuterVisibleModules;\n  };\n  /// The modules we're currently parsing.\n  llvm::SmallVector<ModuleScope, 16> ModuleScopes;\n\n  /// Namespace definitions that we will export when they finish.\n  llvm::SmallPtrSet<const NamespaceDecl*, 8> DeferredExportedNamespaces;\n\n  /// Get the module whose scope we are currently within.\n  Module *getCurrentModule() const {\n    return ModuleScopes.empty() ? nullptr : ModuleScopes.back().Module;\n  }\n\n  VisibleModuleSet VisibleModules;\n\npublic:\n  /// Get the module owning an entity.\n  Module *getOwningModule(const Decl *Entity) {\n    return Entity->getOwningModule();\n  }\n\n  /// Make a merged definition of an existing hidden definition \\p ND\n  /// visible at the specified location.\n  void makeMergedDefinitionVisible(NamedDecl *ND);\n\n  bool isModuleVisible(const Module *M, bool ModulePrivate = false);\n\n  // When loading a non-modular PCH files, this is used to restore module\n  // visibility.\n  void makeModuleVisible(Module *Mod, SourceLocation ImportLoc) {\n    VisibleModules.setVisible(Mod, ImportLoc);\n  }\n\n  /// Determine whether a declaration is visible to name lookup.\n  bool isVisible(const NamedDecl *D) {\n    return D->isUnconditionallyVisible() || isVisibleSlow(D);\n  }\n\n  /// Determine whether any declaration of an entity is visible.\n  bool\n  hasVisibleDeclaration(const NamedDecl *D,\n                        llvm::SmallVectorImpl<Module *> *Modules = nullptr) {\n    return isVisible(D) || hasVisibleDeclarationSlow(D, Modules);\n  }\n  bool hasVisibleDeclarationSlow(const NamedDecl *D,\n                                 llvm::SmallVectorImpl<Module *> *Modules);\n\n  bool hasVisibleMergedDefinition(NamedDecl *Def);\n  bool hasMergedDefinitionInCurrentModule(NamedDecl *Def);\n\n  /// Determine if \\p D and \\p Suggested have a structurally compatible\n  /// layout as described in C11 6.2.7/1.\n  bool hasStructuralCompatLayout(Decl *D, Decl *Suggested);\n\n  /// Determine if \\p D has a visible definition. If not, suggest a declaration\n  /// that should be made visible to expose the definition.\n  bool hasVisibleDefinition(NamedDecl *D, NamedDecl **Suggested,\n                            bool OnlyNeedComplete = false);\n  bool hasVisibleDefinition(const NamedDecl *D) {\n    NamedDecl *Hidden;\n    return hasVisibleDefinition(const_cast<NamedDecl*>(D), &Hidden);\n  }\n\n  /// Determine if the template parameter \\p D has a visible default argument.\n  bool\n  hasVisibleDefaultArgument(const NamedDecl *D,\n                            llvm::SmallVectorImpl<Module *> *Modules = nullptr);\n\n  /// Determine if there is a visible declaration of \\p D that is an explicit\n  /// specialization declaration for a specialization of a template. (For a\n  /// member specialization, use hasVisibleMemberSpecialization.)\n  bool hasVisibleExplicitSpecialization(\n      const NamedDecl *D, llvm::SmallVectorImpl<Module *> *Modules = nullptr);\n\n  /// Determine if there is a visible declaration of \\p D that is a member\n  /// specialization declaration (as opposed to an instantiated declaration).\n  bool hasVisibleMemberSpecialization(\n      const NamedDecl *D, llvm::SmallVectorImpl<Module *> *Modules = nullptr);\n\n  /// Determine if \\p A and \\p B are equivalent internal linkage declarations\n  /// from different modules, and thus an ambiguity error can be downgraded to\n  /// an extension warning.\n  bool isEquivalentInternalLinkageDeclaration(const NamedDecl *A,\n                                              const NamedDecl *B);\n  void diagnoseEquivalentInternalLinkageDeclarations(\n      SourceLocation Loc, const NamedDecl *D,\n      ArrayRef<const NamedDecl *> Equiv);\n\n  bool isUsualDeallocationFunction(const CXXMethodDecl *FD);\n\n  bool isCompleteType(SourceLocation Loc, QualType T,\n                      CompleteTypeKind Kind = CompleteTypeKind::Default) {\n    return !RequireCompleteTypeImpl(Loc, T, Kind, nullptr);\n  }\n  bool RequireCompleteType(SourceLocation Loc, QualType T,\n                           CompleteTypeKind Kind, TypeDiagnoser &Diagnoser);\n  bool RequireCompleteType(SourceLocation Loc, QualType T,\n                           CompleteTypeKind Kind, unsigned DiagID);\n\n  bool RequireCompleteType(SourceLocation Loc, QualType T,\n                           TypeDiagnoser &Diagnoser) {\n    return RequireCompleteType(Loc, T, CompleteTypeKind::Default, Diagnoser);\n  }\n  bool RequireCompleteType(SourceLocation Loc, QualType T, unsigned DiagID) {\n    return RequireCompleteType(Loc, T, CompleteTypeKind::Default, DiagID);\n  }\n\n  template <typename... Ts>\n  bool RequireCompleteType(SourceLocation Loc, QualType T, unsigned DiagID,\n                           const Ts &...Args) {\n    BoundTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireCompleteType(Loc, T, Diagnoser);\n  }\n\n  template <typename... Ts>\n  bool RequireCompleteSizedType(SourceLocation Loc, QualType T, unsigned DiagID,\n                                const Ts &... Args) {\n    SizelessTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireCompleteType(Loc, T, CompleteTypeKind::Normal, Diagnoser);\n  }\n\n  /// Get the type of expression E, triggering instantiation to complete the\n  /// type if necessary -- that is, if the expression refers to a templated\n  /// static data member of incomplete array type.\n  ///\n  /// May still return an incomplete type if instantiation was not possible or\n  /// if the type is incomplete for a different reason. Use\n  /// RequireCompleteExprType instead if a diagnostic is expected for an\n  /// incomplete expression type.\n  QualType getCompletedType(Expr *E);\n\n  void completeExprArrayBound(Expr *E);\n  bool RequireCompleteExprType(Expr *E, CompleteTypeKind Kind,\n                               TypeDiagnoser &Diagnoser);\n  bool RequireCompleteExprType(Expr *E, unsigned DiagID);\n\n  template <typename... Ts>\n  bool RequireCompleteExprType(Expr *E, unsigned DiagID, const Ts &...Args) {\n    BoundTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireCompleteExprType(E, CompleteTypeKind::Default, Diagnoser);\n  }\n\n  template <typename... Ts>\n  bool RequireCompleteSizedExprType(Expr *E, unsigned DiagID,\n                                    const Ts &... Args) {\n    SizelessTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireCompleteExprType(E, CompleteTypeKind::Normal, Diagnoser);\n  }\n\n  bool RequireLiteralType(SourceLocation Loc, QualType T,\n                          TypeDiagnoser &Diagnoser);\n  bool RequireLiteralType(SourceLocation Loc, QualType T, unsigned DiagID);\n\n  template <typename... Ts>\n  bool RequireLiteralType(SourceLocation Loc, QualType T, unsigned DiagID,\n                          const Ts &...Args) {\n    BoundTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireLiteralType(Loc, T, Diagnoser);\n  }\n\n  QualType getElaboratedType(ElaboratedTypeKeyword Keyword,\n                             const CXXScopeSpec &SS, QualType T,\n                             TagDecl *OwnedTagDecl = nullptr);\n\n  QualType BuildTypeofExprType(Expr *E, SourceLocation Loc);\n  /// If AsUnevaluated is false, E is treated as though it were an evaluated\n  /// context, such as when building a type for decltype(auto).\n  QualType BuildDecltypeType(Expr *E, SourceLocation Loc,\n                             bool AsUnevaluated = true);\n  QualType BuildUnaryTransformType(QualType BaseType,\n                                   UnaryTransformType::UTTKind UKind,\n                                   SourceLocation Loc);\n\n  //===--------------------------------------------------------------------===//\n  // Symbol table / Decl tracking callbacks: SemaDecl.cpp.\n  //\n\n  struct SkipBodyInfo {\n    SkipBodyInfo()\n        : ShouldSkip(false), CheckSameAsPrevious(false), Previous(nullptr),\n          New(nullptr) {}\n    bool ShouldSkip;\n    bool CheckSameAsPrevious;\n    NamedDecl *Previous;\n    NamedDecl *New;\n  };\n\n  DeclGroupPtrTy ConvertDeclToDeclGroup(Decl *Ptr, Decl *OwnedType = nullptr);\n\n  void DiagnoseUseOfUnimplementedSelectors();\n\n  bool isSimpleTypeSpecifier(tok::TokenKind Kind) const;\n\n  ParsedType getTypeName(const IdentifierInfo &II, SourceLocation NameLoc,\n                         Scope *S, CXXScopeSpec *SS = nullptr,\n                         bool isClassName = false, bool HasTrailingDot = false,\n                         ParsedType ObjectType = nullptr,\n                         bool IsCtorOrDtorName = false,\n                         bool WantNontrivialTypeSourceInfo = false,\n                         bool IsClassTemplateDeductionContext = true,\n                         IdentifierInfo **CorrectedII = nullptr);\n  TypeSpecifierType isTagName(IdentifierInfo &II, Scope *S);\n  bool isMicrosoftMissingTypename(const CXXScopeSpec *SS, Scope *S);\n  void DiagnoseUnknownTypeName(IdentifierInfo *&II,\n                               SourceLocation IILoc,\n                               Scope *S,\n                               CXXScopeSpec *SS,\n                               ParsedType &SuggestedType,\n                               bool IsTemplateName = false);\n\n  /// Attempt to behave like MSVC in situations where lookup of an unqualified\n  /// type name has failed in a dependent context. In these situations, we\n  /// automatically form a DependentTypeName that will retry lookup in a related\n  /// scope during instantiation.\n  ParsedType ActOnMSVCUnknownTypeName(const IdentifierInfo &II,\n                                      SourceLocation NameLoc,\n                                      bool IsTemplateTypeArg);\n\n  /// Describes the result of the name lookup and resolution performed\n  /// by \\c ClassifyName().\n  enum NameClassificationKind {\n    /// This name is not a type or template in this context, but might be\n    /// something else.\n    NC_Unknown,\n    /// Classification failed; an error has been produced.\n    NC_Error,\n    /// The name has been typo-corrected to a keyword.\n    NC_Keyword,\n    /// The name was classified as a type.\n    NC_Type,\n    /// The name was classified as a specific non-type, non-template\n    /// declaration. ActOnNameClassifiedAsNonType should be called to\n    /// convert the declaration to an expression.\n    NC_NonType,\n    /// The name was classified as an ADL-only function name.\n    /// ActOnNameClassifiedAsUndeclaredNonType should be called to convert the\n    /// result to an expression.\n    NC_UndeclaredNonType,\n    /// The name denotes a member of a dependent type that could not be\n    /// resolved. ActOnNameClassifiedAsDependentNonType should be called to\n    /// convert the result to an expression.\n    NC_DependentNonType,\n    /// The name was classified as an overload set, and an expression\n    /// representing that overload set has been formed.\n    /// ActOnNameClassifiedAsOverloadSet should be called to form a suitable\n    /// expression referencing the overload set.\n    NC_OverloadSet,\n    /// The name was classified as a template whose specializations are types.\n    NC_TypeTemplate,\n    /// The name was classified as a variable template name.\n    NC_VarTemplate,\n    /// The name was classified as a function template name.\n    NC_FunctionTemplate,\n    /// The name was classified as an ADL-only function template name.\n    NC_UndeclaredTemplate,\n    /// The name was classified as a concept name.\n    NC_Concept,\n  };\n\n  class NameClassification {\n    NameClassificationKind Kind;\n    union {\n      ExprResult Expr;\n      NamedDecl *NonTypeDecl;\n      TemplateName Template;\n      ParsedType Type;\n    };\n\n    explicit NameClassification(NameClassificationKind Kind) : Kind(Kind) {}\n\n  public:\n    NameClassification(ParsedType Type) : Kind(NC_Type), Type(Type) {}\n\n    NameClassification(const IdentifierInfo *Keyword) : Kind(NC_Keyword) {}\n\n    static NameClassification Error() {\n      return NameClassification(NC_Error);\n    }\n\n    static NameClassification Unknown() {\n      return NameClassification(NC_Unknown);\n    }\n\n    static NameClassification OverloadSet(ExprResult E) {\n      NameClassification Result(NC_OverloadSet);\n      Result.Expr = E;\n      return Result;\n    }\n\n    static NameClassification NonType(NamedDecl *D) {\n      NameClassification Result(NC_NonType);\n      Result.NonTypeDecl = D;\n      return Result;\n    }\n\n    static NameClassification UndeclaredNonType() {\n      return NameClassification(NC_UndeclaredNonType);\n    }\n\n    static NameClassification DependentNonType() {\n      return NameClassification(NC_DependentNonType);\n    }\n\n    static NameClassification TypeTemplate(TemplateName Name) {\n      NameClassification Result(NC_TypeTemplate);\n      Result.Template = Name;\n      return Result;\n    }\n\n    static NameClassification VarTemplate(TemplateName Name) {\n      NameClassification Result(NC_VarTemplate);\n      Result.Template = Name;\n      return Result;\n    }\n\n    static NameClassification FunctionTemplate(TemplateName Name) {\n      NameClassification Result(NC_FunctionTemplate);\n      Result.Template = Name;\n      return Result;\n    }\n\n    static NameClassification Concept(TemplateName Name) {\n      NameClassification Result(NC_Concept);\n      Result.Template = Name;\n      return Result;\n    }\n\n    static NameClassification UndeclaredTemplate(TemplateName Name) {\n      NameClassification Result(NC_UndeclaredTemplate);\n      Result.Template = Name;\n      return Result;\n    }\n\n    NameClassificationKind getKind() const { return Kind; }\n\n    ExprResult getExpression() const {\n      assert(Kind == NC_OverloadSet);\n      return Expr;\n    }\n\n    ParsedType getType() const {\n      assert(Kind == NC_Type);\n      return Type;\n    }\n\n    NamedDecl *getNonTypeDecl() const {\n      assert(Kind == NC_NonType);\n      return NonTypeDecl;\n    }\n\n    TemplateName getTemplateName() const {\n      assert(Kind == NC_TypeTemplate || Kind == NC_FunctionTemplate ||\n             Kind == NC_VarTemplate || Kind == NC_Concept ||\n             Kind == NC_UndeclaredTemplate);\n      return Template;\n    }\n\n    TemplateNameKind getTemplateNameKind() const {\n      switch (Kind) {\n      case NC_TypeTemplate:\n        return TNK_Type_template;\n      case NC_FunctionTemplate:\n        return TNK_Function_template;\n      case NC_VarTemplate:\n        return TNK_Var_template;\n      case NC_Concept:\n        return TNK_Concept_template;\n      case NC_UndeclaredTemplate:\n        return TNK_Undeclared_template;\n      default:\n        llvm_unreachable(\"unsupported name classification.\");\n      }\n    }\n  };\n\n  /// Perform name lookup on the given name, classifying it based on\n  /// the results of name lookup and the following token.\n  ///\n  /// This routine is used by the parser to resolve identifiers and help direct\n  /// parsing. When the identifier cannot be found, this routine will attempt\n  /// to correct the typo and classify based on the resulting name.\n  ///\n  /// \\param S The scope in which we're performing name lookup.\n  ///\n  /// \\param SS The nested-name-specifier that precedes the name.\n  ///\n  /// \\param Name The identifier. If typo correction finds an alternative name,\n  /// this pointer parameter will be updated accordingly.\n  ///\n  /// \\param NameLoc The location of the identifier.\n  ///\n  /// \\param NextToken The token following the identifier. Used to help\n  /// disambiguate the name.\n  ///\n  /// \\param CCC The correction callback, if typo correction is desired.\n  NameClassification ClassifyName(Scope *S, CXXScopeSpec &SS,\n                                  IdentifierInfo *&Name, SourceLocation NameLoc,\n                                  const Token &NextToken,\n                                  CorrectionCandidateCallback *CCC = nullptr);\n\n  /// Act on the result of classifying a name as an undeclared (ADL-only)\n  /// non-type declaration.\n  ExprResult ActOnNameClassifiedAsUndeclaredNonType(IdentifierInfo *Name,\n                                                    SourceLocation NameLoc);\n  /// Act on the result of classifying a name as an undeclared member of a\n  /// dependent base class.\n  ExprResult ActOnNameClassifiedAsDependentNonType(const CXXScopeSpec &SS,\n                                                   IdentifierInfo *Name,\n                                                   SourceLocation NameLoc,\n                                                   bool IsAddressOfOperand);\n  /// Act on the result of classifying a name as a specific non-type\n  /// declaration.\n  ExprResult ActOnNameClassifiedAsNonType(Scope *S, const CXXScopeSpec &SS,\n                                          NamedDecl *Found,\n                                          SourceLocation NameLoc,\n                                          const Token &NextToken);\n  /// Act on the result of classifying a name as an overload set.\n  ExprResult ActOnNameClassifiedAsOverloadSet(Scope *S, Expr *OverloadSet);\n\n  /// Describes the detailed kind of a template name. Used in diagnostics.\n  enum class TemplateNameKindForDiagnostics {\n    ClassTemplate,\n    FunctionTemplate,\n    VarTemplate,\n    AliasTemplate,\n    TemplateTemplateParam,\n    Concept,\n    DependentTemplate\n  };\n  TemplateNameKindForDiagnostics\n  getTemplateNameKindForDiagnostics(TemplateName Name);\n\n  /// Determine whether it's plausible that E was intended to be a\n  /// template-name.\n  bool mightBeIntendedToBeTemplateName(ExprResult E, bool &Dependent) {\n    if (!getLangOpts().CPlusPlus || E.isInvalid())\n      return false;\n    Dependent = false;\n    if (auto *DRE = dyn_cast<DeclRefExpr>(E.get()))\n      return !DRE->hasExplicitTemplateArgs();\n    if (auto *ME = dyn_cast<MemberExpr>(E.get()))\n      return !ME->hasExplicitTemplateArgs();\n    Dependent = true;\n    if (auto *DSDRE = dyn_cast<DependentScopeDeclRefExpr>(E.get()))\n      return !DSDRE->hasExplicitTemplateArgs();\n    if (auto *DSME = dyn_cast<CXXDependentScopeMemberExpr>(E.get()))\n      return !DSME->hasExplicitTemplateArgs();\n    // Any additional cases recognized here should also be handled by\n    // diagnoseExprIntendedAsTemplateName.\n    return false;\n  }\n  void diagnoseExprIntendedAsTemplateName(Scope *S, ExprResult TemplateName,\n                                          SourceLocation Less,\n                                          SourceLocation Greater);\n\n  Decl *ActOnDeclarator(Scope *S, Declarator &D);\n\n  NamedDecl *HandleDeclarator(Scope *S, Declarator &D,\n                              MultiTemplateParamsArg TemplateParameterLists);\n  void RegisterLocallyScopedExternCDecl(NamedDecl *ND, Scope *S);\n  bool DiagnoseClassNameShadow(DeclContext *DC, DeclarationNameInfo Info);\n  bool diagnoseQualifiedDeclaration(CXXScopeSpec &SS, DeclContext *DC,\n                                    DeclarationName Name, SourceLocation Loc,\n                                    bool IsTemplateId);\n  void\n  diagnoseIgnoredQualifiers(unsigned DiagID, unsigned Quals,\n                            SourceLocation FallbackLoc,\n                            SourceLocation ConstQualLoc = SourceLocation(),\n                            SourceLocation VolatileQualLoc = SourceLocation(),\n                            SourceLocation RestrictQualLoc = SourceLocation(),\n                            SourceLocation AtomicQualLoc = SourceLocation(),\n                            SourceLocation UnalignedQualLoc = SourceLocation());\n\n  static bool adjustContextForLocalExternDecl(DeclContext *&DC);\n  void DiagnoseFunctionSpecifiers(const DeclSpec &DS);\n  NamedDecl *getShadowedDeclaration(const TypedefNameDecl *D,\n                                    const LookupResult &R);\n  NamedDecl *getShadowedDeclaration(const VarDecl *D, const LookupResult &R);\n  NamedDecl *getShadowedDeclaration(const BindingDecl *D,\n                                    const LookupResult &R);\n  void CheckShadow(NamedDecl *D, NamedDecl *ShadowedDecl,\n                   const LookupResult &R);\n  void CheckShadow(Scope *S, VarDecl *D);\n\n  /// Warn if 'E', which is an expression that is about to be modified, refers\n  /// to a shadowing declaration.\n  void CheckShadowingDeclModification(Expr *E, SourceLocation Loc);\n\n  void DiagnoseShadowingLambdaDecls(const sema::LambdaScopeInfo *LSI);\n\nprivate:\n  /// Map of current shadowing declarations to shadowed declarations. Warn if\n  /// it looks like the user is trying to modify the shadowing declaration.\n  llvm::DenseMap<const NamedDecl *, const NamedDecl *> ShadowingDecls;\n\npublic:\n  void CheckCastAlign(Expr *Op, QualType T, SourceRange TRange);\n  void handleTagNumbering(const TagDecl *Tag, Scope *TagScope);\n  void setTagNameForLinkagePurposes(TagDecl *TagFromDeclSpec,\n                                    TypedefNameDecl *NewTD);\n  void CheckTypedefForVariablyModifiedType(Scope *S, TypedefNameDecl *D);\n  NamedDecl* ActOnTypedefDeclarator(Scope* S, Declarator& D, DeclContext* DC,\n                                    TypeSourceInfo *TInfo,\n                                    LookupResult &Previous);\n  NamedDecl* ActOnTypedefNameDecl(Scope* S, DeclContext* DC, TypedefNameDecl *D,\n                                  LookupResult &Previous, bool &Redeclaration);\n  NamedDecl *ActOnVariableDeclarator(Scope *S, Declarator &D, DeclContext *DC,\n                                     TypeSourceInfo *TInfo,\n                                     LookupResult &Previous,\n                                     MultiTemplateParamsArg TemplateParamLists,\n                                     bool &AddToScope,\n                                     ArrayRef<BindingDecl *> Bindings = None);\n  NamedDecl *\n  ActOnDecompositionDeclarator(Scope *S, Declarator &D,\n                               MultiTemplateParamsArg TemplateParamLists);\n  // Returns true if the variable declaration is a redeclaration\n  bool CheckVariableDeclaration(VarDecl *NewVD, LookupResult &Previous);\n  void CheckVariableDeclarationType(VarDecl *NewVD);\n  bool DeduceVariableDeclarationType(VarDecl *VDecl, bool DirectInit,\n                                     Expr *Init);\n  void CheckCompleteVariableDeclaration(VarDecl *VD);\n  void CheckCompleteDecompositionDeclaration(DecompositionDecl *DD);\n  void MaybeSuggestAddingStaticToDecl(const FunctionDecl *D);\n\n  NamedDecl* ActOnFunctionDeclarator(Scope* S, Declarator& D, DeclContext* DC,\n                                     TypeSourceInfo *TInfo,\n                                     LookupResult &Previous,\n                                     MultiTemplateParamsArg TemplateParamLists,\n                                     bool &AddToScope);\n  bool AddOverriddenMethods(CXXRecordDecl *DC, CXXMethodDecl *MD);\n\n  enum class CheckConstexprKind {\n    /// Diagnose issues that are non-constant or that are extensions.\n    Diagnose,\n    /// Identify whether this function satisfies the formal rules for constexpr\n    /// functions in the current lanugage mode (with no extensions).\n    CheckValid\n  };\n\n  bool CheckConstexprFunctionDefinition(const FunctionDecl *FD,\n                                        CheckConstexprKind Kind);\n\n  void DiagnoseHiddenVirtualMethods(CXXMethodDecl *MD);\n  void FindHiddenVirtualMethods(CXXMethodDecl *MD,\n                          SmallVectorImpl<CXXMethodDecl*> &OverloadedMethods);\n  void NoteHiddenVirtualMethods(CXXMethodDecl *MD,\n                          SmallVectorImpl<CXXMethodDecl*> &OverloadedMethods);\n  // Returns true if the function declaration is a redeclaration\n  bool CheckFunctionDeclaration(Scope *S,\n                                FunctionDecl *NewFD, LookupResult &Previous,\n                                bool IsMemberSpecialization);\n  bool shouldLinkDependentDeclWithPrevious(Decl *D, Decl *OldDecl);\n  bool canFullyTypeCheckRedeclaration(ValueDecl *NewD, ValueDecl *OldD,\n                                      QualType NewT, QualType OldT);\n  void CheckMain(FunctionDecl *FD, const DeclSpec &D);\n  void CheckMSVCRTEntryPoint(FunctionDecl *FD);\n  Attr *getImplicitCodeSegOrSectionAttrForFunction(const FunctionDecl *FD,\n                                                   bool IsDefinition);\n  void CheckFunctionOrTemplateParamDeclarator(Scope *S, Declarator &D);\n  Decl *ActOnParamDeclarator(Scope *S, Declarator &D);\n  ParmVarDecl *BuildParmVarDeclForTypedef(DeclContext *DC,\n                                          SourceLocation Loc,\n                                          QualType T);\n  ParmVarDecl *CheckParameter(DeclContext *DC, SourceLocation StartLoc,\n                              SourceLocation NameLoc, IdentifierInfo *Name,\n                              QualType T, TypeSourceInfo *TSInfo,\n                              StorageClass SC);\n  void ActOnParamDefaultArgument(Decl *param,\n                                 SourceLocation EqualLoc,\n                                 Expr *defarg);\n  void ActOnParamUnparsedDefaultArgument(Decl *param, SourceLocation EqualLoc,\n                                         SourceLocation ArgLoc);\n  void ActOnParamDefaultArgumentError(Decl *param, SourceLocation EqualLoc);\n  ExprResult ConvertParamDefaultArgument(const ParmVarDecl *Param,\n                                         Expr *DefaultArg,\n                                         SourceLocation EqualLoc);\n  void SetParamDefaultArgument(ParmVarDecl *Param, Expr *DefaultArg,\n                               SourceLocation EqualLoc);\n\n  // Contexts where using non-trivial C union types can be disallowed. This is\n  // passed to err_non_trivial_c_union_in_invalid_context.\n  enum NonTrivialCUnionContext {\n    // Function parameter.\n    NTCUC_FunctionParam,\n    // Function return.\n    NTCUC_FunctionReturn,\n    // Default-initialized object.\n    NTCUC_DefaultInitializedObject,\n    // Variable with automatic storage duration.\n    NTCUC_AutoVar,\n    // Initializer expression that might copy from another object.\n    NTCUC_CopyInit,\n    // Assignment.\n    NTCUC_Assignment,\n    // Compound literal.\n    NTCUC_CompoundLiteral,\n    // Block capture.\n    NTCUC_BlockCapture,\n    // lvalue-to-rvalue conversion of volatile type.\n    NTCUC_LValueToRValueVolatile,\n  };\n\n  /// Emit diagnostics if the initializer or any of its explicit or\n  /// implicitly-generated subexpressions require copying or\n  /// default-initializing a type that is or contains a C union type that is\n  /// non-trivial to copy or default-initialize.\n  void checkNonTrivialCUnionInInitializer(const Expr *Init, SourceLocation Loc);\n\n  // These flags are passed to checkNonTrivialCUnion.\n  enum NonTrivialCUnionKind {\n    NTCUK_Init = 0x1,\n    NTCUK_Destruct = 0x2,\n    NTCUK_Copy = 0x4,\n  };\n\n  /// Emit diagnostics if a non-trivial C union type or a struct that contains\n  /// a non-trivial C union is used in an invalid context.\n  void checkNonTrivialCUnion(QualType QT, SourceLocation Loc,\n                             NonTrivialCUnionContext UseContext,\n                             unsigned NonTrivialKind);\n\n  void AddInitializerToDecl(Decl *dcl, Expr *init, bool DirectInit);\n  void ActOnUninitializedDecl(Decl *dcl);\n  void ActOnInitializerError(Decl *Dcl);\n\n  void ActOnPureSpecifier(Decl *D, SourceLocation PureSpecLoc);\n  void ActOnCXXForRangeDecl(Decl *D);\n  StmtResult ActOnCXXForRangeIdentifier(Scope *S, SourceLocation IdentLoc,\n                                        IdentifierInfo *Ident,\n                                        ParsedAttributes &Attrs,\n                                        SourceLocation AttrEnd);\n  void SetDeclDeleted(Decl *dcl, SourceLocation DelLoc);\n  void SetDeclDefaulted(Decl *dcl, SourceLocation DefaultLoc);\n  void CheckStaticLocalForDllExport(VarDecl *VD);\n  void FinalizeDeclaration(Decl *D);\n  DeclGroupPtrTy FinalizeDeclaratorGroup(Scope *S, const DeclSpec &DS,\n                                         ArrayRef<Decl *> Group);\n  DeclGroupPtrTy BuildDeclaratorGroup(MutableArrayRef<Decl *> Group);\n\n  /// Should be called on all declarations that might have attached\n  /// documentation comments.\n  void ActOnDocumentableDecl(Decl *D);\n  void ActOnDocumentableDecls(ArrayRef<Decl *> Group);\n\n  void ActOnFinishKNRParamDeclarations(Scope *S, Declarator &D,\n                                       SourceLocation LocAfterDecls);\n  void CheckForFunctionRedefinition(\n      FunctionDecl *FD, const FunctionDecl *EffectiveDefinition = nullptr,\n      SkipBodyInfo *SkipBody = nullptr);\n  Decl *ActOnStartOfFunctionDef(Scope *S, Declarator &D,\n                                MultiTemplateParamsArg TemplateParamLists,\n                                SkipBodyInfo *SkipBody = nullptr);\n  Decl *ActOnStartOfFunctionDef(Scope *S, Decl *D,\n                                SkipBodyInfo *SkipBody = nullptr);\n  void ActOnStartTrailingRequiresClause(Scope *S, Declarator &D);\n  ExprResult ActOnFinishTrailingRequiresClause(ExprResult ConstraintExpr);\n  ExprResult ActOnRequiresClause(ExprResult ConstraintExpr);\n  void ActOnStartOfObjCMethodDef(Scope *S, Decl *D);\n  bool isObjCMethodDecl(Decl *D) {\n    return D && isa<ObjCMethodDecl>(D);\n  }\n\n  /// Determine whether we can delay parsing the body of a function or\n  /// function template until it is used, assuming we don't care about emitting\n  /// code for that function.\n  ///\n  /// This will be \\c false if we may need the body of the function in the\n  /// middle of parsing an expression (where it's impractical to switch to\n  /// parsing a different function), for instance, if it's constexpr in C++11\n  /// or has an 'auto' return type in C++14. These cases are essentially bugs.\n  bool canDelayFunctionBody(const Declarator &D);\n\n  /// Determine whether we can skip parsing the body of a function\n  /// definition, assuming we don't care about analyzing its body or emitting\n  /// code for that function.\n  ///\n  /// This will be \\c false only if we may need the body of the function in\n  /// order to parse the rest of the program (for instance, if it is\n  /// \\c constexpr in C++11 or has an 'auto' return type in C++14).\n  bool canSkipFunctionBody(Decl *D);\n\n  void computeNRVO(Stmt *Body, sema::FunctionScopeInfo *Scope);\n  Decl *ActOnFinishFunctionBody(Decl *Decl, Stmt *Body);\n  Decl *ActOnFinishFunctionBody(Decl *Decl, Stmt *Body, bool IsInstantiation);\n  Decl *ActOnSkippedFunctionBody(Decl *Decl);\n  void ActOnFinishInlineFunctionDef(FunctionDecl *D);\n\n  /// ActOnFinishDelayedAttribute - Invoked when we have finished parsing an\n  /// attribute for which parsing is delayed.\n  void ActOnFinishDelayedAttribute(Scope *S, Decl *D, ParsedAttributes &Attrs);\n\n  /// Diagnose any unused parameters in the given sequence of\n  /// ParmVarDecl pointers.\n  void DiagnoseUnusedParameters(ArrayRef<ParmVarDecl *> Parameters);\n\n  /// Diagnose whether the size of parameters or return value of a\n  /// function or obj-c method definition is pass-by-value and larger than a\n  /// specified threshold.\n  void\n  DiagnoseSizeOfParametersAndReturnValue(ArrayRef<ParmVarDecl *> Parameters,\n                                         QualType ReturnTy, NamedDecl *D);\n\n  void DiagnoseInvalidJumps(Stmt *Body);\n  Decl *ActOnFileScopeAsmDecl(Expr *expr,\n                              SourceLocation AsmLoc,\n                              SourceLocation RParenLoc);\n\n  /// Handle a C++11 empty-declaration and attribute-declaration.\n  Decl *ActOnEmptyDeclaration(Scope *S, const ParsedAttributesView &AttrList,\n                              SourceLocation SemiLoc);\n\n  enum class ModuleDeclKind {\n    Interface,      ///< 'export module X;'\n    Implementation, ///< 'module X;'\n  };\n\n  /// The parser has processed a module-declaration that begins the definition\n  /// of a module interface or implementation.\n  DeclGroupPtrTy ActOnModuleDecl(SourceLocation StartLoc,\n                                 SourceLocation ModuleLoc, ModuleDeclKind MDK,\n                                 ModuleIdPath Path, bool IsFirstDecl);\n\n  /// The parser has processed a global-module-fragment declaration that begins\n  /// the definition of the global module fragment of the current module unit.\n  /// \\param ModuleLoc The location of the 'module' keyword.\n  DeclGroupPtrTy ActOnGlobalModuleFragmentDecl(SourceLocation ModuleLoc);\n\n  /// The parser has processed a private-module-fragment declaration that begins\n  /// the definition of the private module fragment of the current module unit.\n  /// \\param ModuleLoc The location of the 'module' keyword.\n  /// \\param PrivateLoc The location of the 'private' keyword.\n  DeclGroupPtrTy ActOnPrivateModuleFragmentDecl(SourceLocation ModuleLoc,\n                                                SourceLocation PrivateLoc);\n\n  /// The parser has processed a module import declaration.\n  ///\n  /// \\param StartLoc The location of the first token in the declaration. This\n  ///        could be the location of an '@', 'export', or 'import'.\n  /// \\param ExportLoc The location of the 'export' keyword, if any.\n  /// \\param ImportLoc The location of the 'import' keyword.\n  /// \\param Path The module access path.\n  DeclResult ActOnModuleImport(SourceLocation StartLoc,\n                               SourceLocation ExportLoc,\n                               SourceLocation ImportLoc, ModuleIdPath Path);\n  DeclResult ActOnModuleImport(SourceLocation StartLoc,\n                               SourceLocation ExportLoc,\n                               SourceLocation ImportLoc, Module *M,\n                               ModuleIdPath Path = {});\n\n  /// The parser has processed a module import translated from a\n  /// #include or similar preprocessing directive.\n  void ActOnModuleInclude(SourceLocation DirectiveLoc, Module *Mod);\n  void BuildModuleInclude(SourceLocation DirectiveLoc, Module *Mod);\n\n  /// The parsed has entered a submodule.\n  void ActOnModuleBegin(SourceLocation DirectiveLoc, Module *Mod);\n  /// The parser has left a submodule.\n  void ActOnModuleEnd(SourceLocation DirectiveLoc, Module *Mod);\n\n  /// Create an implicit import of the given module at the given\n  /// source location, for error recovery, if possible.\n  ///\n  /// This routine is typically used when an entity found by name lookup\n  /// is actually hidden within a module that we know about but the user\n  /// has forgotten to import.\n  void createImplicitModuleImportForErrorRecovery(SourceLocation Loc,\n                                                  Module *Mod);\n\n  /// Kinds of missing import. Note, the values of these enumerators correspond\n  /// to %select values in diagnostics.\n  enum class MissingImportKind {\n    Declaration,\n    Definition,\n    DefaultArgument,\n    ExplicitSpecialization,\n    PartialSpecialization\n  };\n\n  /// Diagnose that the specified declaration needs to be visible but\n  /// isn't, and suggest a module import that would resolve the problem.\n  void diagnoseMissingImport(SourceLocation Loc, NamedDecl *Decl,\n                             MissingImportKind MIK, bool Recover = true);\n  void diagnoseMissingImport(SourceLocation Loc, NamedDecl *Decl,\n                             SourceLocation DeclLoc, ArrayRef<Module *> Modules,\n                             MissingImportKind MIK, bool Recover);\n\n  Decl *ActOnStartExportDecl(Scope *S, SourceLocation ExportLoc,\n                             SourceLocation LBraceLoc);\n  Decl *ActOnFinishExportDecl(Scope *S, Decl *ExportDecl,\n                              SourceLocation RBraceLoc);\n\n  /// We've found a use of a templated declaration that would trigger an\n  /// implicit instantiation. Check that any relevant explicit specializations\n  /// and partial specializations are visible, and diagnose if not.\n  void checkSpecializationVisibility(SourceLocation Loc, NamedDecl *Spec);\n\n  /// Retrieve a suitable printing policy for diagnostics.\n  PrintingPolicy getPrintingPolicy() const {\n    return getPrintingPolicy(Context, PP);\n  }\n\n  /// Retrieve a suitable printing policy for diagnostics.\n  static PrintingPolicy getPrintingPolicy(const ASTContext &Ctx,\n                                          const Preprocessor &PP);\n\n  /// Scope actions.\n  void ActOnPopScope(SourceLocation Loc, Scope *S);\n  void ActOnTranslationUnitScope(Scope *S);\n\n  Decl *ParsedFreeStandingDeclSpec(Scope *S, AccessSpecifier AS, DeclSpec &DS,\n                                   RecordDecl *&AnonRecord);\n  Decl *ParsedFreeStandingDeclSpec(Scope *S, AccessSpecifier AS, DeclSpec &DS,\n                                   MultiTemplateParamsArg TemplateParams,\n                                   bool IsExplicitInstantiation,\n                                   RecordDecl *&AnonRecord);\n\n  Decl *BuildAnonymousStructOrUnion(Scope *S, DeclSpec &DS,\n                                    AccessSpecifier AS,\n                                    RecordDecl *Record,\n                                    const PrintingPolicy &Policy);\n\n  Decl *BuildMicrosoftCAnonymousStruct(Scope *S, DeclSpec &DS,\n                                       RecordDecl *Record);\n\n  /// Common ways to introduce type names without a tag for use in diagnostics.\n  /// Keep in sync with err_tag_reference_non_tag.\n  enum NonTagKind {\n    NTK_NonStruct,\n    NTK_NonClass,\n    NTK_NonUnion,\n    NTK_NonEnum,\n    NTK_Typedef,\n    NTK_TypeAlias,\n    NTK_Template,\n    NTK_TypeAliasTemplate,\n    NTK_TemplateTemplateArgument,\n  };\n\n  /// Given a non-tag type declaration, returns an enum useful for indicating\n  /// what kind of non-tag type this is.\n  NonTagKind getNonTagTypeDeclKind(const Decl *D, TagTypeKind TTK);\n\n  bool isAcceptableTagRedeclaration(const TagDecl *Previous,\n                                    TagTypeKind NewTag, bool isDefinition,\n                                    SourceLocation NewTagLoc,\n                                    const IdentifierInfo *Name);\n\n  enum TagUseKind {\n    TUK_Reference,   // Reference to a tag:  'struct foo *X;'\n    TUK_Declaration, // Fwd decl of a tag:   'struct foo;'\n    TUK_Definition,  // Definition of a tag: 'struct foo { int X; } Y;'\n    TUK_Friend       // Friend declaration:  'friend struct foo;'\n  };\n\n  Decl *ActOnTag(Scope *S, unsigned TagSpec, TagUseKind TUK,\n                 SourceLocation KWLoc, CXXScopeSpec &SS, IdentifierInfo *Name,\n                 SourceLocation NameLoc, const ParsedAttributesView &Attr,\n                 AccessSpecifier AS, SourceLocation ModulePrivateLoc,\n                 MultiTemplateParamsArg TemplateParameterLists, bool &OwnedDecl,\n                 bool &IsDependent, SourceLocation ScopedEnumKWLoc,\n                 bool ScopedEnumUsesClassTag, TypeResult UnderlyingType,\n                 bool IsTypeSpecifier, bool IsTemplateParamOrArg,\n                 SkipBodyInfo *SkipBody = nullptr);\n\n  Decl *ActOnTemplatedFriendTag(Scope *S, SourceLocation FriendLoc,\n                                unsigned TagSpec, SourceLocation TagLoc,\n                                CXXScopeSpec &SS, IdentifierInfo *Name,\n                                SourceLocation NameLoc,\n                                const ParsedAttributesView &Attr,\n                                MultiTemplateParamsArg TempParamLists);\n\n  TypeResult ActOnDependentTag(Scope *S,\n                               unsigned TagSpec,\n                               TagUseKind TUK,\n                               const CXXScopeSpec &SS,\n                               IdentifierInfo *Name,\n                               SourceLocation TagLoc,\n                               SourceLocation NameLoc);\n\n  void ActOnDefs(Scope *S, Decl *TagD, SourceLocation DeclStart,\n                 IdentifierInfo *ClassName,\n                 SmallVectorImpl<Decl *> &Decls);\n  Decl *ActOnField(Scope *S, Decl *TagD, SourceLocation DeclStart,\n                   Declarator &D, Expr *BitfieldWidth);\n\n  FieldDecl *HandleField(Scope *S, RecordDecl *TagD, SourceLocation DeclStart,\n                         Declarator &D, Expr *BitfieldWidth,\n                         InClassInitStyle InitStyle,\n                         AccessSpecifier AS);\n  MSPropertyDecl *HandleMSProperty(Scope *S, RecordDecl *TagD,\n                                   SourceLocation DeclStart, Declarator &D,\n                                   Expr *BitfieldWidth,\n                                   InClassInitStyle InitStyle,\n                                   AccessSpecifier AS,\n                                   const ParsedAttr &MSPropertyAttr);\n\n  FieldDecl *CheckFieldDecl(DeclarationName Name, QualType T,\n                            TypeSourceInfo *TInfo,\n                            RecordDecl *Record, SourceLocation Loc,\n                            bool Mutable, Expr *BitfieldWidth,\n                            InClassInitStyle InitStyle,\n                            SourceLocation TSSL,\n                            AccessSpecifier AS, NamedDecl *PrevDecl,\n                            Declarator *D = nullptr);\n\n  bool CheckNontrivialField(FieldDecl *FD);\n  void DiagnoseNontrivial(const CXXRecordDecl *Record, CXXSpecialMember CSM);\n\n  enum TrivialABIHandling {\n    /// The triviality of a method unaffected by \"trivial_abi\".\n    TAH_IgnoreTrivialABI,\n\n    /// The triviality of a method affected by \"trivial_abi\".\n    TAH_ConsiderTrivialABI\n  };\n\n  bool SpecialMemberIsTrivial(CXXMethodDecl *MD, CXXSpecialMember CSM,\n                              TrivialABIHandling TAH = TAH_IgnoreTrivialABI,\n                              bool Diagnose = false);\n\n  /// For a defaulted function, the kind of defaulted function that it is.\n  class DefaultedFunctionKind {\n    CXXSpecialMember SpecialMember : 8;\n    DefaultedComparisonKind Comparison : 8;\n\n  public:\n    DefaultedFunctionKind()\n        : SpecialMember(CXXInvalid), Comparison(DefaultedComparisonKind::None) {\n    }\n    DefaultedFunctionKind(CXXSpecialMember CSM)\n        : SpecialMember(CSM), Comparison(DefaultedComparisonKind::None) {}\n    DefaultedFunctionKind(DefaultedComparisonKind Comp)\n        : SpecialMember(CXXInvalid), Comparison(Comp) {}\n\n    bool isSpecialMember() const { return SpecialMember != CXXInvalid; }\n    bool isComparison() const {\n      return Comparison != DefaultedComparisonKind::None;\n    }\n\n    explicit operator bool() const {\n      return isSpecialMember() || isComparison();\n    }\n\n    CXXSpecialMember asSpecialMember() const { return SpecialMember; }\n    DefaultedComparisonKind asComparison() const { return Comparison; }\n\n    /// Get the index of this function kind for use in diagnostics.\n    unsigned getDiagnosticIndex() const {\n      static_assert(CXXInvalid > CXXDestructor,\n                    \"invalid should have highest index\");\n      static_assert((unsigned)DefaultedComparisonKind::None == 0,\n                    \"none should be equal to zero\");\n      return SpecialMember + (unsigned)Comparison;\n    }\n  };\n\n  DefaultedFunctionKind getDefaultedFunctionKind(const FunctionDecl *FD);\n\n  CXXSpecialMember getSpecialMember(const CXXMethodDecl *MD) {\n    return getDefaultedFunctionKind(MD).asSpecialMember();\n  }\n  DefaultedComparisonKind getDefaultedComparisonKind(const FunctionDecl *FD) {\n    return getDefaultedFunctionKind(FD).asComparison();\n  }\n\n  void ActOnLastBitfield(SourceLocation DeclStart,\n                         SmallVectorImpl<Decl *> &AllIvarDecls);\n  Decl *ActOnIvar(Scope *S, SourceLocation DeclStart,\n                  Declarator &D, Expr *BitfieldWidth,\n                  tok::ObjCKeywordKind visibility);\n\n  // This is used for both record definitions and ObjC interface declarations.\n  void ActOnFields(Scope *S, SourceLocation RecLoc, Decl *TagDecl,\n                   ArrayRef<Decl *> Fields, SourceLocation LBrac,\n                   SourceLocation RBrac, const ParsedAttributesView &AttrList);\n\n  /// ActOnTagStartDefinition - Invoked when we have entered the\n  /// scope of a tag's definition (e.g., for an enumeration, class,\n  /// struct, or union).\n  void ActOnTagStartDefinition(Scope *S, Decl *TagDecl);\n\n  /// Perform ODR-like check for C/ObjC when merging tag types from modules.\n  /// Differently from C++, actually parse the body and reject / error out\n  /// in case of a structural mismatch.\n  bool ActOnDuplicateDefinition(DeclSpec &DS, Decl *Prev,\n                                SkipBodyInfo &SkipBody);\n\n  typedef void *SkippedDefinitionContext;\n\n  /// Invoked when we enter a tag definition that we're skipping.\n  SkippedDefinitionContext ActOnTagStartSkippedDefinition(Scope *S, Decl *TD);\n\n  Decl *ActOnObjCContainerStartDefinition(Decl *IDecl);\n\n  /// ActOnStartCXXMemberDeclarations - Invoked when we have parsed a\n  /// C++ record definition's base-specifiers clause and are starting its\n  /// member declarations.\n  void ActOnStartCXXMemberDeclarations(Scope *S, Decl *TagDecl,\n                                       SourceLocation FinalLoc,\n                                       bool IsFinalSpelledSealed,\n                                       SourceLocation LBraceLoc);\n\n  /// ActOnTagFinishDefinition - Invoked once we have finished parsing\n  /// the definition of a tag (enumeration, class, struct, or union).\n  void ActOnTagFinishDefinition(Scope *S, Decl *TagDecl,\n                                SourceRange BraceRange);\n\n  void ActOnTagFinishSkippedDefinition(SkippedDefinitionContext Context);\n\n  void ActOnObjCContainerFinishDefinition();\n\n  /// Invoked when we must temporarily exit the objective-c container\n  /// scope for parsing/looking-up C constructs.\n  ///\n  /// Must be followed by a call to \\see ActOnObjCReenterContainerContext\n  void ActOnObjCTemporaryExitContainerContext(DeclContext *DC);\n  void ActOnObjCReenterContainerContext(DeclContext *DC);\n\n  /// ActOnTagDefinitionError - Invoked when there was an unrecoverable\n  /// error parsing the definition of a tag.\n  void ActOnTagDefinitionError(Scope *S, Decl *TagDecl);\n\n  EnumConstantDecl *CheckEnumConstant(EnumDecl *Enum,\n                                      EnumConstantDecl *LastEnumConst,\n                                      SourceLocation IdLoc,\n                                      IdentifierInfo *Id,\n                                      Expr *val);\n  bool CheckEnumUnderlyingType(TypeSourceInfo *TI);\n  bool CheckEnumRedeclaration(SourceLocation EnumLoc, bool IsScoped,\n                              QualType EnumUnderlyingTy, bool IsFixed,\n                              const EnumDecl *Prev);\n\n  /// Determine whether the body of an anonymous enumeration should be skipped.\n  /// \\param II The name of the first enumerator.\n  SkipBodyInfo shouldSkipAnonEnumBody(Scope *S, IdentifierInfo *II,\n                                      SourceLocation IILoc);\n\n  Decl *ActOnEnumConstant(Scope *S, Decl *EnumDecl, Decl *LastEnumConstant,\n                          SourceLocation IdLoc, IdentifierInfo *Id,\n                          const ParsedAttributesView &Attrs,\n                          SourceLocation EqualLoc, Expr *Val);\n  void ActOnEnumBody(SourceLocation EnumLoc, SourceRange BraceRange,\n                     Decl *EnumDecl, ArrayRef<Decl *> Elements, Scope *S,\n                     const ParsedAttributesView &Attr);\n\n  /// Set the current declaration context until it gets popped.\n  void PushDeclContext(Scope *S, DeclContext *DC);\n  void PopDeclContext();\n\n  /// EnterDeclaratorContext - Used when we must lookup names in the context\n  /// of a declarator's nested name specifier.\n  void EnterDeclaratorContext(Scope *S, DeclContext *DC);\n  void ExitDeclaratorContext(Scope *S);\n\n  /// Enter a template parameter scope, after it's been associated with a particular\n  /// DeclContext. Causes lookup within the scope to chain through enclosing contexts\n  /// in the correct order.\n  void EnterTemplatedContext(Scope *S, DeclContext *DC);\n\n  /// Push the parameters of D, which must be a function, into scope.\n  void ActOnReenterFunctionContext(Scope* S, Decl* D);\n  void ActOnExitFunctionContext();\n\n  DeclContext *getFunctionLevelDeclContext();\n\n  /// getCurFunctionDecl - If inside of a function body, this returns a pointer\n  /// to the function decl for the function being parsed.  If we're currently\n  /// in a 'block', this returns the containing context.\n  FunctionDecl *getCurFunctionDecl();\n\n  /// getCurMethodDecl - If inside of a method body, this returns a pointer to\n  /// the method decl for the method being parsed.  If we're currently\n  /// in a 'block', this returns the containing context.\n  ObjCMethodDecl *getCurMethodDecl();\n\n  /// getCurFunctionOrMethodDecl - Return the Decl for the current ObjC method\n  /// or C function we're in, otherwise return null.  If we're currently\n  /// in a 'block', this returns the containing context.\n  NamedDecl *getCurFunctionOrMethodDecl();\n\n  /// Add this decl to the scope shadowed decl chains.\n  void PushOnScopeChains(NamedDecl *D, Scope *S, bool AddToContext = true);\n\n  /// isDeclInScope - If 'Ctx' is a function/method, isDeclInScope returns true\n  /// if 'D' is in Scope 'S', otherwise 'S' is ignored and isDeclInScope returns\n  /// true if 'D' belongs to the given declaration context.\n  ///\n  /// \\param AllowInlineNamespace If \\c true, allow the declaration to be in the\n  ///        enclosing namespace set of the context, rather than contained\n  ///        directly within it.\n  bool isDeclInScope(NamedDecl *D, DeclContext *Ctx, Scope *S = nullptr,\n                     bool AllowInlineNamespace = false);\n\n  /// Finds the scope corresponding to the given decl context, if it\n  /// happens to be an enclosing scope.  Otherwise return NULL.\n  static Scope *getScopeForDeclContext(Scope *S, DeclContext *DC);\n\n  /// Subroutines of ActOnDeclarator().\n  TypedefDecl *ParseTypedefDecl(Scope *S, Declarator &D, QualType T,\n                                TypeSourceInfo *TInfo);\n  bool isIncompatibleTypedef(TypeDecl *Old, TypedefNameDecl *New);\n\n  /// Describes the kind of merge to perform for availability\n  /// attributes (including \"deprecated\", \"unavailable\", and \"availability\").\n  enum AvailabilityMergeKind {\n    /// Don't merge availability attributes at all.\n    AMK_None,\n    /// Merge availability attributes for a redeclaration, which requires\n    /// an exact match.\n    AMK_Redeclaration,\n    /// Merge availability attributes for an override, which requires\n    /// an exact match or a weakening of constraints.\n    AMK_Override,\n    /// Merge availability attributes for an implementation of\n    /// a protocol requirement.\n    AMK_ProtocolImplementation,\n  };\n\n  /// Describes the kind of priority given to an availability attribute.\n  ///\n  /// The sum of priorities deteremines the final priority of the attribute.\n  /// The final priority determines how the attribute will be merged.\n  /// An attribute with a lower priority will always remove higher priority\n  /// attributes for the specified platform when it is being applied. An\n  /// attribute with a higher priority will not be applied if the declaration\n  /// already has an availability attribute with a lower priority for the\n  /// specified platform. The final prirority values are not expected to match\n  /// the values in this enumeration, but instead should be treated as a plain\n  /// integer value. This enumeration just names the priority weights that are\n  /// used to calculate that final vaue.\n  enum AvailabilityPriority : int {\n    /// The availability attribute was specified explicitly next to the\n    /// declaration.\n    AP_Explicit = 0,\n\n    /// The availability attribute was applied using '#pragma clang attribute'.\n    AP_PragmaClangAttribute = 1,\n\n    /// The availability attribute for a specific platform was inferred from\n    /// an availability attribute for another platform.\n    AP_InferredFromOtherPlatform = 2\n  };\n\n  /// Attribute merging methods. Return true if a new attribute was added.\n  AvailabilityAttr *\n  mergeAvailabilityAttr(NamedDecl *D, const AttributeCommonInfo &CI,\n                        IdentifierInfo *Platform, bool Implicit,\n                        VersionTuple Introduced, VersionTuple Deprecated,\n                        VersionTuple Obsoleted, bool IsUnavailable,\n                        StringRef Message, bool IsStrict, StringRef Replacement,\n                        AvailabilityMergeKind AMK, int Priority);\n  TypeVisibilityAttr *\n  mergeTypeVisibilityAttr(Decl *D, const AttributeCommonInfo &CI,\n                          TypeVisibilityAttr::VisibilityType Vis);\n  VisibilityAttr *mergeVisibilityAttr(Decl *D, const AttributeCommonInfo &CI,\n                                      VisibilityAttr::VisibilityType Vis);\n  UuidAttr *mergeUuidAttr(Decl *D, const AttributeCommonInfo &CI,\n                          StringRef UuidAsWritten, MSGuidDecl *GuidDecl);\n  DLLImportAttr *mergeDLLImportAttr(Decl *D, const AttributeCommonInfo &CI);\n  DLLExportAttr *mergeDLLExportAttr(Decl *D, const AttributeCommonInfo &CI);\n  MSInheritanceAttr *mergeMSInheritanceAttr(Decl *D,\n                                            const AttributeCommonInfo &CI,\n                                            bool BestCase,\n                                            MSInheritanceModel Model);\n  FormatAttr *mergeFormatAttr(Decl *D, const AttributeCommonInfo &CI,\n                              IdentifierInfo *Format, int FormatIdx,\n                              int FirstArg);\n  SectionAttr *mergeSectionAttr(Decl *D, const AttributeCommonInfo &CI,\n                                StringRef Name);\n  CodeSegAttr *mergeCodeSegAttr(Decl *D, const AttributeCommonInfo &CI,\n                                StringRef Name);\n  AlwaysInlineAttr *mergeAlwaysInlineAttr(Decl *D,\n                                          const AttributeCommonInfo &CI,\n                                          const IdentifierInfo *Ident);\n  MinSizeAttr *mergeMinSizeAttr(Decl *D, const AttributeCommonInfo &CI);\n  NoSpeculativeLoadHardeningAttr *\n  mergeNoSpeculativeLoadHardeningAttr(Decl *D,\n                                      const NoSpeculativeLoadHardeningAttr &AL);\n  SpeculativeLoadHardeningAttr *\n  mergeSpeculativeLoadHardeningAttr(Decl *D,\n                                    const SpeculativeLoadHardeningAttr &AL);\n  SwiftNameAttr *mergeSwiftNameAttr(Decl *D, const SwiftNameAttr &SNA,\n                                    StringRef Name);\n  OptimizeNoneAttr *mergeOptimizeNoneAttr(Decl *D,\n                                          const AttributeCommonInfo &CI);\n  InternalLinkageAttr *mergeInternalLinkageAttr(Decl *D, const ParsedAttr &AL);\n  InternalLinkageAttr *mergeInternalLinkageAttr(Decl *D,\n                                                const InternalLinkageAttr &AL);\n  CommonAttr *mergeCommonAttr(Decl *D, const ParsedAttr &AL);\n  CommonAttr *mergeCommonAttr(Decl *D, const CommonAttr &AL);\n  WebAssemblyImportNameAttr *mergeImportNameAttr(\n      Decl *D, const WebAssemblyImportNameAttr &AL);\n  WebAssemblyImportModuleAttr *mergeImportModuleAttr(\n      Decl *D, const WebAssemblyImportModuleAttr &AL);\n  EnforceTCBAttr *mergeEnforceTCBAttr(Decl *D, const EnforceTCBAttr &AL);\n  EnforceTCBLeafAttr *mergeEnforceTCBLeafAttr(Decl *D,\n                                              const EnforceTCBLeafAttr &AL);\n\n  void mergeDeclAttributes(NamedDecl *New, Decl *Old,\n                           AvailabilityMergeKind AMK = AMK_Redeclaration);\n  void MergeTypedefNameDecl(Scope *S, TypedefNameDecl *New,\n                            LookupResult &OldDecls);\n  bool MergeFunctionDecl(FunctionDecl *New, NamedDecl *&Old, Scope *S,\n                         bool MergeTypeWithOld);\n  bool MergeCompatibleFunctionDecls(FunctionDecl *New, FunctionDecl *Old,\n                                    Scope *S, bool MergeTypeWithOld);\n  void mergeObjCMethodDecls(ObjCMethodDecl *New, ObjCMethodDecl *Old);\n  void MergeVarDecl(VarDecl *New, LookupResult &Previous);\n  void MergeVarDeclTypes(VarDecl *New, VarDecl *Old, bool MergeTypeWithOld);\n  void MergeVarDeclExceptionSpecs(VarDecl *New, VarDecl *Old);\n  bool checkVarDeclRedefinition(VarDecl *OldDefn, VarDecl *NewDefn);\n  void notePreviousDefinition(const NamedDecl *Old, SourceLocation New);\n  bool MergeCXXFunctionDecl(FunctionDecl *New, FunctionDecl *Old, Scope *S);\n\n  // AssignmentAction - This is used by all the assignment diagnostic functions\n  // to represent what is actually causing the operation\n  enum AssignmentAction {\n    AA_Assigning,\n    AA_Passing,\n    AA_Returning,\n    AA_Converting,\n    AA_Initializing,\n    AA_Sending,\n    AA_Casting,\n    AA_Passing_CFAudited\n  };\n\n  /// C++ Overloading.\n  enum OverloadKind {\n    /// This is a legitimate overload: the existing declarations are\n    /// functions or function templates with different signatures.\n    Ovl_Overload,\n\n    /// This is not an overload because the signature exactly matches\n    /// an existing declaration.\n    Ovl_Match,\n\n    /// This is not an overload because the lookup results contain a\n    /// non-function.\n    Ovl_NonFunction\n  };\n  OverloadKind CheckOverload(Scope *S,\n                             FunctionDecl *New,\n                             const LookupResult &OldDecls,\n                             NamedDecl *&OldDecl,\n                             bool IsForUsingDecl);\n  bool IsOverload(FunctionDecl *New, FunctionDecl *Old, bool IsForUsingDecl,\n                  bool ConsiderCudaAttrs = true,\n                  bool ConsiderRequiresClauses = true);\n\n  enum class AllowedExplicit {\n    /// Allow no explicit functions to be used.\n    None,\n    /// Allow explicit conversion functions but not explicit constructors.\n    Conversions,\n    /// Allow both explicit conversion functions and explicit constructors.\n    All\n  };\n\n  ImplicitConversionSequence\n  TryImplicitConversion(Expr *From, QualType ToType,\n                        bool SuppressUserConversions,\n                        AllowedExplicit AllowExplicit,\n                        bool InOverloadResolution,\n                        bool CStyle,\n                        bool AllowObjCWritebackConversion);\n\n  bool IsIntegralPromotion(Expr *From, QualType FromType, QualType ToType);\n  bool IsFloatingPointPromotion(QualType FromType, QualType ToType);\n  bool IsComplexPromotion(QualType FromType, QualType ToType);\n  bool IsPointerConversion(Expr *From, QualType FromType, QualType ToType,\n                           bool InOverloadResolution,\n                           QualType& ConvertedType, bool &IncompatibleObjC);\n  bool isObjCPointerConversion(QualType FromType, QualType ToType,\n                               QualType& ConvertedType, bool &IncompatibleObjC);\n  bool isObjCWritebackConversion(QualType FromType, QualType ToType,\n                                 QualType &ConvertedType);\n  bool IsBlockPointerConversion(QualType FromType, QualType ToType,\n                                QualType& ConvertedType);\n  bool FunctionParamTypesAreEqual(const FunctionProtoType *OldType,\n                                  const FunctionProtoType *NewType,\n                                  unsigned *ArgPos = nullptr);\n  void HandleFunctionTypeMismatch(PartialDiagnostic &PDiag,\n                                  QualType FromType, QualType ToType);\n\n  void maybeExtendBlockObject(ExprResult &E);\n  CastKind PrepareCastToObjCObjectPointer(ExprResult &E);\n  bool CheckPointerConversion(Expr *From, QualType ToType,\n                              CastKind &Kind,\n                              CXXCastPath& BasePath,\n                              bool IgnoreBaseAccess,\n                              bool Diagnose = true);\n  bool IsMemberPointerConversion(Expr *From, QualType FromType, QualType ToType,\n                                 bool InOverloadResolution,\n                                 QualType &ConvertedType);\n  bool CheckMemberPointerConversion(Expr *From, QualType ToType,\n                                    CastKind &Kind,\n                                    CXXCastPath &BasePath,\n                                    bool IgnoreBaseAccess);\n  bool IsQualificationConversion(QualType FromType, QualType ToType,\n                                 bool CStyle, bool &ObjCLifetimeConversion);\n  bool IsFunctionConversion(QualType FromType, QualType ToType,\n                            QualType &ResultTy);\n  bool DiagnoseMultipleUserDefinedConversion(Expr *From, QualType ToType);\n  bool isSameOrCompatibleFunctionType(CanQualType Param, CanQualType Arg);\n\n  ExprResult PerformMoveOrCopyInitialization(const InitializedEntity &Entity,\n                                             const VarDecl *NRVOCandidate,\n                                             QualType ResultType,\n                                             Expr *Value,\n                                             bool AllowNRVO = true);\n\n  bool CanPerformAggregateInitializationForOverloadResolution(\n      const InitializedEntity &Entity, InitListExpr *From);\n\n  bool IsStringInit(Expr *Init, const ArrayType *AT);\n\n  bool CanPerformCopyInitialization(const InitializedEntity &Entity,\n                                    ExprResult Init);\n  ExprResult PerformCopyInitialization(const InitializedEntity &Entity,\n                                       SourceLocation EqualLoc,\n                                       ExprResult Init,\n                                       bool TopLevelOfInitList = false,\n                                       bool AllowExplicit = false);\n  ExprResult PerformObjectArgumentInitialization(Expr *From,\n                                                 NestedNameSpecifier *Qualifier,\n                                                 NamedDecl *FoundDecl,\n                                                 CXXMethodDecl *Method);\n\n  /// Check that the lifetime of the initializer (and its subobjects) is\n  /// sufficient for initializing the entity, and perform lifetime extension\n  /// (when permitted) if not.\n  void checkInitializerLifetime(const InitializedEntity &Entity, Expr *Init);\n\n  ExprResult PerformContextuallyConvertToBool(Expr *From);\n  ExprResult PerformContextuallyConvertToObjCPointer(Expr *From);\n\n  /// Contexts in which a converted constant expression is required.\n  enum CCEKind {\n    CCEK_CaseValue,   ///< Expression in a case label.\n    CCEK_Enumerator,  ///< Enumerator value with fixed underlying type.\n    CCEK_TemplateArg, ///< Value of a non-type template parameter.\n    CCEK_ArrayBound,  ///< Array bound in array declarator or new-expression.\n    CCEK_ConstexprIf, ///< Condition in a constexpr if statement.\n    CCEK_ExplicitBool ///< Condition in an explicit(bool) specifier.\n  };\n  ExprResult CheckConvertedConstantExpression(Expr *From, QualType T,\n                                              llvm::APSInt &Value, CCEKind CCE);\n  ExprResult CheckConvertedConstantExpression(Expr *From, QualType T,\n                                              APValue &Value, CCEKind CCE,\n                                              NamedDecl *Dest = nullptr);\n\n  /// Abstract base class used to perform a contextual implicit\n  /// conversion from an expression to any type passing a filter.\n  class ContextualImplicitConverter {\n  public:\n    bool Suppress;\n    bool SuppressConversion;\n\n    ContextualImplicitConverter(bool Suppress = false,\n                                bool SuppressConversion = false)\n        : Suppress(Suppress), SuppressConversion(SuppressConversion) {}\n\n    /// Determine whether the specified type is a valid destination type\n    /// for this conversion.\n    virtual bool match(QualType T) = 0;\n\n    /// Emits a diagnostic complaining that the expression does not have\n    /// integral or enumeration type.\n    virtual SemaDiagnosticBuilder\n    diagnoseNoMatch(Sema &S, SourceLocation Loc, QualType T) = 0;\n\n    /// Emits a diagnostic when the expression has incomplete class type.\n    virtual SemaDiagnosticBuilder\n    diagnoseIncomplete(Sema &S, SourceLocation Loc, QualType T) = 0;\n\n    /// Emits a diagnostic when the only matching conversion function\n    /// is explicit.\n    virtual SemaDiagnosticBuilder diagnoseExplicitConv(\n        Sema &S, SourceLocation Loc, QualType T, QualType ConvTy) = 0;\n\n    /// Emits a note for the explicit conversion function.\n    virtual SemaDiagnosticBuilder\n    noteExplicitConv(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) = 0;\n\n    /// Emits a diagnostic when there are multiple possible conversion\n    /// functions.\n    virtual SemaDiagnosticBuilder\n    diagnoseAmbiguous(Sema &S, SourceLocation Loc, QualType T) = 0;\n\n    /// Emits a note for one of the candidate conversions.\n    virtual SemaDiagnosticBuilder\n    noteAmbiguous(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) = 0;\n\n    /// Emits a diagnostic when we picked a conversion function\n    /// (for cases when we are not allowed to pick a conversion function).\n    virtual SemaDiagnosticBuilder diagnoseConversion(\n        Sema &S, SourceLocation Loc, QualType T, QualType ConvTy) = 0;\n\n    virtual ~ContextualImplicitConverter() {}\n  };\n\n  class ICEConvertDiagnoser : public ContextualImplicitConverter {\n    bool AllowScopedEnumerations;\n\n  public:\n    ICEConvertDiagnoser(bool AllowScopedEnumerations,\n                        bool Suppress, bool SuppressConversion)\n        : ContextualImplicitConverter(Suppress, SuppressConversion),\n          AllowScopedEnumerations(AllowScopedEnumerations) {}\n\n    /// Match an integral or (possibly scoped) enumeration type.\n    bool match(QualType T) override;\n\n    SemaDiagnosticBuilder\n    diagnoseNoMatch(Sema &S, SourceLocation Loc, QualType T) override {\n      return diagnoseNotInt(S, Loc, T);\n    }\n\n    /// Emits a diagnostic complaining that the expression does not have\n    /// integral or enumeration type.\n    virtual SemaDiagnosticBuilder\n    diagnoseNotInt(Sema &S, SourceLocation Loc, QualType T) = 0;\n  };\n\n  /// Perform a contextual implicit conversion.\n  ExprResult PerformContextualImplicitConversion(\n      SourceLocation Loc, Expr *FromE, ContextualImplicitConverter &Converter);\n\n\n  enum ObjCSubscriptKind {\n    OS_Array,\n    OS_Dictionary,\n    OS_Error\n  };\n  ObjCSubscriptKind CheckSubscriptingKind(Expr *FromE);\n\n  // Note that LK_String is intentionally after the other literals, as\n  // this is used for diagnostics logic.\n  enum ObjCLiteralKind {\n    LK_Array,\n    LK_Dictionary,\n    LK_Numeric,\n    LK_Boxed,\n    LK_String,\n    LK_Block,\n    LK_None\n  };\n  ObjCLiteralKind CheckLiteralKind(Expr *FromE);\n\n  ExprResult PerformObjectMemberConversion(Expr *From,\n                                           NestedNameSpecifier *Qualifier,\n                                           NamedDecl *FoundDecl,\n                                           NamedDecl *Member);\n\n  // Members have to be NamespaceDecl* or TranslationUnitDecl*.\n  // TODO: make this is a typesafe union.\n  typedef llvm::SmallSetVector<DeclContext   *, 16> AssociatedNamespaceSet;\n  typedef llvm::SmallSetVector<CXXRecordDecl *, 16> AssociatedClassSet;\n\n  using ADLCallKind = CallExpr::ADLCallKind;\n\n  void AddOverloadCandidate(FunctionDecl *Function, DeclAccessPair FoundDecl,\n                            ArrayRef<Expr *> Args,\n                            OverloadCandidateSet &CandidateSet,\n                            bool SuppressUserConversions = false,\n                            bool PartialOverloading = false,\n                            bool AllowExplicit = true,\n                            bool AllowExplicitConversion = false,\n                            ADLCallKind IsADLCandidate = ADLCallKind::NotADL,\n                            ConversionSequenceList EarlyConversions = None,\n                            OverloadCandidateParamOrder PO = {});\n  void AddFunctionCandidates(const UnresolvedSetImpl &Functions,\n                      ArrayRef<Expr *> Args,\n                      OverloadCandidateSet &CandidateSet,\n                      TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr,\n                      bool SuppressUserConversions = false,\n                      bool PartialOverloading = false,\n                      bool FirstArgumentIsBase = false);\n  void AddMethodCandidate(DeclAccessPair FoundDecl,\n                          QualType ObjectType,\n                          Expr::Classification ObjectClassification,\n                          ArrayRef<Expr *> Args,\n                          OverloadCandidateSet& CandidateSet,\n                          bool SuppressUserConversion = false,\n                          OverloadCandidateParamOrder PO = {});\n  void AddMethodCandidate(CXXMethodDecl *Method,\n                          DeclAccessPair FoundDecl,\n                          CXXRecordDecl *ActingContext, QualType ObjectType,\n                          Expr::Classification ObjectClassification,\n                          ArrayRef<Expr *> Args,\n                          OverloadCandidateSet& CandidateSet,\n                          bool SuppressUserConversions = false,\n                          bool PartialOverloading = false,\n                          ConversionSequenceList EarlyConversions = None,\n                          OverloadCandidateParamOrder PO = {});\n  void AddMethodTemplateCandidate(FunctionTemplateDecl *MethodTmpl,\n                                  DeclAccessPair FoundDecl,\n                                  CXXRecordDecl *ActingContext,\n                                 TemplateArgumentListInfo *ExplicitTemplateArgs,\n                                  QualType ObjectType,\n                                  Expr::Classification ObjectClassification,\n                                  ArrayRef<Expr *> Args,\n                                  OverloadCandidateSet& CandidateSet,\n                                  bool SuppressUserConversions = false,\n                                  bool PartialOverloading = false,\n                                  OverloadCandidateParamOrder PO = {});\n  void AddTemplateOverloadCandidate(\n      FunctionTemplateDecl *FunctionTemplate, DeclAccessPair FoundDecl,\n      TemplateArgumentListInfo *ExplicitTemplateArgs, ArrayRef<Expr *> Args,\n      OverloadCandidateSet &CandidateSet, bool SuppressUserConversions = false,\n      bool PartialOverloading = false, bool AllowExplicit = true,\n      ADLCallKind IsADLCandidate = ADLCallKind::NotADL,\n      OverloadCandidateParamOrder PO = {});\n  bool CheckNonDependentConversions(\n      FunctionTemplateDecl *FunctionTemplate, ArrayRef<QualType> ParamTypes,\n      ArrayRef<Expr *> Args, OverloadCandidateSet &CandidateSet,\n      ConversionSequenceList &Conversions, bool SuppressUserConversions,\n      CXXRecordDecl *ActingContext = nullptr, QualType ObjectType = QualType(),\n      Expr::Classification ObjectClassification = {},\n      OverloadCandidateParamOrder PO = {});\n  void AddConversionCandidate(\n      CXXConversionDecl *Conversion, DeclAccessPair FoundDecl,\n      CXXRecordDecl *ActingContext, Expr *From, QualType ToType,\n      OverloadCandidateSet &CandidateSet, bool AllowObjCConversionOnExplicit,\n      bool AllowExplicit, bool AllowResultConversion = true);\n  void AddTemplateConversionCandidate(\n      FunctionTemplateDecl *FunctionTemplate, DeclAccessPair FoundDecl,\n      CXXRecordDecl *ActingContext, Expr *From, QualType ToType,\n      OverloadCandidateSet &CandidateSet, bool AllowObjCConversionOnExplicit,\n      bool AllowExplicit, bool AllowResultConversion = true);\n  void AddSurrogateCandidate(CXXConversionDecl *Conversion,\n                             DeclAccessPair FoundDecl,\n                             CXXRecordDecl *ActingContext,\n                             const FunctionProtoType *Proto,\n                             Expr *Object, ArrayRef<Expr *> Args,\n                             OverloadCandidateSet& CandidateSet);\n  void AddNonMemberOperatorCandidates(\n      const UnresolvedSetImpl &Functions, ArrayRef<Expr *> Args,\n      OverloadCandidateSet &CandidateSet,\n      TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr);\n  void AddMemberOperatorCandidates(OverloadedOperatorKind Op,\n                                   SourceLocation OpLoc, ArrayRef<Expr *> Args,\n                                   OverloadCandidateSet &CandidateSet,\n                                   OverloadCandidateParamOrder PO = {});\n  void AddBuiltinCandidate(QualType *ParamTys, ArrayRef<Expr *> Args,\n                           OverloadCandidateSet& CandidateSet,\n                           bool IsAssignmentOperator = false,\n                           unsigned NumContextualBoolArguments = 0);\n  void AddBuiltinOperatorCandidates(OverloadedOperatorKind Op,\n                                    SourceLocation OpLoc, ArrayRef<Expr *> Args,\n                                    OverloadCandidateSet& CandidateSet);\n  void AddArgumentDependentLookupCandidates(DeclarationName Name,\n                                            SourceLocation Loc,\n                                            ArrayRef<Expr *> Args,\n                                TemplateArgumentListInfo *ExplicitTemplateArgs,\n                                            OverloadCandidateSet& CandidateSet,\n                                            bool PartialOverloading = false);\n\n  // Emit as a 'note' the specific overload candidate\n  void NoteOverloadCandidate(\n      NamedDecl *Found, FunctionDecl *Fn,\n      OverloadCandidateRewriteKind RewriteKind = OverloadCandidateRewriteKind(),\n      QualType DestType = QualType(), bool TakingAddress = false);\n\n  // Emit as a series of 'note's all template and non-templates identified by\n  // the expression Expr\n  void NoteAllOverloadCandidates(Expr *E, QualType DestType = QualType(),\n                                 bool TakingAddress = false);\n\n  /// Check the enable_if expressions on the given function. Returns the first\n  /// failing attribute, or NULL if they were all successful.\n  EnableIfAttr *CheckEnableIf(FunctionDecl *Function, SourceLocation CallLoc,\n                              ArrayRef<Expr *> Args,\n                              bool MissingImplicitThis = false);\n\n  /// Find the failed Boolean condition within a given Boolean\n  /// constant expression, and describe it with a string.\n  std::pair<Expr *, std::string> findFailedBooleanCondition(Expr *Cond);\n\n  /// Emit diagnostics for the diagnose_if attributes on Function, ignoring any\n  /// non-ArgDependent DiagnoseIfAttrs.\n  ///\n  /// Argument-dependent diagnose_if attributes should be checked each time a\n  /// function is used as a direct callee of a function call.\n  ///\n  /// Returns true if any errors were emitted.\n  bool diagnoseArgDependentDiagnoseIfAttrs(const FunctionDecl *Function,\n                                           const Expr *ThisArg,\n                                           ArrayRef<const Expr *> Args,\n                                           SourceLocation Loc);\n\n  /// Emit diagnostics for the diagnose_if attributes on Function, ignoring any\n  /// ArgDependent DiagnoseIfAttrs.\n  ///\n  /// Argument-independent diagnose_if attributes should be checked on every use\n  /// of a function.\n  ///\n  /// Returns true if any errors were emitted.\n  bool diagnoseArgIndependentDiagnoseIfAttrs(const NamedDecl *ND,\n                                             SourceLocation Loc);\n\n  /// Returns whether the given function's address can be taken or not,\n  /// optionally emitting a diagnostic if the address can't be taken.\n  ///\n  /// Returns false if taking the address of the function is illegal.\n  bool checkAddressOfFunctionIsAvailable(const FunctionDecl *Function,\n                                         bool Complain = false,\n                                         SourceLocation Loc = SourceLocation());\n\n  // [PossiblyAFunctionType]  -->   [Return]\n  // NonFunctionType --> NonFunctionType\n  // R (A) --> R(A)\n  // R (*)(A) --> R (A)\n  // R (&)(A) --> R (A)\n  // R (S::*)(A) --> R (A)\n  QualType ExtractUnqualifiedFunctionType(QualType PossiblyAFunctionType);\n\n  FunctionDecl *\n  ResolveAddressOfOverloadedFunction(Expr *AddressOfExpr,\n                                     QualType TargetType,\n                                     bool Complain,\n                                     DeclAccessPair &Found,\n                                     bool *pHadMultipleCandidates = nullptr);\n\n  FunctionDecl *\n  resolveAddressOfSingleOverloadCandidate(Expr *E, DeclAccessPair &FoundResult);\n\n  bool resolveAndFixAddressOfSingleOverloadCandidate(\n      ExprResult &SrcExpr, bool DoFunctionPointerConversion = false);\n\n  FunctionDecl *\n  ResolveSingleFunctionTemplateSpecialization(OverloadExpr *ovl,\n                                              bool Complain = false,\n                                              DeclAccessPair *Found = nullptr);\n\n  bool ResolveAndFixSingleFunctionTemplateSpecialization(\n                      ExprResult &SrcExpr,\n                      bool DoFunctionPointerConverion = false,\n                      bool Complain = false,\n                      SourceRange OpRangeForComplaining = SourceRange(),\n                      QualType DestTypeForComplaining = QualType(),\n                      unsigned DiagIDForComplaining = 0);\n\n\n  Expr *FixOverloadedFunctionReference(Expr *E,\n                                       DeclAccessPair FoundDecl,\n                                       FunctionDecl *Fn);\n  ExprResult FixOverloadedFunctionReference(ExprResult,\n                                            DeclAccessPair FoundDecl,\n                                            FunctionDecl *Fn);\n\n  void AddOverloadedCallCandidates(UnresolvedLookupExpr *ULE,\n                                   ArrayRef<Expr *> Args,\n                                   OverloadCandidateSet &CandidateSet,\n                                   bool PartialOverloading = false);\n  void AddOverloadedCallCandidates(\n      LookupResult &R, TemplateArgumentListInfo *ExplicitTemplateArgs,\n      ArrayRef<Expr *> Args, OverloadCandidateSet &CandidateSet);\n\n  // An enum used to represent the different possible results of building a\n  // range-based for loop.\n  enum ForRangeStatus {\n    FRS_Success,\n    FRS_NoViableFunction,\n    FRS_DiagnosticIssued\n  };\n\n  ForRangeStatus BuildForRangeBeginEndCall(SourceLocation Loc,\n                                           SourceLocation RangeLoc,\n                                           const DeclarationNameInfo &NameInfo,\n                                           LookupResult &MemberLookup,\n                                           OverloadCandidateSet *CandidateSet,\n                                           Expr *Range, ExprResult *CallExpr);\n\n  ExprResult BuildOverloadedCallExpr(Scope *S, Expr *Fn,\n                                     UnresolvedLookupExpr *ULE,\n                                     SourceLocation LParenLoc,\n                                     MultiExprArg Args,\n                                     SourceLocation RParenLoc,\n                                     Expr *ExecConfig,\n                                     bool AllowTypoCorrection=true,\n                                     bool CalleesAddressIsTaken=false);\n\n  bool buildOverloadedCallSet(Scope *S, Expr *Fn, UnresolvedLookupExpr *ULE,\n                              MultiExprArg Args, SourceLocation RParenLoc,\n                              OverloadCandidateSet *CandidateSet,\n                              ExprResult *Result);\n\n  ExprResult CreateUnresolvedLookupExpr(CXXRecordDecl *NamingClass,\n                                        NestedNameSpecifierLoc NNSLoc,\n                                        DeclarationNameInfo DNI,\n                                        const UnresolvedSetImpl &Fns,\n                                        bool PerformADL = true);\n\n  ExprResult CreateOverloadedUnaryOp(SourceLocation OpLoc,\n                                     UnaryOperatorKind Opc,\n                                     const UnresolvedSetImpl &Fns,\n                                     Expr *input, bool RequiresADL = true);\n\n  void LookupOverloadedBinOp(OverloadCandidateSet &CandidateSet,\n                             OverloadedOperatorKind Op,\n                             const UnresolvedSetImpl &Fns,\n                             ArrayRef<Expr *> Args, bool RequiresADL = true);\n  ExprResult CreateOverloadedBinOp(SourceLocation OpLoc,\n                                   BinaryOperatorKind Opc,\n                                   const UnresolvedSetImpl &Fns,\n                                   Expr *LHS, Expr *RHS,\n                                   bool RequiresADL = true,\n                                   bool AllowRewrittenCandidates = true,\n                                   FunctionDecl *DefaultedFn = nullptr);\n  ExprResult BuildSynthesizedThreeWayComparison(SourceLocation OpLoc,\n                                                const UnresolvedSetImpl &Fns,\n                                                Expr *LHS, Expr *RHS,\n                                                FunctionDecl *DefaultedFn);\n\n  ExprResult CreateOverloadedArraySubscriptExpr(SourceLocation LLoc,\n                                                SourceLocation RLoc,\n                                                Expr *Base,Expr *Idx);\n\n  ExprResult BuildCallToMemberFunction(Scope *S, Expr *MemExpr,\n                                       SourceLocation LParenLoc,\n                                       MultiExprArg Args,\n                                       SourceLocation RParenLoc,\n                                       bool AllowRecovery = false);\n  ExprResult\n  BuildCallToObjectOfClassType(Scope *S, Expr *Object, SourceLocation LParenLoc,\n                               MultiExprArg Args,\n                               SourceLocation RParenLoc);\n\n  ExprResult BuildOverloadedArrowExpr(Scope *S, Expr *Base,\n                                      SourceLocation OpLoc,\n                                      bool *NoArrowOperatorFound = nullptr);\n\n  /// CheckCallReturnType - Checks that a call expression's return type is\n  /// complete. Returns true on failure. The location passed in is the location\n  /// that best represents the call.\n  bool CheckCallReturnType(QualType ReturnType, SourceLocation Loc,\n                           CallExpr *CE, FunctionDecl *FD);\n\n  /// Helpers for dealing with blocks and functions.\n  bool CheckParmsForFunctionDef(ArrayRef<ParmVarDecl *> Parameters,\n                                bool CheckParameterNames);\n  void CheckCXXDefaultArguments(FunctionDecl *FD);\n  void CheckExtraCXXDefaultArguments(Declarator &D);\n  Scope *getNonFieldDeclScope(Scope *S);\n\n  /// \\name Name lookup\n  ///\n  /// These routines provide name lookup that is used during semantic\n  /// analysis to resolve the various kinds of names (identifiers,\n  /// overloaded operator names, constructor names, etc.) into zero or\n  /// more declarations within a particular scope. The major entry\n  /// points are LookupName, which performs unqualified name lookup,\n  /// and LookupQualifiedName, which performs qualified name lookup.\n  ///\n  /// All name lookup is performed based on some specific criteria,\n  /// which specify what names will be visible to name lookup and how\n  /// far name lookup should work. These criteria are important both\n  /// for capturing language semantics (certain lookups will ignore\n  /// certain names, for example) and for performance, since name\n  /// lookup is often a bottleneck in the compilation of C++. Name\n  /// lookup criteria is specified via the LookupCriteria enumeration.\n  ///\n  /// The results of name lookup can vary based on the kind of name\n  /// lookup performed, the current language, and the translation\n  /// unit. In C, for example, name lookup will either return nothing\n  /// (no entity found) or a single declaration. In C++, name lookup\n  /// can additionally refer to a set of overloaded functions or\n  /// result in an ambiguity. All of the possible results of name\n  /// lookup are captured by the LookupResult class, which provides\n  /// the ability to distinguish among them.\n  //@{\n\n  /// Describes the kind of name lookup to perform.\n  enum LookupNameKind {\n    /// Ordinary name lookup, which finds ordinary names (functions,\n    /// variables, typedefs, etc.) in C and most kinds of names\n    /// (functions, variables, members, types, etc.) in C++.\n    LookupOrdinaryName = 0,\n    /// Tag name lookup, which finds the names of enums, classes,\n    /// structs, and unions.\n    LookupTagName,\n    /// Label name lookup.\n    LookupLabel,\n    /// Member name lookup, which finds the names of\n    /// class/struct/union members.\n    LookupMemberName,\n    /// Look up of an operator name (e.g., operator+) for use with\n    /// operator overloading. This lookup is similar to ordinary name\n    /// lookup, but will ignore any declarations that are class members.\n    LookupOperatorName,\n    /// Look up a name following ~ in a destructor name. This is an ordinary\n    /// lookup, but prefers tags to typedefs.\n    LookupDestructorName,\n    /// Look up of a name that precedes the '::' scope resolution\n    /// operator in C++. This lookup completely ignores operator, object,\n    /// function, and enumerator names (C++ [basic.lookup.qual]p1).\n    LookupNestedNameSpecifierName,\n    /// Look up a namespace name within a C++ using directive or\n    /// namespace alias definition, ignoring non-namespace names (C++\n    /// [basic.lookup.udir]p1).\n    LookupNamespaceName,\n    /// Look up all declarations in a scope with the given name,\n    /// including resolved using declarations.  This is appropriate\n    /// for checking redeclarations for a using declaration.\n    LookupUsingDeclName,\n    /// Look up an ordinary name that is going to be redeclared as a\n    /// name with linkage. This lookup ignores any declarations that\n    /// are outside of the current scope unless they have linkage. See\n    /// C99 6.2.2p4-5 and C++ [basic.link]p6.\n    LookupRedeclarationWithLinkage,\n    /// Look up a friend of a local class. This lookup does not look\n    /// outside the innermost non-class scope. See C++11 [class.friend]p11.\n    LookupLocalFriendName,\n    /// Look up the name of an Objective-C protocol.\n    LookupObjCProtocolName,\n    /// Look up implicit 'self' parameter of an objective-c method.\n    LookupObjCImplicitSelfParam,\n    /// Look up the name of an OpenMP user-defined reduction operation.\n    LookupOMPReductionName,\n    /// Look up the name of an OpenMP user-defined mapper.\n    LookupOMPMapperName,\n    /// Look up any declaration with any name.\n    LookupAnyName\n  };\n\n  /// Specifies whether (or how) name lookup is being performed for a\n  /// redeclaration (vs. a reference).\n  enum RedeclarationKind {\n    /// The lookup is a reference to this name that is not for the\n    /// purpose of redeclaring the name.\n    NotForRedeclaration = 0,\n    /// The lookup results will be used for redeclaration of a name,\n    /// if an entity by that name already exists and is visible.\n    ForVisibleRedeclaration,\n    /// The lookup results will be used for redeclaration of a name\n    /// with external linkage; non-visible lookup results with external linkage\n    /// may also be found.\n    ForExternalRedeclaration\n  };\n\n  RedeclarationKind forRedeclarationInCurContext() {\n    // A declaration with an owning module for linkage can never link against\n    // anything that is not visible. We don't need to check linkage here; if\n    // the context has internal linkage, redeclaration lookup won't find things\n    // from other TUs, and we can't safely compute linkage yet in general.\n    if (cast<Decl>(CurContext)\n            ->getOwningModuleForLinkage(/*IgnoreLinkage*/true))\n      return ForVisibleRedeclaration;\n    return ForExternalRedeclaration;\n  }\n\n  /// The possible outcomes of name lookup for a literal operator.\n  enum LiteralOperatorLookupResult {\n    /// The lookup resulted in an error.\n    LOLR_Error,\n    /// The lookup found no match but no diagnostic was issued.\n    LOLR_ErrorNoDiagnostic,\n    /// The lookup found a single 'cooked' literal operator, which\n    /// expects a normal literal to be built and passed to it.\n    LOLR_Cooked,\n    /// The lookup found a single 'raw' literal operator, which expects\n    /// a string literal containing the spelling of the literal token.\n    LOLR_Raw,\n    /// The lookup found an overload set of literal operator templates,\n    /// which expect the characters of the spelling of the literal token to be\n    /// passed as a non-type template argument pack.\n    LOLR_Template,\n    /// The lookup found an overload set of literal operator templates,\n    /// which expect the character type and characters of the spelling of the\n    /// string literal token to be passed as template arguments.\n    LOLR_StringTemplatePack,\n  };\n\n  SpecialMemberOverloadResult LookupSpecialMember(CXXRecordDecl *D,\n                                                  CXXSpecialMember SM,\n                                                  bool ConstArg,\n                                                  bool VolatileArg,\n                                                  bool RValueThis,\n                                                  bool ConstThis,\n                                                  bool VolatileThis);\n\n  typedef std::function<void(const TypoCorrection &)> TypoDiagnosticGenerator;\n  typedef std::function<ExprResult(Sema &, TypoExpr *, TypoCorrection)>\n      TypoRecoveryCallback;\n\nprivate:\n  bool CppLookupName(LookupResult &R, Scope *S);\n\n  struct TypoExprState {\n    std::unique_ptr<TypoCorrectionConsumer> Consumer;\n    TypoDiagnosticGenerator DiagHandler;\n    TypoRecoveryCallback RecoveryHandler;\n    TypoExprState();\n    TypoExprState(TypoExprState &&other) noexcept;\n    TypoExprState &operator=(TypoExprState &&other) noexcept;\n  };\n\n  /// The set of unhandled TypoExprs and their associated state.\n  llvm::MapVector<TypoExpr *, TypoExprState> DelayedTypos;\n\n  /// Creates a new TypoExpr AST node.\n  TypoExpr *createDelayedTypo(std::unique_ptr<TypoCorrectionConsumer> TCC,\n                              TypoDiagnosticGenerator TDG,\n                              TypoRecoveryCallback TRC, SourceLocation TypoLoc);\n\n  // The set of known/encountered (unique, canonicalized) NamespaceDecls.\n  //\n  // The boolean value will be true to indicate that the namespace was loaded\n  // from an AST/PCH file, or false otherwise.\n  llvm::MapVector<NamespaceDecl*, bool> KnownNamespaces;\n\n  /// Whether we have already loaded known namespaces from an extenal\n  /// source.\n  bool LoadedExternalKnownNamespaces;\n\n  /// Helper for CorrectTypo and CorrectTypoDelayed used to create and\n  /// populate a new TypoCorrectionConsumer. Returns nullptr if typo correction\n  /// should be skipped entirely.\n  std::unique_ptr<TypoCorrectionConsumer>\n  makeTypoCorrectionConsumer(const DeclarationNameInfo &Typo,\n                             Sema::LookupNameKind LookupKind, Scope *S,\n                             CXXScopeSpec *SS,\n                             CorrectionCandidateCallback &CCC,\n                             DeclContext *MemberContext, bool EnteringContext,\n                             const ObjCObjectPointerType *OPT,\n                             bool ErrorRecovery);\n\npublic:\n  const TypoExprState &getTypoExprState(TypoExpr *TE) const;\n\n  /// Clears the state of the given TypoExpr.\n  void clearDelayedTypo(TypoExpr *TE);\n\n  /// Look up a name, looking for a single declaration.  Return\n  /// null if the results were absent, ambiguous, or overloaded.\n  ///\n  /// It is preferable to use the elaborated form and explicitly handle\n  /// ambiguity and overloaded.\n  NamedDecl *LookupSingleName(Scope *S, DeclarationName Name,\n                              SourceLocation Loc,\n                              LookupNameKind NameKind,\n                              RedeclarationKind Redecl\n                                = NotForRedeclaration);\n  bool LookupBuiltin(LookupResult &R);\n  void LookupNecessaryTypesForBuiltin(Scope *S, unsigned ID);\n  bool LookupName(LookupResult &R, Scope *S,\n                  bool AllowBuiltinCreation = false);\n  bool LookupQualifiedName(LookupResult &R, DeclContext *LookupCtx,\n                           bool InUnqualifiedLookup = false);\n  bool LookupQualifiedName(LookupResult &R, DeclContext *LookupCtx,\n                           CXXScopeSpec &SS);\n  bool LookupParsedName(LookupResult &R, Scope *S, CXXScopeSpec *SS,\n                        bool AllowBuiltinCreation = false,\n                        bool EnteringContext = false);\n  ObjCProtocolDecl *LookupProtocol(IdentifierInfo *II, SourceLocation IdLoc,\n                                   RedeclarationKind Redecl\n                                     = NotForRedeclaration);\n  bool LookupInSuper(LookupResult &R, CXXRecordDecl *Class);\n\n  void LookupOverloadedOperatorName(OverloadedOperatorKind Op, Scope *S,\n                                    UnresolvedSetImpl &Functions);\n\n  LabelDecl *LookupOrCreateLabel(IdentifierInfo *II, SourceLocation IdentLoc,\n                                 SourceLocation GnuLabelLoc = SourceLocation());\n\n  DeclContextLookupResult LookupConstructors(CXXRecordDecl *Class);\n  CXXConstructorDecl *LookupDefaultConstructor(CXXRecordDecl *Class);\n  CXXConstructorDecl *LookupCopyingConstructor(CXXRecordDecl *Class,\n                                               unsigned Quals);\n  CXXMethodDecl *LookupCopyingAssignment(CXXRecordDecl *Class, unsigned Quals,\n                                         bool RValueThis, unsigned ThisQuals);\n  CXXConstructorDecl *LookupMovingConstructor(CXXRecordDecl *Class,\n                                              unsigned Quals);\n  CXXMethodDecl *LookupMovingAssignment(CXXRecordDecl *Class, unsigned Quals,\n                                        bool RValueThis, unsigned ThisQuals);\n  CXXDestructorDecl *LookupDestructor(CXXRecordDecl *Class);\n\n  bool checkLiteralOperatorId(const CXXScopeSpec &SS, const UnqualifiedId &Id);\n  LiteralOperatorLookupResult\n  LookupLiteralOperator(Scope *S, LookupResult &R, ArrayRef<QualType> ArgTys,\n                        bool AllowRaw, bool AllowTemplate,\n                        bool AllowStringTemplate, bool DiagnoseMissing,\n                        StringLiteral *StringLit = nullptr);\n  bool isKnownName(StringRef name);\n\n  /// Status of the function emission on the CUDA/HIP/OpenMP host/device attrs.\n  enum class FunctionEmissionStatus {\n    Emitted,\n    CUDADiscarded,     // Discarded due to CUDA/HIP hostness\n    OMPDiscarded,      // Discarded due to OpenMP hostness\n    TemplateDiscarded, // Discarded due to uninstantiated templates\n    Unknown,\n  };\n  FunctionEmissionStatus getEmissionStatus(FunctionDecl *Decl,\n                                           bool Final = false);\n\n  // Whether the callee should be ignored in CUDA/HIP/OpenMP host/device check.\n  bool shouldIgnoreInHostDeviceCheck(FunctionDecl *Callee);\n\n  void ArgumentDependentLookup(DeclarationName Name, SourceLocation Loc,\n                               ArrayRef<Expr *> Args, ADLResult &Functions);\n\n  void LookupVisibleDecls(Scope *S, LookupNameKind Kind,\n                          VisibleDeclConsumer &Consumer,\n                          bool IncludeGlobalScope = true,\n                          bool LoadExternal = true);\n  void LookupVisibleDecls(DeclContext *Ctx, LookupNameKind Kind,\n                          VisibleDeclConsumer &Consumer,\n                          bool IncludeGlobalScope = true,\n                          bool IncludeDependentBases = false,\n                          bool LoadExternal = true);\n\n  enum CorrectTypoKind {\n    CTK_NonError,     // CorrectTypo used in a non error recovery situation.\n    CTK_ErrorRecovery // CorrectTypo used in normal error recovery.\n  };\n\n  TypoCorrection CorrectTypo(const DeclarationNameInfo &Typo,\n                             Sema::LookupNameKind LookupKind,\n                             Scope *S, CXXScopeSpec *SS,\n                             CorrectionCandidateCallback &CCC,\n                             CorrectTypoKind Mode,\n                             DeclContext *MemberContext = nullptr,\n                             bool EnteringContext = false,\n                             const ObjCObjectPointerType *OPT = nullptr,\n                             bool RecordFailure = true);\n\n  TypoExpr *CorrectTypoDelayed(const DeclarationNameInfo &Typo,\n                               Sema::LookupNameKind LookupKind, Scope *S,\n                               CXXScopeSpec *SS,\n                               CorrectionCandidateCallback &CCC,\n                               TypoDiagnosticGenerator TDG,\n                               TypoRecoveryCallback TRC, CorrectTypoKind Mode,\n                               DeclContext *MemberContext = nullptr,\n                               bool EnteringContext = false,\n                               const ObjCObjectPointerType *OPT = nullptr);\n\n  /// Process any TypoExprs in the given Expr and its children,\n  /// generating diagnostics as appropriate and returning a new Expr if there\n  /// were typos that were all successfully corrected and ExprError if one or\n  /// more typos could not be corrected.\n  ///\n  /// \\param E The Expr to check for TypoExprs.\n  ///\n  /// \\param InitDecl A VarDecl to avoid because the Expr being corrected is its\n  /// initializer.\n  ///\n  /// \\param RecoverUncorrectedTypos If true, when typo correction fails, it\n  /// will rebuild the given Expr with all TypoExprs degraded to RecoveryExprs.\n  ///\n  /// \\param Filter A function applied to a newly rebuilt Expr to determine if\n  /// it is an acceptable/usable result from a single combination of typo\n  /// corrections. As long as the filter returns ExprError, different\n  /// combinations of corrections will be tried until all are exhausted.\n  ExprResult CorrectDelayedTyposInExpr(\n      Expr *E, VarDecl *InitDecl = nullptr,\n      bool RecoverUncorrectedTypos = false,\n      llvm::function_ref<ExprResult(Expr *)> Filter =\n          [](Expr *E) -> ExprResult { return E; });\n\n  ExprResult CorrectDelayedTyposInExpr(\n      ExprResult ER, VarDecl *InitDecl = nullptr,\n      bool RecoverUncorrectedTypos = false,\n      llvm::function_ref<ExprResult(Expr *)> Filter =\n          [](Expr *E) -> ExprResult { return E; }) {\n    return ER.isInvalid()\n               ? ER\n               : CorrectDelayedTyposInExpr(ER.get(), InitDecl,\n                                           RecoverUncorrectedTypos, Filter);\n  }\n\n  void diagnoseTypo(const TypoCorrection &Correction,\n                    const PartialDiagnostic &TypoDiag,\n                    bool ErrorRecovery = true);\n\n  void diagnoseTypo(const TypoCorrection &Correction,\n                    const PartialDiagnostic &TypoDiag,\n                    const PartialDiagnostic &PrevNote,\n                    bool ErrorRecovery = true);\n\n  void MarkTypoCorrectedFunctionDefinition(const NamedDecl *F);\n\n  void FindAssociatedClassesAndNamespaces(SourceLocation InstantiationLoc,\n                                          ArrayRef<Expr *> Args,\n                                   AssociatedNamespaceSet &AssociatedNamespaces,\n                                   AssociatedClassSet &AssociatedClasses);\n\n  void FilterLookupForScope(LookupResult &R, DeclContext *Ctx, Scope *S,\n                            bool ConsiderLinkage, bool AllowInlineNamespace);\n\n  bool CheckRedeclarationModuleOwnership(NamedDecl *New, NamedDecl *Old);\n\n  void DiagnoseAmbiguousLookup(LookupResult &Result);\n  //@}\n\n  /// Attempts to produce a RecoveryExpr after some AST node cannot be created.\n  ExprResult CreateRecoveryExpr(SourceLocation Begin, SourceLocation End,\n                                ArrayRef<Expr *> SubExprs,\n                                QualType T = QualType());\n\n  ObjCInterfaceDecl *getObjCInterfaceDecl(IdentifierInfo *&Id,\n                                          SourceLocation IdLoc,\n                                          bool TypoCorrection = false);\n  FunctionDecl *CreateBuiltin(IdentifierInfo *II, QualType Type, unsigned ID,\n                              SourceLocation Loc);\n  NamedDecl *LazilyCreateBuiltin(IdentifierInfo *II, unsigned ID,\n                                 Scope *S, bool ForRedeclaration,\n                                 SourceLocation Loc);\n  NamedDecl *ImplicitlyDefineFunction(SourceLocation Loc, IdentifierInfo &II,\n                                      Scope *S);\n  void AddKnownFunctionAttributesForReplaceableGlobalAllocationFunction(\n      FunctionDecl *FD);\n  void AddKnownFunctionAttributes(FunctionDecl *FD);\n\n  // More parsing and symbol table subroutines.\n\n  void ProcessPragmaWeak(Scope *S, Decl *D);\n  // Decl attributes - this routine is the top level dispatcher.\n  void ProcessDeclAttributes(Scope *S, Decl *D, const Declarator &PD);\n  // Helper for delayed processing of attributes.\n  void ProcessDeclAttributeDelayed(Decl *D,\n                                   const ParsedAttributesView &AttrList);\n  void ProcessDeclAttributeList(Scope *S, Decl *D, const ParsedAttributesView &AL,\n                             bool IncludeCXX11Attributes = true);\n  bool ProcessAccessDeclAttributeList(AccessSpecDecl *ASDecl,\n                                   const ParsedAttributesView &AttrList);\n\n  void checkUnusedDeclAttributes(Declarator &D);\n\n  /// Determine if type T is a valid subject for a nonnull and similar\n  /// attributes. By default, we look through references (the behavior used by\n  /// nonnull), but if the second parameter is true, then we treat a reference\n  /// type as valid.\n  bool isValidPointerAttrType(QualType T, bool RefOkay = false);\n\n  bool CheckRegparmAttr(const ParsedAttr &attr, unsigned &value);\n  bool CheckCallingConvAttr(const ParsedAttr &attr, CallingConv &CC,\n                            const FunctionDecl *FD = nullptr);\n  bool CheckAttrTarget(const ParsedAttr &CurrAttr);\n  bool CheckAttrNoArgs(const ParsedAttr &CurrAttr);\n  bool checkStringLiteralArgumentAttr(const ParsedAttr &Attr, unsigned ArgNum,\n                                      StringRef &Str,\n                                      SourceLocation *ArgLocation = nullptr);\n  bool checkSectionName(SourceLocation LiteralLoc, StringRef Str);\n  bool checkTargetAttr(SourceLocation LiteralLoc, StringRef Str);\n  bool checkMSInheritanceAttrOnDefinition(\n      CXXRecordDecl *RD, SourceRange Range, bool BestCase,\n      MSInheritanceModel SemanticSpelling);\n\n  void CheckAlignasUnderalignment(Decl *D);\n\n  /// Adjust the calling convention of a method to be the ABI default if it\n  /// wasn't specified explicitly.  This handles method types formed from\n  /// function type typedefs and typename template arguments.\n  void adjustMemberFunctionCC(QualType &T, bool IsStatic, bool IsCtorOrDtor,\n                              SourceLocation Loc);\n\n  // Check if there is an explicit attribute, but only look through parens.\n  // The intent is to look for an attribute on the current declarator, but not\n  // one that came from a typedef.\n  bool hasExplicitCallingConv(QualType T);\n\n  /// Get the outermost AttributedType node that sets a calling convention.\n  /// Valid types should not have multiple attributes with different CCs.\n  const AttributedType *getCallingConvAttributedType(QualType T) const;\n\n  /// Stmt attributes - this routine is the top level dispatcher.\n  StmtResult ProcessStmtAttributes(Stmt *Stmt,\n                                   const ParsedAttributesView &Attrs,\n                                   SourceRange Range);\n\n  void WarnConflictingTypedMethods(ObjCMethodDecl *Method,\n                                   ObjCMethodDecl *MethodDecl,\n                                   bool IsProtocolMethodDecl);\n\n  void CheckConflictingOverridingMethod(ObjCMethodDecl *Method,\n                                   ObjCMethodDecl *Overridden,\n                                   bool IsProtocolMethodDecl);\n\n  /// WarnExactTypedMethods - This routine issues a warning if method\n  /// implementation declaration matches exactly that of its declaration.\n  void WarnExactTypedMethods(ObjCMethodDecl *Method,\n                             ObjCMethodDecl *MethodDecl,\n                             bool IsProtocolMethodDecl);\n\n  typedef llvm::SmallPtrSet<Selector, 8> SelectorSet;\n\n  /// CheckImplementationIvars - This routine checks if the instance variables\n  /// listed in the implelementation match those listed in the interface.\n  void CheckImplementationIvars(ObjCImplementationDecl *ImpDecl,\n                                ObjCIvarDecl **Fields, unsigned nIvars,\n                                SourceLocation Loc);\n\n  /// ImplMethodsVsClassMethods - This is main routine to warn if any method\n  /// remains unimplemented in the class or category \\@implementation.\n  void ImplMethodsVsClassMethods(Scope *S, ObjCImplDecl* IMPDecl,\n                                 ObjCContainerDecl* IDecl,\n                                 bool IncompleteImpl = false);\n\n  /// DiagnoseUnimplementedProperties - This routine warns on those properties\n  /// which must be implemented by this implementation.\n  void DiagnoseUnimplementedProperties(Scope *S, ObjCImplDecl* IMPDecl,\n                                       ObjCContainerDecl *CDecl,\n                                       bool SynthesizeProperties);\n\n  /// Diagnose any null-resettable synthesized setters.\n  void diagnoseNullResettableSynthesizedSetters(const ObjCImplDecl *impDecl);\n\n  /// DefaultSynthesizeProperties - This routine default synthesizes all\n  /// properties which must be synthesized in the class's \\@implementation.\n  void DefaultSynthesizeProperties(Scope *S, ObjCImplDecl *IMPDecl,\n                                   ObjCInterfaceDecl *IDecl,\n                                   SourceLocation AtEnd);\n  void DefaultSynthesizeProperties(Scope *S, Decl *D, SourceLocation AtEnd);\n\n  /// IvarBacksCurrentMethodAccessor - This routine returns 'true' if 'IV' is\n  /// an ivar synthesized for 'Method' and 'Method' is a property accessor\n  /// declared in class 'IFace'.\n  bool IvarBacksCurrentMethodAccessor(ObjCInterfaceDecl *IFace,\n                                      ObjCMethodDecl *Method, ObjCIvarDecl *IV);\n\n  /// DiagnoseUnusedBackingIvarInAccessor - Issue an 'unused' warning if ivar which\n  /// backs the property is not used in the property's accessor.\n  void DiagnoseUnusedBackingIvarInAccessor(Scope *S,\n                                           const ObjCImplementationDecl *ImplD);\n\n  /// GetIvarBackingPropertyAccessor - If method is a property setter/getter and\n  /// it property has a backing ivar, returns this ivar; otherwise, returns NULL.\n  /// It also returns ivar's property on success.\n  ObjCIvarDecl *GetIvarBackingPropertyAccessor(const ObjCMethodDecl *Method,\n                                               const ObjCPropertyDecl *&PDecl) const;\n\n  /// Called by ActOnProperty to handle \\@property declarations in\n  /// class extensions.\n  ObjCPropertyDecl *HandlePropertyInClassExtension(Scope *S,\n                      SourceLocation AtLoc,\n                      SourceLocation LParenLoc,\n                      FieldDeclarator &FD,\n                      Selector GetterSel,\n                      SourceLocation GetterNameLoc,\n                      Selector SetterSel,\n                      SourceLocation SetterNameLoc,\n                      const bool isReadWrite,\n                      unsigned &Attributes,\n                      const unsigned AttributesAsWritten,\n                      QualType T,\n                      TypeSourceInfo *TSI,\n                      tok::ObjCKeywordKind MethodImplKind);\n\n  /// Called by ActOnProperty and HandlePropertyInClassExtension to\n  /// handle creating the ObjcPropertyDecl for a category or \\@interface.\n  ObjCPropertyDecl *CreatePropertyDecl(Scope *S,\n                                       ObjCContainerDecl *CDecl,\n                                       SourceLocation AtLoc,\n                                       SourceLocation LParenLoc,\n                                       FieldDeclarator &FD,\n                                       Selector GetterSel,\n                                       SourceLocation GetterNameLoc,\n                                       Selector SetterSel,\n                                       SourceLocation SetterNameLoc,\n                                       const bool isReadWrite,\n                                       const unsigned Attributes,\n                                       const unsigned AttributesAsWritten,\n                                       QualType T,\n                                       TypeSourceInfo *TSI,\n                                       tok::ObjCKeywordKind MethodImplKind,\n                                       DeclContext *lexicalDC = nullptr);\n\n  /// AtomicPropertySetterGetterRules - This routine enforces the rule (via\n  /// warning) when atomic property has one but not the other user-declared\n  /// setter or getter.\n  void AtomicPropertySetterGetterRules(ObjCImplDecl* IMPDecl,\n                                       ObjCInterfaceDecl* IDecl);\n\n  void DiagnoseOwningPropertyGetterSynthesis(const ObjCImplementationDecl *D);\n\n  void DiagnoseMissingDesignatedInitOverrides(\n                                          const ObjCImplementationDecl *ImplD,\n                                          const ObjCInterfaceDecl *IFD);\n\n  void DiagnoseDuplicateIvars(ObjCInterfaceDecl *ID, ObjCInterfaceDecl *SID);\n\n  enum MethodMatchStrategy {\n    MMS_loose,\n    MMS_strict\n  };\n\n  /// MatchTwoMethodDeclarations - Checks if two methods' type match and returns\n  /// true, or false, accordingly.\n  bool MatchTwoMethodDeclarations(const ObjCMethodDecl *Method,\n                                  const ObjCMethodDecl *PrevMethod,\n                                  MethodMatchStrategy strategy = MMS_strict);\n\n  /// MatchAllMethodDeclarations - Check methods declaraed in interface or\n  /// or protocol against those declared in their implementations.\n  void MatchAllMethodDeclarations(const SelectorSet &InsMap,\n                                  const SelectorSet &ClsMap,\n                                  SelectorSet &InsMapSeen,\n                                  SelectorSet &ClsMapSeen,\n                                  ObjCImplDecl* IMPDecl,\n                                  ObjCContainerDecl* IDecl,\n                                  bool &IncompleteImpl,\n                                  bool ImmediateClass,\n                                  bool WarnCategoryMethodImpl=false);\n\n  /// CheckCategoryVsClassMethodMatches - Checks that methods implemented in\n  /// category matches with those implemented in its primary class and\n  /// warns each time an exact match is found.\n  void CheckCategoryVsClassMethodMatches(ObjCCategoryImplDecl *CatIMP);\n\n  /// Add the given method to the list of globally-known methods.\n  void addMethodToGlobalList(ObjCMethodList *List, ObjCMethodDecl *Method);\n\n  /// Returns default addr space for method qualifiers.\n  LangAS getDefaultCXXMethodAddrSpace() const;\n\nprivate:\n  /// AddMethodToGlobalPool - Add an instance or factory method to the global\n  /// pool. See descriptoin of AddInstanceMethodToGlobalPool.\n  void AddMethodToGlobalPool(ObjCMethodDecl *Method, bool impl, bool instance);\n\n  /// LookupMethodInGlobalPool - Returns the instance or factory method and\n  /// optionally warns if there are multiple signatures.\n  ObjCMethodDecl *LookupMethodInGlobalPool(Selector Sel, SourceRange R,\n                                           bool receiverIdOrClass,\n                                           bool instance);\n\npublic:\n  /// - Returns instance or factory methods in global method pool for\n  /// given selector. It checks the desired kind first, if none is found, and\n  /// parameter checkTheOther is set, it then checks the other kind. If no such\n  /// method or only one method is found, function returns false; otherwise, it\n  /// returns true.\n  bool\n  CollectMultipleMethodsInGlobalPool(Selector Sel,\n                                     SmallVectorImpl<ObjCMethodDecl*>& Methods,\n                                     bool InstanceFirst, bool CheckTheOther,\n                                     const ObjCObjectType *TypeBound = nullptr);\n\n  bool\n  AreMultipleMethodsInGlobalPool(Selector Sel, ObjCMethodDecl *BestMethod,\n                                 SourceRange R, bool receiverIdOrClass,\n                                 SmallVectorImpl<ObjCMethodDecl*>& Methods);\n\n  void\n  DiagnoseMultipleMethodInGlobalPool(SmallVectorImpl<ObjCMethodDecl*> &Methods,\n                                     Selector Sel, SourceRange R,\n                                     bool receiverIdOrClass);\n\nprivate:\n  /// - Returns a selector which best matches given argument list or\n  /// nullptr if none could be found\n  ObjCMethodDecl *SelectBestMethod(Selector Sel, MultiExprArg Args,\n                                   bool IsInstance,\n                                   SmallVectorImpl<ObjCMethodDecl*>& Methods);\n\n\n  /// Record the typo correction failure and return an empty correction.\n  TypoCorrection FailedCorrection(IdentifierInfo *Typo, SourceLocation TypoLoc,\n                                  bool RecordFailure = true) {\n    if (RecordFailure)\n      TypoCorrectionFailures[Typo].insert(TypoLoc);\n    return TypoCorrection();\n  }\n\npublic:\n  /// AddInstanceMethodToGlobalPool - All instance methods in a translation\n  /// unit are added to a global pool. This allows us to efficiently associate\n  /// a selector with a method declaraation for purposes of typechecking\n  /// messages sent to \"id\" (where the class of the object is unknown).\n  void AddInstanceMethodToGlobalPool(ObjCMethodDecl *Method, bool impl=false) {\n    AddMethodToGlobalPool(Method, impl, /*instance*/true);\n  }\n\n  /// AddFactoryMethodToGlobalPool - Same as above, but for factory methods.\n  void AddFactoryMethodToGlobalPool(ObjCMethodDecl *Method, bool impl=false) {\n    AddMethodToGlobalPool(Method, impl, /*instance*/false);\n  }\n\n  /// AddAnyMethodToGlobalPool - Add any method, instance or factory to global\n  /// pool.\n  void AddAnyMethodToGlobalPool(Decl *D);\n\n  /// LookupInstanceMethodInGlobalPool - Returns the method and warns if\n  /// there are multiple signatures.\n  ObjCMethodDecl *LookupInstanceMethodInGlobalPool(Selector Sel, SourceRange R,\n                                                   bool receiverIdOrClass=false) {\n    return LookupMethodInGlobalPool(Sel, R, receiverIdOrClass,\n                                    /*instance*/true);\n  }\n\n  /// LookupFactoryMethodInGlobalPool - Returns the method and warns if\n  /// there are multiple signatures.\n  ObjCMethodDecl *LookupFactoryMethodInGlobalPool(Selector Sel, SourceRange R,\n                                                  bool receiverIdOrClass=false) {\n    return LookupMethodInGlobalPool(Sel, R, receiverIdOrClass,\n                                    /*instance*/false);\n  }\n\n  const ObjCMethodDecl *SelectorsForTypoCorrection(Selector Sel,\n                              QualType ObjectType=QualType());\n  /// LookupImplementedMethodInGlobalPool - Returns the method which has an\n  /// implementation.\n  ObjCMethodDecl *LookupImplementedMethodInGlobalPool(Selector Sel);\n\n  /// CollectIvarsToConstructOrDestruct - Collect those ivars which require\n  /// initialization.\n  void CollectIvarsToConstructOrDestruct(ObjCInterfaceDecl *OI,\n                                  SmallVectorImpl<ObjCIvarDecl*> &Ivars);\n\n  //===--------------------------------------------------------------------===//\n  // Statement Parsing Callbacks: SemaStmt.cpp.\npublic:\n  class FullExprArg {\n  public:\n    FullExprArg() : E(nullptr) { }\n    FullExprArg(Sema &actions) : E(nullptr) { }\n\n    ExprResult release() {\n      return E;\n    }\n\n    Expr *get() const { return E; }\n\n    Expr *operator->() {\n      return E;\n    }\n\n  private:\n    // FIXME: No need to make the entire Sema class a friend when it's just\n    // Sema::MakeFullExpr that needs access to the constructor below.\n    friend class Sema;\n\n    explicit FullExprArg(Expr *expr) : E(expr) {}\n\n    Expr *E;\n  };\n\n  FullExprArg MakeFullExpr(Expr *Arg) {\n    return MakeFullExpr(Arg, Arg ? Arg->getExprLoc() : SourceLocation());\n  }\n  FullExprArg MakeFullExpr(Expr *Arg, SourceLocation CC) {\n    return FullExprArg(\n        ActOnFinishFullExpr(Arg, CC, /*DiscardedValue*/ false).get());\n  }\n  FullExprArg MakeFullDiscardedValueExpr(Expr *Arg) {\n    ExprResult FE =\n        ActOnFinishFullExpr(Arg, Arg ? Arg->getExprLoc() : SourceLocation(),\n                            /*DiscardedValue*/ true);\n    return FullExprArg(FE.get());\n  }\n\n  StmtResult ActOnExprStmt(ExprResult Arg, bool DiscardedValue = true);\n  StmtResult ActOnExprStmtError();\n\n  StmtResult ActOnNullStmt(SourceLocation SemiLoc,\n                           bool HasLeadingEmptyMacro = false);\n\n  void ActOnStartOfCompoundStmt(bool IsStmtExpr);\n  void ActOnAfterCompoundStatementLeadingPragmas();\n  void ActOnFinishOfCompoundStmt();\n  StmtResult ActOnCompoundStmt(SourceLocation L, SourceLocation R,\n                               ArrayRef<Stmt *> Elts, bool isStmtExpr);\n\n  /// A RAII object to enter scope of a compound statement.\n  class CompoundScopeRAII {\n  public:\n    CompoundScopeRAII(Sema &S, bool IsStmtExpr = false) : S(S) {\n      S.ActOnStartOfCompoundStmt(IsStmtExpr);\n    }\n\n    ~CompoundScopeRAII() {\n      S.ActOnFinishOfCompoundStmt();\n    }\n\n  private:\n    Sema &S;\n  };\n\n  /// An RAII helper that pops function a function scope on exit.\n  struct FunctionScopeRAII {\n    Sema &S;\n    bool Active;\n    FunctionScopeRAII(Sema &S) : S(S), Active(true) {}\n    ~FunctionScopeRAII() {\n      if (Active)\n        S.PopFunctionScopeInfo();\n    }\n    void disable() { Active = false; }\n  };\n\n  StmtResult ActOnDeclStmt(DeclGroupPtrTy Decl,\n                                   SourceLocation StartLoc,\n                                   SourceLocation EndLoc);\n  void ActOnForEachDeclStmt(DeclGroupPtrTy Decl);\n  StmtResult ActOnForEachLValueExpr(Expr *E);\n  ExprResult ActOnCaseExpr(SourceLocation CaseLoc, ExprResult Val);\n  StmtResult ActOnCaseStmt(SourceLocation CaseLoc, ExprResult LHS,\n                           SourceLocation DotDotDotLoc, ExprResult RHS,\n                           SourceLocation ColonLoc);\n  void ActOnCaseStmtBody(Stmt *CaseStmt, Stmt *SubStmt);\n\n  StmtResult ActOnDefaultStmt(SourceLocation DefaultLoc,\n                                      SourceLocation ColonLoc,\n                                      Stmt *SubStmt, Scope *CurScope);\n  StmtResult ActOnLabelStmt(SourceLocation IdentLoc, LabelDecl *TheDecl,\n                            SourceLocation ColonLoc, Stmt *SubStmt);\n\n  StmtResult ActOnAttributedStmt(SourceLocation AttrLoc,\n                                 ArrayRef<const Attr*> Attrs,\n                                 Stmt *SubStmt);\n\n  class ConditionResult;\n  StmtResult ActOnIfStmt(SourceLocation IfLoc, bool IsConstexpr,\n                         SourceLocation LParenLoc, Stmt *InitStmt,\n                         ConditionResult Cond, SourceLocation RParenLoc,\n                         Stmt *ThenVal, SourceLocation ElseLoc, Stmt *ElseVal);\n  StmtResult BuildIfStmt(SourceLocation IfLoc, bool IsConstexpr,\n                         SourceLocation LParenLoc, Stmt *InitStmt,\n                         ConditionResult Cond, SourceLocation RParenLoc,\n                         Stmt *ThenVal, SourceLocation ElseLoc, Stmt *ElseVal);\n  StmtResult ActOnStartOfSwitchStmt(SourceLocation SwitchLoc,\n                                    SourceLocation LParenLoc, Stmt *InitStmt,\n                                    ConditionResult Cond,\n                                    SourceLocation RParenLoc);\n  StmtResult ActOnFinishSwitchStmt(SourceLocation SwitchLoc,\n                                           Stmt *Switch, Stmt *Body);\n  StmtResult ActOnWhileStmt(SourceLocation WhileLoc, SourceLocation LParenLoc,\n                            ConditionResult Cond, SourceLocation RParenLoc,\n                            Stmt *Body);\n  StmtResult ActOnDoStmt(SourceLocation DoLoc, Stmt *Body,\n                         SourceLocation WhileLoc, SourceLocation CondLParen,\n                         Expr *Cond, SourceLocation CondRParen);\n\n  StmtResult ActOnForStmt(SourceLocation ForLoc,\n                          SourceLocation LParenLoc,\n                          Stmt *First,\n                          ConditionResult Second,\n                          FullExprArg Third,\n                          SourceLocation RParenLoc,\n                          Stmt *Body);\n  ExprResult CheckObjCForCollectionOperand(SourceLocation forLoc,\n                                           Expr *collection);\n  StmtResult ActOnObjCForCollectionStmt(SourceLocation ForColLoc,\n                                        Stmt *First, Expr *collection,\n                                        SourceLocation RParenLoc);\n  StmtResult FinishObjCForCollectionStmt(Stmt *ForCollection, Stmt *Body);\n\n  enum BuildForRangeKind {\n    /// Initial building of a for-range statement.\n    BFRK_Build,\n    /// Instantiation or recovery rebuild of a for-range statement. Don't\n    /// attempt any typo-correction.\n    BFRK_Rebuild,\n    /// Determining whether a for-range statement could be built. Avoid any\n    /// unnecessary or irreversible actions.\n    BFRK_Check\n  };\n\n  StmtResult ActOnCXXForRangeStmt(Scope *S, SourceLocation ForLoc,\n                                  SourceLocation CoawaitLoc,\n                                  Stmt *InitStmt,\n                                  Stmt *LoopVar,\n                                  SourceLocation ColonLoc, Expr *Collection,\n                                  SourceLocation RParenLoc,\n                                  BuildForRangeKind Kind);\n  StmtResult BuildCXXForRangeStmt(SourceLocation ForLoc,\n                                  SourceLocation CoawaitLoc,\n                                  Stmt *InitStmt,\n                                  SourceLocation ColonLoc,\n                                  Stmt *RangeDecl, Stmt *Begin, Stmt *End,\n                                  Expr *Cond, Expr *Inc,\n                                  Stmt *LoopVarDecl,\n                                  SourceLocation RParenLoc,\n                                  BuildForRangeKind Kind);\n  StmtResult FinishCXXForRangeStmt(Stmt *ForRange, Stmt *Body);\n\n  StmtResult ActOnGotoStmt(SourceLocation GotoLoc,\n                           SourceLocation LabelLoc,\n                           LabelDecl *TheDecl);\n  StmtResult ActOnIndirectGotoStmt(SourceLocation GotoLoc,\n                                   SourceLocation StarLoc,\n                                   Expr *DestExp);\n  StmtResult ActOnContinueStmt(SourceLocation ContinueLoc, Scope *CurScope);\n  StmtResult ActOnBreakStmt(SourceLocation BreakLoc, Scope *CurScope);\n\n  void ActOnCapturedRegionStart(SourceLocation Loc, Scope *CurScope,\n                                CapturedRegionKind Kind, unsigned NumParams);\n  typedef std::pair<StringRef, QualType> CapturedParamNameType;\n  void ActOnCapturedRegionStart(SourceLocation Loc, Scope *CurScope,\n                                CapturedRegionKind Kind,\n                                ArrayRef<CapturedParamNameType> Params,\n                                unsigned OpenMPCaptureLevel = 0);\n  StmtResult ActOnCapturedRegionEnd(Stmt *S);\n  void ActOnCapturedRegionError();\n  RecordDecl *CreateCapturedStmtRecordDecl(CapturedDecl *&CD,\n                                           SourceLocation Loc,\n                                           unsigned NumParams);\n\n  enum CopyElisionSemanticsKind {\n    CES_Strict = 0,\n    CES_AllowParameters = 1,\n    CES_AllowDifferentTypes = 2,\n    CES_AllowExceptionVariables = 4,\n    CES_AllowRValueReferenceType = 8,\n    CES_ImplicitlyMovableCXX11CXX14CXX17 =\n        (CES_AllowParameters | CES_AllowDifferentTypes),\n    CES_ImplicitlyMovableCXX20 =\n        (CES_AllowParameters | CES_AllowDifferentTypes |\n         CES_AllowExceptionVariables | CES_AllowRValueReferenceType),\n  };\n\n  VarDecl *getCopyElisionCandidate(QualType ReturnType, Expr *E,\n                                   CopyElisionSemanticsKind CESK);\n  bool isCopyElisionCandidate(QualType ReturnType, const VarDecl *VD,\n                              CopyElisionSemanticsKind CESK);\n\n  StmtResult ActOnReturnStmt(SourceLocation ReturnLoc, Expr *RetValExp,\n                             Scope *CurScope);\n  StmtResult BuildReturnStmt(SourceLocation ReturnLoc, Expr *RetValExp);\n  StmtResult ActOnCapScopeReturnStmt(SourceLocation ReturnLoc, Expr *RetValExp);\n\n  StmtResult ActOnGCCAsmStmt(SourceLocation AsmLoc, bool IsSimple,\n                             bool IsVolatile, unsigned NumOutputs,\n                             unsigned NumInputs, IdentifierInfo **Names,\n                             MultiExprArg Constraints, MultiExprArg Exprs,\n                             Expr *AsmString, MultiExprArg Clobbers,\n                             unsigned NumLabels,\n                             SourceLocation RParenLoc);\n\n  void FillInlineAsmIdentifierInfo(Expr *Res,\n                                   llvm::InlineAsmIdentifierInfo &Info);\n  ExprResult LookupInlineAsmIdentifier(CXXScopeSpec &SS,\n                                       SourceLocation TemplateKWLoc,\n                                       UnqualifiedId &Id,\n                                       bool IsUnevaluatedContext);\n  bool LookupInlineAsmField(StringRef Base, StringRef Member,\n                            unsigned &Offset, SourceLocation AsmLoc);\n  ExprResult LookupInlineAsmVarDeclField(Expr *RefExpr, StringRef Member,\n                                         SourceLocation AsmLoc);\n  StmtResult ActOnMSAsmStmt(SourceLocation AsmLoc, SourceLocation LBraceLoc,\n                            ArrayRef<Token> AsmToks,\n                            StringRef AsmString,\n                            unsigned NumOutputs, unsigned NumInputs,\n                            ArrayRef<StringRef> Constraints,\n                            ArrayRef<StringRef> Clobbers,\n                            ArrayRef<Expr*> Exprs,\n                            SourceLocation EndLoc);\n  LabelDecl *GetOrCreateMSAsmLabel(StringRef ExternalLabelName,\n                                   SourceLocation Location,\n                                   bool AlwaysCreate);\n\n  VarDecl *BuildObjCExceptionDecl(TypeSourceInfo *TInfo, QualType ExceptionType,\n                                  SourceLocation StartLoc,\n                                  SourceLocation IdLoc, IdentifierInfo *Id,\n                                  bool Invalid = false);\n\n  Decl *ActOnObjCExceptionDecl(Scope *S, Declarator &D);\n\n  StmtResult ActOnObjCAtCatchStmt(SourceLocation AtLoc, SourceLocation RParen,\n                                  Decl *Parm, Stmt *Body);\n\n  StmtResult ActOnObjCAtFinallyStmt(SourceLocation AtLoc, Stmt *Body);\n\n  StmtResult ActOnObjCAtTryStmt(SourceLocation AtLoc, Stmt *Try,\n                                MultiStmtArg Catch, Stmt *Finally);\n\n  StmtResult BuildObjCAtThrowStmt(SourceLocation AtLoc, Expr *Throw);\n  StmtResult ActOnObjCAtThrowStmt(SourceLocation AtLoc, Expr *Throw,\n                                  Scope *CurScope);\n  ExprResult ActOnObjCAtSynchronizedOperand(SourceLocation atLoc,\n                                            Expr *operand);\n  StmtResult ActOnObjCAtSynchronizedStmt(SourceLocation AtLoc,\n                                         Expr *SynchExpr,\n                                         Stmt *SynchBody);\n\n  StmtResult ActOnObjCAutoreleasePoolStmt(SourceLocation AtLoc, Stmt *Body);\n\n  VarDecl *BuildExceptionDeclaration(Scope *S, TypeSourceInfo *TInfo,\n                                     SourceLocation StartLoc,\n                                     SourceLocation IdLoc,\n                                     IdentifierInfo *Id);\n\n  Decl *ActOnExceptionDeclarator(Scope *S, Declarator &D);\n\n  StmtResult ActOnCXXCatchBlock(SourceLocation CatchLoc,\n                                Decl *ExDecl, Stmt *HandlerBlock);\n  StmtResult ActOnCXXTryBlock(SourceLocation TryLoc, Stmt *TryBlock,\n                              ArrayRef<Stmt *> Handlers);\n\n  StmtResult ActOnSEHTryBlock(bool IsCXXTry, // try (true) or __try (false) ?\n                              SourceLocation TryLoc, Stmt *TryBlock,\n                              Stmt *Handler);\n  StmtResult ActOnSEHExceptBlock(SourceLocation Loc,\n                                 Expr *FilterExpr,\n                                 Stmt *Block);\n  void ActOnStartSEHFinallyBlock();\n  void ActOnAbortSEHFinallyBlock();\n  StmtResult ActOnFinishSEHFinallyBlock(SourceLocation Loc, Stmt *Block);\n  StmtResult ActOnSEHLeaveStmt(SourceLocation Loc, Scope *CurScope);\n\n  void DiagnoseReturnInConstructorExceptionHandler(CXXTryStmt *TryBlock);\n\n  bool ShouldWarnIfUnusedFileScopedDecl(const DeclaratorDecl *D) const;\n\n  /// If it's a file scoped decl that must warn if not used, keep track\n  /// of it.\n  void MarkUnusedFileScopedDecl(const DeclaratorDecl *D);\n\n  /// DiagnoseUnusedExprResult - If the statement passed in is an expression\n  /// whose result is unused, warn.\n  void DiagnoseUnusedExprResult(const Stmt *S);\n  void DiagnoseUnusedNestedTypedefs(const RecordDecl *D);\n  void DiagnoseUnusedDecl(const NamedDecl *ND);\n\n  /// Emit \\p DiagID if statement located on \\p StmtLoc has a suspicious null\n  /// statement as a \\p Body, and it is located on the same line.\n  ///\n  /// This helps prevent bugs due to typos, such as:\n  ///     if (condition);\n  ///       do_stuff();\n  void DiagnoseEmptyStmtBody(SourceLocation StmtLoc,\n                             const Stmt *Body,\n                             unsigned DiagID);\n\n  /// Warn if a for/while loop statement \\p S, which is followed by\n  /// \\p PossibleBody, has a suspicious null statement as a body.\n  void DiagnoseEmptyLoopBody(const Stmt *S,\n                             const Stmt *PossibleBody);\n\n  /// Warn if a value is moved to itself.\n  void DiagnoseSelfMove(const Expr *LHSExpr, const Expr *RHSExpr,\n                        SourceLocation OpLoc);\n\n  /// Warn if we're implicitly casting from a _Nullable pointer type to a\n  /// _Nonnull one.\n  void diagnoseNullableToNonnullConversion(QualType DstType, QualType SrcType,\n                                           SourceLocation Loc);\n\n  /// Warn when implicitly casting 0 to nullptr.\n  void diagnoseZeroToNullptrConversion(CastKind Kind, const Expr *E);\n\n  ParsingDeclState PushParsingDeclaration(sema::DelayedDiagnosticPool &pool) {\n    return DelayedDiagnostics.push(pool);\n  }\n  void PopParsingDeclaration(ParsingDeclState state, Decl *decl);\n\n  typedef ProcessingContextState ParsingClassState;\n  ParsingClassState PushParsingClass() {\n    ParsingClassDepth++;\n    return DelayedDiagnostics.pushUndelayed();\n  }\n  void PopParsingClass(ParsingClassState state) {\n    ParsingClassDepth--;\n    DelayedDiagnostics.popUndelayed(state);\n  }\n\n  void redelayDiagnostics(sema::DelayedDiagnosticPool &pool);\n\n  void DiagnoseAvailabilityOfDecl(NamedDecl *D, ArrayRef<SourceLocation> Locs,\n                                  const ObjCInterfaceDecl *UnknownObjCClass,\n                                  bool ObjCPropertyAccess,\n                                  bool AvoidPartialAvailabilityChecks = false,\n                                  ObjCInterfaceDecl *ClassReceiver = nullptr);\n\n  bool makeUnavailableInSystemHeader(SourceLocation loc,\n                                     UnavailableAttr::ImplicitReason reason);\n\n  /// Issue any -Wunguarded-availability warnings in \\c FD\n  void DiagnoseUnguardedAvailabilityViolations(Decl *FD);\n\n  void handleDelayedAvailabilityCheck(sema::DelayedDiagnostic &DD, Decl *Ctx);\n\n  //===--------------------------------------------------------------------===//\n  // Expression Parsing Callbacks: SemaExpr.cpp.\n\n  bool CanUseDecl(NamedDecl *D, bool TreatUnavailableAsInvalid);\n  bool DiagnoseUseOfDecl(NamedDecl *D, ArrayRef<SourceLocation> Locs,\n                         const ObjCInterfaceDecl *UnknownObjCClass = nullptr,\n                         bool ObjCPropertyAccess = false,\n                         bool AvoidPartialAvailabilityChecks = false,\n                         ObjCInterfaceDecl *ClassReciever = nullptr);\n  void NoteDeletedFunction(FunctionDecl *FD);\n  void NoteDeletedInheritingConstructor(CXXConstructorDecl *CD);\n  bool DiagnosePropertyAccessorMismatch(ObjCPropertyDecl *PD,\n                                        ObjCMethodDecl *Getter,\n                                        SourceLocation Loc);\n  void DiagnoseSentinelCalls(NamedDecl *D, SourceLocation Loc,\n                             ArrayRef<Expr *> Args);\n\n  void PushExpressionEvaluationContext(\n      ExpressionEvaluationContext NewContext, Decl *LambdaContextDecl = nullptr,\n      ExpressionEvaluationContextRecord::ExpressionKind Type =\n          ExpressionEvaluationContextRecord::EK_Other);\n  enum ReuseLambdaContextDecl_t { ReuseLambdaContextDecl };\n  void PushExpressionEvaluationContext(\n      ExpressionEvaluationContext NewContext, ReuseLambdaContextDecl_t,\n      ExpressionEvaluationContextRecord::ExpressionKind Type =\n          ExpressionEvaluationContextRecord::EK_Other);\n  void PopExpressionEvaluationContext();\n\n  void DiscardCleanupsInEvaluationContext();\n\n  ExprResult TransformToPotentiallyEvaluated(Expr *E);\n  ExprResult HandleExprEvaluationContextForTypeof(Expr *E);\n\n  ExprResult CheckUnevaluatedOperand(Expr *E);\n  void CheckUnusedVolatileAssignment(Expr *E);\n\n  ExprResult ActOnConstantExpression(ExprResult Res);\n\n  // Functions for marking a declaration referenced.  These functions also\n  // contain the relevant logic for marking if a reference to a function or\n  // variable is an odr-use (in the C++11 sense).  There are separate variants\n  // for expressions referring to a decl; these exist because odr-use marking\n  // needs to be delayed for some constant variables when we build one of the\n  // named expressions.\n  //\n  // MightBeOdrUse indicates whether the use could possibly be an odr-use, and\n  // should usually be true. This only needs to be set to false if the lack of\n  // odr-use cannot be determined from the current context (for instance,\n  // because the name denotes a virtual function and was written without an\n  // explicit nested-name-specifier).\n  void MarkAnyDeclReferenced(SourceLocation Loc, Decl *D, bool MightBeOdrUse);\n  void MarkFunctionReferenced(SourceLocation Loc, FunctionDecl *Func,\n                              bool MightBeOdrUse = true);\n  void MarkVariableReferenced(SourceLocation Loc, VarDecl *Var);\n  void MarkDeclRefReferenced(DeclRefExpr *E, const Expr *Base = nullptr);\n  void MarkMemberReferenced(MemberExpr *E);\n  void MarkFunctionParmPackReferenced(FunctionParmPackExpr *E);\n  void MarkCaptureUsedInEnclosingContext(VarDecl *Capture, SourceLocation Loc,\n                                         unsigned CapturingScopeIndex);\n\n  ExprResult CheckLValueToRValueConversionOperand(Expr *E);\n  void CleanupVarDeclMarking();\n\n  enum TryCaptureKind {\n    TryCapture_Implicit, TryCapture_ExplicitByVal, TryCapture_ExplicitByRef\n  };\n\n  /// Try to capture the given variable.\n  ///\n  /// \\param Var The variable to capture.\n  ///\n  /// \\param Loc The location at which the capture occurs.\n  ///\n  /// \\param Kind The kind of capture, which may be implicit (for either a\n  /// block or a lambda), or explicit by-value or by-reference (for a lambda).\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis, if one is provided in\n  /// an explicit lambda capture.\n  ///\n  /// \\param BuildAndDiagnose Whether we are actually supposed to add the\n  /// captures or diagnose errors. If false, this routine merely check whether\n  /// the capture can occur without performing the capture itself or complaining\n  /// if the variable cannot be captured.\n  ///\n  /// \\param CaptureType Will be set to the type of the field used to capture\n  /// this variable in the innermost block or lambda. Only valid when the\n  /// variable can be captured.\n  ///\n  /// \\param DeclRefType Will be set to the type of a reference to the capture\n  /// from within the current scope. Only valid when the variable can be\n  /// captured.\n  ///\n  /// \\param FunctionScopeIndexToStopAt If non-null, it points to the index\n  /// of the FunctionScopeInfo stack beyond which we do not attempt to capture.\n  /// This is useful when enclosing lambdas must speculatively capture\n  /// variables that may or may not be used in certain specializations of\n  /// a nested generic lambda.\n  ///\n  /// \\returns true if an error occurred (i.e., the variable cannot be\n  /// captured) and false if the capture succeeded.\n  bool tryCaptureVariable(VarDecl *Var, SourceLocation Loc, TryCaptureKind Kind,\n                          SourceLocation EllipsisLoc, bool BuildAndDiagnose,\n                          QualType &CaptureType,\n                          QualType &DeclRefType,\n                          const unsigned *const FunctionScopeIndexToStopAt);\n\n  /// Try to capture the given variable.\n  bool tryCaptureVariable(VarDecl *Var, SourceLocation Loc,\n                          TryCaptureKind Kind = TryCapture_Implicit,\n                          SourceLocation EllipsisLoc = SourceLocation());\n\n  /// Checks if the variable must be captured.\n  bool NeedToCaptureVariable(VarDecl *Var, SourceLocation Loc);\n\n  /// Given a variable, determine the type that a reference to that\n  /// variable will have in the given scope.\n  QualType getCapturedDeclRefType(VarDecl *Var, SourceLocation Loc);\n\n  /// Mark all of the declarations referenced within a particular AST node as\n  /// referenced. Used when template instantiation instantiates a non-dependent\n  /// type -- entities referenced by the type are now referenced.\n  void MarkDeclarationsReferencedInType(SourceLocation Loc, QualType T);\n  void MarkDeclarationsReferencedInExpr(Expr *E,\n                                        bool SkipLocalVariables = false);\n\n  /// Try to recover by turning the given expression into a\n  /// call.  Returns true if recovery was attempted or an error was\n  /// emitted; this may also leave the ExprResult invalid.\n  bool tryToRecoverWithCall(ExprResult &E, const PartialDiagnostic &PD,\n                            bool ForceComplain = false,\n                            bool (*IsPlausibleResult)(QualType) = nullptr);\n\n  /// Figure out if an expression could be turned into a call.\n  bool tryExprAsCall(Expr &E, QualType &ZeroArgCallReturnTy,\n                     UnresolvedSetImpl &NonTemplateOverloads);\n\n  /// Try to convert an expression \\p E to type \\p Ty. Returns the result of the\n  /// conversion.\n  ExprResult tryConvertExprToType(Expr *E, QualType Ty);\n\n  /// Conditionally issue a diagnostic based on the current\n  /// evaluation context.\n  ///\n  /// \\param Statement If Statement is non-null, delay reporting the\n  /// diagnostic until the function body is parsed, and then do a basic\n  /// reachability analysis to determine if the statement is reachable.\n  /// If it is unreachable, the diagnostic will not be emitted.\n  bool DiagRuntimeBehavior(SourceLocation Loc, const Stmt *Statement,\n                           const PartialDiagnostic &PD);\n  /// Similar, but diagnostic is only produced if all the specified statements\n  /// are reachable.\n  bool DiagRuntimeBehavior(SourceLocation Loc, ArrayRef<const Stmt*> Stmts,\n                           const PartialDiagnostic &PD);\n\n  // Primary Expressions.\n  SourceRange getExprRange(Expr *E) const;\n\n  ExprResult ActOnIdExpression(\n      Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,\n      UnqualifiedId &Id, bool HasTrailingLParen, bool IsAddressOfOperand,\n      CorrectionCandidateCallback *CCC = nullptr,\n      bool IsInlineAsmIdentifier = false, Token *KeywordReplacement = nullptr);\n\n  void DecomposeUnqualifiedId(const UnqualifiedId &Id,\n                              TemplateArgumentListInfo &Buffer,\n                              DeclarationNameInfo &NameInfo,\n                              const TemplateArgumentListInfo *&TemplateArgs);\n\n  bool DiagnoseDependentMemberLookup(LookupResult &R);\n\n  bool\n  DiagnoseEmptyLookup(Scope *S, CXXScopeSpec &SS, LookupResult &R,\n                      CorrectionCandidateCallback &CCC,\n                      TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr,\n                      ArrayRef<Expr *> Args = None, TypoExpr **Out = nullptr);\n\n  DeclResult LookupIvarInObjCMethod(LookupResult &Lookup, Scope *S,\n                                    IdentifierInfo *II);\n  ExprResult BuildIvarRefExpr(Scope *S, SourceLocation Loc, ObjCIvarDecl *IV);\n\n  ExprResult LookupInObjCMethod(LookupResult &LookUp, Scope *S,\n                                IdentifierInfo *II,\n                                bool AllowBuiltinCreation=false);\n\n  ExprResult ActOnDependentIdExpression(const CXXScopeSpec &SS,\n                                        SourceLocation TemplateKWLoc,\n                                        const DeclarationNameInfo &NameInfo,\n                                        bool isAddressOfOperand,\n                                const TemplateArgumentListInfo *TemplateArgs);\n\n  /// If \\p D cannot be odr-used in the current expression evaluation context,\n  /// return a reason explaining why. Otherwise, return NOUR_None.\n  NonOdrUseReason getNonOdrUseReasonInCurrentContext(ValueDecl *D);\n\n  DeclRefExpr *BuildDeclRefExpr(ValueDecl *D, QualType Ty, ExprValueKind VK,\n                                SourceLocation Loc,\n                                const CXXScopeSpec *SS = nullptr);\n  DeclRefExpr *\n  BuildDeclRefExpr(ValueDecl *D, QualType Ty, ExprValueKind VK,\n                   const DeclarationNameInfo &NameInfo,\n                   const CXXScopeSpec *SS = nullptr,\n                   NamedDecl *FoundD = nullptr,\n                   SourceLocation TemplateKWLoc = SourceLocation(),\n                   const TemplateArgumentListInfo *TemplateArgs = nullptr);\n  DeclRefExpr *\n  BuildDeclRefExpr(ValueDecl *D, QualType Ty, ExprValueKind VK,\n                   const DeclarationNameInfo &NameInfo,\n                   NestedNameSpecifierLoc NNS,\n                   NamedDecl *FoundD = nullptr,\n                   SourceLocation TemplateKWLoc = SourceLocation(),\n                   const TemplateArgumentListInfo *TemplateArgs = nullptr);\n\n  ExprResult\n  BuildAnonymousStructUnionMemberReference(\n      const CXXScopeSpec &SS,\n      SourceLocation nameLoc,\n      IndirectFieldDecl *indirectField,\n      DeclAccessPair FoundDecl = DeclAccessPair::make(nullptr, AS_none),\n      Expr *baseObjectExpr = nullptr,\n      SourceLocation opLoc = SourceLocation());\n\n  ExprResult BuildPossibleImplicitMemberExpr(\n      const CXXScopeSpec &SS, SourceLocation TemplateKWLoc, LookupResult &R,\n      const TemplateArgumentListInfo *TemplateArgs, const Scope *S,\n      UnresolvedLookupExpr *AsULE = nullptr);\n  ExprResult BuildImplicitMemberExpr(const CXXScopeSpec &SS,\n                                     SourceLocation TemplateKWLoc,\n                                     LookupResult &R,\n                                const TemplateArgumentListInfo *TemplateArgs,\n                                     bool IsDefiniteInstance,\n                                     const Scope *S);\n  bool UseArgumentDependentLookup(const CXXScopeSpec &SS,\n                                  const LookupResult &R,\n                                  bool HasTrailingLParen);\n\n  ExprResult\n  BuildQualifiedDeclarationNameExpr(CXXScopeSpec &SS,\n                                    const DeclarationNameInfo &NameInfo,\n                                    bool IsAddressOfOperand, const Scope *S,\n                                    TypeSourceInfo **RecoveryTSI = nullptr);\n\n  ExprResult BuildDependentDeclRefExpr(const CXXScopeSpec &SS,\n                                       SourceLocation TemplateKWLoc,\n                                const DeclarationNameInfo &NameInfo,\n                                const TemplateArgumentListInfo *TemplateArgs);\n\n  ExprResult BuildDeclarationNameExpr(const CXXScopeSpec &SS,\n                                      LookupResult &R,\n                                      bool NeedsADL,\n                                      bool AcceptInvalidDecl = false);\n  ExprResult BuildDeclarationNameExpr(\n      const CXXScopeSpec &SS, const DeclarationNameInfo &NameInfo, NamedDecl *D,\n      NamedDecl *FoundD = nullptr,\n      const TemplateArgumentListInfo *TemplateArgs = nullptr,\n      bool AcceptInvalidDecl = false);\n\n  ExprResult BuildLiteralOperatorCall(LookupResult &R,\n                      DeclarationNameInfo &SuffixInfo,\n                      ArrayRef<Expr *> Args,\n                      SourceLocation LitEndLoc,\n                      TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr);\n\n  ExprResult BuildPredefinedExpr(SourceLocation Loc,\n                                 PredefinedExpr::IdentKind IK);\n  ExprResult ActOnPredefinedExpr(SourceLocation Loc, tok::TokenKind Kind);\n  ExprResult ActOnIntegerConstant(SourceLocation Loc, uint64_t Val);\n\n  bool CheckLoopHintExpr(Expr *E, SourceLocation Loc);\n\n  ExprResult ActOnNumericConstant(const Token &Tok, Scope *UDLScope = nullptr);\n  ExprResult ActOnCharacterConstant(const Token &Tok,\n                                    Scope *UDLScope = nullptr);\n  ExprResult ActOnParenExpr(SourceLocation L, SourceLocation R, Expr *E);\n  ExprResult ActOnParenListExpr(SourceLocation L,\n                                SourceLocation R,\n                                MultiExprArg Val);\n\n  /// ActOnStringLiteral - The specified tokens were lexed as pasted string\n  /// fragments (e.g. \"foo\" \"bar\" L\"baz\").\n  ExprResult ActOnStringLiteral(ArrayRef<Token> StringToks,\n                                Scope *UDLScope = nullptr);\n\n  ExprResult ActOnGenericSelectionExpr(SourceLocation KeyLoc,\n                                       SourceLocation DefaultLoc,\n                                       SourceLocation RParenLoc,\n                                       Expr *ControllingExpr,\n                                       ArrayRef<ParsedType> ArgTypes,\n                                       ArrayRef<Expr *> ArgExprs);\n  ExprResult CreateGenericSelectionExpr(SourceLocation KeyLoc,\n                                        SourceLocation DefaultLoc,\n                                        SourceLocation RParenLoc,\n                                        Expr *ControllingExpr,\n                                        ArrayRef<TypeSourceInfo *> Types,\n                                        ArrayRef<Expr *> Exprs);\n\n  // Binary/Unary Operators.  'Tok' is the token for the operator.\n  ExprResult CreateBuiltinUnaryOp(SourceLocation OpLoc, UnaryOperatorKind Opc,\n                                  Expr *InputExpr);\n  ExprResult BuildUnaryOp(Scope *S, SourceLocation OpLoc,\n                          UnaryOperatorKind Opc, Expr *Input);\n  ExprResult ActOnUnaryOp(Scope *S, SourceLocation OpLoc,\n                          tok::TokenKind Op, Expr *Input);\n\n  bool isQualifiedMemberAccess(Expr *E);\n  QualType CheckAddressOfOperand(ExprResult &Operand, SourceLocation OpLoc);\n\n  ExprResult CreateUnaryExprOrTypeTraitExpr(TypeSourceInfo *TInfo,\n                                            SourceLocation OpLoc,\n                                            UnaryExprOrTypeTrait ExprKind,\n                                            SourceRange R);\n  ExprResult CreateUnaryExprOrTypeTraitExpr(Expr *E, SourceLocation OpLoc,\n                                            UnaryExprOrTypeTrait ExprKind);\n  ExprResult\n    ActOnUnaryExprOrTypeTraitExpr(SourceLocation OpLoc,\n                                  UnaryExprOrTypeTrait ExprKind,\n                                  bool IsType, void *TyOrEx,\n                                  SourceRange ArgRange);\n\n  ExprResult CheckPlaceholderExpr(Expr *E);\n  bool CheckVecStepExpr(Expr *E);\n\n  bool CheckUnaryExprOrTypeTraitOperand(Expr *E, UnaryExprOrTypeTrait ExprKind);\n  bool CheckUnaryExprOrTypeTraitOperand(QualType ExprType, SourceLocation OpLoc,\n                                        SourceRange ExprRange,\n                                        UnaryExprOrTypeTrait ExprKind);\n  ExprResult ActOnSizeofParameterPackExpr(Scope *S,\n                                          SourceLocation OpLoc,\n                                          IdentifierInfo &Name,\n                                          SourceLocation NameLoc,\n                                          SourceLocation RParenLoc);\n  ExprResult ActOnPostfixUnaryOp(Scope *S, SourceLocation OpLoc,\n                                 tok::TokenKind Kind, Expr *Input);\n\n  ExprResult ActOnArraySubscriptExpr(Scope *S, Expr *Base, SourceLocation LLoc,\n                                     Expr *Idx, SourceLocation RLoc);\n  ExprResult CreateBuiltinArraySubscriptExpr(Expr *Base, SourceLocation LLoc,\n                                             Expr *Idx, SourceLocation RLoc);\n\n  ExprResult CreateBuiltinMatrixSubscriptExpr(Expr *Base, Expr *RowIdx,\n                                              Expr *ColumnIdx,\n                                              SourceLocation RBLoc);\n\n  ExprResult ActOnOMPArraySectionExpr(Expr *Base, SourceLocation LBLoc,\n                                      Expr *LowerBound,\n                                      SourceLocation ColonLocFirst,\n                                      SourceLocation ColonLocSecond,\n                                      Expr *Length, Expr *Stride,\n                                      SourceLocation RBLoc);\n  ExprResult ActOnOMPArrayShapingExpr(Expr *Base, SourceLocation LParenLoc,\n                                      SourceLocation RParenLoc,\n                                      ArrayRef<Expr *> Dims,\n                                      ArrayRef<SourceRange> Brackets);\n\n  /// Data structure for iterator expression.\n  struct OMPIteratorData {\n    IdentifierInfo *DeclIdent = nullptr;\n    SourceLocation DeclIdentLoc;\n    ParsedType Type;\n    OMPIteratorExpr::IteratorRange Range;\n    SourceLocation AssignLoc;\n    SourceLocation ColonLoc;\n    SourceLocation SecColonLoc;\n  };\n\n  ExprResult ActOnOMPIteratorExpr(Scope *S, SourceLocation IteratorKwLoc,\n                                  SourceLocation LLoc, SourceLocation RLoc,\n                                  ArrayRef<OMPIteratorData> Data);\n\n  // This struct is for use by ActOnMemberAccess to allow\n  // BuildMemberReferenceExpr to be able to reinvoke ActOnMemberAccess after\n  // changing the access operator from a '.' to a '->' (to see if that is the\n  // change needed to fix an error about an unknown member, e.g. when the class\n  // defines a custom operator->).\n  struct ActOnMemberAccessExtraArgs {\n    Scope *S;\n    UnqualifiedId &Id;\n    Decl *ObjCImpDecl;\n  };\n\n  ExprResult BuildMemberReferenceExpr(\n      Expr *Base, QualType BaseType, SourceLocation OpLoc, bool IsArrow,\n      CXXScopeSpec &SS, SourceLocation TemplateKWLoc,\n      NamedDecl *FirstQualifierInScope, const DeclarationNameInfo &NameInfo,\n      const TemplateArgumentListInfo *TemplateArgs,\n      const Scope *S,\n      ActOnMemberAccessExtraArgs *ExtraArgs = nullptr);\n\n  ExprResult\n  BuildMemberReferenceExpr(Expr *Base, QualType BaseType, SourceLocation OpLoc,\n                           bool IsArrow, const CXXScopeSpec &SS,\n                           SourceLocation TemplateKWLoc,\n                           NamedDecl *FirstQualifierInScope, LookupResult &R,\n                           const TemplateArgumentListInfo *TemplateArgs,\n                           const Scope *S,\n                           bool SuppressQualifierCheck = false,\n                           ActOnMemberAccessExtraArgs *ExtraArgs = nullptr);\n\n  ExprResult BuildFieldReferenceExpr(Expr *BaseExpr, bool IsArrow,\n                                     SourceLocation OpLoc,\n                                     const CXXScopeSpec &SS, FieldDecl *Field,\n                                     DeclAccessPair FoundDecl,\n                                     const DeclarationNameInfo &MemberNameInfo);\n\n  ExprResult PerformMemberExprBaseConversion(Expr *Base, bool IsArrow);\n\n  bool CheckQualifiedMemberReference(Expr *BaseExpr, QualType BaseType,\n                                     const CXXScopeSpec &SS,\n                                     const LookupResult &R);\n\n  ExprResult ActOnDependentMemberExpr(Expr *Base, QualType BaseType,\n                                      bool IsArrow, SourceLocation OpLoc,\n                                      const CXXScopeSpec &SS,\n                                      SourceLocation TemplateKWLoc,\n                                      NamedDecl *FirstQualifierInScope,\n                               const DeclarationNameInfo &NameInfo,\n                               const TemplateArgumentListInfo *TemplateArgs);\n\n  ExprResult ActOnMemberAccessExpr(Scope *S, Expr *Base,\n                                   SourceLocation OpLoc,\n                                   tok::TokenKind OpKind,\n                                   CXXScopeSpec &SS,\n                                   SourceLocation TemplateKWLoc,\n                                   UnqualifiedId &Member,\n                                   Decl *ObjCImpDecl);\n\n  MemberExpr *\n  BuildMemberExpr(Expr *Base, bool IsArrow, SourceLocation OpLoc,\n                  const CXXScopeSpec *SS, SourceLocation TemplateKWLoc,\n                  ValueDecl *Member, DeclAccessPair FoundDecl,\n                  bool HadMultipleCandidates,\n                  const DeclarationNameInfo &MemberNameInfo, QualType Ty,\n                  ExprValueKind VK, ExprObjectKind OK,\n                  const TemplateArgumentListInfo *TemplateArgs = nullptr);\n  MemberExpr *\n  BuildMemberExpr(Expr *Base, bool IsArrow, SourceLocation OpLoc,\n                  NestedNameSpecifierLoc NNS, SourceLocation TemplateKWLoc,\n                  ValueDecl *Member, DeclAccessPair FoundDecl,\n                  bool HadMultipleCandidates,\n                  const DeclarationNameInfo &MemberNameInfo, QualType Ty,\n                  ExprValueKind VK, ExprObjectKind OK,\n                  const TemplateArgumentListInfo *TemplateArgs = nullptr);\n\n  void ActOnDefaultCtorInitializers(Decl *CDtorDecl);\n  bool ConvertArgumentsForCall(CallExpr *Call, Expr *Fn,\n                               FunctionDecl *FDecl,\n                               const FunctionProtoType *Proto,\n                               ArrayRef<Expr *> Args,\n                               SourceLocation RParenLoc,\n                               bool ExecConfig = false);\n  void CheckStaticArrayArgument(SourceLocation CallLoc,\n                                ParmVarDecl *Param,\n                                const Expr *ArgExpr);\n\n  /// ActOnCallExpr - Handle a call to Fn with the specified array of arguments.\n  /// This provides the location of the left/right parens and a list of comma\n  /// locations.\n  ExprResult ActOnCallExpr(Scope *S, Expr *Fn, SourceLocation LParenLoc,\n                           MultiExprArg ArgExprs, SourceLocation RParenLoc,\n                           Expr *ExecConfig = nullptr);\n  ExprResult BuildCallExpr(Scope *S, Expr *Fn, SourceLocation LParenLoc,\n                           MultiExprArg ArgExprs, SourceLocation RParenLoc,\n                           Expr *ExecConfig = nullptr,\n                           bool IsExecConfig = false,\n                           bool AllowRecovery = false);\n  enum class AtomicArgumentOrder { API, AST };\n  ExprResult\n  BuildAtomicExpr(SourceRange CallRange, SourceRange ExprRange,\n                  SourceLocation RParenLoc, MultiExprArg Args,\n                  AtomicExpr::AtomicOp Op,\n                  AtomicArgumentOrder ArgOrder = AtomicArgumentOrder::API);\n  ExprResult\n  BuildResolvedCallExpr(Expr *Fn, NamedDecl *NDecl, SourceLocation LParenLoc,\n                        ArrayRef<Expr *> Arg, SourceLocation RParenLoc,\n                        Expr *Config = nullptr, bool IsExecConfig = false,\n                        ADLCallKind UsesADL = ADLCallKind::NotADL);\n\n  ExprResult ActOnCUDAExecConfigExpr(Scope *S, SourceLocation LLLLoc,\n                                     MultiExprArg ExecConfig,\n                                     SourceLocation GGGLoc);\n\n  ExprResult ActOnCastExpr(Scope *S, SourceLocation LParenLoc,\n                           Declarator &D, ParsedType &Ty,\n                           SourceLocation RParenLoc, Expr *CastExpr);\n  ExprResult BuildCStyleCastExpr(SourceLocation LParenLoc,\n                                 TypeSourceInfo *Ty,\n                                 SourceLocation RParenLoc,\n                                 Expr *Op);\n  CastKind PrepareScalarCast(ExprResult &src, QualType destType);\n\n  /// Build an altivec or OpenCL literal.\n  ExprResult BuildVectorLiteral(SourceLocation LParenLoc,\n                                SourceLocation RParenLoc, Expr *E,\n                                TypeSourceInfo *TInfo);\n\n  ExprResult MaybeConvertParenListExprToParenExpr(Scope *S, Expr *ME);\n\n  ExprResult ActOnCompoundLiteral(SourceLocation LParenLoc,\n                                  ParsedType Ty,\n                                  SourceLocation RParenLoc,\n                                  Expr *InitExpr);\n\n  ExprResult BuildCompoundLiteralExpr(SourceLocation LParenLoc,\n                                      TypeSourceInfo *TInfo,\n                                      SourceLocation RParenLoc,\n                                      Expr *LiteralExpr);\n\n  ExprResult ActOnInitList(SourceLocation LBraceLoc,\n                           MultiExprArg InitArgList,\n                           SourceLocation RBraceLoc);\n\n  ExprResult BuildInitList(SourceLocation LBraceLoc,\n                           MultiExprArg InitArgList,\n                           SourceLocation RBraceLoc);\n\n  ExprResult ActOnDesignatedInitializer(Designation &Desig,\n                                        SourceLocation EqualOrColonLoc,\n                                        bool GNUSyntax,\n                                        ExprResult Init);\n\nprivate:\n  static BinaryOperatorKind ConvertTokenKindToBinaryOpcode(tok::TokenKind Kind);\n\npublic:\n  ExprResult ActOnBinOp(Scope *S, SourceLocation TokLoc,\n                        tok::TokenKind Kind, Expr *LHSExpr, Expr *RHSExpr);\n  ExprResult BuildBinOp(Scope *S, SourceLocation OpLoc,\n                        BinaryOperatorKind Opc, Expr *LHSExpr, Expr *RHSExpr);\n  ExprResult CreateBuiltinBinOp(SourceLocation OpLoc, BinaryOperatorKind Opc,\n                                Expr *LHSExpr, Expr *RHSExpr);\n  void LookupBinOp(Scope *S, SourceLocation OpLoc, BinaryOperatorKind Opc,\n                   UnresolvedSetImpl &Functions);\n\n  void DiagnoseCommaOperator(const Expr *LHS, SourceLocation Loc);\n\n  /// ActOnConditionalOp - Parse a ?: operation.  Note that 'LHS' may be null\n  /// in the case of a the GNU conditional expr extension.\n  ExprResult ActOnConditionalOp(SourceLocation QuestionLoc,\n                                SourceLocation ColonLoc,\n                                Expr *CondExpr, Expr *LHSExpr, Expr *RHSExpr);\n\n  /// ActOnAddrLabel - Parse the GNU address of label extension: \"&&foo\".\n  ExprResult ActOnAddrLabel(SourceLocation OpLoc, SourceLocation LabLoc,\n                            LabelDecl *TheDecl);\n\n  void ActOnStartStmtExpr();\n  ExprResult ActOnStmtExpr(Scope *S, SourceLocation LPLoc, Stmt *SubStmt,\n                           SourceLocation RPLoc);\n  ExprResult BuildStmtExpr(SourceLocation LPLoc, Stmt *SubStmt,\n                           SourceLocation RPLoc, unsigned TemplateDepth);\n  // Handle the final expression in a statement expression.\n  ExprResult ActOnStmtExprResult(ExprResult E);\n  void ActOnStmtExprError();\n\n  // __builtin_offsetof(type, identifier(.identifier|[expr])*)\n  struct OffsetOfComponent {\n    SourceLocation LocStart, LocEnd;\n    bool isBrackets;  // true if [expr], false if .ident\n    union {\n      IdentifierInfo *IdentInfo;\n      Expr *E;\n    } U;\n  };\n\n  /// __builtin_offsetof(type, a.b[123][456].c)\n  ExprResult BuildBuiltinOffsetOf(SourceLocation BuiltinLoc,\n                                  TypeSourceInfo *TInfo,\n                                  ArrayRef<OffsetOfComponent> Components,\n                                  SourceLocation RParenLoc);\n  ExprResult ActOnBuiltinOffsetOf(Scope *S,\n                                  SourceLocation BuiltinLoc,\n                                  SourceLocation TypeLoc,\n                                  ParsedType ParsedArgTy,\n                                  ArrayRef<OffsetOfComponent> Components,\n                                  SourceLocation RParenLoc);\n\n  // __builtin_choose_expr(constExpr, expr1, expr2)\n  ExprResult ActOnChooseExpr(SourceLocation BuiltinLoc,\n                             Expr *CondExpr, Expr *LHSExpr,\n                             Expr *RHSExpr, SourceLocation RPLoc);\n\n  // __builtin_va_arg(expr, type)\n  ExprResult ActOnVAArg(SourceLocation BuiltinLoc, Expr *E, ParsedType Ty,\n                        SourceLocation RPLoc);\n  ExprResult BuildVAArgExpr(SourceLocation BuiltinLoc, Expr *E,\n                            TypeSourceInfo *TInfo, SourceLocation RPLoc);\n\n  // __builtin_LINE(), __builtin_FUNCTION(), __builtin_FILE(),\n  // __builtin_COLUMN()\n  ExprResult ActOnSourceLocExpr(SourceLocExpr::IdentKind Kind,\n                                SourceLocation BuiltinLoc,\n                                SourceLocation RPLoc);\n\n  // Build a potentially resolved SourceLocExpr.\n  ExprResult BuildSourceLocExpr(SourceLocExpr::IdentKind Kind,\n                                SourceLocation BuiltinLoc, SourceLocation RPLoc,\n                                DeclContext *ParentContext);\n\n  // __null\n  ExprResult ActOnGNUNullExpr(SourceLocation TokenLoc);\n\n  bool CheckCaseExpression(Expr *E);\n\n  /// Describes the result of an \"if-exists\" condition check.\n  enum IfExistsResult {\n    /// The symbol exists.\n    IER_Exists,\n\n    /// The symbol does not exist.\n    IER_DoesNotExist,\n\n    /// The name is a dependent name, so the results will differ\n    /// from one instantiation to the next.\n    IER_Dependent,\n\n    /// An error occurred.\n    IER_Error\n  };\n\n  IfExistsResult\n  CheckMicrosoftIfExistsSymbol(Scope *S, CXXScopeSpec &SS,\n                               const DeclarationNameInfo &TargetNameInfo);\n\n  IfExistsResult\n  CheckMicrosoftIfExistsSymbol(Scope *S, SourceLocation KeywordLoc,\n                               bool IsIfExists, CXXScopeSpec &SS,\n                               UnqualifiedId &Name);\n\n  StmtResult BuildMSDependentExistsStmt(SourceLocation KeywordLoc,\n                                        bool IsIfExists,\n                                        NestedNameSpecifierLoc QualifierLoc,\n                                        DeclarationNameInfo NameInfo,\n                                        Stmt *Nested);\n  StmtResult ActOnMSDependentExistsStmt(SourceLocation KeywordLoc,\n                                        bool IsIfExists,\n                                        CXXScopeSpec &SS, UnqualifiedId &Name,\n                                        Stmt *Nested);\n\n  //===------------------------- \"Block\" Extension ------------------------===//\n\n  /// ActOnBlockStart - This callback is invoked when a block literal is\n  /// started.\n  void ActOnBlockStart(SourceLocation CaretLoc, Scope *CurScope);\n\n  /// ActOnBlockArguments - This callback allows processing of block arguments.\n  /// If there are no arguments, this is still invoked.\n  void ActOnBlockArguments(SourceLocation CaretLoc, Declarator &ParamInfo,\n                           Scope *CurScope);\n\n  /// ActOnBlockError - If there is an error parsing a block, this callback\n  /// is invoked to pop the information about the block from the action impl.\n  void ActOnBlockError(SourceLocation CaretLoc, Scope *CurScope);\n\n  /// ActOnBlockStmtExpr - This is called when the body of a block statement\n  /// literal was successfully completed.  ^(int x){...}\n  ExprResult ActOnBlockStmtExpr(SourceLocation CaretLoc, Stmt *Body,\n                                Scope *CurScope);\n\n  //===---------------------------- Clang Extensions ----------------------===//\n\n  /// __builtin_convertvector(...)\n  ExprResult ActOnConvertVectorExpr(Expr *E, ParsedType ParsedDestTy,\n                                    SourceLocation BuiltinLoc,\n                                    SourceLocation RParenLoc);\n\n  //===---------------------------- OpenCL Features -----------------------===//\n\n  /// __builtin_astype(...)\n  ExprResult ActOnAsTypeExpr(Expr *E, ParsedType ParsedDestTy,\n                             SourceLocation BuiltinLoc,\n                             SourceLocation RParenLoc);\n\n  //===---------------------------- C++ Features --------------------------===//\n\n  // Act on C++ namespaces\n  Decl *ActOnStartNamespaceDef(Scope *S, SourceLocation InlineLoc,\n                               SourceLocation NamespaceLoc,\n                               SourceLocation IdentLoc, IdentifierInfo *Ident,\n                               SourceLocation LBrace,\n                               const ParsedAttributesView &AttrList,\n                               UsingDirectiveDecl *&UsingDecl);\n  void ActOnFinishNamespaceDef(Decl *Dcl, SourceLocation RBrace);\n\n  NamespaceDecl *getStdNamespace() const;\n  NamespaceDecl *getOrCreateStdNamespace();\n\n  NamespaceDecl *lookupStdExperimentalNamespace();\n\n  CXXRecordDecl *getStdBadAlloc() const;\n  EnumDecl *getStdAlignValT() const;\n\nprivate:\n  // A cache representing if we've fully checked the various comparison category\n  // types stored in ASTContext. The bit-index corresponds to the integer value\n  // of a ComparisonCategoryType enumerator.\n  llvm::SmallBitVector FullyCheckedComparisonCategories;\n\n  ValueDecl *tryLookupCtorInitMemberDecl(CXXRecordDecl *ClassDecl,\n                                         CXXScopeSpec &SS,\n                                         ParsedType TemplateTypeTy,\n                                         IdentifierInfo *MemberOrBase);\n\npublic:\n  enum class ComparisonCategoryUsage {\n    /// The '<=>' operator was used in an expression and a builtin operator\n    /// was selected.\n    OperatorInExpression,\n    /// A defaulted 'operator<=>' needed the comparison category. This\n    /// typically only applies to 'std::strong_ordering', due to the implicit\n    /// fallback return value.\n    DefaultedOperator,\n  };\n\n  /// Lookup the specified comparison category types in the standard\n  ///   library, an check the VarDecls possibly returned by the operator<=>\n  ///   builtins for that type.\n  ///\n  /// \\return The type of the comparison category type corresponding to the\n  ///   specified Kind, or a null type if an error occurs\n  QualType CheckComparisonCategoryType(ComparisonCategoryType Kind,\n                                       SourceLocation Loc,\n                                       ComparisonCategoryUsage Usage);\n\n  /// Tests whether Ty is an instance of std::initializer_list and, if\n  /// it is and Element is not NULL, assigns the element type to Element.\n  bool isStdInitializerList(QualType Ty, QualType *Element);\n\n  /// Looks for the std::initializer_list template and instantiates it\n  /// with Element, or emits an error if it's not found.\n  ///\n  /// \\returns The instantiated template, or null on error.\n  QualType BuildStdInitializerList(QualType Element, SourceLocation Loc);\n\n  /// Determine whether Ctor is an initializer-list constructor, as\n  /// defined in [dcl.init.list]p2.\n  bool isInitListConstructor(const FunctionDecl *Ctor);\n\n  Decl *ActOnUsingDirective(Scope *CurScope, SourceLocation UsingLoc,\n                            SourceLocation NamespcLoc, CXXScopeSpec &SS,\n                            SourceLocation IdentLoc,\n                            IdentifierInfo *NamespcName,\n                            const ParsedAttributesView &AttrList);\n\n  void PushUsingDirective(Scope *S, UsingDirectiveDecl *UDir);\n\n  Decl *ActOnNamespaceAliasDef(Scope *CurScope,\n                               SourceLocation NamespaceLoc,\n                               SourceLocation AliasLoc,\n                               IdentifierInfo *Alias,\n                               CXXScopeSpec &SS,\n                               SourceLocation IdentLoc,\n                               IdentifierInfo *Ident);\n\n  void HideUsingShadowDecl(Scope *S, UsingShadowDecl *Shadow);\n  bool CheckUsingShadowDecl(UsingDecl *UD, NamedDecl *Target,\n                            const LookupResult &PreviousDecls,\n                            UsingShadowDecl *&PrevShadow);\n  UsingShadowDecl *BuildUsingShadowDecl(Scope *S, UsingDecl *UD,\n                                        NamedDecl *Target,\n                                        UsingShadowDecl *PrevDecl);\n\n  bool CheckUsingDeclRedeclaration(SourceLocation UsingLoc,\n                                   bool HasTypenameKeyword,\n                                   const CXXScopeSpec &SS,\n                                   SourceLocation NameLoc,\n                                   const LookupResult &Previous);\n  bool CheckUsingDeclQualifier(SourceLocation UsingLoc,\n                               bool HasTypename,\n                               const CXXScopeSpec &SS,\n                               const DeclarationNameInfo &NameInfo,\n                               SourceLocation NameLoc);\n\n  NamedDecl *BuildUsingDeclaration(\n      Scope *S, AccessSpecifier AS, SourceLocation UsingLoc,\n      bool HasTypenameKeyword, SourceLocation TypenameLoc, CXXScopeSpec &SS,\n      DeclarationNameInfo NameInfo, SourceLocation EllipsisLoc,\n      const ParsedAttributesView &AttrList, bool IsInstantiation);\n  NamedDecl *BuildUsingPackDecl(NamedDecl *InstantiatedFrom,\n                                ArrayRef<NamedDecl *> Expansions);\n\n  bool CheckInheritingConstructorUsingDecl(UsingDecl *UD);\n\n  /// Given a derived-class using shadow declaration for a constructor and the\n  /// correspnding base class constructor, find or create the implicit\n  /// synthesized derived class constructor to use for this initialization.\n  CXXConstructorDecl *\n  findInheritingConstructor(SourceLocation Loc, CXXConstructorDecl *BaseCtor,\n                            ConstructorUsingShadowDecl *DerivedShadow);\n\n  Decl *ActOnUsingDeclaration(Scope *CurScope, AccessSpecifier AS,\n                              SourceLocation UsingLoc,\n                              SourceLocation TypenameLoc, CXXScopeSpec &SS,\n                              UnqualifiedId &Name, SourceLocation EllipsisLoc,\n                              const ParsedAttributesView &AttrList);\n  Decl *ActOnAliasDeclaration(Scope *CurScope, AccessSpecifier AS,\n                              MultiTemplateParamsArg TemplateParams,\n                              SourceLocation UsingLoc, UnqualifiedId &Name,\n                              const ParsedAttributesView &AttrList,\n                              TypeResult Type, Decl *DeclFromDeclSpec);\n\n  /// BuildCXXConstructExpr - Creates a complete call to a constructor,\n  /// including handling of its default argument expressions.\n  ///\n  /// \\param ConstructKind - a CXXConstructExpr::ConstructionKind\n  ExprResult\n  BuildCXXConstructExpr(SourceLocation ConstructLoc, QualType DeclInitType,\n                        NamedDecl *FoundDecl,\n                        CXXConstructorDecl *Constructor, MultiExprArg Exprs,\n                        bool HadMultipleCandidates, bool IsListInitialization,\n                        bool IsStdInitListInitialization,\n                        bool RequiresZeroInit, unsigned ConstructKind,\n                        SourceRange ParenRange);\n\n  /// Build a CXXConstructExpr whose constructor has already been resolved if\n  /// it denotes an inherited constructor.\n  ExprResult\n  BuildCXXConstructExpr(SourceLocation ConstructLoc, QualType DeclInitType,\n                        CXXConstructorDecl *Constructor, bool Elidable,\n                        MultiExprArg Exprs,\n                        bool HadMultipleCandidates, bool IsListInitialization,\n                        bool IsStdInitListInitialization,\n                        bool RequiresZeroInit, unsigned ConstructKind,\n                        SourceRange ParenRange);\n\n  // FIXME: Can we remove this and have the above BuildCXXConstructExpr check if\n  // the constructor can be elidable?\n  ExprResult\n  BuildCXXConstructExpr(SourceLocation ConstructLoc, QualType DeclInitType,\n                        NamedDecl *FoundDecl,\n                        CXXConstructorDecl *Constructor, bool Elidable,\n                        MultiExprArg Exprs, bool HadMultipleCandidates,\n                        bool IsListInitialization,\n                        bool IsStdInitListInitialization, bool RequiresZeroInit,\n                        unsigned ConstructKind, SourceRange ParenRange);\n\n  ExprResult BuildCXXDefaultInitExpr(SourceLocation Loc, FieldDecl *Field);\n\n\n  /// Instantiate or parse a C++ default argument expression as necessary.\n  /// Return true on error.\n  bool CheckCXXDefaultArgExpr(SourceLocation CallLoc, FunctionDecl *FD,\n                              ParmVarDecl *Param);\n\n  /// BuildCXXDefaultArgExpr - Creates a CXXDefaultArgExpr, instantiating\n  /// the default expr if needed.\n  ExprResult BuildCXXDefaultArgExpr(SourceLocation CallLoc,\n                                    FunctionDecl *FD,\n                                    ParmVarDecl *Param);\n\n  /// FinalizeVarWithDestructor - Prepare for calling destructor on the\n  /// constructed variable.\n  void FinalizeVarWithDestructor(VarDecl *VD, const RecordType *DeclInitType);\n\n  /// Helper class that collects exception specifications for\n  /// implicitly-declared special member functions.\n  class ImplicitExceptionSpecification {\n    // Pointer to allow copying\n    Sema *Self;\n    // We order exception specifications thus:\n    // noexcept is the most restrictive, but is only used in C++11.\n    // throw() comes next.\n    // Then a throw(collected exceptions)\n    // Finally no specification, which is expressed as noexcept(false).\n    // throw(...) is used instead if any called function uses it.\n    ExceptionSpecificationType ComputedEST;\n    llvm::SmallPtrSet<CanQualType, 4> ExceptionsSeen;\n    SmallVector<QualType, 4> Exceptions;\n\n    void ClearExceptions() {\n      ExceptionsSeen.clear();\n      Exceptions.clear();\n    }\n\n  public:\n    explicit ImplicitExceptionSpecification(Sema &Self)\n      : Self(&Self), ComputedEST(EST_BasicNoexcept) {\n      if (!Self.getLangOpts().CPlusPlus11)\n        ComputedEST = EST_DynamicNone;\n    }\n\n    /// Get the computed exception specification type.\n    ExceptionSpecificationType getExceptionSpecType() const {\n      assert(!isComputedNoexcept(ComputedEST) &&\n             \"noexcept(expr) should not be a possible result\");\n      return ComputedEST;\n    }\n\n    /// The number of exceptions in the exception specification.\n    unsigned size() const { return Exceptions.size(); }\n\n    /// The set of exceptions in the exception specification.\n    const QualType *data() const { return Exceptions.data(); }\n\n    /// Integrate another called method into the collected data.\n    void CalledDecl(SourceLocation CallLoc, const CXXMethodDecl *Method);\n\n    /// Integrate an invoked expression into the collected data.\n    void CalledExpr(Expr *E) { CalledStmt(E); }\n\n    /// Integrate an invoked statement into the collected data.\n    void CalledStmt(Stmt *S);\n\n    /// Overwrite an EPI's exception specification with this\n    /// computed exception specification.\n    FunctionProtoType::ExceptionSpecInfo getExceptionSpec() const {\n      FunctionProtoType::ExceptionSpecInfo ESI;\n      ESI.Type = getExceptionSpecType();\n      if (ESI.Type == EST_Dynamic) {\n        ESI.Exceptions = Exceptions;\n      } else if (ESI.Type == EST_None) {\n        /// C++11 [except.spec]p14:\n        ///   The exception-specification is noexcept(false) if the set of\n        ///   potential exceptions of the special member function contains \"any\"\n        ESI.Type = EST_NoexceptFalse;\n        ESI.NoexceptExpr = Self->ActOnCXXBoolLiteral(SourceLocation(),\n                                                     tok::kw_false).get();\n      }\n      return ESI;\n    }\n  };\n\n  /// Evaluate the implicit exception specification for a defaulted\n  /// special member function.\n  void EvaluateImplicitExceptionSpec(SourceLocation Loc, FunctionDecl *FD);\n\n  /// Check the given noexcept-specifier, convert its expression, and compute\n  /// the appropriate ExceptionSpecificationType.\n  ExprResult ActOnNoexceptSpec(SourceLocation NoexceptLoc, Expr *NoexceptExpr,\n                               ExceptionSpecificationType &EST);\n\n  /// Check the given exception-specification and update the\n  /// exception specification information with the results.\n  void checkExceptionSpecification(bool IsTopLevel,\n                                   ExceptionSpecificationType EST,\n                                   ArrayRef<ParsedType> DynamicExceptions,\n                                   ArrayRef<SourceRange> DynamicExceptionRanges,\n                                   Expr *NoexceptExpr,\n                                   SmallVectorImpl<QualType> &Exceptions,\n                                   FunctionProtoType::ExceptionSpecInfo &ESI);\n\n  /// Determine if we're in a case where we need to (incorrectly) eagerly\n  /// parse an exception specification to work around a libstdc++ bug.\n  bool isLibstdcxxEagerExceptionSpecHack(const Declarator &D);\n\n  /// Add an exception-specification to the given member function\n  /// (or member function template). The exception-specification was parsed\n  /// after the method itself was declared.\n  void actOnDelayedExceptionSpecification(Decl *Method,\n         ExceptionSpecificationType EST,\n         SourceRange SpecificationRange,\n         ArrayRef<ParsedType> DynamicExceptions,\n         ArrayRef<SourceRange> DynamicExceptionRanges,\n         Expr *NoexceptExpr);\n\n  class InheritedConstructorInfo;\n\n  /// Determine if a special member function should have a deleted\n  /// definition when it is defaulted.\n  bool ShouldDeleteSpecialMember(CXXMethodDecl *MD, CXXSpecialMember CSM,\n                                 InheritedConstructorInfo *ICI = nullptr,\n                                 bool Diagnose = false);\n\n  /// Produce notes explaining why a defaulted function was defined as deleted.\n  void DiagnoseDeletedDefaultedFunction(FunctionDecl *FD);\n\n  /// Declare the implicit default constructor for the given class.\n  ///\n  /// \\param ClassDecl The class declaration into which the implicit\n  /// default constructor will be added.\n  ///\n  /// \\returns The implicitly-declared default constructor.\n  CXXConstructorDecl *DeclareImplicitDefaultConstructor(\n                                                     CXXRecordDecl *ClassDecl);\n\n  /// DefineImplicitDefaultConstructor - Checks for feasibility of\n  /// defining this constructor as the default constructor.\n  void DefineImplicitDefaultConstructor(SourceLocation CurrentLocation,\n                                        CXXConstructorDecl *Constructor);\n\n  /// Declare the implicit destructor for the given class.\n  ///\n  /// \\param ClassDecl The class declaration into which the implicit\n  /// destructor will be added.\n  ///\n  /// \\returns The implicitly-declared destructor.\n  CXXDestructorDecl *DeclareImplicitDestructor(CXXRecordDecl *ClassDecl);\n\n  /// DefineImplicitDestructor - Checks for feasibility of\n  /// defining this destructor as the default destructor.\n  void DefineImplicitDestructor(SourceLocation CurrentLocation,\n                                CXXDestructorDecl *Destructor);\n\n  /// Build an exception spec for destructors that don't have one.\n  ///\n  /// C++11 says that user-defined destructors with no exception spec get one\n  /// that looks as if the destructor was implicitly declared.\n  void AdjustDestructorExceptionSpec(CXXDestructorDecl *Destructor);\n\n  /// Define the specified inheriting constructor.\n  void DefineInheritingConstructor(SourceLocation UseLoc,\n                                   CXXConstructorDecl *Constructor);\n\n  /// Declare the implicit copy constructor for the given class.\n  ///\n  /// \\param ClassDecl The class declaration into which the implicit\n  /// copy constructor will be added.\n  ///\n  /// \\returns The implicitly-declared copy constructor.\n  CXXConstructorDecl *DeclareImplicitCopyConstructor(CXXRecordDecl *ClassDecl);\n\n  /// DefineImplicitCopyConstructor - Checks for feasibility of\n  /// defining this constructor as the copy constructor.\n  void DefineImplicitCopyConstructor(SourceLocation CurrentLocation,\n                                     CXXConstructorDecl *Constructor);\n\n  /// Declare the implicit move constructor for the given class.\n  ///\n  /// \\param ClassDecl The Class declaration into which the implicit\n  /// move constructor will be added.\n  ///\n  /// \\returns The implicitly-declared move constructor, or NULL if it wasn't\n  /// declared.\n  CXXConstructorDecl *DeclareImplicitMoveConstructor(CXXRecordDecl *ClassDecl);\n\n  /// DefineImplicitMoveConstructor - Checks for feasibility of\n  /// defining this constructor as the move constructor.\n  void DefineImplicitMoveConstructor(SourceLocation CurrentLocation,\n                                     CXXConstructorDecl *Constructor);\n\n  /// Declare the implicit copy assignment operator for the given class.\n  ///\n  /// \\param ClassDecl The class declaration into which the implicit\n  /// copy assignment operator will be added.\n  ///\n  /// \\returns The implicitly-declared copy assignment operator.\n  CXXMethodDecl *DeclareImplicitCopyAssignment(CXXRecordDecl *ClassDecl);\n\n  /// Defines an implicitly-declared copy assignment operator.\n  void DefineImplicitCopyAssignment(SourceLocation CurrentLocation,\n                                    CXXMethodDecl *MethodDecl);\n\n  /// Declare the implicit move assignment operator for the given class.\n  ///\n  /// \\param ClassDecl The Class declaration into which the implicit\n  /// move assignment operator will be added.\n  ///\n  /// \\returns The implicitly-declared move assignment operator, or NULL if it\n  /// wasn't declared.\n  CXXMethodDecl *DeclareImplicitMoveAssignment(CXXRecordDecl *ClassDecl);\n\n  /// Defines an implicitly-declared move assignment operator.\n  void DefineImplicitMoveAssignment(SourceLocation CurrentLocation,\n                                    CXXMethodDecl *MethodDecl);\n\n  /// Force the declaration of any implicitly-declared members of this\n  /// class.\n  void ForceDeclarationOfImplicitMembers(CXXRecordDecl *Class);\n\n  /// Check a completed declaration of an implicit special member.\n  void CheckImplicitSpecialMemberDeclaration(Scope *S, FunctionDecl *FD);\n\n  /// Determine whether the given function is an implicitly-deleted\n  /// special member function.\n  bool isImplicitlyDeleted(FunctionDecl *FD);\n\n  /// Check whether 'this' shows up in the type of a static member\n  /// function after the (naturally empty) cv-qualifier-seq would be.\n  ///\n  /// \\returns true if an error occurred.\n  bool checkThisInStaticMemberFunctionType(CXXMethodDecl *Method);\n\n  /// Whether this' shows up in the exception specification of a static\n  /// member function.\n  bool checkThisInStaticMemberFunctionExceptionSpec(CXXMethodDecl *Method);\n\n  /// Check whether 'this' shows up in the attributes of the given\n  /// static member function.\n  ///\n  /// \\returns true if an error occurred.\n  bool checkThisInStaticMemberFunctionAttributes(CXXMethodDecl *Method);\n\n  /// MaybeBindToTemporary - If the passed in expression has a record type with\n  /// a non-trivial destructor, this will return CXXBindTemporaryExpr. Otherwise\n  /// it simply returns the passed in expression.\n  ExprResult MaybeBindToTemporary(Expr *E);\n\n  /// Wrap the expression in a ConstantExpr if it is a potential immediate\n  /// invocation.\n  ExprResult CheckForImmediateInvocation(ExprResult E, FunctionDecl *Decl);\n\n  bool CompleteConstructorCall(CXXConstructorDecl *Constructor,\n                               QualType DeclInitType, MultiExprArg ArgsPtr,\n                               SourceLocation Loc,\n                               SmallVectorImpl<Expr *> &ConvertedArgs,\n                               bool AllowExplicit = false,\n                               bool IsListInitialization = false);\n\n  ParsedType getInheritingConstructorName(CXXScopeSpec &SS,\n                                          SourceLocation NameLoc,\n                                          IdentifierInfo &Name);\n\n  ParsedType getConstructorName(IdentifierInfo &II, SourceLocation NameLoc,\n                                Scope *S, CXXScopeSpec &SS,\n                                bool EnteringContext);\n  ParsedType getDestructorName(SourceLocation TildeLoc,\n                               IdentifierInfo &II, SourceLocation NameLoc,\n                               Scope *S, CXXScopeSpec &SS,\n                               ParsedType ObjectType,\n                               bool EnteringContext);\n\n  ParsedType getDestructorTypeForDecltype(const DeclSpec &DS,\n                                          ParsedType ObjectType);\n\n  // Checks that reinterpret casts don't have undefined behavior.\n  void CheckCompatibleReinterpretCast(QualType SrcType, QualType DestType,\n                                      bool IsDereference, SourceRange Range);\n\n  /// ActOnCXXNamedCast - Parse\n  /// {dynamic,static,reinterpret,const,addrspace}_cast's.\n  ExprResult ActOnCXXNamedCast(SourceLocation OpLoc,\n                               tok::TokenKind Kind,\n                               SourceLocation LAngleBracketLoc,\n                               Declarator &D,\n                               SourceLocation RAngleBracketLoc,\n                               SourceLocation LParenLoc,\n                               Expr *E,\n                               SourceLocation RParenLoc);\n\n  ExprResult BuildCXXNamedCast(SourceLocation OpLoc,\n                               tok::TokenKind Kind,\n                               TypeSourceInfo *Ty,\n                               Expr *E,\n                               SourceRange AngleBrackets,\n                               SourceRange Parens);\n\n  ExprResult ActOnBuiltinBitCastExpr(SourceLocation KWLoc, Declarator &Dcl,\n                                     ExprResult Operand,\n                                     SourceLocation RParenLoc);\n\n  ExprResult BuildBuiltinBitCastExpr(SourceLocation KWLoc, TypeSourceInfo *TSI,\n                                     Expr *Operand, SourceLocation RParenLoc);\n\n  ExprResult BuildCXXTypeId(QualType TypeInfoType,\n                            SourceLocation TypeidLoc,\n                            TypeSourceInfo *Operand,\n                            SourceLocation RParenLoc);\n  ExprResult BuildCXXTypeId(QualType TypeInfoType,\n                            SourceLocation TypeidLoc,\n                            Expr *Operand,\n                            SourceLocation RParenLoc);\n\n  /// ActOnCXXTypeid - Parse typeid( something ).\n  ExprResult ActOnCXXTypeid(SourceLocation OpLoc,\n                            SourceLocation LParenLoc, bool isType,\n                            void *TyOrExpr,\n                            SourceLocation RParenLoc);\n\n  ExprResult BuildCXXUuidof(QualType TypeInfoType,\n                            SourceLocation TypeidLoc,\n                            TypeSourceInfo *Operand,\n                            SourceLocation RParenLoc);\n  ExprResult BuildCXXUuidof(QualType TypeInfoType,\n                            SourceLocation TypeidLoc,\n                            Expr *Operand,\n                            SourceLocation RParenLoc);\n\n  /// ActOnCXXUuidof - Parse __uuidof( something ).\n  ExprResult ActOnCXXUuidof(SourceLocation OpLoc,\n                            SourceLocation LParenLoc, bool isType,\n                            void *TyOrExpr,\n                            SourceLocation RParenLoc);\n\n  /// Handle a C++1z fold-expression: ( expr op ... op expr ).\n  ExprResult ActOnCXXFoldExpr(Scope *S, SourceLocation LParenLoc, Expr *LHS,\n                              tok::TokenKind Operator,\n                              SourceLocation EllipsisLoc, Expr *RHS,\n                              SourceLocation RParenLoc);\n  ExprResult BuildCXXFoldExpr(UnresolvedLookupExpr *Callee,\n                              SourceLocation LParenLoc, Expr *LHS,\n                              BinaryOperatorKind Operator,\n                              SourceLocation EllipsisLoc, Expr *RHS,\n                              SourceLocation RParenLoc,\n                              Optional<unsigned> NumExpansions);\n  ExprResult BuildEmptyCXXFoldExpr(SourceLocation EllipsisLoc,\n                                   BinaryOperatorKind Operator);\n\n  //// ActOnCXXThis -  Parse 'this' pointer.\n  ExprResult ActOnCXXThis(SourceLocation loc);\n\n  /// Build a CXXThisExpr and mark it referenced in the current context.\n  Expr *BuildCXXThisExpr(SourceLocation Loc, QualType Type, bool IsImplicit);\n  void MarkThisReferenced(CXXThisExpr *This);\n\n  /// Try to retrieve the type of the 'this' pointer.\n  ///\n  /// \\returns The type of 'this', if possible. Otherwise, returns a NULL type.\n  QualType getCurrentThisType();\n\n  /// When non-NULL, the C++ 'this' expression is allowed despite the\n  /// current context not being a non-static member function. In such cases,\n  /// this provides the type used for 'this'.\n  QualType CXXThisTypeOverride;\n\n  /// RAII object used to temporarily allow the C++ 'this' expression\n  /// to be used, with the given qualifiers on the current class type.\n  class CXXThisScopeRAII {\n    Sema &S;\n    QualType OldCXXThisTypeOverride;\n    bool Enabled;\n\n  public:\n    /// Introduce a new scope where 'this' may be allowed (when enabled),\n    /// using the given declaration (which is either a class template or a\n    /// class) along with the given qualifiers.\n    /// along with the qualifiers placed on '*this'.\n    CXXThisScopeRAII(Sema &S, Decl *ContextDecl, Qualifiers CXXThisTypeQuals,\n                     bool Enabled = true);\n\n    ~CXXThisScopeRAII();\n  };\n\n  /// Make sure the value of 'this' is actually available in the current\n  /// context, if it is a potentially evaluated context.\n  ///\n  /// \\param Loc The location at which the capture of 'this' occurs.\n  ///\n  /// \\param Explicit Whether 'this' is explicitly captured in a lambda\n  /// capture list.\n  ///\n  /// \\param FunctionScopeIndexToStopAt If non-null, it points to the index\n  /// of the FunctionScopeInfo stack beyond which we do not attempt to capture.\n  /// This is useful when enclosing lambdas must speculatively capture\n  /// 'this' that may or may not be used in certain specializations of\n  /// a nested generic lambda (depending on whether the name resolves to\n  /// a non-static member function or a static function).\n  /// \\return returns 'true' if failed, 'false' if success.\n  bool CheckCXXThisCapture(SourceLocation Loc, bool Explicit = false,\n      bool BuildAndDiagnose = true,\n      const unsigned *const FunctionScopeIndexToStopAt = nullptr,\n      bool ByCopy = false);\n\n  /// Determine whether the given type is the type of *this that is used\n  /// outside of the body of a member function for a type that is currently\n  /// being defined.\n  bool isThisOutsideMemberFunctionBody(QualType BaseType);\n\n  /// ActOnCXXBoolLiteral - Parse {true,false} literals.\n  ExprResult ActOnCXXBoolLiteral(SourceLocation OpLoc, tok::TokenKind Kind);\n\n\n  /// ActOnObjCBoolLiteral - Parse {__objc_yes,__objc_no} literals.\n  ExprResult ActOnObjCBoolLiteral(SourceLocation OpLoc, tok::TokenKind Kind);\n\n  ExprResult\n  ActOnObjCAvailabilityCheckExpr(llvm::ArrayRef<AvailabilitySpec> AvailSpecs,\n                                 SourceLocation AtLoc, SourceLocation RParen);\n\n  /// ActOnCXXNullPtrLiteral - Parse 'nullptr'.\n  ExprResult ActOnCXXNullPtrLiteral(SourceLocation Loc);\n\n  //// ActOnCXXThrow -  Parse throw expressions.\n  ExprResult ActOnCXXThrow(Scope *S, SourceLocation OpLoc, Expr *expr);\n  ExprResult BuildCXXThrow(SourceLocation OpLoc, Expr *Ex,\n                           bool IsThrownVarInScope);\n  bool CheckCXXThrowOperand(SourceLocation ThrowLoc, QualType ThrowTy, Expr *E);\n\n  /// ActOnCXXTypeConstructExpr - Parse construction of a specified type.\n  /// Can be interpreted either as function-style casting (\"int(x)\")\n  /// or class type construction (\"ClassType(x,y,z)\")\n  /// or creation of a value-initialized type (\"int()\").\n  ExprResult ActOnCXXTypeConstructExpr(ParsedType TypeRep,\n                                       SourceLocation LParenOrBraceLoc,\n                                       MultiExprArg Exprs,\n                                       SourceLocation RParenOrBraceLoc,\n                                       bool ListInitialization);\n\n  ExprResult BuildCXXTypeConstructExpr(TypeSourceInfo *Type,\n                                       SourceLocation LParenLoc,\n                                       MultiExprArg Exprs,\n                                       SourceLocation RParenLoc,\n                                       bool ListInitialization);\n\n  /// ActOnCXXNew - Parsed a C++ 'new' expression.\n  ExprResult ActOnCXXNew(SourceLocation StartLoc, bool UseGlobal,\n                         SourceLocation PlacementLParen,\n                         MultiExprArg PlacementArgs,\n                         SourceLocation PlacementRParen,\n                         SourceRange TypeIdParens, Declarator &D,\n                         Expr *Initializer);\n  ExprResult BuildCXXNew(SourceRange Range, bool UseGlobal,\n                         SourceLocation PlacementLParen,\n                         MultiExprArg PlacementArgs,\n                         SourceLocation PlacementRParen,\n                         SourceRange TypeIdParens,\n                         QualType AllocType,\n                         TypeSourceInfo *AllocTypeInfo,\n                         Optional<Expr *> ArraySize,\n                         SourceRange DirectInitRange,\n                         Expr *Initializer);\n\n  /// Determine whether \\p FD is an aligned allocation or deallocation\n  /// function that is unavailable.\n  bool isUnavailableAlignedAllocationFunction(const FunctionDecl &FD) const;\n\n  /// Produce diagnostics if \\p FD is an aligned allocation or deallocation\n  /// function that is unavailable.\n  void diagnoseUnavailableAlignedAllocation(const FunctionDecl &FD,\n                                            SourceLocation Loc);\n\n  bool CheckAllocatedType(QualType AllocType, SourceLocation Loc,\n                          SourceRange R);\n\n  /// The scope in which to find allocation functions.\n  enum AllocationFunctionScope {\n    /// Only look for allocation functions in the global scope.\n    AFS_Global,\n    /// Only look for allocation functions in the scope of the\n    /// allocated class.\n    AFS_Class,\n    /// Look for allocation functions in both the global scope\n    /// and in the scope of the allocated class.\n    AFS_Both\n  };\n\n  /// Finds the overloads of operator new and delete that are appropriate\n  /// for the allocation.\n  bool FindAllocationFunctions(SourceLocation StartLoc, SourceRange Range,\n                               AllocationFunctionScope NewScope,\n                               AllocationFunctionScope DeleteScope,\n                               QualType AllocType, bool IsArray,\n                               bool &PassAlignment, MultiExprArg PlaceArgs,\n                               FunctionDecl *&OperatorNew,\n                               FunctionDecl *&OperatorDelete,\n                               bool Diagnose = true);\n  void DeclareGlobalNewDelete();\n  void DeclareGlobalAllocationFunction(DeclarationName Name, QualType Return,\n                                       ArrayRef<QualType> Params);\n\n  bool FindDeallocationFunction(SourceLocation StartLoc, CXXRecordDecl *RD,\n                                DeclarationName Name, FunctionDecl* &Operator,\n                                bool Diagnose = true);\n  FunctionDecl *FindUsualDeallocationFunction(SourceLocation StartLoc,\n                                              bool CanProvideSize,\n                                              bool Overaligned,\n                                              DeclarationName Name);\n  FunctionDecl *FindDeallocationFunctionForDestructor(SourceLocation StartLoc,\n                                                      CXXRecordDecl *RD);\n\n  /// ActOnCXXDelete - Parsed a C++ 'delete' expression\n  ExprResult ActOnCXXDelete(SourceLocation StartLoc,\n                            bool UseGlobal, bool ArrayForm,\n                            Expr *Operand);\n  void CheckVirtualDtorCall(CXXDestructorDecl *dtor, SourceLocation Loc,\n                            bool IsDelete, bool CallCanBeVirtual,\n                            bool WarnOnNonAbstractTypes,\n                            SourceLocation DtorLoc);\n\n  ExprResult ActOnNoexceptExpr(SourceLocation KeyLoc, SourceLocation LParen,\n                               Expr *Operand, SourceLocation RParen);\n  ExprResult BuildCXXNoexceptExpr(SourceLocation KeyLoc, Expr *Operand,\n                                  SourceLocation RParen);\n\n  /// Parsed one of the type trait support pseudo-functions.\n  ExprResult ActOnTypeTrait(TypeTrait Kind, SourceLocation KWLoc,\n                            ArrayRef<ParsedType> Args,\n                            SourceLocation RParenLoc);\n  ExprResult BuildTypeTrait(TypeTrait Kind, SourceLocation KWLoc,\n                            ArrayRef<TypeSourceInfo *> Args,\n                            SourceLocation RParenLoc);\n\n  /// ActOnArrayTypeTrait - Parsed one of the binary type trait support\n  /// pseudo-functions.\n  ExprResult ActOnArrayTypeTrait(ArrayTypeTrait ATT,\n                                 SourceLocation KWLoc,\n                                 ParsedType LhsTy,\n                                 Expr *DimExpr,\n                                 SourceLocation RParen);\n\n  ExprResult BuildArrayTypeTrait(ArrayTypeTrait ATT,\n                                 SourceLocation KWLoc,\n                                 TypeSourceInfo *TSInfo,\n                                 Expr *DimExpr,\n                                 SourceLocation RParen);\n\n  /// ActOnExpressionTrait - Parsed one of the unary type trait support\n  /// pseudo-functions.\n  ExprResult ActOnExpressionTrait(ExpressionTrait OET,\n                                  SourceLocation KWLoc,\n                                  Expr *Queried,\n                                  SourceLocation RParen);\n\n  ExprResult BuildExpressionTrait(ExpressionTrait OET,\n                                  SourceLocation KWLoc,\n                                  Expr *Queried,\n                                  SourceLocation RParen);\n\n  ExprResult ActOnStartCXXMemberReference(Scope *S,\n                                          Expr *Base,\n                                          SourceLocation OpLoc,\n                                          tok::TokenKind OpKind,\n                                          ParsedType &ObjectType,\n                                          bool &MayBePseudoDestructor);\n\n  ExprResult BuildPseudoDestructorExpr(Expr *Base,\n                                       SourceLocation OpLoc,\n                                       tok::TokenKind OpKind,\n                                       const CXXScopeSpec &SS,\n                                       TypeSourceInfo *ScopeType,\n                                       SourceLocation CCLoc,\n                                       SourceLocation TildeLoc,\n                                     PseudoDestructorTypeStorage DestroyedType);\n\n  ExprResult ActOnPseudoDestructorExpr(Scope *S, Expr *Base,\n                                       SourceLocation OpLoc,\n                                       tok::TokenKind OpKind,\n                                       CXXScopeSpec &SS,\n                                       UnqualifiedId &FirstTypeName,\n                                       SourceLocation CCLoc,\n                                       SourceLocation TildeLoc,\n                                       UnqualifiedId &SecondTypeName);\n\n  ExprResult ActOnPseudoDestructorExpr(Scope *S, Expr *Base,\n                                       SourceLocation OpLoc,\n                                       tok::TokenKind OpKind,\n                                       SourceLocation TildeLoc,\n                                       const DeclSpec& DS);\n\n  /// MaybeCreateExprWithCleanups - If the current full-expression\n  /// requires any cleanups, surround it with a ExprWithCleanups node.\n  /// Otherwise, just returns the passed-in expression.\n  Expr *MaybeCreateExprWithCleanups(Expr *SubExpr);\n  Stmt *MaybeCreateStmtWithCleanups(Stmt *SubStmt);\n  ExprResult MaybeCreateExprWithCleanups(ExprResult SubExpr);\n\n  MaterializeTemporaryExpr *\n  CreateMaterializeTemporaryExpr(QualType T, Expr *Temporary,\n                                 bool BoundToLvalueReference);\n\n  ExprResult ActOnFinishFullExpr(Expr *Expr, bool DiscardedValue) {\n    return ActOnFinishFullExpr(\n        Expr, Expr ? Expr->getExprLoc() : SourceLocation(), DiscardedValue);\n  }\n  ExprResult ActOnFinishFullExpr(Expr *Expr, SourceLocation CC,\n                                 bool DiscardedValue, bool IsConstexpr = false);\n  StmtResult ActOnFinishFullStmt(Stmt *Stmt);\n\n  // Marks SS invalid if it represents an incomplete type.\n  bool RequireCompleteDeclContext(CXXScopeSpec &SS, DeclContext *DC);\n\n  DeclContext *computeDeclContext(QualType T);\n  DeclContext *computeDeclContext(const CXXScopeSpec &SS,\n                                  bool EnteringContext = false);\n  bool isDependentScopeSpecifier(const CXXScopeSpec &SS);\n  CXXRecordDecl *getCurrentInstantiationOf(NestedNameSpecifier *NNS);\n\n  /// The parser has parsed a global nested-name-specifier '::'.\n  ///\n  /// \\param CCLoc The location of the '::'.\n  ///\n  /// \\param SS The nested-name-specifier, which will be updated in-place\n  /// to reflect the parsed nested-name-specifier.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool ActOnCXXGlobalScopeSpecifier(SourceLocation CCLoc, CXXScopeSpec &SS);\n\n  /// The parser has parsed a '__super' nested-name-specifier.\n  ///\n  /// \\param SuperLoc The location of the '__super' keyword.\n  ///\n  /// \\param ColonColonLoc The location of the '::'.\n  ///\n  /// \\param SS The nested-name-specifier, which will be updated in-place\n  /// to reflect the parsed nested-name-specifier.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool ActOnSuperScopeSpecifier(SourceLocation SuperLoc,\n                                SourceLocation ColonColonLoc, CXXScopeSpec &SS);\n\n  bool isAcceptableNestedNameSpecifier(const NamedDecl *SD,\n                                       bool *CanCorrect = nullptr);\n  NamedDecl *FindFirstQualifierInScope(Scope *S, NestedNameSpecifier *NNS);\n\n  /// Keeps information about an identifier in a nested-name-spec.\n  ///\n  struct NestedNameSpecInfo {\n    /// The type of the object, if we're parsing nested-name-specifier in\n    /// a member access expression.\n    ParsedType ObjectType;\n\n    /// The identifier preceding the '::'.\n    IdentifierInfo *Identifier;\n\n    /// The location of the identifier.\n    SourceLocation IdentifierLoc;\n\n    /// The location of the '::'.\n    SourceLocation CCLoc;\n\n    /// Creates info object for the most typical case.\n    NestedNameSpecInfo(IdentifierInfo *II, SourceLocation IdLoc,\n             SourceLocation ColonColonLoc, ParsedType ObjectType = ParsedType())\n      : ObjectType(ObjectType), Identifier(II), IdentifierLoc(IdLoc),\n        CCLoc(ColonColonLoc) {\n    }\n\n    NestedNameSpecInfo(IdentifierInfo *II, SourceLocation IdLoc,\n                       SourceLocation ColonColonLoc, QualType ObjectType)\n      : ObjectType(ParsedType::make(ObjectType)), Identifier(II),\n        IdentifierLoc(IdLoc), CCLoc(ColonColonLoc) {\n    }\n  };\n\n  bool isNonTypeNestedNameSpecifier(Scope *S, CXXScopeSpec &SS,\n                                    NestedNameSpecInfo &IdInfo);\n\n  bool BuildCXXNestedNameSpecifier(Scope *S,\n                                   NestedNameSpecInfo &IdInfo,\n                                   bool EnteringContext,\n                                   CXXScopeSpec &SS,\n                                   NamedDecl *ScopeLookupResult,\n                                   bool ErrorRecoveryLookup,\n                                   bool *IsCorrectedToColon = nullptr,\n                                   bool OnlyNamespace = false);\n\n  /// The parser has parsed a nested-name-specifier 'identifier::'.\n  ///\n  /// \\param S The scope in which this nested-name-specifier occurs.\n  ///\n  /// \\param IdInfo Parser information about an identifier in the\n  /// nested-name-spec.\n  ///\n  /// \\param EnteringContext Whether we're entering the context nominated by\n  /// this nested-name-specifier.\n  ///\n  /// \\param SS The nested-name-specifier, which is both an input\n  /// parameter (the nested-name-specifier before this type) and an\n  /// output parameter (containing the full nested-name-specifier,\n  /// including this new type).\n  ///\n  /// \\param ErrorRecoveryLookup If true, then this method is called to improve\n  /// error recovery. In this case do not emit error message.\n  ///\n  /// \\param IsCorrectedToColon If not null, suggestions to replace '::' -> ':'\n  /// are allowed.  The bool value pointed by this parameter is set to 'true'\n  /// if the identifier is treated as if it was followed by ':', not '::'.\n  ///\n  /// \\param OnlyNamespace If true, only considers namespaces in lookup.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool ActOnCXXNestedNameSpecifier(Scope *S,\n                                   NestedNameSpecInfo &IdInfo,\n                                   bool EnteringContext,\n                                   CXXScopeSpec &SS,\n                                   bool ErrorRecoveryLookup = false,\n                                   bool *IsCorrectedToColon = nullptr,\n                                   bool OnlyNamespace = false);\n\n  ExprResult ActOnDecltypeExpression(Expr *E);\n\n  bool ActOnCXXNestedNameSpecifierDecltype(CXXScopeSpec &SS,\n                                           const DeclSpec &DS,\n                                           SourceLocation ColonColonLoc);\n\n  bool IsInvalidUnlessNestedName(Scope *S, CXXScopeSpec &SS,\n                                 NestedNameSpecInfo &IdInfo,\n                                 bool EnteringContext);\n\n  /// The parser has parsed a nested-name-specifier\n  /// 'template[opt] template-name < template-args >::'.\n  ///\n  /// \\param S The scope in which this nested-name-specifier occurs.\n  ///\n  /// \\param SS The nested-name-specifier, which is both an input\n  /// parameter (the nested-name-specifier before this type) and an\n  /// output parameter (containing the full nested-name-specifier,\n  /// including this new type).\n  ///\n  /// \\param TemplateKWLoc the location of the 'template' keyword, if any.\n  /// \\param TemplateName the template name.\n  /// \\param TemplateNameLoc The location of the template name.\n  /// \\param LAngleLoc The location of the opening angle bracket  ('<').\n  /// \\param TemplateArgs The template arguments.\n  /// \\param RAngleLoc The location of the closing angle bracket  ('>').\n  /// \\param CCLoc The location of the '::'.\n  ///\n  /// \\param EnteringContext Whether we're entering the context of the\n  /// nested-name-specifier.\n  ///\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool ActOnCXXNestedNameSpecifier(Scope *S,\n                                   CXXScopeSpec &SS,\n                                   SourceLocation TemplateKWLoc,\n                                   TemplateTy TemplateName,\n                                   SourceLocation TemplateNameLoc,\n                                   SourceLocation LAngleLoc,\n                                   ASTTemplateArgsPtr TemplateArgs,\n                                   SourceLocation RAngleLoc,\n                                   SourceLocation CCLoc,\n                                   bool EnteringContext);\n\n  /// Given a C++ nested-name-specifier, produce an annotation value\n  /// that the parser can use later to reconstruct the given\n  /// nested-name-specifier.\n  ///\n  /// \\param SS A nested-name-specifier.\n  ///\n  /// \\returns A pointer containing all of the information in the\n  /// nested-name-specifier \\p SS.\n  void *SaveNestedNameSpecifierAnnotation(CXXScopeSpec &SS);\n\n  /// Given an annotation pointer for a nested-name-specifier, restore\n  /// the nested-name-specifier structure.\n  ///\n  /// \\param Annotation The annotation pointer, produced by\n  /// \\c SaveNestedNameSpecifierAnnotation().\n  ///\n  /// \\param AnnotationRange The source range corresponding to the annotation.\n  ///\n  /// \\param SS The nested-name-specifier that will be updated with the contents\n  /// of the annotation pointer.\n  void RestoreNestedNameSpecifierAnnotation(void *Annotation,\n                                            SourceRange AnnotationRange,\n                                            CXXScopeSpec &SS);\n\n  bool ShouldEnterDeclaratorScope(Scope *S, const CXXScopeSpec &SS);\n\n  /// ActOnCXXEnterDeclaratorScope - Called when a C++ scope specifier (global\n  /// scope or nested-name-specifier) is parsed, part of a declarator-id.\n  /// After this method is called, according to [C++ 3.4.3p3], names should be\n  /// looked up in the declarator-id's scope, until the declarator is parsed and\n  /// ActOnCXXExitDeclaratorScope is called.\n  /// The 'SS' should be a non-empty valid CXXScopeSpec.\n  bool ActOnCXXEnterDeclaratorScope(Scope *S, CXXScopeSpec &SS);\n\n  /// ActOnCXXExitDeclaratorScope - Called when a declarator that previously\n  /// invoked ActOnCXXEnterDeclaratorScope(), is finished. 'SS' is the same\n  /// CXXScopeSpec that was passed to ActOnCXXEnterDeclaratorScope as well.\n  /// Used to indicate that names should revert to being looked up in the\n  /// defining scope.\n  void ActOnCXXExitDeclaratorScope(Scope *S, const CXXScopeSpec &SS);\n\n  /// ActOnCXXEnterDeclInitializer - Invoked when we are about to parse an\n  /// initializer for the declaration 'Dcl'.\n  /// After this method is called, according to [C++ 3.4.1p13], if 'Dcl' is a\n  /// static data member of class X, names should be looked up in the scope of\n  /// class X.\n  void ActOnCXXEnterDeclInitializer(Scope *S, Decl *Dcl);\n\n  /// ActOnCXXExitDeclInitializer - Invoked after we are finished parsing an\n  /// initializer for the declaration 'Dcl'.\n  void ActOnCXXExitDeclInitializer(Scope *S, Decl *Dcl);\n\n  /// Create a new lambda closure type.\n  CXXRecordDecl *createLambdaClosureType(SourceRange IntroducerRange,\n                                         TypeSourceInfo *Info,\n                                         bool KnownDependent,\n                                         LambdaCaptureDefault CaptureDefault);\n\n  /// Start the definition of a lambda expression.\n  CXXMethodDecl *startLambdaDefinition(CXXRecordDecl *Class,\n                                       SourceRange IntroducerRange,\n                                       TypeSourceInfo *MethodType,\n                                       SourceLocation EndLoc,\n                                       ArrayRef<ParmVarDecl *> Params,\n                                       ConstexprSpecKind ConstexprKind,\n                                       Expr *TrailingRequiresClause);\n\n  /// Number lambda for linkage purposes if necessary.\n  void handleLambdaNumbering(\n      CXXRecordDecl *Class, CXXMethodDecl *Method,\n      Optional<std::tuple<bool, unsigned, unsigned, Decl *>> Mangling = None);\n\n  /// Endow the lambda scope info with the relevant properties.\n  void buildLambdaScope(sema::LambdaScopeInfo *LSI,\n                        CXXMethodDecl *CallOperator,\n                        SourceRange IntroducerRange,\n                        LambdaCaptureDefault CaptureDefault,\n                        SourceLocation CaptureDefaultLoc,\n                        bool ExplicitParams,\n                        bool ExplicitResultType,\n                        bool Mutable);\n\n  /// Perform initialization analysis of the init-capture and perform\n  /// any implicit conversions such as an lvalue-to-rvalue conversion if\n  /// not being used to initialize a reference.\n  ParsedType actOnLambdaInitCaptureInitialization(\n      SourceLocation Loc, bool ByRef, SourceLocation EllipsisLoc,\n      IdentifierInfo *Id, LambdaCaptureInitKind InitKind, Expr *&Init) {\n    return ParsedType::make(buildLambdaInitCaptureInitialization(\n        Loc, ByRef, EllipsisLoc, None, Id,\n        InitKind != LambdaCaptureInitKind::CopyInit, Init));\n  }\n  QualType buildLambdaInitCaptureInitialization(\n      SourceLocation Loc, bool ByRef, SourceLocation EllipsisLoc,\n      Optional<unsigned> NumExpansions, IdentifierInfo *Id, bool DirectInit,\n      Expr *&Init);\n\n  /// Create a dummy variable within the declcontext of the lambda's\n  ///  call operator, for name lookup purposes for a lambda init capture.\n  ///\n  ///  CodeGen handles emission of lambda captures, ignoring these dummy\n  ///  variables appropriately.\n  VarDecl *createLambdaInitCaptureVarDecl(SourceLocation Loc,\n                                          QualType InitCaptureType,\n                                          SourceLocation EllipsisLoc,\n                                          IdentifierInfo *Id,\n                                          unsigned InitStyle, Expr *Init);\n\n  /// Add an init-capture to a lambda scope.\n  void addInitCapture(sema::LambdaScopeInfo *LSI, VarDecl *Var);\n\n  /// Note that we have finished the explicit captures for the\n  /// given lambda.\n  void finishLambdaExplicitCaptures(sema::LambdaScopeInfo *LSI);\n\n  /// \\brief This is called after parsing the explicit template parameter list\n  /// on a lambda (if it exists) in C++2a.\n  void ActOnLambdaExplicitTemplateParameterList(SourceLocation LAngleLoc,\n                                                ArrayRef<NamedDecl *> TParams,\n                                                SourceLocation RAngleLoc,\n                                                ExprResult RequiresClause);\n\n  /// Introduce the lambda parameters into scope.\n  void addLambdaParameters(\n      ArrayRef<LambdaIntroducer::LambdaCapture> Captures,\n      CXXMethodDecl *CallOperator, Scope *CurScope);\n\n  /// Deduce a block or lambda's return type based on the return\n  /// statements present in the body.\n  void deduceClosureReturnType(sema::CapturingScopeInfo &CSI);\n\n  /// ActOnStartOfLambdaDefinition - This is called just before we start\n  /// parsing the body of a lambda; it analyzes the explicit captures and\n  /// arguments, and sets up various data-structures for the body of the\n  /// lambda.\n  void ActOnStartOfLambdaDefinition(LambdaIntroducer &Intro,\n                                    Declarator &ParamInfo, Scope *CurScope);\n\n  /// ActOnLambdaError - If there is an error parsing a lambda, this callback\n  /// is invoked to pop the information about the lambda.\n  void ActOnLambdaError(SourceLocation StartLoc, Scope *CurScope,\n                        bool IsInstantiation = false);\n\n  /// ActOnLambdaExpr - This is called when the body of a lambda expression\n  /// was successfully completed.\n  ExprResult ActOnLambdaExpr(SourceLocation StartLoc, Stmt *Body,\n                             Scope *CurScope);\n\n  /// Does copying/destroying the captured variable have side effects?\n  bool CaptureHasSideEffects(const sema::Capture &From);\n\n  /// Diagnose if an explicit lambda capture is unused. Returns true if a\n  /// diagnostic is emitted.\n  bool DiagnoseUnusedLambdaCapture(SourceRange CaptureRange,\n                                   const sema::Capture &From);\n\n  /// Build a FieldDecl suitable to hold the given capture.\n  FieldDecl *BuildCaptureField(RecordDecl *RD, const sema::Capture &Capture);\n\n  /// Initialize the given capture with a suitable expression.\n  ExprResult BuildCaptureInit(const sema::Capture &Capture,\n                              SourceLocation ImplicitCaptureLoc,\n                              bool IsOpenMPMapping = false);\n\n  /// Complete a lambda-expression having processed and attached the\n  /// lambda body.\n  ExprResult BuildLambdaExpr(SourceLocation StartLoc, SourceLocation EndLoc,\n                             sema::LambdaScopeInfo *LSI);\n\n  /// Get the return type to use for a lambda's conversion function(s) to\n  /// function pointer type, given the type of the call operator.\n  QualType\n  getLambdaConversionFunctionResultType(const FunctionProtoType *CallOpType,\n                                        CallingConv CC);\n\n  /// Define the \"body\" of the conversion from a lambda object to a\n  /// function pointer.\n  ///\n  /// This routine doesn't actually define a sensible body; rather, it fills\n  /// in the initialization expression needed to copy the lambda object into\n  /// the block, and IR generation actually generates the real body of the\n  /// block pointer conversion.\n  void DefineImplicitLambdaToFunctionPointerConversion(\n         SourceLocation CurrentLoc, CXXConversionDecl *Conv);\n\n  /// Define the \"body\" of the conversion from a lambda object to a\n  /// block pointer.\n  ///\n  /// This routine doesn't actually define a sensible body; rather, it fills\n  /// in the initialization expression needed to copy the lambda object into\n  /// the block, and IR generation actually generates the real body of the\n  /// block pointer conversion.\n  void DefineImplicitLambdaToBlockPointerConversion(SourceLocation CurrentLoc,\n                                                    CXXConversionDecl *Conv);\n\n  ExprResult BuildBlockForLambdaConversion(SourceLocation CurrentLocation,\n                                           SourceLocation ConvLocation,\n                                           CXXConversionDecl *Conv,\n                                           Expr *Src);\n\n  /// Check whether the given expression is a valid constraint expression.\n  /// A diagnostic is emitted if it is not, false is returned, and\n  /// PossibleNonPrimary will be set to true if the failure might be due to a\n  /// non-primary expression being used as an atomic constraint.\n  bool CheckConstraintExpression(const Expr *CE, Token NextToken = Token(),\n                                 bool *PossibleNonPrimary = nullptr,\n                                 bool IsTrailingRequiresClause = false);\n\nprivate:\n  /// Caches pairs of template-like decls whose associated constraints were\n  /// checked for subsumption and whether or not the first's constraints did in\n  /// fact subsume the second's.\n  llvm::DenseMap<std::pair<NamedDecl *, NamedDecl *>, bool> SubsumptionCache;\n  /// Caches the normalized associated constraints of declarations (concepts or\n  /// constrained declarations). If an error occurred while normalizing the\n  /// associated constraints of the template or concept, nullptr will be cached\n  /// here.\n  llvm::DenseMap<NamedDecl *, NormalizedConstraint *>\n      NormalizationCache;\n\n  llvm::ContextualFoldingSet<ConstraintSatisfaction, const ASTContext &>\n      SatisfactionCache;\n\npublic:\n  const NormalizedConstraint *\n  getNormalizedAssociatedConstraints(\n      NamedDecl *ConstrainedDecl, ArrayRef<const Expr *> AssociatedConstraints);\n\n  /// \\brief Check whether the given declaration's associated constraints are\n  /// at least as constrained than another declaration's according to the\n  /// partial ordering of constraints.\n  ///\n  /// \\param Result If no error occurred, receives the result of true if D1 is\n  /// at least constrained than D2, and false otherwise.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool IsAtLeastAsConstrained(NamedDecl *D1, ArrayRef<const Expr *> AC1,\n                              NamedDecl *D2, ArrayRef<const Expr *> AC2,\n                              bool &Result);\n\n  /// If D1 was not at least as constrained as D2, but would've been if a pair\n  /// of atomic constraints involved had been declared in a concept and not\n  /// repeated in two separate places in code.\n  /// \\returns true if such a diagnostic was emitted, false otherwise.\n  bool MaybeEmitAmbiguousAtomicConstraintsDiagnostic(NamedDecl *D1,\n      ArrayRef<const Expr *> AC1, NamedDecl *D2, ArrayRef<const Expr *> AC2);\n\n  /// \\brief Check whether the given list of constraint expressions are\n  /// satisfied (as if in a 'conjunction') given template arguments.\n  /// \\param Template the template-like entity that triggered the constraints\n  /// check (either a concept or a constrained entity).\n  /// \\param ConstraintExprs a list of constraint expressions, treated as if\n  /// they were 'AND'ed together.\n  /// \\param TemplateArgs the list of template arguments to substitute into the\n  /// constraint expression.\n  /// \\param TemplateIDRange The source range of the template id that\n  /// caused the constraints check.\n  /// \\param Satisfaction if true is returned, will contain details of the\n  /// satisfaction, with enough information to diagnose an unsatisfied\n  /// expression.\n  /// \\returns true if an error occurred and satisfaction could not be checked,\n  /// false otherwise.\n  bool CheckConstraintSatisfaction(\n      const NamedDecl *Template, ArrayRef<const Expr *> ConstraintExprs,\n      ArrayRef<TemplateArgument> TemplateArgs,\n      SourceRange TemplateIDRange, ConstraintSatisfaction &Satisfaction);\n\n  /// \\brief Check whether the given non-dependent constraint expression is\n  /// satisfied. Returns false and updates Satisfaction with the satisfaction\n  /// verdict if successful, emits a diagnostic and returns true if an error\n  /// occured and satisfaction could not be determined.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool CheckConstraintSatisfaction(const Expr *ConstraintExpr,\n                                   ConstraintSatisfaction &Satisfaction);\n\n  /// Check whether the given function decl's trailing requires clause is\n  /// satisfied, if any. Returns false and updates Satisfaction with the\n  /// satisfaction verdict if successful, emits a diagnostic and returns true if\n  /// an error occured and satisfaction could not be determined.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool CheckFunctionConstraints(const FunctionDecl *FD,\n                                ConstraintSatisfaction &Satisfaction,\n                                SourceLocation UsageLoc = SourceLocation());\n\n\n  /// \\brief Ensure that the given template arguments satisfy the constraints\n  /// associated with the given template, emitting a diagnostic if they do not.\n  ///\n  /// \\param Template The template to which the template arguments are being\n  /// provided.\n  ///\n  /// \\param TemplateArgs The converted, canonicalized template arguments.\n  ///\n  /// \\param TemplateIDRange The source range of the template id that\n  /// caused the constraints check.\n  ///\n  /// \\returns true if the constrains are not satisfied or could not be checked\n  /// for satisfaction, false if the constraints are satisfied.\n  bool EnsureTemplateArgumentListConstraints(TemplateDecl *Template,\n                                       ArrayRef<TemplateArgument> TemplateArgs,\n                                             SourceRange TemplateIDRange);\n\n  /// \\brief Emit diagnostics explaining why a constraint expression was deemed\n  /// unsatisfied.\n  /// \\param First whether this is the first time an unsatisfied constraint is\n  /// diagnosed for this error.\n  void\n  DiagnoseUnsatisfiedConstraint(const ConstraintSatisfaction &Satisfaction,\n                                bool First = true);\n\n  /// \\brief Emit diagnostics explaining why a constraint expression was deemed\n  /// unsatisfied.\n  void\n  DiagnoseUnsatisfiedConstraint(const ASTConstraintSatisfaction &Satisfaction,\n                                bool First = true);\n\n  // ParseObjCStringLiteral - Parse Objective-C string literals.\n  ExprResult ParseObjCStringLiteral(SourceLocation *AtLocs,\n                                    ArrayRef<Expr *> Strings);\n\n  ExprResult BuildObjCStringLiteral(SourceLocation AtLoc, StringLiteral *S);\n\n  /// BuildObjCNumericLiteral - builds an ObjCBoxedExpr AST node for the\n  /// numeric literal expression. Type of the expression will be \"NSNumber *\"\n  /// or \"id\" if NSNumber is unavailable.\n  ExprResult BuildObjCNumericLiteral(SourceLocation AtLoc, Expr *Number);\n  ExprResult ActOnObjCBoolLiteral(SourceLocation AtLoc, SourceLocation ValueLoc,\n                                  bool Value);\n  ExprResult BuildObjCArrayLiteral(SourceRange SR, MultiExprArg Elements);\n\n  /// BuildObjCBoxedExpr - builds an ObjCBoxedExpr AST node for the\n  /// '@' prefixed parenthesized expression. The type of the expression will\n  /// either be \"NSNumber *\", \"NSString *\" or \"NSValue *\" depending on the type\n  /// of ValueType, which is allowed to be a built-in numeric type, \"char *\",\n  /// \"const char *\" or C structure with attribute 'objc_boxable'.\n  ExprResult BuildObjCBoxedExpr(SourceRange SR, Expr *ValueExpr);\n\n  ExprResult BuildObjCSubscriptExpression(SourceLocation RB, Expr *BaseExpr,\n                                          Expr *IndexExpr,\n                                          ObjCMethodDecl *getterMethod,\n                                          ObjCMethodDecl *setterMethod);\n\n  ExprResult BuildObjCDictionaryLiteral(SourceRange SR,\n                               MutableArrayRef<ObjCDictionaryElement> Elements);\n\n  ExprResult BuildObjCEncodeExpression(SourceLocation AtLoc,\n                                  TypeSourceInfo *EncodedTypeInfo,\n                                  SourceLocation RParenLoc);\n  ExprResult BuildCXXMemberCallExpr(Expr *Exp, NamedDecl *FoundDecl,\n                                    CXXConversionDecl *Method,\n                                    bool HadMultipleCandidates);\n\n  ExprResult ParseObjCEncodeExpression(SourceLocation AtLoc,\n                                       SourceLocation EncodeLoc,\n                                       SourceLocation LParenLoc,\n                                       ParsedType Ty,\n                                       SourceLocation RParenLoc);\n\n  /// ParseObjCSelectorExpression - Build selector expression for \\@selector\n  ExprResult ParseObjCSelectorExpression(Selector Sel,\n                                         SourceLocation AtLoc,\n                                         SourceLocation SelLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation RParenLoc,\n                                         bool WarnMultipleSelectors);\n\n  /// ParseObjCProtocolExpression - Build protocol expression for \\@protocol\n  ExprResult ParseObjCProtocolExpression(IdentifierInfo * ProtocolName,\n                                         SourceLocation AtLoc,\n                                         SourceLocation ProtoLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation ProtoIdLoc,\n                                         SourceLocation RParenLoc);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Declarations\n  //\n  Decl *ActOnStartLinkageSpecification(Scope *S,\n                                       SourceLocation ExternLoc,\n                                       Expr *LangStr,\n                                       SourceLocation LBraceLoc);\n  Decl *ActOnFinishLinkageSpecification(Scope *S,\n                                        Decl *LinkageSpec,\n                                        SourceLocation RBraceLoc);\n\n\n  //===--------------------------------------------------------------------===//\n  // C++ Classes\n  //\n  CXXRecordDecl *getCurrentClass(Scope *S, const CXXScopeSpec *SS);\n  bool isCurrentClassName(const IdentifierInfo &II, Scope *S,\n                          const CXXScopeSpec *SS = nullptr);\n  bool isCurrentClassNameTypo(IdentifierInfo *&II, const CXXScopeSpec *SS);\n\n  bool ActOnAccessSpecifier(AccessSpecifier Access, SourceLocation ASLoc,\n                            SourceLocation ColonLoc,\n                            const ParsedAttributesView &Attrs);\n\n  NamedDecl *ActOnCXXMemberDeclarator(Scope *S, AccessSpecifier AS,\n                                 Declarator &D,\n                                 MultiTemplateParamsArg TemplateParameterLists,\n                                 Expr *BitfieldWidth, const VirtSpecifiers &VS,\n                                 InClassInitStyle InitStyle);\n\n  void ActOnStartCXXInClassMemberInitializer();\n  void ActOnFinishCXXInClassMemberInitializer(Decl *VarDecl,\n                                              SourceLocation EqualLoc,\n                                              Expr *Init);\n\n  MemInitResult ActOnMemInitializer(Decl *ConstructorD,\n                                    Scope *S,\n                                    CXXScopeSpec &SS,\n                                    IdentifierInfo *MemberOrBase,\n                                    ParsedType TemplateTypeTy,\n                                    const DeclSpec &DS,\n                                    SourceLocation IdLoc,\n                                    SourceLocation LParenLoc,\n                                    ArrayRef<Expr *> Args,\n                                    SourceLocation RParenLoc,\n                                    SourceLocation EllipsisLoc);\n\n  MemInitResult ActOnMemInitializer(Decl *ConstructorD,\n                                    Scope *S,\n                                    CXXScopeSpec &SS,\n                                    IdentifierInfo *MemberOrBase,\n                                    ParsedType TemplateTypeTy,\n                                    const DeclSpec &DS,\n                                    SourceLocation IdLoc,\n                                    Expr *InitList,\n                                    SourceLocation EllipsisLoc);\n\n  MemInitResult BuildMemInitializer(Decl *ConstructorD,\n                                    Scope *S,\n                                    CXXScopeSpec &SS,\n                                    IdentifierInfo *MemberOrBase,\n                                    ParsedType TemplateTypeTy,\n                                    const DeclSpec &DS,\n                                    SourceLocation IdLoc,\n                                    Expr *Init,\n                                    SourceLocation EllipsisLoc);\n\n  MemInitResult BuildMemberInitializer(ValueDecl *Member,\n                                       Expr *Init,\n                                       SourceLocation IdLoc);\n\n  MemInitResult BuildBaseInitializer(QualType BaseType,\n                                     TypeSourceInfo *BaseTInfo,\n                                     Expr *Init,\n                                     CXXRecordDecl *ClassDecl,\n                                     SourceLocation EllipsisLoc);\n\n  MemInitResult BuildDelegatingInitializer(TypeSourceInfo *TInfo,\n                                           Expr *Init,\n                                           CXXRecordDecl *ClassDecl);\n\n  bool SetDelegatingInitializer(CXXConstructorDecl *Constructor,\n                                CXXCtorInitializer *Initializer);\n\n  bool SetCtorInitializers(CXXConstructorDecl *Constructor, bool AnyErrors,\n                           ArrayRef<CXXCtorInitializer *> Initializers = None);\n\n  void SetIvarInitializers(ObjCImplementationDecl *ObjCImplementation);\n\n\n  /// MarkBaseAndMemberDestructorsReferenced - Given a record decl,\n  /// mark all the non-trivial destructors of its members and bases as\n  /// referenced.\n  void MarkBaseAndMemberDestructorsReferenced(SourceLocation Loc,\n                                              CXXRecordDecl *Record);\n\n  /// Mark destructors of virtual bases of this class referenced. In the Itanium\n  /// C++ ABI, this is done when emitting a destructor for any non-abstract\n  /// class. In the Microsoft C++ ABI, this is done any time a class's\n  /// destructor is referenced.\n  void MarkVirtualBaseDestructorsReferenced(\n      SourceLocation Location, CXXRecordDecl *ClassDecl,\n      llvm::SmallPtrSetImpl<const RecordType *> *DirectVirtualBases = nullptr);\n\n  /// Do semantic checks to allow the complete destructor variant to be emitted\n  /// when the destructor is defined in another translation unit. In the Itanium\n  /// C++ ABI, destructor variants are emitted together. In the MS C++ ABI, they\n  /// can be emitted in separate TUs. To emit the complete variant, run a subset\n  /// of the checks performed when emitting a regular destructor.\n  void CheckCompleteDestructorVariant(SourceLocation CurrentLocation,\n                                      CXXDestructorDecl *Dtor);\n\n  /// The list of classes whose vtables have been used within\n  /// this translation unit, and the source locations at which the\n  /// first use occurred.\n  typedef std::pair<CXXRecordDecl*, SourceLocation> VTableUse;\n\n  /// The list of vtables that are required but have not yet been\n  /// materialized.\n  SmallVector<VTableUse, 16> VTableUses;\n\n  /// The set of classes whose vtables have been used within\n  /// this translation unit, and a bit that will be true if the vtable is\n  /// required to be emitted (otherwise, it should be emitted only if needed\n  /// by code generation).\n  llvm::DenseMap<CXXRecordDecl *, bool> VTablesUsed;\n\n  /// Load any externally-stored vtable uses.\n  void LoadExternalVTableUses();\n\n  /// Note that the vtable for the given class was used at the\n  /// given location.\n  void MarkVTableUsed(SourceLocation Loc, CXXRecordDecl *Class,\n                      bool DefinitionRequired = false);\n\n  /// Mark the exception specifications of all virtual member functions\n  /// in the given class as needed.\n  void MarkVirtualMemberExceptionSpecsNeeded(SourceLocation Loc,\n                                             const CXXRecordDecl *RD);\n\n  /// MarkVirtualMembersReferenced - Will mark all members of the given\n  /// CXXRecordDecl referenced.\n  void MarkVirtualMembersReferenced(SourceLocation Loc, const CXXRecordDecl *RD,\n                                    bool ConstexprOnly = false);\n\n  /// Define all of the vtables that have been used in this\n  /// translation unit and reference any virtual members used by those\n  /// vtables.\n  ///\n  /// \\returns true if any work was done, false otherwise.\n  bool DefineUsedVTables();\n\n  void AddImplicitlyDeclaredMembersToClass(CXXRecordDecl *ClassDecl);\n\n  void ActOnMemInitializers(Decl *ConstructorDecl,\n                            SourceLocation ColonLoc,\n                            ArrayRef<CXXCtorInitializer*> MemInits,\n                            bool AnyErrors);\n\n  /// Check class-level dllimport/dllexport attribute. The caller must\n  /// ensure that referenceDLLExportedClassMethods is called some point later\n  /// when all outer classes of Class are complete.\n  void checkClassLevelDLLAttribute(CXXRecordDecl *Class);\n  void checkClassLevelCodeSegAttribute(CXXRecordDecl *Class);\n\n  void referenceDLLExportedClassMethods();\n\n  void propagateDLLAttrToBaseClassTemplate(\n      CXXRecordDecl *Class, Attr *ClassAttr,\n      ClassTemplateSpecializationDecl *BaseTemplateSpec,\n      SourceLocation BaseLoc);\n\n  /// Add gsl::Pointer attribute to std::container::iterator\n  /// \\param ND The declaration that introduces the name\n  /// std::container::iterator. \\param UnderlyingRecord The record named by ND.\n  void inferGslPointerAttribute(NamedDecl *ND, CXXRecordDecl *UnderlyingRecord);\n\n  /// Add [[gsl::Owner]] and [[gsl::Pointer]] attributes for std:: types.\n  void inferGslOwnerPointerAttribute(CXXRecordDecl *Record);\n\n  /// Add [[gsl::Pointer]] attributes for std:: types.\n  void inferGslPointerAttribute(TypedefNameDecl *TD);\n\n  void CheckCompletedCXXClass(Scope *S, CXXRecordDecl *Record);\n\n  /// Check that the C++ class annoated with \"trivial_abi\" satisfies all the\n  /// conditions that are needed for the attribute to have an effect.\n  void checkIllFormedTrivialABIStruct(CXXRecordDecl &RD);\n\n  void ActOnFinishCXXMemberSpecification(Scope *S, SourceLocation RLoc,\n                                         Decl *TagDecl, SourceLocation LBrac,\n                                         SourceLocation RBrac,\n                                         const ParsedAttributesView &AttrList);\n  void ActOnFinishCXXMemberDecls();\n  void ActOnFinishCXXNonNestedClass();\n\n  void ActOnReenterCXXMethodParameter(Scope *S, ParmVarDecl *Param);\n  unsigned ActOnReenterTemplateScope(Decl *Template,\n                                     llvm::function_ref<Scope *()> EnterScope);\n  void ActOnStartDelayedMemberDeclarations(Scope *S, Decl *Record);\n  void ActOnStartDelayedCXXMethodDeclaration(Scope *S, Decl *Method);\n  void ActOnDelayedCXXMethodParameter(Scope *S, Decl *Param);\n  void ActOnFinishDelayedMemberDeclarations(Scope *S, Decl *Record);\n  void ActOnFinishDelayedCXXMethodDeclaration(Scope *S, Decl *Method);\n  void ActOnFinishDelayedMemberInitializers(Decl *Record);\n  void MarkAsLateParsedTemplate(FunctionDecl *FD, Decl *FnD,\n                                CachedTokens &Toks);\n  void UnmarkAsLateParsedTemplate(FunctionDecl *FD);\n  bool IsInsideALocalClassWithinATemplateFunction();\n\n  Decl *ActOnStaticAssertDeclaration(SourceLocation StaticAssertLoc,\n                                     Expr *AssertExpr,\n                                     Expr *AssertMessageExpr,\n                                     SourceLocation RParenLoc);\n  Decl *BuildStaticAssertDeclaration(SourceLocation StaticAssertLoc,\n                                     Expr *AssertExpr,\n                                     StringLiteral *AssertMessageExpr,\n                                     SourceLocation RParenLoc,\n                                     bool Failed);\n\n  FriendDecl *CheckFriendTypeDecl(SourceLocation LocStart,\n                                  SourceLocation FriendLoc,\n                                  TypeSourceInfo *TSInfo);\n  Decl *ActOnFriendTypeDecl(Scope *S, const DeclSpec &DS,\n                            MultiTemplateParamsArg TemplateParams);\n  NamedDecl *ActOnFriendFunctionDecl(Scope *S, Declarator &D,\n                                     MultiTemplateParamsArg TemplateParams);\n\n  QualType CheckConstructorDeclarator(Declarator &D, QualType R,\n                                      StorageClass& SC);\n  void CheckConstructor(CXXConstructorDecl *Constructor);\n  QualType CheckDestructorDeclarator(Declarator &D, QualType R,\n                                     StorageClass& SC);\n  bool CheckDestructor(CXXDestructorDecl *Destructor);\n  void CheckConversionDeclarator(Declarator &D, QualType &R,\n                                 StorageClass& SC);\n  Decl *ActOnConversionDeclarator(CXXConversionDecl *Conversion);\n  void CheckDeductionGuideDeclarator(Declarator &D, QualType &R,\n                                     StorageClass &SC);\n  void CheckDeductionGuideTemplate(FunctionTemplateDecl *TD);\n\n  void CheckExplicitlyDefaultedFunction(Scope *S, FunctionDecl *MD);\n\n  bool CheckExplicitlyDefaultedSpecialMember(CXXMethodDecl *MD,\n                                             CXXSpecialMember CSM);\n  void CheckDelayedMemberExceptionSpecs();\n\n  bool CheckExplicitlyDefaultedComparison(Scope *S, FunctionDecl *MD,\n                                          DefaultedComparisonKind DCK);\n  void DeclareImplicitEqualityComparison(CXXRecordDecl *RD,\n                                         FunctionDecl *Spaceship);\n  void DefineDefaultedComparison(SourceLocation Loc, FunctionDecl *FD,\n                                 DefaultedComparisonKind DCK);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Derived Classes\n  //\n\n  /// ActOnBaseSpecifier - Parsed a base specifier\n  CXXBaseSpecifier *CheckBaseSpecifier(CXXRecordDecl *Class,\n                                       SourceRange SpecifierRange,\n                                       bool Virtual, AccessSpecifier Access,\n                                       TypeSourceInfo *TInfo,\n                                       SourceLocation EllipsisLoc);\n\n  BaseResult ActOnBaseSpecifier(Decl *classdecl,\n                                SourceRange SpecifierRange,\n                                ParsedAttributes &Attrs,\n                                bool Virtual, AccessSpecifier Access,\n                                ParsedType basetype,\n                                SourceLocation BaseLoc,\n                                SourceLocation EllipsisLoc);\n\n  bool AttachBaseSpecifiers(CXXRecordDecl *Class,\n                            MutableArrayRef<CXXBaseSpecifier *> Bases);\n  void ActOnBaseSpecifiers(Decl *ClassDecl,\n                           MutableArrayRef<CXXBaseSpecifier *> Bases);\n\n  bool IsDerivedFrom(SourceLocation Loc, QualType Derived, QualType Base);\n  bool IsDerivedFrom(SourceLocation Loc, QualType Derived, QualType Base,\n                     CXXBasePaths &Paths);\n\n  // FIXME: I don't like this name.\n  void BuildBasePathArray(const CXXBasePaths &Paths, CXXCastPath &BasePath);\n\n  bool CheckDerivedToBaseConversion(QualType Derived, QualType Base,\n                                    SourceLocation Loc, SourceRange Range,\n                                    CXXCastPath *BasePath = nullptr,\n                                    bool IgnoreAccess = false);\n  bool CheckDerivedToBaseConversion(QualType Derived, QualType Base,\n                                    unsigned InaccessibleBaseID,\n                                    unsigned AmbiguousBaseConvID,\n                                    SourceLocation Loc, SourceRange Range,\n                                    DeclarationName Name,\n                                    CXXCastPath *BasePath,\n                                    bool IgnoreAccess = false);\n\n  std::string getAmbiguousPathsDisplayString(CXXBasePaths &Paths);\n\n  bool CheckOverridingFunctionAttributes(const CXXMethodDecl *New,\n                                         const CXXMethodDecl *Old);\n\n  /// CheckOverridingFunctionReturnType - Checks whether the return types are\n  /// covariant, according to C++ [class.virtual]p5.\n  bool CheckOverridingFunctionReturnType(const CXXMethodDecl *New,\n                                         const CXXMethodDecl *Old);\n\n  /// CheckOverridingFunctionExceptionSpec - Checks whether the exception\n  /// spec is a subset of base spec.\n  bool CheckOverridingFunctionExceptionSpec(const CXXMethodDecl *New,\n                                            const CXXMethodDecl *Old);\n\n  bool CheckPureMethod(CXXMethodDecl *Method, SourceRange InitRange);\n\n  /// CheckOverrideControl - Check C++11 override control semantics.\n  void CheckOverrideControl(NamedDecl *D);\n\n  /// DiagnoseAbsenceOfOverrideControl - Diagnose if 'override' keyword was\n  /// not used in the declaration of an overriding method.\n  void DiagnoseAbsenceOfOverrideControl(NamedDecl *D, bool Inconsistent);\n\n  /// CheckForFunctionMarkedFinal - Checks whether a virtual member function\n  /// overrides a virtual member function marked 'final', according to\n  /// C++11 [class.virtual]p4.\n  bool CheckIfOverriddenFunctionIsMarkedFinal(const CXXMethodDecl *New,\n                                              const CXXMethodDecl *Old);\n\n\n  //===--------------------------------------------------------------------===//\n  // C++ Access Control\n  //\n\n  enum AccessResult {\n    AR_accessible,\n    AR_inaccessible,\n    AR_dependent,\n    AR_delayed\n  };\n\n  bool SetMemberAccessSpecifier(NamedDecl *MemberDecl,\n                                NamedDecl *PrevMemberDecl,\n                                AccessSpecifier LexicalAS);\n\n  AccessResult CheckUnresolvedMemberAccess(UnresolvedMemberExpr *E,\n                                           DeclAccessPair FoundDecl);\n  AccessResult CheckUnresolvedLookupAccess(UnresolvedLookupExpr *E,\n                                           DeclAccessPair FoundDecl);\n  AccessResult CheckAllocationAccess(SourceLocation OperatorLoc,\n                                     SourceRange PlacementRange,\n                                     CXXRecordDecl *NamingClass,\n                                     DeclAccessPair FoundDecl,\n                                     bool Diagnose = true);\n  AccessResult CheckConstructorAccess(SourceLocation Loc,\n                                      CXXConstructorDecl *D,\n                                      DeclAccessPair FoundDecl,\n                                      const InitializedEntity &Entity,\n                                      bool IsCopyBindingRefToTemp = false);\n  AccessResult CheckConstructorAccess(SourceLocation Loc,\n                                      CXXConstructorDecl *D,\n                                      DeclAccessPair FoundDecl,\n                                      const InitializedEntity &Entity,\n                                      const PartialDiagnostic &PDiag);\n  AccessResult CheckDestructorAccess(SourceLocation Loc,\n                                     CXXDestructorDecl *Dtor,\n                                     const PartialDiagnostic &PDiag,\n                                     QualType objectType = QualType());\n  AccessResult CheckFriendAccess(NamedDecl *D);\n  AccessResult CheckMemberAccess(SourceLocation UseLoc,\n                                 CXXRecordDecl *NamingClass,\n                                 DeclAccessPair Found);\n  AccessResult\n  CheckStructuredBindingMemberAccess(SourceLocation UseLoc,\n                                     CXXRecordDecl *DecomposedClass,\n                                     DeclAccessPair Field);\n  AccessResult CheckMemberOperatorAccess(SourceLocation Loc,\n                                         Expr *ObjectExpr,\n                                         Expr *ArgExpr,\n                                         DeclAccessPair FoundDecl);\n  AccessResult CheckAddressOfMemberAccess(Expr *OvlExpr,\n                                          DeclAccessPair FoundDecl);\n  AccessResult CheckBaseClassAccess(SourceLocation AccessLoc,\n                                    QualType Base, QualType Derived,\n                                    const CXXBasePath &Path,\n                                    unsigned DiagID,\n                                    bool ForceCheck = false,\n                                    bool ForceUnprivileged = false);\n  void CheckLookupAccess(const LookupResult &R);\n  bool IsSimplyAccessible(NamedDecl *Decl, CXXRecordDecl *NamingClass,\n                          QualType BaseType);\n  bool isMemberAccessibleForDeletion(CXXRecordDecl *NamingClass,\n                                     DeclAccessPair Found, QualType ObjectType,\n                                     SourceLocation Loc,\n                                     const PartialDiagnostic &Diag);\n  bool isMemberAccessibleForDeletion(CXXRecordDecl *NamingClass,\n                                     DeclAccessPair Found,\n                                     QualType ObjectType) {\n    return isMemberAccessibleForDeletion(NamingClass, Found, ObjectType,\n                                         SourceLocation(), PDiag());\n  }\n\n  void HandleDependentAccessCheck(const DependentDiagnostic &DD,\n                         const MultiLevelTemplateArgumentList &TemplateArgs);\n  void PerformDependentDiagnostics(const DeclContext *Pattern,\n                        const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  void HandleDelayedAccessCheck(sema::DelayedDiagnostic &DD, Decl *Ctx);\n\n  /// When true, access checking violations are treated as SFINAE\n  /// failures rather than hard errors.\n  bool AccessCheckingSFINAE;\n\n  enum AbstractDiagSelID {\n    AbstractNone = -1,\n    AbstractReturnType,\n    AbstractParamType,\n    AbstractVariableType,\n    AbstractFieldType,\n    AbstractIvarType,\n    AbstractSynthesizedIvarType,\n    AbstractArrayType\n  };\n\n  bool isAbstractType(SourceLocation Loc, QualType T);\n  bool RequireNonAbstractType(SourceLocation Loc, QualType T,\n                              TypeDiagnoser &Diagnoser);\n  template <typename... Ts>\n  bool RequireNonAbstractType(SourceLocation Loc, QualType T, unsigned DiagID,\n                              const Ts &...Args) {\n    BoundTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireNonAbstractType(Loc, T, Diagnoser);\n  }\n\n  void DiagnoseAbstractType(const CXXRecordDecl *RD);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Overloaded Operators [C++ 13.5]\n  //\n\n  bool CheckOverloadedOperatorDeclaration(FunctionDecl *FnDecl);\n\n  bool CheckLiteralOperatorDeclaration(FunctionDecl *FnDecl);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Templates [C++ 14]\n  //\n  void FilterAcceptableTemplateNames(LookupResult &R,\n                                     bool AllowFunctionTemplates = true,\n                                     bool AllowDependent = true);\n  bool hasAnyAcceptableTemplateNames(LookupResult &R,\n                                     bool AllowFunctionTemplates = true,\n                                     bool AllowDependent = true,\n                                     bool AllowNonTemplateFunctions = false);\n  /// Try to interpret the lookup result D as a template-name.\n  ///\n  /// \\param D A declaration found by name lookup.\n  /// \\param AllowFunctionTemplates Whether function templates should be\n  ///        considered valid results.\n  /// \\param AllowDependent Whether unresolved using declarations (that might\n  ///        name templates) should be considered valid results.\n  static NamedDecl *getAsTemplateNameDecl(NamedDecl *D,\n                                          bool AllowFunctionTemplates = true,\n                                          bool AllowDependent = true);\n\n  enum TemplateNameIsRequiredTag { TemplateNameIsRequired };\n  /// Whether and why a template name is required in this lookup.\n  class RequiredTemplateKind {\n  public:\n    /// Template name is required if TemplateKWLoc is valid.\n    RequiredTemplateKind(SourceLocation TemplateKWLoc = SourceLocation())\n        : TemplateKW(TemplateKWLoc) {}\n    /// Template name is unconditionally required.\n    RequiredTemplateKind(TemplateNameIsRequiredTag) : TemplateKW() {}\n\n    SourceLocation getTemplateKeywordLoc() const {\n      return TemplateKW.getValueOr(SourceLocation());\n    }\n    bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n    bool isRequired() const { return TemplateKW != SourceLocation(); }\n    explicit operator bool() const { return isRequired(); }\n\n  private:\n    llvm::Optional<SourceLocation> TemplateKW;\n  };\n\n  enum class AssumedTemplateKind {\n    /// This is not assumed to be a template name.\n    None,\n    /// This is assumed to be a template name because lookup found nothing.\n    FoundNothing,\n    /// This is assumed to be a template name because lookup found one or more\n    /// functions (but no function templates).\n    FoundFunctions,\n  };\n  bool LookupTemplateName(\n      LookupResult &R, Scope *S, CXXScopeSpec &SS, QualType ObjectType,\n      bool EnteringContext, bool &MemberOfUnknownSpecialization,\n      RequiredTemplateKind RequiredTemplate = SourceLocation(),\n      AssumedTemplateKind *ATK = nullptr, bool AllowTypoCorrection = true);\n\n  TemplateNameKind isTemplateName(Scope *S,\n                                  CXXScopeSpec &SS,\n                                  bool hasTemplateKeyword,\n                                  const UnqualifiedId &Name,\n                                  ParsedType ObjectType,\n                                  bool EnteringContext,\n                                  TemplateTy &Template,\n                                  bool &MemberOfUnknownSpecialization,\n                                  bool Disambiguation = false);\n\n  /// Try to resolve an undeclared template name as a type template.\n  ///\n  /// Sets II to the identifier corresponding to the template name, and updates\n  /// Name to a corresponding (typo-corrected) type template name and TNK to\n  /// the corresponding kind, if possible.\n  void ActOnUndeclaredTypeTemplateName(Scope *S, TemplateTy &Name,\n                                       TemplateNameKind &TNK,\n                                       SourceLocation NameLoc,\n                                       IdentifierInfo *&II);\n\n  bool resolveAssumedTemplateNameAsType(Scope *S, TemplateName &Name,\n                                        SourceLocation NameLoc,\n                                        bool Diagnose = true);\n\n  /// Determine whether a particular identifier might be the name in a C++1z\n  /// deduction-guide declaration.\n  bool isDeductionGuideName(Scope *S, const IdentifierInfo &Name,\n                            SourceLocation NameLoc,\n                            ParsedTemplateTy *Template = nullptr);\n\n  bool DiagnoseUnknownTemplateName(const IdentifierInfo &II,\n                                   SourceLocation IILoc,\n                                   Scope *S,\n                                   const CXXScopeSpec *SS,\n                                   TemplateTy &SuggestedTemplate,\n                                   TemplateNameKind &SuggestedKind);\n\n  bool DiagnoseUninstantiableTemplate(SourceLocation PointOfInstantiation,\n                                      NamedDecl *Instantiation,\n                                      bool InstantiatedFromMember,\n                                      const NamedDecl *Pattern,\n                                      const NamedDecl *PatternDef,\n                                      TemplateSpecializationKind TSK,\n                                      bool Complain = true);\n\n  void DiagnoseTemplateParameterShadow(SourceLocation Loc, Decl *PrevDecl);\n  TemplateDecl *AdjustDeclIfTemplate(Decl *&Decl);\n\n  NamedDecl *ActOnTypeParameter(Scope *S, bool Typename,\n                                SourceLocation EllipsisLoc,\n                                SourceLocation KeyLoc,\n                                IdentifierInfo *ParamName,\n                                SourceLocation ParamNameLoc,\n                                unsigned Depth, unsigned Position,\n                                SourceLocation EqualLoc,\n                                ParsedType DefaultArg, bool HasTypeConstraint);\n\n  bool ActOnTypeConstraint(const CXXScopeSpec &SS,\n                           TemplateIdAnnotation *TypeConstraint,\n                           TemplateTypeParmDecl *ConstrainedParameter,\n                           SourceLocation EllipsisLoc);\n\n  bool AttachTypeConstraint(NestedNameSpecifierLoc NS,\n                            DeclarationNameInfo NameInfo,\n                            ConceptDecl *NamedConcept,\n                            const TemplateArgumentListInfo *TemplateArgs,\n                            TemplateTypeParmDecl *ConstrainedParameter,\n                            SourceLocation EllipsisLoc);\n\n  bool AttachTypeConstraint(AutoTypeLoc TL,\n                            NonTypeTemplateParmDecl *ConstrainedParameter,\n                            SourceLocation EllipsisLoc);\n\n  bool RequireStructuralType(QualType T, SourceLocation Loc);\n\n  QualType CheckNonTypeTemplateParameterType(TypeSourceInfo *&TSI,\n                                             SourceLocation Loc);\n  QualType CheckNonTypeTemplateParameterType(QualType T, SourceLocation Loc);\n\n  NamedDecl *ActOnNonTypeTemplateParameter(Scope *S, Declarator &D,\n                                      unsigned Depth,\n                                      unsigned Position,\n                                      SourceLocation EqualLoc,\n                                      Expr *DefaultArg);\n  NamedDecl *ActOnTemplateTemplateParameter(Scope *S,\n                                       SourceLocation TmpLoc,\n                                       TemplateParameterList *Params,\n                                       SourceLocation EllipsisLoc,\n                                       IdentifierInfo *ParamName,\n                                       SourceLocation ParamNameLoc,\n                                       unsigned Depth,\n                                       unsigned Position,\n                                       SourceLocation EqualLoc,\n                                       ParsedTemplateArgument DefaultArg);\n\n  TemplateParameterList *\n  ActOnTemplateParameterList(unsigned Depth,\n                             SourceLocation ExportLoc,\n                             SourceLocation TemplateLoc,\n                             SourceLocation LAngleLoc,\n                             ArrayRef<NamedDecl *> Params,\n                             SourceLocation RAngleLoc,\n                             Expr *RequiresClause);\n\n  /// The context in which we are checking a template parameter list.\n  enum TemplateParamListContext {\n    TPC_ClassTemplate,\n    TPC_VarTemplate,\n    TPC_FunctionTemplate,\n    TPC_ClassTemplateMember,\n    TPC_FriendClassTemplate,\n    TPC_FriendFunctionTemplate,\n    TPC_FriendFunctionTemplateDefinition,\n    TPC_TypeAliasTemplate\n  };\n\n  bool CheckTemplateParameterList(TemplateParameterList *NewParams,\n                                  TemplateParameterList *OldParams,\n                                  TemplateParamListContext TPC,\n                                  SkipBodyInfo *SkipBody = nullptr);\n  TemplateParameterList *MatchTemplateParametersToScopeSpecifier(\n      SourceLocation DeclStartLoc, SourceLocation DeclLoc,\n      const CXXScopeSpec &SS, TemplateIdAnnotation *TemplateId,\n      ArrayRef<TemplateParameterList *> ParamLists,\n      bool IsFriend, bool &IsMemberSpecialization, bool &Invalid,\n      bool SuppressDiagnostic = false);\n\n  DeclResult CheckClassTemplate(\n      Scope *S, unsigned TagSpec, TagUseKind TUK, SourceLocation KWLoc,\n      CXXScopeSpec &SS, IdentifierInfo *Name, SourceLocation NameLoc,\n      const ParsedAttributesView &Attr, TemplateParameterList *TemplateParams,\n      AccessSpecifier AS, SourceLocation ModulePrivateLoc,\n      SourceLocation FriendLoc, unsigned NumOuterTemplateParamLists,\n      TemplateParameterList **OuterTemplateParamLists,\n      SkipBodyInfo *SkipBody = nullptr);\n\n  TemplateArgumentLoc getTrivialTemplateArgumentLoc(const TemplateArgument &Arg,\n                                                    QualType NTTPType,\n                                                    SourceLocation Loc);\n\n  /// Get a template argument mapping the given template parameter to itself,\n  /// e.g. for X in \\c template<int X>, this would return an expression template\n  /// argument referencing X.\n  TemplateArgumentLoc getIdentityTemplateArgumentLoc(NamedDecl *Param,\n                                                     SourceLocation Location);\n\n  void translateTemplateArguments(const ASTTemplateArgsPtr &In,\n                                  TemplateArgumentListInfo &Out);\n\n  ParsedTemplateArgument ActOnTemplateTypeArgument(TypeResult ParsedType);\n\n  void NoteAllFoundTemplates(TemplateName Name);\n\n  QualType CheckTemplateIdType(TemplateName Template,\n                               SourceLocation TemplateLoc,\n                              TemplateArgumentListInfo &TemplateArgs);\n\n  TypeResult\n  ActOnTemplateIdType(Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,\n                      TemplateTy Template, IdentifierInfo *TemplateII,\n                      SourceLocation TemplateIILoc, SourceLocation LAngleLoc,\n                      ASTTemplateArgsPtr TemplateArgs, SourceLocation RAngleLoc,\n                      bool IsCtorOrDtorName = false, bool IsClassName = false);\n\n  /// Parsed an elaborated-type-specifier that refers to a template-id,\n  /// such as \\c class T::template apply<U>.\n  TypeResult ActOnTagTemplateIdType(TagUseKind TUK,\n                                    TypeSpecifierType TagSpec,\n                                    SourceLocation TagLoc,\n                                    CXXScopeSpec &SS,\n                                    SourceLocation TemplateKWLoc,\n                                    TemplateTy TemplateD,\n                                    SourceLocation TemplateLoc,\n                                    SourceLocation LAngleLoc,\n                                    ASTTemplateArgsPtr TemplateArgsIn,\n                                    SourceLocation RAngleLoc);\n\n  DeclResult ActOnVarTemplateSpecialization(\n      Scope *S, Declarator &D, TypeSourceInfo *DI,\n      SourceLocation TemplateKWLoc, TemplateParameterList *TemplateParams,\n      StorageClass SC, bool IsPartialSpecialization);\n\n  /// Get the specialization of the given variable template corresponding to\n  /// the specified argument list, or a null-but-valid result if the arguments\n  /// are dependent.\n  DeclResult CheckVarTemplateId(VarTemplateDecl *Template,\n                                SourceLocation TemplateLoc,\n                                SourceLocation TemplateNameLoc,\n                                const TemplateArgumentListInfo &TemplateArgs);\n\n  /// Form a reference to the specialization of the given variable template\n  /// corresponding to the specified argument list, or a null-but-valid result\n  /// if the arguments are dependent.\n  ExprResult CheckVarTemplateId(const CXXScopeSpec &SS,\n                                const DeclarationNameInfo &NameInfo,\n                                VarTemplateDecl *Template,\n                                SourceLocation TemplateLoc,\n                                const TemplateArgumentListInfo *TemplateArgs);\n\n  ExprResult\n  CheckConceptTemplateId(const CXXScopeSpec &SS,\n                         SourceLocation TemplateKWLoc,\n                         const DeclarationNameInfo &ConceptNameInfo,\n                         NamedDecl *FoundDecl, ConceptDecl *NamedConcept,\n                         const TemplateArgumentListInfo *TemplateArgs);\n\n  void diagnoseMissingTemplateArguments(TemplateName Name, SourceLocation Loc);\n\n  ExprResult BuildTemplateIdExpr(const CXXScopeSpec &SS,\n                                 SourceLocation TemplateKWLoc,\n                                 LookupResult &R,\n                                 bool RequiresADL,\n                               const TemplateArgumentListInfo *TemplateArgs);\n\n  ExprResult BuildQualifiedTemplateIdExpr(CXXScopeSpec &SS,\n                                          SourceLocation TemplateKWLoc,\n                               const DeclarationNameInfo &NameInfo,\n                               const TemplateArgumentListInfo *TemplateArgs);\n\n  TemplateNameKind ActOnTemplateName(\n      Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,\n      const UnqualifiedId &Name, ParsedType ObjectType, bool EnteringContext,\n      TemplateTy &Template, bool AllowInjectedClassName = false);\n\n  DeclResult ActOnClassTemplateSpecialization(\n      Scope *S, unsigned TagSpec, TagUseKind TUK, SourceLocation KWLoc,\n      SourceLocation ModulePrivateLoc, CXXScopeSpec &SS,\n      TemplateIdAnnotation &TemplateId, const ParsedAttributesView &Attr,\n      MultiTemplateParamsArg TemplateParameterLists,\n      SkipBodyInfo *SkipBody = nullptr);\n\n  bool CheckTemplatePartialSpecializationArgs(SourceLocation Loc,\n                                              TemplateDecl *PrimaryTemplate,\n                                              unsigned NumExplicitArgs,\n                                              ArrayRef<TemplateArgument> Args);\n  void CheckTemplatePartialSpecialization(\n      ClassTemplatePartialSpecializationDecl *Partial);\n  void CheckTemplatePartialSpecialization(\n      VarTemplatePartialSpecializationDecl *Partial);\n\n  Decl *ActOnTemplateDeclarator(Scope *S,\n                                MultiTemplateParamsArg TemplateParameterLists,\n                                Declarator &D);\n\n  bool\n  CheckSpecializationInstantiationRedecl(SourceLocation NewLoc,\n                                         TemplateSpecializationKind NewTSK,\n                                         NamedDecl *PrevDecl,\n                                         TemplateSpecializationKind PrevTSK,\n                                         SourceLocation PrevPtOfInstantiation,\n                                         bool &SuppressNew);\n\n  bool CheckDependentFunctionTemplateSpecialization(FunctionDecl *FD,\n                    const TemplateArgumentListInfo &ExplicitTemplateArgs,\n                                                    LookupResult &Previous);\n\n  bool CheckFunctionTemplateSpecialization(\n      FunctionDecl *FD, TemplateArgumentListInfo *ExplicitTemplateArgs,\n      LookupResult &Previous, bool QualifiedFriend = false);\n  bool CheckMemberSpecialization(NamedDecl *Member, LookupResult &Previous);\n  void CompleteMemberSpecialization(NamedDecl *Member, LookupResult &Previous);\n\n  DeclResult ActOnExplicitInstantiation(\n      Scope *S, SourceLocation ExternLoc, SourceLocation TemplateLoc,\n      unsigned TagSpec, SourceLocation KWLoc, const CXXScopeSpec &SS,\n      TemplateTy Template, SourceLocation TemplateNameLoc,\n      SourceLocation LAngleLoc, ASTTemplateArgsPtr TemplateArgs,\n      SourceLocation RAngleLoc, const ParsedAttributesView &Attr);\n\n  DeclResult ActOnExplicitInstantiation(Scope *S, SourceLocation ExternLoc,\n                                        SourceLocation TemplateLoc,\n                                        unsigned TagSpec, SourceLocation KWLoc,\n                                        CXXScopeSpec &SS, IdentifierInfo *Name,\n                                        SourceLocation NameLoc,\n                                        const ParsedAttributesView &Attr);\n\n  DeclResult ActOnExplicitInstantiation(Scope *S,\n                                        SourceLocation ExternLoc,\n                                        SourceLocation TemplateLoc,\n                                        Declarator &D);\n\n  TemplateArgumentLoc\n  SubstDefaultTemplateArgumentIfAvailable(TemplateDecl *Template,\n                                          SourceLocation TemplateLoc,\n                                          SourceLocation RAngleLoc,\n                                          Decl *Param,\n                                          SmallVectorImpl<TemplateArgument>\n                                            &Converted,\n                                          bool &HasDefaultArg);\n\n  /// Specifies the context in which a particular template\n  /// argument is being checked.\n  enum CheckTemplateArgumentKind {\n    /// The template argument was specified in the code or was\n    /// instantiated with some deduced template arguments.\n    CTAK_Specified,\n\n    /// The template argument was deduced via template argument\n    /// deduction.\n    CTAK_Deduced,\n\n    /// The template argument was deduced from an array bound\n    /// via template argument deduction.\n    CTAK_DeducedFromArrayBound\n  };\n\n  bool CheckTemplateArgument(NamedDecl *Param,\n                             TemplateArgumentLoc &Arg,\n                             NamedDecl *Template,\n                             SourceLocation TemplateLoc,\n                             SourceLocation RAngleLoc,\n                             unsigned ArgumentPackIndex,\n                           SmallVectorImpl<TemplateArgument> &Converted,\n                             CheckTemplateArgumentKind CTAK = CTAK_Specified);\n\n  /// Check that the given template arguments can be be provided to\n  /// the given template, converting the arguments along the way.\n  ///\n  /// \\param Template The template to which the template arguments are being\n  /// provided.\n  ///\n  /// \\param TemplateLoc The location of the template name in the source.\n  ///\n  /// \\param TemplateArgs The list of template arguments. If the template is\n  /// a template template parameter, this function may extend the set of\n  /// template arguments to also include substituted, defaulted template\n  /// arguments.\n  ///\n  /// \\param PartialTemplateArgs True if the list of template arguments is\n  /// intentionally partial, e.g., because we're checking just the initial\n  /// set of template arguments.\n  ///\n  /// \\param Converted Will receive the converted, canonicalized template\n  /// arguments.\n  ///\n  /// \\param UpdateArgsWithConversions If \\c true, update \\p TemplateArgs to\n  /// contain the converted forms of the template arguments as written.\n  /// Otherwise, \\p TemplateArgs will not be modified.\n  ///\n  /// \\param ConstraintsNotSatisfied If provided, and an error occured, will\n  /// receive true if the cause for the error is the associated constraints of\n  /// the template not being satisfied by the template arguments.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool CheckTemplateArgumentList(TemplateDecl *Template,\n                                 SourceLocation TemplateLoc,\n                                 TemplateArgumentListInfo &TemplateArgs,\n                                 bool PartialTemplateArgs,\n                                 SmallVectorImpl<TemplateArgument> &Converted,\n                                 bool UpdateArgsWithConversions = true,\n                                 bool *ConstraintsNotSatisfied = nullptr);\n\n  bool CheckTemplateTypeArgument(TemplateTypeParmDecl *Param,\n                                 TemplateArgumentLoc &Arg,\n                           SmallVectorImpl<TemplateArgument> &Converted);\n\n  bool CheckTemplateArgument(TemplateTypeParmDecl *Param,\n                             TypeSourceInfo *Arg);\n  ExprResult CheckTemplateArgument(NonTypeTemplateParmDecl *Param,\n                                   QualType InstantiatedParamType, Expr *Arg,\n                                   TemplateArgument &Converted,\n                               CheckTemplateArgumentKind CTAK = CTAK_Specified);\n  bool CheckTemplateTemplateArgument(TemplateTemplateParmDecl *Param,\n                                     TemplateParameterList *Params,\n                                     TemplateArgumentLoc &Arg);\n\n  ExprResult\n  BuildExpressionFromDeclTemplateArgument(const TemplateArgument &Arg,\n                                          QualType ParamType,\n                                          SourceLocation Loc);\n  ExprResult\n  BuildExpressionFromIntegralTemplateArgument(const TemplateArgument &Arg,\n                                              SourceLocation Loc);\n\n  /// Enumeration describing how template parameter lists are compared\n  /// for equality.\n  enum TemplateParameterListEqualKind {\n    /// We are matching the template parameter lists of two templates\n    /// that might be redeclarations.\n    ///\n    /// \\code\n    /// template<typename T> struct X;\n    /// template<typename T> struct X;\n    /// \\endcode\n    TPL_TemplateMatch,\n\n    /// We are matching the template parameter lists of two template\n    /// template parameters as part of matching the template parameter lists\n    /// of two templates that might be redeclarations.\n    ///\n    /// \\code\n    /// template<template<int I> class TT> struct X;\n    /// template<template<int Value> class Other> struct X;\n    /// \\endcode\n    TPL_TemplateTemplateParmMatch,\n\n    /// We are matching the template parameter lists of a template\n    /// template argument against the template parameter lists of a template\n    /// template parameter.\n    ///\n    /// \\code\n    /// template<template<int Value> class Metafun> struct X;\n    /// template<int Value> struct integer_c;\n    /// X<integer_c> xic;\n    /// \\endcode\n    TPL_TemplateTemplateArgumentMatch\n  };\n\n  bool TemplateParameterListsAreEqual(TemplateParameterList *New,\n                                      TemplateParameterList *Old,\n                                      bool Complain,\n                                      TemplateParameterListEqualKind Kind,\n                                      SourceLocation TemplateArgLoc\n                                        = SourceLocation());\n\n  bool CheckTemplateDeclScope(Scope *S, TemplateParameterList *TemplateParams);\n\n  /// Called when the parser has parsed a C++ typename\n  /// specifier, e.g., \"typename T::type\".\n  ///\n  /// \\param S The scope in which this typename type occurs.\n  /// \\param TypenameLoc the location of the 'typename' keyword\n  /// \\param SS the nested-name-specifier following the typename (e.g., 'T::').\n  /// \\param II the identifier we're retrieving (e.g., 'type' in the example).\n  /// \\param IdLoc the location of the identifier.\n  TypeResult\n  ActOnTypenameType(Scope *S, SourceLocation TypenameLoc,\n                    const CXXScopeSpec &SS, const IdentifierInfo &II,\n                    SourceLocation IdLoc);\n\n  /// Called when the parser has parsed a C++ typename\n  /// specifier that ends in a template-id, e.g.,\n  /// \"typename MetaFun::template apply<T1, T2>\".\n  ///\n  /// \\param S The scope in which this typename type occurs.\n  /// \\param TypenameLoc the location of the 'typename' keyword\n  /// \\param SS the nested-name-specifier following the typename (e.g., 'T::').\n  /// \\param TemplateLoc the location of the 'template' keyword, if any.\n  /// \\param TemplateName The template name.\n  /// \\param TemplateII The identifier used to name the template.\n  /// \\param TemplateIILoc The location of the template name.\n  /// \\param LAngleLoc The location of the opening angle bracket  ('<').\n  /// \\param TemplateArgs The template arguments.\n  /// \\param RAngleLoc The location of the closing angle bracket  ('>').\n  TypeResult\n  ActOnTypenameType(Scope *S, SourceLocation TypenameLoc,\n                    const CXXScopeSpec &SS,\n                    SourceLocation TemplateLoc,\n                    TemplateTy TemplateName,\n                    IdentifierInfo *TemplateII,\n                    SourceLocation TemplateIILoc,\n                    SourceLocation LAngleLoc,\n                    ASTTemplateArgsPtr TemplateArgs,\n                    SourceLocation RAngleLoc);\n\n  QualType CheckTypenameType(ElaboratedTypeKeyword Keyword,\n                             SourceLocation KeywordLoc,\n                             NestedNameSpecifierLoc QualifierLoc,\n                             const IdentifierInfo &II,\n                             SourceLocation IILoc,\n                             TypeSourceInfo **TSI,\n                             bool DeducedTSTContext);\n\n  QualType CheckTypenameType(ElaboratedTypeKeyword Keyword,\n                             SourceLocation KeywordLoc,\n                             NestedNameSpecifierLoc QualifierLoc,\n                             const IdentifierInfo &II,\n                             SourceLocation IILoc,\n                             bool DeducedTSTContext = true);\n\n\n  TypeSourceInfo *RebuildTypeInCurrentInstantiation(TypeSourceInfo *T,\n                                                    SourceLocation Loc,\n                                                    DeclarationName Name);\n  bool RebuildNestedNameSpecifierInCurrentInstantiation(CXXScopeSpec &SS);\n\n  ExprResult RebuildExprInCurrentInstantiation(Expr *E);\n  bool RebuildTemplateParamsInCurrentInstantiation(\n                                                TemplateParameterList *Params);\n\n  std::string\n  getTemplateArgumentBindingsText(const TemplateParameterList *Params,\n                                  const TemplateArgumentList &Args);\n\n  std::string\n  getTemplateArgumentBindingsText(const TemplateParameterList *Params,\n                                  const TemplateArgument *Args,\n                                  unsigned NumArgs);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Concepts\n  //===--------------------------------------------------------------------===//\n  Decl *ActOnConceptDefinition(\n      Scope *S, MultiTemplateParamsArg TemplateParameterLists,\n      IdentifierInfo *Name, SourceLocation NameLoc, Expr *ConstraintExpr);\n\n  RequiresExprBodyDecl *\n  ActOnStartRequiresExpr(SourceLocation RequiresKWLoc,\n                         ArrayRef<ParmVarDecl *> LocalParameters,\n                         Scope *BodyScope);\n  void ActOnFinishRequiresExpr();\n  concepts::Requirement *ActOnSimpleRequirement(Expr *E);\n  concepts::Requirement *ActOnTypeRequirement(\n      SourceLocation TypenameKWLoc, CXXScopeSpec &SS, SourceLocation NameLoc,\n      IdentifierInfo *TypeName, TemplateIdAnnotation *TemplateId);\n  concepts::Requirement *ActOnCompoundRequirement(Expr *E,\n                                                  SourceLocation NoexceptLoc);\n  concepts::Requirement *\n  ActOnCompoundRequirement(\n      Expr *E, SourceLocation NoexceptLoc, CXXScopeSpec &SS,\n      TemplateIdAnnotation *TypeConstraint, unsigned Depth);\n  concepts::Requirement *ActOnNestedRequirement(Expr *Constraint);\n  concepts::ExprRequirement *\n  BuildExprRequirement(\n      Expr *E, bool IsSatisfied, SourceLocation NoexceptLoc,\n      concepts::ExprRequirement::ReturnTypeRequirement ReturnTypeRequirement);\n  concepts::ExprRequirement *\n  BuildExprRequirement(\n      concepts::Requirement::SubstitutionDiagnostic *ExprSubstDiag,\n      bool IsSatisfied, SourceLocation NoexceptLoc,\n      concepts::ExprRequirement::ReturnTypeRequirement ReturnTypeRequirement);\n  concepts::TypeRequirement *BuildTypeRequirement(TypeSourceInfo *Type);\n  concepts::TypeRequirement *\n  BuildTypeRequirement(\n      concepts::Requirement::SubstitutionDiagnostic *SubstDiag);\n  concepts::NestedRequirement *BuildNestedRequirement(Expr *E);\n  concepts::NestedRequirement *\n  BuildNestedRequirement(\n      concepts::Requirement::SubstitutionDiagnostic *SubstDiag);\n  ExprResult ActOnRequiresExpr(SourceLocation RequiresKWLoc,\n                               RequiresExprBodyDecl *Body,\n                               ArrayRef<ParmVarDecl *> LocalParameters,\n                               ArrayRef<concepts::Requirement *> Requirements,\n                               SourceLocation ClosingBraceLoc);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Variadic Templates (C++0x [temp.variadic])\n  //===--------------------------------------------------------------------===//\n\n  /// Determine whether an unexpanded parameter pack might be permitted in this\n  /// location. Useful for error recovery.\n  bool isUnexpandedParameterPackPermitted();\n\n  /// The context in which an unexpanded parameter pack is\n  /// being diagnosed.\n  ///\n  /// Note that the values of this enumeration line up with the first\n  /// argument to the \\c err_unexpanded_parameter_pack diagnostic.\n  enum UnexpandedParameterPackContext {\n    /// An arbitrary expression.\n    UPPC_Expression = 0,\n\n    /// The base type of a class type.\n    UPPC_BaseType,\n\n    /// The type of an arbitrary declaration.\n    UPPC_DeclarationType,\n\n    /// The type of a data member.\n    UPPC_DataMemberType,\n\n    /// The size of a bit-field.\n    UPPC_BitFieldWidth,\n\n    /// The expression in a static assertion.\n    UPPC_StaticAssertExpression,\n\n    /// The fixed underlying type of an enumeration.\n    UPPC_FixedUnderlyingType,\n\n    /// The enumerator value.\n    UPPC_EnumeratorValue,\n\n    /// A using declaration.\n    UPPC_UsingDeclaration,\n\n    /// A friend declaration.\n    UPPC_FriendDeclaration,\n\n    /// A declaration qualifier.\n    UPPC_DeclarationQualifier,\n\n    /// An initializer.\n    UPPC_Initializer,\n\n    /// A default argument.\n    UPPC_DefaultArgument,\n\n    /// The type of a non-type template parameter.\n    UPPC_NonTypeTemplateParameterType,\n\n    /// The type of an exception.\n    UPPC_ExceptionType,\n\n    /// Partial specialization.\n    UPPC_PartialSpecialization,\n\n    /// Microsoft __if_exists.\n    UPPC_IfExists,\n\n    /// Microsoft __if_not_exists.\n    UPPC_IfNotExists,\n\n    /// Lambda expression.\n    UPPC_Lambda,\n\n    /// Block expression.\n    UPPC_Block,\n\n    /// A type constraint.\n    UPPC_TypeConstraint,\n\n    // A requirement in a requires-expression.\n    UPPC_Requirement,\n\n    // A requires-clause.\n    UPPC_RequiresClause,\n  };\n\n  /// Diagnose unexpanded parameter packs.\n  ///\n  /// \\param Loc The location at which we should emit the diagnostic.\n  ///\n  /// \\param UPPC The context in which we are diagnosing unexpanded\n  /// parameter packs.\n  ///\n  /// \\param Unexpanded the set of unexpanded parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPacks(SourceLocation Loc,\n                                        UnexpandedParameterPackContext UPPC,\n                                  ArrayRef<UnexpandedParameterPack> Unexpanded);\n\n  /// If the given type contains an unexpanded parameter pack,\n  /// diagnose the error.\n  ///\n  /// \\param Loc The source location where a diagnostc should be emitted.\n  ///\n  /// \\param T The type that is being checked for unexpanded parameter\n  /// packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(SourceLocation Loc, TypeSourceInfo *T,\n                                       UnexpandedParameterPackContext UPPC);\n\n  /// If the given expression contains an unexpanded parameter\n  /// pack, diagnose the error.\n  ///\n  /// \\param E The expression that is being checked for unexpanded\n  /// parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(Expr *E,\n                       UnexpandedParameterPackContext UPPC = UPPC_Expression);\n\n  /// If the given requirees-expression contains an unexpanded reference to one\n  /// of its own parameter packs, diagnose the error.\n  ///\n  /// \\param RE The requiress-expression that is being checked for unexpanded\n  /// parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPackInRequiresExpr(RequiresExpr *RE);\n\n  /// If the given nested-name-specifier contains an unexpanded\n  /// parameter pack, diagnose the error.\n  ///\n  /// \\param SS The nested-name-specifier that is being checked for\n  /// unexpanded parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(const CXXScopeSpec &SS,\n                                       UnexpandedParameterPackContext UPPC);\n\n  /// If the given name contains an unexpanded parameter pack,\n  /// diagnose the error.\n  ///\n  /// \\param NameInfo The name (with source location information) that\n  /// is being checked for unexpanded parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(const DeclarationNameInfo &NameInfo,\n                                       UnexpandedParameterPackContext UPPC);\n\n  /// If the given template name contains an unexpanded parameter pack,\n  /// diagnose the error.\n  ///\n  /// \\param Loc The location of the template name.\n  ///\n  /// \\param Template The template name that is being checked for unexpanded\n  /// parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(SourceLocation Loc,\n                                       TemplateName Template,\n                                       UnexpandedParameterPackContext UPPC);\n\n  /// If the given template argument contains an unexpanded parameter\n  /// pack, diagnose the error.\n  ///\n  /// \\param Arg The template argument that is being checked for unexpanded\n  /// parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(TemplateArgumentLoc Arg,\n                                       UnexpandedParameterPackContext UPPC);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// template argument.\n  ///\n  /// \\param Arg The template argument that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(TemplateArgument Arg,\n                   SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// template argument.\n  ///\n  /// \\param Arg The template argument that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(TemplateArgumentLoc Arg,\n                    SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// type.\n  ///\n  /// \\param T The type that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(QualType T,\n                   SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// type.\n  ///\n  /// \\param TL The type that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(TypeLoc TL,\n                   SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// nested-name-specifier.\n  ///\n  /// \\param NNS The nested-name-specifier that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(NestedNameSpecifierLoc NNS,\n                         SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// name.\n  ///\n  /// \\param NameInfo The name that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(const DeclarationNameInfo &NameInfo,\n                         SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Invoked when parsing a template argument followed by an\n  /// ellipsis, which creates a pack expansion.\n  ///\n  /// \\param Arg The template argument preceding the ellipsis, which\n  /// may already be invalid.\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis.\n  ParsedTemplateArgument ActOnPackExpansion(const ParsedTemplateArgument &Arg,\n                                            SourceLocation EllipsisLoc);\n\n  /// Invoked when parsing a type followed by an ellipsis, which\n  /// creates a pack expansion.\n  ///\n  /// \\param Type The type preceding the ellipsis, which will become\n  /// the pattern of the pack expansion.\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis.\n  TypeResult ActOnPackExpansion(ParsedType Type, SourceLocation EllipsisLoc);\n\n  /// Construct a pack expansion type from the pattern of the pack\n  /// expansion.\n  TypeSourceInfo *CheckPackExpansion(TypeSourceInfo *Pattern,\n                                     SourceLocation EllipsisLoc,\n                                     Optional<unsigned> NumExpansions);\n\n  /// Construct a pack expansion type from the pattern of the pack\n  /// expansion.\n  QualType CheckPackExpansion(QualType Pattern,\n                              SourceRange PatternRange,\n                              SourceLocation EllipsisLoc,\n                              Optional<unsigned> NumExpansions);\n\n  /// Invoked when parsing an expression followed by an ellipsis, which\n  /// creates a pack expansion.\n  ///\n  /// \\param Pattern The expression preceding the ellipsis, which will become\n  /// the pattern of the pack expansion.\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis.\n  ExprResult ActOnPackExpansion(Expr *Pattern, SourceLocation EllipsisLoc);\n\n  /// Invoked when parsing an expression followed by an ellipsis, which\n  /// creates a pack expansion.\n  ///\n  /// \\param Pattern The expression preceding the ellipsis, which will become\n  /// the pattern of the pack expansion.\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis.\n  ExprResult CheckPackExpansion(Expr *Pattern, SourceLocation EllipsisLoc,\n                                Optional<unsigned> NumExpansions);\n\n  /// Determine whether we could expand a pack expansion with the\n  /// given set of parameter packs into separate arguments by repeatedly\n  /// transforming the pattern.\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis that identifies the\n  /// pack expansion.\n  ///\n  /// \\param PatternRange The source range that covers the entire pattern of\n  /// the pack expansion.\n  ///\n  /// \\param Unexpanded The set of unexpanded parameter packs within the\n  /// pattern.\n  ///\n  /// \\param ShouldExpand Will be set to \\c true if the transformer should\n  /// expand the corresponding pack expansions into separate arguments. When\n  /// set, \\c NumExpansions must also be set.\n  ///\n  /// \\param RetainExpansion Whether the caller should add an unexpanded\n  /// pack expansion after all of the expanded arguments. This is used\n  /// when extending explicitly-specified template argument packs per\n  /// C++0x [temp.arg.explicit]p9.\n  ///\n  /// \\param NumExpansions The number of separate arguments that will be in\n  /// the expanded form of the corresponding pack expansion. This is both an\n  /// input and an output parameter, which can be set by the caller if the\n  /// number of expansions is known a priori (e.g., due to a prior substitution)\n  /// and will be set by the callee when the number of expansions is known.\n  /// The callee must set this value when \\c ShouldExpand is \\c true; it may\n  /// set this value in other cases.\n  ///\n  /// \\returns true if an error occurred (e.g., because the parameter packs\n  /// are to be instantiated with arguments of different lengths), false\n  /// otherwise. If false, \\c ShouldExpand (and possibly \\c NumExpansions)\n  /// must be set.\n  bool CheckParameterPacksForExpansion(SourceLocation EllipsisLoc,\n                                       SourceRange PatternRange,\n                             ArrayRef<UnexpandedParameterPack> Unexpanded,\n                             const MultiLevelTemplateArgumentList &TemplateArgs,\n                                       bool &ShouldExpand,\n                                       bool &RetainExpansion,\n                                       Optional<unsigned> &NumExpansions);\n\n  /// Determine the number of arguments in the given pack expansion\n  /// type.\n  ///\n  /// This routine assumes that the number of arguments in the expansion is\n  /// consistent across all of the unexpanded parameter packs in its pattern.\n  ///\n  /// Returns an empty Optional if the type can't be expanded.\n  Optional<unsigned> getNumArgumentsInExpansion(QualType T,\n      const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  /// Determine whether the given declarator contains any unexpanded\n  /// parameter packs.\n  ///\n  /// This routine is used by the parser to disambiguate function declarators\n  /// with an ellipsis prior to the ')', e.g.,\n  ///\n  /// \\code\n  ///   void f(T...);\n  /// \\endcode\n  ///\n  /// To determine whether we have an (unnamed) function parameter pack or\n  /// a variadic function.\n  ///\n  /// \\returns true if the declarator contains any unexpanded parameter packs,\n  /// false otherwise.\n  bool containsUnexpandedParameterPacks(Declarator &D);\n\n  /// Returns the pattern of the pack expansion for a template argument.\n  ///\n  /// \\param OrigLoc The template argument to expand.\n  ///\n  /// \\param Ellipsis Will be set to the location of the ellipsis.\n  ///\n  /// \\param NumExpansions Will be set to the number of expansions that will\n  /// be generated from this pack expansion, if known a priori.\n  TemplateArgumentLoc getTemplateArgumentPackExpansionPattern(\n      TemplateArgumentLoc OrigLoc,\n      SourceLocation &Ellipsis,\n      Optional<unsigned> &NumExpansions) const;\n\n  /// Given a template argument that contains an unexpanded parameter pack, but\n  /// which has already been substituted, attempt to determine the number of\n  /// elements that will be produced once this argument is fully-expanded.\n  ///\n  /// This is intended for use when transforming 'sizeof...(Arg)' in order to\n  /// avoid actually expanding the pack where possible.\n  Optional<unsigned> getFullyPackExpandedSize(TemplateArgument Arg);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Template Argument Deduction (C++ [temp.deduct])\n  //===--------------------------------------------------------------------===//\n\n  /// Adjust the type \\p ArgFunctionType to match the calling convention,\n  /// noreturn, and optionally the exception specification of \\p FunctionType.\n  /// Deduction often wants to ignore these properties when matching function\n  /// types.\n  QualType adjustCCAndNoReturn(QualType ArgFunctionType, QualType FunctionType,\n                               bool AdjustExceptionSpec = false);\n\n  /// Describes the result of template argument deduction.\n  ///\n  /// The TemplateDeductionResult enumeration describes the result of\n  /// template argument deduction, as returned from\n  /// DeduceTemplateArguments(). The separate TemplateDeductionInfo\n  /// structure provides additional information about the results of\n  /// template argument deduction, e.g., the deduced template argument\n  /// list (if successful) or the specific template parameters or\n  /// deduced arguments that were involved in the failure.\n  enum TemplateDeductionResult {\n    /// Template argument deduction was successful.\n    TDK_Success = 0,\n    /// The declaration was invalid; do nothing.\n    TDK_Invalid,\n    /// Template argument deduction exceeded the maximum template\n    /// instantiation depth (which has already been diagnosed).\n    TDK_InstantiationDepth,\n    /// Template argument deduction did not deduce a value\n    /// for every template parameter.\n    TDK_Incomplete,\n    /// Template argument deduction did not deduce a value for every\n    /// expansion of an expanded template parameter pack.\n    TDK_IncompletePack,\n    /// Template argument deduction produced inconsistent\n    /// deduced values for the given template parameter.\n    TDK_Inconsistent,\n    /// Template argument deduction failed due to inconsistent\n    /// cv-qualifiers on a template parameter type that would\n    /// otherwise be deduced, e.g., we tried to deduce T in \"const T\"\n    /// but were given a non-const \"X\".\n    TDK_Underqualified,\n    /// Substitution of the deduced template argument values\n    /// resulted in an error.\n    TDK_SubstitutionFailure,\n    /// After substituting deduced template arguments, a dependent\n    /// parameter type did not match the corresponding argument.\n    TDK_DeducedMismatch,\n    /// After substituting deduced template arguments, an element of\n    /// a dependent parameter type did not match the corresponding element\n    /// of the corresponding argument (when deducing from an initializer list).\n    TDK_DeducedMismatchNested,\n    /// A non-depnedent component of the parameter did not match the\n    /// corresponding component of the argument.\n    TDK_NonDeducedMismatch,\n    /// When performing template argument deduction for a function\n    /// template, there were too many call arguments.\n    TDK_TooManyArguments,\n    /// When performing template argument deduction for a function\n    /// template, there were too few call arguments.\n    TDK_TooFewArguments,\n    /// The explicitly-specified template arguments were not valid\n    /// template arguments for the given template.\n    TDK_InvalidExplicitArguments,\n    /// Checking non-dependent argument conversions failed.\n    TDK_NonDependentConversionFailure,\n    /// The deduced arguments did not satisfy the constraints associated\n    /// with the template.\n    TDK_ConstraintsNotSatisfied,\n    /// Deduction failed; that's all we know.\n    TDK_MiscellaneousDeductionFailure,\n    /// CUDA Target attributes do not match.\n    TDK_CUDATargetMismatch\n  };\n\n  TemplateDeductionResult\n  DeduceTemplateArguments(ClassTemplatePartialSpecializationDecl *Partial,\n                          const TemplateArgumentList &TemplateArgs,\n                          sema::TemplateDeductionInfo &Info);\n\n  TemplateDeductionResult\n  DeduceTemplateArguments(VarTemplatePartialSpecializationDecl *Partial,\n                          const TemplateArgumentList &TemplateArgs,\n                          sema::TemplateDeductionInfo &Info);\n\n  TemplateDeductionResult SubstituteExplicitTemplateArguments(\n      FunctionTemplateDecl *FunctionTemplate,\n      TemplateArgumentListInfo &ExplicitTemplateArgs,\n      SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n      SmallVectorImpl<QualType> &ParamTypes, QualType *FunctionType,\n      sema::TemplateDeductionInfo &Info);\n\n  /// brief A function argument from which we performed template argument\n  // deduction for a call.\n  struct OriginalCallArg {\n    OriginalCallArg(QualType OriginalParamType, bool DecomposedParam,\n                    unsigned ArgIdx, QualType OriginalArgType)\n        : OriginalParamType(OriginalParamType),\n          DecomposedParam(DecomposedParam), ArgIdx(ArgIdx),\n          OriginalArgType(OriginalArgType) {}\n\n    QualType OriginalParamType;\n    bool DecomposedParam;\n    unsigned ArgIdx;\n    QualType OriginalArgType;\n  };\n\n  TemplateDeductionResult FinishTemplateArgumentDeduction(\n      FunctionTemplateDecl *FunctionTemplate,\n      SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n      unsigned NumExplicitlySpecified, FunctionDecl *&Specialization,\n      sema::TemplateDeductionInfo &Info,\n      SmallVectorImpl<OriginalCallArg> const *OriginalCallArgs = nullptr,\n      bool PartialOverloading = false,\n      llvm::function_ref<bool()> CheckNonDependent = []{ return false; });\n\n  TemplateDeductionResult DeduceTemplateArguments(\n      FunctionTemplateDecl *FunctionTemplate,\n      TemplateArgumentListInfo *ExplicitTemplateArgs, ArrayRef<Expr *> Args,\n      FunctionDecl *&Specialization, sema::TemplateDeductionInfo &Info,\n      bool PartialOverloading,\n      llvm::function_ref<bool(ArrayRef<QualType>)> CheckNonDependent);\n\n  TemplateDeductionResult\n  DeduceTemplateArguments(FunctionTemplateDecl *FunctionTemplate,\n                          TemplateArgumentListInfo *ExplicitTemplateArgs,\n                          QualType ArgFunctionType,\n                          FunctionDecl *&Specialization,\n                          sema::TemplateDeductionInfo &Info,\n                          bool IsAddressOfFunction = false);\n\n  TemplateDeductionResult\n  DeduceTemplateArguments(FunctionTemplateDecl *FunctionTemplate,\n                          QualType ToType,\n                          CXXConversionDecl *&Specialization,\n                          sema::TemplateDeductionInfo &Info);\n\n  TemplateDeductionResult\n  DeduceTemplateArguments(FunctionTemplateDecl *FunctionTemplate,\n                          TemplateArgumentListInfo *ExplicitTemplateArgs,\n                          FunctionDecl *&Specialization,\n                          sema::TemplateDeductionInfo &Info,\n                          bool IsAddressOfFunction = false);\n\n  /// Substitute Replacement for \\p auto in \\p TypeWithAuto\n  QualType SubstAutoType(QualType TypeWithAuto, QualType Replacement);\n  /// Substitute Replacement for auto in TypeWithAuto\n  TypeSourceInfo* SubstAutoTypeSourceInfo(TypeSourceInfo *TypeWithAuto,\n                                          QualType Replacement);\n  /// Completely replace the \\c auto in \\p TypeWithAuto by\n  /// \\p Replacement. This does not retain any \\c auto type sugar.\n  QualType ReplaceAutoType(QualType TypeWithAuto, QualType Replacement);\n  TypeSourceInfo *ReplaceAutoTypeSourceInfo(TypeSourceInfo *TypeWithAuto,\n                                            QualType Replacement);\n\n  /// Result type of DeduceAutoType.\n  enum DeduceAutoResult {\n    DAR_Succeeded,\n    DAR_Failed,\n    DAR_FailedAlreadyDiagnosed\n  };\n\n  DeduceAutoResult\n  DeduceAutoType(TypeSourceInfo *AutoType, Expr *&Initializer, QualType &Result,\n                 Optional<unsigned> DependentDeductionDepth = None,\n                 bool IgnoreConstraints = false);\n  DeduceAutoResult\n  DeduceAutoType(TypeLoc AutoTypeLoc, Expr *&Initializer, QualType &Result,\n                 Optional<unsigned> DependentDeductionDepth = None,\n                 bool IgnoreConstraints = false);\n  void DiagnoseAutoDeductionFailure(VarDecl *VDecl, Expr *Init);\n  bool DeduceReturnType(FunctionDecl *FD, SourceLocation Loc,\n                        bool Diagnose = true);\n\n  /// Declare implicit deduction guides for a class template if we've\n  /// not already done so.\n  void DeclareImplicitDeductionGuides(TemplateDecl *Template,\n                                      SourceLocation Loc);\n\n  QualType DeduceTemplateSpecializationFromInitializer(\n      TypeSourceInfo *TInfo, const InitializedEntity &Entity,\n      const InitializationKind &Kind, MultiExprArg Init);\n\n  QualType deduceVarTypeFromInitializer(VarDecl *VDecl, DeclarationName Name,\n                                        QualType Type, TypeSourceInfo *TSI,\n                                        SourceRange Range, bool DirectInit,\n                                        Expr *Init);\n\n  TypeLoc getReturnTypeLoc(FunctionDecl *FD) const;\n\n  bool DeduceFunctionTypeFromReturnExpr(FunctionDecl *FD,\n                                        SourceLocation ReturnLoc,\n                                        Expr *&RetExpr, AutoType *AT);\n\n  FunctionTemplateDecl *getMoreSpecializedTemplate(\n      FunctionTemplateDecl *FT1, FunctionTemplateDecl *FT2, SourceLocation Loc,\n      TemplatePartialOrderingContext TPOC, unsigned NumCallArguments1,\n      unsigned NumCallArguments2, bool Reversed = false);\n  UnresolvedSetIterator\n  getMostSpecialized(UnresolvedSetIterator SBegin, UnresolvedSetIterator SEnd,\n                     TemplateSpecCandidateSet &FailedCandidates,\n                     SourceLocation Loc,\n                     const PartialDiagnostic &NoneDiag,\n                     const PartialDiagnostic &AmbigDiag,\n                     const PartialDiagnostic &CandidateDiag,\n                     bool Complain = true, QualType TargetType = QualType());\n\n  ClassTemplatePartialSpecializationDecl *\n  getMoreSpecializedPartialSpecialization(\n                                  ClassTemplatePartialSpecializationDecl *PS1,\n                                  ClassTemplatePartialSpecializationDecl *PS2,\n                                  SourceLocation Loc);\n\n  bool isMoreSpecializedThanPrimary(ClassTemplatePartialSpecializationDecl *T,\n                                    sema::TemplateDeductionInfo &Info);\n\n  VarTemplatePartialSpecializationDecl *getMoreSpecializedPartialSpecialization(\n      VarTemplatePartialSpecializationDecl *PS1,\n      VarTemplatePartialSpecializationDecl *PS2, SourceLocation Loc);\n\n  bool isMoreSpecializedThanPrimary(VarTemplatePartialSpecializationDecl *T,\n                                    sema::TemplateDeductionInfo &Info);\n\n  bool isTemplateTemplateParameterAtLeastAsSpecializedAs(\n      TemplateParameterList *PParam, TemplateDecl *AArg, SourceLocation Loc);\n\n  void MarkUsedTemplateParameters(const Expr *E, bool OnlyDeduced,\n                                  unsigned Depth, llvm::SmallBitVector &Used);\n\n  void MarkUsedTemplateParameters(const TemplateArgumentList &TemplateArgs,\n                                  bool OnlyDeduced,\n                                  unsigned Depth,\n                                  llvm::SmallBitVector &Used);\n  void MarkDeducedTemplateParameters(\n                                  const FunctionTemplateDecl *FunctionTemplate,\n                                  llvm::SmallBitVector &Deduced) {\n    return MarkDeducedTemplateParameters(Context, FunctionTemplate, Deduced);\n  }\n  static void MarkDeducedTemplateParameters(ASTContext &Ctx,\n                                  const FunctionTemplateDecl *FunctionTemplate,\n                                  llvm::SmallBitVector &Deduced);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Template Instantiation\n  //\n\n  MultiLevelTemplateArgumentList\n  getTemplateInstantiationArgs(NamedDecl *D,\n                               const TemplateArgumentList *Innermost = nullptr,\n                               bool RelativeToPrimary = false,\n                               const FunctionDecl *Pattern = nullptr);\n\n  /// A context in which code is being synthesized (where a source location\n  /// alone is not sufficient to identify the context). This covers template\n  /// instantiation and various forms of implicitly-generated functions.\n  struct CodeSynthesisContext {\n    /// The kind of template instantiation we are performing\n    enum SynthesisKind {\n      /// We are instantiating a template declaration. The entity is\n      /// the declaration we're instantiating (e.g., a CXXRecordDecl).\n      TemplateInstantiation,\n\n      /// We are instantiating a default argument for a template\n      /// parameter. The Entity is the template parameter whose argument is\n      /// being instantiated, the Template is the template, and the\n      /// TemplateArgs/NumTemplateArguments provide the template arguments as\n      /// specified.\n      DefaultTemplateArgumentInstantiation,\n\n      /// We are instantiating a default argument for a function.\n      /// The Entity is the ParmVarDecl, and TemplateArgs/NumTemplateArgs\n      /// provides the template arguments as specified.\n      DefaultFunctionArgumentInstantiation,\n\n      /// We are substituting explicit template arguments provided for\n      /// a function template. The entity is a FunctionTemplateDecl.\n      ExplicitTemplateArgumentSubstitution,\n\n      /// We are substituting template argument determined as part of\n      /// template argument deduction for either a class template\n      /// partial specialization or a function template. The\n      /// Entity is either a {Class|Var}TemplatePartialSpecializationDecl or\n      /// a TemplateDecl.\n      DeducedTemplateArgumentSubstitution,\n\n      /// We are substituting prior template arguments into a new\n      /// template parameter. The template parameter itself is either a\n      /// NonTypeTemplateParmDecl or a TemplateTemplateParmDecl.\n      PriorTemplateArgumentSubstitution,\n\n      /// We are checking the validity of a default template argument that\n      /// has been used when naming a template-id.\n      DefaultTemplateArgumentChecking,\n\n      /// We are computing the exception specification for a defaulted special\n      /// member function.\n      ExceptionSpecEvaluation,\n\n      /// We are instantiating the exception specification for a function\n      /// template which was deferred until it was needed.\n      ExceptionSpecInstantiation,\n\n      /// We are instantiating a requirement of a requires expression.\n      RequirementInstantiation,\n\n      /// We are checking the satisfaction of a nested requirement of a requires\n      /// expression.\n      NestedRequirementConstraintsCheck,\n\n      /// We are declaring an implicit special member function.\n      DeclaringSpecialMember,\n\n      /// We are declaring an implicit 'operator==' for a defaulted\n      /// 'operator<=>'.\n      DeclaringImplicitEqualityComparison,\n\n      /// We are defining a synthesized function (such as a defaulted special\n      /// member).\n      DefiningSynthesizedFunction,\n\n      // We are checking the constraints associated with a constrained entity or\n      // the constraint expression of a concept. This includes the checks that\n      // atomic constraints have the type 'bool' and that they can be constant\n      // evaluated.\n      ConstraintsCheck,\n\n      // We are substituting template arguments into a constraint expression.\n      ConstraintSubstitution,\n\n      // We are normalizing a constraint expression.\n      ConstraintNormalization,\n\n      // We are substituting into the parameter mapping of an atomic constraint\n      // during normalization.\n      ParameterMappingSubstitution,\n\n      /// We are rewriting a comparison operator in terms of an operator<=>.\n      RewritingOperatorAsSpaceship,\n\n      /// We are initializing a structured binding.\n      InitializingStructuredBinding,\n\n      /// We are marking a class as __dllexport.\n      MarkingClassDllexported,\n\n      /// Added for Template instantiation observation.\n      /// Memoization means we are _not_ instantiating a template because\n      /// it is already instantiated (but we entered a context where we\n      /// would have had to if it was not already instantiated).\n      Memoization\n    } Kind;\n\n    /// Was the enclosing context a non-instantiation SFINAE context?\n    bool SavedInNonInstantiationSFINAEContext;\n\n    /// The point of instantiation or synthesis within the source code.\n    SourceLocation PointOfInstantiation;\n\n    /// The entity that is being synthesized.\n    Decl *Entity;\n\n    /// The template (or partial specialization) in which we are\n    /// performing the instantiation, for substitutions of prior template\n    /// arguments.\n    NamedDecl *Template;\n\n    /// The list of template arguments we are substituting, if they\n    /// are not part of the entity.\n    const TemplateArgument *TemplateArgs;\n\n    // FIXME: Wrap this union around more members, or perhaps store the\n    // kind-specific members in the RAII object owning the context.\n    union {\n      /// The number of template arguments in TemplateArgs.\n      unsigned NumTemplateArgs;\n\n      /// The special member being declared or defined.\n      CXXSpecialMember SpecialMember;\n    };\n\n    ArrayRef<TemplateArgument> template_arguments() const {\n      assert(Kind != DeclaringSpecialMember);\n      return {TemplateArgs, NumTemplateArgs};\n    }\n\n    /// The template deduction info object associated with the\n    /// substitution or checking of explicit or deduced template arguments.\n    sema::TemplateDeductionInfo *DeductionInfo;\n\n    /// The source range that covers the construct that cause\n    /// the instantiation, e.g., the template-id that causes a class\n    /// template instantiation.\n    SourceRange InstantiationRange;\n\n    CodeSynthesisContext()\n        : Kind(TemplateInstantiation),\n          SavedInNonInstantiationSFINAEContext(false), Entity(nullptr),\n          Template(nullptr), TemplateArgs(nullptr), NumTemplateArgs(0),\n          DeductionInfo(nullptr) {}\n\n    /// Determines whether this template is an actual instantiation\n    /// that should be counted toward the maximum instantiation depth.\n    bool isInstantiationRecord() const;\n  };\n\n  /// List of active code synthesis contexts.\n  ///\n  /// This vector is treated as a stack. As synthesis of one entity requires\n  /// synthesis of another, additional contexts are pushed onto the stack.\n  SmallVector<CodeSynthesisContext, 16> CodeSynthesisContexts;\n\n  /// Specializations whose definitions are currently being instantiated.\n  llvm::DenseSet<std::pair<Decl *, unsigned>> InstantiatingSpecializations;\n\n  /// Non-dependent types used in templates that have already been instantiated\n  /// by some template instantiation.\n  llvm::DenseSet<QualType> InstantiatedNonDependentTypes;\n\n  /// Extra modules inspected when performing a lookup during a template\n  /// instantiation. Computed lazily.\n  SmallVector<Module*, 16> CodeSynthesisContextLookupModules;\n\n  /// Cache of additional modules that should be used for name lookup\n  /// within the current template instantiation. Computed lazily; use\n  /// getLookupModules() to get a complete set.\n  llvm::DenseSet<Module*> LookupModulesCache;\n\n  /// Get the set of additional modules that should be checked during\n  /// name lookup. A module and its imports become visible when instanting a\n  /// template defined within it.\n  llvm::DenseSet<Module*> &getLookupModules();\n\n  /// Map from the most recent declaration of a namespace to the most\n  /// recent visible declaration of that namespace.\n  llvm::DenseMap<NamedDecl*, NamedDecl*> VisibleNamespaceCache;\n\n  /// Whether we are in a SFINAE context that is not associated with\n  /// template instantiation.\n  ///\n  /// This is used when setting up a SFINAE trap (\\c see SFINAETrap) outside\n  /// of a template instantiation or template argument deduction.\n  bool InNonInstantiationSFINAEContext;\n\n  /// The number of \\p CodeSynthesisContexts that are not template\n  /// instantiations and, therefore, should not be counted as part of the\n  /// instantiation depth.\n  ///\n  /// When the instantiation depth reaches the user-configurable limit\n  /// \\p LangOptions::InstantiationDepth we will abort instantiation.\n  // FIXME: Should we have a similar limit for other forms of synthesis?\n  unsigned NonInstantiationEntries;\n\n  /// The depth of the context stack at the point when the most recent\n  /// error or warning was produced.\n  ///\n  /// This value is used to suppress printing of redundant context stacks\n  /// when there are multiple errors or warnings in the same instantiation.\n  // FIXME: Does this belong in Sema? It's tough to implement it anywhere else.\n  unsigned LastEmittedCodeSynthesisContextDepth = 0;\n\n  /// The template instantiation callbacks to trace or track\n  /// instantiations (objects can be chained).\n  ///\n  /// This callbacks is used to print, trace or track template\n  /// instantiations as they are being constructed.\n  std::vector<std::unique_ptr<TemplateInstantiationCallback>>\n      TemplateInstCallbacks;\n\n  /// The current index into pack expansion arguments that will be\n  /// used for substitution of parameter packs.\n  ///\n  /// The pack expansion index will be -1 to indicate that parameter packs\n  /// should be instantiated as themselves. Otherwise, the index specifies\n  /// which argument within the parameter pack will be used for substitution.\n  int ArgumentPackSubstitutionIndex;\n\n  /// RAII object used to change the argument pack substitution index\n  /// within a \\c Sema object.\n  ///\n  /// See \\c ArgumentPackSubstitutionIndex for more information.\n  class ArgumentPackSubstitutionIndexRAII {\n    Sema &Self;\n    int OldSubstitutionIndex;\n\n  public:\n    ArgumentPackSubstitutionIndexRAII(Sema &Self, int NewSubstitutionIndex)\n      : Self(Self), OldSubstitutionIndex(Self.ArgumentPackSubstitutionIndex) {\n      Self.ArgumentPackSubstitutionIndex = NewSubstitutionIndex;\n    }\n\n    ~ArgumentPackSubstitutionIndexRAII() {\n      Self.ArgumentPackSubstitutionIndex = OldSubstitutionIndex;\n    }\n  };\n\n  friend class ArgumentPackSubstitutionRAII;\n\n  /// For each declaration that involved template argument deduction, the\n  /// set of diagnostics that were suppressed during that template argument\n  /// deduction.\n  ///\n  /// FIXME: Serialize this structure to the AST file.\n  typedef llvm::DenseMap<Decl *, SmallVector<PartialDiagnosticAt, 1> >\n    SuppressedDiagnosticsMap;\n  SuppressedDiagnosticsMap SuppressedDiagnostics;\n\n  /// A stack object to be created when performing template\n  /// instantiation.\n  ///\n  /// Construction of an object of type \\c InstantiatingTemplate\n  /// pushes the current instantiation onto the stack of active\n  /// instantiations. If the size of this stack exceeds the maximum\n  /// number of recursive template instantiations, construction\n  /// produces an error and evaluates true.\n  ///\n  /// Destruction of this object will pop the named instantiation off\n  /// the stack.\n  struct InstantiatingTemplate {\n    /// Note that we are instantiating a class template,\n    /// function template, variable template, alias template,\n    /// or a member thereof.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          Decl *Entity,\n                          SourceRange InstantiationRange = SourceRange());\n\n    struct ExceptionSpecification {};\n    /// Note that we are instantiating an exception specification\n    /// of a function template.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          FunctionDecl *Entity, ExceptionSpecification,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating a default argument in a\n    /// template-id.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          TemplateParameter Param, TemplateDecl *Template,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are substituting either explicitly-specified or\n    /// deduced template arguments during function template argument deduction.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          FunctionTemplateDecl *FunctionTemplate,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          CodeSynthesisContext::SynthesisKind Kind,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating as part of template\n    /// argument deduction for a class template declaration.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          TemplateDecl *Template,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating as part of template\n    /// argument deduction for a class template partial\n    /// specialization.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ClassTemplatePartialSpecializationDecl *PartialSpec,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating as part of template\n    /// argument deduction for a variable template partial\n    /// specialization.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          VarTemplatePartialSpecializationDecl *PartialSpec,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating a default argument for a function\n    /// parameter.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ParmVarDecl *Param,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are substituting prior template arguments into a\n    /// non-type parameter.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          NamedDecl *Template,\n                          NonTypeTemplateParmDecl *Param,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange);\n\n    /// Note that we are substituting prior template arguments into a\n    /// template template parameter.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          NamedDecl *Template,\n                          TemplateTemplateParmDecl *Param,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange);\n\n    /// Note that we are checking the default template argument\n    /// against the template parameter for a given template-id.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          TemplateDecl *Template,\n                          NamedDecl *Param,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange);\n\n    struct ConstraintsCheck {};\n    /// \\brief Note that we are checking the constraints associated with some\n    /// constrained entity (a concept declaration or a template with associated\n    /// constraints).\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ConstraintsCheck, NamedDecl *Template,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange);\n\n    struct ConstraintSubstitution {};\n    /// \\brief Note that we are checking a constraint expression associated\n    /// with a template declaration or as part of the satisfaction check of a\n    /// concept.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ConstraintSubstitution, NamedDecl *Template,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange);\n\n    struct ConstraintNormalization {};\n    /// \\brief Note that we are normalizing a constraint expression.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ConstraintNormalization, NamedDecl *Template,\n                          SourceRange InstantiationRange);\n\n    struct ParameterMappingSubstitution {};\n    /// \\brief Note that we are subtituting into the parameter mapping of an\n    /// atomic constraint during constraint normalization.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ParameterMappingSubstitution, NamedDecl *Template,\n                          SourceRange InstantiationRange);\n\n    /// \\brief Note that we are substituting template arguments into a part of\n    /// a requirement of a requires expression.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          concepts::Requirement *Req,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// \\brief Note that we are checking the satisfaction of the constraint\n    /// expression inside of a nested requirement.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          concepts::NestedRequirement *Req, ConstraintsCheck,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we have finished instantiating this template.\n    void Clear();\n\n    ~InstantiatingTemplate() { Clear(); }\n\n    /// Determines whether we have exceeded the maximum\n    /// recursive template instantiations.\n    bool isInvalid() const { return Invalid; }\n\n    /// Determine whether we are already instantiating this\n    /// specialization in some surrounding active instantiation.\n    bool isAlreadyInstantiating() const { return AlreadyInstantiating; }\n\n  private:\n    Sema &SemaRef;\n    bool Invalid;\n    bool AlreadyInstantiating;\n    bool CheckInstantiationDepth(SourceLocation PointOfInstantiation,\n                                 SourceRange InstantiationRange);\n\n    InstantiatingTemplate(\n        Sema &SemaRef, CodeSynthesisContext::SynthesisKind Kind,\n        SourceLocation PointOfInstantiation, SourceRange InstantiationRange,\n        Decl *Entity, NamedDecl *Template = nullptr,\n        ArrayRef<TemplateArgument> TemplateArgs = None,\n        sema::TemplateDeductionInfo *DeductionInfo = nullptr);\n\n    InstantiatingTemplate(const InstantiatingTemplate&) = delete;\n\n    InstantiatingTemplate&\n    operator=(const InstantiatingTemplate&) = delete;\n  };\n\n  void pushCodeSynthesisContext(CodeSynthesisContext Ctx);\n  void popCodeSynthesisContext();\n\n  /// Determine whether we are currently performing template instantiation.\n  bool inTemplateInstantiation() const {\n    return CodeSynthesisContexts.size() > NonInstantiationEntries;\n  }\n\n  void PrintContextStack() {\n    if (!CodeSynthesisContexts.empty() &&\n        CodeSynthesisContexts.size() != LastEmittedCodeSynthesisContextDepth) {\n      PrintInstantiationStack();\n      LastEmittedCodeSynthesisContextDepth = CodeSynthesisContexts.size();\n    }\n    if (PragmaAttributeCurrentTargetDecl)\n      PrintPragmaAttributeInstantiationPoint();\n  }\n  void PrintInstantiationStack();\n\n  void PrintPragmaAttributeInstantiationPoint();\n\n  /// Determines whether we are currently in a context where\n  /// template argument substitution failures are not considered\n  /// errors.\n  ///\n  /// \\returns An empty \\c Optional if we're not in a SFINAE context.\n  /// Otherwise, contains a pointer that, if non-NULL, contains the nearest\n  /// template-deduction context object, which can be used to capture\n  /// diagnostics that will be suppressed.\n  Optional<sema::TemplateDeductionInfo *> isSFINAEContext() const;\n\n  /// Determines whether we are currently in a context that\n  /// is not evaluated as per C++ [expr] p5.\n  bool isUnevaluatedContext() const {\n    assert(!ExprEvalContexts.empty() &&\n           \"Must be in an expression evaluation context\");\n    return ExprEvalContexts.back().isUnevaluated();\n  }\n\n  /// RAII class used to determine whether SFINAE has\n  /// trapped any errors that occur during template argument\n  /// deduction.\n  class SFINAETrap {\n    Sema &SemaRef;\n    unsigned PrevSFINAEErrors;\n    bool PrevInNonInstantiationSFINAEContext;\n    bool PrevAccessCheckingSFINAE;\n    bool PrevLastDiagnosticIgnored;\n\n  public:\n    explicit SFINAETrap(Sema &SemaRef, bool AccessCheckingSFINAE = false)\n      : SemaRef(SemaRef), PrevSFINAEErrors(SemaRef.NumSFINAEErrors),\n        PrevInNonInstantiationSFINAEContext(\n                                      SemaRef.InNonInstantiationSFINAEContext),\n        PrevAccessCheckingSFINAE(SemaRef.AccessCheckingSFINAE),\n        PrevLastDiagnosticIgnored(\n            SemaRef.getDiagnostics().isLastDiagnosticIgnored())\n    {\n      if (!SemaRef.isSFINAEContext())\n        SemaRef.InNonInstantiationSFINAEContext = true;\n      SemaRef.AccessCheckingSFINAE = AccessCheckingSFINAE;\n    }\n\n    ~SFINAETrap() {\n      SemaRef.NumSFINAEErrors = PrevSFINAEErrors;\n      SemaRef.InNonInstantiationSFINAEContext\n        = PrevInNonInstantiationSFINAEContext;\n      SemaRef.AccessCheckingSFINAE = PrevAccessCheckingSFINAE;\n      SemaRef.getDiagnostics().setLastDiagnosticIgnored(\n          PrevLastDiagnosticIgnored);\n    }\n\n    /// Determine whether any SFINAE errors have been trapped.\n    bool hasErrorOccurred() const {\n      return SemaRef.NumSFINAEErrors > PrevSFINAEErrors;\n    }\n  };\n\n  /// RAII class used to indicate that we are performing provisional\n  /// semantic analysis to determine the validity of a construct, so\n  /// typo-correction and diagnostics in the immediate context (not within\n  /// implicitly-instantiated templates) should be suppressed.\n  class TentativeAnalysisScope {\n    Sema &SemaRef;\n    // FIXME: Using a SFINAETrap for this is a hack.\n    SFINAETrap Trap;\n    bool PrevDisableTypoCorrection;\n  public:\n    explicit TentativeAnalysisScope(Sema &SemaRef)\n        : SemaRef(SemaRef), Trap(SemaRef, true),\n          PrevDisableTypoCorrection(SemaRef.DisableTypoCorrection) {\n      SemaRef.DisableTypoCorrection = true;\n    }\n    ~TentativeAnalysisScope() {\n      SemaRef.DisableTypoCorrection = PrevDisableTypoCorrection;\n    }\n  };\n\n  /// The current instantiation scope used to store local\n  /// variables.\n  LocalInstantiationScope *CurrentInstantiationScope;\n\n  /// Tracks whether we are in a context where typo correction is\n  /// disabled.\n  bool DisableTypoCorrection;\n\n  /// The number of typos corrected by CorrectTypo.\n  unsigned TyposCorrected;\n\n  typedef llvm::SmallSet<SourceLocation, 2> SrcLocSet;\n  typedef llvm::DenseMap<IdentifierInfo *, SrcLocSet> IdentifierSourceLocations;\n\n  /// A cache containing identifiers for which typo correction failed and\n  /// their locations, so that repeated attempts to correct an identifier in a\n  /// given location are ignored if typo correction already failed for it.\n  IdentifierSourceLocations TypoCorrectionFailures;\n\n  /// Worker object for performing CFG-based warnings.\n  sema::AnalysisBasedWarnings AnalysisWarnings;\n  threadSafety::BeforeSet *ThreadSafetyDeclCache;\n\n  /// An entity for which implicit template instantiation is required.\n  ///\n  /// The source location associated with the declaration is the first place in\n  /// the source code where the declaration was \"used\". It is not necessarily\n  /// the point of instantiation (which will be either before or after the\n  /// namespace-scope declaration that triggered this implicit instantiation),\n  /// However, it is the location that diagnostics should generally refer to,\n  /// because users will need to know what code triggered the instantiation.\n  typedef std::pair<ValueDecl *, SourceLocation> PendingImplicitInstantiation;\n\n  /// The queue of implicit template instantiations that are required\n  /// but have not yet been performed.\n  std::deque<PendingImplicitInstantiation> PendingInstantiations;\n\n  /// Queue of implicit template instantiations that cannot be performed\n  /// eagerly.\n  SmallVector<PendingImplicitInstantiation, 1> LateParsedInstantiations;\n\n  class GlobalEagerInstantiationScope {\n  public:\n    GlobalEagerInstantiationScope(Sema &S, bool Enabled)\n        : S(S), Enabled(Enabled) {\n      if (!Enabled) return;\n\n      SavedPendingInstantiations.swap(S.PendingInstantiations);\n      SavedVTableUses.swap(S.VTableUses);\n    }\n\n    void perform() {\n      if (Enabled) {\n        S.DefineUsedVTables();\n        S.PerformPendingInstantiations();\n      }\n    }\n\n    ~GlobalEagerInstantiationScope() {\n      if (!Enabled) return;\n\n      // Restore the set of pending vtables.\n      assert(S.VTableUses.empty() &&\n             \"VTableUses should be empty before it is discarded.\");\n      S.VTableUses.swap(SavedVTableUses);\n\n      // Restore the set of pending implicit instantiations.\n      if (S.TUKind != TU_Prefix || !S.LangOpts.PCHInstantiateTemplates) {\n        assert(S.PendingInstantiations.empty() &&\n               \"PendingInstantiations should be empty before it is discarded.\");\n        S.PendingInstantiations.swap(SavedPendingInstantiations);\n      } else {\n        // Template instantiations in the PCH may be delayed until the TU.\n        S.PendingInstantiations.swap(SavedPendingInstantiations);\n        S.PendingInstantiations.insert(S.PendingInstantiations.end(),\n                                       SavedPendingInstantiations.begin(),\n                                       SavedPendingInstantiations.end());\n      }\n    }\n\n  private:\n    Sema &S;\n    SmallVector<VTableUse, 16> SavedVTableUses;\n    std::deque<PendingImplicitInstantiation> SavedPendingInstantiations;\n    bool Enabled;\n  };\n\n  /// The queue of implicit template instantiations that are required\n  /// and must be performed within the current local scope.\n  ///\n  /// This queue is only used for member functions of local classes in\n  /// templates, which must be instantiated in the same scope as their\n  /// enclosing function, so that they can reference function-local\n  /// types, static variables, enumerators, etc.\n  std::deque<PendingImplicitInstantiation> PendingLocalImplicitInstantiations;\n\n  class LocalEagerInstantiationScope {\n  public:\n    LocalEagerInstantiationScope(Sema &S) : S(S) {\n      SavedPendingLocalImplicitInstantiations.swap(\n          S.PendingLocalImplicitInstantiations);\n    }\n\n    void perform() { S.PerformPendingInstantiations(/*LocalOnly=*/true); }\n\n    ~LocalEagerInstantiationScope() {\n      assert(S.PendingLocalImplicitInstantiations.empty() &&\n             \"there shouldn't be any pending local implicit instantiations\");\n      SavedPendingLocalImplicitInstantiations.swap(\n          S.PendingLocalImplicitInstantiations);\n    }\n\n  private:\n    Sema &S;\n    std::deque<PendingImplicitInstantiation>\n        SavedPendingLocalImplicitInstantiations;\n  };\n\n  /// A helper class for building up ExtParameterInfos.\n  class ExtParameterInfoBuilder {\n    SmallVector<FunctionProtoType::ExtParameterInfo, 16> Infos;\n    bool HasInteresting = false;\n\n  public:\n    /// Set the ExtParameterInfo for the parameter at the given index,\n    ///\n    void set(unsigned index, FunctionProtoType::ExtParameterInfo info) {\n      assert(Infos.size() <= index);\n      Infos.resize(index);\n      Infos.push_back(info);\n\n      if (!HasInteresting)\n        HasInteresting = (info != FunctionProtoType::ExtParameterInfo());\n    }\n\n    /// Return a pointer (suitable for setting in an ExtProtoInfo) to the\n    /// ExtParameterInfo array we've built up.\n    const FunctionProtoType::ExtParameterInfo *\n    getPointerOrNull(unsigned numParams) {\n      if (!HasInteresting) return nullptr;\n      Infos.resize(numParams);\n      return Infos.data();\n    }\n  };\n\n  void PerformPendingInstantiations(bool LocalOnly = false);\n\n  TypeSourceInfo *SubstType(TypeSourceInfo *T,\n                            const MultiLevelTemplateArgumentList &TemplateArgs,\n                            SourceLocation Loc, DeclarationName Entity,\n                            bool AllowDeducedTST = false);\n\n  QualType SubstType(QualType T,\n                     const MultiLevelTemplateArgumentList &TemplateArgs,\n                     SourceLocation Loc, DeclarationName Entity);\n\n  TypeSourceInfo *SubstType(TypeLoc TL,\n                            const MultiLevelTemplateArgumentList &TemplateArgs,\n                            SourceLocation Loc, DeclarationName Entity);\n\n  TypeSourceInfo *SubstFunctionDeclType(TypeSourceInfo *T,\n                            const MultiLevelTemplateArgumentList &TemplateArgs,\n                                        SourceLocation Loc,\n                                        DeclarationName Entity,\n                                        CXXRecordDecl *ThisContext,\n                                        Qualifiers ThisTypeQuals);\n  void SubstExceptionSpec(FunctionDecl *New, const FunctionProtoType *Proto,\n                          const MultiLevelTemplateArgumentList &Args);\n  bool SubstExceptionSpec(SourceLocation Loc,\n                          FunctionProtoType::ExceptionSpecInfo &ESI,\n                          SmallVectorImpl<QualType> &ExceptionStorage,\n                          const MultiLevelTemplateArgumentList &Args);\n  ParmVarDecl *SubstParmVarDecl(ParmVarDecl *D,\n                            const MultiLevelTemplateArgumentList &TemplateArgs,\n                                int indexAdjustment,\n                                Optional<unsigned> NumExpansions,\n                                bool ExpectParameterPack);\n  bool SubstParmTypes(SourceLocation Loc, ArrayRef<ParmVarDecl *> Params,\n                      const FunctionProtoType::ExtParameterInfo *ExtParamInfos,\n                      const MultiLevelTemplateArgumentList &TemplateArgs,\n                      SmallVectorImpl<QualType> &ParamTypes,\n                      SmallVectorImpl<ParmVarDecl *> *OutParams,\n                      ExtParameterInfoBuilder &ParamInfos);\n  ExprResult SubstExpr(Expr *E,\n                       const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  /// Substitute the given template arguments into a list of\n  /// expressions, expanding pack expansions if required.\n  ///\n  /// \\param Exprs The list of expressions to substitute into.\n  ///\n  /// \\param IsCall Whether this is some form of call, in which case\n  /// default arguments will be dropped.\n  ///\n  /// \\param TemplateArgs The set of template arguments to substitute.\n  ///\n  /// \\param Outputs Will receive all of the substituted arguments.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool SubstExprs(ArrayRef<Expr *> Exprs, bool IsCall,\n                  const MultiLevelTemplateArgumentList &TemplateArgs,\n                  SmallVectorImpl<Expr *> &Outputs);\n\n  StmtResult SubstStmt(Stmt *S,\n                       const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  TemplateParameterList *\n  SubstTemplateParams(TemplateParameterList *Params, DeclContext *Owner,\n                      const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  bool\n  SubstTemplateArguments(ArrayRef<TemplateArgumentLoc> Args,\n                         const MultiLevelTemplateArgumentList &TemplateArgs,\n                         TemplateArgumentListInfo &Outputs);\n\n\n  Decl *SubstDecl(Decl *D, DeclContext *Owner,\n                  const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  /// Substitute the name and return type of a defaulted 'operator<=>' to form\n  /// an implicit 'operator=='.\n  FunctionDecl *SubstSpaceshipAsEqualEqual(CXXRecordDecl *RD,\n                                           FunctionDecl *Spaceship);\n\n  ExprResult SubstInitializer(Expr *E,\n                       const MultiLevelTemplateArgumentList &TemplateArgs,\n                       bool CXXDirectInit);\n\n  bool\n  SubstBaseSpecifiers(CXXRecordDecl *Instantiation,\n                      CXXRecordDecl *Pattern,\n                      const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  bool\n  InstantiateClass(SourceLocation PointOfInstantiation,\n                   CXXRecordDecl *Instantiation, CXXRecordDecl *Pattern,\n                   const MultiLevelTemplateArgumentList &TemplateArgs,\n                   TemplateSpecializationKind TSK,\n                   bool Complain = true);\n\n  bool InstantiateEnum(SourceLocation PointOfInstantiation,\n                       EnumDecl *Instantiation, EnumDecl *Pattern,\n                       const MultiLevelTemplateArgumentList &TemplateArgs,\n                       TemplateSpecializationKind TSK);\n\n  bool InstantiateInClassInitializer(\n      SourceLocation PointOfInstantiation, FieldDecl *Instantiation,\n      FieldDecl *Pattern, const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  struct LateInstantiatedAttribute {\n    const Attr *TmplAttr;\n    LocalInstantiationScope *Scope;\n    Decl *NewDecl;\n\n    LateInstantiatedAttribute(const Attr *A, LocalInstantiationScope *S,\n                              Decl *D)\n      : TmplAttr(A), Scope(S), NewDecl(D)\n    { }\n  };\n  typedef SmallVector<LateInstantiatedAttribute, 16> LateInstantiatedAttrVec;\n\n  void InstantiateAttrs(const MultiLevelTemplateArgumentList &TemplateArgs,\n                        const Decl *Pattern, Decl *Inst,\n                        LateInstantiatedAttrVec *LateAttrs = nullptr,\n                        LocalInstantiationScope *OuterMostScope = nullptr);\n\n  void\n  InstantiateAttrsForDecl(const MultiLevelTemplateArgumentList &TemplateArgs,\n                          const Decl *Pattern, Decl *Inst,\n                          LateInstantiatedAttrVec *LateAttrs = nullptr,\n                          LocalInstantiationScope *OuterMostScope = nullptr);\n\n  void InstantiateDefaultCtorDefaultArgs(CXXConstructorDecl *Ctor);\n\n  bool usesPartialOrExplicitSpecialization(\n      SourceLocation Loc, ClassTemplateSpecializationDecl *ClassTemplateSpec);\n\n  bool\n  InstantiateClassTemplateSpecialization(SourceLocation PointOfInstantiation,\n                           ClassTemplateSpecializationDecl *ClassTemplateSpec,\n                           TemplateSpecializationKind TSK,\n                           bool Complain = true);\n\n  void InstantiateClassMembers(SourceLocation PointOfInstantiation,\n                               CXXRecordDecl *Instantiation,\n                            const MultiLevelTemplateArgumentList &TemplateArgs,\n                               TemplateSpecializationKind TSK);\n\n  void InstantiateClassTemplateSpecializationMembers(\n                                          SourceLocation PointOfInstantiation,\n                           ClassTemplateSpecializationDecl *ClassTemplateSpec,\n                                                TemplateSpecializationKind TSK);\n\n  NestedNameSpecifierLoc\n  SubstNestedNameSpecifierLoc(NestedNameSpecifierLoc NNS,\n                           const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  DeclarationNameInfo\n  SubstDeclarationNameInfo(const DeclarationNameInfo &NameInfo,\n                           const MultiLevelTemplateArgumentList &TemplateArgs);\n  TemplateName\n  SubstTemplateName(NestedNameSpecifierLoc QualifierLoc, TemplateName Name,\n                    SourceLocation Loc,\n                    const MultiLevelTemplateArgumentList &TemplateArgs);\n  bool Subst(const TemplateArgumentLoc *Args, unsigned NumArgs,\n             TemplateArgumentListInfo &Result,\n             const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  bool InstantiateDefaultArgument(SourceLocation CallLoc, FunctionDecl *FD,\n                                  ParmVarDecl *Param);\n  void InstantiateExceptionSpec(SourceLocation PointOfInstantiation,\n                                FunctionDecl *Function);\n  bool CheckInstantiatedFunctionTemplateConstraints(\n      SourceLocation PointOfInstantiation, FunctionDecl *Decl,\n      ArrayRef<TemplateArgument> TemplateArgs,\n      ConstraintSatisfaction &Satisfaction);\n  FunctionDecl *InstantiateFunctionDeclaration(FunctionTemplateDecl *FTD,\n                                               const TemplateArgumentList *Args,\n                                               SourceLocation Loc);\n  void InstantiateFunctionDefinition(SourceLocation PointOfInstantiation,\n                                     FunctionDecl *Function,\n                                     bool Recursive = false,\n                                     bool DefinitionRequired = false,\n                                     bool AtEndOfTU = false);\n  VarTemplateSpecializationDecl *BuildVarTemplateInstantiation(\n      VarTemplateDecl *VarTemplate, VarDecl *FromVar,\n      const TemplateArgumentList &TemplateArgList,\n      const TemplateArgumentListInfo &TemplateArgsInfo,\n      SmallVectorImpl<TemplateArgument> &Converted,\n      SourceLocation PointOfInstantiation,\n      LateInstantiatedAttrVec *LateAttrs = nullptr,\n      LocalInstantiationScope *StartingScope = nullptr);\n  VarTemplateSpecializationDecl *CompleteVarTemplateSpecializationDecl(\n      VarTemplateSpecializationDecl *VarSpec, VarDecl *PatternDecl,\n      const MultiLevelTemplateArgumentList &TemplateArgs);\n  void\n  BuildVariableInstantiation(VarDecl *NewVar, VarDecl *OldVar,\n                             const MultiLevelTemplateArgumentList &TemplateArgs,\n                             LateInstantiatedAttrVec *LateAttrs,\n                             DeclContext *Owner,\n                             LocalInstantiationScope *StartingScope,\n                             bool InstantiatingVarTemplate = false,\n                             VarTemplateSpecializationDecl *PrevVTSD = nullptr);\n\n  void InstantiateVariableInitializer(\n      VarDecl *Var, VarDecl *OldVar,\n      const MultiLevelTemplateArgumentList &TemplateArgs);\n  void InstantiateVariableDefinition(SourceLocation PointOfInstantiation,\n                                     VarDecl *Var, bool Recursive = false,\n                                     bool DefinitionRequired = false,\n                                     bool AtEndOfTU = false);\n\n  void InstantiateMemInitializers(CXXConstructorDecl *New,\n                                  const CXXConstructorDecl *Tmpl,\n                            const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  NamedDecl *FindInstantiatedDecl(SourceLocation Loc, NamedDecl *D,\n                          const MultiLevelTemplateArgumentList &TemplateArgs,\n                          bool FindingInstantiatedContext = false);\n  DeclContext *FindInstantiatedContext(SourceLocation Loc, DeclContext *DC,\n                          const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  // Objective-C declarations.\n  enum ObjCContainerKind {\n    OCK_None = -1,\n    OCK_Interface = 0,\n    OCK_Protocol,\n    OCK_Category,\n    OCK_ClassExtension,\n    OCK_Implementation,\n    OCK_CategoryImplementation\n  };\n  ObjCContainerKind getObjCContainerKind() const;\n\n  DeclResult actOnObjCTypeParam(Scope *S,\n                                ObjCTypeParamVariance variance,\n                                SourceLocation varianceLoc,\n                                unsigned index,\n                                IdentifierInfo *paramName,\n                                SourceLocation paramLoc,\n                                SourceLocation colonLoc,\n                                ParsedType typeBound);\n\n  ObjCTypeParamList *actOnObjCTypeParamList(Scope *S, SourceLocation lAngleLoc,\n                                            ArrayRef<Decl *> typeParams,\n                                            SourceLocation rAngleLoc);\n  void popObjCTypeParamList(Scope *S, ObjCTypeParamList *typeParamList);\n\n  Decl *ActOnStartClassInterface(\n      Scope *S, SourceLocation AtInterfaceLoc, IdentifierInfo *ClassName,\n      SourceLocation ClassLoc, ObjCTypeParamList *typeParamList,\n      IdentifierInfo *SuperName, SourceLocation SuperLoc,\n      ArrayRef<ParsedType> SuperTypeArgs, SourceRange SuperTypeArgsRange,\n      Decl *const *ProtoRefs, unsigned NumProtoRefs,\n      const SourceLocation *ProtoLocs, SourceLocation EndProtoLoc,\n      const ParsedAttributesView &AttrList);\n\n  void ActOnSuperClassOfClassInterface(Scope *S,\n                                       SourceLocation AtInterfaceLoc,\n                                       ObjCInterfaceDecl *IDecl,\n                                       IdentifierInfo *ClassName,\n                                       SourceLocation ClassLoc,\n                                       IdentifierInfo *SuperName,\n                                       SourceLocation SuperLoc,\n                                       ArrayRef<ParsedType> SuperTypeArgs,\n                                       SourceRange SuperTypeArgsRange);\n\n  void ActOnTypedefedProtocols(SmallVectorImpl<Decl *> &ProtocolRefs,\n                               SmallVectorImpl<SourceLocation> &ProtocolLocs,\n                               IdentifierInfo *SuperName,\n                               SourceLocation SuperLoc);\n\n  Decl *ActOnCompatibilityAlias(\n                    SourceLocation AtCompatibilityAliasLoc,\n                    IdentifierInfo *AliasName,  SourceLocation AliasLocation,\n                    IdentifierInfo *ClassName, SourceLocation ClassLocation);\n\n  bool CheckForwardProtocolDeclarationForCircularDependency(\n    IdentifierInfo *PName,\n    SourceLocation &PLoc, SourceLocation PrevLoc,\n    const ObjCList<ObjCProtocolDecl> &PList);\n\n  Decl *ActOnStartProtocolInterface(\n      SourceLocation AtProtoInterfaceLoc, IdentifierInfo *ProtocolName,\n      SourceLocation ProtocolLoc, Decl *const *ProtoRefNames,\n      unsigned NumProtoRefs, const SourceLocation *ProtoLocs,\n      SourceLocation EndProtoLoc, const ParsedAttributesView &AttrList);\n\n  Decl *ActOnStartCategoryInterface(\n      SourceLocation AtInterfaceLoc, IdentifierInfo *ClassName,\n      SourceLocation ClassLoc, ObjCTypeParamList *typeParamList,\n      IdentifierInfo *CategoryName, SourceLocation CategoryLoc,\n      Decl *const *ProtoRefs, unsigned NumProtoRefs,\n      const SourceLocation *ProtoLocs, SourceLocation EndProtoLoc,\n      const ParsedAttributesView &AttrList);\n\n  Decl *ActOnStartClassImplementation(SourceLocation AtClassImplLoc,\n                                      IdentifierInfo *ClassName,\n                                      SourceLocation ClassLoc,\n                                      IdentifierInfo *SuperClassname,\n                                      SourceLocation SuperClassLoc,\n                                      const ParsedAttributesView &AttrList);\n\n  Decl *ActOnStartCategoryImplementation(SourceLocation AtCatImplLoc,\n                                         IdentifierInfo *ClassName,\n                                         SourceLocation ClassLoc,\n                                         IdentifierInfo *CatName,\n                                         SourceLocation CatLoc,\n                                         const ParsedAttributesView &AttrList);\n\n  DeclGroupPtrTy ActOnFinishObjCImplementation(Decl *ObjCImpDecl,\n                                               ArrayRef<Decl *> Decls);\n\n  DeclGroupPtrTy ActOnForwardClassDeclaration(SourceLocation Loc,\n                   IdentifierInfo **IdentList,\n                   SourceLocation *IdentLocs,\n                   ArrayRef<ObjCTypeParamList *> TypeParamLists,\n                   unsigned NumElts);\n\n  DeclGroupPtrTy\n  ActOnForwardProtocolDeclaration(SourceLocation AtProtoclLoc,\n                                  ArrayRef<IdentifierLocPair> IdentList,\n                                  const ParsedAttributesView &attrList);\n\n  void FindProtocolDeclaration(bool WarnOnDeclarations, bool ForObjCContainer,\n                               ArrayRef<IdentifierLocPair> ProtocolId,\n                               SmallVectorImpl<Decl *> &Protocols);\n\n  void DiagnoseTypeArgsAndProtocols(IdentifierInfo *ProtocolId,\n                                    SourceLocation ProtocolLoc,\n                                    IdentifierInfo *TypeArgId,\n                                    SourceLocation TypeArgLoc,\n                                    bool SelectProtocolFirst = false);\n\n  /// Given a list of identifiers (and their locations), resolve the\n  /// names to either Objective-C protocol qualifiers or type\n  /// arguments, as appropriate.\n  void actOnObjCTypeArgsOrProtocolQualifiers(\n         Scope *S,\n         ParsedType baseType,\n         SourceLocation lAngleLoc,\n         ArrayRef<IdentifierInfo *> identifiers,\n         ArrayRef<SourceLocation> identifierLocs,\n         SourceLocation rAngleLoc,\n         SourceLocation &typeArgsLAngleLoc,\n         SmallVectorImpl<ParsedType> &typeArgs,\n         SourceLocation &typeArgsRAngleLoc,\n         SourceLocation &protocolLAngleLoc,\n         SmallVectorImpl<Decl *> &protocols,\n         SourceLocation &protocolRAngleLoc,\n         bool warnOnIncompleteProtocols);\n\n  /// Build a an Objective-C protocol-qualified 'id' type where no\n  /// base type was specified.\n  TypeResult actOnObjCProtocolQualifierType(\n               SourceLocation lAngleLoc,\n               ArrayRef<Decl *> protocols,\n               ArrayRef<SourceLocation> protocolLocs,\n               SourceLocation rAngleLoc);\n\n  /// Build a specialized and/or protocol-qualified Objective-C type.\n  TypeResult actOnObjCTypeArgsAndProtocolQualifiers(\n               Scope *S,\n               SourceLocation Loc,\n               ParsedType BaseType,\n               SourceLocation TypeArgsLAngleLoc,\n               ArrayRef<ParsedType> TypeArgs,\n               SourceLocation TypeArgsRAngleLoc,\n               SourceLocation ProtocolLAngleLoc,\n               ArrayRef<Decl *> Protocols,\n               ArrayRef<SourceLocation> ProtocolLocs,\n               SourceLocation ProtocolRAngleLoc);\n\n  /// Build an Objective-C type parameter type.\n  QualType BuildObjCTypeParamType(const ObjCTypeParamDecl *Decl,\n                                  SourceLocation ProtocolLAngleLoc,\n                                  ArrayRef<ObjCProtocolDecl *> Protocols,\n                                  ArrayRef<SourceLocation> ProtocolLocs,\n                                  SourceLocation ProtocolRAngleLoc,\n                                  bool FailOnError = false);\n\n  /// Build an Objective-C object pointer type.\n  QualType BuildObjCObjectType(QualType BaseType,\n                               SourceLocation Loc,\n                               SourceLocation TypeArgsLAngleLoc,\n                               ArrayRef<TypeSourceInfo *> TypeArgs,\n                               SourceLocation TypeArgsRAngleLoc,\n                               SourceLocation ProtocolLAngleLoc,\n                               ArrayRef<ObjCProtocolDecl *> Protocols,\n                               ArrayRef<SourceLocation> ProtocolLocs,\n                               SourceLocation ProtocolRAngleLoc,\n                               bool FailOnError = false);\n\n  /// Ensure attributes are consistent with type.\n  /// \\param [in, out] Attributes The attributes to check; they will\n  /// be modified to be consistent with \\p PropertyTy.\n  void CheckObjCPropertyAttributes(Decl *PropertyPtrTy,\n                                   SourceLocation Loc,\n                                   unsigned &Attributes,\n                                   bool propertyInPrimaryClass);\n\n  /// Process the specified property declaration and create decls for the\n  /// setters and getters as needed.\n  /// \\param property The property declaration being processed\n  void ProcessPropertyDecl(ObjCPropertyDecl *property);\n\n\n  void DiagnosePropertyMismatch(ObjCPropertyDecl *Property,\n                                ObjCPropertyDecl *SuperProperty,\n                                const IdentifierInfo *Name,\n                                bool OverridingProtocolProperty);\n\n  void DiagnoseClassExtensionDupMethods(ObjCCategoryDecl *CAT,\n                                        ObjCInterfaceDecl *ID);\n\n  Decl *ActOnAtEnd(Scope *S, SourceRange AtEnd,\n                   ArrayRef<Decl *> allMethods = None,\n                   ArrayRef<DeclGroupPtrTy> allTUVars = None);\n\n  Decl *ActOnProperty(Scope *S, SourceLocation AtLoc,\n                      SourceLocation LParenLoc,\n                      FieldDeclarator &FD, ObjCDeclSpec &ODS,\n                      Selector GetterSel, Selector SetterSel,\n                      tok::ObjCKeywordKind MethodImplKind,\n                      DeclContext *lexicalDC = nullptr);\n\n  Decl *ActOnPropertyImplDecl(Scope *S,\n                              SourceLocation AtLoc,\n                              SourceLocation PropertyLoc,\n                              bool ImplKind,\n                              IdentifierInfo *PropertyId,\n                              IdentifierInfo *PropertyIvar,\n                              SourceLocation PropertyIvarLoc,\n                              ObjCPropertyQueryKind QueryKind);\n\n  enum ObjCSpecialMethodKind {\n    OSMK_None,\n    OSMK_Alloc,\n    OSMK_New,\n    OSMK_Copy,\n    OSMK_RetainingInit,\n    OSMK_NonRetainingInit\n  };\n\n  struct ObjCArgInfo {\n    IdentifierInfo *Name;\n    SourceLocation NameLoc;\n    // The Type is null if no type was specified, and the DeclSpec is invalid\n    // in this case.\n    ParsedType Type;\n    ObjCDeclSpec DeclSpec;\n\n    /// ArgAttrs - Attribute list for this argument.\n    ParsedAttributesView ArgAttrs;\n  };\n\n  Decl *ActOnMethodDeclaration(\n      Scope *S,\n      SourceLocation BeginLoc, // location of the + or -.\n      SourceLocation EndLoc,   // location of the ; or {.\n      tok::TokenKind MethodType, ObjCDeclSpec &ReturnQT, ParsedType ReturnType,\n      ArrayRef<SourceLocation> SelectorLocs, Selector Sel,\n      // optional arguments. The number of types/arguments is obtained\n      // from the Sel.getNumArgs().\n      ObjCArgInfo *ArgInfo, DeclaratorChunk::ParamInfo *CParamInfo,\n      unsigned CNumArgs, // c-style args\n      const ParsedAttributesView &AttrList, tok::ObjCKeywordKind MethodImplKind,\n      bool isVariadic, bool MethodDefinition);\n\n  ObjCMethodDecl *LookupMethodInQualifiedType(Selector Sel,\n                                              const ObjCObjectPointerType *OPT,\n                                              bool IsInstance);\n  ObjCMethodDecl *LookupMethodInObjectType(Selector Sel, QualType Ty,\n                                           bool IsInstance);\n\n  bool CheckARCMethodDecl(ObjCMethodDecl *method);\n  bool inferObjCARCLifetime(ValueDecl *decl);\n\n  void deduceOpenCLAddressSpace(ValueDecl *decl);\n\n  ExprResult\n  HandleExprPropertyRefExpr(const ObjCObjectPointerType *OPT,\n                            Expr *BaseExpr,\n                            SourceLocation OpLoc,\n                            DeclarationName MemberName,\n                            SourceLocation MemberLoc,\n                            SourceLocation SuperLoc, QualType SuperType,\n                            bool Super);\n\n  ExprResult\n  ActOnClassPropertyRefExpr(IdentifierInfo &receiverName,\n                            IdentifierInfo &propertyName,\n                            SourceLocation receiverNameLoc,\n                            SourceLocation propertyNameLoc);\n\n  ObjCMethodDecl *tryCaptureObjCSelf(SourceLocation Loc);\n\n  /// Describes the kind of message expression indicated by a message\n  /// send that starts with an identifier.\n  enum ObjCMessageKind {\n    /// The message is sent to 'super'.\n    ObjCSuperMessage,\n    /// The message is an instance message.\n    ObjCInstanceMessage,\n    /// The message is a class message, and the identifier is a type\n    /// name.\n    ObjCClassMessage\n  };\n\n  ObjCMessageKind getObjCMessageKind(Scope *S,\n                                     IdentifierInfo *Name,\n                                     SourceLocation NameLoc,\n                                     bool IsSuper,\n                                     bool HasTrailingDot,\n                                     ParsedType &ReceiverType);\n\n  ExprResult ActOnSuperMessage(Scope *S, SourceLocation SuperLoc,\n                               Selector Sel,\n                               SourceLocation LBracLoc,\n                               ArrayRef<SourceLocation> SelectorLocs,\n                               SourceLocation RBracLoc,\n                               MultiExprArg Args);\n\n  ExprResult BuildClassMessage(TypeSourceInfo *ReceiverTypeInfo,\n                               QualType ReceiverType,\n                               SourceLocation SuperLoc,\n                               Selector Sel,\n                               ObjCMethodDecl *Method,\n                               SourceLocation LBracLoc,\n                               ArrayRef<SourceLocation> SelectorLocs,\n                               SourceLocation RBracLoc,\n                               MultiExprArg Args,\n                               bool isImplicit = false);\n\n  ExprResult BuildClassMessageImplicit(QualType ReceiverType,\n                                       bool isSuperReceiver,\n                                       SourceLocation Loc,\n                                       Selector Sel,\n                                       ObjCMethodDecl *Method,\n                                       MultiExprArg Args);\n\n  ExprResult ActOnClassMessage(Scope *S,\n                               ParsedType Receiver,\n                               Selector Sel,\n                               SourceLocation LBracLoc,\n                               ArrayRef<SourceLocation> SelectorLocs,\n                               SourceLocation RBracLoc,\n                               MultiExprArg Args);\n\n  ExprResult BuildInstanceMessage(Expr *Receiver,\n                                  QualType ReceiverType,\n                                  SourceLocation SuperLoc,\n                                  Selector Sel,\n                                  ObjCMethodDecl *Method,\n                                  SourceLocation LBracLoc,\n                                  ArrayRef<SourceLocation> SelectorLocs,\n                                  SourceLocation RBracLoc,\n                                  MultiExprArg Args,\n                                  bool isImplicit = false);\n\n  ExprResult BuildInstanceMessageImplicit(Expr *Receiver,\n                                          QualType ReceiverType,\n                                          SourceLocation Loc,\n                                          Selector Sel,\n                                          ObjCMethodDecl *Method,\n                                          MultiExprArg Args);\n\n  ExprResult ActOnInstanceMessage(Scope *S,\n                                  Expr *Receiver,\n                                  Selector Sel,\n                                  SourceLocation LBracLoc,\n                                  ArrayRef<SourceLocation> SelectorLocs,\n                                  SourceLocation RBracLoc,\n                                  MultiExprArg Args);\n\n  ExprResult BuildObjCBridgedCast(SourceLocation LParenLoc,\n                                  ObjCBridgeCastKind Kind,\n                                  SourceLocation BridgeKeywordLoc,\n                                  TypeSourceInfo *TSInfo,\n                                  Expr *SubExpr);\n\n  ExprResult ActOnObjCBridgedCast(Scope *S,\n                                  SourceLocation LParenLoc,\n                                  ObjCBridgeCastKind Kind,\n                                  SourceLocation BridgeKeywordLoc,\n                                  ParsedType Type,\n                                  SourceLocation RParenLoc,\n                                  Expr *SubExpr);\n\n  void CheckTollFreeBridgeCast(QualType castType, Expr *castExpr);\n\n  void CheckObjCBridgeRelatedCast(QualType castType, Expr *castExpr);\n\n  bool CheckTollFreeBridgeStaticCast(QualType castType, Expr *castExpr,\n                                     CastKind &Kind);\n\n  bool checkObjCBridgeRelatedComponents(SourceLocation Loc,\n                                        QualType DestType, QualType SrcType,\n                                        ObjCInterfaceDecl *&RelatedClass,\n                                        ObjCMethodDecl *&ClassMethod,\n                                        ObjCMethodDecl *&InstanceMethod,\n                                        TypedefNameDecl *&TDNDecl,\n                                        bool CfToNs, bool Diagnose = true);\n\n  bool CheckObjCBridgeRelatedConversions(SourceLocation Loc,\n                                         QualType DestType, QualType SrcType,\n                                         Expr *&SrcExpr, bool Diagnose = true);\n\n  bool CheckConversionToObjCLiteral(QualType DstType, Expr *&SrcExpr,\n                                    bool Diagnose = true);\n\n  bool checkInitMethod(ObjCMethodDecl *method, QualType receiverTypeIfCall);\n\n  /// Check whether the given new method is a valid override of the\n  /// given overridden method, and set any properties that should be inherited.\n  void CheckObjCMethodOverride(ObjCMethodDecl *NewMethod,\n                               const ObjCMethodDecl *Overridden);\n\n  /// Describes the compatibility of a result type with its method.\n  enum ResultTypeCompatibilityKind {\n    RTC_Compatible,\n    RTC_Incompatible,\n    RTC_Unknown\n  };\n\n  void CheckObjCMethodDirectOverrides(ObjCMethodDecl *method,\n                                      ObjCMethodDecl *overridden);\n\n  void CheckObjCMethodOverrides(ObjCMethodDecl *ObjCMethod,\n                                ObjCInterfaceDecl *CurrentClass,\n                                ResultTypeCompatibilityKind RTC);\n\n  enum PragmaOptionsAlignKind {\n    POAK_Native,  // #pragma options align=native\n    POAK_Natural, // #pragma options align=natural\n    POAK_Packed,  // #pragma options align=packed\n    POAK_Power,   // #pragma options align=power\n    POAK_Mac68k,  // #pragma options align=mac68k\n    POAK_Reset    // #pragma options align=reset\n  };\n\n  /// ActOnPragmaClangSection - Called on well formed \\#pragma clang section\n  void ActOnPragmaClangSection(SourceLocation PragmaLoc,\n                               PragmaClangSectionAction Action,\n                               PragmaClangSectionKind SecKind, StringRef SecName);\n\n  /// ActOnPragmaOptionsAlign - Called on well formed \\#pragma options align.\n  void ActOnPragmaOptionsAlign(PragmaOptionsAlignKind Kind,\n                               SourceLocation PragmaLoc);\n\n  /// ActOnPragmaPack - Called on well formed \\#pragma pack(...).\n  void ActOnPragmaPack(SourceLocation PragmaLoc, PragmaMsStackAction Action,\n                       StringRef SlotLabel, Expr *Alignment);\n\n  enum class PragmaAlignPackDiagnoseKind {\n    NonDefaultStateAtInclude,\n    ChangedStateAtExit\n  };\n\n  void DiagnoseNonDefaultPragmaAlignPack(PragmaAlignPackDiagnoseKind Kind,\n                                         SourceLocation IncludeLoc);\n  void DiagnoseUnterminatedPragmaAlignPack();\n\n  /// ActOnPragmaMSStruct - Called on well formed \\#pragma ms_struct [on|off].\n  void ActOnPragmaMSStruct(PragmaMSStructKind Kind);\n\n  /// ActOnPragmaMSComment - Called on well formed\n  /// \\#pragma comment(kind, \"arg\").\n  void ActOnPragmaMSComment(SourceLocation CommentLoc, PragmaMSCommentKind Kind,\n                            StringRef Arg);\n\n  /// ActOnPragmaMSPointersToMembers - called on well formed \\#pragma\n  /// pointers_to_members(representation method[, general purpose\n  /// representation]).\n  void ActOnPragmaMSPointersToMembers(\n      LangOptions::PragmaMSPointersToMembersKind Kind,\n      SourceLocation PragmaLoc);\n\n  /// Called on well formed \\#pragma vtordisp().\n  void ActOnPragmaMSVtorDisp(PragmaMsStackAction Action,\n                             SourceLocation PragmaLoc,\n                             MSVtorDispMode Value);\n\n  enum PragmaSectionKind {\n    PSK_DataSeg,\n    PSK_BSSSeg,\n    PSK_ConstSeg,\n    PSK_CodeSeg,\n  };\n\n  bool UnifySection(StringRef SectionName, int SectionFlags,\n                    NamedDecl *TheDecl);\n  bool UnifySection(StringRef SectionName,\n                    int SectionFlags,\n                    SourceLocation PragmaSectionLocation);\n\n  /// Called on well formed \\#pragma bss_seg/data_seg/const_seg/code_seg.\n  void ActOnPragmaMSSeg(SourceLocation PragmaLocation,\n                        PragmaMsStackAction Action,\n                        llvm::StringRef StackSlotLabel,\n                        StringLiteral *SegmentName,\n                        llvm::StringRef PragmaName);\n\n  /// Called on well formed \\#pragma section().\n  void ActOnPragmaMSSection(SourceLocation PragmaLocation,\n                            int SectionFlags, StringLiteral *SegmentName);\n\n  /// Called on well-formed \\#pragma init_seg().\n  void ActOnPragmaMSInitSeg(SourceLocation PragmaLocation,\n                            StringLiteral *SegmentName);\n\n  /// Called on #pragma clang __debug dump II\n  void ActOnPragmaDump(Scope *S, SourceLocation Loc, IdentifierInfo *II);\n\n  /// ActOnPragmaDetectMismatch - Call on well-formed \\#pragma detect_mismatch\n  void ActOnPragmaDetectMismatch(SourceLocation Loc, StringRef Name,\n                                 StringRef Value);\n\n  /// Are precise floating point semantics currently enabled?\n  bool isPreciseFPEnabled() {\n    return !CurFPFeatures.getAllowFPReassociate() &&\n           !CurFPFeatures.getNoSignedZero() &&\n           !CurFPFeatures.getAllowReciprocal() &&\n           !CurFPFeatures.getAllowApproxFunc();\n  }\n\n  /// ActOnPragmaFloatControl - Call on well-formed \\#pragma float_control\n  void ActOnPragmaFloatControl(SourceLocation Loc, PragmaMsStackAction Action,\n                               PragmaFloatControlKind Value);\n\n  /// ActOnPragmaUnused - Called on well-formed '\\#pragma unused'.\n  void ActOnPragmaUnused(const Token &Identifier,\n                         Scope *curScope,\n                         SourceLocation PragmaLoc);\n\n  /// ActOnPragmaVisibility - Called on well formed \\#pragma GCC visibility... .\n  void ActOnPragmaVisibility(const IdentifierInfo* VisType,\n                             SourceLocation PragmaLoc);\n\n  NamedDecl *DeclClonePragmaWeak(NamedDecl *ND, IdentifierInfo *II,\n                                 SourceLocation Loc);\n  void DeclApplyPragmaWeak(Scope *S, NamedDecl *ND, WeakInfo &W);\n\n  /// ActOnPragmaWeakID - Called on well formed \\#pragma weak ident.\n  void ActOnPragmaWeakID(IdentifierInfo* WeakName,\n                         SourceLocation PragmaLoc,\n                         SourceLocation WeakNameLoc);\n\n  /// ActOnPragmaRedefineExtname - Called on well formed\n  /// \\#pragma redefine_extname oldname newname.\n  void ActOnPragmaRedefineExtname(IdentifierInfo* WeakName,\n                                  IdentifierInfo* AliasName,\n                                  SourceLocation PragmaLoc,\n                                  SourceLocation WeakNameLoc,\n                                  SourceLocation AliasNameLoc);\n\n  /// ActOnPragmaWeakAlias - Called on well formed \\#pragma weak ident = ident.\n  void ActOnPragmaWeakAlias(IdentifierInfo* WeakName,\n                            IdentifierInfo* AliasName,\n                            SourceLocation PragmaLoc,\n                            SourceLocation WeakNameLoc,\n                            SourceLocation AliasNameLoc);\n\n  /// ActOnPragmaFPContract - Called on well formed\n  /// \\#pragma {STDC,OPENCL} FP_CONTRACT and\n  /// \\#pragma clang fp contract\n  void ActOnPragmaFPContract(SourceLocation Loc, LangOptions::FPModeKind FPC);\n\n  /// Called on well formed\n  /// \\#pragma clang fp reassociate\n  void ActOnPragmaFPReassociate(SourceLocation Loc, bool IsEnabled);\n\n  /// ActOnPragmaFenvAccess - Called on well formed\n  /// \\#pragma STDC FENV_ACCESS\n  void ActOnPragmaFEnvAccess(SourceLocation Loc, bool IsEnabled);\n\n  /// Called on well formed '\\#pragma clang fp' that has option 'exceptions'.\n  void ActOnPragmaFPExceptions(SourceLocation Loc,\n                               LangOptions::FPExceptionModeKind);\n\n  /// Called to set constant rounding mode for floating point operations.\n  void setRoundingMode(SourceLocation Loc, llvm::RoundingMode);\n\n  /// Called to set exception behavior for floating point operations.\n  void setExceptionMode(SourceLocation Loc, LangOptions::FPExceptionModeKind);\n\n  /// AddAlignmentAttributesForRecord - Adds any needed alignment attributes to\n  /// a the record decl, to handle '\\#pragma pack' and '\\#pragma options align'.\n  void AddAlignmentAttributesForRecord(RecordDecl *RD);\n\n  /// AddMsStructLayoutForRecord - Adds ms_struct layout attribute to record.\n  void AddMsStructLayoutForRecord(RecordDecl *RD);\n\n  /// PushNamespaceVisibilityAttr - Note that we've entered a\n  /// namespace with a visibility attribute.\n  void PushNamespaceVisibilityAttr(const VisibilityAttr *Attr,\n                                   SourceLocation Loc);\n\n  /// AddPushedVisibilityAttribute - If '\\#pragma GCC visibility' was used,\n  /// add an appropriate visibility attribute.\n  void AddPushedVisibilityAttribute(Decl *RD);\n\n  /// PopPragmaVisibility - Pop the top element of the visibility stack; used\n  /// for '\\#pragma GCC visibility' and visibility attributes on namespaces.\n  void PopPragmaVisibility(bool IsNamespaceEnd, SourceLocation EndLoc);\n\n  /// FreeVisContext - Deallocate and null out VisContext.\n  void FreeVisContext();\n\n  /// AddCFAuditedAttribute - Check whether we're currently within\n  /// '\\#pragma clang arc_cf_code_audited' and, if so, consider adding\n  /// the appropriate attribute.\n  void AddCFAuditedAttribute(Decl *D);\n\n  void ActOnPragmaAttributeAttribute(ParsedAttr &Attribute,\n                                     SourceLocation PragmaLoc,\n                                     attr::ParsedSubjectMatchRuleSet Rules);\n  void ActOnPragmaAttributeEmptyPush(SourceLocation PragmaLoc,\n                                     const IdentifierInfo *Namespace);\n\n  /// Called on well-formed '\\#pragma clang attribute pop'.\n  void ActOnPragmaAttributePop(SourceLocation PragmaLoc,\n                               const IdentifierInfo *Namespace);\n\n  /// Adds the attributes that have been specified using the\n  /// '\\#pragma clang attribute push' directives to the given declaration.\n  void AddPragmaAttributes(Scope *S, Decl *D);\n\n  void DiagnoseUnterminatedPragmaAttribute();\n\n  /// Called on well formed \\#pragma clang optimize.\n  void ActOnPragmaOptimize(bool On, SourceLocation PragmaLoc);\n\n  /// Get the location for the currently active \"\\#pragma clang optimize\n  /// off\". If this location is invalid, then the state of the pragma is \"on\".\n  SourceLocation getOptimizeOffPragmaLocation() const {\n    return OptimizeOffPragmaLocation;\n  }\n\n  /// Only called on function definitions; if there is a pragma in scope\n  /// with the effect of a range-based optnone, consider marking the function\n  /// with attribute optnone.\n  void AddRangeBasedOptnone(FunctionDecl *FD);\n\n  /// Adds the 'optnone' attribute to the function declaration if there\n  /// are no conflicts; Loc represents the location causing the 'optnone'\n  /// attribute to be added (usually because of a pragma).\n  void AddOptnoneAttributeIfNoConflicts(FunctionDecl *FD, SourceLocation Loc);\n\n  /// AddAlignedAttr - Adds an aligned attribute to a particular declaration.\n  void AddAlignedAttr(Decl *D, const AttributeCommonInfo &CI, Expr *E,\n                      bool IsPackExpansion);\n  void AddAlignedAttr(Decl *D, const AttributeCommonInfo &CI, TypeSourceInfo *T,\n                      bool IsPackExpansion);\n\n  /// AddAssumeAlignedAttr - Adds an assume_aligned attribute to a particular\n  /// declaration.\n  void AddAssumeAlignedAttr(Decl *D, const AttributeCommonInfo &CI, Expr *E,\n                            Expr *OE);\n\n  /// AddAllocAlignAttr - Adds an alloc_align attribute to a particular\n  /// declaration.\n  void AddAllocAlignAttr(Decl *D, const AttributeCommonInfo &CI,\n                         Expr *ParamExpr);\n\n  /// AddAlignValueAttr - Adds an align_value attribute to a particular\n  /// declaration.\n  void AddAlignValueAttr(Decl *D, const AttributeCommonInfo &CI, Expr *E);\n\n  /// AddAnnotationAttr - Adds an annotation Annot with Args arguments to D.\n  void AddAnnotationAttr(Decl *D, const AttributeCommonInfo &CI,\n                         StringRef Annot, MutableArrayRef<Expr *> Args);\n\n  /// AddLaunchBoundsAttr - Adds a launch_bounds attribute to a particular\n  /// declaration.\n  void AddLaunchBoundsAttr(Decl *D, const AttributeCommonInfo &CI,\n                           Expr *MaxThreads, Expr *MinBlocks);\n\n  /// AddModeAttr - Adds a mode attribute to a particular declaration.\n  void AddModeAttr(Decl *D, const AttributeCommonInfo &CI, IdentifierInfo *Name,\n                   bool InInstantiation = false);\n\n  void AddParameterABIAttr(Decl *D, const AttributeCommonInfo &CI,\n                           ParameterABI ABI);\n\n  enum class RetainOwnershipKind {NS, CF, OS};\n  void AddXConsumedAttr(Decl *D, const AttributeCommonInfo &CI,\n                        RetainOwnershipKind K, bool IsTemplateInstantiation);\n\n  /// addAMDGPUFlatWorkGroupSizeAttr - Adds an amdgpu_flat_work_group_size\n  /// attribute to a particular declaration.\n  void addAMDGPUFlatWorkGroupSizeAttr(Decl *D, const AttributeCommonInfo &CI,\n                                      Expr *Min, Expr *Max);\n\n  /// addAMDGPUWavePersEUAttr - Adds an amdgpu_waves_per_eu attribute to a\n  /// particular declaration.\n  void addAMDGPUWavesPerEUAttr(Decl *D, const AttributeCommonInfo &CI,\n                               Expr *Min, Expr *Max);\n\n  bool checkNSReturnsRetainedReturnType(SourceLocation loc, QualType type);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Coroutines TS\n  //\n  bool ActOnCoroutineBodyStart(Scope *S, SourceLocation KwLoc,\n                               StringRef Keyword);\n  ExprResult ActOnCoawaitExpr(Scope *S, SourceLocation KwLoc, Expr *E);\n  ExprResult ActOnCoyieldExpr(Scope *S, SourceLocation KwLoc, Expr *E);\n  StmtResult ActOnCoreturnStmt(Scope *S, SourceLocation KwLoc, Expr *E);\n\n  ExprResult BuildResolvedCoawaitExpr(SourceLocation KwLoc, Expr *E,\n                                      bool IsImplicit = false);\n  ExprResult BuildUnresolvedCoawaitExpr(SourceLocation KwLoc, Expr *E,\n                                        UnresolvedLookupExpr* Lookup);\n  ExprResult BuildCoyieldExpr(SourceLocation KwLoc, Expr *E);\n  StmtResult BuildCoreturnStmt(SourceLocation KwLoc, Expr *E,\n                               bool IsImplicit = false);\n  StmtResult BuildCoroutineBodyStmt(CoroutineBodyStmt::CtorArgs);\n  bool buildCoroutineParameterMoves(SourceLocation Loc);\n  VarDecl *buildCoroutinePromise(SourceLocation Loc);\n  void CheckCompletedCoroutineBody(FunctionDecl *FD, Stmt *&Body);\n  ClassTemplateDecl *lookupCoroutineTraits(SourceLocation KwLoc,\n                                           SourceLocation FuncLoc);\n  /// Check that the expression co_await promise.final_suspend() shall not be\n  /// potentially-throwing.\n  bool checkFinalSuspendNoThrow(const Stmt *FinalSuspend);\n\n  //===--------------------------------------------------------------------===//\n  // OpenCL extensions.\n  //\nprivate:\n  std::string CurrOpenCLExtension;\n  /// Extensions required by an OpenCL type.\n  llvm::DenseMap<const Type*, std::set<std::string>> OpenCLTypeExtMap;\n  /// Extensions required by an OpenCL declaration.\n  llvm::DenseMap<const Decl*, std::set<std::string>> OpenCLDeclExtMap;\npublic:\n  llvm::StringRef getCurrentOpenCLExtension() const {\n    return CurrOpenCLExtension;\n  }\n\n  /// Check if a function declaration \\p FD associates with any\n  /// extensions present in OpenCLDeclExtMap and if so return the\n  /// extension(s) name(s).\n  std::string getOpenCLExtensionsFromDeclExtMap(FunctionDecl *FD);\n\n  /// Check if a function type \\p FT associates with any\n  /// extensions present in OpenCLTypeExtMap and if so return the\n  /// extension(s) name(s).\n  std::string getOpenCLExtensionsFromTypeExtMap(FunctionType *FT);\n\n  /// Find an extension in an appropriate extension map and return its name\n  template<typename T, typename MapT>\n  std::string getOpenCLExtensionsFromExtMap(T* FT, MapT &Map);\n\n  void setCurrentOpenCLExtension(llvm::StringRef Ext) {\n    CurrOpenCLExtension = std::string(Ext);\n  }\n\n  /// Set OpenCL extensions for a type which can only be used when these\n  /// OpenCL extensions are enabled. If \\p Exts is empty, do nothing.\n  /// \\param Exts A space separated list of OpenCL extensions.\n  void setOpenCLExtensionForType(QualType T, llvm::StringRef Exts);\n\n  /// Set OpenCL extensions for a declaration which can only be\n  /// used when these OpenCL extensions are enabled. If \\p Exts is empty, do\n  /// nothing.\n  /// \\param Exts A space separated list of OpenCL extensions.\n  void setOpenCLExtensionForDecl(Decl *FD, llvm::StringRef Exts);\n\n  /// Set current OpenCL extensions for a type which can only be used\n  /// when these OpenCL extensions are enabled. If current OpenCL extension is\n  /// empty, do nothing.\n  void setCurrentOpenCLExtensionForType(QualType T);\n\n  /// Set current OpenCL extensions for a declaration which\n  /// can only be used when these OpenCL extensions are enabled. If current\n  /// OpenCL extension is empty, do nothing.\n  void setCurrentOpenCLExtensionForDecl(Decl *FD);\n\n  bool isOpenCLDisabledDecl(Decl *FD);\n\n  /// Check if type \\p T corresponding to declaration specifier \\p DS\n  /// is disabled due to required OpenCL extensions being disabled. If so,\n  /// emit diagnostics.\n  /// \\return true if type is disabled.\n  bool checkOpenCLDisabledTypeDeclSpec(const DeclSpec &DS, QualType T);\n\n  /// Check if declaration \\p D used by expression \\p E\n  /// is disabled due to required OpenCL extensions being disabled. If so,\n  /// emit diagnostics.\n  /// \\return true if type is disabled.\n  bool checkOpenCLDisabledDecl(const NamedDecl &D, const Expr &E);\n\n  //===--------------------------------------------------------------------===//\n  // OpenMP directives and clauses.\n  //\nprivate:\n  void *VarDataSharingAttributesStack;\n  /// Number of nested '#pragma omp declare target' directives.\n  SmallVector<SourceLocation, 4> DeclareTargetNesting;\n  /// Initialization of data-sharing attributes stack.\n  void InitDataSharingAttributesStack();\n  void DestroyDataSharingAttributesStack();\n  ExprResult\n  VerifyPositiveIntegerConstantInClause(Expr *Op, OpenMPClauseKind CKind,\n                                        bool StrictlyPositive = true);\n  /// Returns OpenMP nesting level for current directive.\n  unsigned getOpenMPNestingLevel() const;\n\n  /// Adjusts the function scopes index for the target-based regions.\n  void adjustOpenMPTargetScopeIndex(unsigned &FunctionScopesIndex,\n                                    unsigned Level) const;\n\n  /// Returns the number of scopes associated with the construct on the given\n  /// OpenMP level.\n  int getNumberOfConstructScopes(unsigned Level) const;\n\n  /// Push new OpenMP function region for non-capturing function.\n  void pushOpenMPFunctionRegion();\n\n  /// Pop OpenMP function region for non-capturing function.\n  void popOpenMPFunctionRegion(const sema::FunctionScopeInfo *OldFSI);\n\n  /// Checks if a type or a declaration is disabled due to the owning extension\n  /// being disabled, and emits diagnostic messages if it is disabled.\n  /// \\param D type or declaration to be checked.\n  /// \\param DiagLoc source location for the diagnostic message.\n  /// \\param DiagInfo information to be emitted for the diagnostic message.\n  /// \\param SrcRange source range of the declaration.\n  /// \\param Map maps type or declaration to the extensions.\n  /// \\param Selector selects diagnostic message: 0 for type and 1 for\n  ///        declaration.\n  /// \\return true if the type or declaration is disabled.\n  template <typename T, typename DiagLocT, typename DiagInfoT, typename MapT>\n  bool checkOpenCLDisabledTypeOrDecl(T D, DiagLocT DiagLoc, DiagInfoT DiagInfo,\n                                     MapT &Map, unsigned Selector = 0,\n                                     SourceRange SrcRange = SourceRange());\n\n  /// Helper to keep information about the current `omp begin/end declare\n  /// variant` nesting.\n  struct OMPDeclareVariantScope {\n    /// The associated OpenMP context selector.\n    OMPTraitInfo *TI;\n\n    /// The associated OpenMP context selector mangling.\n    std::string NameSuffix;\n\n    OMPDeclareVariantScope(OMPTraitInfo &TI);\n  };\n\n  /// Return the OMPTraitInfo for the surrounding scope, if any.\n  OMPTraitInfo *getOMPTraitInfoForSurroundingScope() {\n    return OMPDeclareVariantScopes.empty() ? nullptr\n                                           : OMPDeclareVariantScopes.back().TI;\n  }\n\n  /// The current `omp begin/end declare variant` scopes.\n  SmallVector<OMPDeclareVariantScope, 4> OMPDeclareVariantScopes;\n\n  /// The current `omp begin/end assumes` scopes.\n  SmallVector<AssumptionAttr *, 4> OMPAssumeScoped;\n\n  /// All `omp assumes` we encountered so far.\n  SmallVector<AssumptionAttr *, 4> OMPAssumeGlobal;\n\npublic:\n  /// The declarator \\p D defines a function in the scope \\p S which is nested\n  /// in an `omp begin/end declare variant` scope. In this method we create a\n  /// declaration for \\p D and rename \\p D according to the OpenMP context\n  /// selector of the surrounding scope. Return all base functions in \\p Bases.\n  void ActOnStartOfFunctionDefinitionInOpenMPDeclareVariantScope(\n      Scope *S, Declarator &D, MultiTemplateParamsArg TemplateParameterLists,\n      SmallVectorImpl<FunctionDecl *> &Bases);\n\n  /// Register \\p D as specialization of all base functions in \\p Bases in the\n  /// current `omp begin/end declare variant` scope.\n  void ActOnFinishedFunctionDefinitionInOpenMPDeclareVariantScope(\n      Decl *D, SmallVectorImpl<FunctionDecl *> &Bases);\n\n  /// Act on \\p D, a function definition inside of an `omp [begin/end] assumes`.\n  void ActOnFinishedFunctionDefinitionInOpenMPAssumeScope(Decl *D);\n\n  /// Can we exit an OpenMP declare variant scope at the moment.\n  bool isInOpenMPDeclareVariantScope() const {\n    return !OMPDeclareVariantScopes.empty();\n  }\n\n  /// Given the potential call expression \\p Call, determine if there is a\n  /// specialization via the OpenMP declare variant mechanism available. If\n  /// there is, return the specialized call expression, otherwise return the\n  /// original \\p Call.\n  ExprResult ActOnOpenMPCall(ExprResult Call, Scope *Scope,\n                             SourceLocation LParenLoc, MultiExprArg ArgExprs,\n                             SourceLocation RParenLoc, Expr *ExecConfig);\n\n  /// Handle a `omp begin declare variant`.\n  void ActOnOpenMPBeginDeclareVariant(SourceLocation Loc, OMPTraitInfo &TI);\n\n  /// Handle a `omp end declare variant`.\n  void ActOnOpenMPEndDeclareVariant();\n\n  /// Checks if the variant/multiversion functions are compatible.\n  bool areMultiversionVariantFunctionsCompatible(\n      const FunctionDecl *OldFD, const FunctionDecl *NewFD,\n      const PartialDiagnostic &NoProtoDiagID,\n      const PartialDiagnosticAt &NoteCausedDiagIDAt,\n      const PartialDiagnosticAt &NoSupportDiagIDAt,\n      const PartialDiagnosticAt &DiffDiagIDAt, bool TemplatesSupported,\n      bool ConstexprSupported, bool CLinkageMayDiffer);\n\n  /// Function tries to capture lambda's captured variables in the OpenMP region\n  /// before the original lambda is captured.\n  void tryCaptureOpenMPLambdas(ValueDecl *V);\n\n  /// Return true if the provided declaration \\a VD should be captured by\n  /// reference.\n  /// \\param Level Relative level of nested OpenMP construct for that the check\n  /// is performed.\n  /// \\param OpenMPCaptureLevel Capture level within an OpenMP construct.\n  bool isOpenMPCapturedByRef(const ValueDecl *D, unsigned Level,\n                             unsigned OpenMPCaptureLevel) const;\n\n  /// Check if the specified variable is used in one of the private\n  /// clauses (private, firstprivate, lastprivate, reduction etc.) in OpenMP\n  /// constructs.\n  VarDecl *isOpenMPCapturedDecl(ValueDecl *D, bool CheckScopeInfo = false,\n                                unsigned StopAt = 0);\n  ExprResult getOpenMPCapturedExpr(VarDecl *Capture, ExprValueKind VK,\n                                   ExprObjectKind OK, SourceLocation Loc);\n\n  /// If the current region is a loop-based region, mark the start of the loop\n  /// construct.\n  void startOpenMPLoop();\n\n  /// If the current region is a range loop-based region, mark the start of the\n  /// loop construct.\n  void startOpenMPCXXRangeFor();\n\n  /// Check if the specified variable is used in 'private' clause.\n  /// \\param Level Relative level of nested OpenMP construct for that the check\n  /// is performed.\n  OpenMPClauseKind isOpenMPPrivateDecl(ValueDecl *D, unsigned Level,\n                                       unsigned CapLevel) const;\n\n  /// Sets OpenMP capture kind (OMPC_private, OMPC_firstprivate, OMPC_map etc.)\n  /// for \\p FD based on DSA for the provided corresponding captured declaration\n  /// \\p D.\n  void setOpenMPCaptureKind(FieldDecl *FD, const ValueDecl *D, unsigned Level);\n\n  /// Check if the specified variable is captured  by 'target' directive.\n  /// \\param Level Relative level of nested OpenMP construct for that the check\n  /// is performed.\n  bool isOpenMPTargetCapturedDecl(const ValueDecl *D, unsigned Level,\n                                  unsigned CaptureLevel) const;\n\n  /// Check if the specified global variable must be captured  by outer capture\n  /// regions.\n  /// \\param Level Relative level of nested OpenMP construct for that\n  /// the check is performed.\n  bool isOpenMPGlobalCapturedDecl(ValueDecl *D, unsigned Level,\n                                  unsigned CaptureLevel) const;\n\n  ExprResult PerformOpenMPImplicitIntegerConversion(SourceLocation OpLoc,\n                                                    Expr *Op);\n  /// Called on start of new data sharing attribute block.\n  void StartOpenMPDSABlock(OpenMPDirectiveKind K,\n                           const DeclarationNameInfo &DirName, Scope *CurScope,\n                           SourceLocation Loc);\n  /// Start analysis of clauses.\n  void StartOpenMPClause(OpenMPClauseKind K);\n  /// End analysis of clauses.\n  void EndOpenMPClause();\n  /// Called on end of data sharing attribute block.\n  void EndOpenMPDSABlock(Stmt *CurDirective);\n\n  /// Check if the current region is an OpenMP loop region and if it is,\n  /// mark loop control variable, used in \\p Init for loop initialization, as\n  /// private by default.\n  /// \\param Init First part of the for loop.\n  void ActOnOpenMPLoopInitialization(SourceLocation ForLoc, Stmt *Init);\n\n  // OpenMP directives and clauses.\n  /// Called on correct id-expression from the '#pragma omp\n  /// threadprivate'.\n  ExprResult ActOnOpenMPIdExpression(Scope *CurScope, CXXScopeSpec &ScopeSpec,\n                                     const DeclarationNameInfo &Id,\n                                     OpenMPDirectiveKind Kind);\n  /// Called on well-formed '#pragma omp threadprivate'.\n  DeclGroupPtrTy ActOnOpenMPThreadprivateDirective(\n                                     SourceLocation Loc,\n                                     ArrayRef<Expr *> VarList);\n  /// Builds a new OpenMPThreadPrivateDecl and checks its correctness.\n  OMPThreadPrivateDecl *CheckOMPThreadPrivateDecl(SourceLocation Loc,\n                                                  ArrayRef<Expr *> VarList);\n  /// Called on well-formed '#pragma omp allocate'.\n  DeclGroupPtrTy ActOnOpenMPAllocateDirective(SourceLocation Loc,\n                                              ArrayRef<Expr *> VarList,\n                                              ArrayRef<OMPClause *> Clauses,\n                                              DeclContext *Owner = nullptr);\n\n  /// Called on well-formed '#pragma omp [begin] assume[s]'.\n  void ActOnOpenMPAssumesDirective(SourceLocation Loc,\n                                   OpenMPDirectiveKind DKind,\n                                   ArrayRef<StringRef> Assumptions,\n                                   bool SkippedClauses);\n\n  /// Check if there is an active global `omp begin assumes` directive.\n  bool isInOpenMPAssumeScope() const { return !OMPAssumeScoped.empty(); }\n\n  /// Check if there is an active global `omp assumes` directive.\n  bool hasGlobalOpenMPAssumes() const { return !OMPAssumeGlobal.empty(); }\n\n  /// Called on well-formed '#pragma omp end assumes'.\n  void ActOnOpenMPEndAssumesDirective();\n\n  /// Called on well-formed '#pragma omp requires'.\n  DeclGroupPtrTy ActOnOpenMPRequiresDirective(SourceLocation Loc,\n                                              ArrayRef<OMPClause *> ClauseList);\n  /// Check restrictions on Requires directive\n  OMPRequiresDecl *CheckOMPRequiresDecl(SourceLocation Loc,\n                                        ArrayRef<OMPClause *> Clauses);\n  /// Check if the specified type is allowed to be used in 'omp declare\n  /// reduction' construct.\n  QualType ActOnOpenMPDeclareReductionType(SourceLocation TyLoc,\n                                           TypeResult ParsedType);\n  /// Called on start of '#pragma omp declare reduction'.\n  DeclGroupPtrTy ActOnOpenMPDeclareReductionDirectiveStart(\n      Scope *S, DeclContext *DC, DeclarationName Name,\n      ArrayRef<std::pair<QualType, SourceLocation>> ReductionTypes,\n      AccessSpecifier AS, Decl *PrevDeclInScope = nullptr);\n  /// Initialize declare reduction construct initializer.\n  void ActOnOpenMPDeclareReductionCombinerStart(Scope *S, Decl *D);\n  /// Finish current declare reduction construct initializer.\n  void ActOnOpenMPDeclareReductionCombinerEnd(Decl *D, Expr *Combiner);\n  /// Initialize declare reduction construct initializer.\n  /// \\return omp_priv variable.\n  VarDecl *ActOnOpenMPDeclareReductionInitializerStart(Scope *S, Decl *D);\n  /// Finish current declare reduction construct initializer.\n  void ActOnOpenMPDeclareReductionInitializerEnd(Decl *D, Expr *Initializer,\n                                                 VarDecl *OmpPrivParm);\n  /// Called at the end of '#pragma omp declare reduction'.\n  DeclGroupPtrTy ActOnOpenMPDeclareReductionDirectiveEnd(\n      Scope *S, DeclGroupPtrTy DeclReductions, bool IsValid);\n\n  /// Check variable declaration in 'omp declare mapper' construct.\n  TypeResult ActOnOpenMPDeclareMapperVarDecl(Scope *S, Declarator &D);\n  /// Check if the specified type is allowed to be used in 'omp declare\n  /// mapper' construct.\n  QualType ActOnOpenMPDeclareMapperType(SourceLocation TyLoc,\n                                        TypeResult ParsedType);\n  /// Called on start of '#pragma omp declare mapper'.\n  DeclGroupPtrTy ActOnOpenMPDeclareMapperDirective(\n      Scope *S, DeclContext *DC, DeclarationName Name, QualType MapperType,\n      SourceLocation StartLoc, DeclarationName VN, AccessSpecifier AS,\n      Expr *MapperVarRef, ArrayRef<OMPClause *> Clauses,\n      Decl *PrevDeclInScope = nullptr);\n  /// Build the mapper variable of '#pragma omp declare mapper'.\n  ExprResult ActOnOpenMPDeclareMapperDirectiveVarDecl(Scope *S,\n                                                      QualType MapperType,\n                                                      SourceLocation StartLoc,\n                                                      DeclarationName VN);\n  bool isOpenMPDeclareMapperVarDeclAllowed(const VarDecl *VD) const;\n  const ValueDecl *getOpenMPDeclareMapperVarName() const;\n\n  /// Called on the start of target region i.e. '#pragma omp declare target'.\n  bool ActOnStartOpenMPDeclareTargetDirective(SourceLocation Loc);\n  /// Called at the end of target region i.e. '#pragme omp end declare target'.\n  void ActOnFinishOpenMPDeclareTargetDirective();\n  /// Searches for the provided declaration name for OpenMP declare target\n  /// directive.\n  NamedDecl *\n  lookupOpenMPDeclareTargetName(Scope *CurScope, CXXScopeSpec &ScopeSpec,\n                                const DeclarationNameInfo &Id,\n                                NamedDeclSetType &SameDirectiveDecls);\n  /// Called on correct id-expression from the '#pragma omp declare target'.\n  void ActOnOpenMPDeclareTargetName(NamedDecl *ND, SourceLocation Loc,\n                                    OMPDeclareTargetDeclAttr::MapTypeTy MT,\n                                    OMPDeclareTargetDeclAttr::DevTypeTy DT);\n  /// Check declaration inside target region.\n  void\n  checkDeclIsAllowedInOpenMPTarget(Expr *E, Decl *D,\n                                   SourceLocation IdLoc = SourceLocation());\n  /// Finishes analysis of the deferred functions calls that may be declared as\n  /// host/nohost during device/host compilation.\n  void finalizeOpenMPDelayedAnalysis(const FunctionDecl *Caller,\n                                     const FunctionDecl *Callee,\n                                     SourceLocation Loc);\n  /// Return true inside OpenMP declare target region.\n  bool isInOpenMPDeclareTargetContext() const {\n    return !DeclareTargetNesting.empty();\n  }\n  /// Return true inside OpenMP target region.\n  bool isInOpenMPTargetExecutionDirective() const;\n\n  /// Return the number of captured regions created for an OpenMP directive.\n  static int getOpenMPCaptureLevels(OpenMPDirectiveKind Kind);\n\n  /// Initialization of captured region for OpenMP region.\n  void ActOnOpenMPRegionStart(OpenMPDirectiveKind DKind, Scope *CurScope);\n\n  /// Called for syntactical loops (ForStmt or CXXForRangeStmt) associated to\n  /// an OpenMP loop directive.\n  StmtResult ActOnOpenMPCanonicalLoop(Stmt *AStmt);\n\n  /// End of OpenMP region.\n  ///\n  /// \\param S Statement associated with the current OpenMP region.\n  /// \\param Clauses List of clauses for the current OpenMP region.\n  ///\n  /// \\returns Statement for finished OpenMP region.\n  StmtResult ActOnOpenMPRegionEnd(StmtResult S, ArrayRef<OMPClause *> Clauses);\n  StmtResult ActOnOpenMPExecutableDirective(\n      OpenMPDirectiveKind Kind, const DeclarationNameInfo &DirName,\n      OpenMPDirectiveKind CancelRegion, ArrayRef<OMPClause *> Clauses,\n      Stmt *AStmt, SourceLocation StartLoc, SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp parallel' after parsing\n  /// of the  associated statement.\n  StmtResult ActOnOpenMPParallelDirective(ArrayRef<OMPClause *> Clauses,\n                                          Stmt *AStmt,\n                                          SourceLocation StartLoc,\n                                          SourceLocation EndLoc);\n  using VarsWithInheritedDSAType =\n      llvm::SmallDenseMap<const ValueDecl *, const Expr *, 4>;\n  /// Called on well-formed '\\#pragma omp simd' after parsing\n  /// of the associated statement.\n  StmtResult\n  ActOnOpenMPSimdDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                           SourceLocation StartLoc, SourceLocation EndLoc,\n                           VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '#pragma omp tile' after parsing of its clauses and\n  /// the associated statement.\n  StmtResult ActOnOpenMPTileDirective(ArrayRef<OMPClause *> Clauses,\n                                      Stmt *AStmt, SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp for' after parsing\n  /// of the associated statement.\n  StmtResult\n  ActOnOpenMPForDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                          SourceLocation StartLoc, SourceLocation EndLoc,\n                          VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp for simd' after parsing\n  /// of the associated statement.\n  StmtResult\n  ActOnOpenMPForSimdDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                              SourceLocation StartLoc, SourceLocation EndLoc,\n                              VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp sections' after parsing\n  /// of the associated statement.\n  StmtResult ActOnOpenMPSectionsDirective(ArrayRef<OMPClause *> Clauses,\n                                          Stmt *AStmt, SourceLocation StartLoc,\n                                          SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp section' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPSectionDirective(Stmt *AStmt, SourceLocation StartLoc,\n                                         SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp single' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPSingleDirective(ArrayRef<OMPClause *> Clauses,\n                                        Stmt *AStmt, SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp master' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPMasterDirective(Stmt *AStmt, SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp critical' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPCriticalDirective(const DeclarationNameInfo &DirName,\n                                          ArrayRef<OMPClause *> Clauses,\n                                          Stmt *AStmt, SourceLocation StartLoc,\n                                          SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp parallel for' after parsing\n  /// of the  associated statement.\n  StmtResult ActOnOpenMPParallelForDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp parallel for simd' after\n  /// parsing of the  associated statement.\n  StmtResult ActOnOpenMPParallelForSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp parallel master' after\n  /// parsing of the  associated statement.\n  StmtResult ActOnOpenMPParallelMasterDirective(ArrayRef<OMPClause *> Clauses,\n                                                Stmt *AStmt,\n                                                SourceLocation StartLoc,\n                                                SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp parallel sections' after\n  /// parsing of the  associated statement.\n  StmtResult ActOnOpenMPParallelSectionsDirective(ArrayRef<OMPClause *> Clauses,\n                                                  Stmt *AStmt,\n                                                  SourceLocation StartLoc,\n                                                  SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp task' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPTaskDirective(ArrayRef<OMPClause *> Clauses,\n                                      Stmt *AStmt, SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp taskyield'.\n  StmtResult ActOnOpenMPTaskyieldDirective(SourceLocation StartLoc,\n                                           SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp barrier'.\n  StmtResult ActOnOpenMPBarrierDirective(SourceLocation StartLoc,\n                                         SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp taskwait'.\n  StmtResult ActOnOpenMPTaskwaitDirective(SourceLocation StartLoc,\n                                          SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp taskgroup'.\n  StmtResult ActOnOpenMPTaskgroupDirective(ArrayRef<OMPClause *> Clauses,\n                                           Stmt *AStmt, SourceLocation StartLoc,\n                                           SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp flush'.\n  StmtResult ActOnOpenMPFlushDirective(ArrayRef<OMPClause *> Clauses,\n                                       SourceLocation StartLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp depobj'.\n  StmtResult ActOnOpenMPDepobjDirective(ArrayRef<OMPClause *> Clauses,\n                                        SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp scan'.\n  StmtResult ActOnOpenMPScanDirective(ArrayRef<OMPClause *> Clauses,\n                                      SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp ordered' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPOrderedDirective(ArrayRef<OMPClause *> Clauses,\n                                         Stmt *AStmt, SourceLocation StartLoc,\n                                         SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp atomic' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPAtomicDirective(ArrayRef<OMPClause *> Clauses,\n                                        Stmt *AStmt, SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp target' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPTargetDirective(ArrayRef<OMPClause *> Clauses,\n                                        Stmt *AStmt, SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp target data' after parsing of\n  /// the associated statement.\n  StmtResult ActOnOpenMPTargetDataDirective(ArrayRef<OMPClause *> Clauses,\n                                            Stmt *AStmt, SourceLocation StartLoc,\n                                            SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp target enter data' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetEnterDataDirective(ArrayRef<OMPClause *> Clauses,\n                                                 SourceLocation StartLoc,\n                                                 SourceLocation EndLoc,\n                                                 Stmt *AStmt);\n  /// Called on well-formed '\\#pragma omp target exit data' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetExitDataDirective(ArrayRef<OMPClause *> Clauses,\n                                                SourceLocation StartLoc,\n                                                SourceLocation EndLoc,\n                                                Stmt *AStmt);\n  /// Called on well-formed '\\#pragma omp target parallel' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetParallelDirective(ArrayRef<OMPClause *> Clauses,\n                                                Stmt *AStmt,\n                                                SourceLocation StartLoc,\n                                                SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp target parallel for' after\n  /// parsing of the  associated statement.\n  StmtResult ActOnOpenMPTargetParallelForDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp teams' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPTeamsDirective(ArrayRef<OMPClause *> Clauses,\n                                       Stmt *AStmt, SourceLocation StartLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp cancellation point'.\n  StmtResult\n  ActOnOpenMPCancellationPointDirective(SourceLocation StartLoc,\n                                        SourceLocation EndLoc,\n                                        OpenMPDirectiveKind CancelRegion);\n  /// Called on well-formed '\\#pragma omp cancel'.\n  StmtResult ActOnOpenMPCancelDirective(ArrayRef<OMPClause *> Clauses,\n                                        SourceLocation StartLoc,\n                                        SourceLocation EndLoc,\n                                        OpenMPDirectiveKind CancelRegion);\n  /// Called on well-formed '\\#pragma omp taskloop' after parsing of the\n  /// associated statement.\n  StmtResult\n  ActOnOpenMPTaskLoopDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                               SourceLocation StartLoc, SourceLocation EndLoc,\n                               VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp taskloop simd' after parsing of\n  /// the associated statement.\n  StmtResult ActOnOpenMPTaskLoopSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp master taskloop' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPMasterTaskLoopDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp master taskloop simd' after parsing of\n  /// the associated statement.\n  StmtResult ActOnOpenMPMasterTaskLoopSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp parallel master taskloop' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPParallelMasterTaskLoopDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp parallel master taskloop simd' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPParallelMasterTaskLoopSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp distribute' after parsing\n  /// of the associated statement.\n  StmtResult\n  ActOnOpenMPDistributeDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                                 SourceLocation StartLoc, SourceLocation EndLoc,\n                                 VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target update'.\n  StmtResult ActOnOpenMPTargetUpdateDirective(ArrayRef<OMPClause *> Clauses,\n                                              SourceLocation StartLoc,\n                                              SourceLocation EndLoc,\n                                              Stmt *AStmt);\n  /// Called on well-formed '\\#pragma omp distribute parallel for' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPDistributeParallelForDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp distribute parallel for simd'\n  /// after parsing of the associated statement.\n  StmtResult ActOnOpenMPDistributeParallelForSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp distribute simd' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPDistributeSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target parallel for simd' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetParallelForSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target simd' after parsing of\n  /// the associated statement.\n  StmtResult\n  ActOnOpenMPTargetSimdDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                                 SourceLocation StartLoc, SourceLocation EndLoc,\n                                 VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp teams distribute' after parsing of\n  /// the associated statement.\n  StmtResult ActOnOpenMPTeamsDistributeDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp teams distribute simd' after parsing\n  /// of the associated statement.\n  StmtResult ActOnOpenMPTeamsDistributeSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp teams distribute parallel for simd'\n  /// after parsing of the associated statement.\n  StmtResult ActOnOpenMPTeamsDistributeParallelForSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp teams distribute parallel for'\n  /// after parsing of the associated statement.\n  StmtResult ActOnOpenMPTeamsDistributeParallelForDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target teams' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPTargetTeamsDirective(ArrayRef<OMPClause *> Clauses,\n                                             Stmt *AStmt,\n                                             SourceLocation StartLoc,\n                                             SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp target teams distribute' after parsing\n  /// of the associated statement.\n  StmtResult ActOnOpenMPTargetTeamsDistributeDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target teams distribute parallel for'\n  /// after parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetTeamsDistributeParallelForDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target teams distribute parallel for\n  /// simd' after parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetTeamsDistributeParallelForSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target teams distribute simd' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetTeamsDistributeSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n\n  /// Checks correctness of linear modifiers.\n  bool CheckOpenMPLinearModifier(OpenMPLinearClauseKind LinKind,\n                                 SourceLocation LinLoc);\n  /// Checks that the specified declaration matches requirements for the linear\n  /// decls.\n  bool CheckOpenMPLinearDecl(const ValueDecl *D, SourceLocation ELoc,\n                             OpenMPLinearClauseKind LinKind, QualType Type,\n                             bool IsDeclareSimd = false);\n\n  /// Called on well-formed '\\#pragma omp declare simd' after parsing of\n  /// the associated method/function.\n  DeclGroupPtrTy ActOnOpenMPDeclareSimdDirective(\n      DeclGroupPtrTy DG, OMPDeclareSimdDeclAttr::BranchStateTy BS,\n      Expr *Simdlen, ArrayRef<Expr *> Uniforms, ArrayRef<Expr *> Aligneds,\n      ArrayRef<Expr *> Alignments, ArrayRef<Expr *> Linears,\n      ArrayRef<unsigned> LinModifiers, ArrayRef<Expr *> Steps, SourceRange SR);\n\n  /// Checks '\\#pragma omp declare variant' variant function and original\n  /// functions after parsing of the associated method/function.\n  /// \\param DG Function declaration to which declare variant directive is\n  /// applied to.\n  /// \\param VariantRef Expression that references the variant function, which\n  /// must be used instead of the original one, specified in \\p DG.\n  /// \\param TI The trait info object representing the match clause.\n  /// \\returns None, if the function/variant function are not compatible with\n  /// the pragma, pair of original function/variant ref expression otherwise.\n  Optional<std::pair<FunctionDecl *, Expr *>>\n  checkOpenMPDeclareVariantFunction(DeclGroupPtrTy DG, Expr *VariantRef,\n                                    OMPTraitInfo &TI, SourceRange SR);\n\n  /// Called on well-formed '\\#pragma omp declare variant' after parsing of\n  /// the associated method/function.\n  /// \\param FD Function declaration to which declare variant directive is\n  /// applied to.\n  /// \\param VariantRef Expression that references the variant function, which\n  /// must be used instead of the original one, specified in \\p DG.\n  /// \\param TI The context traits associated with the function variant.\n  void ActOnOpenMPDeclareVariantDirective(FunctionDecl *FD, Expr *VariantRef,\n                                          OMPTraitInfo &TI, SourceRange SR);\n\n  OMPClause *ActOnOpenMPSingleExprClause(OpenMPClauseKind Kind,\n                                         Expr *Expr,\n                                         SourceLocation StartLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation EndLoc);\n  /// Called on well-formed 'allocator' clause.\n  OMPClause *ActOnOpenMPAllocatorClause(Expr *Allocator,\n                                        SourceLocation StartLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed 'if' clause.\n  OMPClause *ActOnOpenMPIfClause(OpenMPDirectiveKind NameModifier,\n                                 Expr *Condition, SourceLocation StartLoc,\n                                 SourceLocation LParenLoc,\n                                 SourceLocation NameModifierLoc,\n                                 SourceLocation ColonLoc,\n                                 SourceLocation EndLoc);\n  /// Called on well-formed 'final' clause.\n  OMPClause *ActOnOpenMPFinalClause(Expr *Condition, SourceLocation StartLoc,\n                                    SourceLocation LParenLoc,\n                                    SourceLocation EndLoc);\n  /// Called on well-formed 'num_threads' clause.\n  OMPClause *ActOnOpenMPNumThreadsClause(Expr *NumThreads,\n                                         SourceLocation StartLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation EndLoc);\n  /// Called on well-formed 'safelen' clause.\n  OMPClause *ActOnOpenMPSafelenClause(Expr *Length,\n                                      SourceLocation StartLoc,\n                                      SourceLocation LParenLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'simdlen' clause.\n  OMPClause *ActOnOpenMPSimdlenClause(Expr *Length, SourceLocation StartLoc,\n                                      SourceLocation LParenLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-form 'sizes' clause.\n  OMPClause *ActOnOpenMPSizesClause(ArrayRef<Expr *> SizeExprs,\n                                    SourceLocation StartLoc,\n                                    SourceLocation LParenLoc,\n                                    SourceLocation EndLoc);\n  /// Called on well-formed 'collapse' clause.\n  OMPClause *ActOnOpenMPCollapseClause(Expr *NumForLoops,\n                                       SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed 'ordered' clause.\n  OMPClause *\n  ActOnOpenMPOrderedClause(SourceLocation StartLoc, SourceLocation EndLoc,\n                           SourceLocation LParenLoc = SourceLocation(),\n                           Expr *NumForLoops = nullptr);\n  /// Called on well-formed 'grainsize' clause.\n  OMPClause *ActOnOpenMPGrainsizeClause(Expr *Size, SourceLocation StartLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed 'num_tasks' clause.\n  OMPClause *ActOnOpenMPNumTasksClause(Expr *NumTasks, SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed 'hint' clause.\n  OMPClause *ActOnOpenMPHintClause(Expr *Hint, SourceLocation StartLoc,\n                                   SourceLocation LParenLoc,\n                                   SourceLocation EndLoc);\n  /// Called on well-formed 'detach' clause.\n  OMPClause *ActOnOpenMPDetachClause(Expr *Evt, SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n\n  OMPClause *ActOnOpenMPSimpleClause(OpenMPClauseKind Kind,\n                                     unsigned Argument,\n                                     SourceLocation ArgumentLoc,\n                                     SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'default' clause.\n  OMPClause *ActOnOpenMPDefaultClause(llvm::omp::DefaultKind Kind,\n                                      SourceLocation KindLoc,\n                                      SourceLocation StartLoc,\n                                      SourceLocation LParenLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'proc_bind' clause.\n  OMPClause *ActOnOpenMPProcBindClause(llvm::omp::ProcBindKind Kind,\n                                       SourceLocation KindLoc,\n                                       SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed 'order' clause.\n  OMPClause *ActOnOpenMPOrderClause(OpenMPOrderClauseKind Kind,\n                                    SourceLocation KindLoc,\n                                    SourceLocation StartLoc,\n                                    SourceLocation LParenLoc,\n                                    SourceLocation EndLoc);\n  /// Called on well-formed 'update' clause.\n  OMPClause *ActOnOpenMPUpdateClause(OpenMPDependClauseKind Kind,\n                                     SourceLocation KindLoc,\n                                     SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n\n  OMPClause *ActOnOpenMPSingleExprWithArgClause(\n      OpenMPClauseKind Kind, ArrayRef<unsigned> Arguments, Expr *Expr,\n      SourceLocation StartLoc, SourceLocation LParenLoc,\n      ArrayRef<SourceLocation> ArgumentsLoc, SourceLocation DelimLoc,\n      SourceLocation EndLoc);\n  /// Called on well-formed 'schedule' clause.\n  OMPClause *ActOnOpenMPScheduleClause(\n      OpenMPScheduleClauseModifier M1, OpenMPScheduleClauseModifier M2,\n      OpenMPScheduleClauseKind Kind, Expr *ChunkSize, SourceLocation StartLoc,\n      SourceLocation LParenLoc, SourceLocation M1Loc, SourceLocation M2Loc,\n      SourceLocation KindLoc, SourceLocation CommaLoc, SourceLocation EndLoc);\n\n  OMPClause *ActOnOpenMPClause(OpenMPClauseKind Kind, SourceLocation StartLoc,\n                               SourceLocation EndLoc);\n  /// Called on well-formed 'nowait' clause.\n  OMPClause *ActOnOpenMPNowaitClause(SourceLocation StartLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'untied' clause.\n  OMPClause *ActOnOpenMPUntiedClause(SourceLocation StartLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'mergeable' clause.\n  OMPClause *ActOnOpenMPMergeableClause(SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed 'read' clause.\n  OMPClause *ActOnOpenMPReadClause(SourceLocation StartLoc,\n                                   SourceLocation EndLoc);\n  /// Called on well-formed 'write' clause.\n  OMPClause *ActOnOpenMPWriteClause(SourceLocation StartLoc,\n                                    SourceLocation EndLoc);\n  /// Called on well-formed 'update' clause.\n  OMPClause *ActOnOpenMPUpdateClause(SourceLocation StartLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'capture' clause.\n  OMPClause *ActOnOpenMPCaptureClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'seq_cst' clause.\n  OMPClause *ActOnOpenMPSeqCstClause(SourceLocation StartLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'acq_rel' clause.\n  OMPClause *ActOnOpenMPAcqRelClause(SourceLocation StartLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'acquire' clause.\n  OMPClause *ActOnOpenMPAcquireClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'release' clause.\n  OMPClause *ActOnOpenMPReleaseClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'relaxed' clause.\n  OMPClause *ActOnOpenMPRelaxedClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'destroy' clause.\n  OMPClause *ActOnOpenMPDestroyClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'threads' clause.\n  OMPClause *ActOnOpenMPThreadsClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'simd' clause.\n  OMPClause *ActOnOpenMPSIMDClause(SourceLocation StartLoc,\n                                   SourceLocation EndLoc);\n  /// Called on well-formed 'nogroup' clause.\n  OMPClause *ActOnOpenMPNogroupClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'unified_address' clause.\n  OMPClause *ActOnOpenMPUnifiedAddressClause(SourceLocation StartLoc,\n                                             SourceLocation EndLoc);\n\n  /// Called on well-formed 'unified_address' clause.\n  OMPClause *ActOnOpenMPUnifiedSharedMemoryClause(SourceLocation StartLoc,\n                                                  SourceLocation EndLoc);\n\n  /// Called on well-formed 'reverse_offload' clause.\n  OMPClause *ActOnOpenMPReverseOffloadClause(SourceLocation StartLoc,\n                                             SourceLocation EndLoc);\n\n  /// Called on well-formed 'dynamic_allocators' clause.\n  OMPClause *ActOnOpenMPDynamicAllocatorsClause(SourceLocation StartLoc,\n                                                SourceLocation EndLoc);\n\n  /// Called on well-formed 'atomic_default_mem_order' clause.\n  OMPClause *ActOnOpenMPAtomicDefaultMemOrderClause(\n      OpenMPAtomicDefaultMemOrderClauseKind Kind, SourceLocation KindLoc,\n      SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation EndLoc);\n\n  OMPClause *ActOnOpenMPVarListClause(\n      OpenMPClauseKind Kind, ArrayRef<Expr *> Vars, Expr *DepModOrTailExpr,\n      const OMPVarListLocTy &Locs, SourceLocation ColonLoc,\n      CXXScopeSpec &ReductionOrMapperIdScopeSpec,\n      DeclarationNameInfo &ReductionOrMapperId, int ExtraModifier,\n      ArrayRef<OpenMPMapModifierKind> MapTypeModifiers,\n      ArrayRef<SourceLocation> MapTypeModifiersLoc, bool IsMapTypeImplicit,\n      SourceLocation ExtraModifierLoc,\n      ArrayRef<OpenMPMotionModifierKind> MotionModifiers,\n      ArrayRef<SourceLocation> MotionModifiersLoc);\n  /// Called on well-formed 'inclusive' clause.\n  OMPClause *ActOnOpenMPInclusiveClause(ArrayRef<Expr *> VarList,\n                                        SourceLocation StartLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed 'exclusive' clause.\n  OMPClause *ActOnOpenMPExclusiveClause(ArrayRef<Expr *> VarList,\n                                        SourceLocation StartLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed 'allocate' clause.\n  OMPClause *\n  ActOnOpenMPAllocateClause(Expr *Allocator, ArrayRef<Expr *> VarList,\n                            SourceLocation StartLoc, SourceLocation ColonLoc,\n                            SourceLocation LParenLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'private' clause.\n  OMPClause *ActOnOpenMPPrivateClause(ArrayRef<Expr *> VarList,\n                                      SourceLocation StartLoc,\n                                      SourceLocation LParenLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'firstprivate' clause.\n  OMPClause *ActOnOpenMPFirstprivateClause(ArrayRef<Expr *> VarList,\n                                           SourceLocation StartLoc,\n                                           SourceLocation LParenLoc,\n                                           SourceLocation EndLoc);\n  /// Called on well-formed 'lastprivate' clause.\n  OMPClause *ActOnOpenMPLastprivateClause(\n      ArrayRef<Expr *> VarList, OpenMPLastprivateModifier LPKind,\n      SourceLocation LPKindLoc, SourceLocation ColonLoc,\n      SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'shared' clause.\n  OMPClause *ActOnOpenMPSharedClause(ArrayRef<Expr *> VarList,\n                                     SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'reduction' clause.\n  OMPClause *ActOnOpenMPReductionClause(\n      ArrayRef<Expr *> VarList, OpenMPReductionClauseModifier Modifier,\n      SourceLocation StartLoc, SourceLocation LParenLoc,\n      SourceLocation ModifierLoc, SourceLocation ColonLoc,\n      SourceLocation EndLoc, CXXScopeSpec &ReductionIdScopeSpec,\n      const DeclarationNameInfo &ReductionId,\n      ArrayRef<Expr *> UnresolvedReductions = llvm::None);\n  /// Called on well-formed 'task_reduction' clause.\n  OMPClause *ActOnOpenMPTaskReductionClause(\n      ArrayRef<Expr *> VarList, SourceLocation StartLoc,\n      SourceLocation LParenLoc, SourceLocation ColonLoc, SourceLocation EndLoc,\n      CXXScopeSpec &ReductionIdScopeSpec,\n      const DeclarationNameInfo &ReductionId,\n      ArrayRef<Expr *> UnresolvedReductions = llvm::None);\n  /// Called on well-formed 'in_reduction' clause.\n  OMPClause *ActOnOpenMPInReductionClause(\n      ArrayRef<Expr *> VarList, SourceLocation StartLoc,\n      SourceLocation LParenLoc, SourceLocation ColonLoc, SourceLocation EndLoc,\n      CXXScopeSpec &ReductionIdScopeSpec,\n      const DeclarationNameInfo &ReductionId,\n      ArrayRef<Expr *> UnresolvedReductions = llvm::None);\n  /// Called on well-formed 'linear' clause.\n  OMPClause *\n  ActOnOpenMPLinearClause(ArrayRef<Expr *> VarList, Expr *Step,\n                          SourceLocation StartLoc, SourceLocation LParenLoc,\n                          OpenMPLinearClauseKind LinKind, SourceLocation LinLoc,\n                          SourceLocation ColonLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'aligned' clause.\n  OMPClause *ActOnOpenMPAlignedClause(ArrayRef<Expr *> VarList,\n                                      Expr *Alignment,\n                                      SourceLocation StartLoc,\n                                      SourceLocation LParenLoc,\n                                      SourceLocation ColonLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'copyin' clause.\n  OMPClause *ActOnOpenMPCopyinClause(ArrayRef<Expr *> VarList,\n                                     SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'copyprivate' clause.\n  OMPClause *ActOnOpenMPCopyprivateClause(ArrayRef<Expr *> VarList,\n                                          SourceLocation StartLoc,\n                                          SourceLocation LParenLoc,\n                                          SourceLocation EndLoc);\n  /// Called on well-formed 'flush' pseudo clause.\n  OMPClause *ActOnOpenMPFlushClause(ArrayRef<Expr *> VarList,\n                                    SourceLocation StartLoc,\n                                    SourceLocation LParenLoc,\n                                    SourceLocation EndLoc);\n  /// Called on well-formed 'depobj' pseudo clause.\n  OMPClause *ActOnOpenMPDepobjClause(Expr *Depobj, SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'depend' clause.\n  OMPClause *\n  ActOnOpenMPDependClause(Expr *DepModifier, OpenMPDependClauseKind DepKind,\n                          SourceLocation DepLoc, SourceLocation ColonLoc,\n                          ArrayRef<Expr *> VarList, SourceLocation StartLoc,\n                          SourceLocation LParenLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'device' clause.\n  OMPClause *ActOnOpenMPDeviceClause(OpenMPDeviceClauseModifier Modifier,\n                                     Expr *Device, SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation ModifierLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'map' clause.\n  OMPClause *\n  ActOnOpenMPMapClause(ArrayRef<OpenMPMapModifierKind> MapTypeModifiers,\n                       ArrayRef<SourceLocation> MapTypeModifiersLoc,\n                       CXXScopeSpec &MapperIdScopeSpec,\n                       DeclarationNameInfo &MapperId,\n                       OpenMPMapClauseKind MapType, bool IsMapTypeImplicit,\n                       SourceLocation MapLoc, SourceLocation ColonLoc,\n                       ArrayRef<Expr *> VarList, const OMPVarListLocTy &Locs,\n                       ArrayRef<Expr *> UnresolvedMappers = llvm::None);\n  /// Called on well-formed 'num_teams' clause.\n  OMPClause *ActOnOpenMPNumTeamsClause(Expr *NumTeams, SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed 'thread_limit' clause.\n  OMPClause *ActOnOpenMPThreadLimitClause(Expr *ThreadLimit,\n                                          SourceLocation StartLoc,\n                                          SourceLocation LParenLoc,\n                                          SourceLocation EndLoc);\n  /// Called on well-formed 'priority' clause.\n  OMPClause *ActOnOpenMPPriorityClause(Expr *Priority, SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed 'dist_schedule' clause.\n  OMPClause *ActOnOpenMPDistScheduleClause(\n      OpenMPDistScheduleClauseKind Kind, Expr *ChunkSize,\n      SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation KindLoc,\n      SourceLocation CommaLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'defaultmap' clause.\n  OMPClause *ActOnOpenMPDefaultmapClause(\n      OpenMPDefaultmapClauseModifier M, OpenMPDefaultmapClauseKind Kind,\n      SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation MLoc,\n      SourceLocation KindLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'to' clause.\n  OMPClause *\n  ActOnOpenMPToClause(ArrayRef<OpenMPMotionModifierKind> MotionModifiers,\n                      ArrayRef<SourceLocation> MotionModifiersLoc,\n                      CXXScopeSpec &MapperIdScopeSpec,\n                      DeclarationNameInfo &MapperId, SourceLocation ColonLoc,\n                      ArrayRef<Expr *> VarList, const OMPVarListLocTy &Locs,\n                      ArrayRef<Expr *> UnresolvedMappers = llvm::None);\n  /// Called on well-formed 'from' clause.\n  OMPClause *\n  ActOnOpenMPFromClause(ArrayRef<OpenMPMotionModifierKind> MotionModifiers,\n                        ArrayRef<SourceLocation> MotionModifiersLoc,\n                        CXXScopeSpec &MapperIdScopeSpec,\n                        DeclarationNameInfo &MapperId, SourceLocation ColonLoc,\n                        ArrayRef<Expr *> VarList, const OMPVarListLocTy &Locs,\n                        ArrayRef<Expr *> UnresolvedMappers = llvm::None);\n  /// Called on well-formed 'use_device_ptr' clause.\n  OMPClause *ActOnOpenMPUseDevicePtrClause(ArrayRef<Expr *> VarList,\n                                           const OMPVarListLocTy &Locs);\n  /// Called on well-formed 'use_device_addr' clause.\n  OMPClause *ActOnOpenMPUseDeviceAddrClause(ArrayRef<Expr *> VarList,\n                                            const OMPVarListLocTy &Locs);\n  /// Called on well-formed 'is_device_ptr' clause.\n  OMPClause *ActOnOpenMPIsDevicePtrClause(ArrayRef<Expr *> VarList,\n                                          const OMPVarListLocTy &Locs);\n  /// Called on well-formed 'nontemporal' clause.\n  OMPClause *ActOnOpenMPNontemporalClause(ArrayRef<Expr *> VarList,\n                                          SourceLocation StartLoc,\n                                          SourceLocation LParenLoc,\n                                          SourceLocation EndLoc);\n\n  /// Data for list of allocators.\n  struct UsesAllocatorsData {\n    /// Allocator.\n    Expr *Allocator = nullptr;\n    /// Allocator traits.\n    Expr *AllocatorTraits = nullptr;\n    /// Locations of '(' and ')' symbols.\n    SourceLocation LParenLoc, RParenLoc;\n  };\n  /// Called on well-formed 'uses_allocators' clause.\n  OMPClause *ActOnOpenMPUsesAllocatorClause(SourceLocation StartLoc,\n                                            SourceLocation LParenLoc,\n                                            SourceLocation EndLoc,\n                                            ArrayRef<UsesAllocatorsData> Data);\n  /// Called on well-formed 'affinity' clause.\n  OMPClause *ActOnOpenMPAffinityClause(SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation ColonLoc,\n                                       SourceLocation EndLoc, Expr *Modifier,\n                                       ArrayRef<Expr *> Locators);\n\n  /// The kind of conversion being performed.\n  enum CheckedConversionKind {\n    /// An implicit conversion.\n    CCK_ImplicitConversion,\n    /// A C-style cast.\n    CCK_CStyleCast,\n    /// A functional-style cast.\n    CCK_FunctionalCast,\n    /// A cast other than a C-style cast.\n    CCK_OtherCast,\n    /// A conversion for an operand of a builtin overloaded operator.\n    CCK_ForBuiltinOverloadedOp\n  };\n\n  static bool isCast(CheckedConversionKind CCK) {\n    return CCK == CCK_CStyleCast || CCK == CCK_FunctionalCast ||\n           CCK == CCK_OtherCast;\n  }\n\n  /// ImpCastExprToType - If Expr is not of type 'Type', insert an implicit\n  /// cast.  If there is already an implicit cast, merge into the existing one.\n  /// If isLvalue, the result of the cast is an lvalue.\n  ExprResult ImpCastExprToType(Expr *E, QualType Type, CastKind CK,\n                               ExprValueKind VK = VK_RValue,\n                               const CXXCastPath *BasePath = nullptr,\n                               CheckedConversionKind CCK\n                                  = CCK_ImplicitConversion);\n\n  /// ScalarTypeToBooleanCastKind - Returns the cast kind corresponding\n  /// to the conversion from scalar type ScalarTy to the Boolean type.\n  static CastKind ScalarTypeToBooleanCastKind(QualType ScalarTy);\n\n  /// IgnoredValueConversions - Given that an expression's result is\n  /// syntactically ignored, perform any conversions that are\n  /// required.\n  ExprResult IgnoredValueConversions(Expr *E);\n\n  // UsualUnaryConversions - promotes integers (C99 6.3.1.1p2) and converts\n  // functions and arrays to their respective pointers (C99 6.3.2.1).\n  ExprResult UsualUnaryConversions(Expr *E);\n\n  /// CallExprUnaryConversions - a special case of an unary conversion\n  /// performed on a function designator of a call expression.\n  ExprResult CallExprUnaryConversions(Expr *E);\n\n  // DefaultFunctionArrayConversion - converts functions and arrays\n  // to their respective pointers (C99 6.3.2.1).\n  ExprResult DefaultFunctionArrayConversion(Expr *E, bool Diagnose = true);\n\n  // DefaultFunctionArrayLvalueConversion - converts functions and\n  // arrays to their respective pointers and performs the\n  // lvalue-to-rvalue conversion.\n  ExprResult DefaultFunctionArrayLvalueConversion(Expr *E,\n                                                  bool Diagnose = true);\n\n  // DefaultLvalueConversion - performs lvalue-to-rvalue conversion on\n  // the operand. This function is a no-op if the operand has a function type\n  // or an array type.\n  ExprResult DefaultLvalueConversion(Expr *E);\n\n  // DefaultArgumentPromotion (C99 6.5.2.2p6). Used for function calls that\n  // do not have a prototype. Integer promotions are performed on each\n  // argument, and arguments that have type float are promoted to double.\n  ExprResult DefaultArgumentPromotion(Expr *E);\n\n  /// If \\p E is a prvalue denoting an unmaterialized temporary, materialize\n  /// it as an xvalue. In C++98, the result will still be a prvalue, because\n  /// we don't have xvalues there.\n  ExprResult TemporaryMaterializationConversion(Expr *E);\n\n  // Used for emitting the right warning by DefaultVariadicArgumentPromotion\n  enum VariadicCallType {\n    VariadicFunction,\n    VariadicBlock,\n    VariadicMethod,\n    VariadicConstructor,\n    VariadicDoesNotApply\n  };\n\n  VariadicCallType getVariadicCallType(FunctionDecl *FDecl,\n                                       const FunctionProtoType *Proto,\n                                       Expr *Fn);\n\n  // Used for determining in which context a type is allowed to be passed to a\n  // vararg function.\n  enum VarArgKind {\n    VAK_Valid,\n    VAK_ValidInCXX11,\n    VAK_Undefined,\n    VAK_MSVCUndefined,\n    VAK_Invalid\n  };\n\n  // Determines which VarArgKind fits an expression.\n  VarArgKind isValidVarArgType(const QualType &Ty);\n\n  /// Check to see if the given expression is a valid argument to a variadic\n  /// function, issuing a diagnostic if not.\n  void checkVariadicArgument(const Expr *E, VariadicCallType CT);\n\n  /// Check to see if a given expression could have '.c_str()' called on it.\n  bool hasCStrMethod(const Expr *E);\n\n  /// GatherArgumentsForCall - Collector argument expressions for various\n  /// form of call prototypes.\n  bool GatherArgumentsForCall(SourceLocation CallLoc, FunctionDecl *FDecl,\n                              const FunctionProtoType *Proto,\n                              unsigned FirstParam, ArrayRef<Expr *> Args,\n                              SmallVectorImpl<Expr *> &AllArgs,\n                              VariadicCallType CallType = VariadicDoesNotApply,\n                              bool AllowExplicit = false,\n                              bool IsListInitialization = false);\n\n  // DefaultVariadicArgumentPromotion - Like DefaultArgumentPromotion, but\n  // will create a runtime trap if the resulting type is not a POD type.\n  ExprResult DefaultVariadicArgumentPromotion(Expr *E, VariadicCallType CT,\n                                              FunctionDecl *FDecl);\n\n  /// Context in which we're performing a usual arithmetic conversion.\n  enum ArithConvKind {\n    /// An arithmetic operation.\n    ACK_Arithmetic,\n    /// A bitwise operation.\n    ACK_BitwiseOp,\n    /// A comparison.\n    ACK_Comparison,\n    /// A conditional (?:) operator.\n    ACK_Conditional,\n    /// A compound assignment expression.\n    ACK_CompAssign,\n  };\n\n  // UsualArithmeticConversions - performs the UsualUnaryConversions on it's\n  // operands and then handles various conversions that are common to binary\n  // operators (C99 6.3.1.8). If both operands aren't arithmetic, this\n  // routine returns the first non-arithmetic type found. The client is\n  // responsible for emitting appropriate error diagnostics.\n  QualType UsualArithmeticConversions(ExprResult &LHS, ExprResult &RHS,\n                                      SourceLocation Loc, ArithConvKind ACK);\n\n  /// AssignConvertType - All of the 'assignment' semantic checks return this\n  /// enum to indicate whether the assignment was allowed.  These checks are\n  /// done for simple assignments, as well as initialization, return from\n  /// function, argument passing, etc.  The query is phrased in terms of a\n  /// source and destination type.\n  enum AssignConvertType {\n    /// Compatible - the types are compatible according to the standard.\n    Compatible,\n\n    /// PointerToInt - The assignment converts a pointer to an int, which we\n    /// accept as an extension.\n    PointerToInt,\n\n    /// IntToPointer - The assignment converts an int to a pointer, which we\n    /// accept as an extension.\n    IntToPointer,\n\n    /// FunctionVoidPointer - The assignment is between a function pointer and\n    /// void*, which the standard doesn't allow, but we accept as an extension.\n    FunctionVoidPointer,\n\n    /// IncompatiblePointer - The assignment is between two pointers types that\n    /// are not compatible, but we accept them as an extension.\n    IncompatiblePointer,\n\n    /// IncompatibleFunctionPointer - The assignment is between two function\n    /// pointers types that are not compatible, but we accept them as an\n    /// extension.\n    IncompatibleFunctionPointer,\n\n    /// IncompatiblePointerSign - The assignment is between two pointers types\n    /// which point to integers which have a different sign, but are otherwise\n    /// identical. This is a subset of the above, but broken out because it's by\n    /// far the most common case of incompatible pointers.\n    IncompatiblePointerSign,\n\n    /// CompatiblePointerDiscardsQualifiers - The assignment discards\n    /// c/v/r qualifiers, which we accept as an extension.\n    CompatiblePointerDiscardsQualifiers,\n\n    /// IncompatiblePointerDiscardsQualifiers - The assignment\n    /// discards qualifiers that we don't permit to be discarded,\n    /// like address spaces.\n    IncompatiblePointerDiscardsQualifiers,\n\n    /// IncompatibleNestedPointerAddressSpaceMismatch - The assignment\n    /// changes address spaces in nested pointer types which is not allowed.\n    /// For instance, converting __private int ** to __generic int ** is\n    /// illegal even though __private could be converted to __generic.\n    IncompatibleNestedPointerAddressSpaceMismatch,\n\n    /// IncompatibleNestedPointerQualifiers - The assignment is between two\n    /// nested pointer types, and the qualifiers other than the first two\n    /// levels differ e.g. char ** -> const char **, but we accept them as an\n    /// extension.\n    IncompatibleNestedPointerQualifiers,\n\n    /// IncompatibleVectors - The assignment is between two vector types that\n    /// have the same size, which we accept as an extension.\n    IncompatibleVectors,\n\n    /// IntToBlockPointer - The assignment converts an int to a block\n    /// pointer. We disallow this.\n    IntToBlockPointer,\n\n    /// IncompatibleBlockPointer - The assignment is between two block\n    /// pointers types that are not compatible.\n    IncompatibleBlockPointer,\n\n    /// IncompatibleObjCQualifiedId - The assignment is between a qualified\n    /// id type and something else (that is incompatible with it). For example,\n    /// \"id <XXX>\" = \"Foo *\", where \"Foo *\" doesn't implement the XXX protocol.\n    IncompatibleObjCQualifiedId,\n\n    /// IncompatibleObjCWeakRef - Assigning a weak-unavailable object to an\n    /// object with __weak qualifier.\n    IncompatibleObjCWeakRef,\n\n    /// Incompatible - We reject this conversion outright, it is invalid to\n    /// represent it in the AST.\n    Incompatible\n  };\n\n  /// DiagnoseAssignmentResult - Emit a diagnostic, if required, for the\n  /// assignment conversion type specified by ConvTy.  This returns true if the\n  /// conversion was invalid or false if the conversion was accepted.\n  bool DiagnoseAssignmentResult(AssignConvertType ConvTy,\n                                SourceLocation Loc,\n                                QualType DstType, QualType SrcType,\n                                Expr *SrcExpr, AssignmentAction Action,\n                                bool *Complained = nullptr);\n\n  /// IsValueInFlagEnum - Determine if a value is allowed as part of a flag\n  /// enum. If AllowMask is true, then we also allow the complement of a valid\n  /// value, to be used as a mask.\n  bool IsValueInFlagEnum(const EnumDecl *ED, const llvm::APInt &Val,\n                         bool AllowMask) const;\n\n  /// DiagnoseAssignmentEnum - Warn if assignment to enum is a constant\n  /// integer not in the range of enum values.\n  void DiagnoseAssignmentEnum(QualType DstType, QualType SrcType,\n                              Expr *SrcExpr);\n\n  /// CheckAssignmentConstraints - Perform type checking for assignment,\n  /// argument passing, variable initialization, and function return values.\n  /// C99 6.5.16.\n  AssignConvertType CheckAssignmentConstraints(SourceLocation Loc,\n                                               QualType LHSType,\n                                               QualType RHSType);\n\n  /// Check assignment constraints and optionally prepare for a conversion of\n  /// the RHS to the LHS type. The conversion is prepared for if ConvertRHS\n  /// is true.\n  AssignConvertType CheckAssignmentConstraints(QualType LHSType,\n                                               ExprResult &RHS,\n                                               CastKind &Kind,\n                                               bool ConvertRHS = true);\n\n  /// Check assignment constraints for an assignment of RHS to LHSType.\n  ///\n  /// \\param LHSType The destination type for the assignment.\n  /// \\param RHS The source expression for the assignment.\n  /// \\param Diagnose If \\c true, diagnostics may be produced when checking\n  ///        for assignability. If a diagnostic is produced, \\p RHS will be\n  ///        set to ExprError(). Note that this function may still return\n  ///        without producing a diagnostic, even for an invalid assignment.\n  /// \\param DiagnoseCFAudited If \\c true, the target is a function parameter\n  ///        in an audited Core Foundation API and does not need to be checked\n  ///        for ARC retain issues.\n  /// \\param ConvertRHS If \\c true, \\p RHS will be updated to model the\n  ///        conversions necessary to perform the assignment. If \\c false,\n  ///        \\p Diagnose must also be \\c false.\n  AssignConvertType CheckSingleAssignmentConstraints(\n      QualType LHSType, ExprResult &RHS, bool Diagnose = true,\n      bool DiagnoseCFAudited = false, bool ConvertRHS = true);\n\n  // If the lhs type is a transparent union, check whether we\n  // can initialize the transparent union with the given expression.\n  AssignConvertType CheckTransparentUnionArgumentConstraints(QualType ArgType,\n                                                             ExprResult &RHS);\n\n  bool IsStringLiteralToNonConstPointerConversion(Expr *From, QualType ToType);\n\n  bool CheckExceptionSpecCompatibility(Expr *From, QualType ToType);\n\n  ExprResult PerformImplicitConversion(Expr *From, QualType ToType,\n                                       AssignmentAction Action,\n                                       bool AllowExplicit = false);\n  ExprResult PerformImplicitConversion(Expr *From, QualType ToType,\n                                       const ImplicitConversionSequence& ICS,\n                                       AssignmentAction Action,\n                                       CheckedConversionKind CCK\n                                          = CCK_ImplicitConversion);\n  ExprResult PerformImplicitConversion(Expr *From, QualType ToType,\n                                       const StandardConversionSequence& SCS,\n                                       AssignmentAction Action,\n                                       CheckedConversionKind CCK);\n\n  ExprResult PerformQualificationConversion(\n      Expr *E, QualType Ty, ExprValueKind VK = VK_RValue,\n      CheckedConversionKind CCK = CCK_ImplicitConversion);\n\n  /// the following \"Check\" methods will return a valid/converted QualType\n  /// or a null QualType (indicating an error diagnostic was issued).\n\n  /// type checking binary operators (subroutines of CreateBuiltinBinOp).\n  QualType InvalidOperands(SourceLocation Loc, ExprResult &LHS,\n                           ExprResult &RHS);\n  QualType InvalidLogicalVectorOperands(SourceLocation Loc, ExprResult &LHS,\n                                 ExprResult &RHS);\n  QualType CheckPointerToMemberOperands( // C++ 5.5\n    ExprResult &LHS, ExprResult &RHS, ExprValueKind &VK,\n    SourceLocation OpLoc, bool isIndirect);\n  QualType CheckMultiplyDivideOperands( // C99 6.5.5\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc, bool IsCompAssign,\n    bool IsDivide);\n  QualType CheckRemainderOperands( // C99 6.5.5\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n    bool IsCompAssign = false);\n  QualType CheckAdditionOperands( // C99 6.5.6\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n    BinaryOperatorKind Opc, QualType* CompLHSTy = nullptr);\n  QualType CheckSubtractionOperands( // C99 6.5.6\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n    QualType* CompLHSTy = nullptr);\n  QualType CheckShiftOperands( // C99 6.5.7\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n    BinaryOperatorKind Opc, bool IsCompAssign = false);\n  void CheckPtrComparisonWithNullChar(ExprResult &E, ExprResult &NullE);\n  QualType CheckCompareOperands( // C99 6.5.8/9\n      ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n      BinaryOperatorKind Opc);\n  QualType CheckBitwiseOperands( // C99 6.5.[10...12]\n      ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n      BinaryOperatorKind Opc);\n  QualType CheckLogicalOperands( // C99 6.5.[13,14]\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n    BinaryOperatorKind Opc);\n  // CheckAssignmentOperands is used for both simple and compound assignment.\n  // For simple assignment, pass both expressions and a null converted type.\n  // For compound assignment, pass both expressions and the converted type.\n  QualType CheckAssignmentOperands( // C99 6.5.16.[1,2]\n    Expr *LHSExpr, ExprResult &RHS, SourceLocation Loc, QualType CompoundType);\n\n  ExprResult checkPseudoObjectIncDec(Scope *S, SourceLocation OpLoc,\n                                     UnaryOperatorKind Opcode, Expr *Op);\n  ExprResult checkPseudoObjectAssignment(Scope *S, SourceLocation OpLoc,\n                                         BinaryOperatorKind Opcode,\n                                         Expr *LHS, Expr *RHS);\n  ExprResult checkPseudoObjectRValue(Expr *E);\n  Expr *recreateSyntacticForm(PseudoObjectExpr *E);\n\n  QualType CheckConditionalOperands( // C99 6.5.15\n    ExprResult &Cond, ExprResult &LHS, ExprResult &RHS,\n    ExprValueKind &VK, ExprObjectKind &OK, SourceLocation QuestionLoc);\n  QualType CXXCheckConditionalOperands( // C++ 5.16\n    ExprResult &cond, ExprResult &lhs, ExprResult &rhs,\n    ExprValueKind &VK, ExprObjectKind &OK, SourceLocation questionLoc);\n  QualType CheckVectorConditionalTypes(ExprResult &Cond, ExprResult &LHS,\n                                       ExprResult &RHS,\n                                       SourceLocation QuestionLoc);\n  QualType FindCompositePointerType(SourceLocation Loc, Expr *&E1, Expr *&E2,\n                                    bool ConvertArgs = true);\n  QualType FindCompositePointerType(SourceLocation Loc,\n                                    ExprResult &E1, ExprResult &E2,\n                                    bool ConvertArgs = true) {\n    Expr *E1Tmp = E1.get(), *E2Tmp = E2.get();\n    QualType Composite =\n        FindCompositePointerType(Loc, E1Tmp, E2Tmp, ConvertArgs);\n    E1 = E1Tmp;\n    E2 = E2Tmp;\n    return Composite;\n  }\n\n  QualType FindCompositeObjCPointerType(ExprResult &LHS, ExprResult &RHS,\n                                        SourceLocation QuestionLoc);\n\n  bool DiagnoseConditionalForNull(Expr *LHSExpr, Expr *RHSExpr,\n                                  SourceLocation QuestionLoc);\n\n  void DiagnoseAlwaysNonNullPointer(Expr *E,\n                                    Expr::NullPointerConstantKind NullType,\n                                    bool IsEqual, SourceRange Range);\n\n  /// type checking for vector binary operators.\n  QualType CheckVectorOperands(ExprResult &LHS, ExprResult &RHS,\n                               SourceLocation Loc, bool IsCompAssign,\n                               bool AllowBothBool, bool AllowBoolConversion);\n  QualType GetSignedVectorType(QualType V);\n  QualType CheckVectorCompareOperands(ExprResult &LHS, ExprResult &RHS,\n                                      SourceLocation Loc,\n                                      BinaryOperatorKind Opc);\n  QualType CheckVectorLogicalOperands(ExprResult &LHS, ExprResult &RHS,\n                                      SourceLocation Loc);\n\n  /// Type checking for matrix binary operators.\n  QualType CheckMatrixElementwiseOperands(ExprResult &LHS, ExprResult &RHS,\n                                          SourceLocation Loc,\n                                          bool IsCompAssign);\n  QualType CheckMatrixMultiplyOperands(ExprResult &LHS, ExprResult &RHS,\n                                       SourceLocation Loc, bool IsCompAssign);\n\n  bool isValidSveBitcast(QualType srcType, QualType destType);\n\n  bool areLaxCompatibleVectorTypes(QualType srcType, QualType destType);\n  bool isLaxVectorConversion(QualType srcType, QualType destType);\n\n  /// type checking declaration initializers (C99 6.7.8)\n  bool CheckForConstantInitializer(Expr *e, QualType t);\n\n  // type checking C++ declaration initializers (C++ [dcl.init]).\n\n  /// ReferenceCompareResult - Expresses the result of comparing two\n  /// types (cv1 T1 and cv2 T2) to determine their compatibility for the\n  /// purposes of initialization by reference (C++ [dcl.init.ref]p4).\n  enum ReferenceCompareResult {\n    /// Ref_Incompatible - The two types are incompatible, so direct\n    /// reference binding is not possible.\n    Ref_Incompatible = 0,\n    /// Ref_Related - The two types are reference-related, which means\n    /// that their unqualified forms (T1 and T2) are either the same\n    /// or T1 is a base class of T2.\n    Ref_Related,\n    /// Ref_Compatible - The two types are reference-compatible.\n    Ref_Compatible\n  };\n\n  // Fake up a scoped enumeration that still contextually converts to bool.\n  struct ReferenceConversionsScope {\n    /// The conversions that would be performed on an lvalue of type T2 when\n    /// binding a reference of type T1 to it, as determined when evaluating\n    /// whether T1 is reference-compatible with T2.\n    enum ReferenceConversions {\n      Qualification = 0x1,\n      NestedQualification = 0x2,\n      Function = 0x4,\n      DerivedToBase = 0x8,\n      ObjC = 0x10,\n      ObjCLifetime = 0x20,\n\n      LLVM_MARK_AS_BITMASK_ENUM(/*LargestValue=*/ObjCLifetime)\n    };\n  };\n  using ReferenceConversions = ReferenceConversionsScope::ReferenceConversions;\n\n  ReferenceCompareResult\n  CompareReferenceRelationship(SourceLocation Loc, QualType T1, QualType T2,\n                               ReferenceConversions *Conv = nullptr);\n\n  ExprResult checkUnknownAnyCast(SourceRange TypeRange, QualType CastType,\n                                 Expr *CastExpr, CastKind &CastKind,\n                                 ExprValueKind &VK, CXXCastPath &Path);\n\n  /// Force an expression with unknown-type to an expression of the\n  /// given type.\n  ExprResult forceUnknownAnyToType(Expr *E, QualType ToType);\n\n  /// Type-check an expression that's being passed to an\n  /// __unknown_anytype parameter.\n  ExprResult checkUnknownAnyArg(SourceLocation callLoc,\n                                Expr *result, QualType &paramType);\n\n  // CheckVectorCast - check type constraints for vectors.\n  // Since vectors are an extension, there are no C standard reference for this.\n  // We allow casting between vectors and integer datatypes of the same size.\n  // returns true if the cast is invalid\n  bool CheckVectorCast(SourceRange R, QualType VectorTy, QualType Ty,\n                       CastKind &Kind);\n\n  /// Prepare `SplattedExpr` for a vector splat operation, adding\n  /// implicit casts if necessary.\n  ExprResult prepareVectorSplat(QualType VectorTy, Expr *SplattedExpr);\n\n  // CheckExtVectorCast - check type constraints for extended vectors.\n  // Since vectors are an extension, there are no C standard reference for this.\n  // We allow casting between vectors and integer datatypes of the same size,\n  // or vectors and the element type of that vector.\n  // returns the cast expr\n  ExprResult CheckExtVectorCast(SourceRange R, QualType DestTy, Expr *CastExpr,\n                                CastKind &Kind);\n\n  ExprResult BuildCXXFunctionalCastExpr(TypeSourceInfo *TInfo, QualType Type,\n                                        SourceLocation LParenLoc,\n                                        Expr *CastExpr,\n                                        SourceLocation RParenLoc);\n\n  enum ARCConversionResult { ACR_okay, ACR_unbridged, ACR_error };\n\n  /// Checks for invalid conversions and casts between\n  /// retainable pointers and other pointer kinds for ARC and Weak.\n  ARCConversionResult CheckObjCConversion(SourceRange castRange,\n                                          QualType castType, Expr *&op,\n                                          CheckedConversionKind CCK,\n                                          bool Diagnose = true,\n                                          bool DiagnoseCFAudited = false,\n                                          BinaryOperatorKind Opc = BO_PtrMemD\n                                          );\n\n  Expr *stripARCUnbridgedCast(Expr *e);\n  void diagnoseARCUnbridgedCast(Expr *e);\n\n  bool CheckObjCARCUnavailableWeakConversion(QualType castType,\n                                             QualType ExprType);\n\n  /// checkRetainCycles - Check whether an Objective-C message send\n  /// might create an obvious retain cycle.\n  void checkRetainCycles(ObjCMessageExpr *msg);\n  void checkRetainCycles(Expr *receiver, Expr *argument);\n  void checkRetainCycles(VarDecl *Var, Expr *Init);\n\n  /// checkUnsafeAssigns - Check whether +1 expr is being assigned\n  /// to weak/__unsafe_unretained type.\n  bool checkUnsafeAssigns(SourceLocation Loc, QualType LHS, Expr *RHS);\n\n  /// checkUnsafeExprAssigns - Check whether +1 expr is being assigned\n  /// to weak/__unsafe_unretained expression.\n  void checkUnsafeExprAssigns(SourceLocation Loc, Expr *LHS, Expr *RHS);\n\n  /// CheckMessageArgumentTypes - Check types in an Obj-C message send.\n  /// \\param Method - May be null.\n  /// \\param [out] ReturnType - The return type of the send.\n  /// \\return true iff there were any incompatible types.\n  bool CheckMessageArgumentTypes(const Expr *Receiver, QualType ReceiverType,\n                                 MultiExprArg Args, Selector Sel,\n                                 ArrayRef<SourceLocation> SelectorLocs,\n                                 ObjCMethodDecl *Method, bool isClassMessage,\n                                 bool isSuperMessage, SourceLocation lbrac,\n                                 SourceLocation rbrac, SourceRange RecRange,\n                                 QualType &ReturnType, ExprValueKind &VK);\n\n  /// Determine the result of a message send expression based on\n  /// the type of the receiver, the method expected to receive the message,\n  /// and the form of the message send.\n  QualType getMessageSendResultType(const Expr *Receiver, QualType ReceiverType,\n                                    ObjCMethodDecl *Method, bool isClassMessage,\n                                    bool isSuperMessage);\n\n  /// If the given expression involves a message send to a method\n  /// with a related result type, emit a note describing what happened.\n  void EmitRelatedResultTypeNote(const Expr *E);\n\n  /// Given that we had incompatible pointer types in a return\n  /// statement, check whether we're in a method with a related result\n  /// type, and if so, emit a note describing what happened.\n  void EmitRelatedResultTypeNoteForReturn(QualType destType);\n\n  class ConditionResult {\n    Decl *ConditionVar;\n    FullExprArg Condition;\n    bool Invalid;\n    bool HasKnownValue;\n    bool KnownValue;\n\n    friend class Sema;\n    ConditionResult(Sema &S, Decl *ConditionVar, FullExprArg Condition,\n                    bool IsConstexpr)\n        : ConditionVar(ConditionVar), Condition(Condition), Invalid(false),\n          HasKnownValue(IsConstexpr && Condition.get() &&\n                        !Condition.get()->isValueDependent()),\n          KnownValue(HasKnownValue &&\n                     !!Condition.get()->EvaluateKnownConstInt(S.Context)) {}\n    explicit ConditionResult(bool Invalid)\n        : ConditionVar(nullptr), Condition(nullptr), Invalid(Invalid),\n          HasKnownValue(false), KnownValue(false) {}\n\n  public:\n    ConditionResult() : ConditionResult(false) {}\n    bool isInvalid() const { return Invalid; }\n    std::pair<VarDecl *, Expr *> get() const {\n      return std::make_pair(cast_or_null<VarDecl>(ConditionVar),\n                            Condition.get());\n    }\n    llvm::Optional<bool> getKnownValue() const {\n      if (!HasKnownValue)\n        return None;\n      return KnownValue;\n    }\n  };\n  static ConditionResult ConditionError() { return ConditionResult(true); }\n\n  enum class ConditionKind {\n    Boolean,     ///< A boolean condition, from 'if', 'while', 'for', or 'do'.\n    ConstexprIf, ///< A constant boolean condition from 'if constexpr'.\n    Switch       ///< An integral condition for a 'switch' statement.\n  };\n\n  ConditionResult ActOnCondition(Scope *S, SourceLocation Loc,\n                                 Expr *SubExpr, ConditionKind CK);\n\n  ConditionResult ActOnConditionVariable(Decl *ConditionVar,\n                                         SourceLocation StmtLoc,\n                                         ConditionKind CK);\n\n  DeclResult ActOnCXXConditionDeclaration(Scope *S, Declarator &D);\n\n  ExprResult CheckConditionVariable(VarDecl *ConditionVar,\n                                    SourceLocation StmtLoc,\n                                    ConditionKind CK);\n  ExprResult CheckSwitchCondition(SourceLocation SwitchLoc, Expr *Cond);\n\n  /// CheckBooleanCondition - Diagnose problems involving the use of\n  /// the given expression as a boolean condition (e.g. in an if\n  /// statement).  Also performs the standard function and array\n  /// decays, possibly changing the input variable.\n  ///\n  /// \\param Loc - A location associated with the condition, e.g. the\n  /// 'if' keyword.\n  /// \\return true iff there were any errors\n  ExprResult CheckBooleanCondition(SourceLocation Loc, Expr *E,\n                                   bool IsConstexpr = false);\n\n  /// ActOnExplicitBoolSpecifier - Build an ExplicitSpecifier from an expression\n  /// found in an explicit(bool) specifier.\n  ExplicitSpecifier ActOnExplicitBoolSpecifier(Expr *E);\n\n  /// tryResolveExplicitSpecifier - Attempt to resolve the explict specifier.\n  /// Returns true if the explicit specifier is now resolved.\n  bool tryResolveExplicitSpecifier(ExplicitSpecifier &ExplicitSpec);\n\n  /// DiagnoseAssignmentAsCondition - Given that an expression is\n  /// being used as a boolean condition, warn if it's an assignment.\n  void DiagnoseAssignmentAsCondition(Expr *E);\n\n  /// Redundant parentheses over an equality comparison can indicate\n  /// that the user intended an assignment used as condition.\n  void DiagnoseEqualityWithExtraParens(ParenExpr *ParenE);\n\n  /// CheckCXXBooleanCondition - Returns true if conversion to bool is invalid.\n  ExprResult CheckCXXBooleanCondition(Expr *CondExpr, bool IsConstexpr = false);\n\n  /// ConvertIntegerToTypeWarnOnOverflow - Convert the specified APInt to have\n  /// the specified width and sign.  If an overflow occurs, detect it and emit\n  /// the specified diagnostic.\n  void ConvertIntegerToTypeWarnOnOverflow(llvm::APSInt &OldVal,\n                                          unsigned NewWidth, bool NewSign,\n                                          SourceLocation Loc, unsigned DiagID);\n\n  /// Checks that the Objective-C declaration is declared in the global scope.\n  /// Emits an error and marks the declaration as invalid if it's not declared\n  /// in the global scope.\n  bool CheckObjCDeclScope(Decl *D);\n\n  /// Abstract base class used for diagnosing integer constant\n  /// expression violations.\n  class VerifyICEDiagnoser {\n  public:\n    bool Suppress;\n\n    VerifyICEDiagnoser(bool Suppress = false) : Suppress(Suppress) { }\n\n    virtual SemaDiagnosticBuilder\n    diagnoseNotICEType(Sema &S, SourceLocation Loc, QualType T);\n    virtual SemaDiagnosticBuilder diagnoseNotICE(Sema &S,\n                                                 SourceLocation Loc) = 0;\n    virtual SemaDiagnosticBuilder diagnoseFold(Sema &S, SourceLocation Loc);\n    virtual ~VerifyICEDiagnoser() {}\n  };\n\n  enum AllowFoldKind {\n    NoFold,\n    AllowFold,\n  };\n\n  /// VerifyIntegerConstantExpression - Verifies that an expression is an ICE,\n  /// and reports the appropriate diagnostics. Returns false on success.\n  /// Can optionally return the value of the expression.\n  ExprResult VerifyIntegerConstantExpression(Expr *E, llvm::APSInt *Result,\n                                             VerifyICEDiagnoser &Diagnoser,\n                                             AllowFoldKind CanFold = NoFold);\n  ExprResult VerifyIntegerConstantExpression(Expr *E, llvm::APSInt *Result,\n                                             unsigned DiagID,\n                                             AllowFoldKind CanFold = NoFold);\n  ExprResult VerifyIntegerConstantExpression(Expr *E,\n                                             llvm::APSInt *Result = nullptr,\n                                             AllowFoldKind CanFold = NoFold);\n  ExprResult VerifyIntegerConstantExpression(Expr *E,\n                                             AllowFoldKind CanFold = NoFold) {\n    return VerifyIntegerConstantExpression(E, nullptr, CanFold);\n  }\n\n  /// VerifyBitField - verifies that a bit field expression is an ICE and has\n  /// the correct width, and that the field type is valid.\n  /// Returns false on success.\n  /// Can optionally return whether the bit-field is of width 0\n  ExprResult VerifyBitField(SourceLocation FieldLoc, IdentifierInfo *FieldName,\n                            QualType FieldTy, bool IsMsStruct,\n                            Expr *BitWidth, bool *ZeroWidth = nullptr);\n\nprivate:\n  unsigned ForceCUDAHostDeviceDepth = 0;\n\npublic:\n  /// Increments our count of the number of times we've seen a pragma forcing\n  /// functions to be __host__ __device__.  So long as this count is greater\n  /// than zero, all functions encountered will be __host__ __device__.\n  void PushForceCUDAHostDevice();\n\n  /// Decrements our count of the number of times we've seen a pragma forcing\n  /// functions to be __host__ __device__.  Returns false if the count is 0\n  /// before incrementing, so you can emit an error.\n  bool PopForceCUDAHostDevice();\n\n  /// Diagnostics that are emitted only if we discover that the given function\n  /// must be codegen'ed.  Because handling these correctly adds overhead to\n  /// compilation, this is currently only enabled for CUDA compilations.\n  llvm::DenseMap<CanonicalDeclPtr<FunctionDecl>,\n                 std::vector<PartialDiagnosticAt>>\n      DeviceDeferredDiags;\n\n  /// A pair of a canonical FunctionDecl and a SourceLocation.  When used as the\n  /// key in a hashtable, both the FD and location are hashed.\n  struct FunctionDeclAndLoc {\n    CanonicalDeclPtr<FunctionDecl> FD;\n    SourceLocation Loc;\n  };\n\n  /// FunctionDecls and SourceLocations for which CheckCUDACall has emitted a\n  /// (maybe deferred) \"bad call\" diagnostic.  We use this to avoid emitting the\n  /// same deferred diag twice.\n  llvm::DenseSet<FunctionDeclAndLoc> LocsWithCUDACallDiags;\n\n  /// An inverse call graph, mapping known-emitted functions to one of their\n  /// known-emitted callers (plus the location of the call).\n  ///\n  /// Functions that we can tell a priori must be emitted aren't added to this\n  /// map.\n  llvm::DenseMap</* Callee = */ CanonicalDeclPtr<FunctionDecl>,\n                 /* Caller = */ FunctionDeclAndLoc>\n      DeviceKnownEmittedFns;\n\n  /// Creates a SemaDiagnosticBuilder that emits the diagnostic if the current\n  /// context is \"used as device code\".\n  ///\n  /// - If CurContext is a __host__ function, does not emit any diagnostics\n  ///   unless \\p EmitOnBothSides is true.\n  /// - If CurContext is a __device__ or __global__ function, emits the\n  ///   diagnostics immediately.\n  /// - If CurContext is a __host__ __device__ function and we are compiling for\n  ///   the device, creates a diagnostic which is emitted if and when we realize\n  ///   that the function will be codegen'ed.\n  ///\n  /// Example usage:\n  ///\n  ///  // Variable-length arrays are not allowed in CUDA device code.\n  ///  if (CUDADiagIfDeviceCode(Loc, diag::err_cuda_vla) << CurrentCUDATarget())\n  ///    return ExprError();\n  ///  // Otherwise, continue parsing as normal.\n  SemaDiagnosticBuilder CUDADiagIfDeviceCode(SourceLocation Loc,\n                                             unsigned DiagID);\n\n  /// Creates a SemaDiagnosticBuilder that emits the diagnostic if the current\n  /// context is \"used as host code\".\n  ///\n  /// Same as CUDADiagIfDeviceCode, with \"host\" and \"device\" switched.\n  SemaDiagnosticBuilder CUDADiagIfHostCode(SourceLocation Loc, unsigned DiagID);\n\n  /// Creates a SemaDiagnosticBuilder that emits the diagnostic if the current\n  /// context is \"used as device code\".\n  ///\n  /// - If CurContext is a `declare target` function or it is known that the\n  /// function is emitted for the device, emits the diagnostics immediately.\n  /// - If CurContext is a non-`declare target` function and we are compiling\n  ///   for the device, creates a diagnostic which is emitted if and when we\n  ///   realize that the function will be codegen'ed.\n  ///\n  /// Example usage:\n  ///\n  ///  // Variable-length arrays are not allowed in NVPTX device code.\n  ///  if (diagIfOpenMPDeviceCode(Loc, diag::err_vla_unsupported))\n  ///    return ExprError();\n  ///  // Otherwise, continue parsing as normal.\n  SemaDiagnosticBuilder\n  diagIfOpenMPDeviceCode(SourceLocation Loc, unsigned DiagID, FunctionDecl *FD);\n\n  /// Creates a SemaDiagnosticBuilder that emits the diagnostic if the current\n  /// context is \"used as host code\".\n  ///\n  /// - If CurContext is a `declare target` function or it is known that the\n  /// function is emitted for the host, emits the diagnostics immediately.\n  /// - If CurContext is a non-host function, just ignore it.\n  ///\n  /// Example usage:\n  ///\n  ///  // Variable-length arrays are not allowed in NVPTX device code.\n  ///  if (diagIfOpenMPHostode(Loc, diag::err_vla_unsupported))\n  ///    return ExprError();\n  ///  // Otherwise, continue parsing as normal.\n  SemaDiagnosticBuilder diagIfOpenMPHostCode(SourceLocation Loc,\n                                             unsigned DiagID, FunctionDecl *FD);\n\n  SemaDiagnosticBuilder targetDiag(SourceLocation Loc, unsigned DiagID,\n                                   FunctionDecl *FD = nullptr);\n  SemaDiagnosticBuilder targetDiag(SourceLocation Loc,\n                                   const PartialDiagnostic &PD,\n                                   FunctionDecl *FD = nullptr) {\n    return targetDiag(Loc, PD.getDiagID(), FD) << PD;\n  }\n\n  /// Check if the expression is allowed to be used in expressions for the\n  /// offloading devices.\n  void checkDeviceDecl(ValueDecl *D, SourceLocation Loc);\n\n  enum CUDAFunctionTarget {\n    CFT_Device,\n    CFT_Global,\n    CFT_Host,\n    CFT_HostDevice,\n    CFT_InvalidTarget\n  };\n\n  /// Determines whether the given function is a CUDA device/host/kernel/etc.\n  /// function.\n  ///\n  /// Use this rather than examining the function's attributes yourself -- you\n  /// will get it wrong.  Returns CFT_Host if D is null.\n  CUDAFunctionTarget IdentifyCUDATarget(const FunctionDecl *D,\n                                        bool IgnoreImplicitHDAttr = false);\n  CUDAFunctionTarget IdentifyCUDATarget(const ParsedAttributesView &Attrs);\n\n  /// Gets the CUDA target for the current context.\n  CUDAFunctionTarget CurrentCUDATarget() {\n    return IdentifyCUDATarget(dyn_cast<FunctionDecl>(CurContext));\n  }\n\n  static bool isCUDAImplicitHostDeviceFunction(const FunctionDecl *D);\n\n  // CUDA function call preference. Must be ordered numerically from\n  // worst to best.\n  enum CUDAFunctionPreference {\n    CFP_Never,      // Invalid caller/callee combination.\n    CFP_WrongSide,  // Calls from host-device to host or device\n                    // function that do not match current compilation\n                    // mode.\n    CFP_HostDevice, // Any calls to host/device functions.\n    CFP_SameSide,   // Calls from host-device to host or device\n                    // function matching current compilation mode.\n    CFP_Native,     // host-to-host or device-to-device calls.\n  };\n\n  /// Identifies relative preference of a given Caller/Callee\n  /// combination, based on their host/device attributes.\n  /// \\param Caller function which needs address of \\p Callee.\n  ///               nullptr in case of global context.\n  /// \\param Callee target function\n  ///\n  /// \\returns preference value for particular Caller/Callee combination.\n  CUDAFunctionPreference IdentifyCUDAPreference(const FunctionDecl *Caller,\n                                                const FunctionDecl *Callee);\n\n  /// Determines whether Caller may invoke Callee, based on their CUDA\n  /// host/device attributes.  Returns false if the call is not allowed.\n  ///\n  /// Note: Will return true for CFP_WrongSide calls.  These may appear in\n  /// semantically correct CUDA programs, but only if they're never codegen'ed.\n  bool IsAllowedCUDACall(const FunctionDecl *Caller,\n                         const FunctionDecl *Callee) {\n    return IdentifyCUDAPreference(Caller, Callee) != CFP_Never;\n  }\n\n  /// May add implicit CUDAHostAttr and CUDADeviceAttr attributes to FD,\n  /// depending on FD and the current compilation settings.\n  void maybeAddCUDAHostDeviceAttrs(FunctionDecl *FD,\n                                   const LookupResult &Previous);\n\n  /// May add implicit CUDAConstantAttr attribute to VD, depending on VD\n  /// and current compilation settings.\n  void MaybeAddCUDAConstantAttr(VarDecl *VD);\n\npublic:\n  /// Check whether we're allowed to call Callee from the current context.\n  ///\n  /// - If the call is never allowed in a semantically-correct program\n  ///   (CFP_Never), emits an error and returns false.\n  ///\n  /// - If the call is allowed in semantically-correct programs, but only if\n  ///   it's never codegen'ed (CFP_WrongSide), creates a deferred diagnostic to\n  ///   be emitted if and when the caller is codegen'ed, and returns true.\n  ///\n  ///   Will only create deferred diagnostics for a given SourceLocation once,\n  ///   so you can safely call this multiple times without generating duplicate\n  ///   deferred errors.\n  ///\n  /// - Otherwise, returns true without emitting any diagnostics.\n  bool CheckCUDACall(SourceLocation Loc, FunctionDecl *Callee);\n\n  void CUDACheckLambdaCapture(CXXMethodDecl *D, const sema::Capture &Capture);\n\n  /// Set __device__ or __host__ __device__ attributes on the given lambda\n  /// operator() method.\n  ///\n  /// CUDA lambdas by default is host device function unless it has explicit\n  /// host or device attribute.\n  void CUDASetLambdaAttrs(CXXMethodDecl *Method);\n\n  /// Finds a function in \\p Matches with highest calling priority\n  /// from \\p Caller context and erases all functions with lower\n  /// calling priority.\n  void EraseUnwantedCUDAMatches(\n      const FunctionDecl *Caller,\n      SmallVectorImpl<std::pair<DeclAccessPair, FunctionDecl *>> &Matches);\n\n  /// Given a implicit special member, infer its CUDA target from the\n  /// calls it needs to make to underlying base/field special members.\n  /// \\param ClassDecl the class for which the member is being created.\n  /// \\param CSM the kind of special member.\n  /// \\param MemberDecl the special member itself.\n  /// \\param ConstRHS true if this is a copy operation with a const object on\n  ///        its RHS.\n  /// \\param Diagnose true if this call should emit diagnostics.\n  /// \\return true if there was an error inferring.\n  /// The result of this call is implicit CUDA target attribute(s) attached to\n  /// the member declaration.\n  bool inferCUDATargetForImplicitSpecialMember(CXXRecordDecl *ClassDecl,\n                                               CXXSpecialMember CSM,\n                                               CXXMethodDecl *MemberDecl,\n                                               bool ConstRHS,\n                                               bool Diagnose);\n\n  /// \\return true if \\p CD can be considered empty according to CUDA\n  /// (E.2.3.1 in CUDA 7.5 Programming guide).\n  bool isEmptyCudaConstructor(SourceLocation Loc, CXXConstructorDecl *CD);\n  bool isEmptyCudaDestructor(SourceLocation Loc, CXXDestructorDecl *CD);\n\n  // \\brief Checks that initializers of \\p Var satisfy CUDA restrictions. In\n  // case of error emits appropriate diagnostic and invalidates \\p Var.\n  //\n  // \\details CUDA allows only empty constructors as initializers for global\n  // variables (see E.2.3.1, CUDA 7.5). The same restriction also applies to all\n  // __shared__ variables whether they are local or not (they all are implicitly\n  // static in CUDA). One exception is that CUDA allows constant initializers\n  // for __constant__ and __device__ variables.\n  void checkAllowedCUDAInitializer(VarDecl *VD);\n\n  /// Check whether NewFD is a valid overload for CUDA. Emits\n  /// diagnostics and invalidates NewFD if not.\n  void checkCUDATargetOverload(FunctionDecl *NewFD,\n                               const LookupResult &Previous);\n  /// Copies target attributes from the template TD to the function FD.\n  void inheritCUDATargetAttrs(FunctionDecl *FD, const FunctionTemplateDecl &TD);\n\n  /// Returns the name of the launch configuration function.  This is the name\n  /// of the function that will be called to configure kernel call, with the\n  /// parameters specified via <<<>>>.\n  std::string getCudaConfigureFuncName() const;\n\n  /// \\name Code completion\n  //@{\n  /// Describes the context in which code completion occurs.\n  enum ParserCompletionContext {\n    /// Code completion occurs at top-level or namespace context.\n    PCC_Namespace,\n    /// Code completion occurs within a class, struct, or union.\n    PCC_Class,\n    /// Code completion occurs within an Objective-C interface, protocol,\n    /// or category.\n    PCC_ObjCInterface,\n    /// Code completion occurs within an Objective-C implementation or\n    /// category implementation\n    PCC_ObjCImplementation,\n    /// Code completion occurs within the list of instance variables\n    /// in an Objective-C interface, protocol, category, or implementation.\n    PCC_ObjCInstanceVariableList,\n    /// Code completion occurs following one or more template\n    /// headers.\n    PCC_Template,\n    /// Code completion occurs following one or more template\n    /// headers within a class.\n    PCC_MemberTemplate,\n    /// Code completion occurs within an expression.\n    PCC_Expression,\n    /// Code completion occurs within a statement, which may\n    /// also be an expression or a declaration.\n    PCC_Statement,\n    /// Code completion occurs at the beginning of the\n    /// initialization statement (or expression) in a for loop.\n    PCC_ForInit,\n    /// Code completion occurs within the condition of an if,\n    /// while, switch, or for statement.\n    PCC_Condition,\n    /// Code completion occurs within the body of a function on a\n    /// recovery path, where we do not have a specific handle on our position\n    /// in the grammar.\n    PCC_RecoveryInFunction,\n    /// Code completion occurs where only a type is permitted.\n    PCC_Type,\n    /// Code completion occurs in a parenthesized expression, which\n    /// might also be a type cast.\n    PCC_ParenthesizedExpression,\n    /// Code completion occurs within a sequence of declaration\n    /// specifiers within a function, method, or block.\n    PCC_LocalDeclarationSpecifiers\n  };\n\n  void CodeCompleteModuleImport(SourceLocation ImportLoc, ModuleIdPath Path);\n  void CodeCompleteOrdinaryName(Scope *S,\n                                ParserCompletionContext CompletionContext);\n  void CodeCompleteDeclSpec(Scope *S, DeclSpec &DS,\n                            bool AllowNonIdentifiers,\n                            bool AllowNestedNameSpecifiers);\n\n  struct CodeCompleteExpressionData;\n  void CodeCompleteExpression(Scope *S,\n                              const CodeCompleteExpressionData &Data);\n  void CodeCompleteExpression(Scope *S, QualType PreferredType,\n                              bool IsParenthesized = false);\n  void CodeCompleteMemberReferenceExpr(Scope *S, Expr *Base, Expr *OtherOpBase,\n                                       SourceLocation OpLoc, bool IsArrow,\n                                       bool IsBaseExprStatement,\n                                       QualType PreferredType);\n  void CodeCompletePostfixExpression(Scope *S, ExprResult LHS,\n                                     QualType PreferredType);\n  void CodeCompleteTag(Scope *S, unsigned TagSpec);\n  void CodeCompleteTypeQualifiers(DeclSpec &DS);\n  void CodeCompleteFunctionQualifiers(DeclSpec &DS, Declarator &D,\n                                      const VirtSpecifiers *VS = nullptr);\n  void CodeCompleteBracketDeclarator(Scope *S);\n  void CodeCompleteCase(Scope *S);\n  /// Reports signatures for a call to CodeCompleteConsumer and returns the\n  /// preferred type for the current argument. Returned type can be null.\n  QualType ProduceCallSignatureHelp(Scope *S, Expr *Fn, ArrayRef<Expr *> Args,\n                                    SourceLocation OpenParLoc);\n  QualType ProduceConstructorSignatureHelp(Scope *S, QualType Type,\n                                           SourceLocation Loc,\n                                           ArrayRef<Expr *> Args,\n                                           SourceLocation OpenParLoc);\n  QualType ProduceCtorInitMemberSignatureHelp(Scope *S, Decl *ConstructorDecl,\n                                              CXXScopeSpec SS,\n                                              ParsedType TemplateTypeTy,\n                                              ArrayRef<Expr *> ArgExprs,\n                                              IdentifierInfo *II,\n                                              SourceLocation OpenParLoc);\n  void CodeCompleteInitializer(Scope *S, Decl *D);\n  /// Trigger code completion for a record of \\p BaseType. \\p InitExprs are\n  /// expressions in the initializer list seen so far and \\p D is the current\n  /// Designation being parsed.\n  void CodeCompleteDesignator(const QualType BaseType,\n                              llvm::ArrayRef<Expr *> InitExprs,\n                              const Designation &D);\n  void CodeCompleteAfterIf(Scope *S, bool IsBracedThen);\n\n  void CodeCompleteQualifiedId(Scope *S, CXXScopeSpec &SS, bool EnteringContext,\n                               bool IsUsingDeclaration, QualType BaseType,\n                               QualType PreferredType);\n  void CodeCompleteUsing(Scope *S);\n  void CodeCompleteUsingDirective(Scope *S);\n  void CodeCompleteNamespaceDecl(Scope *S);\n  void CodeCompleteNamespaceAliasDecl(Scope *S);\n  void CodeCompleteOperatorName(Scope *S);\n  void CodeCompleteConstructorInitializer(\n                                Decl *Constructor,\n                                ArrayRef<CXXCtorInitializer *> Initializers);\n\n  void CodeCompleteLambdaIntroducer(Scope *S, LambdaIntroducer &Intro,\n                                    bool AfterAmpersand);\n  void CodeCompleteAfterFunctionEquals(Declarator &D);\n\n  void CodeCompleteObjCAtDirective(Scope *S);\n  void CodeCompleteObjCAtVisibility(Scope *S);\n  void CodeCompleteObjCAtStatement(Scope *S);\n  void CodeCompleteObjCAtExpression(Scope *S);\n  void CodeCompleteObjCPropertyFlags(Scope *S, ObjCDeclSpec &ODS);\n  void CodeCompleteObjCPropertyGetter(Scope *S);\n  void CodeCompleteObjCPropertySetter(Scope *S);\n  void CodeCompleteObjCPassingType(Scope *S, ObjCDeclSpec &DS,\n                                   bool IsParameter);\n  void CodeCompleteObjCMessageReceiver(Scope *S);\n  void CodeCompleteObjCSuperMessage(Scope *S, SourceLocation SuperLoc,\n                                    ArrayRef<IdentifierInfo *> SelIdents,\n                                    bool AtArgumentExpression);\n  void CodeCompleteObjCClassMessage(Scope *S, ParsedType Receiver,\n                                    ArrayRef<IdentifierInfo *> SelIdents,\n                                    bool AtArgumentExpression,\n                                    bool IsSuper = false);\n  void CodeCompleteObjCInstanceMessage(Scope *S, Expr *Receiver,\n                                       ArrayRef<IdentifierInfo *> SelIdents,\n                                       bool AtArgumentExpression,\n                                       ObjCInterfaceDecl *Super = nullptr);\n  void CodeCompleteObjCForCollection(Scope *S,\n                                     DeclGroupPtrTy IterationVar);\n  void CodeCompleteObjCSelector(Scope *S,\n                                ArrayRef<IdentifierInfo *> SelIdents);\n  void CodeCompleteObjCProtocolReferences(\n                                         ArrayRef<IdentifierLocPair> Protocols);\n  void CodeCompleteObjCProtocolDecl(Scope *S);\n  void CodeCompleteObjCInterfaceDecl(Scope *S);\n  void CodeCompleteObjCSuperclass(Scope *S,\n                                  IdentifierInfo *ClassName,\n                                  SourceLocation ClassNameLoc);\n  void CodeCompleteObjCImplementationDecl(Scope *S);\n  void CodeCompleteObjCInterfaceCategory(Scope *S,\n                                         IdentifierInfo *ClassName,\n                                         SourceLocation ClassNameLoc);\n  void CodeCompleteObjCImplementationCategory(Scope *S,\n                                              IdentifierInfo *ClassName,\n                                              SourceLocation ClassNameLoc);\n  void CodeCompleteObjCPropertyDefinition(Scope *S);\n  void CodeCompleteObjCPropertySynthesizeIvar(Scope *S,\n                                              IdentifierInfo *PropertyName);\n  void CodeCompleteObjCMethodDecl(Scope *S, Optional<bool> IsInstanceMethod,\n                                  ParsedType ReturnType);\n  void CodeCompleteObjCMethodDeclSelector(Scope *S,\n                                          bool IsInstanceMethod,\n                                          bool AtParameterName,\n                                          ParsedType ReturnType,\n                                          ArrayRef<IdentifierInfo *> SelIdents);\n  void CodeCompleteObjCClassPropertyRefExpr(Scope *S, IdentifierInfo &ClassName,\n                                            SourceLocation ClassNameLoc,\n                                            bool IsBaseExprStatement);\n  void CodeCompletePreprocessorDirective(bool InConditional);\n  void CodeCompleteInPreprocessorConditionalExclusion(Scope *S);\n  void CodeCompletePreprocessorMacroName(bool IsDefinition);\n  void CodeCompletePreprocessorExpression();\n  void CodeCompletePreprocessorMacroArgument(Scope *S,\n                                             IdentifierInfo *Macro,\n                                             MacroInfo *MacroInfo,\n                                             unsigned Argument);\n  void CodeCompleteIncludedFile(llvm::StringRef Dir, bool IsAngled);\n  void CodeCompleteNaturalLanguage();\n  void CodeCompleteAvailabilityPlatformName();\n  void GatherGlobalCodeCompletions(CodeCompletionAllocator &Allocator,\n                                   CodeCompletionTUInfo &CCTUInfo,\n                  SmallVectorImpl<CodeCompletionResult> &Results);\n  //@}\n\n  //===--------------------------------------------------------------------===//\n  // Extra semantic analysis beyond the C type system\n\npublic:\n  SourceLocation getLocationOfStringLiteralByte(const StringLiteral *SL,\n                                                unsigned ByteNo) const;\n\nprivate:\n  void CheckArrayAccess(const Expr *BaseExpr, const Expr *IndexExpr,\n                        const ArraySubscriptExpr *ASE=nullptr,\n                        bool AllowOnePastEnd=true, bool IndexNegated=false);\n  void CheckArrayAccess(const Expr *E);\n  // Used to grab the relevant information from a FormatAttr and a\n  // FunctionDeclaration.\n  struct FormatStringInfo {\n    unsigned FormatIdx;\n    unsigned FirstDataArg;\n    bool HasVAListArg;\n  };\n\n  static bool getFormatStringInfo(const FormatAttr *Format, bool IsCXXMember,\n                                  FormatStringInfo *FSI);\n  bool CheckFunctionCall(FunctionDecl *FDecl, CallExpr *TheCall,\n                         const FunctionProtoType *Proto);\n  bool CheckObjCMethodCall(ObjCMethodDecl *Method, SourceLocation loc,\n                           ArrayRef<const Expr *> Args);\n  bool CheckPointerCall(NamedDecl *NDecl, CallExpr *TheCall,\n                        const FunctionProtoType *Proto);\n  bool CheckOtherCall(CallExpr *TheCall, const FunctionProtoType *Proto);\n  void CheckConstructorCall(FunctionDecl *FDecl, QualType ThisType,\n                            ArrayRef<const Expr *> Args,\n                            const FunctionProtoType *Proto, SourceLocation Loc);\n\n  void CheckArgAlignment(SourceLocation Loc, NamedDecl *FDecl,\n                         StringRef ParamName, QualType ArgTy, QualType ParamTy);\n\n  void checkCall(NamedDecl *FDecl, const FunctionProtoType *Proto,\n                 const Expr *ThisArg, ArrayRef<const Expr *> Args,\n                 bool IsMemberFunction, SourceLocation Loc, SourceRange Range,\n                 VariadicCallType CallType);\n\n  bool CheckObjCString(Expr *Arg);\n  ExprResult CheckOSLogFormatStringArg(Expr *Arg);\n\n  ExprResult CheckBuiltinFunctionCall(FunctionDecl *FDecl,\n                                      unsigned BuiltinID, CallExpr *TheCall);\n\n  bool CheckTSBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                  CallExpr *TheCall);\n\n  void checkFortifiedBuiltinMemoryFunction(FunctionDecl *FD, CallExpr *TheCall);\n\n  bool CheckARMBuiltinExclusiveCall(unsigned BuiltinID, CallExpr *TheCall,\n                                    unsigned MaxWidth);\n  bool CheckNeonBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                    CallExpr *TheCall);\n  bool CheckMVEBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckSVEBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckCDEBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                   CallExpr *TheCall);\n  bool CheckARMCoprocessorImmediate(const TargetInfo &TI, const Expr *CoprocArg,\n                                    bool WantCDE);\n  bool CheckARMBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                   CallExpr *TheCall);\n\n  bool CheckAArch64BuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                       CallExpr *TheCall);\n  bool CheckBPFBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckHexagonBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckHexagonBuiltinArgument(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckMipsBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                    CallExpr *TheCall);\n  bool CheckMipsBuiltinCpu(const TargetInfo &TI, unsigned BuiltinID,\n                           CallExpr *TheCall);\n  bool CheckMipsBuiltinArgument(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckSystemZBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckX86BuiltinRoundingOrSAE(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckX86BuiltinGatherScatterScale(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckX86BuiltinTileArguments(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckX86BuiltinTileArgumentsRange(CallExpr *TheCall,\n                                         ArrayRef<int> ArgNums);\n  bool CheckX86BuiltinTileDuplicate(CallExpr *TheCall, ArrayRef<int> ArgNums);\n  bool CheckX86BuiltinTileRangeAndDuplicate(CallExpr *TheCall,\n                                            ArrayRef<int> ArgNums);\n  bool CheckX86BuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                   CallExpr *TheCall);\n  bool CheckPPCBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                   CallExpr *TheCall);\n  bool CheckAMDGCNBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckRISCVBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                     CallExpr *TheCall);\n\n  bool SemaBuiltinVAStart(unsigned BuiltinID, CallExpr *TheCall);\n  bool SemaBuiltinVAStartARMMicrosoft(CallExpr *Call);\n  bool SemaBuiltinUnorderedCompare(CallExpr *TheCall);\n  bool SemaBuiltinFPClassification(CallExpr *TheCall, unsigned NumArgs);\n  bool SemaBuiltinComplex(CallExpr *TheCall);\n  bool SemaBuiltinVSX(CallExpr *TheCall);\n  bool SemaBuiltinOSLogFormat(CallExpr *TheCall);\n\npublic:\n  // Used by C++ template instantiation.\n  ExprResult SemaBuiltinShuffleVector(CallExpr *TheCall);\n  ExprResult SemaConvertVectorExpr(Expr *E, TypeSourceInfo *TInfo,\n                                   SourceLocation BuiltinLoc,\n                                   SourceLocation RParenLoc);\n\nprivate:\n  bool SemaBuiltinPrefetch(CallExpr *TheCall);\n  bool SemaBuiltinAllocaWithAlign(CallExpr *TheCall);\n  bool SemaBuiltinAssume(CallExpr *TheCall);\n  bool SemaBuiltinAssumeAligned(CallExpr *TheCall);\n  bool SemaBuiltinLongjmp(CallExpr *TheCall);\n  bool SemaBuiltinSetjmp(CallExpr *TheCall);\n  ExprResult SemaBuiltinAtomicOverloaded(ExprResult TheCallResult);\n  ExprResult SemaBuiltinNontemporalOverloaded(ExprResult TheCallResult);\n  ExprResult SemaAtomicOpsOverloaded(ExprResult TheCallResult,\n                                     AtomicExpr::AtomicOp Op);\n  ExprResult SemaBuiltinOperatorNewDeleteOverloaded(ExprResult TheCallResult,\n                                                    bool IsDelete);\n  bool SemaBuiltinConstantArg(CallExpr *TheCall, int ArgNum,\n                              llvm::APSInt &Result);\n  bool SemaBuiltinConstantArgRange(CallExpr *TheCall, int ArgNum, int Low,\n                                   int High, bool RangeIsError = true);\n  bool SemaBuiltinConstantArgMultiple(CallExpr *TheCall, int ArgNum,\n                                      unsigned Multiple);\n  bool SemaBuiltinConstantArgPower2(CallExpr *TheCall, int ArgNum);\n  bool SemaBuiltinConstantArgShiftedByte(CallExpr *TheCall, int ArgNum,\n                                         unsigned ArgBits);\n  bool SemaBuiltinConstantArgShiftedByteOrXXFF(CallExpr *TheCall, int ArgNum,\n                                               unsigned ArgBits);\n  bool SemaBuiltinARMSpecialReg(unsigned BuiltinID, CallExpr *TheCall,\n                                int ArgNum, unsigned ExpectedFieldNum,\n                                bool AllowName);\n  bool SemaBuiltinARMMemoryTaggingCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool SemaBuiltinPPCMMACall(CallExpr *TheCall, const char *TypeDesc);\n\n  bool CheckPPCMMAType(QualType Type, SourceLocation TypeLoc);\n\n  // Matrix builtin handling.\n  ExprResult SemaBuiltinMatrixTranspose(CallExpr *TheCall,\n                                        ExprResult CallResult);\n  ExprResult SemaBuiltinMatrixColumnMajorLoad(CallExpr *TheCall,\n                                              ExprResult CallResult);\n  ExprResult SemaBuiltinMatrixColumnMajorStore(CallExpr *TheCall,\n                                               ExprResult CallResult);\n\npublic:\n  enum FormatStringType {\n    FST_Scanf,\n    FST_Printf,\n    FST_NSString,\n    FST_Strftime,\n    FST_Strfmon,\n    FST_Kprintf,\n    FST_FreeBSDKPrintf,\n    FST_OSTrace,\n    FST_OSLog,\n    FST_Unknown\n  };\n  static FormatStringType GetFormatStringType(const FormatAttr *Format);\n\n  bool FormatStringHasSArg(const StringLiteral *FExpr);\n\n  static bool GetFormatNSStringIdx(const FormatAttr *Format, unsigned &Idx);\n\nprivate:\n  bool CheckFormatArguments(const FormatAttr *Format,\n                            ArrayRef<const Expr *> Args,\n                            bool IsCXXMember,\n                            VariadicCallType CallType,\n                            SourceLocation Loc, SourceRange Range,\n                            llvm::SmallBitVector &CheckedVarArgs);\n  bool CheckFormatArguments(ArrayRef<const Expr *> Args,\n                            bool HasVAListArg, unsigned format_idx,\n                            unsigned firstDataArg, FormatStringType Type,\n                            VariadicCallType CallType,\n                            SourceLocation Loc, SourceRange range,\n                            llvm::SmallBitVector &CheckedVarArgs);\n\n  void CheckAbsoluteValueFunction(const CallExpr *Call,\n                                  const FunctionDecl *FDecl);\n\n  void CheckMaxUnsignedZero(const CallExpr *Call, const FunctionDecl *FDecl);\n\n  void CheckMemaccessArguments(const CallExpr *Call,\n                               unsigned BId,\n                               IdentifierInfo *FnName);\n\n  void CheckStrlcpycatArguments(const CallExpr *Call,\n                                IdentifierInfo *FnName);\n\n  void CheckStrncatArguments(const CallExpr *Call,\n                             IdentifierInfo *FnName);\n\n  void CheckFreeArguments(const CallExpr *E);\n\n  void CheckReturnValExpr(Expr *RetValExp, QualType lhsType,\n                          SourceLocation ReturnLoc,\n                          bool isObjCMethod = false,\n                          const AttrVec *Attrs = nullptr,\n                          const FunctionDecl *FD = nullptr);\n\npublic:\n  void CheckFloatComparison(SourceLocation Loc, Expr *LHS, Expr *RHS);\n\nprivate:\n  void CheckImplicitConversions(Expr *E, SourceLocation CC = SourceLocation());\n  void CheckBoolLikeConversion(Expr *E, SourceLocation CC);\n  void CheckForIntOverflow(Expr *E);\n  void CheckUnsequencedOperations(const Expr *E);\n\n  /// Perform semantic checks on a completed expression. This will either\n  /// be a full-expression or a default argument expression.\n  void CheckCompletedExpr(Expr *E, SourceLocation CheckLoc = SourceLocation(),\n                          bool IsConstexpr = false);\n\n  void CheckBitFieldInitialization(SourceLocation InitLoc, FieldDecl *Field,\n                                   Expr *Init);\n\n  /// Check if there is a field shadowing.\n  void CheckShadowInheritedFields(const SourceLocation &Loc,\n                                  DeclarationName FieldName,\n                                  const CXXRecordDecl *RD,\n                                  bool DeclIsField = true);\n\n  /// Check if the given expression contains 'break' or 'continue'\n  /// statement that produces control flow different from GCC.\n  void CheckBreakContinueBinding(Expr *E);\n\n  /// Check whether receiver is mutable ObjC container which\n  /// attempts to add itself into the container\n  void CheckObjCCircularContainer(ObjCMessageExpr *Message);\n\n  void CheckTCBEnforcement(const CallExpr *TheCall, const FunctionDecl *Callee);\n\n  void AnalyzeDeleteExprMismatch(const CXXDeleteExpr *DE);\n  void AnalyzeDeleteExprMismatch(FieldDecl *Field, SourceLocation DeleteLoc,\n                                 bool DeleteWasArrayForm);\npublic:\n  /// Register a magic integral constant to be used as a type tag.\n  void RegisterTypeTagForDatatype(const IdentifierInfo *ArgumentKind,\n                                  uint64_t MagicValue, QualType Type,\n                                  bool LayoutCompatible, bool MustBeNull);\n\n  struct TypeTagData {\n    TypeTagData() {}\n\n    TypeTagData(QualType Type, bool LayoutCompatible, bool MustBeNull) :\n        Type(Type), LayoutCompatible(LayoutCompatible),\n        MustBeNull(MustBeNull)\n    {}\n\n    QualType Type;\n\n    /// If true, \\c Type should be compared with other expression's types for\n    /// layout-compatibility.\n    unsigned LayoutCompatible : 1;\n    unsigned MustBeNull : 1;\n  };\n\n  /// A pair of ArgumentKind identifier and magic value.  This uniquely\n  /// identifies the magic value.\n  typedef std::pair<const IdentifierInfo *, uint64_t> TypeTagMagicValue;\n\nprivate:\n  /// A map from magic value to type information.\n  std::unique_ptr<llvm::DenseMap<TypeTagMagicValue, TypeTagData>>\n      TypeTagForDatatypeMagicValues;\n\n  /// Peform checks on a call of a function with argument_with_type_tag\n  /// or pointer_with_type_tag attributes.\n  void CheckArgumentWithTypeTag(const ArgumentWithTypeTagAttr *Attr,\n                                const ArrayRef<const Expr *> ExprArgs,\n                                SourceLocation CallSiteLoc);\n\n  /// Check if we are taking the address of a packed field\n  /// as this may be a problem if the pointer value is dereferenced.\n  void CheckAddressOfPackedMember(Expr *rhs);\n\n  /// The parser's current scope.\n  ///\n  /// The parser maintains this state here.\n  Scope *CurScope;\n\n  mutable IdentifierInfo *Ident_super;\n  mutable IdentifierInfo *Ident___float128;\n\n  /// Nullability type specifiers.\n  IdentifierInfo *Ident__Nonnull = nullptr;\n  IdentifierInfo *Ident__Nullable = nullptr;\n  IdentifierInfo *Ident__Nullable_result = nullptr;\n  IdentifierInfo *Ident__Null_unspecified = nullptr;\n\n  IdentifierInfo *Ident_NSError = nullptr;\n\n  /// The handler for the FileChanged preprocessor events.\n  ///\n  /// Used for diagnostics that implement custom semantic analysis for #include\n  /// directives, like -Wpragma-pack.\n  sema::SemaPPCallbacks *SemaPPCallbackHandler;\n\nprotected:\n  friend class Parser;\n  friend class InitializationSequence;\n  friend class ASTReader;\n  friend class ASTDeclReader;\n  friend class ASTWriter;\n\npublic:\n  /// Retrieve the keyword associated\n  IdentifierInfo *getNullabilityKeyword(NullabilityKind nullability);\n\n  /// The struct behind the CFErrorRef pointer.\n  RecordDecl *CFError = nullptr;\n  bool isCFError(RecordDecl *D);\n\n  /// Retrieve the identifier \"NSError\".\n  IdentifierInfo *getNSErrorIdent();\n\n  /// Retrieve the parser's current scope.\n  ///\n  /// This routine must only be used when it is certain that semantic analysis\n  /// and the parser are in precisely the same context, which is not the case\n  /// when, e.g., we are performing any kind of template instantiation.\n  /// Therefore, the only safe places to use this scope are in the parser\n  /// itself and in routines directly invoked from the parser and *never* from\n  /// template substitution or instantiation.\n  Scope *getCurScope() const { return CurScope; }\n\n  void incrementMSManglingNumber() const {\n    return CurScope->incrementMSManglingNumber();\n  }\n\n  IdentifierInfo *getSuperIdentifier() const;\n  IdentifierInfo *getFloat128Identifier() const;\n\n  Decl *getObjCDeclContext() const;\n\n  DeclContext *getCurLexicalContext() const {\n    return OriginalLexicalContext ? OriginalLexicalContext : CurContext;\n  }\n\n  const DeclContext *getCurObjCLexicalContext() const {\n    const DeclContext *DC = getCurLexicalContext();\n    // A category implicitly has the attribute of the interface.\n    if (const ObjCCategoryDecl *CatD = dyn_cast<ObjCCategoryDecl>(DC))\n      DC = CatD->getClassInterface();\n    return DC;\n  }\n\n  /// Determine the number of levels of enclosing template parameters. This is\n  /// only usable while parsing. Note that this does not include dependent\n  /// contexts in which no template parameters have yet been declared, such as\n  /// in a terse function template or generic lambda before the first 'auto' is\n  /// encountered.\n  unsigned getTemplateDepth(Scope *S) const;\n\n  /// To be used for checking whether the arguments being passed to\n  /// function exceeds the number of parameters expected for it.\n  static bool TooManyArguments(size_t NumParams, size_t NumArgs,\n                               bool PartialOverloading = false) {\n    // We check whether we're just after a comma in code-completion.\n    if (NumArgs > 0 && PartialOverloading)\n      return NumArgs + 1 > NumParams; // If so, we view as an extra argument.\n    return NumArgs > NumParams;\n  }\n\n  // Emitting members of dllexported classes is delayed until the class\n  // (including field initializers) is fully parsed.\n  SmallVector<CXXRecordDecl*, 4> DelayedDllExportClasses;\n  SmallVector<CXXMethodDecl*, 4> DelayedDllExportMemberFunctions;\n\nprivate:\n  int ParsingClassDepth = 0;\n\n  class SavePendingParsedClassStateRAII {\n  public:\n    SavePendingParsedClassStateRAII(Sema &S) : S(S) { swapSavedState(); }\n\n    ~SavePendingParsedClassStateRAII() {\n      assert(S.DelayedOverridingExceptionSpecChecks.empty() &&\n             \"there shouldn't be any pending delayed exception spec checks\");\n      assert(S.DelayedEquivalentExceptionSpecChecks.empty() &&\n             \"there shouldn't be any pending delayed exception spec checks\");\n      swapSavedState();\n    }\n\n  private:\n    Sema &S;\n    decltype(DelayedOverridingExceptionSpecChecks)\n        SavedOverridingExceptionSpecChecks;\n    decltype(DelayedEquivalentExceptionSpecChecks)\n        SavedEquivalentExceptionSpecChecks;\n\n    void swapSavedState() {\n      SavedOverridingExceptionSpecChecks.swap(\n          S.DelayedOverridingExceptionSpecChecks);\n      SavedEquivalentExceptionSpecChecks.swap(\n          S.DelayedEquivalentExceptionSpecChecks);\n    }\n  };\n\n  /// Helper class that collects misaligned member designations and\n  /// their location info for delayed diagnostics.\n  struct MisalignedMember {\n    Expr *E;\n    RecordDecl *RD;\n    ValueDecl *MD;\n    CharUnits Alignment;\n\n    MisalignedMember() : E(), RD(), MD(), Alignment() {}\n    MisalignedMember(Expr *E, RecordDecl *RD, ValueDecl *MD,\n                     CharUnits Alignment)\n        : E(E), RD(RD), MD(MD), Alignment(Alignment) {}\n    explicit MisalignedMember(Expr *E)\n        : MisalignedMember(E, nullptr, nullptr, CharUnits()) {}\n\n    bool operator==(const MisalignedMember &m) { return this->E == m.E; }\n  };\n  /// Small set of gathered accesses to potentially misaligned members\n  /// due to the packed attribute.\n  SmallVector<MisalignedMember, 4> MisalignedMembers;\n\n  /// Adds an expression to the set of gathered misaligned members.\n  void AddPotentialMisalignedMembers(Expr *E, RecordDecl *RD, ValueDecl *MD,\n                                     CharUnits Alignment);\n\npublic:\n  /// Diagnoses the current set of gathered accesses. This typically\n  /// happens at full expression level. The set is cleared after emitting the\n  /// diagnostics.\n  void DiagnoseMisalignedMembers();\n\n  /// This function checks if the expression is in the sef of potentially\n  /// misaligned members and it is converted to some pointer type T with lower\n  /// or equal alignment requirements. If so it removes it. This is used when\n  /// we do not want to diagnose such misaligned access (e.g. in conversions to\n  /// void*).\n  void DiscardMisalignedMemberAddress(const Type *T, Expr *E);\n\n  /// This function calls Action when it determines that E designates a\n  /// misaligned member due to the packed attribute. This is used to emit\n  /// local diagnostics like in reference binding.\n  void RefersToMemberWithReducedAlignment(\n      Expr *E,\n      llvm::function_ref<void(Expr *, RecordDecl *, FieldDecl *, CharUnits)>\n          Action);\n\n  /// Describes the reason a calling convention specification was ignored, used\n  /// for diagnostics.\n  enum class CallingConventionIgnoredReason {\n    ForThisTarget = 0,\n    VariadicFunction,\n    ConstructorDestructor,\n    BuiltinFunction\n  };\n  /// Creates a SemaDiagnosticBuilder that emits the diagnostic if the current\n  /// context is \"used as device code\".\n  ///\n  /// - If CurLexicalContext is a kernel function or it is known that the\n  ///   function will be emitted for the device, emits the diagnostics\n  ///   immediately.\n  /// - If CurLexicalContext is a function and we are compiling\n  ///   for the device, but we don't know that this function will be codegen'ed\n  ///   for devive yet, creates a diagnostic which is emitted if and when we\n  ///   realize that the function will be codegen'ed.\n  ///\n  /// Example usage:\n  ///\n  /// Diagnose __float128 type usage only from SYCL device code if the current\n  /// target doesn't support it\n  /// if (!S.Context.getTargetInfo().hasFloat128Type() &&\n  ///     S.getLangOpts().SYCLIsDevice)\n  ///   SYCLDiagIfDeviceCode(Loc, diag::err_type_unsupported) << \"__float128\";\n  SemaDiagnosticBuilder SYCLDiagIfDeviceCode(SourceLocation Loc,\n                                             unsigned DiagID);\n\n  /// Check whether we're allowed to call Callee from the current context.\n  ///\n  /// - If the call is never allowed in a semantically-correct program\n  ///   emits an error and returns false.\n  ///\n  /// - If the call is allowed in semantically-correct programs, but only if\n  ///   it's never codegen'ed, creates a deferred diagnostic to be emitted if\n  ///   and when the caller is codegen'ed, and returns true.\n  ///\n  /// - Otherwise, returns true without emitting any diagnostics.\n  ///\n  /// Adds Callee to DeviceCallGraph if we don't know if its caller will be\n  /// codegen'ed yet.\n  bool checkSYCLDeviceFunction(SourceLocation Loc, FunctionDecl *Callee);\n};\n\n/// RAII object that enters a new expression evaluation context.\nclass EnterExpressionEvaluationContext {\n  Sema &Actions;\n  bool Entered = true;\n\npublic:\n  EnterExpressionEvaluationContext(\n      Sema &Actions, Sema::ExpressionEvaluationContext NewContext,\n      Decl *LambdaContextDecl = nullptr,\n      Sema::ExpressionEvaluationContextRecord::ExpressionKind ExprContext =\n          Sema::ExpressionEvaluationContextRecord::EK_Other,\n      bool ShouldEnter = true)\n      : Actions(Actions), Entered(ShouldEnter) {\n    if (Entered)\n      Actions.PushExpressionEvaluationContext(NewContext, LambdaContextDecl,\n                                              ExprContext);\n  }\n  EnterExpressionEvaluationContext(\n      Sema &Actions, Sema::ExpressionEvaluationContext NewContext,\n      Sema::ReuseLambdaContextDecl_t,\n      Sema::ExpressionEvaluationContextRecord::ExpressionKind ExprContext =\n          Sema::ExpressionEvaluationContextRecord::EK_Other)\n      : Actions(Actions) {\n    Actions.PushExpressionEvaluationContext(\n        NewContext, Sema::ReuseLambdaContextDecl, ExprContext);\n  }\n\n  enum InitListTag { InitList };\n  EnterExpressionEvaluationContext(Sema &Actions, InitListTag,\n                                   bool ShouldEnter = true)\n      : Actions(Actions), Entered(false) {\n    // In C++11 onwards, narrowing checks are performed on the contents of\n    // braced-init-lists, even when they occur within unevaluated operands.\n    // Therefore we still need to instantiate constexpr functions used in such\n    // a context.\n    if (ShouldEnter && Actions.isUnevaluatedContext() &&\n        Actions.getLangOpts().CPlusPlus11) {\n      Actions.PushExpressionEvaluationContext(\n          Sema::ExpressionEvaluationContext::UnevaluatedList);\n      Entered = true;\n    }\n  }\n\n  ~EnterExpressionEvaluationContext() {\n    if (Entered)\n      Actions.PopExpressionEvaluationContext();\n  }\n};\n\nDeductionFailureInfo\nMakeDeductionFailureInfo(ASTContext &Context, Sema::TemplateDeductionResult TDK,\n                         sema::TemplateDeductionInfo &Info);\n\n/// Contains a late templated function.\n/// Will be parsed at the end of the translation unit, used by Sema & Parser.\nstruct LateParsedTemplate {\n  CachedTokens Toks;\n  /// The template function declaration to be late parsed.\n  Decl *D;\n};\n\ntemplate <>\nvoid Sema::PragmaStack<Sema::AlignPackInfo>::Act(SourceLocation PragmaLocation,\n                                                 PragmaMsStackAction Action,\n                                                 llvm::StringRef StackSlotLabel,\n                                                 AlignPackInfo Value);\n\n} // end namespace clang\n\nnamespace llvm {\n// Hash a FunctionDeclAndLoc by looking at both its FunctionDecl and its\n// SourceLocation.\ntemplate <> struct DenseMapInfo<clang::Sema::FunctionDeclAndLoc> {\n  using FunctionDeclAndLoc = clang::Sema::FunctionDeclAndLoc;\n  using FDBaseInfo = DenseMapInfo<clang::CanonicalDeclPtr<clang::FunctionDecl>>;\n\n  static FunctionDeclAndLoc getEmptyKey() {\n    return {FDBaseInfo::getEmptyKey(), clang::SourceLocation()};\n  }\n\n  static FunctionDeclAndLoc getTombstoneKey() {\n    return {FDBaseInfo::getTombstoneKey(), clang::SourceLocation()};\n  }\n\n  static unsigned getHashValue(const FunctionDeclAndLoc &FDL) {\n    return hash_combine(FDBaseInfo::getHashValue(FDL.FD),\n                        FDL.Loc.getHashValue());\n  }\n\n  static bool isEqual(const FunctionDeclAndLoc &LHS,\n                      const FunctionDeclAndLoc &RHS) {\n    return LHS.FD == RHS.FD && LHS.Loc == RHS.Loc;\n  }\n};\n} // namespace llvm\n\n#endif\n"}, "80": {"id": 80, "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp", "content": "//===- CIndexCodeCompletion.cpp - Code Completion API hooks ---------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the Clang-C Source Indexing library hooks for\n// code completion.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"CIndexer.h\"\n#include \"CIndexDiagnostic.h\"\n#include \"CLog.h\"\n#include \"CXCursor.h\"\n#include \"CXSourceLocation.h\"\n#include \"CXString.h\"\n#include \"CXTranslationUnit.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/FileManager.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Frontend/ASTUnit.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Sema/CodeCompleteConsumer.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/Support/CrashRecoveryContext.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/Program.h\"\n#include \"llvm/Support/Timer.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <atomic>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n\n\n#ifdef UDP_CODE_COMPLETION_LOGGER\n#include \"clang/Basic/Version.h\"\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n#endif\n\nusing namespace clang;\nusing namespace clang::cxindex;\n\nenum CXCompletionChunkKind\nclang_getCompletionChunkKind(CXCompletionString completion_string,\n                             unsigned chunk_number) {\n  CodeCompletionString *CCStr = (CodeCompletionString *)completion_string;\n  if (!CCStr || chunk_number >= CCStr->size())\n    return CXCompletionChunk_Text;\n\n  switch ((*CCStr)[chunk_number].Kind) {\n  case CodeCompletionString::CK_TypedText:\n    return CXCompletionChunk_TypedText;\n  case CodeCompletionString::CK_Text:\n    return CXCompletionChunk_Text;\n  case CodeCompletionString::CK_Optional:\n    return CXCompletionChunk_Optional;\n  case CodeCompletionString::CK_Placeholder:\n    return CXCompletionChunk_Placeholder;\n  case CodeCompletionString::CK_Informative:\n    return CXCompletionChunk_Informative;\n  case CodeCompletionString::CK_ResultType:\n    return CXCompletionChunk_ResultType;\n  case CodeCompletionString::CK_CurrentParameter:\n    return CXCompletionChunk_CurrentParameter;\n  case CodeCompletionString::CK_LeftParen:\n    return CXCompletionChunk_LeftParen;\n  case CodeCompletionString::CK_RightParen:\n    return CXCompletionChunk_RightParen;\n  case CodeCompletionString::CK_LeftBracket:\n    return CXCompletionChunk_LeftBracket;\n  case CodeCompletionString::CK_RightBracket:\n    return CXCompletionChunk_RightBracket;\n  case CodeCompletionString::CK_LeftBrace:\n    return CXCompletionChunk_LeftBrace;\n  case CodeCompletionString::CK_RightBrace:\n    return CXCompletionChunk_RightBrace;\n  case CodeCompletionString::CK_LeftAngle:\n    return CXCompletionChunk_LeftAngle;\n  case CodeCompletionString::CK_RightAngle:\n    return CXCompletionChunk_RightAngle;\n  case CodeCompletionString::CK_Comma:\n    return CXCompletionChunk_Comma;\n  case CodeCompletionString::CK_Colon:\n    return CXCompletionChunk_Colon;\n  case CodeCompletionString::CK_SemiColon:\n    return CXCompletionChunk_SemiColon;\n  case CodeCompletionString::CK_Equal:\n    return CXCompletionChunk_Equal;\n  case CodeCompletionString::CK_HorizontalSpace:\n    return CXCompletionChunk_HorizontalSpace;\n  case CodeCompletionString::CK_VerticalSpace:\n    return CXCompletionChunk_VerticalSpace;\n  }\n\n  llvm_unreachable(\"Invalid CompletionKind!\");\n}\n\nCXString clang_getCompletionChunkText(CXCompletionString completion_string,\n                                      unsigned chunk_number) {\n  CodeCompletionString *CCStr = (CodeCompletionString *)completion_string;\n  if (!CCStr || chunk_number >= CCStr->size())\n    return cxstring::createNull();\n\n  switch ((*CCStr)[chunk_number].Kind) {\n  case CodeCompletionString::CK_TypedText:\n  case CodeCompletionString::CK_Text:\n  case CodeCompletionString::CK_Placeholder:\n  case CodeCompletionString::CK_CurrentParameter:\n  case CodeCompletionString::CK_Informative:\n  case CodeCompletionString::CK_LeftParen:\n  case CodeCompletionString::CK_RightParen:\n  case CodeCompletionString::CK_LeftBracket:\n  case CodeCompletionString::CK_RightBracket:\n  case CodeCompletionString::CK_LeftBrace:\n  case CodeCompletionString::CK_RightBrace:\n  case CodeCompletionString::CK_LeftAngle:\n  case CodeCompletionString::CK_RightAngle:\n  case CodeCompletionString::CK_Comma:\n  case CodeCompletionString::CK_ResultType:\n  case CodeCompletionString::CK_Colon:\n  case CodeCompletionString::CK_SemiColon:\n  case CodeCompletionString::CK_Equal:\n  case CodeCompletionString::CK_HorizontalSpace:\n  case CodeCompletionString::CK_VerticalSpace:\n    return cxstring::createRef((*CCStr)[chunk_number].Text);\n      \n  case CodeCompletionString::CK_Optional:\n    // Note: treated as an empty text block.\n    return cxstring::createEmpty();\n  }\n\n  llvm_unreachable(\"Invalid CodeCompletionString Kind!\");\n}\n\n\nCXCompletionString\nclang_getCompletionChunkCompletionString(CXCompletionString completion_string,\n                                         unsigned chunk_number) {\n  CodeCompletionString *CCStr = (CodeCompletionString *)completion_string;\n  if (!CCStr || chunk_number >= CCStr->size())\n    return nullptr;\n\n  switch ((*CCStr)[chunk_number].Kind) {\n  case CodeCompletionString::CK_TypedText:\n  case CodeCompletionString::CK_Text:\n  case CodeCompletionString::CK_Placeholder:\n  case CodeCompletionString::CK_CurrentParameter:\n  case CodeCompletionString::CK_Informative:\n  case CodeCompletionString::CK_LeftParen:\n  case CodeCompletionString::CK_RightParen:\n  case CodeCompletionString::CK_LeftBracket:\n  case CodeCompletionString::CK_RightBracket:\n  case CodeCompletionString::CK_LeftBrace:\n  case CodeCompletionString::CK_RightBrace:\n  case CodeCompletionString::CK_LeftAngle:\n  case CodeCompletionString::CK_RightAngle:\n  case CodeCompletionString::CK_Comma:\n  case CodeCompletionString::CK_ResultType:\n  case CodeCompletionString::CK_Colon:\n  case CodeCompletionString::CK_SemiColon:\n  case CodeCompletionString::CK_Equal:\n  case CodeCompletionString::CK_HorizontalSpace:\n  case CodeCompletionString::CK_VerticalSpace:\n    return nullptr;\n\n  case CodeCompletionString::CK_Optional:\n    // Note: treated as an empty text block.\n    return (*CCStr)[chunk_number].Optional;\n  }\n\n  llvm_unreachable(\"Invalid CompletionKind!\");\n}\n\nunsigned clang_getNumCompletionChunks(CXCompletionString completion_string) {\n  CodeCompletionString *CCStr = (CodeCompletionString *)completion_string;\n  return CCStr? CCStr->size() : 0;\n}\n\nunsigned clang_getCompletionPriority(CXCompletionString completion_string) {\n  CodeCompletionString *CCStr = (CodeCompletionString *)completion_string;\n  return CCStr? CCStr->getPriority() : unsigned(CCP_Unlikely);\n}\n  \nenum CXAvailabilityKind \nclang_getCompletionAvailability(CXCompletionString completion_string) {\n  CodeCompletionString *CCStr = (CodeCompletionString *)completion_string;\n  return CCStr? static_cast<CXAvailabilityKind>(CCStr->getAvailability())\n              : CXAvailability_Available;\n}\n\nunsigned clang_getCompletionNumAnnotations(CXCompletionString completion_string)\n{\n  CodeCompletionString *CCStr = (CodeCompletionString *)completion_string;\n  return CCStr ? CCStr->getAnnotationCount() : 0;\n}\n\nCXString clang_getCompletionAnnotation(CXCompletionString completion_string,\n                                       unsigned annotation_number) {\n  CodeCompletionString *CCStr = (CodeCompletionString *)completion_string;\n  return CCStr ? cxstring::createRef(CCStr->getAnnotation(annotation_number))\n               : cxstring::createNull();\n}\n\nCXString\nclang_getCompletionParent(CXCompletionString completion_string,\n                          CXCursorKind *kind) {\n  if (kind)\n    *kind = CXCursor_NotImplemented;\n  \n  CodeCompletionString *CCStr = (CodeCompletionString *)completion_string;\n  if (!CCStr)\n    return cxstring::createNull();\n  \n  return cxstring::createRef(CCStr->getParentContextName());\n}\n\nCXString\nclang_getCompletionBriefComment(CXCompletionString completion_string) {\n  CodeCompletionString *CCStr = (CodeCompletionString *)completion_string;\n\n  if (!CCStr)\n    return cxstring::createNull();\n\n  return cxstring::createRef(CCStr->getBriefComment());\n}\n\nnamespace {\n\n/// The CXCodeCompleteResults structure we allocate internally;\n/// the client only sees the initial CXCodeCompleteResults structure.\n///\n/// Normally, clients of CXString shouldn't care whether or not a CXString is\n/// managed by a pool or by explicitly malloc'ed memory.  But\n/// AllocatedCXCodeCompleteResults outlives the CXTranslationUnit, so we can\n/// not rely on the StringPool in the TU.\nstruct AllocatedCXCodeCompleteResults : public CXCodeCompleteResults {\n  AllocatedCXCodeCompleteResults(IntrusiveRefCntPtr<FileManager> FileMgr);\n  ~AllocatedCXCodeCompleteResults();\n  \n  /// Diagnostics produced while performing code completion.\n  SmallVector<StoredDiagnostic, 8> Diagnostics;\n\n  /// Allocated API-exposed wrappters for Diagnostics.\n  SmallVector<std::unique_ptr<CXStoredDiagnostic>, 8> DiagnosticsWrappers;\n\n  IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts;\n  \n  /// Diag object\n  IntrusiveRefCntPtr<DiagnosticsEngine> Diag;\n  \n  /// Language options used to adjust source locations.\n  LangOptions LangOpts;\n\n  /// File manager, used for diagnostics.\n  IntrusiveRefCntPtr<FileManager> FileMgr;\n\n  /// Source manager, used for diagnostics.\n  IntrusiveRefCntPtr<SourceManager> SourceMgr;\n  \n  /// Temporary buffers that will be deleted once we have finished with\n  /// the code-completion results.\n  SmallVector<const llvm::MemoryBuffer *, 1> TemporaryBuffers;\n  \n  /// Allocator used to store globally cached code-completion results.\n  std::shared_ptr<clang::GlobalCodeCompletionAllocator>\n      CachedCompletionAllocator;\n\n  /// Allocator used to store code completion results.\n  std::shared_ptr<clang::GlobalCodeCompletionAllocator> CodeCompletionAllocator;\n\n  /// Context under which completion occurred.\n  enum clang::CodeCompletionContext::Kind ContextKind;\n  \n  /// A bitfield representing the acceptable completions for the\n  /// current context.\n  unsigned long long Contexts;\n  \n  /// The kind of the container for the current context for completions.\n  enum CXCursorKind ContainerKind;\n\n  /// The USR of the container for the current context for completions.\n  std::string ContainerUSR;\n\n  /// a boolean value indicating whether there is complete information\n  /// about the container\n  unsigned ContainerIsIncomplete;\n  \n  /// A string containing the Objective-C selector entered thus far for a\n  /// message send.\n  std::string Selector;\n\n  /// Vector of fix-its for each completion result that *must* be applied\n  /// before that result for the corresponding completion item.\n  std::vector<std::vector<FixItHint>> FixItsVector;\n};\n\n} // end anonymous namespace\n\nunsigned clang_getCompletionNumFixIts(CXCodeCompleteResults *results,\n                                      unsigned completion_index) {\n  AllocatedCXCodeCompleteResults *allocated_results = (AllocatedCXCodeCompleteResults *)results;\n\n  if (!allocated_results || allocated_results->FixItsVector.size() <= completion_index)\n    return 0;\n\n  return static_cast<unsigned>(allocated_results->FixItsVector[completion_index].size());\n}\n\nCXString clang_getCompletionFixIt(CXCodeCompleteResults *results,\n                                  unsigned completion_index,\n                                  unsigned fixit_index,\n                                  CXSourceRange *replacement_range) {\n  AllocatedCXCodeCompleteResults *allocated_results = (AllocatedCXCodeCompleteResults *)results;\n\n  if (!allocated_results || allocated_results->FixItsVector.size() <= completion_index) {\n    if (replacement_range)\n      *replacement_range = clang_getNullRange();\n    return cxstring::createNull();\n  }\n\n  ArrayRef<FixItHint> FixIts = allocated_results->FixItsVector[completion_index];\n  if (FixIts.size() <= fixit_index) {\n    if (replacement_range)\n      *replacement_range = clang_getNullRange();\n    return cxstring::createNull();\n  }\n\n  const FixItHint &FixIt = FixIts[fixit_index];\n  if (replacement_range) {\n    *replacement_range = cxloc::translateSourceRange(\n        *allocated_results->SourceMgr, allocated_results->LangOpts,\n        FixIt.RemoveRange);\n  }\n\n  return cxstring::createRef(FixIt.CodeToInsert.c_str());\n}\n\n/// Tracks the number of code-completion result objects that are \n/// currently active.\n///\n/// Used for debugging purposes only.\nstatic std::atomic<unsigned> CodeCompletionResultObjects;\n\nAllocatedCXCodeCompleteResults::AllocatedCXCodeCompleteResults(\n    IntrusiveRefCntPtr<FileManager> FileMgr)\n    : CXCodeCompleteResults(), DiagOpts(new DiagnosticOptions),\n      Diag(new DiagnosticsEngine(\n          IntrusiveRefCntPtr<DiagnosticIDs>(new DiagnosticIDs), &*DiagOpts)),\n      FileMgr(std::move(FileMgr)),\n      SourceMgr(new SourceManager(*Diag, *this->FileMgr)),\n      CodeCompletionAllocator(\n          std::make_shared<clang::GlobalCodeCompletionAllocator>()),\n      Contexts(CXCompletionContext_Unknown),\n      ContainerKind(CXCursor_InvalidCode), ContainerIsIncomplete(1) {\n  if (getenv(\"LIBCLANG_OBJTRACKING\"))\n    fprintf(stderr, \"+++ %u completion results\\n\",\n            ++CodeCompletionResultObjects);\n}\n  \nAllocatedCXCodeCompleteResults::~AllocatedCXCodeCompleteResults() {\n  delete [] Results;\n\n  for (unsigned I = 0, N = TemporaryBuffers.size(); I != N; ++I)\n    delete TemporaryBuffers[I];\n\n  if (getenv(\"LIBCLANG_OBJTRACKING\"))\n    fprintf(stderr, \"--- %u completion results\\n\",\n            --CodeCompletionResultObjects);\n}\n\nstatic unsigned long long getContextsForContextKind(\n                                          enum CodeCompletionContext::Kind kind, \n                                                    Sema &S) {\n  unsigned long long contexts = 0;\n  switch (kind) {\n    case CodeCompletionContext::CCC_OtherWithMacros: {\n      //We can allow macros here, but we don't know what else is permissible\n      //So we'll say the only thing permissible are macros\n      contexts = CXCompletionContext_MacroName;\n      break;\n    }\n    case CodeCompletionContext::CCC_TopLevel:\n    case CodeCompletionContext::CCC_ObjCIvarList:\n    case CodeCompletionContext::CCC_ClassStructUnion:\n    case CodeCompletionContext::CCC_Type: {\n      contexts = CXCompletionContext_AnyType | \n                 CXCompletionContext_ObjCInterface;\n      if (S.getLangOpts().CPlusPlus) {\n        contexts |= CXCompletionContext_EnumTag |\n                    CXCompletionContext_UnionTag |\n                    CXCompletionContext_StructTag |\n                    CXCompletionContext_ClassTag |\n                    CXCompletionContext_NestedNameSpecifier;\n      }\n      break;\n    }\n    case CodeCompletionContext::CCC_Statement: {\n      contexts = CXCompletionContext_AnyType |\n                 CXCompletionContext_ObjCInterface |\n                 CXCompletionContext_AnyValue;\n      if (S.getLangOpts().CPlusPlus) {\n        contexts |= CXCompletionContext_EnumTag |\n                    CXCompletionContext_UnionTag |\n                    CXCompletionContext_StructTag |\n                    CXCompletionContext_ClassTag |\n                    CXCompletionContext_NestedNameSpecifier;\n      }\n      break;\n    }\n    case CodeCompletionContext::CCC_Expression: {\n      contexts = CXCompletionContext_AnyValue;\n      if (S.getLangOpts().CPlusPlus) {\n        contexts |= CXCompletionContext_AnyType |\n                    CXCompletionContext_ObjCInterface |\n                    CXCompletionContext_EnumTag |\n                    CXCompletionContext_UnionTag |\n                    CXCompletionContext_StructTag |\n                    CXCompletionContext_ClassTag |\n                    CXCompletionContext_NestedNameSpecifier;\n      }\n      break;\n    }\n    case CodeCompletionContext::CCC_ObjCMessageReceiver: {\n      contexts = CXCompletionContext_ObjCObjectValue |\n                 CXCompletionContext_ObjCSelectorValue |\n                 CXCompletionContext_ObjCInterface;\n      if (S.getLangOpts().CPlusPlus) {\n        contexts |= CXCompletionContext_CXXClassTypeValue |\n                    CXCompletionContext_AnyType |\n                    CXCompletionContext_EnumTag |\n                    CXCompletionContext_UnionTag |\n                    CXCompletionContext_StructTag |\n                    CXCompletionContext_ClassTag |\n                    CXCompletionContext_NestedNameSpecifier;\n      }\n      break;\n    }\n    case CodeCompletionContext::CCC_DotMemberAccess: {\n      contexts = CXCompletionContext_DotMemberAccess;\n      break;\n    }\n    case CodeCompletionContext::CCC_ArrowMemberAccess: {\n      contexts = CXCompletionContext_ArrowMemberAccess;\n      break;\n    }\n    case CodeCompletionContext::CCC_ObjCPropertyAccess: {\n      contexts = CXCompletionContext_ObjCPropertyAccess;\n      break;\n    }\n    case CodeCompletionContext::CCC_EnumTag: {\n      contexts = CXCompletionContext_EnumTag |\n                 CXCompletionContext_NestedNameSpecifier;\n      break;\n    }\n    case CodeCompletionContext::CCC_UnionTag: {\n      contexts = CXCompletionContext_UnionTag |\n                 CXCompletionContext_NestedNameSpecifier;\n      break;\n    }\n    case CodeCompletionContext::CCC_ClassOrStructTag: {\n      contexts = CXCompletionContext_StructTag |\n                 CXCompletionContext_ClassTag |\n                 CXCompletionContext_NestedNameSpecifier;\n      break;\n    }\n    case CodeCompletionContext::CCC_ObjCProtocolName: {\n      contexts = CXCompletionContext_ObjCProtocol;\n      break;\n    }\n    case CodeCompletionContext::CCC_Namespace: {\n      contexts = CXCompletionContext_Namespace;\n      break;\n    }\n    case CodeCompletionContext::CCC_SymbolOrNewName:\n    case CodeCompletionContext::CCC_Symbol: {\n      contexts = CXCompletionContext_NestedNameSpecifier;\n      break;\n    }\n    case CodeCompletionContext::CCC_MacroNameUse: {\n      contexts = CXCompletionContext_MacroName;\n      break;\n    }\n    case CodeCompletionContext::CCC_NaturalLanguage: {\n      contexts = CXCompletionContext_NaturalLanguage;\n      break;\n    }\n    case CodeCompletionContext::CCC_IncludedFile: {\n      contexts = CXCompletionContext_IncludedFile;\n      break;\n    }\n    case CodeCompletionContext::CCC_SelectorName: {\n      contexts = CXCompletionContext_ObjCSelectorName;\n      break;\n    }\n    case CodeCompletionContext::CCC_ParenthesizedExpression: {\n      contexts = CXCompletionContext_AnyType |\n                 CXCompletionContext_ObjCInterface |\n                 CXCompletionContext_AnyValue;\n      if (S.getLangOpts().CPlusPlus) {\n        contexts |= CXCompletionContext_EnumTag |\n                    CXCompletionContext_UnionTag |\n                    CXCompletionContext_StructTag |\n                    CXCompletionContext_ClassTag |\n                    CXCompletionContext_NestedNameSpecifier;\n      }\n      break;\n    }\n    case CodeCompletionContext::CCC_ObjCInstanceMessage: {\n      contexts = CXCompletionContext_ObjCInstanceMessage;\n      break;\n    }\n    case CodeCompletionContext::CCC_ObjCClassMessage: {\n      contexts = CXCompletionContext_ObjCClassMessage;\n      break;\n    }\n    case CodeCompletionContext::CCC_ObjCInterfaceName: {\n      contexts = CXCompletionContext_ObjCInterface;\n      break;\n    }\n    case CodeCompletionContext::CCC_ObjCCategoryName: {\n      contexts = CXCompletionContext_ObjCCategory;\n      break;\n    }\n    case CodeCompletionContext::CCC_Other:\n    case CodeCompletionContext::CCC_ObjCInterface:\n    case CodeCompletionContext::CCC_ObjCImplementation:\n    case CodeCompletionContext::CCC_NewName:\n    case CodeCompletionContext::CCC_MacroName:\n    case CodeCompletionContext::CCC_PreprocessorExpression:\n    case CodeCompletionContext::CCC_PreprocessorDirective:\n    case CodeCompletionContext::CCC_TypeQualifiers: {\n      //Only Clang results should be accepted, so we'll set all of the other\n      //context bits to 0 (i.e. the empty set)\n      contexts = CXCompletionContext_Unexposed;\n      break;\n    }\n    case CodeCompletionContext::CCC_Recovery: {\n      //We don't know what the current context is, so we'll return unknown\n      //This is the equivalent of setting all of the other context bits\n      contexts = CXCompletionContext_Unknown;\n      break;\n    }\n  }\n  return contexts;\n}\n\nnamespace {\n  class CaptureCompletionResults : public CodeCompleteConsumer {\n    AllocatedCXCodeCompleteResults &AllocatedResults;\n    CodeCompletionTUInfo CCTUInfo;\n    SmallVector<CXCompletionResult, 16> StoredResults;\n    CXTranslationUnit *TU;\n  public:\n    CaptureCompletionResults(const CodeCompleteOptions &Opts,\n                             AllocatedCXCodeCompleteResults &Results,\n                             CXTranslationUnit *TranslationUnit)\n        : CodeCompleteConsumer(Opts), AllocatedResults(Results),\n          CCTUInfo(Results.CodeCompletionAllocator), TU(TranslationUnit) {}\n    ~CaptureCompletionResults() override { Finish(); }\n\n    void ProcessCodeCompleteResults(Sema &S, \n                                    CodeCompletionContext Context,\n                                    CodeCompletionResult *Results,\n                                    unsigned NumResults) override {\n      StoredResults.reserve(StoredResults.size() + NumResults);\n      if (includeFixIts())\n        AllocatedResults.FixItsVector.reserve(NumResults);\n      for (unsigned I = 0; I != NumResults; ++I) {\n        CodeCompletionString *StoredCompletion\n          = Results[I].CreateCodeCompletionString(S, Context, getAllocator(),\n                                                  getCodeCompletionTUInfo(),\n                                                  includeBriefComments());\n        \n        CXCompletionResult R;\n        R.CursorKind = Results[I].CursorKind;\n        R.CompletionString = StoredCompletion;\n        StoredResults.push_back(R);\n        if (includeFixIts())\n          AllocatedResults.FixItsVector.emplace_back(std::move(Results[I].FixIts));\n      }\n\n      enum CodeCompletionContext::Kind contextKind = Context.getKind();\n      \n      AllocatedResults.ContextKind = contextKind;\n      AllocatedResults.Contexts = getContextsForContextKind(contextKind, S);\n      \n      AllocatedResults.Selector = \"\";\n      ArrayRef<IdentifierInfo *> SelIdents = Context.getSelIdents();\n      for (ArrayRef<IdentifierInfo *>::iterator I = SelIdents.begin(),\n                                                E = SelIdents.end();\n           I != E; ++I) {\n        if (IdentifierInfo *selIdent = *I)\n          AllocatedResults.Selector += selIdent->getName();\n        AllocatedResults.Selector += \":\";\n      }\n      \n      QualType baseType = Context.getBaseType();\n      NamedDecl *D = nullptr;\n\n      if (!baseType.isNull()) {\n        // Get the declaration for a class/struct/union/enum type\n        if (const TagType *Tag = baseType->getAs<TagType>())\n          D = Tag->getDecl();\n        // Get the @interface declaration for a (possibly-qualified) Objective-C\n        // object pointer type, e.g., NSString*\n        else if (const ObjCObjectPointerType *ObjPtr = \n                 baseType->getAs<ObjCObjectPointerType>())\n          D = ObjPtr->getInterfaceDecl();\n        // Get the @interface declaration for an Objective-C object type\n        else if (const ObjCObjectType *Obj = baseType->getAs<ObjCObjectType>())\n          D = Obj->getInterface();\n        // Get the class for a C++ injected-class-name\n        else if (const InjectedClassNameType *Injected =\n                 baseType->getAs<InjectedClassNameType>())\n          D = Injected->getDecl();\n      }\n\n      if (D != nullptr) {\n        CXCursor cursor = cxcursor::MakeCXCursor(D, *TU);\n\n        AllocatedResults.ContainerKind = clang_getCursorKind(cursor);\n\n        CXString CursorUSR = clang_getCursorUSR(cursor);\n        AllocatedResults.ContainerUSR = clang_getCString(CursorUSR);\n        clang_disposeString(CursorUSR);\n\n        const Type *type = baseType.getTypePtrOrNull();\n        if (type) {\n          AllocatedResults.ContainerIsIncomplete = type->isIncompleteType();\n        }\n        else {\n          AllocatedResults.ContainerIsIncomplete = 1;\n        }\n      }\n      else {\n        AllocatedResults.ContainerKind = CXCursor_InvalidCode;\n        AllocatedResults.ContainerUSR.clear();\n        AllocatedResults.ContainerIsIncomplete = 1;\n      }\n    }\n\n    void ProcessOverloadCandidates(Sema &S, unsigned CurrentArg,\n                                   OverloadCandidate *Candidates,\n                                   unsigned NumCandidates,\n                                   SourceLocation OpenParLoc) override {\n      StoredResults.reserve(StoredResults.size() + NumCandidates);\n      for (unsigned I = 0; I != NumCandidates; ++I) {\n        CodeCompletionString *StoredCompletion\n          = Candidates[I].CreateSignatureString(CurrentArg, S, getAllocator(),\n                                                getCodeCompletionTUInfo(),\n                                                includeBriefComments());\n        \n        CXCompletionResult R;\n        R.CursorKind = CXCursor_OverloadCandidate;\n        R.CompletionString = StoredCompletion;\n        StoredResults.push_back(R);\n      }\n    }\n\n    CodeCompletionAllocator &getAllocator() override {\n      return *AllocatedResults.CodeCompletionAllocator;\n    }\n\n    CodeCompletionTUInfo &getCodeCompletionTUInfo() override { return CCTUInfo;}\n\n  private:\n    void Finish() {\n      AllocatedResults.Results = new CXCompletionResult [StoredResults.size()];\n      AllocatedResults.NumResults = StoredResults.size();\n      std::memcpy(AllocatedResults.Results, StoredResults.data(), \n                  StoredResults.size() * sizeof(CXCompletionResult));\n      StoredResults.clear();\n    }\n  };\n}\n\nstatic CXCodeCompleteResults *\nclang_codeCompleteAt_Impl(CXTranslationUnit TU, const char *complete_filename,\n                          unsigned complete_line, unsigned complete_column,\n                          ArrayRef<CXUnsavedFile> unsaved_files,\n                          unsigned options) {\n  bool IncludeBriefComments = options & CXCodeComplete_IncludeBriefComments;\n  bool SkipPreamble = options & CXCodeComplete_SkipPreamble;\n  bool IncludeFixIts = options & CXCodeComplete_IncludeCompletionsWithFixIts;\n\n#ifdef UDP_CODE_COMPLETION_LOGGER\n#ifdef UDP_CODE_COMPLETION_LOGGER_PORT\n  const llvm::TimeRecord &StartTime =  llvm::TimeRecord::getCurrentTime();\n#endif\n#endif\n  bool EnableLogging = getenv(\"LIBCLANG_CODE_COMPLETION_LOGGING\") != nullptr;\n\n  if (cxtu::isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return nullptr;\n  }\n\n  ASTUnit *AST = cxtu::getASTUnit(TU);\n  if (!AST)\n    return nullptr;\n\n  CIndexer *CXXIdx = TU->CIdx;\n  if (CXXIdx->isOptEnabled(CXGlobalOpt_ThreadBackgroundPriorityForEditing))\n    setThreadBackgroundPriority();\n\n  ASTUnit::ConcurrencyCheck Check(*AST);\n\n  // Perform the remapping of source files.\n  SmallVector<ASTUnit::RemappedFile, 4> RemappedFiles;\n\n  for (auto &UF : unsaved_files) {\n    std::unique_ptr<llvm::MemoryBuffer> MB =\n        llvm::MemoryBuffer::getMemBufferCopy(getContents(UF), UF.Filename);\n    RemappedFiles.push_back(std::make_pair(UF.Filename, MB.release()));\n  }\n\n  if (EnableLogging) {\n    // FIXME: Add logging.\n  }\n\n  // Parse the resulting source file to find code-completion results.\n  AllocatedCXCodeCompleteResults *Results = new AllocatedCXCodeCompleteResults(\n      &AST->getFileManager());\n  Results->Results = nullptr;\n  Results->NumResults = 0;\n  \n  // Create a code-completion consumer to capture the results.\n  CodeCompleteOptions Opts;\n  Opts.IncludeBriefComments = IncludeBriefComments;\n  Opts.LoadExternal = !SkipPreamble;\n  Opts.IncludeFixIts = IncludeFixIts;\n  CaptureCompletionResults Capture(Opts, *Results, &TU);\n\n  // Perform completion.\n  std::vector<const char *> CArgs;\n  for (const auto &Arg : TU->Arguments)\n    CArgs.push_back(Arg.c_str());\n  std::string CompletionInvocation =\n      llvm::formatv(\"-code-completion-at={0}:{1}:{2}\", complete_filename,\n                    complete_line, complete_column)\n          .str();\n  LibclangInvocationReporter InvocationReporter(\n      *CXXIdx, LibclangInvocationReporter::OperationKind::CompletionOperation,\n      TU->ParsingOptions, CArgs, CompletionInvocation, unsaved_files);\n  AST->CodeComplete(complete_filename, complete_line, complete_column,\n                    RemappedFiles, (options & CXCodeComplete_IncludeMacros),\n                    (options & CXCodeComplete_IncludeCodePatterns),\n                    IncludeBriefComments, Capture,\n                    CXXIdx->getPCHContainerOperations(), *Results->Diag,\n                    Results->LangOpts, *Results->SourceMgr, *Results->FileMgr,\n                    Results->Diagnostics, Results->TemporaryBuffers);\n\n  Results->DiagnosticsWrappers.resize(Results->Diagnostics.size());\n\n  // Keep a reference to the allocator used for cached global completions, so\n  // that we can be sure that the memory used by our code completion strings\n  // doesn't get freed due to subsequent reparses (while the code completion\n  // results are still active).\n  Results->CachedCompletionAllocator = AST->getCachedCompletionAllocator();\n\n  \n\n#ifdef UDP_CODE_COMPLETION_LOGGER\n#ifdef UDP_CODE_COMPLETION_LOGGER_PORT\n  const llvm::TimeRecord &EndTime =  llvm::TimeRecord::getCurrentTime();\n  SmallString<256> LogResult;\n  llvm::raw_svector_ostream os(LogResult);\n\n  // Figure out the language and whether or not it uses PCH.\n  const char *lang = 0;\n  bool usesPCH = false;\n\n  for (std::vector<const char*>::iterator I = argv.begin(), E = argv.end();\n       I != E; ++I) {\n    if (*I == 0)\n      continue;\n    if (strcmp(*I, \"-x\") == 0) {\n      if (I + 1 != E) {\n        lang = *(++I);\n        continue;\n      }\n    }\n    else if (strcmp(*I, \"-include\") == 0) {\n      if (I+1 != E) {\n        const char *arg = *(++I);\n        SmallString<512> pchName;\n        {\n          llvm::raw_svector_ostream os(pchName);\n          os << arg << \".pth\";\n        }\n        pchName.push_back('\\0');\n        llvm::sys::fs::file_status stat_results;\n        if (!llvm::sys::fs::status(pchName, stat_results))\n          usesPCH = true;\n        continue;\n      }\n    }\n  }\n\n  os << \"{ \";\n  os << \"\\\"wall\\\": \" << (EndTime.getWallTime() - StartTime.getWallTime());\n  os << \", \\\"numRes\\\": \" << Results->NumResults;\n  os << \", \\\"diags\\\": \" << Results->Diagnostics.size();\n  os << \", \\\"pch\\\": \" << (usesPCH ? \"true\" : \"false\");\n  os << \", \\\"lang\\\": \\\"\" << (lang ? lang : \"<unknown>\") << '\"';\n  const char *name = getlogin();\n  os << \", \\\"user\\\": \\\"\" << (name ? name : \"unknown\") << '\"';\n  os << \", \\\"clangVer\\\": \\\"\" << getClangFullVersion() << '\"';\n  os << \" }\";\n\n  StringRef res = os.str();\n  if (res.size() > 0) {\n    do {\n      // Setup the UDP socket.\n      struct sockaddr_in servaddr;\n      bzero(&servaddr, sizeof(servaddr));\n      servaddr.sin_family = AF_INET;\n      servaddr.sin_port = htons(UDP_CODE_COMPLETION_LOGGER_PORT);\n      if (inet_pton(AF_INET, UDP_CODE_COMPLETION_LOGGER,\n                    &servaddr.sin_addr) <= 0)\n        break;\n\n      int sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n      if (sockfd < 0)\n        break;\n\n      sendto(sockfd, res.data(), res.size(), 0,\n             (struct sockaddr *)&servaddr, sizeof(servaddr));\n      close(sockfd);\n    }\n    while (false);\n  }\n#endif\n#endif\n  return Results;\n}\n\nCXCodeCompleteResults *clang_codeCompleteAt(CXTranslationUnit TU,\n                                            const char *complete_filename,\n                                            unsigned complete_line,\n                                            unsigned complete_column,\n                                            struct CXUnsavedFile *unsaved_files,\n                                            unsigned num_unsaved_files,\n                                            unsigned options) {\n  LOG_FUNC_SECTION {\n    *Log << TU << ' '\n         << complete_filename << ':' << complete_line << ':' << complete_column;\n  }\n\n  if (num_unsaved_files && !unsaved_files)\n    return nullptr;\n\n  CXCodeCompleteResults *result;\n  auto CodeCompleteAtImpl = [=, &result]() {\n    result = clang_codeCompleteAt_Impl(\n        TU, complete_filename, complete_line, complete_column,\n        llvm::makeArrayRef(unsaved_files, num_unsaved_files), options);\n  };\n\n  llvm::CrashRecoveryContext CRC;\n\n  if (!RunSafely(CRC, CodeCompleteAtImpl)) {\n    fprintf(stderr, \"libclang: crash detected in code completion\\n\");\n    cxtu::getASTUnit(TU)->setUnsafeToFree(true);\n    return nullptr;\n  } else if (getenv(\"LIBCLANG_RESOURCE_USAGE\"))\n    PrintLibclangResourceUsage(TU);\n\n  return result;\n}\n\nunsigned clang_defaultCodeCompleteOptions(void) {\n  return CXCodeComplete_IncludeMacros;\n}\n\nvoid clang_disposeCodeCompleteResults(CXCodeCompleteResults *ResultsIn) {\n  if (!ResultsIn)\n    return;\n\n  AllocatedCXCodeCompleteResults *Results\n    = static_cast<AllocatedCXCodeCompleteResults*>(ResultsIn);\n  delete Results;\n}\n  \nunsigned \nclang_codeCompleteGetNumDiagnostics(CXCodeCompleteResults *ResultsIn) {\n  AllocatedCXCodeCompleteResults *Results\n    = static_cast<AllocatedCXCodeCompleteResults*>(ResultsIn);\n  if (!Results)\n    return 0;\n\n  return Results->Diagnostics.size();\n}\n\nCXDiagnostic \nclang_codeCompleteGetDiagnostic(CXCodeCompleteResults *ResultsIn,\n                                unsigned Index) {\n  AllocatedCXCodeCompleteResults *Results\n    = static_cast<AllocatedCXCodeCompleteResults*>(ResultsIn);\n  if (!Results || Index >= Results->Diagnostics.size())\n    return nullptr;\n\n  CXStoredDiagnostic *Diag = Results->DiagnosticsWrappers[Index].get();\n  if (!Diag)\n    Diag = (Results->DiagnosticsWrappers[Index] =\n                std::make_unique<CXStoredDiagnostic>(\n                    Results->Diagnostics[Index], Results->LangOpts))\n               .get();\n  return Diag;\n}\n\nunsigned long long\nclang_codeCompleteGetContexts(CXCodeCompleteResults *ResultsIn) {\n  AllocatedCXCodeCompleteResults *Results\n    = static_cast<AllocatedCXCodeCompleteResults*>(ResultsIn);\n  if (!Results)\n    return 0;\n  \n  return Results->Contexts;\n}\n\nenum CXCursorKind clang_codeCompleteGetContainerKind(\n                                               CXCodeCompleteResults *ResultsIn,\n                                                     unsigned *IsIncomplete) {\n  AllocatedCXCodeCompleteResults *Results =\n    static_cast<AllocatedCXCodeCompleteResults *>(ResultsIn);\n  if (!Results)\n    return CXCursor_InvalidCode;\n\n  if (IsIncomplete != nullptr) {\n    *IsIncomplete = Results->ContainerIsIncomplete;\n  }\n  \n  return Results->ContainerKind;\n}\n  \nCXString clang_codeCompleteGetContainerUSR(CXCodeCompleteResults *ResultsIn) {\n  AllocatedCXCodeCompleteResults *Results =\n    static_cast<AllocatedCXCodeCompleteResults *>(ResultsIn);\n  if (!Results)\n    return cxstring::createEmpty();\n\n  return cxstring::createRef(Results->ContainerUSR.c_str());\n}\n\n  \nCXString clang_codeCompleteGetObjCSelector(CXCodeCompleteResults *ResultsIn) {\n  AllocatedCXCodeCompleteResults *Results =\n    static_cast<AllocatedCXCodeCompleteResults *>(ResultsIn);\n  if (!Results)\n    return cxstring::createEmpty();\n  \n  return cxstring::createDup(Results->Selector);\n}\n  \n/// Simple utility function that appends a \\p New string to the given\n/// \\p Old string, using the \\p Buffer for storage.\n///\n/// \\param Old The string to which we are appending. This parameter will be\n/// updated to reflect the complete string.\n///\n///\n/// \\param New The string to append to \\p Old.\n///\n/// \\param Buffer A buffer that stores the actual, concatenated string. It will\n/// be used if the old string is already-non-empty.\nstatic void AppendToString(StringRef &Old, StringRef New,\n                           SmallString<256> &Buffer) {\n  if (Old.empty()) {\n    Old = New;\n    return;\n  }\n  \n  if (Buffer.empty())\n    Buffer.append(Old.begin(), Old.end());\n  Buffer.append(New.begin(), New.end());\n  Old = Buffer.str();\n}\n\n/// Get the typed-text blocks from the given code-completion string\n/// and return them as a single string.\n///\n/// \\param String The code-completion string whose typed-text blocks will be\n/// concatenated.\n///\n/// \\param Buffer A buffer used for storage of the completed name.\nstatic StringRef GetTypedName(CodeCompletionString *String,\n                                    SmallString<256> &Buffer) {\n  StringRef Result;\n  for (CodeCompletionString::iterator C = String->begin(), CEnd = String->end();\n       C != CEnd; ++C) {\n    if (C->Kind == CodeCompletionString::CK_TypedText)\n      AppendToString(Result, C->Text, Buffer);\n  }\n  \n  return Result;\n}\n\nnamespace {\n  struct OrderCompletionResults {\n    bool operator()(const CXCompletionResult &XR, \n                    const CXCompletionResult &YR) const {\n      CodeCompletionString *X\n        = (CodeCompletionString *)XR.CompletionString;\n      CodeCompletionString *Y\n        = (CodeCompletionString *)YR.CompletionString;\n\n      SmallString<256> XBuffer;\n      StringRef XText = GetTypedName(X, XBuffer);\n      SmallString<256> YBuffer;\n      StringRef YText = GetTypedName(Y, YBuffer);\n      \n      if (XText.empty() || YText.empty())\n        return !XText.empty();\n            \n      int result = XText.compare_lower(YText);\n      if (result < 0)\n        return true;\n      if (result > 0)\n        return false;\n      \n      result = XText.compare(YText);\n      return result < 0;\n    }\n  };\n}\n\nvoid clang_sortCodeCompletionResults(CXCompletionResult *Results,\n                                     unsigned NumResults) {\n  std::stable_sort(Results, Results + NumResults, OrderCompletionResults());\n}\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 0, "line": 5137}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang-c/Index.h", "reportHash": "f61eecd813b4cea2c175eb16d05ba31b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 0, "line": 5471}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang-c/Index.h", "reportHash": "f61eecd813b4cea2c175eb16d05ba31b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 72, "line": 2118}, "message": "'ModuleScope' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Sema.h", "reportHash": "4e24d6d085cd03e46ddc010c8e9e5b1f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 80, "line": 1013}, "message": "'OrderCompletionResults' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp", "reportHash": "72d9ad0c5b6eb0686d9e826e63f36161", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
