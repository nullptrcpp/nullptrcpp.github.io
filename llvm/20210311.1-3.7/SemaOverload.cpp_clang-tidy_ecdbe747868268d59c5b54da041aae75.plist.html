<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaOverload.cpp", "content": "//===--- SemaOverload.cpp - C++ Overloading -------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides Sema routines for C++ overloading.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/TypeOrdering.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/DiagnosticOptions.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Sema/Initialization.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/Overload.h\"\n#include \"clang/Sema/SemaInternal.h\"\n#include \"clang/Sema/Template.h\"\n#include \"clang/Sema/TemplateDeduction.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace clang;\nusing namespace sema;\n\nusing AllowedExplicit = Sema::AllowedExplicit;\n\nstatic bool functionHasPassObjectSizeParams(const FunctionDecl *FD) {\n  return llvm::any_of(FD->parameters(), [](const ParmVarDecl *P) {\n    return P->hasAttr<PassObjectSizeAttr>();\n  });\n}\n\n/// A convenience routine for creating a decayed reference to a function.\nstatic ExprResult\nCreateFunctionRefExpr(Sema &S, FunctionDecl *Fn, NamedDecl *FoundDecl,\n                      const Expr *Base, bool HadMultipleCandidates,\n                      SourceLocation Loc = SourceLocation(),\n                      const DeclarationNameLoc &LocInfo = DeclarationNameLoc()){\n  if (S.DiagnoseUseOfDecl(FoundDecl, Loc))\n    return ExprError();\n  // If FoundDecl is different from Fn (such as if one is a template\n  // and the other a specialization), make sure DiagnoseUseOfDecl is\n  // called on both.\n  // FIXME: This would be more comprehensively addressed by modifying\n  // DiagnoseUseOfDecl to accept both the FoundDecl and the decl\n  // being used.\n  if (FoundDecl != Fn && S.DiagnoseUseOfDecl(Fn, Loc))\n    return ExprError();\n  DeclRefExpr *DRE = new (S.Context)\n      DeclRefExpr(S.Context, Fn, false, Fn->getType(), VK_LValue, Loc, LocInfo);\n  if (HadMultipleCandidates)\n    DRE->setHadMultipleCandidates(true);\n\n  S.MarkDeclRefReferenced(DRE, Base);\n  if (auto *FPT = DRE->getType()->getAs<FunctionProtoType>()) {\n    if (isUnresolvedExceptionSpec(FPT->getExceptionSpecType())) {\n      S.ResolveExceptionSpec(Loc, FPT);\n      DRE->setType(Fn->getType());\n    }\n  }\n  return S.ImpCastExprToType(DRE, S.Context.getPointerType(DRE->getType()),\n                             CK_FunctionToPointerDecay);\n}\n\nstatic bool IsStandardConversion(Sema &S, Expr* From, QualType ToType,\n                                 bool InOverloadResolution,\n                                 StandardConversionSequence &SCS,\n                                 bool CStyle,\n                                 bool AllowObjCWritebackConversion);\n\nstatic bool IsTransparentUnionStandardConversion(Sema &S, Expr* From,\n                                                 QualType &ToType,\n                                                 bool InOverloadResolution,\n                                                 StandardConversionSequence &SCS,\n                                                 bool CStyle);\nstatic OverloadingResult\nIsUserDefinedConversion(Sema &S, Expr *From, QualType ToType,\n                        UserDefinedConversionSequence& User,\n                        OverloadCandidateSet& Conversions,\n                        AllowedExplicit AllowExplicit,\n                        bool AllowObjCConversionOnExplicit);\n\nstatic ImplicitConversionSequence::CompareKind\nCompareStandardConversionSequences(Sema &S, SourceLocation Loc,\n                                   const StandardConversionSequence& SCS1,\n                                   const StandardConversionSequence& SCS2);\n\nstatic ImplicitConversionSequence::CompareKind\nCompareQualificationConversions(Sema &S,\n                                const StandardConversionSequence& SCS1,\n                                const StandardConversionSequence& SCS2);\n\nstatic ImplicitConversionSequence::CompareKind\nCompareDerivedToBaseConversions(Sema &S, SourceLocation Loc,\n                                const StandardConversionSequence& SCS1,\n                                const StandardConversionSequence& SCS2);\n\n/// GetConversionRank - Retrieve the implicit conversion rank\n/// corresponding to the given implicit conversion kind.\nImplicitConversionRank clang::GetConversionRank(ImplicitConversionKind Kind) {\n  static const ImplicitConversionRank\n    Rank[(int)ICK_Num_Conversion_Kinds] = {\n    ICR_Exact_Match,\n    ICR_Exact_Match,\n    ICR_Exact_Match,\n    ICR_Exact_Match,\n    ICR_Exact_Match,\n    ICR_Exact_Match,\n    ICR_Promotion,\n    ICR_Promotion,\n    ICR_Promotion,\n    ICR_Conversion,\n    ICR_Conversion,\n    ICR_Conversion,\n    ICR_Conversion,\n    ICR_Conversion,\n    ICR_Conversion,\n    ICR_Conversion,\n    ICR_Conversion,\n    ICR_Conversion,\n    ICR_Conversion,\n    ICR_Conversion,\n    ICR_OCL_Scalar_Widening,\n    ICR_Complex_Real_Conversion,\n    ICR_Conversion,\n    ICR_Conversion,\n    ICR_Writeback_Conversion,\n    ICR_Exact_Match, // NOTE(gbiv): This may not be completely right --\n                     // it was omitted by the patch that added\n                     // ICK_Zero_Event_Conversion\n    ICR_C_Conversion,\n    ICR_C_Conversion_Extension\n  };\n  return Rank[(int)Kind];\n}\n\n/// GetImplicitConversionName - Return the name of this kind of\n/// implicit conversion.\nstatic const char* GetImplicitConversionName(ImplicitConversionKind Kind) {\n  static const char* const Name[(int)ICK_Num_Conversion_Kinds] = {\n    \"No conversion\",\n    \"Lvalue-to-rvalue\",\n    \"Array-to-pointer\",\n    \"Function-to-pointer\",\n    \"Function pointer conversion\",\n    \"Qualification\",\n    \"Integral promotion\",\n    \"Floating point promotion\",\n    \"Complex promotion\",\n    \"Integral conversion\",\n    \"Floating conversion\",\n    \"Complex conversion\",\n    \"Floating-integral conversion\",\n    \"Pointer conversion\",\n    \"Pointer-to-member conversion\",\n    \"Boolean conversion\",\n    \"Compatible-types conversion\",\n    \"Derived-to-base conversion\",\n    \"Vector conversion\",\n    \"SVE Vector conversion\",\n    \"Vector splat\",\n    \"Complex-real conversion\",\n    \"Block Pointer conversion\",\n    \"Transparent Union Conversion\",\n    \"Writeback conversion\",\n    \"OpenCL Zero Event Conversion\",\n    \"C specific type conversion\",\n    \"Incompatible pointer conversion\"\n  };\n  return Name[Kind];\n}\n\n/// StandardConversionSequence - Set the standard conversion\n/// sequence to the identity conversion.\nvoid StandardConversionSequence::setAsIdentityConversion() {\n  First = ICK_Identity;\n  Second = ICK_Identity;\n  Third = ICK_Identity;\n  DeprecatedStringLiteralToCharPtr = false;\n  QualificationIncludesObjCLifetime = false;\n  ReferenceBinding = false;\n  DirectBinding = false;\n  IsLvalueReference = true;\n  BindsToFunctionLvalue = false;\n  BindsToRvalue = false;\n  BindsImplicitObjectArgumentWithoutRefQualifier = false;\n  ObjCLifetimeConversionBinding = false;\n  CopyConstructor = nullptr;\n}\n\n/// getRank - Retrieve the rank of this standard conversion sequence\n/// (C++ 13.3.3.1.1p3). The rank is the largest rank of each of the\n/// implicit conversions.\nImplicitConversionRank StandardConversionSequence::getRank() const {\n  ImplicitConversionRank Rank = ICR_Exact_Match;\n  if  (GetConversionRank(First) > Rank)\n    Rank = GetConversionRank(First);\n  if  (GetConversionRank(Second) > Rank)\n    Rank = GetConversionRank(Second);\n  if  (GetConversionRank(Third) > Rank)\n    Rank = GetConversionRank(Third);\n  return Rank;\n}\n\n/// isPointerConversionToBool - Determines whether this conversion is\n/// a conversion of a pointer or pointer-to-member to bool. This is\n/// used as part of the ranking of standard conversion sequences\n/// (C++ 13.3.3.2p4).\nbool StandardConversionSequence::isPointerConversionToBool() const {\n  // Note that FromType has not necessarily been transformed by the\n  // array-to-pointer or function-to-pointer implicit conversions, so\n  // check for their presence as well as checking whether FromType is\n  // a pointer.\n  if (getToType(1)->isBooleanType() &&\n      (getFromType()->isPointerType() ||\n       getFromType()->isMemberPointerType() ||\n       getFromType()->isObjCObjectPointerType() ||\n       getFromType()->isBlockPointerType() ||\n       First == ICK_Array_To_Pointer || First == ICK_Function_To_Pointer))\n    return true;\n\n  return false;\n}\n\n/// isPointerConversionToVoidPointer - Determines whether this\n/// conversion is a conversion of a pointer to a void pointer. This is\n/// used as part of the ranking of standard conversion sequences (C++\n/// 13.3.3.2p4).\nbool\nStandardConversionSequence::\nisPointerConversionToVoidPointer(ASTContext& Context) const {\n  QualType FromType = getFromType();\n  QualType ToType = getToType(1);\n\n  // Note that FromType has not necessarily been transformed by the\n  // array-to-pointer implicit conversion, so check for its presence\n  // and redo the conversion to get a pointer.\n  if (First == ICK_Array_To_Pointer)\n    FromType = Context.getArrayDecayedType(FromType);\n\n  if (Second == ICK_Pointer_Conversion && FromType->isAnyPointerType())\n    if (const PointerType* ToPtrType = ToType->getAs<PointerType>())\n      return ToPtrType->getPointeeType()->isVoidType();\n\n  return false;\n}\n\n/// Skip any implicit casts which could be either part of a narrowing conversion\n/// or after one in an implicit conversion.\nstatic const Expr *IgnoreNarrowingConversion(ASTContext &Ctx,\n                                             const Expr *Converted) {\n  // We can have cleanups wrapping the converted expression; these need to be\n  // preserved so that destructors run if necessary.\n  if (auto *EWC = dyn_cast<ExprWithCleanups>(Converted)) {\n    Expr *Inner =\n        const_cast<Expr *>(IgnoreNarrowingConversion(Ctx, EWC->getSubExpr()));\n    return ExprWithCleanups::Create(Ctx, Inner, EWC->cleanupsHaveSideEffects(),\n                                    EWC->getObjects());\n  }\n\n  while (auto *ICE = dyn_cast<ImplicitCastExpr>(Converted)) {\n    switch (ICE->getCastKind()) {\n    case CK_NoOp:\n    case CK_IntegralCast:\n    case CK_IntegralToBoolean:\n    case CK_IntegralToFloating:\n    case CK_BooleanToSignedIntegral:\n    case CK_FloatingToIntegral:\n    case CK_FloatingToBoolean:\n    case CK_FloatingCast:\n      Converted = ICE->getSubExpr();\n      continue;\n\n    default:\n      return Converted;\n    }\n  }\n\n  return Converted;\n}\n\n/// Check if this standard conversion sequence represents a narrowing\n/// conversion, according to C++11 [dcl.init.list]p7.\n///\n/// \\param Ctx  The AST context.\n/// \\param Converted  The result of applying this standard conversion sequence.\n/// \\param ConstantValue  If this is an NK_Constant_Narrowing conversion, the\n///        value of the expression prior to the narrowing conversion.\n/// \\param ConstantType  If this is an NK_Constant_Narrowing conversion, the\n///        type of the expression prior to the narrowing conversion.\n/// \\param IgnoreFloatToIntegralConversion If true type-narrowing conversions\n///        from floating point types to integral types should be ignored.\nNarrowingKind StandardConversionSequence::getNarrowingKind(\n    ASTContext &Ctx, const Expr *Converted, APValue &ConstantValue,\n    QualType &ConstantType, bool IgnoreFloatToIntegralConversion) const {\n  assert(Ctx.getLangOpts().CPlusPlus && \"narrowing check outside C++\");\n\n  // C++11 [dcl.init.list]p7:\n  //   A narrowing conversion is an implicit conversion ...\n  QualType FromType = getToType(0);\n  QualType ToType = getToType(1);\n\n  // A conversion to an enumeration type is narrowing if the conversion to\n  // the underlying type is narrowing. This only arises for expressions of\n  // the form 'Enum{init}'.\n  if (auto *ET = ToType->getAs<EnumType>())\n    ToType = ET->getDecl()->getIntegerType();\n\n  switch (Second) {\n  // 'bool' is an integral type; dispatch to the right place to handle it.\n  case ICK_Boolean_Conversion:\n    if (FromType->isRealFloatingType())\n      goto FloatingIntegralConversion;\n    if (FromType->isIntegralOrUnscopedEnumerationType())\n      goto IntegralConversion;\n    // -- from a pointer type or pointer-to-member type to bool, or\n    return NK_Type_Narrowing;\n\n  // -- from a floating-point type to an integer type, or\n  //\n  // -- from an integer type or unscoped enumeration type to a floating-point\n  //    type, except where the source is a constant expression and the actual\n  //    value after conversion will fit into the target type and will produce\n  //    the original value when converted back to the original type, or\n  case ICK_Floating_Integral:\n  FloatingIntegralConversion:\n    if (FromType->isRealFloatingType() && ToType->isIntegralType(Ctx)) {\n      return NK_Type_Narrowing;\n    } else if (FromType->isIntegralOrUnscopedEnumerationType() &&\n               ToType->isRealFloatingType()) {\n      if (IgnoreFloatToIntegralConversion)\n        return NK_Not_Narrowing;\n      const Expr *Initializer = IgnoreNarrowingConversion(Ctx, Converted);\n      assert(Initializer && \"Unknown conversion expression\");\n\n      // If it's value-dependent, we can't tell whether it's narrowing.\n      if (Initializer->isValueDependent())\n        return NK_Dependent_Narrowing;\n\n      if (Optional<llvm::APSInt> IntConstantValue =\n              Initializer->getIntegerConstantExpr(Ctx)) {\n        // Convert the integer to the floating type.\n        llvm::APFloat Result(Ctx.getFloatTypeSemantics(ToType));\n        Result.convertFromAPInt(*IntConstantValue, IntConstantValue->isSigned(),\n                                llvm::APFloat::rmNearestTiesToEven);\n        // And back.\n        llvm::APSInt ConvertedValue = *IntConstantValue;\n        bool ignored;\n        Result.convertToInteger(ConvertedValue,\n                                llvm::APFloat::rmTowardZero, &ignored);\n        // If the resulting value is different, this was a narrowing conversion.\n        if (*IntConstantValue != ConvertedValue) {\n          ConstantValue = APValue(*IntConstantValue);\n          ConstantType = Initializer->getType();\n          return NK_Constant_Narrowing;\n        }\n      } else {\n        // Variables are always narrowings.\n        return NK_Variable_Narrowing;\n      }\n    }\n    return NK_Not_Narrowing;\n\n  // -- from long double to double or float, or from double to float, except\n  //    where the source is a constant expression and the actual value after\n  //    conversion is within the range of values that can be represented (even\n  //    if it cannot be represented exactly), or\n  case ICK_Floating_Conversion:\n    if (FromType->isRealFloatingType() && ToType->isRealFloatingType() &&\n        Ctx.getFloatingTypeOrder(FromType, ToType) == 1) {\n      // FromType is larger than ToType.\n      const Expr *Initializer = IgnoreNarrowingConversion(Ctx, Converted);\n\n      // If it's value-dependent, we can't tell whether it's narrowing.\n      if (Initializer->isValueDependent())\n        return NK_Dependent_Narrowing;\n\n      if (Initializer->isCXX11ConstantExpr(Ctx, &ConstantValue)) {\n        // Constant!\n        assert(ConstantValue.isFloat());\n        llvm::APFloat FloatVal = ConstantValue.getFloat();\n        // Convert the source value into the target type.\n        bool ignored;\n        llvm::APFloat::opStatus ConvertStatus = FloatVal.convert(\n          Ctx.getFloatTypeSemantics(ToType),\n          llvm::APFloat::rmNearestTiesToEven, &ignored);\n        // If there was no overflow, the source value is within the range of\n        // values that can be represented.\n        if (ConvertStatus & llvm::APFloat::opOverflow) {\n          ConstantType = Initializer->getType();\n          return NK_Constant_Narrowing;\n        }\n      } else {\n        return NK_Variable_Narrowing;\n      }\n    }\n    return NK_Not_Narrowing;\n\n  // -- from an integer type or unscoped enumeration type to an integer type\n  //    that cannot represent all the values of the original type, except where\n  //    the source is a constant expression and the actual value after\n  //    conversion will fit into the target type and will produce the original\n  //    value when converted back to the original type.\n  case ICK_Integral_Conversion:\n  IntegralConversion: {\n    assert(FromType->isIntegralOrUnscopedEnumerationType());\n    assert(ToType->isIntegralOrUnscopedEnumerationType());\n    const bool FromSigned = FromType->isSignedIntegerOrEnumerationType();\n    const unsigned FromWidth = Ctx.getIntWidth(FromType);\n    const bool ToSigned = ToType->isSignedIntegerOrEnumerationType();\n    const unsigned ToWidth = Ctx.getIntWidth(ToType);\n\n    if (FromWidth > ToWidth ||\n        (FromWidth == ToWidth && FromSigned != ToSigned) ||\n        (FromSigned && !ToSigned)) {\n      // Not all values of FromType can be represented in ToType.\n      const Expr *Initializer = IgnoreNarrowingConversion(Ctx, Converted);\n\n      // If it's value-dependent, we can't tell whether it's narrowing.\n      if (Initializer->isValueDependent())\n        return NK_Dependent_Narrowing;\n\n      Optional<llvm::APSInt> OptInitializerValue;\n      if (!(OptInitializerValue = Initializer->getIntegerConstantExpr(Ctx))) {\n        // Such conversions on variables are always narrowing.\n        return NK_Variable_Narrowing;\n      }\n      llvm::APSInt &InitializerValue = *OptInitializerValue;\n      bool Narrowing = false;\n      if (FromWidth < ToWidth) {\n        // Negative -> unsigned is narrowing. Otherwise, more bits is never\n        // narrowing.\n        if (InitializerValue.isSigned() && InitializerValue.isNegative())\n          Narrowing = true;\n      } else {\n        // Add a bit to the InitializerValue so we don't have to worry about\n        // signed vs. unsigned comparisons.\n        InitializerValue = InitializerValue.extend(\n          InitializerValue.getBitWidth() + 1);\n        // Convert the initializer to and from the target width and signed-ness.\n        llvm::APSInt ConvertedValue = InitializerValue;\n        ConvertedValue = ConvertedValue.trunc(ToWidth);\n        ConvertedValue.setIsSigned(ToSigned);\n        ConvertedValue = ConvertedValue.extend(InitializerValue.getBitWidth());\n        ConvertedValue.setIsSigned(InitializerValue.isSigned());\n        // If the result is different, this was a narrowing conversion.\n        if (ConvertedValue != InitializerValue)\n          Narrowing = true;\n      }\n      if (Narrowing) {\n        ConstantType = Initializer->getType();\n        ConstantValue = APValue(InitializerValue);\n        return NK_Constant_Narrowing;\n      }\n    }\n    return NK_Not_Narrowing;\n  }\n\n  default:\n    // Other kinds of conversions are not narrowings.\n    return NK_Not_Narrowing;\n  }\n}\n\n/// dump - Print this standard conversion sequence to standard\n/// error. Useful for debugging overloading issues.\nLLVM_DUMP_METHOD void StandardConversionSequence::dump() const {\n  raw_ostream &OS = llvm::errs();\n  bool PrintedSomething = false;\n  if (First != ICK_Identity) {\n    OS << GetImplicitConversionName(First);\n    PrintedSomething = true;\n  }\n\n  if (Second != ICK_Identity) {\n    if (PrintedSomething) {\n      OS << \" -> \";\n    }\n    OS << GetImplicitConversionName(Second);\n\n    if (CopyConstructor) {\n      OS << \" (by copy constructor)\";\n    } else if (DirectBinding) {\n      OS << \" (direct reference binding)\";\n    } else if (ReferenceBinding) {\n      OS << \" (reference binding)\";\n    }\n    PrintedSomething = true;\n  }\n\n  if (Third != ICK_Identity) {\n    if (PrintedSomething) {\n      OS << \" -> \";\n    }\n    OS << GetImplicitConversionName(Third);\n    PrintedSomething = true;\n  }\n\n  if (!PrintedSomething) {\n    OS << \"No conversions required\";\n  }\n}\n\n/// dump - Print this user-defined conversion sequence to standard\n/// error. Useful for debugging overloading issues.\nvoid UserDefinedConversionSequence::dump() const {\n  raw_ostream &OS = llvm::errs();\n  if (Before.First || Before.Second || Before.Third) {\n    Before.dump();\n    OS << \" -> \";\n  }\n  if (ConversionFunction)\n    OS << '\\'' << *ConversionFunction << '\\'';\n  else\n    OS << \"aggregate initialization\";\n  if (After.First || After.Second || After.Third) {\n    OS << \" -> \";\n    After.dump();\n  }\n}\n\n/// dump - Print this implicit conversion sequence to standard\n/// error. Useful for debugging overloading issues.\nvoid ImplicitConversionSequence::dump() const {\n  raw_ostream &OS = llvm::errs();\n  if (isStdInitializerListElement())\n    OS << \"Worst std::initializer_list element conversion: \";\n  switch (ConversionKind) {\n  case StandardConversion:\n    OS << \"Standard conversion: \";\n    Standard.dump();\n    break;\n  case UserDefinedConversion:\n    OS << \"User-defined conversion: \";\n    UserDefined.dump();\n    break;\n  case EllipsisConversion:\n    OS << \"Ellipsis conversion\";\n    break;\n  case AmbiguousConversion:\n    OS << \"Ambiguous conversion\";\n    break;\n  case BadConversion:\n    OS << \"Bad conversion\";\n    break;\n  }\n\n  OS << \"\\n\";\n}\n\nvoid AmbiguousConversionSequence::construct() {\n  new (&conversions()) ConversionSet();\n}\n\nvoid AmbiguousConversionSequence::destruct() {\n  conversions().~ConversionSet();\n}\n\nvoid\nAmbiguousConversionSequence::copyFrom(const AmbiguousConversionSequence &O) {\n  FromTypePtr = O.FromTypePtr;\n  ToTypePtr = O.ToTypePtr;\n  new (&conversions()) ConversionSet(O.conversions());\n}\n\nnamespace {\n  // Structure used by DeductionFailureInfo to store\n  // template argument information.\n  struct DFIArguments {\n    TemplateArgument FirstArg;\n    TemplateArgument SecondArg;\n  };\n  // Structure used by DeductionFailureInfo to store\n  // template parameter and template argument information.\n  struct DFIParamWithArguments : DFIArguments {\n    TemplateParameter Param;\n  };\n  // Structure used by DeductionFailureInfo to store template argument\n  // information and the index of the problematic call argument.\n  struct DFIDeducedMismatchArgs : DFIArguments {\n    TemplateArgumentList *TemplateArgs;\n    unsigned CallArgIndex;\n  };\n  // Structure used by DeductionFailureInfo to store information about\n  // unsatisfied constraints.\n  struct CNSInfo {\n    TemplateArgumentList *TemplateArgs;\n    ConstraintSatisfaction Satisfaction;\n  };\n}\n\n/// Convert from Sema's representation of template deduction information\n/// to the form used in overload-candidate information.\nDeductionFailureInfo\nclang::MakeDeductionFailureInfo(ASTContext &Context,\n                                Sema::TemplateDeductionResult TDK,\n                                TemplateDeductionInfo &Info) {\n  DeductionFailureInfo Result;\n  Result.Result = static_cast<unsigned>(TDK);\n  Result.HasDiagnostic = false;\n  switch (TDK) {\n  case Sema::TDK_Invalid:\n  case Sema::TDK_InstantiationDepth:\n  case Sema::TDK_TooManyArguments:\n  case Sema::TDK_TooFewArguments:\n  case Sema::TDK_MiscellaneousDeductionFailure:\n  case Sema::TDK_CUDATargetMismatch:\n    Result.Data = nullptr;\n    break;\n\n  case Sema::TDK_Incomplete:\n  case Sema::TDK_InvalidExplicitArguments:\n    Result.Data = Info.Param.getOpaqueValue();\n    break;\n\n  case Sema::TDK_DeducedMismatch:\n  case Sema::TDK_DeducedMismatchNested: {\n    // FIXME: Should allocate from normal heap so that we can free this later.\n    auto *Saved = new (Context) DFIDeducedMismatchArgs;\n    Saved->FirstArg = Info.FirstArg;\n    Saved->SecondArg = Info.SecondArg;\n    Saved->TemplateArgs = Info.take();\n    Saved->CallArgIndex = Info.CallArgIndex;\n    Result.Data = Saved;\n    break;\n  }\n\n  case Sema::TDK_NonDeducedMismatch: {\n    // FIXME: Should allocate from normal heap so that we can free this later.\n    DFIArguments *Saved = new (Context) DFIArguments;\n    Saved->FirstArg = Info.FirstArg;\n    Saved->SecondArg = Info.SecondArg;\n    Result.Data = Saved;\n    break;\n  }\n\n  case Sema::TDK_IncompletePack:\n    // FIXME: It's slightly wasteful to allocate two TemplateArguments for this.\n  case Sema::TDK_Inconsistent:\n  case Sema::TDK_Underqualified: {\n    // FIXME: Should allocate from normal heap so that we can free this later.\n    DFIParamWithArguments *Saved = new (Context) DFIParamWithArguments;\n    Saved->Param = Info.Param;\n    Saved->FirstArg = Info.FirstArg;\n    Saved->SecondArg = Info.SecondArg;\n    Result.Data = Saved;\n    break;\n  }\n\n  case Sema::TDK_SubstitutionFailure:\n    Result.Data = Info.take();\n    if (Info.hasSFINAEDiagnostic()) {\n      PartialDiagnosticAt *Diag = new (Result.Diagnostic) PartialDiagnosticAt(\n          SourceLocation(), PartialDiagnostic::NullDiagnostic());\n      Info.takeSFINAEDiagnostic(*Diag);\n      Result.HasDiagnostic = true;\n    }\n    break;\n\n  case Sema::TDK_ConstraintsNotSatisfied: {\n    CNSInfo *Saved = new (Context) CNSInfo;\n    Saved->TemplateArgs = Info.take();\n    Saved->Satisfaction = Info.AssociatedConstraintsSatisfaction;\n    Result.Data = Saved;\n    break;\n  }\n\n  case Sema::TDK_Success:\n  case Sema::TDK_NonDependentConversionFailure:\n    llvm_unreachable(\"not a deduction failure\");\n  }\n\n  return Result;\n}\n\nvoid DeductionFailureInfo::Destroy() {\n  switch (static_cast<Sema::TemplateDeductionResult>(Result)) {\n  case Sema::TDK_Success:\n  case Sema::TDK_Invalid:\n  case Sema::TDK_InstantiationDepth:\n  case Sema::TDK_Incomplete:\n  case Sema::TDK_TooManyArguments:\n  case Sema::TDK_TooFewArguments:\n  case Sema::TDK_InvalidExplicitArguments:\n  case Sema::TDK_CUDATargetMismatch:\n  case Sema::TDK_NonDependentConversionFailure:\n    break;\n\n  case Sema::TDK_IncompletePack:\n  case Sema::TDK_Inconsistent:\n  case Sema::TDK_Underqualified:\n  case Sema::TDK_DeducedMismatch:\n  case Sema::TDK_DeducedMismatchNested:\n  case Sema::TDK_NonDeducedMismatch:\n    // FIXME: Destroy the data?\n    Data = nullptr;\n    break;\n\n  case Sema::TDK_SubstitutionFailure:\n    // FIXME: Destroy the template argument list?\n    Data = nullptr;\n    if (PartialDiagnosticAt *Diag = getSFINAEDiagnostic()) {\n      Diag->~PartialDiagnosticAt();\n      HasDiagnostic = false;\n    }\n    break;\n\n  case Sema::TDK_ConstraintsNotSatisfied:\n    // FIXME: Destroy the template argument list?\n    Data = nullptr;\n    if (PartialDiagnosticAt *Diag = getSFINAEDiagnostic()) {\n      Diag->~PartialDiagnosticAt();\n      HasDiagnostic = false;\n    }\n    break;\n\n  // Unhandled\n  case Sema::TDK_MiscellaneousDeductionFailure:\n    break;\n  }\n}\n\nPartialDiagnosticAt *DeductionFailureInfo::getSFINAEDiagnostic() {\n  if (HasDiagnostic)\n    return static_cast<PartialDiagnosticAt*>(static_cast<void*>(Diagnostic));\n  return nullptr;\n}\n\nTemplateParameter DeductionFailureInfo::getTemplateParameter() {\n  switch (static_cast<Sema::TemplateDeductionResult>(Result)) {\n  case Sema::TDK_Success:\n  case Sema::TDK_Invalid:\n  case Sema::TDK_InstantiationDepth:\n  case Sema::TDK_TooManyArguments:\n  case Sema::TDK_TooFewArguments:\n  case Sema::TDK_SubstitutionFailure:\n  case Sema::TDK_DeducedMismatch:\n  case Sema::TDK_DeducedMismatchNested:\n  case Sema::TDK_NonDeducedMismatch:\n  case Sema::TDK_CUDATargetMismatch:\n  case Sema::TDK_NonDependentConversionFailure:\n  case Sema::TDK_ConstraintsNotSatisfied:\n    return TemplateParameter();\n\n  case Sema::TDK_Incomplete:\n  case Sema::TDK_InvalidExplicitArguments:\n    return TemplateParameter::getFromOpaqueValue(Data);\n\n  case Sema::TDK_IncompletePack:\n  case Sema::TDK_Inconsistent:\n  case Sema::TDK_Underqualified:\n    return static_cast<DFIParamWithArguments*>(Data)->Param;\n\n  // Unhandled\n  case Sema::TDK_MiscellaneousDeductionFailure:\n    break;\n  }\n\n  return TemplateParameter();\n}\n\nTemplateArgumentList *DeductionFailureInfo::getTemplateArgumentList() {\n  switch (static_cast<Sema::TemplateDeductionResult>(Result)) {\n  case Sema::TDK_Success:\n  case Sema::TDK_Invalid:\n  case Sema::TDK_InstantiationDepth:\n  case Sema::TDK_TooManyArguments:\n  case Sema::TDK_TooFewArguments:\n  case Sema::TDK_Incomplete:\n  case Sema::TDK_IncompletePack:\n  case Sema::TDK_InvalidExplicitArguments:\n  case Sema::TDK_Inconsistent:\n  case Sema::TDK_Underqualified:\n  case Sema::TDK_NonDeducedMismatch:\n  case Sema::TDK_CUDATargetMismatch:\n  case Sema::TDK_NonDependentConversionFailure:\n    return nullptr;\n\n  case Sema::TDK_DeducedMismatch:\n  case Sema::TDK_DeducedMismatchNested:\n    return static_cast<DFIDeducedMismatchArgs*>(Data)->TemplateArgs;\n\n  case Sema::TDK_SubstitutionFailure:\n    return static_cast<TemplateArgumentList*>(Data);\n\n  case Sema::TDK_ConstraintsNotSatisfied:\n    return static_cast<CNSInfo*>(Data)->TemplateArgs;\n\n  // Unhandled\n  case Sema::TDK_MiscellaneousDeductionFailure:\n    break;\n  }\n\n  return nullptr;\n}\n\nconst TemplateArgument *DeductionFailureInfo::getFirstArg() {\n  switch (static_cast<Sema::TemplateDeductionResult>(Result)) {\n  case Sema::TDK_Success:\n  case Sema::TDK_Invalid:\n  case Sema::TDK_InstantiationDepth:\n  case Sema::TDK_Incomplete:\n  case Sema::TDK_TooManyArguments:\n  case Sema::TDK_TooFewArguments:\n  case Sema::TDK_InvalidExplicitArguments:\n  case Sema::TDK_SubstitutionFailure:\n  case Sema::TDK_CUDATargetMismatch:\n  case Sema::TDK_NonDependentConversionFailure:\n  case Sema::TDK_ConstraintsNotSatisfied:\n    return nullptr;\n\n  case Sema::TDK_IncompletePack:\n  case Sema::TDK_Inconsistent:\n  case Sema::TDK_Underqualified:\n  case Sema::TDK_DeducedMismatch:\n  case Sema::TDK_DeducedMismatchNested:\n  case Sema::TDK_NonDeducedMismatch:\n    return &static_cast<DFIArguments*>(Data)->FirstArg;\n\n  // Unhandled\n  case Sema::TDK_MiscellaneousDeductionFailure:\n    break;\n  }\n\n  return nullptr;\n}\n\nconst TemplateArgument *DeductionFailureInfo::getSecondArg() {\n  switch (static_cast<Sema::TemplateDeductionResult>(Result)) {\n  case Sema::TDK_Success:\n  case Sema::TDK_Invalid:\n  case Sema::TDK_InstantiationDepth:\n  case Sema::TDK_Incomplete:\n  case Sema::TDK_IncompletePack:\n  case Sema::TDK_TooManyArguments:\n  case Sema::TDK_TooFewArguments:\n  case Sema::TDK_InvalidExplicitArguments:\n  case Sema::TDK_SubstitutionFailure:\n  case Sema::TDK_CUDATargetMismatch:\n  case Sema::TDK_NonDependentConversionFailure:\n  case Sema::TDK_ConstraintsNotSatisfied:\n    return nullptr;\n\n  case Sema::TDK_Inconsistent:\n  case Sema::TDK_Underqualified:\n  case Sema::TDK_DeducedMismatch:\n  case Sema::TDK_DeducedMismatchNested:\n  case Sema::TDK_NonDeducedMismatch:\n    return &static_cast<DFIArguments*>(Data)->SecondArg;\n\n  // Unhandled\n  case Sema::TDK_MiscellaneousDeductionFailure:\n    break;\n  }\n\n  return nullptr;\n}\n\nllvm::Optional<unsigned> DeductionFailureInfo::getCallArgIndex() {\n  switch (static_cast<Sema::TemplateDeductionResult>(Result)) {\n  case Sema::TDK_DeducedMismatch:\n  case Sema::TDK_DeducedMismatchNested:\n    return static_cast<DFIDeducedMismatchArgs*>(Data)->CallArgIndex;\n\n  default:\n    return llvm::None;\n  }\n}\n\nbool OverloadCandidateSet::OperatorRewriteInfo::shouldAddReversed(\n    OverloadedOperatorKind Op) {\n  if (!AllowRewrittenCandidates)\n    return false;\n  return Op == OO_EqualEqual || Op == OO_Spaceship;\n}\n\nbool OverloadCandidateSet::OperatorRewriteInfo::shouldAddReversed(\n    ASTContext &Ctx, const FunctionDecl *FD) {\n  if (!shouldAddReversed(FD->getDeclName().getCXXOverloadedOperator()))\n    return false;\n  // Don't bother adding a reversed candidate that can never be a better\n  // match than the non-reversed version.\n  return FD->getNumParams() != 2 ||\n         !Ctx.hasSameUnqualifiedType(FD->getParamDecl(0)->getType(),\n                                     FD->getParamDecl(1)->getType()) ||\n         FD->hasAttr<EnableIfAttr>();\n}\n\nvoid OverloadCandidateSet::destroyCandidates() {\n  for (iterator i = begin(), e = end(); i != e; ++i) {\n    for (auto &C : i->Conversions)\n      C.~ImplicitConversionSequence();\n    if (!i->Viable && i->FailureKind == ovl_fail_bad_deduction)\n      i->DeductionFailure.Destroy();\n  }\n}\n\nvoid OverloadCandidateSet::clear(CandidateSetKind CSK) {\n  destroyCandidates();\n  SlabAllocator.Reset();\n  NumInlineBytesUsed = 0;\n  Candidates.clear();\n  Functions.clear();\n  Kind = CSK;\n}\n\nnamespace {\n  class UnbridgedCastsSet {\n    struct Entry {\n      Expr **Addr;\n      Expr *Saved;\n    };\n    SmallVector<Entry, 2> Entries;\n\n  public:\n    void save(Sema &S, Expr *&E) {\n      assert(E->hasPlaceholderType(BuiltinType::ARCUnbridgedCast));\n      Entry entry = { &E, E };\n      Entries.push_back(entry);\n      E = S.stripARCUnbridgedCast(E);\n    }\n\n    void restore() {\n      for (SmallVectorImpl<Entry>::iterator\n             i = Entries.begin(), e = Entries.end(); i != e; ++i)\n        *i->Addr = i->Saved;\n    }\n  };\n}\n\n/// checkPlaceholderForOverload - Do any interesting placeholder-like\n/// preprocessing on the given expression.\n///\n/// \\param unbridgedCasts a collection to which to add unbridged casts;\n///   without this, they will be immediately diagnosed as errors\n///\n/// Return true on unrecoverable error.\nstatic bool\ncheckPlaceholderForOverload(Sema &S, Expr *&E,\n                            UnbridgedCastsSet *unbridgedCasts = nullptr) {\n  if (const BuiltinType *placeholder =  E->getType()->getAsPlaceholderType()) {\n    // We can't handle overloaded expressions here because overload\n    // resolution might reasonably tweak them.\n    if (placeholder->getKind() == BuiltinType::Overload) return false;\n\n    // If the context potentially accepts unbridged ARC casts, strip\n    // the unbridged cast and add it to the collection for later restoration.\n    if (placeholder->getKind() == BuiltinType::ARCUnbridgedCast &&\n        unbridgedCasts) {\n      unbridgedCasts->save(S, E);\n      return false;\n    }\n\n    // Go ahead and check everything else.\n    ExprResult result = S.CheckPlaceholderExpr(E);\n    if (result.isInvalid())\n      return true;\n\n    E = result.get();\n    return false;\n  }\n\n  // Nothing to do.\n  return false;\n}\n\n/// checkArgPlaceholdersForOverload - Check a set of call operands for\n/// placeholders.\nstatic bool checkArgPlaceholdersForOverload(Sema &S,\n                                            MultiExprArg Args,\n                                            UnbridgedCastsSet &unbridged) {\n  for (unsigned i = 0, e = Args.size(); i != e; ++i)\n    if (checkPlaceholderForOverload(S, Args[i], &unbridged))\n      return true;\n\n  return false;\n}\n\n/// Determine whether the given New declaration is an overload of the\n/// declarations in Old. This routine returns Ovl_Match or Ovl_NonFunction if\n/// New and Old cannot be overloaded, e.g., if New has the same signature as\n/// some function in Old (C++ 1.3.10) or if the Old declarations aren't\n/// functions (or function templates) at all. When it does return Ovl_Match or\n/// Ovl_NonFunction, MatchedDecl will point to the decl that New cannot be\n/// overloaded with. This decl may be a UsingShadowDecl on top of the underlying\n/// declaration.\n///\n/// Example: Given the following input:\n///\n///   void f(int, float); // #1\n///   void f(int, int); // #2\n///   int f(int, int); // #3\n///\n/// When we process #1, there is no previous declaration of \"f\", so IsOverload\n/// will not be used.\n///\n/// When we process #2, Old contains only the FunctionDecl for #1. By comparing\n/// the parameter types, we see that #1 and #2 are overloaded (since they have\n/// different signatures), so this routine returns Ovl_Overload; MatchedDecl is\n/// unchanged.\n///\n/// When we process #3, Old is an overload set containing #1 and #2. We compare\n/// the signatures of #3 to #1 (they're overloaded, so we do nothing) and then\n/// #3 to #2. Since the signatures of #3 and #2 are identical (return types of\n/// functions are not part of the signature), IsOverload returns Ovl_Match and\n/// MatchedDecl will be set to point to the FunctionDecl for #2.\n///\n/// 'NewIsUsingShadowDecl' indicates that 'New' is being introduced into a class\n/// by a using declaration. The rules for whether to hide shadow declarations\n/// ignore some properties which otherwise figure into a function template's\n/// signature.\nSema::OverloadKind\nSema::CheckOverload(Scope *S, FunctionDecl *New, const LookupResult &Old,\n                    NamedDecl *&Match, bool NewIsUsingDecl) {\n  for (LookupResult::iterator I = Old.begin(), E = Old.end();\n         I != E; ++I) {\n    NamedDecl *OldD = *I;\n\n    bool OldIsUsingDecl = false;\n    if (isa<UsingShadowDecl>(OldD)) {\n      OldIsUsingDecl = true;\n\n      // We can always introduce two using declarations into the same\n      // context, even if they have identical signatures.\n      if (NewIsUsingDecl) continue;\n\n      OldD = cast<UsingShadowDecl>(OldD)->getTargetDecl();\n    }\n\n    // A using-declaration does not conflict with another declaration\n    // if one of them is hidden.\n    if ((OldIsUsingDecl || NewIsUsingDecl) && !isVisible(*I))\n      continue;\n\n    // If either declaration was introduced by a using declaration,\n    // we'll need to use slightly different rules for matching.\n    // Essentially, these rules are the normal rules, except that\n    // function templates hide function templates with different\n    // return types or template parameter lists.\n    bool UseMemberUsingDeclRules =\n      (OldIsUsingDecl || NewIsUsingDecl) && CurContext->isRecord() &&\n      !New->getFriendObjectKind();\n\n    if (FunctionDecl *OldF = OldD->getAsFunction()) {\n      if (!IsOverload(New, OldF, UseMemberUsingDeclRules)) {\n        if (UseMemberUsingDeclRules && OldIsUsingDecl) {\n          HideUsingShadowDecl(S, cast<UsingShadowDecl>(*I));\n          continue;\n        }\n\n        if (!isa<FunctionTemplateDecl>(OldD) &&\n            !shouldLinkPossiblyHiddenDecl(*I, New))\n          continue;\n\n        Match = *I;\n        return Ovl_Match;\n      }\n\n      // Builtins that have custom typechecking or have a reference should\n      // not be overloadable or redeclarable.\n      if (!getASTContext().canBuiltinBeRedeclared(OldF)) {\n        Match = *I;\n        return Ovl_NonFunction;\n      }\n    } else if (isa<UsingDecl>(OldD) || isa<UsingPackDecl>(OldD)) {\n      // We can overload with these, which can show up when doing\n      // redeclaration checks for UsingDecls.\n      assert(Old.getLookupKind() == LookupUsingDeclName);\n    } else if (isa<TagDecl>(OldD)) {\n      // We can always overload with tags by hiding them.\n    } else if (auto *UUD = dyn_cast<UnresolvedUsingValueDecl>(OldD)) {\n      // Optimistically assume that an unresolved using decl will\n      // overload; if it doesn't, we'll have to diagnose during\n      // template instantiation.\n      //\n      // Exception: if the scope is dependent and this is not a class\n      // member, the using declaration can only introduce an enumerator.\n      if (UUD->getQualifier()->isDependent() && !UUD->isCXXClassMember()) {\n        Match = *I;\n        return Ovl_NonFunction;\n      }\n    } else {\n      // (C++ 13p1):\n      //   Only function declarations can be overloaded; object and type\n      //   declarations cannot be overloaded.\n      Match = *I;\n      return Ovl_NonFunction;\n    }\n  }\n\n  // C++ [temp.friend]p1:\n  //   For a friend function declaration that is not a template declaration:\n  //    -- if the name of the friend is a qualified or unqualified template-id,\n  //       [...], otherwise\n  //    -- if the name of the friend is a qualified-id and a matching\n  //       non-template function is found in the specified class or namespace,\n  //       the friend declaration refers to that function, otherwise,\n  //    -- if the name of the friend is a qualified-id and a matching function\n  //       template is found in the specified class or namespace, the friend\n  //       declaration refers to the deduced specialization of that function\n  //       template, otherwise\n  //    -- the name shall be an unqualified-id [...]\n  // If we get here for a qualified friend declaration, we've just reached the\n  // third bullet. If the type of the friend is dependent, skip this lookup\n  // until instantiation.\n  if (New->getFriendObjectKind() && New->getQualifier() &&\n      !New->getDescribedFunctionTemplate() &&\n      !New->getDependentSpecializationInfo() &&\n      !New->getType()->isDependentType()) {\n    LookupResult TemplateSpecResult(LookupResult::Temporary, Old);\n    TemplateSpecResult.addAllDecls(Old);\n    if (CheckFunctionTemplateSpecialization(New, nullptr, TemplateSpecResult,\n                                            /*QualifiedFriend*/true)) {\n      New->setInvalidDecl();\n      return Ovl_Overload;\n    }\n\n    Match = TemplateSpecResult.getAsSingle<FunctionDecl>();\n    return Ovl_Match;\n  }\n\n  return Ovl_Overload;\n}\n\nbool Sema::IsOverload(FunctionDecl *New, FunctionDecl *Old,\n                      bool UseMemberUsingDeclRules, bool ConsiderCudaAttrs,\n                      bool ConsiderRequiresClauses) {\n  // C++ [basic.start.main]p2: This function shall not be overloaded.\n  if (New->isMain())\n    return false;\n\n  // MSVCRT user defined entry points cannot be overloaded.\n  if (New->isMSVCRTEntryPoint())\n    return false;\n\n  FunctionTemplateDecl *OldTemplate = Old->getDescribedFunctionTemplate();\n  FunctionTemplateDecl *NewTemplate = New->getDescribedFunctionTemplate();\n\n  // C++ [temp.fct]p2:\n  //   A function template can be overloaded with other function templates\n  //   and with normal (non-template) functions.\n  if ((OldTemplate == nullptr) != (NewTemplate == nullptr))\n    return true;\n\n  // Is the function New an overload of the function Old?\n  QualType OldQType = Context.getCanonicalType(Old->getType());\n  QualType NewQType = Context.getCanonicalType(New->getType());\n\n  // Compare the signatures (C++ 1.3.10) of the two functions to\n  // determine whether they are overloads. If we find any mismatch\n  // in the signature, they are overloads.\n\n  // If either of these functions is a K&R-style function (no\n  // prototype), then we consider them to have matching signatures.\n  if (isa<FunctionNoProtoType>(OldQType.getTypePtr()) ||\n      isa<FunctionNoProtoType>(NewQType.getTypePtr()))\n    return false;\n\n  const FunctionProtoType *OldType = cast<FunctionProtoType>(OldQType);\n  const FunctionProtoType *NewType = cast<FunctionProtoType>(NewQType);\n\n  // The signature of a function includes the types of its\n  // parameters (C++ 1.3.10), which includes the presence or absence\n  // of the ellipsis; see C++ DR 357).\n  if (OldQType != NewQType &&\n      (OldType->getNumParams() != NewType->getNumParams() ||\n       OldType->isVariadic() != NewType->isVariadic() ||\n       !FunctionParamTypesAreEqual(OldType, NewType)))\n    return true;\n\n  // C++ [temp.over.link]p4:\n  //   The signature of a function template consists of its function\n  //   signature, its return type and its template parameter list. The names\n  //   of the template parameters are significant only for establishing the\n  //   relationship between the template parameters and the rest of the\n  //   signature.\n  //\n  // We check the return type and template parameter lists for function\n  // templates first; the remaining checks follow.\n  //\n  // However, we don't consider either of these when deciding whether\n  // a member introduced by a shadow declaration is hidden.\n  if (!UseMemberUsingDeclRules && NewTemplate &&\n      (!TemplateParameterListsAreEqual(NewTemplate->getTemplateParameters(),\n                                       OldTemplate->getTemplateParameters(),\n                                       false, TPL_TemplateMatch) ||\n       !Context.hasSameType(Old->getDeclaredReturnType(),\n                            New->getDeclaredReturnType())))\n    return true;\n\n  // If the function is a class member, its signature includes the\n  // cv-qualifiers (if any) and ref-qualifier (if any) on the function itself.\n  //\n  // As part of this, also check whether one of the member functions\n  // is static, in which case they are not overloads (C++\n  // 13.1p2). While not part of the definition of the signature,\n  // this check is important to determine whether these functions\n  // can be overloaded.\n  CXXMethodDecl *OldMethod = dyn_cast<CXXMethodDecl>(Old);\n  CXXMethodDecl *NewMethod = dyn_cast<CXXMethodDecl>(New);\n  if (OldMethod && NewMethod &&\n      !OldMethod->isStatic() && !NewMethod->isStatic()) {\n    if (OldMethod->getRefQualifier() != NewMethod->getRefQualifier()) {\n      if (!UseMemberUsingDeclRules &&\n          (OldMethod->getRefQualifier() == RQ_None ||\n           NewMethod->getRefQualifier() == RQ_None)) {\n        // C++0x [over.load]p2:\n        //   - Member function declarations with the same name and the same\n        //     parameter-type-list as well as member function template\n        //     declarations with the same name, the same parameter-type-list, and\n        //     the same template parameter lists cannot be overloaded if any of\n        //     them, but not all, have a ref-qualifier (8.3.5).\n        Diag(NewMethod->getLocation(), diag::err_ref_qualifier_overload)\n          << NewMethod->getRefQualifier() << OldMethod->getRefQualifier();\n        Diag(OldMethod->getLocation(), diag::note_previous_declaration);\n      }\n      return true;\n    }\n\n    // We may not have applied the implicit const for a constexpr member\n    // function yet (because we haven't yet resolved whether this is a static\n    // or non-static member function). Add it now, on the assumption that this\n    // is a redeclaration of OldMethod.\n    auto OldQuals = OldMethod->getMethodQualifiers();\n    auto NewQuals = NewMethod->getMethodQualifiers();\n    if (!getLangOpts().CPlusPlus14 && NewMethod->isConstexpr() &&\n        !isa<CXXConstructorDecl>(NewMethod))\n      NewQuals.addConst();\n    // We do not allow overloading based off of '__restrict'.\n    OldQuals.removeRestrict();\n    NewQuals.removeRestrict();\n    if (OldQuals != NewQuals)\n      return true;\n  }\n\n  // Though pass_object_size is placed on parameters and takes an argument, we\n  // consider it to be a function-level modifier for the sake of function\n  // identity. Either the function has one or more parameters with\n  // pass_object_size or it doesn't.\n  if (functionHasPassObjectSizeParams(New) !=\n      functionHasPassObjectSizeParams(Old))\n    return true;\n\n  // enable_if attributes are an order-sensitive part of the signature.\n  for (specific_attr_iterator<EnableIfAttr>\n         NewI = New->specific_attr_begin<EnableIfAttr>(),\n         NewE = New->specific_attr_end<EnableIfAttr>(),\n         OldI = Old->specific_attr_begin<EnableIfAttr>(),\n         OldE = Old->specific_attr_end<EnableIfAttr>();\n       NewI != NewE || OldI != OldE; ++NewI, ++OldI) {\n    if (NewI == NewE || OldI == OldE)\n      return true;\n    llvm::FoldingSetNodeID NewID, OldID;\n    NewI->getCond()->Profile(NewID, Context, true);\n    OldI->getCond()->Profile(OldID, Context, true);\n    if (NewID != OldID)\n      return true;\n  }\n\n  if (getLangOpts().CUDA && ConsiderCudaAttrs) {\n    // Don't allow overloading of destructors.  (In theory we could, but it\n    // would be a giant change to clang.)\n    if (!isa<CXXDestructorDecl>(New)) {\n      CUDAFunctionTarget NewTarget = IdentifyCUDATarget(New),\n                         OldTarget = IdentifyCUDATarget(Old);\n      if (NewTarget != CFT_InvalidTarget) {\n        assert((OldTarget != CFT_InvalidTarget) &&\n               \"Unexpected invalid target.\");\n\n        // Allow overloading of functions with same signature and different CUDA\n        // target attributes.\n        if (NewTarget != OldTarget)\n          return true;\n      }\n    }\n  }\n\n  if (ConsiderRequiresClauses) {\n    Expr *NewRC = New->getTrailingRequiresClause(),\n         *OldRC = Old->getTrailingRequiresClause();\n    if ((NewRC != nullptr) != (OldRC != nullptr))\n      // RC are most certainly different - these are overloads.\n      return true;\n\n    if (NewRC) {\n      llvm::FoldingSetNodeID NewID, OldID;\n      NewRC->Profile(NewID, Context, /*Canonical=*/true);\n      OldRC->Profile(OldID, Context, /*Canonical=*/true);\n      if (NewID != OldID)\n        // RCs are not equivalent - these are overloads.\n        return true;\n    }\n  }\n\n  // The signatures match; this is not an overload.\n  return false;\n}\n\n/// Tries a user-defined conversion from From to ToType.\n///\n/// Produces an implicit conversion sequence for when a standard conversion\n/// is not an option. See TryImplicitConversion for more information.\nstatic ImplicitConversionSequence\nTryUserDefinedConversion(Sema &S, Expr *From, QualType ToType,\n                         bool SuppressUserConversions,\n                         AllowedExplicit AllowExplicit,\n                         bool InOverloadResolution,\n                         bool CStyle,\n                         bool AllowObjCWritebackConversion,\n                         bool AllowObjCConversionOnExplicit) {\n  ImplicitConversionSequence ICS;\n\n  if (SuppressUserConversions) {\n    // We're not in the case above, so there is no conversion that\n    // we can perform.\n    ICS.setBad(BadConversionSequence::no_conversion, From, ToType);\n    return ICS;\n  }\n\n  // Attempt user-defined conversion.\n  OverloadCandidateSet Conversions(From->getExprLoc(),\n                                   OverloadCandidateSet::CSK_Normal);\n  switch (IsUserDefinedConversion(S, From, ToType, ICS.UserDefined,\n                                  Conversions, AllowExplicit,\n                                  AllowObjCConversionOnExplicit)) {\n  case OR_Success:\n  case OR_Deleted:\n    ICS.setUserDefined();\n    // C++ [over.ics.user]p4:\n    //   A conversion of an expression of class type to the same class\n    //   type is given Exact Match rank, and a conversion of an\n    //   expression of class type to a base class of that type is\n    //   given Conversion rank, in spite of the fact that a copy\n    //   constructor (i.e., a user-defined conversion function) is\n    //   called for those cases.\n    if (CXXConstructorDecl *Constructor\n          = dyn_cast<CXXConstructorDecl>(ICS.UserDefined.ConversionFunction)) {\n      QualType FromCanon\n        = S.Context.getCanonicalType(From->getType().getUnqualifiedType());\n      QualType ToCanon\n        = S.Context.getCanonicalType(ToType).getUnqualifiedType();\n      if (Constructor->isCopyConstructor() &&\n          (FromCanon == ToCanon ||\n           S.IsDerivedFrom(From->getBeginLoc(), FromCanon, ToCanon))) {\n        // Turn this into a \"standard\" conversion sequence, so that it\n        // gets ranked with standard conversion sequences.\n        DeclAccessPair Found = ICS.UserDefined.FoundConversionFunction;\n        ICS.setStandard();\n        ICS.Standard.setAsIdentityConversion();\n        ICS.Standard.setFromType(From->getType());\n        ICS.Standard.setAllToTypes(ToType);\n        ICS.Standard.CopyConstructor = Constructor;\n        ICS.Standard.FoundCopyConstructor = Found;\n        if (ToCanon != FromCanon)\n          ICS.Standard.Second = ICK_Derived_To_Base;\n      }\n    }\n    break;\n\n  case OR_Ambiguous:\n    ICS.setAmbiguous();\n    ICS.Ambiguous.setFromType(From->getType());\n    ICS.Ambiguous.setToType(ToType);\n    for (OverloadCandidateSet::iterator Cand = Conversions.begin();\n         Cand != Conversions.end(); ++Cand)\n      if (Cand->Best)\n        ICS.Ambiguous.addConversion(Cand->FoundDecl, Cand->Function);\n    break;\n\n    // Fall through.\n  case OR_No_Viable_Function:\n    ICS.setBad(BadConversionSequence::no_conversion, From, ToType);\n    break;\n  }\n\n  return ICS;\n}\n\n/// TryImplicitConversion - Attempt to perform an implicit conversion\n/// from the given expression (Expr) to the given type (ToType). This\n/// function returns an implicit conversion sequence that can be used\n/// to perform the initialization. Given\n///\n///   void f(float f);\n///   void g(int i) { f(i); }\n///\n/// this routine would produce an implicit conversion sequence to\n/// describe the initialization of f from i, which will be a standard\n/// conversion sequence containing an lvalue-to-rvalue conversion (C++\n/// 4.1) followed by a floating-integral conversion (C++ 4.9).\n//\n/// Note that this routine only determines how the conversion can be\n/// performed; it does not actually perform the conversion. As such,\n/// it will not produce any diagnostics if no conversion is available,\n/// but will instead return an implicit conversion sequence of kind\n/// \"BadConversion\".\n///\n/// If @p SuppressUserConversions, then user-defined conversions are\n/// not permitted.\n/// If @p AllowExplicit, then explicit user-defined conversions are\n/// permitted.\n///\n/// \\param AllowObjCWritebackConversion Whether we allow the Objective-C\n/// writeback conversion, which allows __autoreleasing id* parameters to\n/// be initialized with __strong id* or __weak id* arguments.\nstatic ImplicitConversionSequence\nTryImplicitConversion(Sema &S, Expr *From, QualType ToType,\n                      bool SuppressUserConversions,\n                      AllowedExplicit AllowExplicit,\n                      bool InOverloadResolution,\n                      bool CStyle,\n                      bool AllowObjCWritebackConversion,\n                      bool AllowObjCConversionOnExplicit) {\n  ImplicitConversionSequence ICS;\n  if (IsStandardConversion(S, From, ToType, InOverloadResolution,\n                           ICS.Standard, CStyle, AllowObjCWritebackConversion)){\n    ICS.setStandard();\n    return ICS;\n  }\n\n  if (!S.getLangOpts().CPlusPlus) {\n    ICS.setBad(BadConversionSequence::no_conversion, From, ToType);\n    return ICS;\n  }\n\n  // C++ [over.ics.user]p4:\n  //   A conversion of an expression of class type to the same class\n  //   type is given Exact Match rank, and a conversion of an\n  //   expression of class type to a base class of that type is\n  //   given Conversion rank, in spite of the fact that a copy/move\n  //   constructor (i.e., a user-defined conversion function) is\n  //   called for those cases.\n  QualType FromType = From->getType();\n  if (ToType->getAs<RecordType>() && FromType->getAs<RecordType>() &&\n      (S.Context.hasSameUnqualifiedType(FromType, ToType) ||\n       S.IsDerivedFrom(From->getBeginLoc(), FromType, ToType))) {\n    ICS.setStandard();\n    ICS.Standard.setAsIdentityConversion();\n    ICS.Standard.setFromType(FromType);\n    ICS.Standard.setAllToTypes(ToType);\n\n    // We don't actually check at this point whether there is a valid\n    // copy/move constructor, since overloading just assumes that it\n    // exists. When we actually perform initialization, we'll find the\n    // appropriate constructor to copy the returned object, if needed.\n    ICS.Standard.CopyConstructor = nullptr;\n\n    // Determine whether this is considered a derived-to-base conversion.\n    if (!S.Context.hasSameUnqualifiedType(FromType, ToType))\n      ICS.Standard.Second = ICK_Derived_To_Base;\n\n    return ICS;\n  }\n\n  return TryUserDefinedConversion(S, From, ToType, SuppressUserConversions,\n                                  AllowExplicit, InOverloadResolution, CStyle,\n                                  AllowObjCWritebackConversion,\n                                  AllowObjCConversionOnExplicit);\n}\n\nImplicitConversionSequence\nSema::TryImplicitConversion(Expr *From, QualType ToType,\n                            bool SuppressUserConversions,\n                            AllowedExplicit AllowExplicit,\n                            bool InOverloadResolution,\n                            bool CStyle,\n                            bool AllowObjCWritebackConversion) {\n  return ::TryImplicitConversion(*this, From, ToType, SuppressUserConversions,\n                                 AllowExplicit, InOverloadResolution, CStyle,\n                                 AllowObjCWritebackConversion,\n                                 /*AllowObjCConversionOnExplicit=*/false);\n}\n\n/// PerformImplicitConversion - Perform an implicit conversion of the\n/// expression From to the type ToType. Returns the\n/// converted expression. Flavor is the kind of conversion we're\n/// performing, used in the error message. If @p AllowExplicit,\n/// explicit user-defined conversions are permitted.\nExprResult Sema::PerformImplicitConversion(Expr *From, QualType ToType,\n                                           AssignmentAction Action,\n                                           bool AllowExplicit) {\n  if (checkPlaceholderForOverload(*this, From))\n    return ExprError();\n\n  // Objective-C ARC: Determine whether we will allow the writeback conversion.\n  bool AllowObjCWritebackConversion\n    = getLangOpts().ObjCAutoRefCount &&\n      (Action == AA_Passing || Action == AA_Sending);\n  if (getLangOpts().ObjC)\n    CheckObjCBridgeRelatedConversions(From->getBeginLoc(), ToType,\n                                      From->getType(), From);\n  ImplicitConversionSequence ICS = ::TryImplicitConversion(\n      *this, From, ToType,\n      /*SuppressUserConversions=*/false,\n      AllowExplicit ? AllowedExplicit::All : AllowedExplicit::None,\n      /*InOverloadResolution=*/false,\n      /*CStyle=*/false, AllowObjCWritebackConversion,\n      /*AllowObjCConversionOnExplicit=*/false);\n  return PerformImplicitConversion(From, ToType, ICS, Action);\n}\n\n/// Determine whether the conversion from FromType to ToType is a valid\n/// conversion that strips \"noexcept\" or \"noreturn\" off the nested function\n/// type.\nbool Sema::IsFunctionConversion(QualType FromType, QualType ToType,\n                                QualType &ResultTy) {\n  if (Context.hasSameUnqualifiedType(FromType, ToType))\n    return false;\n\n  // Permit the conversion F(t __attribute__((noreturn))) -> F(t)\n  //                    or F(t noexcept) -> F(t)\n  // where F adds one of the following at most once:\n  //   - a pointer\n  //   - a member pointer\n  //   - a block pointer\n  // Changes here need matching changes in FindCompositePointerType.\n  CanQualType CanTo = Context.getCanonicalType(ToType);\n  CanQualType CanFrom = Context.getCanonicalType(FromType);\n  Type::TypeClass TyClass = CanTo->getTypeClass();\n  if (TyClass != CanFrom->getTypeClass()) return false;\n  if (TyClass != Type::FunctionProto && TyClass != Type::FunctionNoProto) {\n    if (TyClass == Type::Pointer) {\n      CanTo = CanTo.castAs<PointerType>()->getPointeeType();\n      CanFrom = CanFrom.castAs<PointerType>()->getPointeeType();\n    } else if (TyClass == Type::BlockPointer) {\n      CanTo = CanTo.castAs<BlockPointerType>()->getPointeeType();\n      CanFrom = CanFrom.castAs<BlockPointerType>()->getPointeeType();\n    } else if (TyClass == Type::MemberPointer) {\n      auto ToMPT = CanTo.castAs<MemberPointerType>();\n      auto FromMPT = CanFrom.castAs<MemberPointerType>();\n      // A function pointer conversion cannot change the class of the function.\n      if (ToMPT->getClass() != FromMPT->getClass())\n        return false;\n      CanTo = ToMPT->getPointeeType();\n      CanFrom = FromMPT->getPointeeType();\n    } else {\n      return false;\n    }\n\n    TyClass = CanTo->getTypeClass();\n    if (TyClass != CanFrom->getTypeClass()) return false;\n    if (TyClass != Type::FunctionProto && TyClass != Type::FunctionNoProto)\n      return false;\n  }\n\n  const auto *FromFn = cast<FunctionType>(CanFrom);\n  FunctionType::ExtInfo FromEInfo = FromFn->getExtInfo();\n\n  const auto *ToFn = cast<FunctionType>(CanTo);\n  FunctionType::ExtInfo ToEInfo = ToFn->getExtInfo();\n\n  bool Changed = false;\n\n  // Drop 'noreturn' if not present in target type.\n  if (FromEInfo.getNoReturn() && !ToEInfo.getNoReturn()) {\n    FromFn = Context.adjustFunctionType(FromFn, FromEInfo.withNoReturn(false));\n    Changed = true;\n  }\n\n  // Drop 'noexcept' if not present in target type.\n  if (const auto *FromFPT = dyn_cast<FunctionProtoType>(FromFn)) {\n    const auto *ToFPT = cast<FunctionProtoType>(ToFn);\n    if (FromFPT->isNothrow() && !ToFPT->isNothrow()) {\n      FromFn = cast<FunctionType>(\n          Context.getFunctionTypeWithExceptionSpec(QualType(FromFPT, 0),\n                                                   EST_None)\n                 .getTypePtr());\n      Changed = true;\n    }\n\n    // Convert FromFPT's ExtParameterInfo if necessary. The conversion is valid\n    // only if the ExtParameterInfo lists of the two function prototypes can be\n    // merged and the merged list is identical to ToFPT's ExtParameterInfo list.\n    SmallVector<FunctionProtoType::ExtParameterInfo, 4> NewParamInfos;\n    bool CanUseToFPT, CanUseFromFPT;\n    if (Context.mergeExtParameterInfo(ToFPT, FromFPT, CanUseToFPT,\n                                      CanUseFromFPT, NewParamInfos) &&\n        CanUseToFPT && !CanUseFromFPT) {\n      FunctionProtoType::ExtProtoInfo ExtInfo = FromFPT->getExtProtoInfo();\n      ExtInfo.ExtParameterInfos =\n          NewParamInfos.empty() ? nullptr : NewParamInfos.data();\n      QualType QT = Context.getFunctionType(FromFPT->getReturnType(),\n                                            FromFPT->getParamTypes(), ExtInfo);\n      FromFn = QT->getAs<FunctionType>();\n      Changed = true;\n    }\n  }\n\n  if (!Changed)\n    return false;\n\n  assert(QualType(FromFn, 0).isCanonical());\n  if (QualType(FromFn, 0) != CanTo) return false;\n\n  ResultTy = ToType;\n  return true;\n}\n\n/// Determine whether the conversion from FromType to ToType is a valid\n/// vector conversion.\n///\n/// \\param ICK Will be set to the vector conversion kind, if this is a vector\n/// conversion.\nstatic bool IsVectorConversion(Sema &S, QualType FromType,\n                               QualType ToType, ImplicitConversionKind &ICK) {\n  // We need at least one of these types to be a vector type to have a vector\n  // conversion.\n  if (!ToType->isVectorType() && !FromType->isVectorType())\n    return false;\n\n  // Identical types require no conversions.\n  if (S.Context.hasSameUnqualifiedType(FromType, ToType))\n    return false;\n\n  // There are no conversions between extended vector types, only identity.\n  if (ToType->isExtVectorType()) {\n    // There are no conversions between extended vector types other than the\n    // identity conversion.\n    if (FromType->isExtVectorType())\n      return false;\n\n    // Vector splat from any arithmetic type to a vector.\n    if (FromType->isArithmeticType()) {\n      ICK = ICK_Vector_Splat;\n      return true;\n    }\n  }\n\n  if (ToType->isSizelessBuiltinType() || FromType->isSizelessBuiltinType())\n    if (S.Context.areCompatibleSveTypes(FromType, ToType) ||\n        S.Context.areLaxCompatibleSveTypes(FromType, ToType)) {\n      ICK = ICK_SVE_Vector_Conversion;\n      return true;\n    }\n\n  // We can perform the conversion between vector types in the following cases:\n  // 1)vector types are equivalent AltiVec and GCC vector types\n  // 2)lax vector conversions are permitted and the vector types are of the\n  //   same size\n  // 3)the destination type does not have the ARM MVE strict-polymorphism\n  //   attribute, which inhibits lax vector conversion for overload resolution\n  //   only\n  if (ToType->isVectorType() && FromType->isVectorType()) {\n    if (S.Context.areCompatibleVectorTypes(FromType, ToType) ||\n        (S.isLaxVectorConversion(FromType, ToType) &&\n         !ToType->hasAttr(attr::ArmMveStrictPolymorphism))) {\n      ICK = ICK_Vector_Conversion;\n      return true;\n    }\n  }\n\n  return false;\n}\n\nstatic bool tryAtomicConversion(Sema &S, Expr *From, QualType ToType,\n                                bool InOverloadResolution,\n                                StandardConversionSequence &SCS,\n                                bool CStyle);\n\n/// IsStandardConversion - Determines whether there is a standard\n/// conversion sequence (C++ [conv], C++ [over.ics.scs]) from the\n/// expression From to the type ToType. Standard conversion sequences\n/// only consider non-class types; for conversions that involve class\n/// types, use TryImplicitConversion. If a conversion exists, SCS will\n/// contain the standard conversion sequence required to perform this\n/// conversion and this routine will return true. Otherwise, this\n/// routine will return false and the value of SCS is unspecified.\nstatic bool IsStandardConversion(Sema &S, Expr* From, QualType ToType,\n                                 bool InOverloadResolution,\n                                 StandardConversionSequence &SCS,\n                                 bool CStyle,\n                                 bool AllowObjCWritebackConversion) {\n  QualType FromType = From->getType();\n\n  // Standard conversions (C++ [conv])\n  SCS.setAsIdentityConversion();\n  SCS.IncompatibleObjC = false;\n  SCS.setFromType(FromType);\n  SCS.CopyConstructor = nullptr;\n\n  // There are no standard conversions for class types in C++, so\n  // abort early. When overloading in C, however, we do permit them.\n  if (S.getLangOpts().CPlusPlus &&\n      (FromType->isRecordType() || ToType->isRecordType()))\n    return false;\n\n  // The first conversion can be an lvalue-to-rvalue conversion,\n  // array-to-pointer conversion, or function-to-pointer conversion\n  // (C++ 4p1).\n\n  if (FromType == S.Context.OverloadTy) {\n    DeclAccessPair AccessPair;\n    if (FunctionDecl *Fn\n          = S.ResolveAddressOfOverloadedFunction(From, ToType, false,\n                                                 AccessPair)) {\n      // We were able to resolve the address of the overloaded function,\n      // so we can convert to the type of that function.\n      FromType = Fn->getType();\n      SCS.setFromType(FromType);\n\n      // we can sometimes resolve &foo<int> regardless of ToType, so check\n      // if the type matches (identity) or we are converting to bool\n      if (!S.Context.hasSameUnqualifiedType(\n                      S.ExtractUnqualifiedFunctionType(ToType), FromType)) {\n        QualType resultTy;\n        // if the function type matches except for [[noreturn]], it's ok\n        if (!S.IsFunctionConversion(FromType,\n              S.ExtractUnqualifiedFunctionType(ToType), resultTy))\n          // otherwise, only a boolean conversion is standard\n          if (!ToType->isBooleanType())\n            return false;\n      }\n\n      // Check if the \"from\" expression is taking the address of an overloaded\n      // function and recompute the FromType accordingly. Take advantage of the\n      // fact that non-static member functions *must* have such an address-of\n      // expression.\n      CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(Fn);\n      if (Method && !Method->isStatic()) {\n        assert(isa<UnaryOperator>(From->IgnoreParens()) &&\n               \"Non-unary operator on non-static member address\");\n        assert(cast<UnaryOperator>(From->IgnoreParens())->getOpcode()\n               == UO_AddrOf &&\n               \"Non-address-of operator on non-static member address\");\n        const Type *ClassType\n          = S.Context.getTypeDeclType(Method->getParent()).getTypePtr();\n        FromType = S.Context.getMemberPointerType(FromType, ClassType);\n      } else if (isa<UnaryOperator>(From->IgnoreParens())) {\n        assert(cast<UnaryOperator>(From->IgnoreParens())->getOpcode() ==\n               UO_AddrOf &&\n               \"Non-address-of operator for overloaded function expression\");\n        FromType = S.Context.getPointerType(FromType);\n      }\n\n      // Check that we've computed the proper type after overload resolution.\n      // FIXME: FixOverloadedFunctionReference has side-effects; we shouldn't\n      // be calling it from within an NDEBUG block.\n      assert(S.Context.hasSameType(\n        FromType,\n        S.FixOverloadedFunctionReference(From, AccessPair, Fn)->getType()));\n    } else {\n      return false;\n    }\n  }\n  // Lvalue-to-rvalue conversion (C++11 4.1):\n  //   A glvalue (3.10) of a non-function, non-array type T can\n  //   be converted to a prvalue.\n  bool argIsLValue = From->isGLValue();\n  if (argIsLValue &&\n      !FromType->isFunctionType() && !FromType->isArrayType() &&\n      S.Context.getCanonicalType(FromType) != S.Context.OverloadTy) {\n    SCS.First = ICK_Lvalue_To_Rvalue;\n\n    // C11 6.3.2.1p2:\n    //   ... if the lvalue has atomic type, the value has the non-atomic version\n    //   of the type of the lvalue ...\n    if (const AtomicType *Atomic = FromType->getAs<AtomicType>())\n      FromType = Atomic->getValueType();\n\n    // If T is a non-class type, the type of the rvalue is the\n    // cv-unqualified version of T. Otherwise, the type of the rvalue\n    // is T (C++ 4.1p1). C++ can't get here with class types; in C, we\n    // just strip the qualifiers because they don't matter.\n    FromType = FromType.getUnqualifiedType();\n  } else if (FromType->isArrayType()) {\n    // Array-to-pointer conversion (C++ 4.2)\n    SCS.First = ICK_Array_To_Pointer;\n\n    // An lvalue or rvalue of type \"array of N T\" or \"array of unknown\n    // bound of T\" can be converted to an rvalue of type \"pointer to\n    // T\" (C++ 4.2p1).\n    FromType = S.Context.getArrayDecayedType(FromType);\n\n    if (S.IsStringLiteralToNonConstPointerConversion(From, ToType)) {\n      // This conversion is deprecated in C++03 (D.4)\n      SCS.DeprecatedStringLiteralToCharPtr = true;\n\n      // For the purpose of ranking in overload resolution\n      // (13.3.3.1.1), this conversion is considered an\n      // array-to-pointer conversion followed by a qualification\n      // conversion (4.4). (C++ 4.2p2)\n      SCS.Second = ICK_Identity;\n      SCS.Third = ICK_Qualification;\n      SCS.QualificationIncludesObjCLifetime = false;\n      SCS.setAllToTypes(FromType);\n      return true;\n    }\n  } else if (FromType->isFunctionType() && argIsLValue) {\n    // Function-to-pointer conversion (C++ 4.3).\n    SCS.First = ICK_Function_To_Pointer;\n\n    if (auto *DRE = dyn_cast<DeclRefExpr>(From->IgnoreParenCasts()))\n      if (auto *FD = dyn_cast<FunctionDecl>(DRE->getDecl()))\n        if (!S.checkAddressOfFunctionIsAvailable(FD))\n          return false;\n\n    // An lvalue of function type T can be converted to an rvalue of\n    // type \"pointer to T.\" The result is a pointer to the\n    // function. (C++ 4.3p1).\n    FromType = S.Context.getPointerType(FromType);\n  } else {\n    // We don't require any conversions for the first step.\n    SCS.First = ICK_Identity;\n  }\n  SCS.setToType(0, FromType);\n\n  // The second conversion can be an integral promotion, floating\n  // point promotion, integral conversion, floating point conversion,\n  // floating-integral conversion, pointer conversion,\n  // pointer-to-member conversion, or boolean conversion (C++ 4p1).\n  // For overloading in C, this can also be a \"compatible-type\"\n  // conversion.\n  bool IncompatibleObjC = false;\n  ImplicitConversionKind SecondICK = ICK_Identity;\n  if (S.Context.hasSameUnqualifiedType(FromType, ToType)) {\n    // The unqualified versions of the types are the same: there's no\n    // conversion to do.\n    SCS.Second = ICK_Identity;\n  } else if (S.IsIntegralPromotion(From, FromType, ToType)) {\n    // Integral promotion (C++ 4.5).\n    SCS.Second = ICK_Integral_Promotion;\n    FromType = ToType.getUnqualifiedType();\n  } else if (S.IsFloatingPointPromotion(FromType, ToType)) {\n    // Floating point promotion (C++ 4.6).\n    SCS.Second = ICK_Floating_Promotion;\n    FromType = ToType.getUnqualifiedType();\n  } else if (S.IsComplexPromotion(FromType, ToType)) {\n    // Complex promotion (Clang extension)\n    SCS.Second = ICK_Complex_Promotion;\n    FromType = ToType.getUnqualifiedType();\n  } else if (ToType->isBooleanType() &&\n             (FromType->isArithmeticType() ||\n              FromType->isAnyPointerType() ||\n              FromType->isBlockPointerType() ||\n              FromType->isMemberPointerType())) {\n    // Boolean conversions (C++ 4.12).\n    SCS.Second = ICK_Boolean_Conversion;\n    FromType = S.Context.BoolTy;\n  } else if (FromType->isIntegralOrUnscopedEnumerationType() &&\n             ToType->isIntegralType(S.Context)) {\n    // Integral conversions (C++ 4.7).\n    SCS.Second = ICK_Integral_Conversion;\n    FromType = ToType.getUnqualifiedType();\n  } else if (FromType->isAnyComplexType() && ToType->isAnyComplexType()) {\n    // Complex conversions (C99 6.3.1.6)\n    SCS.Second = ICK_Complex_Conversion;\n    FromType = ToType.getUnqualifiedType();\n  } else if ((FromType->isAnyComplexType() && ToType->isArithmeticType()) ||\n             (ToType->isAnyComplexType() && FromType->isArithmeticType())) {\n    // Complex-real conversions (C99 6.3.1.7)\n    SCS.Second = ICK_Complex_Real;\n    FromType = ToType.getUnqualifiedType();\n  } else if (FromType->isRealFloatingType() && ToType->isRealFloatingType()) {\n    // FIXME: disable conversions between long double and __float128 if\n    // their representation is different until there is back end support\n    // We of course allow this conversion if long double is really double.\n\n    // Conversions between bfloat and other floats are not permitted.\n    if (FromType == S.Context.BFloat16Ty || ToType == S.Context.BFloat16Ty)\n      return false;\n    if (&S.Context.getFloatTypeSemantics(FromType) !=\n        &S.Context.getFloatTypeSemantics(ToType)) {\n      bool Float128AndLongDouble = ((FromType == S.Context.Float128Ty &&\n                                    ToType == S.Context.LongDoubleTy) ||\n                                   (FromType == S.Context.LongDoubleTy &&\n                                    ToType == S.Context.Float128Ty));\n      if (Float128AndLongDouble &&\n          (&S.Context.getFloatTypeSemantics(S.Context.LongDoubleTy) ==\n           &llvm::APFloat::PPCDoubleDouble()))\n        return false;\n    }\n    // Floating point conversions (C++ 4.8).\n    SCS.Second = ICK_Floating_Conversion;\n    FromType = ToType.getUnqualifiedType();\n  } else if ((FromType->isRealFloatingType() &&\n              ToType->isIntegralType(S.Context)) ||\n             (FromType->isIntegralOrUnscopedEnumerationType() &&\n              ToType->isRealFloatingType())) {\n    // Conversions between bfloat and int are not permitted.\n    if (FromType->isBFloat16Type() || ToType->isBFloat16Type())\n      return false;\n\n    // Floating-integral conversions (C++ 4.9).\n    SCS.Second = ICK_Floating_Integral;\n    FromType = ToType.getUnqualifiedType();\n  } else if (S.IsBlockPointerConversion(FromType, ToType, FromType)) {\n    SCS.Second = ICK_Block_Pointer_Conversion;\n  } else if (AllowObjCWritebackConversion &&\n             S.isObjCWritebackConversion(FromType, ToType, FromType)) {\n    SCS.Second = ICK_Writeback_Conversion;\n  } else if (S.IsPointerConversion(From, FromType, ToType, InOverloadResolution,\n                                   FromType, IncompatibleObjC)) {\n    // Pointer conversions (C++ 4.10).\n    SCS.Second = ICK_Pointer_Conversion;\n    SCS.IncompatibleObjC = IncompatibleObjC;\n    FromType = FromType.getUnqualifiedType();\n  } else if (S.IsMemberPointerConversion(From, FromType, ToType,\n                                         InOverloadResolution, FromType)) {\n    // Pointer to member conversions (4.11).\n    SCS.Second = ICK_Pointer_Member;\n  } else if (IsVectorConversion(S, FromType, ToType, SecondICK)) {\n    SCS.Second = SecondICK;\n    FromType = ToType.getUnqualifiedType();\n  } else if (!S.getLangOpts().CPlusPlus &&\n             S.Context.typesAreCompatible(ToType, FromType)) {\n    // Compatible conversions (Clang extension for C function overloading)\n    SCS.Second = ICK_Compatible_Conversion;\n    FromType = ToType.getUnqualifiedType();\n  } else if (IsTransparentUnionStandardConversion(S, From, ToType,\n                                             InOverloadResolution,\n                                             SCS, CStyle)) {\n    SCS.Second = ICK_TransparentUnionConversion;\n    FromType = ToType;\n  } else if (tryAtomicConversion(S, From, ToType, InOverloadResolution, SCS,\n                                 CStyle)) {\n    // tryAtomicConversion has updated the standard conversion sequence\n    // appropriately.\n    return true;\n  } else if (ToType->isEventT() &&\n             From->isIntegerConstantExpr(S.getASTContext()) &&\n             From->EvaluateKnownConstInt(S.getASTContext()) == 0) {\n    SCS.Second = ICK_Zero_Event_Conversion;\n    FromType = ToType;\n  } else if (ToType->isQueueT() &&\n             From->isIntegerConstantExpr(S.getASTContext()) &&\n             (From->EvaluateKnownConstInt(S.getASTContext()) == 0)) {\n    SCS.Second = ICK_Zero_Queue_Conversion;\n    FromType = ToType;\n  } else if (ToType->isSamplerT() &&\n             From->isIntegerConstantExpr(S.getASTContext())) {\n    SCS.Second = ICK_Compatible_Conversion;\n    FromType = ToType;\n  } else {\n    // No second conversion required.\n    SCS.Second = ICK_Identity;\n  }\n  SCS.setToType(1, FromType);\n\n  // The third conversion can be a function pointer conversion or a\n  // qualification conversion (C++ [conv.fctptr], [conv.qual]).\n  bool ObjCLifetimeConversion;\n  if (S.IsFunctionConversion(FromType, ToType, FromType)) {\n    // Function pointer conversions (removing 'noexcept') including removal of\n    // 'noreturn' (Clang extension).\n    SCS.Third = ICK_Function_Conversion;\n  } else if (S.IsQualificationConversion(FromType, ToType, CStyle,\n                                         ObjCLifetimeConversion)) {\n    SCS.Third = ICK_Qualification;\n    SCS.QualificationIncludesObjCLifetime = ObjCLifetimeConversion;\n    FromType = ToType;\n  } else {\n    // No conversion required\n    SCS.Third = ICK_Identity;\n  }\n\n  // C++ [over.best.ics]p6:\n  //   [...] Any difference in top-level cv-qualification is\n  //   subsumed by the initialization itself and does not constitute\n  //   a conversion. [...]\n  QualType CanonFrom = S.Context.getCanonicalType(FromType);\n  QualType CanonTo = S.Context.getCanonicalType(ToType);\n  if (CanonFrom.getLocalUnqualifiedType()\n                                     == CanonTo.getLocalUnqualifiedType() &&\n      CanonFrom.getLocalQualifiers() != CanonTo.getLocalQualifiers()) {\n    FromType = ToType;\n    CanonFrom = CanonTo;\n  }\n\n  SCS.setToType(2, FromType);\n\n  if (CanonFrom == CanonTo)\n    return true;\n\n  // If we have not converted the argument type to the parameter type,\n  // this is a bad conversion sequence, unless we're resolving an overload in C.\n  if (S.getLangOpts().CPlusPlus || !InOverloadResolution)\n    return false;\n\n  ExprResult ER = ExprResult{From};\n  Sema::AssignConvertType Conv =\n      S.CheckSingleAssignmentConstraints(ToType, ER,\n                                         /*Diagnose=*/false,\n                                         /*DiagnoseCFAudited=*/false,\n                                         /*ConvertRHS=*/false);\n  ImplicitConversionKind SecondConv;\n  switch (Conv) {\n  case Sema::Compatible:\n    SecondConv = ICK_C_Only_Conversion;\n    break;\n  // For our purposes, discarding qualifiers is just as bad as using an\n  // incompatible pointer. Note that an IncompatiblePointer conversion can drop\n  // qualifiers, as well.\n  case Sema::CompatiblePointerDiscardsQualifiers:\n  case Sema::IncompatiblePointer:\n  case Sema::IncompatiblePointerSign:\n    SecondConv = ICK_Incompatible_Pointer_Conversion;\n    break;\n  default:\n    return false;\n  }\n\n  // First can only be an lvalue conversion, so we pretend that this was the\n  // second conversion. First should already be valid from earlier in the\n  // function.\n  SCS.Second = SecondConv;\n  SCS.setToType(1, ToType);\n\n  // Third is Identity, because Second should rank us worse than any other\n  // conversion. This could also be ICK_Qualification, but it's simpler to just\n  // lump everything in with the second conversion, and we don't gain anything\n  // from making this ICK_Qualification.\n  SCS.Third = ICK_Identity;\n  SCS.setToType(2, ToType);\n  return true;\n}\n\nstatic bool\nIsTransparentUnionStandardConversion(Sema &S, Expr* From,\n                                     QualType &ToType,\n                                     bool InOverloadResolution,\n                                     StandardConversionSequence &SCS,\n                                     bool CStyle) {\n\n  const RecordType *UT = ToType->getAsUnionType();\n  if (!UT || !UT->getDecl()->hasAttr<TransparentUnionAttr>())\n    return false;\n  // The field to initialize within the transparent union.\n  RecordDecl *UD = UT->getDecl();\n  // It's compatible if the expression matches any of the fields.\n  for (const auto *it : UD->fields()) {\n    if (IsStandardConversion(S, From, it->getType(), InOverloadResolution, SCS,\n                             CStyle, /*AllowObjCWritebackConversion=*/false)) {\n      ToType = it->getType();\n      return true;\n    }\n  }\n  return false;\n}\n\n/// IsIntegralPromotion - Determines whether the conversion from the\n/// expression From (whose potentially-adjusted type is FromType) to\n/// ToType is an integral promotion (C++ 4.5). If so, returns true and\n/// sets PromotedType to the promoted type.\nbool Sema::IsIntegralPromotion(Expr *From, QualType FromType, QualType ToType) {\n  const BuiltinType *To = ToType->getAs<BuiltinType>();\n  // All integers are built-in.\n  if (!To) {\n    return false;\n  }\n\n  // An rvalue of type char, signed char, unsigned char, short int, or\n  // unsigned short int can be converted to an rvalue of type int if\n  // int can represent all the values of the source type; otherwise,\n  // the source rvalue can be converted to an rvalue of type unsigned\n  // int (C++ 4.5p1).\n  if (FromType->isPromotableIntegerType() && !FromType->isBooleanType() &&\n      !FromType->isEnumeralType()) {\n    if (// We can promote any signed, promotable integer type to an int\n        (FromType->isSignedIntegerType() ||\n         // We can promote any unsigned integer type whose size is\n         // less than int to an int.\n         Context.getTypeSize(FromType) < Context.getTypeSize(ToType))) {\n      return To->getKind() == BuiltinType::Int;\n    }\n\n    return To->getKind() == BuiltinType::UInt;\n  }\n\n  // C++11 [conv.prom]p3:\n  //   A prvalue of an unscoped enumeration type whose underlying type is not\n  //   fixed (7.2) can be converted to an rvalue a prvalue of the first of the\n  //   following types that can represent all the values of the enumeration\n  //   (i.e., the values in the range bmin to bmax as described in 7.2): int,\n  //   unsigned int, long int, unsigned long int, long long int, or unsigned\n  //   long long int. If none of the types in that list can represent all the\n  //   values of the enumeration, an rvalue a prvalue of an unscoped enumeration\n  //   type can be converted to an rvalue a prvalue of the extended integer type\n  //   with lowest integer conversion rank (4.13) greater than the rank of long\n  //   long in which all the values of the enumeration can be represented. If\n  //   there are two such extended types, the signed one is chosen.\n  // C++11 [conv.prom]p4:\n  //   A prvalue of an unscoped enumeration type whose underlying type is fixed\n  //   can be converted to a prvalue of its underlying type. Moreover, if\n  //   integral promotion can be applied to its underlying type, a prvalue of an\n  //   unscoped enumeration type whose underlying type is fixed can also be\n  //   converted to a prvalue of the promoted underlying type.\n  if (const EnumType *FromEnumType = FromType->getAs<EnumType>()) {\n    // C++0x 7.2p9: Note that this implicit enum to int conversion is not\n    // provided for a scoped enumeration.\n    if (FromEnumType->getDecl()->isScoped())\n      return false;\n\n    // We can perform an integral promotion to the underlying type of the enum,\n    // even if that's not the promoted type. Note that the check for promoting\n    // the underlying type is based on the type alone, and does not consider\n    // the bitfield-ness of the actual source expression.\n    if (FromEnumType->getDecl()->isFixed()) {\n      QualType Underlying = FromEnumType->getDecl()->getIntegerType();\n      return Context.hasSameUnqualifiedType(Underlying, ToType) ||\n             IsIntegralPromotion(nullptr, Underlying, ToType);\n    }\n\n    // We have already pre-calculated the promotion type, so this is trivial.\n    if (ToType->isIntegerType() &&\n        isCompleteType(From->getBeginLoc(), FromType))\n      return Context.hasSameUnqualifiedType(\n          ToType, FromEnumType->getDecl()->getPromotionType());\n\n    // C++ [conv.prom]p5:\n    //   If the bit-field has an enumerated type, it is treated as any other\n    //   value of that type for promotion purposes.\n    //\n    // ... so do not fall through into the bit-field checks below in C++.\n    if (getLangOpts().CPlusPlus)\n      return false;\n  }\n\n  // C++0x [conv.prom]p2:\n  //   A prvalue of type char16_t, char32_t, or wchar_t (3.9.1) can be converted\n  //   to an rvalue a prvalue of the first of the following types that can\n  //   represent all the values of its underlying type: int, unsigned int,\n  //   long int, unsigned long int, long long int, or unsigned long long int.\n  //   If none of the types in that list can represent all the values of its\n  //   underlying type, an rvalue a prvalue of type char16_t, char32_t,\n  //   or wchar_t can be converted to an rvalue a prvalue of its underlying\n  //   type.\n  if (FromType->isAnyCharacterType() && !FromType->isCharType() &&\n      ToType->isIntegerType()) {\n    // Determine whether the type we're converting from is signed or\n    // unsigned.\n    bool FromIsSigned = FromType->isSignedIntegerType();\n    uint64_t FromSize = Context.getTypeSize(FromType);\n\n    // The types we'll try to promote to, in the appropriate\n    // order. Try each of these types.\n    QualType PromoteTypes[6] = {\n      Context.IntTy, Context.UnsignedIntTy,\n      Context.LongTy, Context.UnsignedLongTy ,\n      Context.LongLongTy, Context.UnsignedLongLongTy\n    };\n    for (int Idx = 0; Idx < 6; ++Idx) {\n      uint64_t ToSize = Context.getTypeSize(PromoteTypes[Idx]);\n      if (FromSize < ToSize ||\n          (FromSize == ToSize &&\n           FromIsSigned == PromoteTypes[Idx]->isSignedIntegerType())) {\n        // We found the type that we can promote to. If this is the\n        // type we wanted, we have a promotion. Otherwise, no\n        // promotion.\n        return Context.hasSameUnqualifiedType(ToType, PromoteTypes[Idx]);\n      }\n    }\n  }\n\n  // An rvalue for an integral bit-field (9.6) can be converted to an\n  // rvalue of type int if int can represent all the values of the\n  // bit-field; otherwise, it can be converted to unsigned int if\n  // unsigned int can represent all the values of the bit-field. If\n  // the bit-field is larger yet, no integral promotion applies to\n  // it. If the bit-field has an enumerated type, it is treated as any\n  // other value of that type for promotion purposes (C++ 4.5p3).\n  // FIXME: We should delay checking of bit-fields until we actually perform the\n  // conversion.\n  //\n  // FIXME: In C, only bit-fields of types _Bool, int, or unsigned int may be\n  // promoted, per C11 6.3.1.1/2. We promote all bit-fields (including enum\n  // bit-fields and those whose underlying type is larger than int) for GCC\n  // compatibility.\n  if (From) {\n    if (FieldDecl *MemberDecl = From->getSourceBitField()) {\n      Optional<llvm::APSInt> BitWidth;\n      if (FromType->isIntegralType(Context) &&\n          (BitWidth =\n               MemberDecl->getBitWidth()->getIntegerConstantExpr(Context))) {\n        llvm::APSInt ToSize(BitWidth->getBitWidth(), BitWidth->isUnsigned());\n        ToSize = Context.getTypeSize(ToType);\n\n        // Are we promoting to an int from a bitfield that fits in an int?\n        if (*BitWidth < ToSize ||\n            (FromType->isSignedIntegerType() && *BitWidth <= ToSize)) {\n          return To->getKind() == BuiltinType::Int;\n        }\n\n        // Are we promoting to an unsigned int from an unsigned bitfield\n        // that fits into an unsigned int?\n        if (FromType->isUnsignedIntegerType() && *BitWidth <= ToSize) {\n          return To->getKind() == BuiltinType::UInt;\n        }\n\n        return false;\n      }\n    }\n  }\n\n  // An rvalue of type bool can be converted to an rvalue of type int,\n  // with false becoming zero and true becoming one (C++ 4.5p4).\n  if (FromType->isBooleanType() && To->getKind() == BuiltinType::Int) {\n    return true;\n  }\n\n  return false;\n}\n\n/// IsFloatingPointPromotion - Determines whether the conversion from\n/// FromType to ToType is a floating point promotion (C++ 4.6). If so,\n/// returns true and sets PromotedType to the promoted type.\nbool Sema::IsFloatingPointPromotion(QualType FromType, QualType ToType) {\n  if (const BuiltinType *FromBuiltin = FromType->getAs<BuiltinType>())\n    if (const BuiltinType *ToBuiltin = ToType->getAs<BuiltinType>()) {\n      /// An rvalue of type float can be converted to an rvalue of type\n      /// double. (C++ 4.6p1).\n      if (FromBuiltin->getKind() == BuiltinType::Float &&\n          ToBuiltin->getKind() == BuiltinType::Double)\n        return true;\n\n      // C99 6.3.1.5p1:\n      //   When a float is promoted to double or long double, or a\n      //   double is promoted to long double [...].\n      if (!getLangOpts().CPlusPlus &&\n          (FromBuiltin->getKind() == BuiltinType::Float ||\n           FromBuiltin->getKind() == BuiltinType::Double) &&\n          (ToBuiltin->getKind() == BuiltinType::LongDouble ||\n           ToBuiltin->getKind() == BuiltinType::Float128))\n        return true;\n\n      // Half can be promoted to float.\n      if (!getLangOpts().NativeHalfType &&\n           FromBuiltin->getKind() == BuiltinType::Half &&\n          ToBuiltin->getKind() == BuiltinType::Float)\n        return true;\n    }\n\n  return false;\n}\n\n/// Determine if a conversion is a complex promotion.\n///\n/// A complex promotion is defined as a complex -> complex conversion\n/// where the conversion between the underlying real types is a\n/// floating-point or integral promotion.\nbool Sema::IsComplexPromotion(QualType FromType, QualType ToType) {\n  const ComplexType *FromComplex = FromType->getAs<ComplexType>();\n  if (!FromComplex)\n    return false;\n\n  const ComplexType *ToComplex = ToType->getAs<ComplexType>();\n  if (!ToComplex)\n    return false;\n\n  return IsFloatingPointPromotion(FromComplex->getElementType(),\n                                  ToComplex->getElementType()) ||\n    IsIntegralPromotion(nullptr, FromComplex->getElementType(),\n                        ToComplex->getElementType());\n}\n\n/// BuildSimilarlyQualifiedPointerType - In a pointer conversion from\n/// the pointer type FromPtr to a pointer to type ToPointee, with the\n/// same type qualifiers as FromPtr has on its pointee type. ToType,\n/// if non-empty, will be a pointer to ToType that may or may not have\n/// the right set of qualifiers on its pointee.\n///\nstatic QualType\nBuildSimilarlyQualifiedPointerType(const Type *FromPtr,\n                                   QualType ToPointee, QualType ToType,\n                                   ASTContext &Context,\n                                   bool StripObjCLifetime = false) {\n  assert((FromPtr->getTypeClass() == Type::Pointer ||\n          FromPtr->getTypeClass() == Type::ObjCObjectPointer) &&\n         \"Invalid similarly-qualified pointer type\");\n\n  /// Conversions to 'id' subsume cv-qualifier conversions.\n  if (ToType->isObjCIdType() || ToType->isObjCQualifiedIdType())\n    return ToType.getUnqualifiedType();\n\n  QualType CanonFromPointee\n    = Context.getCanonicalType(FromPtr->getPointeeType());\n  QualType CanonToPointee = Context.getCanonicalType(ToPointee);\n  Qualifiers Quals = CanonFromPointee.getQualifiers();\n\n  if (StripObjCLifetime)\n    Quals.removeObjCLifetime();\n\n  // Exact qualifier match -> return the pointer type we're converting to.\n  if (CanonToPointee.getLocalQualifiers() == Quals) {\n    // ToType is exactly what we need. Return it.\n    if (!ToType.isNull())\n      return ToType.getUnqualifiedType();\n\n    // Build a pointer to ToPointee. It has the right qualifiers\n    // already.\n    if (isa<ObjCObjectPointerType>(ToType))\n      return Context.getObjCObjectPointerType(ToPointee);\n    return Context.getPointerType(ToPointee);\n  }\n\n  // Just build a canonical type that has the right qualifiers.\n  QualType QualifiedCanonToPointee\n    = Context.getQualifiedType(CanonToPointee.getLocalUnqualifiedType(), Quals);\n\n  if (isa<ObjCObjectPointerType>(ToType))\n    return Context.getObjCObjectPointerType(QualifiedCanonToPointee);\n  return Context.getPointerType(QualifiedCanonToPointee);\n}\n\nstatic bool isNullPointerConstantForConversion(Expr *Expr,\n                                               bool InOverloadResolution,\n                                               ASTContext &Context) {\n  // Handle value-dependent integral null pointer constants correctly.\n  // http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#903\n  if (Expr->isValueDependent() && !Expr->isTypeDependent() &&\n      Expr->getType()->isIntegerType() && !Expr->getType()->isEnumeralType())\n    return !InOverloadResolution;\n\n  return Expr->isNullPointerConstant(Context,\n                    InOverloadResolution? Expr::NPC_ValueDependentIsNotNull\n                                        : Expr::NPC_ValueDependentIsNull);\n}\n\n/// IsPointerConversion - Determines whether the conversion of the\n/// expression From, which has the (possibly adjusted) type FromType,\n/// can be converted to the type ToType via a pointer conversion (C++\n/// 4.10). If so, returns true and places the converted type (that\n/// might differ from ToType in its cv-qualifiers at some level) into\n/// ConvertedType.\n///\n/// This routine also supports conversions to and from block pointers\n/// and conversions with Objective-C's 'id', 'id<protocols...>', and\n/// pointers to interfaces. FIXME: Once we've determined the\n/// appropriate overloading rules for Objective-C, we may want to\n/// split the Objective-C checks into a different routine; however,\n/// GCC seems to consider all of these conversions to be pointer\n/// conversions, so for now they live here. IncompatibleObjC will be\n/// set if the conversion is an allowed Objective-C conversion that\n/// should result in a warning.\nbool Sema::IsPointerConversion(Expr *From, QualType FromType, QualType ToType,\n                               bool InOverloadResolution,\n                               QualType& ConvertedType,\n                               bool &IncompatibleObjC) {\n  IncompatibleObjC = false;\n  if (isObjCPointerConversion(FromType, ToType, ConvertedType,\n                              IncompatibleObjC))\n    return true;\n\n  // Conversion from a null pointer constant to any Objective-C pointer type.\n  if (ToType->isObjCObjectPointerType() &&\n      isNullPointerConstantForConversion(From, InOverloadResolution, Context)) {\n    ConvertedType = ToType;\n    return true;\n  }\n\n  // Blocks: Block pointers can be converted to void*.\n  if (FromType->isBlockPointerType() && ToType->isPointerType() &&\n      ToType->castAs<PointerType>()->getPointeeType()->isVoidType()) {\n    ConvertedType = ToType;\n    return true;\n  }\n  // Blocks: A null pointer constant can be converted to a block\n  // pointer type.\n  if (ToType->isBlockPointerType() &&\n      isNullPointerConstantForConversion(From, InOverloadResolution, Context)) {\n    ConvertedType = ToType;\n    return true;\n  }\n\n  // If the left-hand-side is nullptr_t, the right side can be a null\n  // pointer constant.\n  if (ToType->isNullPtrType() &&\n      isNullPointerConstantForConversion(From, InOverloadResolution, Context)) {\n    ConvertedType = ToType;\n    return true;\n  }\n\n  const PointerType* ToTypePtr = ToType->getAs<PointerType>();\n  if (!ToTypePtr)\n    return false;\n\n  // A null pointer constant can be converted to a pointer type (C++ 4.10p1).\n  if (isNullPointerConstantForConversion(From, InOverloadResolution, Context)) {\n    ConvertedType = ToType;\n    return true;\n  }\n\n  // Beyond this point, both types need to be pointers\n  // , including objective-c pointers.\n  QualType ToPointeeType = ToTypePtr->getPointeeType();\n  if (FromType->isObjCObjectPointerType() && ToPointeeType->isVoidType() &&\n      !getLangOpts().ObjCAutoRefCount) {\n    ConvertedType = BuildSimilarlyQualifiedPointerType(\n                                      FromType->getAs<ObjCObjectPointerType>(),\n                                                       ToPointeeType,\n                                                       ToType, Context);\n    return true;\n  }\n  const PointerType *FromTypePtr = FromType->getAs<PointerType>();\n  if (!FromTypePtr)\n    return false;\n\n  QualType FromPointeeType = FromTypePtr->getPointeeType();\n\n  // If the unqualified pointee types are the same, this can't be a\n  // pointer conversion, so don't do all of the work below.\n  if (Context.hasSameUnqualifiedType(FromPointeeType, ToPointeeType))\n    return false;\n\n  // An rvalue of type \"pointer to cv T,\" where T is an object type,\n  // can be converted to an rvalue of type \"pointer to cv void\" (C++\n  // 4.10p2).\n  if (FromPointeeType->isIncompleteOrObjectType() &&\n      ToPointeeType->isVoidType()) {\n    ConvertedType = BuildSimilarlyQualifiedPointerType(FromTypePtr,\n                                                       ToPointeeType,\n                                                       ToType, Context,\n                                                   /*StripObjCLifetime=*/true);\n    return true;\n  }\n\n  // MSVC allows implicit function to void* type conversion.\n  if (getLangOpts().MSVCCompat && FromPointeeType->isFunctionType() &&\n      ToPointeeType->isVoidType()) {\n    ConvertedType = BuildSimilarlyQualifiedPointerType(FromTypePtr,\n                                                       ToPointeeType,\n                                                       ToType, Context);\n    return true;\n  }\n\n  // When we're overloading in C, we allow a special kind of pointer\n  // conversion for compatible-but-not-identical pointee types.\n  if (!getLangOpts().CPlusPlus &&\n      Context.typesAreCompatible(FromPointeeType, ToPointeeType)) {\n    ConvertedType = BuildSimilarlyQualifiedPointerType(FromTypePtr,\n                                                       ToPointeeType,\n                                                       ToType, Context);\n    return true;\n  }\n\n  // C++ [conv.ptr]p3:\n  //\n  //   An rvalue of type \"pointer to cv D,\" where D is a class type,\n  //   can be converted to an rvalue of type \"pointer to cv B,\" where\n  //   B is a base class (clause 10) of D. If B is an inaccessible\n  //   (clause 11) or ambiguous (10.2) base class of D, a program that\n  //   necessitates this conversion is ill-formed. The result of the\n  //   conversion is a pointer to the base class sub-object of the\n  //   derived class object. The null pointer value is converted to\n  //   the null pointer value of the destination type.\n  //\n  // Note that we do not check for ambiguity or inaccessibility\n  // here. That is handled by CheckPointerConversion.\n  if (getLangOpts().CPlusPlus && FromPointeeType->isRecordType() &&\n      ToPointeeType->isRecordType() &&\n      !Context.hasSameUnqualifiedType(FromPointeeType, ToPointeeType) &&\n      IsDerivedFrom(From->getBeginLoc(), FromPointeeType, ToPointeeType)) {\n    ConvertedType = BuildSimilarlyQualifiedPointerType(FromTypePtr,\n                                                       ToPointeeType,\n                                                       ToType, Context);\n    return true;\n  }\n\n  if (FromPointeeType->isVectorType() && ToPointeeType->isVectorType() &&\n      Context.areCompatibleVectorTypes(FromPointeeType, ToPointeeType)) {\n    ConvertedType = BuildSimilarlyQualifiedPointerType(FromTypePtr,\n                                                       ToPointeeType,\n                                                       ToType, Context);\n    return true;\n  }\n\n  return false;\n}\n\n/// Adopt the given qualifiers for the given type.\nstatic QualType AdoptQualifiers(ASTContext &Context, QualType T, Qualifiers Qs){\n  Qualifiers TQs = T.getQualifiers();\n\n  // Check whether qualifiers already match.\n  if (TQs == Qs)\n    return T;\n\n  if (Qs.compatiblyIncludes(TQs))\n    return Context.getQualifiedType(T, Qs);\n\n  return Context.getQualifiedType(T.getUnqualifiedType(), Qs);\n}\n\n/// isObjCPointerConversion - Determines whether this is an\n/// Objective-C pointer conversion. Subroutine of IsPointerConversion,\n/// with the same arguments and return values.\nbool Sema::isObjCPointerConversion(QualType FromType, QualType ToType,\n                                   QualType& ConvertedType,\n                                   bool &IncompatibleObjC) {\n  if (!getLangOpts().ObjC)\n    return false;\n\n  // The set of qualifiers on the type we're converting from.\n  Qualifiers FromQualifiers = FromType.getQualifiers();\n\n  // First, we handle all conversions on ObjC object pointer types.\n  const ObjCObjectPointerType* ToObjCPtr =\n    ToType->getAs<ObjCObjectPointerType>();\n  const ObjCObjectPointerType *FromObjCPtr =\n    FromType->getAs<ObjCObjectPointerType>();\n\n  if (ToObjCPtr && FromObjCPtr) {\n    // If the pointee types are the same (ignoring qualifications),\n    // then this is not a pointer conversion.\n    if (Context.hasSameUnqualifiedType(ToObjCPtr->getPointeeType(),\n                                       FromObjCPtr->getPointeeType()))\n      return false;\n\n    // Conversion between Objective-C pointers.\n    if (Context.canAssignObjCInterfaces(ToObjCPtr, FromObjCPtr)) {\n      const ObjCInterfaceType* LHS = ToObjCPtr->getInterfaceType();\n      const ObjCInterfaceType* RHS = FromObjCPtr->getInterfaceType();\n      if (getLangOpts().CPlusPlus && LHS && RHS &&\n          !ToObjCPtr->getPointeeType().isAtLeastAsQualifiedAs(\n                                                FromObjCPtr->getPointeeType()))\n        return false;\n      ConvertedType = BuildSimilarlyQualifiedPointerType(FromObjCPtr,\n                                                   ToObjCPtr->getPointeeType(),\n                                                         ToType, Context);\n      ConvertedType = AdoptQualifiers(Context, ConvertedType, FromQualifiers);\n      return true;\n    }\n\n    if (Context.canAssignObjCInterfaces(FromObjCPtr, ToObjCPtr)) {\n      // Okay: this is some kind of implicit downcast of Objective-C\n      // interfaces, which is permitted. However, we're going to\n      // complain about it.\n      IncompatibleObjC = true;\n      ConvertedType = BuildSimilarlyQualifiedPointerType(FromObjCPtr,\n                                                   ToObjCPtr->getPointeeType(),\n                                                         ToType, Context);\n      ConvertedType = AdoptQualifiers(Context, ConvertedType, FromQualifiers);\n      return true;\n    }\n  }\n  // Beyond this point, both types need to be C pointers or block pointers.\n  QualType ToPointeeType;\n  if (const PointerType *ToCPtr = ToType->getAs<PointerType>())\n    ToPointeeType = ToCPtr->getPointeeType();\n  else if (const BlockPointerType *ToBlockPtr =\n            ToType->getAs<BlockPointerType>()) {\n    // Objective C++: We're able to convert from a pointer to any object\n    // to a block pointer type.\n    if (FromObjCPtr && FromObjCPtr->isObjCBuiltinType()) {\n      ConvertedType = AdoptQualifiers(Context, ToType, FromQualifiers);\n      return true;\n    }\n    ToPointeeType = ToBlockPtr->getPointeeType();\n  }\n  else if (FromType->getAs<BlockPointerType>() &&\n           ToObjCPtr && ToObjCPtr->isObjCBuiltinType()) {\n    // Objective C++: We're able to convert from a block pointer type to a\n    // pointer to any object.\n    ConvertedType = AdoptQualifiers(Context, ToType, FromQualifiers);\n    return true;\n  }\n  else\n    return false;\n\n  QualType FromPointeeType;\n  if (const PointerType *FromCPtr = FromType->getAs<PointerType>())\n    FromPointeeType = FromCPtr->getPointeeType();\n  else if (const BlockPointerType *FromBlockPtr =\n           FromType->getAs<BlockPointerType>())\n    FromPointeeType = FromBlockPtr->getPointeeType();\n  else\n    return false;\n\n  // If we have pointers to pointers, recursively check whether this\n  // is an Objective-C conversion.\n  if (FromPointeeType->isPointerType() && ToPointeeType->isPointerType() &&\n      isObjCPointerConversion(FromPointeeType, ToPointeeType, ConvertedType,\n                              IncompatibleObjC)) {\n    // We always complain about this conversion.\n    IncompatibleObjC = true;\n    ConvertedType = Context.getPointerType(ConvertedType);\n    ConvertedType = AdoptQualifiers(Context, ConvertedType, FromQualifiers);\n    return true;\n  }\n  // Allow conversion of pointee being objective-c pointer to another one;\n  // as in I* to id.\n  if (FromPointeeType->getAs<ObjCObjectPointerType>() &&\n      ToPointeeType->getAs<ObjCObjectPointerType>() &&\n      isObjCPointerConversion(FromPointeeType, ToPointeeType, ConvertedType,\n                              IncompatibleObjC)) {\n\n    ConvertedType = Context.getPointerType(ConvertedType);\n    ConvertedType = AdoptQualifiers(Context, ConvertedType, FromQualifiers);\n    return true;\n  }\n\n  // If we have pointers to functions or blocks, check whether the only\n  // differences in the argument and result types are in Objective-C\n  // pointer conversions. If so, we permit the conversion (but\n  // complain about it).\n  const FunctionProtoType *FromFunctionType\n    = FromPointeeType->getAs<FunctionProtoType>();\n  const FunctionProtoType *ToFunctionType\n    = ToPointeeType->getAs<FunctionProtoType>();\n  if (FromFunctionType && ToFunctionType) {\n    // If the function types are exactly the same, this isn't an\n    // Objective-C pointer conversion.\n    if (Context.getCanonicalType(FromPointeeType)\n          == Context.getCanonicalType(ToPointeeType))\n      return false;\n\n    // Perform the quick checks that will tell us whether these\n    // function types are obviously different.\n    if (FromFunctionType->getNumParams() != ToFunctionType->getNumParams() ||\n        FromFunctionType->isVariadic() != ToFunctionType->isVariadic() ||\n        FromFunctionType->getMethodQuals() != ToFunctionType->getMethodQuals())\n      return false;\n\n    bool HasObjCConversion = false;\n    if (Context.getCanonicalType(FromFunctionType->getReturnType()) ==\n        Context.getCanonicalType(ToFunctionType->getReturnType())) {\n      // Okay, the types match exactly. Nothing to do.\n    } else if (isObjCPointerConversion(FromFunctionType->getReturnType(),\n                                       ToFunctionType->getReturnType(),\n                                       ConvertedType, IncompatibleObjC)) {\n      // Okay, we have an Objective-C pointer conversion.\n      HasObjCConversion = true;\n    } else {\n      // Function types are too different. Abort.\n      return false;\n    }\n\n    // Check argument types.\n    for (unsigned ArgIdx = 0, NumArgs = FromFunctionType->getNumParams();\n         ArgIdx != NumArgs; ++ArgIdx) {\n      QualType FromArgType = FromFunctionType->getParamType(ArgIdx);\n      QualType ToArgType = ToFunctionType->getParamType(ArgIdx);\n      if (Context.getCanonicalType(FromArgType)\n            == Context.getCanonicalType(ToArgType)) {\n        // Okay, the types match exactly. Nothing to do.\n      } else if (isObjCPointerConversion(FromArgType, ToArgType,\n                                         ConvertedType, IncompatibleObjC)) {\n        // Okay, we have an Objective-C pointer conversion.\n        HasObjCConversion = true;\n      } else {\n        // Argument types are too different. Abort.\n        return false;\n      }\n    }\n\n    if (HasObjCConversion) {\n      // We had an Objective-C conversion. Allow this pointer\n      // conversion, but complain about it.\n      ConvertedType = AdoptQualifiers(Context, ToType, FromQualifiers);\n      IncompatibleObjC = true;\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/// Determine whether this is an Objective-C writeback conversion,\n/// used for parameter passing when performing automatic reference counting.\n///\n/// \\param FromType The type we're converting form.\n///\n/// \\param ToType The type we're converting to.\n///\n/// \\param ConvertedType The type that will be produced after applying\n/// this conversion.\nbool Sema::isObjCWritebackConversion(QualType FromType, QualType ToType,\n                                     QualType &ConvertedType) {\n  if (!getLangOpts().ObjCAutoRefCount ||\n      Context.hasSameUnqualifiedType(FromType, ToType))\n    return false;\n\n  // Parameter must be a pointer to __autoreleasing (with no other qualifiers).\n  QualType ToPointee;\n  if (const PointerType *ToPointer = ToType->getAs<PointerType>())\n    ToPointee = ToPointer->getPointeeType();\n  else\n    return false;\n\n  Qualifiers ToQuals = ToPointee.getQualifiers();\n  if (!ToPointee->isObjCLifetimeType() ||\n      ToQuals.getObjCLifetime() != Qualifiers::OCL_Autoreleasing ||\n      !ToQuals.withoutObjCLifetime().empty())\n    return false;\n\n  // Argument must be a pointer to __strong to __weak.\n  QualType FromPointee;\n  if (const PointerType *FromPointer = FromType->getAs<PointerType>())\n    FromPointee = FromPointer->getPointeeType();\n  else\n    return false;\n\n  Qualifiers FromQuals = FromPointee.getQualifiers();\n  if (!FromPointee->isObjCLifetimeType() ||\n      (FromQuals.getObjCLifetime() != Qualifiers::OCL_Strong &&\n       FromQuals.getObjCLifetime() != Qualifiers::OCL_Weak))\n    return false;\n\n  // Make sure that we have compatible qualifiers.\n  FromQuals.setObjCLifetime(Qualifiers::OCL_Autoreleasing);\n  if (!ToQuals.compatiblyIncludes(FromQuals))\n    return false;\n\n  // Remove qualifiers from the pointee type we're converting from; they\n  // aren't used in the compatibility check belong, and we'll be adding back\n  // qualifiers (with __autoreleasing) if the compatibility check succeeds.\n  FromPointee = FromPointee.getUnqualifiedType();\n\n  // The unqualified form of the pointee types must be compatible.\n  ToPointee = ToPointee.getUnqualifiedType();\n  bool IncompatibleObjC;\n  if (Context.typesAreCompatible(FromPointee, ToPointee))\n    FromPointee = ToPointee;\n  else if (!isObjCPointerConversion(FromPointee, ToPointee, FromPointee,\n                                    IncompatibleObjC))\n    return false;\n\n  /// Construct the type we're converting to, which is a pointer to\n  /// __autoreleasing pointee.\n  FromPointee = Context.getQualifiedType(FromPointee, FromQuals);\n  ConvertedType = Context.getPointerType(FromPointee);\n  return true;\n}\n\nbool Sema::IsBlockPointerConversion(QualType FromType, QualType ToType,\n                                    QualType& ConvertedType) {\n  QualType ToPointeeType;\n  if (const BlockPointerType *ToBlockPtr =\n        ToType->getAs<BlockPointerType>())\n    ToPointeeType = ToBlockPtr->getPointeeType();\n  else\n    return false;\n\n  QualType FromPointeeType;\n  if (const BlockPointerType *FromBlockPtr =\n      FromType->getAs<BlockPointerType>())\n    FromPointeeType = FromBlockPtr->getPointeeType();\n  else\n    return false;\n  // We have pointer to blocks, check whether the only\n  // differences in the argument and result types are in Objective-C\n  // pointer conversions. If so, we permit the conversion.\n\n  const FunctionProtoType *FromFunctionType\n    = FromPointeeType->getAs<FunctionProtoType>();\n  const FunctionProtoType *ToFunctionType\n    = ToPointeeType->getAs<FunctionProtoType>();\n\n  if (!FromFunctionType || !ToFunctionType)\n    return false;\n\n  if (Context.hasSameType(FromPointeeType, ToPointeeType))\n    return true;\n\n  // Perform the quick checks that will tell us whether these\n  // function types are obviously different.\n  if (FromFunctionType->getNumParams() != ToFunctionType->getNumParams() ||\n      FromFunctionType->isVariadic() != ToFunctionType->isVariadic())\n    return false;\n\n  FunctionType::ExtInfo FromEInfo = FromFunctionType->getExtInfo();\n  FunctionType::ExtInfo ToEInfo = ToFunctionType->getExtInfo();\n  if (FromEInfo != ToEInfo)\n    return false;\n\n  bool IncompatibleObjC = false;\n  if (Context.hasSameType(FromFunctionType->getReturnType(),\n                          ToFunctionType->getReturnType())) {\n    // Okay, the types match exactly. Nothing to do.\n  } else {\n    QualType RHS = FromFunctionType->getReturnType();\n    QualType LHS = ToFunctionType->getReturnType();\n    if ((!getLangOpts().CPlusPlus || !RHS->isRecordType()) &&\n        !RHS.hasQualifiers() && LHS.hasQualifiers())\n       LHS = LHS.getUnqualifiedType();\n\n     if (Context.hasSameType(RHS,LHS)) {\n       // OK exact match.\n     } else if (isObjCPointerConversion(RHS, LHS,\n                                        ConvertedType, IncompatibleObjC)) {\n     if (IncompatibleObjC)\n       return false;\n     // Okay, we have an Objective-C pointer conversion.\n     }\n     else\n       return false;\n   }\n\n   // Check argument types.\n   for (unsigned ArgIdx = 0, NumArgs = FromFunctionType->getNumParams();\n        ArgIdx != NumArgs; ++ArgIdx) {\n     IncompatibleObjC = false;\n     QualType FromArgType = FromFunctionType->getParamType(ArgIdx);\n     QualType ToArgType = ToFunctionType->getParamType(ArgIdx);\n     if (Context.hasSameType(FromArgType, ToArgType)) {\n       // Okay, the types match exactly. Nothing to do.\n     } else if (isObjCPointerConversion(ToArgType, FromArgType,\n                                        ConvertedType, IncompatibleObjC)) {\n       if (IncompatibleObjC)\n         return false;\n       // Okay, we have an Objective-C pointer conversion.\n     } else\n       // Argument types are too different. Abort.\n       return false;\n   }\n\n   SmallVector<FunctionProtoType::ExtParameterInfo, 4> NewParamInfos;\n   bool CanUseToFPT, CanUseFromFPT;\n   if (!Context.mergeExtParameterInfo(ToFunctionType, FromFunctionType,\n                                      CanUseToFPT, CanUseFromFPT,\n                                      NewParamInfos))\n     return false;\n\n   ConvertedType = ToType;\n   return true;\n}\n\nenum {\n  ft_default,\n  ft_different_class,\n  ft_parameter_arity,\n  ft_parameter_mismatch,\n  ft_return_type,\n  ft_qualifer_mismatch,\n  ft_noexcept\n};\n\n/// Attempts to get the FunctionProtoType from a Type. Handles\n/// MemberFunctionPointers properly.\nstatic const FunctionProtoType *tryGetFunctionProtoType(QualType FromType) {\n  if (auto *FPT = FromType->getAs<FunctionProtoType>())\n    return FPT;\n\n  if (auto *MPT = FromType->getAs<MemberPointerType>())\n    return MPT->getPointeeType()->getAs<FunctionProtoType>();\n\n  return nullptr;\n}\n\n/// HandleFunctionTypeMismatch - Gives diagnostic information for differeing\n/// function types.  Catches different number of parameter, mismatch in\n/// parameter types, and different return types.\nvoid Sema::HandleFunctionTypeMismatch(PartialDiagnostic &PDiag,\n                                      QualType FromType, QualType ToType) {\n  // If either type is not valid, include no extra info.\n  if (FromType.isNull() || ToType.isNull()) {\n    PDiag << ft_default;\n    return;\n  }\n\n  // Get the function type from the pointers.\n  if (FromType->isMemberPointerType() && ToType->isMemberPointerType()) {\n    const auto *FromMember = FromType->castAs<MemberPointerType>(),\n               *ToMember = ToType->castAs<MemberPointerType>();\n    if (!Context.hasSameType(FromMember->getClass(), ToMember->getClass())) {\n      PDiag << ft_different_class << QualType(ToMember->getClass(), 0)\n            << QualType(FromMember->getClass(), 0);\n      return;\n    }\n    FromType = FromMember->getPointeeType();\n    ToType = ToMember->getPointeeType();\n  }\n\n  if (FromType->isPointerType())\n    FromType = FromType->getPointeeType();\n  if (ToType->isPointerType())\n    ToType = ToType->getPointeeType();\n\n  // Remove references.\n  FromType = FromType.getNonReferenceType();\n  ToType = ToType.getNonReferenceType();\n\n  // Don't print extra info for non-specialized template functions.\n  if (FromType->isInstantiationDependentType() &&\n      !FromType->getAs<TemplateSpecializationType>()) {\n    PDiag << ft_default;\n    return;\n  }\n\n  // No extra info for same types.\n  if (Context.hasSameType(FromType, ToType)) {\n    PDiag << ft_default;\n    return;\n  }\n\n  const FunctionProtoType *FromFunction = tryGetFunctionProtoType(FromType),\n                          *ToFunction = tryGetFunctionProtoType(ToType);\n\n  // Both types need to be function types.\n  if (!FromFunction || !ToFunction) {\n    PDiag << ft_default;\n    return;\n  }\n\n  if (FromFunction->getNumParams() != ToFunction->getNumParams()) {\n    PDiag << ft_parameter_arity << ToFunction->getNumParams()\n          << FromFunction->getNumParams();\n    return;\n  }\n\n  // Handle different parameter types.\n  unsigned ArgPos;\n  if (!FunctionParamTypesAreEqual(FromFunction, ToFunction, &ArgPos)) {\n    PDiag << ft_parameter_mismatch << ArgPos + 1\n          << ToFunction->getParamType(ArgPos)\n          << FromFunction->getParamType(ArgPos);\n    return;\n  }\n\n  // Handle different return type.\n  if (!Context.hasSameType(FromFunction->getReturnType(),\n                           ToFunction->getReturnType())) {\n    PDiag << ft_return_type << ToFunction->getReturnType()\n          << FromFunction->getReturnType();\n    return;\n  }\n\n  if (FromFunction->getMethodQuals() != ToFunction->getMethodQuals()) {\n    PDiag << ft_qualifer_mismatch << ToFunction->getMethodQuals()\n          << FromFunction->getMethodQuals();\n    return;\n  }\n\n  // Handle exception specification differences on canonical type (in C++17\n  // onwards).\n  if (cast<FunctionProtoType>(FromFunction->getCanonicalTypeUnqualified())\n          ->isNothrow() !=\n      cast<FunctionProtoType>(ToFunction->getCanonicalTypeUnqualified())\n          ->isNothrow()) {\n    PDiag << ft_noexcept;\n    return;\n  }\n\n  // Unable to find a difference, so add no extra info.\n  PDiag << ft_default;\n}\n\n/// FunctionParamTypesAreEqual - This routine checks two function proto types\n/// for equality of their argument types. Caller has already checked that\n/// they have same number of arguments.  If the parameters are different,\n/// ArgPos will have the parameter index of the first different parameter.\nbool Sema::FunctionParamTypesAreEqual(const FunctionProtoType *OldType,\n                                      const FunctionProtoType *NewType,\n                                      unsigned *ArgPos) {\n  for (FunctionProtoType::param_type_iterator O = OldType->param_type_begin(),\n                                              N = NewType->param_type_begin(),\n                                              E = OldType->param_type_end();\n       O && (O != E); ++O, ++N) {\n    // Ignore address spaces in pointee type. This is to disallow overloading\n    // on __ptr32/__ptr64 address spaces.\n    QualType Old = Context.removePtrSizeAddrSpace(O->getUnqualifiedType());\n    QualType New = Context.removePtrSizeAddrSpace(N->getUnqualifiedType());\n\n    if (!Context.hasSameType(Old, New)) {\n      if (ArgPos)\n        *ArgPos = O - OldType->param_type_begin();\n      return false;\n    }\n  }\n  return true;\n}\n\n/// CheckPointerConversion - Check the pointer conversion from the\n/// expression From to the type ToType. This routine checks for\n/// ambiguous or inaccessible derived-to-base pointer\n/// conversions for which IsPointerConversion has already returned\n/// true. It returns true and produces a diagnostic if there was an\n/// error, or returns false otherwise.\nbool Sema::CheckPointerConversion(Expr *From, QualType ToType,\n                                  CastKind &Kind,\n                                  CXXCastPath& BasePath,\n                                  bool IgnoreBaseAccess,\n                                  bool Diagnose) {\n  QualType FromType = From->getType();\n  bool IsCStyleOrFunctionalCast = IgnoreBaseAccess;\n\n  Kind = CK_BitCast;\n\n  if (Diagnose && !IsCStyleOrFunctionalCast && !FromType->isAnyPointerType() &&\n      From->isNullPointerConstant(Context, Expr::NPC_ValueDependentIsNotNull) ==\n          Expr::NPCK_ZeroExpression) {\n    if (Context.hasSameUnqualifiedType(From->getType(), Context.BoolTy))\n      DiagRuntimeBehavior(From->getExprLoc(), From,\n                          PDiag(diag::warn_impcast_bool_to_null_pointer)\n                            << ToType << From->getSourceRange());\n    else if (!isUnevaluatedContext())\n      Diag(From->getExprLoc(), diag::warn_non_literal_null_pointer)\n        << ToType << From->getSourceRange();\n  }\n  if (const PointerType *ToPtrType = ToType->getAs<PointerType>()) {\n    if (const PointerType *FromPtrType = FromType->getAs<PointerType>()) {\n      QualType FromPointeeType = FromPtrType->getPointeeType(),\n               ToPointeeType   = ToPtrType->getPointeeType();\n\n      if (FromPointeeType->isRecordType() && ToPointeeType->isRecordType() &&\n          !Context.hasSameUnqualifiedType(FromPointeeType, ToPointeeType)) {\n        // We must have a derived-to-base conversion. Check an\n        // ambiguous or inaccessible conversion.\n        unsigned InaccessibleID = 0;\n        unsigned AmbiguousID = 0;\n        if (Diagnose) {\n          InaccessibleID = diag::err_upcast_to_inaccessible_base;\n          AmbiguousID = diag::err_ambiguous_derived_to_base_conv;\n        }\n        if (CheckDerivedToBaseConversion(\n                FromPointeeType, ToPointeeType, InaccessibleID, AmbiguousID,\n                From->getExprLoc(), From->getSourceRange(), DeclarationName(),\n                &BasePath, IgnoreBaseAccess))\n          return true;\n\n        // The conversion was successful.\n        Kind = CK_DerivedToBase;\n      }\n\n      if (Diagnose && !IsCStyleOrFunctionalCast &&\n          FromPointeeType->isFunctionType() && ToPointeeType->isVoidType()) {\n        assert(getLangOpts().MSVCCompat &&\n               \"this should only be possible with MSVCCompat!\");\n        Diag(From->getExprLoc(), diag::ext_ms_impcast_fn_obj)\n            << From->getSourceRange();\n      }\n    }\n  } else if (const ObjCObjectPointerType *ToPtrType =\n               ToType->getAs<ObjCObjectPointerType>()) {\n    if (const ObjCObjectPointerType *FromPtrType =\n          FromType->getAs<ObjCObjectPointerType>()) {\n      // Objective-C++ conversions are always okay.\n      // FIXME: We should have a different class of conversions for the\n      // Objective-C++ implicit conversions.\n      if (FromPtrType->isObjCBuiltinType() || ToPtrType->isObjCBuiltinType())\n        return false;\n    } else if (FromType->isBlockPointerType()) {\n      Kind = CK_BlockPointerToObjCPointerCast;\n    } else {\n      Kind = CK_CPointerToObjCPointerCast;\n    }\n  } else if (ToType->isBlockPointerType()) {\n    if (!FromType->isBlockPointerType())\n      Kind = CK_AnyPointerToBlockPointerCast;\n  }\n\n  // We shouldn't fall into this case unless it's valid for other\n  // reasons.\n  if (From->isNullPointerConstant(Context, Expr::NPC_ValueDependentIsNull))\n    Kind = CK_NullToPointer;\n\n  return false;\n}\n\n/// IsMemberPointerConversion - Determines whether the conversion of the\n/// expression From, which has the (possibly adjusted) type FromType, can be\n/// converted to the type ToType via a member pointer conversion (C++ 4.11).\n/// If so, returns true and places the converted type (that might differ from\n/// ToType in its cv-qualifiers at some level) into ConvertedType.\nbool Sema::IsMemberPointerConversion(Expr *From, QualType FromType,\n                                     QualType ToType,\n                                     bool InOverloadResolution,\n                                     QualType &ConvertedType) {\n  const MemberPointerType *ToTypePtr = ToType->getAs<MemberPointerType>();\n  if (!ToTypePtr)\n    return false;\n\n  // A null pointer constant can be converted to a member pointer (C++ 4.11p1)\n  if (From->isNullPointerConstant(Context,\n                    InOverloadResolution? Expr::NPC_ValueDependentIsNotNull\n                                        : Expr::NPC_ValueDependentIsNull)) {\n    ConvertedType = ToType;\n    return true;\n  }\n\n  // Otherwise, both types have to be member pointers.\n  const MemberPointerType *FromTypePtr = FromType->getAs<MemberPointerType>();\n  if (!FromTypePtr)\n    return false;\n\n  // A pointer to member of B can be converted to a pointer to member of D,\n  // where D is derived from B (C++ 4.11p2).\n  QualType FromClass(FromTypePtr->getClass(), 0);\n  QualType ToClass(ToTypePtr->getClass(), 0);\n\n  if (!Context.hasSameUnqualifiedType(FromClass, ToClass) &&\n      IsDerivedFrom(From->getBeginLoc(), ToClass, FromClass)) {\n    ConvertedType = Context.getMemberPointerType(FromTypePtr->getPointeeType(),\n                                                 ToClass.getTypePtr());\n    return true;\n  }\n\n  return false;\n}\n\n/// CheckMemberPointerConversion - Check the member pointer conversion from the\n/// expression From to the type ToType. This routine checks for ambiguous or\n/// virtual or inaccessible base-to-derived member pointer conversions\n/// for which IsMemberPointerConversion has already returned true. It returns\n/// true and produces a diagnostic if there was an error, or returns false\n/// otherwise.\nbool Sema::CheckMemberPointerConversion(Expr *From, QualType ToType,\n                                        CastKind &Kind,\n                                        CXXCastPath &BasePath,\n                                        bool IgnoreBaseAccess) {\n  QualType FromType = From->getType();\n  const MemberPointerType *FromPtrType = FromType->getAs<MemberPointerType>();\n  if (!FromPtrType) {\n    // This must be a null pointer to member pointer conversion\n    assert(From->isNullPointerConstant(Context,\n                                       Expr::NPC_ValueDependentIsNull) &&\n           \"Expr must be null pointer constant!\");\n    Kind = CK_NullToMemberPointer;\n    return false;\n  }\n\n  const MemberPointerType *ToPtrType = ToType->getAs<MemberPointerType>();\n  assert(ToPtrType && \"No member pointer cast has a target type \"\n                      \"that is not a member pointer.\");\n\n  QualType FromClass = QualType(FromPtrType->getClass(), 0);\n  QualType ToClass   = QualType(ToPtrType->getClass(), 0);\n\n  // FIXME: What about dependent types?\n  assert(FromClass->isRecordType() && \"Pointer into non-class.\");\n  assert(ToClass->isRecordType() && \"Pointer into non-class.\");\n\n  CXXBasePaths Paths(/*FindAmbiguities=*/true, /*RecordPaths=*/true,\n                     /*DetectVirtual=*/true);\n  bool DerivationOkay =\n      IsDerivedFrom(From->getBeginLoc(), ToClass, FromClass, Paths);\n  assert(DerivationOkay &&\n         \"Should not have been called if derivation isn't OK.\");\n  (void)DerivationOkay;\n\n  if (Paths.isAmbiguous(Context.getCanonicalType(FromClass).\n                                  getUnqualifiedType())) {\n    std::string PathDisplayStr = getAmbiguousPathsDisplayString(Paths);\n    Diag(From->getExprLoc(), diag::err_ambiguous_memptr_conv)\n      << 0 << FromClass << ToClass << PathDisplayStr << From->getSourceRange();\n    return true;\n  }\n\n  if (const RecordType *VBase = Paths.getDetectedVirtual()) {\n    Diag(From->getExprLoc(), diag::err_memptr_conv_via_virtual)\n      << FromClass << ToClass << QualType(VBase, 0)\n      << From->getSourceRange();\n    return true;\n  }\n\n  if (!IgnoreBaseAccess)\n    CheckBaseClassAccess(From->getExprLoc(), FromClass, ToClass,\n                         Paths.front(),\n                         diag::err_downcast_from_inaccessible_base);\n\n  // Must be a base to derived member conversion.\n  BuildBasePathArray(Paths, BasePath);\n  Kind = CK_BaseToDerivedMemberPointer;\n  return false;\n}\n\n/// Determine whether the lifetime conversion between the two given\n/// qualifiers sets is nontrivial.\nstatic bool isNonTrivialObjCLifetimeConversion(Qualifiers FromQuals,\n                                               Qualifiers ToQuals) {\n  // Converting anything to const __unsafe_unretained is trivial.\n  if (ToQuals.hasConst() &&\n      ToQuals.getObjCLifetime() == Qualifiers::OCL_ExplicitNone)\n    return false;\n\n  return true;\n}\n\n/// Perform a single iteration of the loop for checking if a qualification\n/// conversion is valid.\n///\n/// Specifically, check whether any change between the qualifiers of \\p\n/// FromType and \\p ToType is permissible, given knowledge about whether every\n/// outer layer is const-qualified.\nstatic bool isQualificationConversionStep(QualType FromType, QualType ToType,\n                                          bool CStyle, bool IsTopLevel,\n                                          bool &PreviousToQualsIncludeConst,\n                                          bool &ObjCLifetimeConversion) {\n  Qualifiers FromQuals = FromType.getQualifiers();\n  Qualifiers ToQuals = ToType.getQualifiers();\n\n  // Ignore __unaligned qualifier if this type is void.\n  if (ToType.getUnqualifiedType()->isVoidType())\n    FromQuals.removeUnaligned();\n\n  // Objective-C ARC:\n  //   Check Objective-C lifetime conversions.\n  if (FromQuals.getObjCLifetime() != ToQuals.getObjCLifetime()) {\n    if (ToQuals.compatiblyIncludesObjCLifetime(FromQuals)) {\n      if (isNonTrivialObjCLifetimeConversion(FromQuals, ToQuals))\n        ObjCLifetimeConversion = true;\n      FromQuals.removeObjCLifetime();\n      ToQuals.removeObjCLifetime();\n    } else {\n      // Qualification conversions cannot cast between different\n      // Objective-C lifetime qualifiers.\n      return false;\n    }\n  }\n\n  // Allow addition/removal of GC attributes but not changing GC attributes.\n  if (FromQuals.getObjCGCAttr() != ToQuals.getObjCGCAttr() &&\n      (!FromQuals.hasObjCGCAttr() || !ToQuals.hasObjCGCAttr())) {\n    FromQuals.removeObjCGCAttr();\n    ToQuals.removeObjCGCAttr();\n  }\n\n  //   -- for every j > 0, if const is in cv 1,j then const is in cv\n  //      2,j, and similarly for volatile.\n  if (!CStyle && !ToQuals.compatiblyIncludes(FromQuals))\n    return false;\n\n  // If address spaces mismatch:\n  //  - in top level it is only valid to convert to addr space that is a\n  //    superset in all cases apart from C-style casts where we allow\n  //    conversions between overlapping address spaces.\n  //  - in non-top levels it is not a valid conversion.\n  if (ToQuals.getAddressSpace() != FromQuals.getAddressSpace() &&\n      (!IsTopLevel ||\n       !(ToQuals.isAddressSpaceSupersetOf(FromQuals) ||\n         (CStyle && FromQuals.isAddressSpaceSupersetOf(ToQuals)))))\n    return false;\n\n  //   -- if the cv 1,j and cv 2,j are different, then const is in\n  //      every cv for 0 < k < j.\n  if (!CStyle && FromQuals.getCVRQualifiers() != ToQuals.getCVRQualifiers() &&\n      !PreviousToQualsIncludeConst)\n    return false;\n\n  // Keep track of whether all prior cv-qualifiers in the \"to\" type\n  // include const.\n  PreviousToQualsIncludeConst =\n      PreviousToQualsIncludeConst && ToQuals.hasConst();\n  return true;\n}\n\n/// IsQualificationConversion - Determines whether the conversion from\n/// an rvalue of type FromType to ToType is a qualification conversion\n/// (C++ 4.4).\n///\n/// \\param ObjCLifetimeConversion Output parameter that will be set to indicate\n/// when the qualification conversion involves a change in the Objective-C\n/// object lifetime.\nbool\nSema::IsQualificationConversion(QualType FromType, QualType ToType,\n                                bool CStyle, bool &ObjCLifetimeConversion) {\n  FromType = Context.getCanonicalType(FromType);\n  ToType = Context.getCanonicalType(ToType);\n  ObjCLifetimeConversion = false;\n\n  // If FromType and ToType are the same type, this is not a\n  // qualification conversion.\n  if (FromType.getUnqualifiedType() == ToType.getUnqualifiedType())\n    return false;\n\n  // (C++ 4.4p4):\n  //   A conversion can add cv-qualifiers at levels other than the first\n  //   in multi-level pointers, subject to the following rules: [...]\n  bool PreviousToQualsIncludeConst = true;\n  bool UnwrappedAnyPointer = false;\n  while (Context.UnwrapSimilarTypes(FromType, ToType)) {\n    if (!isQualificationConversionStep(\n            FromType, ToType, CStyle, !UnwrappedAnyPointer,\n            PreviousToQualsIncludeConst, ObjCLifetimeConversion))\n      return false;\n    UnwrappedAnyPointer = true;\n  }\n\n  // We are left with FromType and ToType being the pointee types\n  // after unwrapping the original FromType and ToType the same number\n  // of times. If we unwrapped any pointers, and if FromType and\n  // ToType have the same unqualified type (since we checked\n  // qualifiers above), then this is a qualification conversion.\n  return UnwrappedAnyPointer && Context.hasSameUnqualifiedType(FromType,ToType);\n}\n\n/// - Determine whether this is a conversion from a scalar type to an\n/// atomic type.\n///\n/// If successful, updates \\c SCS's second and third steps in the conversion\n/// sequence to finish the conversion.\nstatic bool tryAtomicConversion(Sema &S, Expr *From, QualType ToType,\n                                bool InOverloadResolution,\n                                StandardConversionSequence &SCS,\n                                bool CStyle) {\n  const AtomicType *ToAtomic = ToType->getAs<AtomicType>();\n  if (!ToAtomic)\n    return false;\n\n  StandardConversionSequence InnerSCS;\n  if (!IsStandardConversion(S, From, ToAtomic->getValueType(),\n                            InOverloadResolution, InnerSCS,\n                            CStyle, /*AllowObjCWritebackConversion=*/false))\n    return false;\n\n  SCS.Second = InnerSCS.Second;\n  SCS.setToType(1, InnerSCS.getToType(1));\n  SCS.Third = InnerSCS.Third;\n  SCS.QualificationIncludesObjCLifetime\n    = InnerSCS.QualificationIncludesObjCLifetime;\n  SCS.setToType(2, InnerSCS.getToType(2));\n  return true;\n}\n\nstatic bool isFirstArgumentCompatibleWithType(ASTContext &Context,\n                                              CXXConstructorDecl *Constructor,\n                                              QualType Type) {\n  const auto *CtorType = Constructor->getType()->castAs<FunctionProtoType>();\n  if (CtorType->getNumParams() > 0) {\n    QualType FirstArg = CtorType->getParamType(0);\n    if (Context.hasSameUnqualifiedType(Type, FirstArg.getNonReferenceType()))\n      return true;\n  }\n  return false;\n}\n\nstatic OverloadingResult\nIsInitializerListConstructorConversion(Sema &S, Expr *From, QualType ToType,\n                                       CXXRecordDecl *To,\n                                       UserDefinedConversionSequence &User,\n                                       OverloadCandidateSet &CandidateSet,\n                                       bool AllowExplicit) {\n  CandidateSet.clear(OverloadCandidateSet::CSK_InitByUserDefinedConversion);\n  for (auto *D : S.LookupConstructors(To)) {\n    auto Info = getConstructorInfo(D);\n    if (!Info)\n      continue;\n\n    bool Usable = !Info.Constructor->isInvalidDecl() &&\n                  S.isInitListConstructor(Info.Constructor);\n    if (Usable) {\n      // If the first argument is (a reference to) the target type,\n      // suppress conversions.\n      bool SuppressUserConversions = isFirstArgumentCompatibleWithType(\n          S.Context, Info.Constructor, ToType);\n      if (Info.ConstructorTmpl)\n        S.AddTemplateOverloadCandidate(Info.ConstructorTmpl, Info.FoundDecl,\n                                       /*ExplicitArgs*/ nullptr, From,\n                                       CandidateSet, SuppressUserConversions,\n                                       /*PartialOverloading*/ false,\n                                       AllowExplicit);\n      else\n        S.AddOverloadCandidate(Info.Constructor, Info.FoundDecl, From,\n                               CandidateSet, SuppressUserConversions,\n                               /*PartialOverloading*/ false, AllowExplicit);\n    }\n  }\n\n  bool HadMultipleCandidates = (CandidateSet.size() > 1);\n\n  OverloadCandidateSet::iterator Best;\n  switch (auto Result =\n              CandidateSet.BestViableFunction(S, From->getBeginLoc(), Best)) {\n  case OR_Deleted:\n  case OR_Success: {\n    // Record the standard conversion we used and the conversion function.\n    CXXConstructorDecl *Constructor = cast<CXXConstructorDecl>(Best->Function);\n    QualType ThisType = Constructor->getThisType();\n    // Initializer lists don't have conversions as such.\n    User.Before.setAsIdentityConversion();\n    User.HadMultipleCandidates = HadMultipleCandidates;\n    User.ConversionFunction = Constructor;\n    User.FoundConversionFunction = Best->FoundDecl;\n    User.After.setAsIdentityConversion();\n    User.After.setFromType(ThisType->castAs<PointerType>()->getPointeeType());\n    User.After.setAllToTypes(ToType);\n    return Result;\n  }\n\n  case OR_No_Viable_Function:\n    return OR_No_Viable_Function;\n  case OR_Ambiguous:\n    return OR_Ambiguous;\n  }\n\n  llvm_unreachable(\"Invalid OverloadResult!\");\n}\n\n/// Determines whether there is a user-defined conversion sequence\n/// (C++ [over.ics.user]) that converts expression From to the type\n/// ToType. If such a conversion exists, User will contain the\n/// user-defined conversion sequence that performs such a conversion\n/// and this routine will return true. Otherwise, this routine returns\n/// false and User is unspecified.\n///\n/// \\param AllowExplicit  true if the conversion should consider C++0x\n/// \"explicit\" conversion functions as well as non-explicit conversion\n/// functions (C++0x [class.conv.fct]p2).\n///\n/// \\param AllowObjCConversionOnExplicit true if the conversion should\n/// allow an extra Objective-C pointer conversion on uses of explicit\n/// constructors. Requires \\c AllowExplicit to also be set.\nstatic OverloadingResult\nIsUserDefinedConversion(Sema &S, Expr *From, QualType ToType,\n                        UserDefinedConversionSequence &User,\n                        OverloadCandidateSet &CandidateSet,\n                        AllowedExplicit AllowExplicit,\n                        bool AllowObjCConversionOnExplicit) {\n  assert(AllowExplicit != AllowedExplicit::None ||\n         !AllowObjCConversionOnExplicit);\n  CandidateSet.clear(OverloadCandidateSet::CSK_InitByUserDefinedConversion);\n\n  // Whether we will only visit constructors.\n  bool ConstructorsOnly = false;\n\n  // If the type we are conversion to is a class type, enumerate its\n  // constructors.\n  if (const RecordType *ToRecordType = ToType->getAs<RecordType>()) {\n    // C++ [over.match.ctor]p1:\n    //   When objects of class type are direct-initialized (8.5), or\n    //   copy-initialized from an expression of the same or a\n    //   derived class type (8.5), overload resolution selects the\n    //   constructor. [...] For copy-initialization, the candidate\n    //   functions are all the converting constructors (12.3.1) of\n    //   that class. The argument list is the expression-list within\n    //   the parentheses of the initializer.\n    if (S.Context.hasSameUnqualifiedType(ToType, From->getType()) ||\n        (From->getType()->getAs<RecordType>() &&\n         S.IsDerivedFrom(From->getBeginLoc(), From->getType(), ToType)))\n      ConstructorsOnly = true;\n\n    if (!S.isCompleteType(From->getExprLoc(), ToType)) {\n      // We're not going to find any constructors.\n    } else if (CXXRecordDecl *ToRecordDecl\n                 = dyn_cast<CXXRecordDecl>(ToRecordType->getDecl())) {\n\n      Expr **Args = &From;\n      unsigned NumArgs = 1;\n      bool ListInitializing = false;\n      if (InitListExpr *InitList = dyn_cast<InitListExpr>(From)) {\n        // But first, see if there is an init-list-constructor that will work.\n        OverloadingResult Result = IsInitializerListConstructorConversion(\n            S, From, ToType, ToRecordDecl, User, CandidateSet,\n            AllowExplicit == AllowedExplicit::All);\n        if (Result != OR_No_Viable_Function)\n          return Result;\n        // Never mind.\n        CandidateSet.clear(\n            OverloadCandidateSet::CSK_InitByUserDefinedConversion);\n\n        // If we're list-initializing, we pass the individual elements as\n        // arguments, not the entire list.\n        Args = InitList->getInits();\n        NumArgs = InitList->getNumInits();\n        ListInitializing = true;\n      }\n\n      for (auto *D : S.LookupConstructors(ToRecordDecl)) {\n        auto Info = getConstructorInfo(D);\n        if (!Info)\n          continue;\n\n        bool Usable = !Info.Constructor->isInvalidDecl();\n        if (!ListInitializing)\n          Usable = Usable && Info.Constructor->isConvertingConstructor(\n                                 /*AllowExplicit*/ true);\n        if (Usable) {\n          bool SuppressUserConversions = !ConstructorsOnly;\n          if (SuppressUserConversions && ListInitializing) {\n            SuppressUserConversions = false;\n            if (NumArgs == 1) {\n              // If the first argument is (a reference to) the target type,\n              // suppress conversions.\n              SuppressUserConversions = isFirstArgumentCompatibleWithType(\n                  S.Context, Info.Constructor, ToType);\n            }\n          }\n          if (Info.ConstructorTmpl)\n            S.AddTemplateOverloadCandidate(\n                Info.ConstructorTmpl, Info.FoundDecl,\n                /*ExplicitArgs*/ nullptr, llvm::makeArrayRef(Args, NumArgs),\n                CandidateSet, SuppressUserConversions,\n                /*PartialOverloading*/ false,\n                AllowExplicit == AllowedExplicit::All);\n          else\n            // Allow one user-defined conversion when user specifies a\n            // From->ToType conversion via an static cast (c-style, etc).\n            S.AddOverloadCandidate(Info.Constructor, Info.FoundDecl,\n                                   llvm::makeArrayRef(Args, NumArgs),\n                                   CandidateSet, SuppressUserConversions,\n                                   /*PartialOverloading*/ false,\n                                   AllowExplicit == AllowedExplicit::All);\n        }\n      }\n    }\n  }\n\n  // Enumerate conversion functions, if we're allowed to.\n  if (ConstructorsOnly || isa<InitListExpr>(From)) {\n  } else if (!S.isCompleteType(From->getBeginLoc(), From->getType())) {\n    // No conversion functions from incomplete types.\n  } else if (const RecordType *FromRecordType =\n                 From->getType()->getAs<RecordType>()) {\n    if (CXXRecordDecl *FromRecordDecl\n         = dyn_cast<CXXRecordDecl>(FromRecordType->getDecl())) {\n      // Add all of the conversion functions as candidates.\n      const auto &Conversions = FromRecordDecl->getVisibleConversionFunctions();\n      for (auto I = Conversions.begin(), E = Conversions.end(); I != E; ++I) {\n        DeclAccessPair FoundDecl = I.getPair();\n        NamedDecl *D = FoundDecl.getDecl();\n        CXXRecordDecl *ActingContext = cast<CXXRecordDecl>(D->getDeclContext());\n        if (isa<UsingShadowDecl>(D))\n          D = cast<UsingShadowDecl>(D)->getTargetDecl();\n\n        CXXConversionDecl *Conv;\n        FunctionTemplateDecl *ConvTemplate;\n        if ((ConvTemplate = dyn_cast<FunctionTemplateDecl>(D)))\n          Conv = cast<CXXConversionDecl>(ConvTemplate->getTemplatedDecl());\n        else\n          Conv = cast<CXXConversionDecl>(D);\n\n        if (ConvTemplate)\n          S.AddTemplateConversionCandidate(\n              ConvTemplate, FoundDecl, ActingContext, From, ToType,\n              CandidateSet, AllowObjCConversionOnExplicit,\n              AllowExplicit != AllowedExplicit::None);\n        else\n          S.AddConversionCandidate(Conv, FoundDecl, ActingContext, From, ToType,\n                                   CandidateSet, AllowObjCConversionOnExplicit,\n                                   AllowExplicit != AllowedExplicit::None);\n      }\n    }\n  }\n\n  bool HadMultipleCandidates = (CandidateSet.size() > 1);\n\n  OverloadCandidateSet::iterator Best;\n  switch (auto Result =\n              CandidateSet.BestViableFunction(S, From->getBeginLoc(), Best)) {\n  case OR_Success:\n  case OR_Deleted:\n    // Record the standard conversion we used and the conversion function.\n    if (CXXConstructorDecl *Constructor\n          = dyn_cast<CXXConstructorDecl>(Best->Function)) {\n      // C++ [over.ics.user]p1:\n      //   If the user-defined conversion is specified by a\n      //   constructor (12.3.1), the initial standard conversion\n      //   sequence converts the source type to the type required by\n      //   the argument of the constructor.\n      //\n      QualType ThisType = Constructor->getThisType();\n      if (isa<InitListExpr>(From)) {\n        // Initializer lists don't have conversions as such.\n        User.Before.setAsIdentityConversion();\n      } else {\n        if (Best->Conversions[0].isEllipsis())\n          User.EllipsisConversion = true;\n        else {\n          User.Before = Best->Conversions[0].Standard;\n          User.EllipsisConversion = false;\n        }\n      }\n      User.HadMultipleCandidates = HadMultipleCandidates;\n      User.ConversionFunction = Constructor;\n      User.FoundConversionFunction = Best->FoundDecl;\n      User.After.setAsIdentityConversion();\n      User.After.setFromType(ThisType->castAs<PointerType>()->getPointeeType());\n      User.After.setAllToTypes(ToType);\n      return Result;\n    }\n    if (CXXConversionDecl *Conversion\n                 = dyn_cast<CXXConversionDecl>(Best->Function)) {\n      // C++ [over.ics.user]p1:\n      //\n      //   [...] If the user-defined conversion is specified by a\n      //   conversion function (12.3.2), the initial standard\n      //   conversion sequence converts the source type to the\n      //   implicit object parameter of the conversion function.\n      User.Before = Best->Conversions[0].Standard;\n      User.HadMultipleCandidates = HadMultipleCandidates;\n      User.ConversionFunction = Conversion;\n      User.FoundConversionFunction = Best->FoundDecl;\n      User.EllipsisConversion = false;\n\n      // C++ [over.ics.user]p2:\n      //   The second standard conversion sequence converts the\n      //   result of the user-defined conversion to the target type\n      //   for the sequence. Since an implicit conversion sequence\n      //   is an initialization, the special rules for\n      //   initialization by user-defined conversion apply when\n      //   selecting the best user-defined conversion for a\n      //   user-defined conversion sequence (see 13.3.3 and\n      //   13.3.3.1).\n      User.After = Best->FinalConversion;\n      return Result;\n    }\n    llvm_unreachable(\"Not a constructor or conversion function?\");\n\n  case OR_No_Viable_Function:\n    return OR_No_Viable_Function;\n\n  case OR_Ambiguous:\n    return OR_Ambiguous;\n  }\n\n  llvm_unreachable(\"Invalid OverloadResult!\");\n}\n\nbool\nSema::DiagnoseMultipleUserDefinedConversion(Expr *From, QualType ToType) {\n  ImplicitConversionSequence ICS;\n  OverloadCandidateSet CandidateSet(From->getExprLoc(),\n                                    OverloadCandidateSet::CSK_Normal);\n  OverloadingResult OvResult =\n    IsUserDefinedConversion(*this, From, ToType, ICS.UserDefined,\n                            CandidateSet, AllowedExplicit::None, false);\n\n  if (!(OvResult == OR_Ambiguous ||\n        (OvResult == OR_No_Viable_Function && !CandidateSet.empty())))\n    return false;\n\n  auto Cands = CandidateSet.CompleteCandidates(\n      *this,\n      OvResult == OR_Ambiguous ? OCD_AmbiguousCandidates : OCD_AllCandidates,\n      From);\n  if (OvResult == OR_Ambiguous)\n    Diag(From->getBeginLoc(), diag::err_typecheck_ambiguous_condition)\n        << From->getType() << ToType << From->getSourceRange();\n  else { // OR_No_Viable_Function && !CandidateSet.empty()\n    if (!RequireCompleteType(From->getBeginLoc(), ToType,\n                             diag::err_typecheck_nonviable_condition_incomplete,\n                             From->getType(), From->getSourceRange()))\n      Diag(From->getBeginLoc(), diag::err_typecheck_nonviable_condition)\n          << false << From->getType() << From->getSourceRange() << ToType;\n  }\n\n  CandidateSet.NoteCandidates(\n                              *this, From, Cands);\n  return true;\n}\n\n// Helper for compareConversionFunctions that gets the FunctionType that the\n// conversion-operator return  value 'points' to, or nullptr.\nstatic const FunctionType *\ngetConversionOpReturnTyAsFunction(CXXConversionDecl *Conv) {\n  const FunctionType *ConvFuncTy = Conv->getType()->castAs<FunctionType>();\n  const PointerType *RetPtrTy =\n      ConvFuncTy->getReturnType()->getAs<PointerType>();\n\n  if (!RetPtrTy)\n    return nullptr;\n\n  return RetPtrTy->getPointeeType()->getAs<FunctionType>();\n}\n\n/// Compare the user-defined conversion functions or constructors\n/// of two user-defined conversion sequences to determine whether any ordering\n/// is possible.\nstatic ImplicitConversionSequence::CompareKind\ncompareConversionFunctions(Sema &S, FunctionDecl *Function1,\n                           FunctionDecl *Function2) {\n  CXXConversionDecl *Conv1 = dyn_cast_or_null<CXXConversionDecl>(Function1);\n  CXXConversionDecl *Conv2 = dyn_cast_or_null<CXXConversionDecl>(Function2);\n  if (!Conv1 || !Conv2)\n    return ImplicitConversionSequence::Indistinguishable;\n\n  if (!Conv1->getParent()->isLambda() || !Conv2->getParent()->isLambda())\n    return ImplicitConversionSequence::Indistinguishable;\n\n  // Objective-C++:\n  //   If both conversion functions are implicitly-declared conversions from\n  //   a lambda closure type to a function pointer and a block pointer,\n  //   respectively, always prefer the conversion to a function pointer,\n  //   because the function pointer is more lightweight and is more likely\n  //   to keep code working.\n  if (S.getLangOpts().ObjC && S.getLangOpts().CPlusPlus11) {\n    bool Block1 = Conv1->getConversionType()->isBlockPointerType();\n    bool Block2 = Conv2->getConversionType()->isBlockPointerType();\n    if (Block1 != Block2)\n      return Block1 ? ImplicitConversionSequence::Worse\n                    : ImplicitConversionSequence::Better;\n  }\n\n  // In order to support multiple calling conventions for the lambda conversion\n  // operator (such as when the free and member function calling convention is\n  // different), prefer the 'free' mechanism, followed by the calling-convention\n  // of operator(). The latter is in place to support the MSVC-like solution of\n  // defining ALL of the possible conversions in regards to calling-convention.\n  const FunctionType *Conv1FuncRet = getConversionOpReturnTyAsFunction(Conv1);\n  const FunctionType *Conv2FuncRet = getConversionOpReturnTyAsFunction(Conv2);\n\n  if (Conv1FuncRet && Conv2FuncRet &&\n      Conv1FuncRet->getCallConv() != Conv2FuncRet->getCallConv()) {\n    CallingConv Conv1CC = Conv1FuncRet->getCallConv();\n    CallingConv Conv2CC = Conv2FuncRet->getCallConv();\n\n    CXXMethodDecl *CallOp = Conv2->getParent()->getLambdaCallOperator();\n    const FunctionProtoType *CallOpProto =\n        CallOp->getType()->getAs<FunctionProtoType>();\n\n    CallingConv CallOpCC =\n        CallOp->getType()->getAs<FunctionType>()->getCallConv();\n    CallingConv DefaultFree = S.Context.getDefaultCallingConvention(\n        CallOpProto->isVariadic(), /*IsCXXMethod=*/false);\n    CallingConv DefaultMember = S.Context.getDefaultCallingConvention(\n        CallOpProto->isVariadic(), /*IsCXXMethod=*/true);\n\n    CallingConv PrefOrder[] = {DefaultFree, DefaultMember, CallOpCC};\n    for (CallingConv CC : PrefOrder) {\n      if (Conv1CC == CC)\n        return ImplicitConversionSequence::Better;\n      if (Conv2CC == CC)\n        return ImplicitConversionSequence::Worse;\n    }\n  }\n\n  return ImplicitConversionSequence::Indistinguishable;\n}\n\nstatic bool hasDeprecatedStringLiteralToCharPtrConversion(\n    const ImplicitConversionSequence &ICS) {\n  return (ICS.isStandard() && ICS.Standard.DeprecatedStringLiteralToCharPtr) ||\n         (ICS.isUserDefined() &&\n          ICS.UserDefined.Before.DeprecatedStringLiteralToCharPtr);\n}\n\n/// CompareImplicitConversionSequences - Compare two implicit\n/// conversion sequences to determine whether one is better than the\n/// other or if they are indistinguishable (C++ 13.3.3.2).\nstatic ImplicitConversionSequence::CompareKind\nCompareImplicitConversionSequences(Sema &S, SourceLocation Loc,\n                                   const ImplicitConversionSequence& ICS1,\n                                   const ImplicitConversionSequence& ICS2)\n{\n  // (C++ 13.3.3.2p2): When comparing the basic forms of implicit\n  // conversion sequences (as defined in 13.3.3.1)\n  //   -- a standard conversion sequence (13.3.3.1.1) is a better\n  //      conversion sequence than a user-defined conversion sequence or\n  //      an ellipsis conversion sequence, and\n  //   -- a user-defined conversion sequence (13.3.3.1.2) is a better\n  //      conversion sequence than an ellipsis conversion sequence\n  //      (13.3.3.1.3).\n  //\n  // C++0x [over.best.ics]p10:\n  //   For the purpose of ranking implicit conversion sequences as\n  //   described in 13.3.3.2, the ambiguous conversion sequence is\n  //   treated as a user-defined sequence that is indistinguishable\n  //   from any other user-defined conversion sequence.\n\n  // String literal to 'char *' conversion has been deprecated in C++03. It has\n  // been removed from C++11. We still accept this conversion, if it happens at\n  // the best viable function. Otherwise, this conversion is considered worse\n  // than ellipsis conversion. Consider this as an extension; this is not in the\n  // standard. For example:\n  //\n  // int &f(...);    // #1\n  // void f(char*);  // #2\n  // void g() { int &r = f(\"foo\"); }\n  //\n  // In C++03, we pick #2 as the best viable function.\n  // In C++11, we pick #1 as the best viable function, because ellipsis\n  // conversion is better than string-literal to char* conversion (since there\n  // is no such conversion in C++11). If there was no #1 at all or #1 couldn't\n  // convert arguments, #2 would be the best viable function in C++11.\n  // If the best viable function has this conversion, a warning will be issued\n  // in C++03, or an ExtWarn (+SFINAE failure) will be issued in C++11.\n\n  if (S.getLangOpts().CPlusPlus11 && !S.getLangOpts().WritableStrings &&\n      hasDeprecatedStringLiteralToCharPtrConversion(ICS1) !=\n      hasDeprecatedStringLiteralToCharPtrConversion(ICS2))\n    return hasDeprecatedStringLiteralToCharPtrConversion(ICS1)\n               ? ImplicitConversionSequence::Worse\n               : ImplicitConversionSequence::Better;\n\n  if (ICS1.getKindRank() < ICS2.getKindRank())\n    return ImplicitConversionSequence::Better;\n  if (ICS2.getKindRank() < ICS1.getKindRank())\n    return ImplicitConversionSequence::Worse;\n\n  // The following checks require both conversion sequences to be of\n  // the same kind.\n  if (ICS1.getKind() != ICS2.getKind())\n    return ImplicitConversionSequence::Indistinguishable;\n\n  ImplicitConversionSequence::CompareKind Result =\n      ImplicitConversionSequence::Indistinguishable;\n\n  // Two implicit conversion sequences of the same form are\n  // indistinguishable conversion sequences unless one of the\n  // following rules apply: (C++ 13.3.3.2p3):\n\n  // List-initialization sequence L1 is a better conversion sequence than\n  // list-initialization sequence L2 if:\n  // - L1 converts to std::initializer_list<X> for some X and L2 does not, or,\n  //   if not that,\n  // - L1 converts to type \"array of N1 T\", L2 converts to type \"array of N2 T\",\n  //   and N1 is smaller than N2.,\n  // even if one of the other rules in this paragraph would otherwise apply.\n  if (!ICS1.isBad()) {\n    if (ICS1.isStdInitializerListElement() &&\n        !ICS2.isStdInitializerListElement())\n      return ImplicitConversionSequence::Better;\n    if (!ICS1.isStdInitializerListElement() &&\n        ICS2.isStdInitializerListElement())\n      return ImplicitConversionSequence::Worse;\n  }\n\n  if (ICS1.isStandard())\n    // Standard conversion sequence S1 is a better conversion sequence than\n    // standard conversion sequence S2 if [...]\n    Result = CompareStandardConversionSequences(S, Loc,\n                                                ICS1.Standard, ICS2.Standard);\n  else if (ICS1.isUserDefined()) {\n    // User-defined conversion sequence U1 is a better conversion\n    // sequence than another user-defined conversion sequence U2 if\n    // they contain the same user-defined conversion function or\n    // constructor and if the second standard conversion sequence of\n    // U1 is better than the second standard conversion sequence of\n    // U2 (C++ 13.3.3.2p3).\n    if (ICS1.UserDefined.ConversionFunction ==\n          ICS2.UserDefined.ConversionFunction)\n      Result = CompareStandardConversionSequences(S, Loc,\n                                                  ICS1.UserDefined.After,\n                                                  ICS2.UserDefined.After);\n    else\n      Result = compareConversionFunctions(S,\n                                          ICS1.UserDefined.ConversionFunction,\n                                          ICS2.UserDefined.ConversionFunction);\n  }\n\n  return Result;\n}\n\n// Per 13.3.3.2p3, compare the given standard conversion sequences to\n// determine if one is a proper subset of the other.\nstatic ImplicitConversionSequence::CompareKind\ncompareStandardConversionSubsets(ASTContext &Context,\n                                 const StandardConversionSequence& SCS1,\n                                 const StandardConversionSequence& SCS2) {\n  ImplicitConversionSequence::CompareKind Result\n    = ImplicitConversionSequence::Indistinguishable;\n\n  // the identity conversion sequence is considered to be a subsequence of\n  // any non-identity conversion sequence\n  if (SCS1.isIdentityConversion() && !SCS2.isIdentityConversion())\n    return ImplicitConversionSequence::Better;\n  else if (!SCS1.isIdentityConversion() && SCS2.isIdentityConversion())\n    return ImplicitConversionSequence::Worse;\n\n  if (SCS1.Second != SCS2.Second) {\n    if (SCS1.Second == ICK_Identity)\n      Result = ImplicitConversionSequence::Better;\n    else if (SCS2.Second == ICK_Identity)\n      Result = ImplicitConversionSequence::Worse;\n    else\n      return ImplicitConversionSequence::Indistinguishable;\n  } else if (!Context.hasSimilarType(SCS1.getToType(1), SCS2.getToType(1)))\n    return ImplicitConversionSequence::Indistinguishable;\n\n  if (SCS1.Third == SCS2.Third) {\n    return Context.hasSameType(SCS1.getToType(2), SCS2.getToType(2))? Result\n                             : ImplicitConversionSequence::Indistinguishable;\n  }\n\n  if (SCS1.Third == ICK_Identity)\n    return Result == ImplicitConversionSequence::Worse\n             ? ImplicitConversionSequence::Indistinguishable\n             : ImplicitConversionSequence::Better;\n\n  if (SCS2.Third == ICK_Identity)\n    return Result == ImplicitConversionSequence::Better\n             ? ImplicitConversionSequence::Indistinguishable\n             : ImplicitConversionSequence::Worse;\n\n  return ImplicitConversionSequence::Indistinguishable;\n}\n\n/// Determine whether one of the given reference bindings is better\n/// than the other based on what kind of bindings they are.\nstatic bool\nisBetterReferenceBindingKind(const StandardConversionSequence &SCS1,\n                             const StandardConversionSequence &SCS2) {\n  // C++0x [over.ics.rank]p3b4:\n  //   -- S1 and S2 are reference bindings (8.5.3) and neither refers to an\n  //      implicit object parameter of a non-static member function declared\n  //      without a ref-qualifier, and *either* S1 binds an rvalue reference\n  //      to an rvalue and S2 binds an lvalue reference *or S1 binds an\n  //      lvalue reference to a function lvalue and S2 binds an rvalue\n  //      reference*.\n  //\n  // FIXME: Rvalue references. We're going rogue with the above edits,\n  // because the semantics in the current C++0x working paper (N3225 at the\n  // time of this writing) break the standard definition of std::forward\n  // and std::reference_wrapper when dealing with references to functions.\n  // Proposed wording changes submitted to CWG for consideration.\n  if (SCS1.BindsImplicitObjectArgumentWithoutRefQualifier ||\n      SCS2.BindsImplicitObjectArgumentWithoutRefQualifier)\n    return false;\n\n  return (!SCS1.IsLvalueReference && SCS1.BindsToRvalue &&\n          SCS2.IsLvalueReference) ||\n         (SCS1.IsLvalueReference && SCS1.BindsToFunctionLvalue &&\n          !SCS2.IsLvalueReference && SCS2.BindsToFunctionLvalue);\n}\n\nenum class FixedEnumPromotion {\n  None,\n  ToUnderlyingType,\n  ToPromotedUnderlyingType\n};\n\n/// Returns kind of fixed enum promotion the \\a SCS uses.\nstatic FixedEnumPromotion\ngetFixedEnumPromtion(Sema &S, const StandardConversionSequence &SCS) {\n\n  if (SCS.Second != ICK_Integral_Promotion)\n    return FixedEnumPromotion::None;\n\n  QualType FromType = SCS.getFromType();\n  if (!FromType->isEnumeralType())\n    return FixedEnumPromotion::None;\n\n  EnumDecl *Enum = FromType->getAs<EnumType>()->getDecl();\n  if (!Enum->isFixed())\n    return FixedEnumPromotion::None;\n\n  QualType UnderlyingType = Enum->getIntegerType();\n  if (S.Context.hasSameType(SCS.getToType(1), UnderlyingType))\n    return FixedEnumPromotion::ToUnderlyingType;\n\n  return FixedEnumPromotion::ToPromotedUnderlyingType;\n}\n\n/// CompareStandardConversionSequences - Compare two standard\n/// conversion sequences to determine whether one is better than the\n/// other or if they are indistinguishable (C++ 13.3.3.2p3).\nstatic ImplicitConversionSequence::CompareKind\nCompareStandardConversionSequences(Sema &S, SourceLocation Loc,\n                                   const StandardConversionSequence& SCS1,\n                                   const StandardConversionSequence& SCS2)\n{\n  // Standard conversion sequence S1 is a better conversion sequence\n  // than standard conversion sequence S2 if (C++ 13.3.3.2p3):\n\n  //  -- S1 is a proper subsequence of S2 (comparing the conversion\n  //     sequences in the canonical form defined by 13.3.3.1.1,\n  //     excluding any Lvalue Transformation; the identity conversion\n  //     sequence is considered to be a subsequence of any\n  //     non-identity conversion sequence) or, if not that,\n  if (ImplicitConversionSequence::CompareKind CK\n        = compareStandardConversionSubsets(S.Context, SCS1, SCS2))\n    return CK;\n\n  //  -- the rank of S1 is better than the rank of S2 (by the rules\n  //     defined below), or, if not that,\n  ImplicitConversionRank Rank1 = SCS1.getRank();\n  ImplicitConversionRank Rank2 = SCS2.getRank();\n  if (Rank1 < Rank2)\n    return ImplicitConversionSequence::Better;\n  else if (Rank2 < Rank1)\n    return ImplicitConversionSequence::Worse;\n\n  // (C++ 13.3.3.2p4): Two conversion sequences with the same rank\n  // are indistinguishable unless one of the following rules\n  // applies:\n\n  //   A conversion that is not a conversion of a pointer, or\n  //   pointer to member, to bool is better than another conversion\n  //   that is such a conversion.\n  if (SCS1.isPointerConversionToBool() != SCS2.isPointerConversionToBool())\n    return SCS2.isPointerConversionToBool()\n             ? ImplicitConversionSequence::Better\n             : ImplicitConversionSequence::Worse;\n\n  // C++14 [over.ics.rank]p4b2:\n  // This is retroactively applied to C++11 by CWG 1601.\n  //\n  //   A conversion that promotes an enumeration whose underlying type is fixed\n  //   to its underlying type is better than one that promotes to the promoted\n  //   underlying type, if the two are different.\n  FixedEnumPromotion FEP1 = getFixedEnumPromtion(S, SCS1);\n  FixedEnumPromotion FEP2 = getFixedEnumPromtion(S, SCS2);\n  if (FEP1 != FixedEnumPromotion::None && FEP2 != FixedEnumPromotion::None &&\n      FEP1 != FEP2)\n    return FEP1 == FixedEnumPromotion::ToUnderlyingType\n               ? ImplicitConversionSequence::Better\n               : ImplicitConversionSequence::Worse;\n\n  // C++ [over.ics.rank]p4b2:\n  //\n  //   If class B is derived directly or indirectly from class A,\n  //   conversion of B* to A* is better than conversion of B* to\n  //   void*, and conversion of A* to void* is better than conversion\n  //   of B* to void*.\n  bool SCS1ConvertsToVoid\n    = SCS1.isPointerConversionToVoidPointer(S.Context);\n  bool SCS2ConvertsToVoid\n    = SCS2.isPointerConversionToVoidPointer(S.Context);\n  if (SCS1ConvertsToVoid != SCS2ConvertsToVoid) {\n    // Exactly one of the conversion sequences is a conversion to\n    // a void pointer; it's the worse conversion.\n    return SCS2ConvertsToVoid ? ImplicitConversionSequence::Better\n                              : ImplicitConversionSequence::Worse;\n  } else if (!SCS1ConvertsToVoid && !SCS2ConvertsToVoid) {\n    // Neither conversion sequence converts to a void pointer; compare\n    // their derived-to-base conversions.\n    if (ImplicitConversionSequence::CompareKind DerivedCK\n          = CompareDerivedToBaseConversions(S, Loc, SCS1, SCS2))\n      return DerivedCK;\n  } else if (SCS1ConvertsToVoid && SCS2ConvertsToVoid &&\n             !S.Context.hasSameType(SCS1.getFromType(), SCS2.getFromType())) {\n    // Both conversion sequences are conversions to void\n    // pointers. Compare the source types to determine if there's an\n    // inheritance relationship in their sources.\n    QualType FromType1 = SCS1.getFromType();\n    QualType FromType2 = SCS2.getFromType();\n\n    // Adjust the types we're converting from via the array-to-pointer\n    // conversion, if we need to.\n    if (SCS1.First == ICK_Array_To_Pointer)\n      FromType1 = S.Context.getArrayDecayedType(FromType1);\n    if (SCS2.First == ICK_Array_To_Pointer)\n      FromType2 = S.Context.getArrayDecayedType(FromType2);\n\n    QualType FromPointee1 = FromType1->getPointeeType().getUnqualifiedType();\n    QualType FromPointee2 = FromType2->getPointeeType().getUnqualifiedType();\n\n    if (S.IsDerivedFrom(Loc, FromPointee2, FromPointee1))\n      return ImplicitConversionSequence::Better;\n    else if (S.IsDerivedFrom(Loc, FromPointee1, FromPointee2))\n      return ImplicitConversionSequence::Worse;\n\n    // Objective-C++: If one interface is more specific than the\n    // other, it is the better one.\n    const ObjCObjectPointerType* FromObjCPtr1\n      = FromType1->getAs<ObjCObjectPointerType>();\n    const ObjCObjectPointerType* FromObjCPtr2\n      = FromType2->getAs<ObjCObjectPointerType>();\n    if (FromObjCPtr1 && FromObjCPtr2) {\n      bool AssignLeft = S.Context.canAssignObjCInterfaces(FromObjCPtr1,\n                                                          FromObjCPtr2);\n      bool AssignRight = S.Context.canAssignObjCInterfaces(FromObjCPtr2,\n                                                           FromObjCPtr1);\n      if (AssignLeft != AssignRight) {\n        return AssignLeft? ImplicitConversionSequence::Better\n                         : ImplicitConversionSequence::Worse;\n      }\n    }\n  }\n\n  if (SCS1.ReferenceBinding && SCS2.ReferenceBinding) {\n    // Check for a better reference binding based on the kind of bindings.\n    if (isBetterReferenceBindingKind(SCS1, SCS2))\n      return ImplicitConversionSequence::Better;\n    else if (isBetterReferenceBindingKind(SCS2, SCS1))\n      return ImplicitConversionSequence::Worse;\n  }\n\n  // Compare based on qualification conversions (C++ 13.3.3.2p3,\n  // bullet 3).\n  if (ImplicitConversionSequence::CompareKind QualCK\n        = CompareQualificationConversions(S, SCS1, SCS2))\n    return QualCK;\n\n  if (SCS1.ReferenceBinding && SCS2.ReferenceBinding) {\n    // C++ [over.ics.rank]p3b4:\n    //   -- S1 and S2 are reference bindings (8.5.3), and the types to\n    //      which the references refer are the same type except for\n    //      top-level cv-qualifiers, and the type to which the reference\n    //      initialized by S2 refers is more cv-qualified than the type\n    //      to which the reference initialized by S1 refers.\n    QualType T1 = SCS1.getToType(2);\n    QualType T2 = SCS2.getToType(2);\n    T1 = S.Context.getCanonicalType(T1);\n    T2 = S.Context.getCanonicalType(T2);\n    Qualifiers T1Quals, T2Quals;\n    QualType UnqualT1 = S.Context.getUnqualifiedArrayType(T1, T1Quals);\n    QualType UnqualT2 = S.Context.getUnqualifiedArrayType(T2, T2Quals);\n    if (UnqualT1 == UnqualT2) {\n      // Objective-C++ ARC: If the references refer to objects with different\n      // lifetimes, prefer bindings that don't change lifetime.\n      if (SCS1.ObjCLifetimeConversionBinding !=\n                                          SCS2.ObjCLifetimeConversionBinding) {\n        return SCS1.ObjCLifetimeConversionBinding\n                                           ? ImplicitConversionSequence::Worse\n                                           : ImplicitConversionSequence::Better;\n      }\n\n      // If the type is an array type, promote the element qualifiers to the\n      // type for comparison.\n      if (isa<ArrayType>(T1) && T1Quals)\n        T1 = S.Context.getQualifiedType(UnqualT1, T1Quals);\n      if (isa<ArrayType>(T2) && T2Quals)\n        T2 = S.Context.getQualifiedType(UnqualT2, T2Quals);\n      if (T2.isMoreQualifiedThan(T1))\n        return ImplicitConversionSequence::Better;\n      if (T1.isMoreQualifiedThan(T2))\n        return ImplicitConversionSequence::Worse;\n    }\n  }\n\n  // In Microsoft mode, prefer an integral conversion to a\n  // floating-to-integral conversion if the integral conversion\n  // is between types of the same size.\n  // For example:\n  // void f(float);\n  // void f(int);\n  // int main {\n  //    long a;\n  //    f(a);\n  // }\n  // Here, MSVC will call f(int) instead of generating a compile error\n  // as clang will do in standard mode.\n  if (S.getLangOpts().MSVCCompat && SCS1.Second == ICK_Integral_Conversion &&\n      SCS2.Second == ICK_Floating_Integral &&\n      S.Context.getTypeSize(SCS1.getFromType()) ==\n          S.Context.getTypeSize(SCS1.getToType(2)))\n    return ImplicitConversionSequence::Better;\n\n  // Prefer a compatible vector conversion over a lax vector conversion\n  // For example:\n  //\n  // typedef float __v4sf __attribute__((__vector_size__(16)));\n  // void f(vector float);\n  // void f(vector signed int);\n  // int main() {\n  //   __v4sf a;\n  //   f(a);\n  // }\n  // Here, we'd like to choose f(vector float) and not\n  // report an ambiguous call error\n  if (SCS1.Second == ICK_Vector_Conversion &&\n      SCS2.Second == ICK_Vector_Conversion) {\n    bool SCS1IsCompatibleVectorConversion = S.Context.areCompatibleVectorTypes(\n        SCS1.getFromType(), SCS1.getToType(2));\n    bool SCS2IsCompatibleVectorConversion = S.Context.areCompatibleVectorTypes(\n        SCS2.getFromType(), SCS2.getToType(2));\n\n    if (SCS1IsCompatibleVectorConversion != SCS2IsCompatibleVectorConversion)\n      return SCS1IsCompatibleVectorConversion\n                 ? ImplicitConversionSequence::Better\n                 : ImplicitConversionSequence::Worse;\n  }\n\n  if (SCS1.Second == ICK_SVE_Vector_Conversion &&\n      SCS2.Second == ICK_SVE_Vector_Conversion) {\n    bool SCS1IsCompatibleSVEVectorConversion =\n        S.Context.areCompatibleSveTypes(SCS1.getFromType(), SCS1.getToType(2));\n    bool SCS2IsCompatibleSVEVectorConversion =\n        S.Context.areCompatibleSveTypes(SCS2.getFromType(), SCS2.getToType(2));\n\n    if (SCS1IsCompatibleSVEVectorConversion !=\n        SCS2IsCompatibleSVEVectorConversion)\n      return SCS1IsCompatibleSVEVectorConversion\n                 ? ImplicitConversionSequence::Better\n                 : ImplicitConversionSequence::Worse;\n  }\n\n  return ImplicitConversionSequence::Indistinguishable;\n}\n\n/// CompareQualificationConversions - Compares two standard conversion\n/// sequences to determine whether they can be ranked based on their\n/// qualification conversions (C++ 13.3.3.2p3 bullet 3).\nstatic ImplicitConversionSequence::CompareKind\nCompareQualificationConversions(Sema &S,\n                                const StandardConversionSequence& SCS1,\n                                const StandardConversionSequence& SCS2) {\n  // C++ 13.3.3.2p3:\n  //  -- S1 and S2 differ only in their qualification conversion and\n  //     yield similar types T1 and T2 (C++ 4.4), respectively, and the\n  //     cv-qualification signature of type T1 is a proper subset of\n  //     the cv-qualification signature of type T2, and S1 is not the\n  //     deprecated string literal array-to-pointer conversion (4.2).\n  if (SCS1.First != SCS2.First || SCS1.Second != SCS2.Second ||\n      SCS1.Third != SCS2.Third || SCS1.Third != ICK_Qualification)\n    return ImplicitConversionSequence::Indistinguishable;\n\n  // FIXME: the example in the standard doesn't use a qualification\n  // conversion (!)\n  QualType T1 = SCS1.getToType(2);\n  QualType T2 = SCS2.getToType(2);\n  T1 = S.Context.getCanonicalType(T1);\n  T2 = S.Context.getCanonicalType(T2);\n  assert(!T1->isReferenceType() && !T2->isReferenceType());\n  Qualifiers T1Quals, T2Quals;\n  QualType UnqualT1 = S.Context.getUnqualifiedArrayType(T1, T1Quals);\n  QualType UnqualT2 = S.Context.getUnqualifiedArrayType(T2, T2Quals);\n\n  // If the types are the same, we won't learn anything by unwrapping\n  // them.\n  if (UnqualT1 == UnqualT2)\n    return ImplicitConversionSequence::Indistinguishable;\n\n  ImplicitConversionSequence::CompareKind Result\n    = ImplicitConversionSequence::Indistinguishable;\n\n  // Objective-C++ ARC:\n  //   Prefer qualification conversions not involving a change in lifetime\n  //   to qualification conversions that do not change lifetime.\n  if (SCS1.QualificationIncludesObjCLifetime !=\n                                      SCS2.QualificationIncludesObjCLifetime) {\n    Result = SCS1.QualificationIncludesObjCLifetime\n               ? ImplicitConversionSequence::Worse\n               : ImplicitConversionSequence::Better;\n  }\n\n  while (S.Context.UnwrapSimilarTypes(T1, T2)) {\n    // Within each iteration of the loop, we check the qualifiers to\n    // determine if this still looks like a qualification\n    // conversion. Then, if all is well, we unwrap one more level of\n    // pointers or pointers-to-members and do it all again\n    // until there are no more pointers or pointers-to-members left\n    // to unwrap. This essentially mimics what\n    // IsQualificationConversion does, but here we're checking for a\n    // strict subset of qualifiers.\n    if (T1.getQualifiers().withoutObjCLifetime() ==\n        T2.getQualifiers().withoutObjCLifetime())\n      // The qualifiers are the same, so this doesn't tell us anything\n      // about how the sequences rank.\n      // ObjC ownership quals are omitted above as they interfere with\n      // the ARC overload rule.\n      ;\n    else if (T2.isMoreQualifiedThan(T1)) {\n      // T1 has fewer qualifiers, so it could be the better sequence.\n      if (Result == ImplicitConversionSequence::Worse)\n        // Neither has qualifiers that are a subset of the other's\n        // qualifiers.\n        return ImplicitConversionSequence::Indistinguishable;\n\n      Result = ImplicitConversionSequence::Better;\n    } else if (T1.isMoreQualifiedThan(T2)) {\n      // T2 has fewer qualifiers, so it could be the better sequence.\n      if (Result == ImplicitConversionSequence::Better)\n        // Neither has qualifiers that are a subset of the other's\n        // qualifiers.\n        return ImplicitConversionSequence::Indistinguishable;\n\n      Result = ImplicitConversionSequence::Worse;\n    } else {\n      // Qualifiers are disjoint.\n      return ImplicitConversionSequence::Indistinguishable;\n    }\n\n    // If the types after this point are equivalent, we're done.\n    if (S.Context.hasSameUnqualifiedType(T1, T2))\n      break;\n  }\n\n  // Check that the winning standard conversion sequence isn't using\n  // the deprecated string literal array to pointer conversion.\n  switch (Result) {\n  case ImplicitConversionSequence::Better:\n    if (SCS1.DeprecatedStringLiteralToCharPtr)\n      Result = ImplicitConversionSequence::Indistinguishable;\n    break;\n\n  case ImplicitConversionSequence::Indistinguishable:\n    break;\n\n  case ImplicitConversionSequence::Worse:\n    if (SCS2.DeprecatedStringLiteralToCharPtr)\n      Result = ImplicitConversionSequence::Indistinguishable;\n    break;\n  }\n\n  return Result;\n}\n\n/// CompareDerivedToBaseConversions - Compares two standard conversion\n/// sequences to determine whether they can be ranked based on their\n/// various kinds of derived-to-base conversions (C++\n/// [over.ics.rank]p4b3).  As part of these checks, we also look at\n/// conversions between Objective-C interface types.\nstatic ImplicitConversionSequence::CompareKind\nCompareDerivedToBaseConversions(Sema &S, SourceLocation Loc,\n                                const StandardConversionSequence& SCS1,\n                                const StandardConversionSequence& SCS2) {\n  QualType FromType1 = SCS1.getFromType();\n  QualType ToType1 = SCS1.getToType(1);\n  QualType FromType2 = SCS2.getFromType();\n  QualType ToType2 = SCS2.getToType(1);\n\n  // Adjust the types we're converting from via the array-to-pointer\n  // conversion, if we need to.\n  if (SCS1.First == ICK_Array_To_Pointer)\n    FromType1 = S.Context.getArrayDecayedType(FromType1);\n  if (SCS2.First == ICK_Array_To_Pointer)\n    FromType2 = S.Context.getArrayDecayedType(FromType2);\n\n  // Canonicalize all of the types.\n  FromType1 = S.Context.getCanonicalType(FromType1);\n  ToType1 = S.Context.getCanonicalType(ToType1);\n  FromType2 = S.Context.getCanonicalType(FromType2);\n  ToType2 = S.Context.getCanonicalType(ToType2);\n\n  // C++ [over.ics.rank]p4b3:\n  //\n  //   If class B is derived directly or indirectly from class A and\n  //   class C is derived directly or indirectly from B,\n  //\n  // Compare based on pointer conversions.\n  if (SCS1.Second == ICK_Pointer_Conversion &&\n      SCS2.Second == ICK_Pointer_Conversion &&\n      /*FIXME: Remove if Objective-C id conversions get their own rank*/\n      FromType1->isPointerType() && FromType2->isPointerType() &&\n      ToType1->isPointerType() && ToType2->isPointerType()) {\n    QualType FromPointee1 =\n        FromType1->castAs<PointerType>()->getPointeeType().getUnqualifiedType();\n    QualType ToPointee1 =\n        ToType1->castAs<PointerType>()->getPointeeType().getUnqualifiedType();\n    QualType FromPointee2 =\n        FromType2->castAs<PointerType>()->getPointeeType().getUnqualifiedType();\n    QualType ToPointee2 =\n        ToType2->castAs<PointerType>()->getPointeeType().getUnqualifiedType();\n\n    //   -- conversion of C* to B* is better than conversion of C* to A*,\n    if (FromPointee1 == FromPointee2 && ToPointee1 != ToPointee2) {\n      if (S.IsDerivedFrom(Loc, ToPointee1, ToPointee2))\n        return ImplicitConversionSequence::Better;\n      else if (S.IsDerivedFrom(Loc, ToPointee2, ToPointee1))\n        return ImplicitConversionSequence::Worse;\n    }\n\n    //   -- conversion of B* to A* is better than conversion of C* to A*,\n    if (FromPointee1 != FromPointee2 && ToPointee1 == ToPointee2) {\n      if (S.IsDerivedFrom(Loc, FromPointee2, FromPointee1))\n        return ImplicitConversionSequence::Better;\n      else if (S.IsDerivedFrom(Loc, FromPointee1, FromPointee2))\n        return ImplicitConversionSequence::Worse;\n    }\n  } else if (SCS1.Second == ICK_Pointer_Conversion &&\n             SCS2.Second == ICK_Pointer_Conversion) {\n    const ObjCObjectPointerType *FromPtr1\n      = FromType1->getAs<ObjCObjectPointerType>();\n    const ObjCObjectPointerType *FromPtr2\n      = FromType2->getAs<ObjCObjectPointerType>();\n    const ObjCObjectPointerType *ToPtr1\n      = ToType1->getAs<ObjCObjectPointerType>();\n    const ObjCObjectPointerType *ToPtr2\n      = ToType2->getAs<ObjCObjectPointerType>();\n\n    if (FromPtr1 && FromPtr2 && ToPtr1 && ToPtr2) {\n      // Apply the same conversion ranking rules for Objective-C pointer types\n      // that we do for C++ pointers to class types. However, we employ the\n      // Objective-C pseudo-subtyping relationship used for assignment of\n      // Objective-C pointer types.\n      bool FromAssignLeft\n        = S.Context.canAssignObjCInterfaces(FromPtr1, FromPtr2);\n      bool FromAssignRight\n        = S.Context.canAssignObjCInterfaces(FromPtr2, FromPtr1);\n      bool ToAssignLeft\n        = S.Context.canAssignObjCInterfaces(ToPtr1, ToPtr2);\n      bool ToAssignRight\n        = S.Context.canAssignObjCInterfaces(ToPtr2, ToPtr1);\n\n      // A conversion to an a non-id object pointer type or qualified 'id'\n      // type is better than a conversion to 'id'.\n      if (ToPtr1->isObjCIdType() &&\n          (ToPtr2->isObjCQualifiedIdType() || ToPtr2->getInterfaceDecl()))\n        return ImplicitConversionSequence::Worse;\n      if (ToPtr2->isObjCIdType() &&\n          (ToPtr1->isObjCQualifiedIdType() || ToPtr1->getInterfaceDecl()))\n        return ImplicitConversionSequence::Better;\n\n      // A conversion to a non-id object pointer type is better than a\n      // conversion to a qualified 'id' type\n      if (ToPtr1->isObjCQualifiedIdType() && ToPtr2->getInterfaceDecl())\n        return ImplicitConversionSequence::Worse;\n      if (ToPtr2->isObjCQualifiedIdType() && ToPtr1->getInterfaceDecl())\n        return ImplicitConversionSequence::Better;\n\n      // A conversion to an a non-Class object pointer type or qualified 'Class'\n      // type is better than a conversion to 'Class'.\n      if (ToPtr1->isObjCClassType() &&\n          (ToPtr2->isObjCQualifiedClassType() || ToPtr2->getInterfaceDecl()))\n        return ImplicitConversionSequence::Worse;\n      if (ToPtr2->isObjCClassType() &&\n          (ToPtr1->isObjCQualifiedClassType() || ToPtr1->getInterfaceDecl()))\n        return ImplicitConversionSequence::Better;\n\n      // A conversion to a non-Class object pointer type is better than a\n      // conversion to a qualified 'Class' type.\n      if (ToPtr1->isObjCQualifiedClassType() && ToPtr2->getInterfaceDecl())\n        return ImplicitConversionSequence::Worse;\n      if (ToPtr2->isObjCQualifiedClassType() && ToPtr1->getInterfaceDecl())\n        return ImplicitConversionSequence::Better;\n\n      //   -- \"conversion of C* to B* is better than conversion of C* to A*,\"\n      if (S.Context.hasSameType(FromType1, FromType2) &&\n          !FromPtr1->isObjCIdType() && !FromPtr1->isObjCClassType() &&\n          (ToAssignLeft != ToAssignRight)) {\n        if (FromPtr1->isSpecialized()) {\n          // \"conversion of B<A> * to B * is better than conversion of B * to\n          // C *.\n          bool IsFirstSame =\n              FromPtr1->getInterfaceDecl() == ToPtr1->getInterfaceDecl();\n          bool IsSecondSame =\n              FromPtr1->getInterfaceDecl() == ToPtr2->getInterfaceDecl();\n          if (IsFirstSame) {\n            if (!IsSecondSame)\n              return ImplicitConversionSequence::Better;\n          } else if (IsSecondSame)\n            return ImplicitConversionSequence::Worse;\n        }\n        return ToAssignLeft? ImplicitConversionSequence::Worse\n                           : ImplicitConversionSequence::Better;\n      }\n\n      //   -- \"conversion of B* to A* is better than conversion of C* to A*,\"\n      if (S.Context.hasSameUnqualifiedType(ToType1, ToType2) &&\n          (FromAssignLeft != FromAssignRight))\n        return FromAssignLeft? ImplicitConversionSequence::Better\n        : ImplicitConversionSequence::Worse;\n    }\n  }\n\n  // Ranking of member-pointer types.\n  if (SCS1.Second == ICK_Pointer_Member && SCS2.Second == ICK_Pointer_Member &&\n      FromType1->isMemberPointerType() && FromType2->isMemberPointerType() &&\n      ToType1->isMemberPointerType() && ToType2->isMemberPointerType()) {\n    const auto *FromMemPointer1 = FromType1->castAs<MemberPointerType>();\n    const auto *ToMemPointer1 = ToType1->castAs<MemberPointerType>();\n    const auto *FromMemPointer2 = FromType2->castAs<MemberPointerType>();\n    const auto *ToMemPointer2 = ToType2->castAs<MemberPointerType>();\n    const Type *FromPointeeType1 = FromMemPointer1->getClass();\n    const Type *ToPointeeType1 = ToMemPointer1->getClass();\n    const Type *FromPointeeType2 = FromMemPointer2->getClass();\n    const Type *ToPointeeType2 = ToMemPointer2->getClass();\n    QualType FromPointee1 = QualType(FromPointeeType1, 0).getUnqualifiedType();\n    QualType ToPointee1 = QualType(ToPointeeType1, 0).getUnqualifiedType();\n    QualType FromPointee2 = QualType(FromPointeeType2, 0).getUnqualifiedType();\n    QualType ToPointee2 = QualType(ToPointeeType2, 0).getUnqualifiedType();\n    // conversion of A::* to B::* is better than conversion of A::* to C::*,\n    if (FromPointee1 == FromPointee2 && ToPointee1 != ToPointee2) {\n      if (S.IsDerivedFrom(Loc, ToPointee1, ToPointee2))\n        return ImplicitConversionSequence::Worse;\n      else if (S.IsDerivedFrom(Loc, ToPointee2, ToPointee1))\n        return ImplicitConversionSequence::Better;\n    }\n    // conversion of B::* to C::* is better than conversion of A::* to C::*\n    if (ToPointee1 == ToPointee2 && FromPointee1 != FromPointee2) {\n      if (S.IsDerivedFrom(Loc, FromPointee1, FromPointee2))\n        return ImplicitConversionSequence::Better;\n      else if (S.IsDerivedFrom(Loc, FromPointee2, FromPointee1))\n        return ImplicitConversionSequence::Worse;\n    }\n  }\n\n  if (SCS1.Second == ICK_Derived_To_Base) {\n    //   -- conversion of C to B is better than conversion of C to A,\n    //   -- binding of an expression of type C to a reference of type\n    //      B& is better than binding an expression of type C to a\n    //      reference of type A&,\n    if (S.Context.hasSameUnqualifiedType(FromType1, FromType2) &&\n        !S.Context.hasSameUnqualifiedType(ToType1, ToType2)) {\n      if (S.IsDerivedFrom(Loc, ToType1, ToType2))\n        return ImplicitConversionSequence::Better;\n      else if (S.IsDerivedFrom(Loc, ToType2, ToType1))\n        return ImplicitConversionSequence::Worse;\n    }\n\n    //   -- conversion of B to A is better than conversion of C to A.\n    //   -- binding of an expression of type B to a reference of type\n    //      A& is better than binding an expression of type C to a\n    //      reference of type A&,\n    if (!S.Context.hasSameUnqualifiedType(FromType1, FromType2) &&\n        S.Context.hasSameUnqualifiedType(ToType1, ToType2)) {\n      if (S.IsDerivedFrom(Loc, FromType2, FromType1))\n        return ImplicitConversionSequence::Better;\n      else if (S.IsDerivedFrom(Loc, FromType1, FromType2))\n        return ImplicitConversionSequence::Worse;\n    }\n  }\n\n  return ImplicitConversionSequence::Indistinguishable;\n}\n\n/// Determine whether the given type is valid, e.g., it is not an invalid\n/// C++ class.\nstatic bool isTypeValid(QualType T) {\n  if (CXXRecordDecl *Record = T->getAsCXXRecordDecl())\n    return !Record->isInvalidDecl();\n\n  return true;\n}\n\nstatic QualType withoutUnaligned(ASTContext &Ctx, QualType T) {\n  if (!T.getQualifiers().hasUnaligned())\n    return T;\n\n  Qualifiers Q;\n  T = Ctx.getUnqualifiedArrayType(T, Q);\n  Q.removeUnaligned();\n  return Ctx.getQualifiedType(T, Q);\n}\n\n/// CompareReferenceRelationship - Compare the two types T1 and T2 to\n/// determine whether they are reference-compatible,\n/// reference-related, or incompatible, for use in C++ initialization by\n/// reference (C++ [dcl.ref.init]p4). Neither type can be a reference\n/// type, and the first type (T1) is the pointee type of the reference\n/// type being initialized.\nSema::ReferenceCompareResult\nSema::CompareReferenceRelationship(SourceLocation Loc,\n                                   QualType OrigT1, QualType OrigT2,\n                                   ReferenceConversions *ConvOut) {\n  assert(!OrigT1->isReferenceType() &&\n    \"T1 must be the pointee type of the reference type\");\n  assert(!OrigT2->isReferenceType() && \"T2 cannot be a reference type\");\n\n  QualType T1 = Context.getCanonicalType(OrigT1);\n  QualType T2 = Context.getCanonicalType(OrigT2);\n  Qualifiers T1Quals, T2Quals;\n  QualType UnqualT1 = Context.getUnqualifiedArrayType(T1, T1Quals);\n  QualType UnqualT2 = Context.getUnqualifiedArrayType(T2, T2Quals);\n\n  ReferenceConversions ConvTmp;\n  ReferenceConversions &Conv = ConvOut ? *ConvOut : ConvTmp;\n  Conv = ReferenceConversions();\n\n  // C++2a [dcl.init.ref]p4:\n  //   Given types \"cv1 T1\" and \"cv2 T2,\" \"cv1 T1\" is\n  //   reference-related to \"cv2 T2\" if T1 is similar to T2, or\n  //   T1 is a base class of T2.\n  //   \"cv1 T1\" is reference-compatible with \"cv2 T2\" if\n  //   a prvalue of type \"pointer to cv2 T2\" can be converted to the type\n  //   \"pointer to cv1 T1\" via a standard conversion sequence.\n\n  // Check for standard conversions we can apply to pointers: derived-to-base\n  // conversions, ObjC pointer conversions, and function pointer conversions.\n  // (Qualification conversions are checked last.)\n  QualType ConvertedT2;\n  if (UnqualT1 == UnqualT2) {\n    // Nothing to do.\n  } else if (isCompleteType(Loc, OrigT2) &&\n             isTypeValid(UnqualT1) && isTypeValid(UnqualT2) &&\n             IsDerivedFrom(Loc, UnqualT2, UnqualT1))\n    Conv |= ReferenceConversions::DerivedToBase;\n  else if (UnqualT1->isObjCObjectOrInterfaceType() &&\n           UnqualT2->isObjCObjectOrInterfaceType() &&\n           Context.canBindObjCObjectType(UnqualT1, UnqualT2))\n    Conv |= ReferenceConversions::ObjC;\n  else if (UnqualT2->isFunctionType() &&\n           IsFunctionConversion(UnqualT2, UnqualT1, ConvertedT2)) {\n    Conv |= ReferenceConversions::Function;\n    // No need to check qualifiers; function types don't have them.\n    return Ref_Compatible;\n  }\n  bool ConvertedReferent = Conv != 0;\n\n  // We can have a qualification conversion. Compute whether the types are\n  // similar at the same time.\n  bool PreviousToQualsIncludeConst = true;\n  bool TopLevel = true;\n  do {\n    if (T1 == T2)\n      break;\n\n    // We will need a qualification conversion.\n    Conv |= ReferenceConversions::Qualification;\n\n    // Track whether we performed a qualification conversion anywhere other\n    // than the top level. This matters for ranking reference bindings in\n    // overload resolution.\n    if (!TopLevel)\n      Conv |= ReferenceConversions::NestedQualification;\n\n    // MS compiler ignores __unaligned qualifier for references; do the same.\n    T1 = withoutUnaligned(Context, T1);\n    T2 = withoutUnaligned(Context, T2);\n\n    // If we find a qualifier mismatch, the types are not reference-compatible,\n    // but are still be reference-related if they're similar.\n    bool ObjCLifetimeConversion = false;\n    if (!isQualificationConversionStep(T2, T1, /*CStyle=*/false, TopLevel,\n                                       PreviousToQualsIncludeConst,\n                                       ObjCLifetimeConversion))\n      return (ConvertedReferent || Context.hasSimilarType(T1, T2))\n                 ? Ref_Related\n                 : Ref_Incompatible;\n\n    // FIXME: Should we track this for any level other than the first?\n    if (ObjCLifetimeConversion)\n      Conv |= ReferenceConversions::ObjCLifetime;\n\n    TopLevel = false;\n  } while (Context.UnwrapSimilarTypes(T1, T2));\n\n  // At this point, if the types are reference-related, we must either have the\n  // same inner type (ignoring qualifiers), or must have already worked out how\n  // to convert the referent.\n  return (ConvertedReferent || Context.hasSameUnqualifiedType(T1, T2))\n             ? Ref_Compatible\n             : Ref_Incompatible;\n}\n\n/// Look for a user-defined conversion to a value reference-compatible\n///        with DeclType. Return true if something definite is found.\nstatic bool\nFindConversionForRefInit(Sema &S, ImplicitConversionSequence &ICS,\n                         QualType DeclType, SourceLocation DeclLoc,\n                         Expr *Init, QualType T2, bool AllowRvalues,\n                         bool AllowExplicit) {\n  assert(T2->isRecordType() && \"Can only find conversions of record types.\");\n  auto *T2RecordDecl = cast<CXXRecordDecl>(T2->castAs<RecordType>()->getDecl());\n\n  OverloadCandidateSet CandidateSet(\n      DeclLoc, OverloadCandidateSet::CSK_InitByUserDefinedConversion);\n  const auto &Conversions = T2RecordDecl->getVisibleConversionFunctions();\n  for (auto I = Conversions.begin(), E = Conversions.end(); I != E; ++I) {\n    NamedDecl *D = *I;\n    CXXRecordDecl *ActingDC = cast<CXXRecordDecl>(D->getDeclContext());\n    if (isa<UsingShadowDecl>(D))\n      D = cast<UsingShadowDecl>(D)->getTargetDecl();\n\n    FunctionTemplateDecl *ConvTemplate\n      = dyn_cast<FunctionTemplateDecl>(D);\n    CXXConversionDecl *Conv;\n    if (ConvTemplate)\n      Conv = cast<CXXConversionDecl>(ConvTemplate->getTemplatedDecl());\n    else\n      Conv = cast<CXXConversionDecl>(D);\n\n    if (AllowRvalues) {\n      // If we are initializing an rvalue reference, don't permit conversion\n      // functions that return lvalues.\n      if (!ConvTemplate && DeclType->isRValueReferenceType()) {\n        const ReferenceType *RefType\n          = Conv->getConversionType()->getAs<LValueReferenceType>();\n        if (RefType && !RefType->getPointeeType()->isFunctionType())\n          continue;\n      }\n\n      if (!ConvTemplate &&\n          S.CompareReferenceRelationship(\n              DeclLoc,\n              Conv->getConversionType()\n                  .getNonReferenceType()\n                  .getUnqualifiedType(),\n              DeclType.getNonReferenceType().getUnqualifiedType()) ==\n              Sema::Ref_Incompatible)\n        continue;\n    } else {\n      // If the conversion function doesn't return a reference type,\n      // it can't be considered for this conversion. An rvalue reference\n      // is only acceptable if its referencee is a function type.\n\n      const ReferenceType *RefType =\n        Conv->getConversionType()->getAs<ReferenceType>();\n      if (!RefType ||\n          (!RefType->isLValueReferenceType() &&\n           !RefType->getPointeeType()->isFunctionType()))\n        continue;\n    }\n\n    if (ConvTemplate)\n      S.AddTemplateConversionCandidate(\n          ConvTemplate, I.getPair(), ActingDC, Init, DeclType, CandidateSet,\n          /*AllowObjCConversionOnExplicit=*/false, AllowExplicit);\n    else\n      S.AddConversionCandidate(\n          Conv, I.getPair(), ActingDC, Init, DeclType, CandidateSet,\n          /*AllowObjCConversionOnExplicit=*/false, AllowExplicit);\n  }\n\n  bool HadMultipleCandidates = (CandidateSet.size() > 1);\n\n  OverloadCandidateSet::iterator Best;\n  switch (CandidateSet.BestViableFunction(S, DeclLoc, Best)) {\n  case OR_Success:\n    // C++ [over.ics.ref]p1:\n    //\n    //   [...] If the parameter binds directly to the result of\n    //   applying a conversion function to the argument\n    //   expression, the implicit conversion sequence is a\n    //   user-defined conversion sequence (13.3.3.1.2), with the\n    //   second standard conversion sequence either an identity\n    //   conversion or, if the conversion function returns an\n    //   entity of a type that is a derived class of the parameter\n    //   type, a derived-to-base Conversion.\n    if (!Best->FinalConversion.DirectBinding)\n      return false;\n\n    ICS.setUserDefined();\n    ICS.UserDefined.Before = Best->Conversions[0].Standard;\n    ICS.UserDefined.After = Best->FinalConversion;\n    ICS.UserDefined.HadMultipleCandidates = HadMultipleCandidates;\n    ICS.UserDefined.ConversionFunction = Best->Function;\n    ICS.UserDefined.FoundConversionFunction = Best->FoundDecl;\n    ICS.UserDefined.EllipsisConversion = false;\n    assert(ICS.UserDefined.After.ReferenceBinding &&\n           ICS.UserDefined.After.DirectBinding &&\n           \"Expected a direct reference binding!\");\n    return true;\n\n  case OR_Ambiguous:\n    ICS.setAmbiguous();\n    for (OverloadCandidateSet::iterator Cand = CandidateSet.begin();\n         Cand != CandidateSet.end(); ++Cand)\n      if (Cand->Best)\n        ICS.Ambiguous.addConversion(Cand->FoundDecl, Cand->Function);\n    return true;\n\n  case OR_No_Viable_Function:\n  case OR_Deleted:\n    // There was no suitable conversion, or we found a deleted\n    // conversion; continue with other checks.\n    return false;\n  }\n\n  llvm_unreachable(\"Invalid OverloadResult!\");\n}\n\n/// Compute an implicit conversion sequence for reference\n/// initialization.\nstatic ImplicitConversionSequence\nTryReferenceInit(Sema &S, Expr *Init, QualType DeclType,\n                 SourceLocation DeclLoc,\n                 bool SuppressUserConversions,\n                 bool AllowExplicit) {\n  assert(DeclType->isReferenceType() && \"Reference init needs a reference\");\n\n  // Most paths end in a failed conversion.\n  ImplicitConversionSequence ICS;\n  ICS.setBad(BadConversionSequence::no_conversion, Init, DeclType);\n\n  QualType T1 = DeclType->castAs<ReferenceType>()->getPointeeType();\n  QualType T2 = Init->getType();\n\n  // If the initializer is the address of an overloaded function, try\n  // to resolve the overloaded function. If all goes well, T2 is the\n  // type of the resulting function.\n  if (S.Context.getCanonicalType(T2) == S.Context.OverloadTy) {\n    DeclAccessPair Found;\n    if (FunctionDecl *Fn = S.ResolveAddressOfOverloadedFunction(Init, DeclType,\n                                                                false, Found))\n      T2 = Fn->getType();\n  }\n\n  // Compute some basic properties of the types and the initializer.\n  bool isRValRef = DeclType->isRValueReferenceType();\n  Expr::Classification InitCategory = Init->Classify(S.Context);\n\n  Sema::ReferenceConversions RefConv;\n  Sema::ReferenceCompareResult RefRelationship =\n      S.CompareReferenceRelationship(DeclLoc, T1, T2, &RefConv);\n\n  auto SetAsReferenceBinding = [&](bool BindsDirectly) {\n    ICS.setStandard();\n    ICS.Standard.First = ICK_Identity;\n    // FIXME: A reference binding can be a function conversion too. We should\n    // consider that when ordering reference-to-function bindings.\n    ICS.Standard.Second = (RefConv & Sema::ReferenceConversions::DerivedToBase)\n                              ? ICK_Derived_To_Base\n                              : (RefConv & Sema::ReferenceConversions::ObjC)\n                                    ? ICK_Compatible_Conversion\n                                    : ICK_Identity;\n    // FIXME: As a speculative fix to a defect introduced by CWG2352, we rank\n    // a reference binding that performs a non-top-level qualification\n    // conversion as a qualification conversion, not as an identity conversion.\n    ICS.Standard.Third = (RefConv &\n                              Sema::ReferenceConversions::NestedQualification)\n                             ? ICK_Qualification\n                             : ICK_Identity;\n    ICS.Standard.setFromType(T2);\n    ICS.Standard.setToType(0, T2);\n    ICS.Standard.setToType(1, T1);\n    ICS.Standard.setToType(2, T1);\n    ICS.Standard.ReferenceBinding = true;\n    ICS.Standard.DirectBinding = BindsDirectly;\n    ICS.Standard.IsLvalueReference = !isRValRef;\n    ICS.Standard.BindsToFunctionLvalue = T2->isFunctionType();\n    ICS.Standard.BindsToRvalue = InitCategory.isRValue();\n    ICS.Standard.BindsImplicitObjectArgumentWithoutRefQualifier = false;\n    ICS.Standard.ObjCLifetimeConversionBinding =\n        (RefConv & Sema::ReferenceConversions::ObjCLifetime) != 0;\n    ICS.Standard.CopyConstructor = nullptr;\n    ICS.Standard.DeprecatedStringLiteralToCharPtr = false;\n  };\n\n  // C++0x [dcl.init.ref]p5:\n  //   A reference to type \"cv1 T1\" is initialized by an expression\n  //   of type \"cv2 T2\" as follows:\n\n  //     -- If reference is an lvalue reference and the initializer expression\n  if (!isRValRef) {\n    //     -- is an lvalue (but is not a bit-field), and \"cv1 T1\" is\n    //        reference-compatible with \"cv2 T2,\" or\n    //\n    // Per C++ [over.ics.ref]p4, we don't check the bit-field property here.\n    if (InitCategory.isLValue() && RefRelationship == Sema::Ref_Compatible) {\n      // C++ [over.ics.ref]p1:\n      //   When a parameter of reference type binds directly (8.5.3)\n      //   to an argument expression, the implicit conversion sequence\n      //   is the identity conversion, unless the argument expression\n      //   has a type that is a derived class of the parameter type,\n      //   in which case the implicit conversion sequence is a\n      //   derived-to-base Conversion (13.3.3.1).\n      SetAsReferenceBinding(/*BindsDirectly=*/true);\n\n      // Nothing more to do: the inaccessibility/ambiguity check for\n      // derived-to-base conversions is suppressed when we're\n      // computing the implicit conversion sequence (C++\n      // [over.best.ics]p2).\n      return ICS;\n    }\n\n    //       -- has a class type (i.e., T2 is a class type), where T1 is\n    //          not reference-related to T2, and can be implicitly\n    //          converted to an lvalue of type \"cv3 T3,\" where \"cv1 T1\"\n    //          is reference-compatible with \"cv3 T3\" 92) (this\n    //          conversion is selected by enumerating the applicable\n    //          conversion functions (13.3.1.6) and choosing the best\n    //          one through overload resolution (13.3)),\n    if (!SuppressUserConversions && T2->isRecordType() &&\n        S.isCompleteType(DeclLoc, T2) &&\n        RefRelationship == Sema::Ref_Incompatible) {\n      if (FindConversionForRefInit(S, ICS, DeclType, DeclLoc,\n                                   Init, T2, /*AllowRvalues=*/false,\n                                   AllowExplicit))\n        return ICS;\n    }\n  }\n\n  //     -- Otherwise, the reference shall be an lvalue reference to a\n  //        non-volatile const type (i.e., cv1 shall be const), or the reference\n  //        shall be an rvalue reference.\n  if (!isRValRef && (!T1.isConstQualified() || T1.isVolatileQualified())) {\n    if (InitCategory.isRValue() && RefRelationship != Sema::Ref_Incompatible)\n      ICS.setBad(BadConversionSequence::lvalue_ref_to_rvalue, Init, DeclType);\n    return ICS;\n  }\n\n  //       -- If the initializer expression\n  //\n  //            -- is an xvalue, class prvalue, array prvalue or function\n  //               lvalue and \"cv1 T1\" is reference-compatible with \"cv2 T2\", or\n  if (RefRelationship == Sema::Ref_Compatible &&\n      (InitCategory.isXValue() ||\n       (InitCategory.isPRValue() &&\n          (T2->isRecordType() || T2->isArrayType())) ||\n       (InitCategory.isLValue() && T2->isFunctionType()))) {\n    // In C++11, this is always a direct binding. In C++98/03, it's a direct\n    // binding unless we're binding to a class prvalue.\n    // Note: Although xvalues wouldn't normally show up in C++98/03 code, we\n    // allow the use of rvalue references in C++98/03 for the benefit of\n    // standard library implementors; therefore, we need the xvalue check here.\n    SetAsReferenceBinding(/*BindsDirectly=*/S.getLangOpts().CPlusPlus11 ||\n                          !(InitCategory.isPRValue() || T2->isRecordType()));\n    return ICS;\n  }\n\n  //            -- has a class type (i.e., T2 is a class type), where T1 is not\n  //               reference-related to T2, and can be implicitly converted to\n  //               an xvalue, class prvalue, or function lvalue of type\n  //               \"cv3 T3\", where \"cv1 T1\" is reference-compatible with\n  //               \"cv3 T3\",\n  //\n  //          then the reference is bound to the value of the initializer\n  //          expression in the first case and to the result of the conversion\n  //          in the second case (or, in either case, to an appropriate base\n  //          class subobject).\n  if (!SuppressUserConversions && RefRelationship == Sema::Ref_Incompatible &&\n      T2->isRecordType() && S.isCompleteType(DeclLoc, T2) &&\n      FindConversionForRefInit(S, ICS, DeclType, DeclLoc,\n                               Init, T2, /*AllowRvalues=*/true,\n                               AllowExplicit)) {\n    // In the second case, if the reference is an rvalue reference\n    // and the second standard conversion sequence of the\n    // user-defined conversion sequence includes an lvalue-to-rvalue\n    // conversion, the program is ill-formed.\n    if (ICS.isUserDefined() && isRValRef &&\n        ICS.UserDefined.After.First == ICK_Lvalue_To_Rvalue)\n      ICS.setBad(BadConversionSequence::no_conversion, Init, DeclType);\n\n    return ICS;\n  }\n\n  // A temporary of function type cannot be created; don't even try.\n  if (T1->isFunctionType())\n    return ICS;\n\n  //       -- Otherwise, a temporary of type \"cv1 T1\" is created and\n  //          initialized from the initializer expression using the\n  //          rules for a non-reference copy initialization (8.5). The\n  //          reference is then bound to the temporary. If T1 is\n  //          reference-related to T2, cv1 must be the same\n  //          cv-qualification as, or greater cv-qualification than,\n  //          cv2; otherwise, the program is ill-formed.\n  if (RefRelationship == Sema::Ref_Related) {\n    // If cv1 == cv2 or cv1 is a greater cv-qualified than cv2, then\n    // we would be reference-compatible or reference-compatible with\n    // added qualification. But that wasn't the case, so the reference\n    // initialization fails.\n    //\n    // Note that we only want to check address spaces and cvr-qualifiers here.\n    // ObjC GC, lifetime and unaligned qualifiers aren't important.\n    Qualifiers T1Quals = T1.getQualifiers();\n    Qualifiers T2Quals = T2.getQualifiers();\n    T1Quals.removeObjCGCAttr();\n    T1Quals.removeObjCLifetime();\n    T2Quals.removeObjCGCAttr();\n    T2Quals.removeObjCLifetime();\n    // MS compiler ignores __unaligned qualifier for references; do the same.\n    T1Quals.removeUnaligned();\n    T2Quals.removeUnaligned();\n    if (!T1Quals.compatiblyIncludes(T2Quals))\n      return ICS;\n  }\n\n  // If at least one of the types is a class type, the types are not\n  // related, and we aren't allowed any user conversions, the\n  // reference binding fails. This case is important for breaking\n  // recursion, since TryImplicitConversion below will attempt to\n  // create a temporary through the use of a copy constructor.\n  if (SuppressUserConversions && RefRelationship == Sema::Ref_Incompatible &&\n      (T1->isRecordType() || T2->isRecordType()))\n    return ICS;\n\n  // If T1 is reference-related to T2 and the reference is an rvalue\n  // reference, the initializer expression shall not be an lvalue.\n  if (RefRelationship >= Sema::Ref_Related && isRValRef &&\n      Init->Classify(S.Context).isLValue()) {\n    ICS.setBad(BadConversionSequence::rvalue_ref_to_lvalue, Init, DeclType);\n    return ICS;\n  }\n\n  // C++ [over.ics.ref]p2:\n  //   When a parameter of reference type is not bound directly to\n  //   an argument expression, the conversion sequence is the one\n  //   required to convert the argument expression to the\n  //   underlying type of the reference according to\n  //   13.3.3.1. Conceptually, this conversion sequence corresponds\n  //   to copy-initializing a temporary of the underlying type with\n  //   the argument expression. Any difference in top-level\n  //   cv-qualification is subsumed by the initialization itself\n  //   and does not constitute a conversion.\n  ICS = TryImplicitConversion(S, Init, T1, SuppressUserConversions,\n                              AllowedExplicit::None,\n                              /*InOverloadResolution=*/false,\n                              /*CStyle=*/false,\n                              /*AllowObjCWritebackConversion=*/false,\n                              /*AllowObjCConversionOnExplicit=*/false);\n\n  // Of course, that's still a reference binding.\n  if (ICS.isStandard()) {\n    ICS.Standard.ReferenceBinding = true;\n    ICS.Standard.IsLvalueReference = !isRValRef;\n    ICS.Standard.BindsToFunctionLvalue = false;\n    ICS.Standard.BindsToRvalue = true;\n    ICS.Standard.BindsImplicitObjectArgumentWithoutRefQualifier = false;\n    ICS.Standard.ObjCLifetimeConversionBinding = false;\n  } else if (ICS.isUserDefined()) {\n    const ReferenceType *LValRefType =\n        ICS.UserDefined.ConversionFunction->getReturnType()\n            ->getAs<LValueReferenceType>();\n\n    // C++ [over.ics.ref]p3:\n    //   Except for an implicit object parameter, for which see 13.3.1, a\n    //   standard conversion sequence cannot be formed if it requires [...]\n    //   binding an rvalue reference to an lvalue other than a function\n    //   lvalue.\n    // Note that the function case is not possible here.\n    if (isRValRef && LValRefType) {\n      ICS.setBad(BadConversionSequence::no_conversion, Init, DeclType);\n      return ICS;\n    }\n\n    ICS.UserDefined.After.ReferenceBinding = true;\n    ICS.UserDefined.After.IsLvalueReference = !isRValRef;\n    ICS.UserDefined.After.BindsToFunctionLvalue = false;\n    ICS.UserDefined.After.BindsToRvalue = !LValRefType;\n    ICS.UserDefined.After.BindsImplicitObjectArgumentWithoutRefQualifier = false;\n    ICS.UserDefined.After.ObjCLifetimeConversionBinding = false;\n  }\n\n  return ICS;\n}\n\nstatic ImplicitConversionSequence\nTryCopyInitialization(Sema &S, Expr *From, QualType ToType,\n                      bool SuppressUserConversions,\n                      bool InOverloadResolution,\n                      bool AllowObjCWritebackConversion,\n                      bool AllowExplicit = false);\n\n/// TryListConversion - Try to copy-initialize a value of type ToType from the\n/// initializer list From.\nstatic ImplicitConversionSequence\nTryListConversion(Sema &S, InitListExpr *From, QualType ToType,\n                  bool SuppressUserConversions,\n                  bool InOverloadResolution,\n                  bool AllowObjCWritebackConversion) {\n  // C++11 [over.ics.list]p1:\n  //   When an argument is an initializer list, it is not an expression and\n  //   special rules apply for converting it to a parameter type.\n\n  ImplicitConversionSequence Result;\n  Result.setBad(BadConversionSequence::no_conversion, From, ToType);\n\n  // We need a complete type for what follows. Incomplete types can never be\n  // initialized from init lists.\n  if (!S.isCompleteType(From->getBeginLoc(), ToType))\n    return Result;\n\n  // Per DR1467:\n  //   If the parameter type is a class X and the initializer list has a single\n  //   element of type cv U, where U is X or a class derived from X, the\n  //   implicit conversion sequence is the one required to convert the element\n  //   to the parameter type.\n  //\n  //   Otherwise, if the parameter type is a character array [... ]\n  //   and the initializer list has a single element that is an\n  //   appropriately-typed string literal (8.5.2 [dcl.init.string]), the\n  //   implicit conversion sequence is the identity conversion.\n  if (From->getNumInits() == 1) {\n    if (ToType->isRecordType()) {\n      QualType InitType = From->getInit(0)->getType();\n      if (S.Context.hasSameUnqualifiedType(InitType, ToType) ||\n          S.IsDerivedFrom(From->getBeginLoc(), InitType, ToType))\n        return TryCopyInitialization(S, From->getInit(0), ToType,\n                                     SuppressUserConversions,\n                                     InOverloadResolution,\n                                     AllowObjCWritebackConversion);\n    }\n\n    if (const auto *AT = S.Context.getAsArrayType(ToType)) {\n      if (S.IsStringInit(From->getInit(0), AT)) {\n        InitializedEntity Entity =\n          InitializedEntity::InitializeParameter(S.Context, ToType,\n                                                 /*Consumed=*/false);\n        if (S.CanPerformCopyInitialization(Entity, From)) {\n          Result.setStandard();\n          Result.Standard.setAsIdentityConversion();\n          Result.Standard.setFromType(ToType);\n          Result.Standard.setAllToTypes(ToType);\n          return Result;\n        }\n      }\n    }\n  }\n\n  // C++14 [over.ics.list]p2: Otherwise, if the parameter type [...] (below).\n  // C++11 [over.ics.list]p2:\n  //   If the parameter type is std::initializer_list<X> or \"array of X\" and\n  //   all the elements can be implicitly converted to X, the implicit\n  //   conversion sequence is the worst conversion necessary to convert an\n  //   element of the list to X.\n  //\n  // C++14 [over.ics.list]p3:\n  //   Otherwise, if the parameter type is \"array of N X\", if the initializer\n  //   list has exactly N elements or if it has fewer than N elements and X is\n  //   default-constructible, and if all the elements of the initializer list\n  //   can be implicitly converted to X, the implicit conversion sequence is\n  //   the worst conversion necessary to convert an element of the list to X.\n  //\n  // FIXME: We're missing a lot of these checks.\n  bool toStdInitializerList = false;\n  QualType X;\n  if (ToType->isArrayType())\n    X = S.Context.getAsArrayType(ToType)->getElementType();\n  else\n    toStdInitializerList = S.isStdInitializerList(ToType, &X);\n  if (!X.isNull()) {\n    for (unsigned i = 0, e = From->getNumInits(); i < e; ++i) {\n      Expr *Init = From->getInit(i);\n      ImplicitConversionSequence ICS =\n          TryCopyInitialization(S, Init, X, SuppressUserConversions,\n                                InOverloadResolution,\n                                AllowObjCWritebackConversion);\n      // If a single element isn't convertible, fail.\n      if (ICS.isBad()) {\n        Result = ICS;\n        break;\n      }\n      // Otherwise, look for the worst conversion.\n      if (Result.isBad() || CompareImplicitConversionSequences(\n                                S, From->getBeginLoc(), ICS, Result) ==\n                                ImplicitConversionSequence::Worse)\n        Result = ICS;\n    }\n\n    // For an empty list, we won't have computed any conversion sequence.\n    // Introduce the identity conversion sequence.\n    if (From->getNumInits() == 0) {\n      Result.setStandard();\n      Result.Standard.setAsIdentityConversion();\n      Result.Standard.setFromType(ToType);\n      Result.Standard.setAllToTypes(ToType);\n    }\n\n    Result.setStdInitializerListElement(toStdInitializerList);\n    return Result;\n  }\n\n  // C++14 [over.ics.list]p4:\n  // C++11 [over.ics.list]p3:\n  //   Otherwise, if the parameter is a non-aggregate class X and overload\n  //   resolution chooses a single best constructor [...] the implicit\n  //   conversion sequence is a user-defined conversion sequence. If multiple\n  //   constructors are viable but none is better than the others, the\n  //   implicit conversion sequence is a user-defined conversion sequence.\n  if (ToType->isRecordType() && !ToType->isAggregateType()) {\n    // This function can deal with initializer lists.\n    return TryUserDefinedConversion(S, From, ToType, SuppressUserConversions,\n                                    AllowedExplicit::None,\n                                    InOverloadResolution, /*CStyle=*/false,\n                                    AllowObjCWritebackConversion,\n                                    /*AllowObjCConversionOnExplicit=*/false);\n  }\n\n  // C++14 [over.ics.list]p5:\n  // C++11 [over.ics.list]p4:\n  //   Otherwise, if the parameter has an aggregate type which can be\n  //   initialized from the initializer list [...] the implicit conversion\n  //   sequence is a user-defined conversion sequence.\n  if (ToType->isAggregateType()) {\n    // Type is an aggregate, argument is an init list. At this point it comes\n    // down to checking whether the initialization works.\n    // FIXME: Find out whether this parameter is consumed or not.\n    InitializedEntity Entity =\n        InitializedEntity::InitializeParameter(S.Context, ToType,\n                                               /*Consumed=*/false);\n    if (S.CanPerformAggregateInitializationForOverloadResolution(Entity,\n                                                                 From)) {\n      Result.setUserDefined();\n      Result.UserDefined.Before.setAsIdentityConversion();\n      // Initializer lists don't have a type.\n      Result.UserDefined.Before.setFromType(QualType());\n      Result.UserDefined.Before.setAllToTypes(QualType());\n\n      Result.UserDefined.After.setAsIdentityConversion();\n      Result.UserDefined.After.setFromType(ToType);\n      Result.UserDefined.After.setAllToTypes(ToType);\n      Result.UserDefined.ConversionFunction = nullptr;\n    }\n    return Result;\n  }\n\n  // C++14 [over.ics.list]p6:\n  // C++11 [over.ics.list]p5:\n  //   Otherwise, if the parameter is a reference, see 13.3.3.1.4.\n  if (ToType->isReferenceType()) {\n    // The standard is notoriously unclear here, since 13.3.3.1.4 doesn't\n    // mention initializer lists in any way. So we go by what list-\n    // initialization would do and try to extrapolate from that.\n\n    QualType T1 = ToType->castAs<ReferenceType>()->getPointeeType();\n\n    // If the initializer list has a single element that is reference-related\n    // to the parameter type, we initialize the reference from that.\n    if (From->getNumInits() == 1) {\n      Expr *Init = From->getInit(0);\n\n      QualType T2 = Init->getType();\n\n      // If the initializer is the address of an overloaded function, try\n      // to resolve the overloaded function. If all goes well, T2 is the\n      // type of the resulting function.\n      if (S.Context.getCanonicalType(T2) == S.Context.OverloadTy) {\n        DeclAccessPair Found;\n        if (FunctionDecl *Fn = S.ResolveAddressOfOverloadedFunction(\n                                   Init, ToType, false, Found))\n          T2 = Fn->getType();\n      }\n\n      // Compute some basic properties of the types and the initializer.\n      Sema::ReferenceCompareResult RefRelationship =\n          S.CompareReferenceRelationship(From->getBeginLoc(), T1, T2);\n\n      if (RefRelationship >= Sema::Ref_Related) {\n        return TryReferenceInit(S, Init, ToType, /*FIXME*/ From->getBeginLoc(),\n                                SuppressUserConversions,\n                                /*AllowExplicit=*/false);\n      }\n    }\n\n    // Otherwise, we bind the reference to a temporary created from the\n    // initializer list.\n    Result = TryListConversion(S, From, T1, SuppressUserConversions,\n                               InOverloadResolution,\n                               AllowObjCWritebackConversion);\n    if (Result.isFailure())\n      return Result;\n    assert(!Result.isEllipsis() &&\n           \"Sub-initialization cannot result in ellipsis conversion.\");\n\n    // Can we even bind to a temporary?\n    if (ToType->isRValueReferenceType() ||\n        (T1.isConstQualified() && !T1.isVolatileQualified())) {\n      StandardConversionSequence &SCS = Result.isStandard() ? Result.Standard :\n                                            Result.UserDefined.After;\n      SCS.ReferenceBinding = true;\n      SCS.IsLvalueReference = ToType->isLValueReferenceType();\n      SCS.BindsToRvalue = true;\n      SCS.BindsToFunctionLvalue = false;\n      SCS.BindsImplicitObjectArgumentWithoutRefQualifier = false;\n      SCS.ObjCLifetimeConversionBinding = false;\n    } else\n      Result.setBad(BadConversionSequence::lvalue_ref_to_rvalue,\n                    From, ToType);\n    return Result;\n  }\n\n  // C++14 [over.ics.list]p7:\n  // C++11 [over.ics.list]p6:\n  //   Otherwise, if the parameter type is not a class:\n  if (!ToType->isRecordType()) {\n    //    - if the initializer list has one element that is not itself an\n    //      initializer list, the implicit conversion sequence is the one\n    //      required to convert the element to the parameter type.\n    unsigned NumInits = From->getNumInits();\n    if (NumInits == 1 && !isa<InitListExpr>(From->getInit(0)))\n      Result = TryCopyInitialization(S, From->getInit(0), ToType,\n                                     SuppressUserConversions,\n                                     InOverloadResolution,\n                                     AllowObjCWritebackConversion);\n    //    - if the initializer list has no elements, the implicit conversion\n    //      sequence is the identity conversion.\n    else if (NumInits == 0) {\n      Result.setStandard();\n      Result.Standard.setAsIdentityConversion();\n      Result.Standard.setFromType(ToType);\n      Result.Standard.setAllToTypes(ToType);\n    }\n    return Result;\n  }\n\n  // C++14 [over.ics.list]p8:\n  // C++11 [over.ics.list]p7:\n  //   In all cases other than those enumerated above, no conversion is possible\n  return Result;\n}\n\n/// TryCopyInitialization - Try to copy-initialize a value of type\n/// ToType from the expression From. Return the implicit conversion\n/// sequence required to pass this argument, which may be a bad\n/// conversion sequence (meaning that the argument cannot be passed to\n/// a parameter of this type). If @p SuppressUserConversions, then we\n/// do not permit any user-defined conversion sequences.\nstatic ImplicitConversionSequence\nTryCopyInitialization(Sema &S, Expr *From, QualType ToType,\n                      bool SuppressUserConversions,\n                      bool InOverloadResolution,\n                      bool AllowObjCWritebackConversion,\n                      bool AllowExplicit) {\n  if (InitListExpr *FromInitList = dyn_cast<InitListExpr>(From))\n    return TryListConversion(S, FromInitList, ToType, SuppressUserConversions,\n                             InOverloadResolution,AllowObjCWritebackConversion);\n\n  if (ToType->isReferenceType())\n    return TryReferenceInit(S, From, ToType,\n                            /*FIXME:*/ From->getBeginLoc(),\n                            SuppressUserConversions, AllowExplicit);\n\n  return TryImplicitConversion(S, From, ToType,\n                               SuppressUserConversions,\n                               AllowedExplicit::None,\n                               InOverloadResolution,\n                               /*CStyle=*/false,\n                               AllowObjCWritebackConversion,\n                               /*AllowObjCConversionOnExplicit=*/false);\n}\n\nstatic bool TryCopyInitialization(const CanQualType FromQTy,\n                                  const CanQualType ToQTy,\n                                  Sema &S,\n                                  SourceLocation Loc,\n                                  ExprValueKind FromVK) {\n  OpaqueValueExpr TmpExpr(Loc, FromQTy, FromVK);\n  ImplicitConversionSequence ICS =\n    TryCopyInitialization(S, &TmpExpr, ToQTy, true, true, false);\n\n  return !ICS.isBad();\n}\n\n/// TryObjectArgumentInitialization - Try to initialize the object\n/// parameter of the given member function (@c Method) from the\n/// expression @p From.\nstatic ImplicitConversionSequence\nTryObjectArgumentInitialization(Sema &S, SourceLocation Loc, QualType FromType,\n                                Expr::Classification FromClassification,\n                                CXXMethodDecl *Method,\n                                CXXRecordDecl *ActingContext) {\n  QualType ClassType = S.Context.getTypeDeclType(ActingContext);\n  // [class.dtor]p2: A destructor can be invoked for a const, volatile or\n  //                 const volatile object.\n  Qualifiers Quals = Method->getMethodQualifiers();\n  if (isa<CXXDestructorDecl>(Method)) {\n    Quals.addConst();\n    Quals.addVolatile();\n  }\n\n  QualType ImplicitParamType = S.Context.getQualifiedType(ClassType, Quals);\n\n  // Set up the conversion sequence as a \"bad\" conversion, to allow us\n  // to exit early.\n  ImplicitConversionSequence ICS;\n\n  // We need to have an object of class type.\n  if (const PointerType *PT = FromType->getAs<PointerType>()) {\n    FromType = PT->getPointeeType();\n\n    // When we had a pointer, it's implicitly dereferenced, so we\n    // better have an lvalue.\n    assert(FromClassification.isLValue());\n  }\n\n  assert(FromType->isRecordType());\n\n  // C++0x [over.match.funcs]p4:\n  //   For non-static member functions, the type of the implicit object\n  //   parameter is\n  //\n  //     - \"lvalue reference to cv X\" for functions declared without a\n  //        ref-qualifier or with the & ref-qualifier\n  //     - \"rvalue reference to cv X\" for functions declared with the &&\n  //        ref-qualifier\n  //\n  // where X is the class of which the function is a member and cv is the\n  // cv-qualification on the member function declaration.\n  //\n  // However, when finding an implicit conversion sequence for the argument, we\n  // are not allowed to perform user-defined conversions\n  // (C++ [over.match.funcs]p5). We perform a simplified version of\n  // reference binding here, that allows class rvalues to bind to\n  // non-constant references.\n\n  // First check the qualifiers.\n  QualType FromTypeCanon = S.Context.getCanonicalType(FromType);\n  if (ImplicitParamType.getCVRQualifiers()\n                                    != FromTypeCanon.getLocalCVRQualifiers() &&\n      !ImplicitParamType.isAtLeastAsQualifiedAs(FromTypeCanon)) {\n    ICS.setBad(BadConversionSequence::bad_qualifiers,\n               FromType, ImplicitParamType);\n    return ICS;\n  }\n\n  if (FromTypeCanon.hasAddressSpace()) {\n    Qualifiers QualsImplicitParamType = ImplicitParamType.getQualifiers();\n    Qualifiers QualsFromType = FromTypeCanon.getQualifiers();\n    if (!QualsImplicitParamType.isAddressSpaceSupersetOf(QualsFromType)) {\n      ICS.setBad(BadConversionSequence::bad_qualifiers,\n                 FromType, ImplicitParamType);\n      return ICS;\n    }\n  }\n\n  // Check that we have either the same type or a derived type. It\n  // affects the conversion rank.\n  QualType ClassTypeCanon = S.Context.getCanonicalType(ClassType);\n  ImplicitConversionKind SecondKind;\n  if (ClassTypeCanon == FromTypeCanon.getLocalUnqualifiedType()) {\n    SecondKind = ICK_Identity;\n  } else if (S.IsDerivedFrom(Loc, FromType, ClassType))\n    SecondKind = ICK_Derived_To_Base;\n  else {\n    ICS.setBad(BadConversionSequence::unrelated_class,\n               FromType, ImplicitParamType);\n    return ICS;\n  }\n\n  // Check the ref-qualifier.\n  switch (Method->getRefQualifier()) {\n  case RQ_None:\n    // Do nothing; we don't care about lvalueness or rvalueness.\n    break;\n\n  case RQ_LValue:\n    if (!FromClassification.isLValue() && !Quals.hasOnlyConst()) {\n      // non-const lvalue reference cannot bind to an rvalue\n      ICS.setBad(BadConversionSequence::lvalue_ref_to_rvalue, FromType,\n                 ImplicitParamType);\n      return ICS;\n    }\n    break;\n\n  case RQ_RValue:\n    if (!FromClassification.isRValue()) {\n      // rvalue reference cannot bind to an lvalue\n      ICS.setBad(BadConversionSequence::rvalue_ref_to_lvalue, FromType,\n                 ImplicitParamType);\n      return ICS;\n    }\n    break;\n  }\n\n  // Success. Mark this as a reference binding.\n  ICS.setStandard();\n  ICS.Standard.setAsIdentityConversion();\n  ICS.Standard.Second = SecondKind;\n  ICS.Standard.setFromType(FromType);\n  ICS.Standard.setAllToTypes(ImplicitParamType);\n  ICS.Standard.ReferenceBinding = true;\n  ICS.Standard.DirectBinding = true;\n  ICS.Standard.IsLvalueReference = Method->getRefQualifier() != RQ_RValue;\n  ICS.Standard.BindsToFunctionLvalue = false;\n  ICS.Standard.BindsToRvalue = FromClassification.isRValue();\n  ICS.Standard.BindsImplicitObjectArgumentWithoutRefQualifier\n    = (Method->getRefQualifier() == RQ_None);\n  return ICS;\n}\n\n/// PerformObjectArgumentInitialization - Perform initialization of\n/// the implicit object parameter for the given Method with the given\n/// expression.\nExprResult\nSema::PerformObjectArgumentInitialization(Expr *From,\n                                          NestedNameSpecifier *Qualifier,\n                                          NamedDecl *FoundDecl,\n                                          CXXMethodDecl *Method) {\n  QualType FromRecordType, DestType;\n  QualType ImplicitParamRecordType  =\n    Method->getThisType()->castAs<PointerType>()->getPointeeType();\n\n  Expr::Classification FromClassification;\n  if (const PointerType *PT = From->getType()->getAs<PointerType>()) {\n    FromRecordType = PT->getPointeeType();\n    DestType = Method->getThisType();\n    FromClassification = Expr::Classification::makeSimpleLValue();\n  } else {\n    FromRecordType = From->getType();\n    DestType = ImplicitParamRecordType;\n    FromClassification = From->Classify(Context);\n\n    // When performing member access on an rvalue, materialize a temporary.\n    if (From->isRValue()) {\n      From = CreateMaterializeTemporaryExpr(FromRecordType, From,\n                                            Method->getRefQualifier() !=\n                                                RefQualifierKind::RQ_RValue);\n    }\n  }\n\n  // Note that we always use the true parent context when performing\n  // the actual argument initialization.\n  ImplicitConversionSequence ICS = TryObjectArgumentInitialization(\n      *this, From->getBeginLoc(), From->getType(), FromClassification, Method,\n      Method->getParent());\n  if (ICS.isBad()) {\n    switch (ICS.Bad.Kind) {\n    case BadConversionSequence::bad_qualifiers: {\n      Qualifiers FromQs = FromRecordType.getQualifiers();\n      Qualifiers ToQs = DestType.getQualifiers();\n      unsigned CVR = FromQs.getCVRQualifiers() & ~ToQs.getCVRQualifiers();\n      if (CVR) {\n        Diag(From->getBeginLoc(), diag::err_member_function_call_bad_cvr)\n            << Method->getDeclName() << FromRecordType << (CVR - 1)\n            << From->getSourceRange();\n        Diag(Method->getLocation(), diag::note_previous_decl)\n          << Method->getDeclName();\n        return ExprError();\n      }\n      break;\n    }\n\n    case BadConversionSequence::lvalue_ref_to_rvalue:\n    case BadConversionSequence::rvalue_ref_to_lvalue: {\n      bool IsRValueQualified =\n        Method->getRefQualifier() == RefQualifierKind::RQ_RValue;\n      Diag(From->getBeginLoc(), diag::err_member_function_call_bad_ref)\n          << Method->getDeclName() << FromClassification.isRValue()\n          << IsRValueQualified;\n      Diag(Method->getLocation(), diag::note_previous_decl)\n        << Method->getDeclName();\n      return ExprError();\n    }\n\n    case BadConversionSequence::no_conversion:\n    case BadConversionSequence::unrelated_class:\n      break;\n    }\n\n    return Diag(From->getBeginLoc(), diag::err_member_function_call_bad_type)\n           << ImplicitParamRecordType << FromRecordType\n           << From->getSourceRange();\n  }\n\n  if (ICS.Standard.Second == ICK_Derived_To_Base) {\n    ExprResult FromRes =\n      PerformObjectMemberConversion(From, Qualifier, FoundDecl, Method);\n    if (FromRes.isInvalid())\n      return ExprError();\n    From = FromRes.get();\n  }\n\n  if (!Context.hasSameType(From->getType(), DestType)) {\n    CastKind CK;\n    QualType PteeTy = DestType->getPointeeType();\n    LangAS DestAS =\n        PteeTy.isNull() ? DestType.getAddressSpace() : PteeTy.getAddressSpace();\n    if (FromRecordType.getAddressSpace() != DestAS)\n      CK = CK_AddressSpaceConversion;\n    else\n      CK = CK_NoOp;\n    From = ImpCastExprToType(From, DestType, CK, From->getValueKind()).get();\n  }\n  return From;\n}\n\n/// TryContextuallyConvertToBool - Attempt to contextually convert the\n/// expression From to bool (C++0x [conv]p3).\nstatic ImplicitConversionSequence\nTryContextuallyConvertToBool(Sema &S, Expr *From) {\n  // C++ [dcl.init]/17.8:\n  //   - Otherwise, if the initialization is direct-initialization, the source\n  //     type is std::nullptr_t, and the destination type is bool, the initial\n  //     value of the object being initialized is false.\n  if (From->getType()->isNullPtrType())\n    return ImplicitConversionSequence::getNullptrToBool(From->getType(),\n                                                        S.Context.BoolTy,\n                                                        From->isGLValue());\n\n  // All other direct-initialization of bool is equivalent to an implicit\n  // conversion to bool in which explicit conversions are permitted.\n  return TryImplicitConversion(S, From, S.Context.BoolTy,\n                               /*SuppressUserConversions=*/false,\n                               AllowedExplicit::Conversions,\n                               /*InOverloadResolution=*/false,\n                               /*CStyle=*/false,\n                               /*AllowObjCWritebackConversion=*/false,\n                               /*AllowObjCConversionOnExplicit=*/false);\n}\n\n/// PerformContextuallyConvertToBool - Perform a contextual conversion\n/// of the expression From to bool (C++0x [conv]p3).\nExprResult Sema::PerformContextuallyConvertToBool(Expr *From) {\n  if (checkPlaceholderForOverload(*this, From))\n    return ExprError();\n\n  ImplicitConversionSequence ICS = TryContextuallyConvertToBool(*this, From);\n  if (!ICS.isBad())\n    return PerformImplicitConversion(From, Context.BoolTy, ICS, AA_Converting);\n\n  if (!DiagnoseMultipleUserDefinedConversion(From, Context.BoolTy))\n    return Diag(From->getBeginLoc(), diag::err_typecheck_bool_condition)\n           << From->getType() << From->getSourceRange();\n  return ExprError();\n}\n\n/// Check that the specified conversion is permitted in a converted constant\n/// expression, according to C++11 [expr.const]p3. Return true if the conversion\n/// is acceptable.\nstatic bool CheckConvertedConstantConversions(Sema &S,\n                                              StandardConversionSequence &SCS) {\n  // Since we know that the target type is an integral or unscoped enumeration\n  // type, most conversion kinds are impossible. All possible First and Third\n  // conversions are fine.\n  switch (SCS.Second) {\n  case ICK_Identity:\n  case ICK_Integral_Promotion:\n  case ICK_Integral_Conversion: // Narrowing conversions are checked elsewhere.\n  case ICK_Zero_Queue_Conversion:\n    return true;\n\n  case ICK_Boolean_Conversion:\n    // Conversion from an integral or unscoped enumeration type to bool is\n    // classified as ICK_Boolean_Conversion, but it's also arguably an integral\n    // conversion, so we allow it in a converted constant expression.\n    //\n    // FIXME: Per core issue 1407, we should not allow this, but that breaks\n    // a lot of popular code. We should at least add a warning for this\n    // (non-conforming) extension.\n    return SCS.getFromType()->isIntegralOrUnscopedEnumerationType() &&\n           SCS.getToType(2)->isBooleanType();\n\n  case ICK_Pointer_Conversion:\n  case ICK_Pointer_Member:\n    // C++1z: null pointer conversions and null member pointer conversions are\n    // only permitted if the source type is std::nullptr_t.\n    return SCS.getFromType()->isNullPtrType();\n\n  case ICK_Floating_Promotion:\n  case ICK_Complex_Promotion:\n  case ICK_Floating_Conversion:\n  case ICK_Complex_Conversion:\n  case ICK_Floating_Integral:\n  case ICK_Compatible_Conversion:\n  case ICK_Derived_To_Base:\n  case ICK_Vector_Conversion:\n  case ICK_SVE_Vector_Conversion:\n  case ICK_Vector_Splat:\n  case ICK_Complex_Real:\n  case ICK_Block_Pointer_Conversion:\n  case ICK_TransparentUnionConversion:\n  case ICK_Writeback_Conversion:\n  case ICK_Zero_Event_Conversion:\n  case ICK_C_Only_Conversion:\n  case ICK_Incompatible_Pointer_Conversion:\n    return false;\n\n  case ICK_Lvalue_To_Rvalue:\n  case ICK_Array_To_Pointer:\n  case ICK_Function_To_Pointer:\n    llvm_unreachable(\"found a first conversion kind in Second\");\n\n  case ICK_Function_Conversion:\n  case ICK_Qualification:\n    llvm_unreachable(\"found a third conversion kind in Second\");\n\n  case ICK_Num_Conversion_Kinds:\n    break;\n  }\n\n  llvm_unreachable(\"unknown conversion kind\");\n}\n\n/// CheckConvertedConstantExpression - Check that the expression From is a\n/// converted constant expression of type T, perform the conversion and produce\n/// the converted expression, per C++11 [expr.const]p3.\nstatic ExprResult CheckConvertedConstantExpression(Sema &S, Expr *From,\n                                                   QualType T, APValue &Value,\n                                                   Sema::CCEKind CCE,\n                                                   bool RequireInt,\n                                                   NamedDecl *Dest) {\n  assert(S.getLangOpts().CPlusPlus11 &&\n         \"converted constant expression outside C++11\");\n\n  if (checkPlaceholderForOverload(S, From))\n    return ExprError();\n\n  // C++1z [expr.const]p3:\n  //  A converted constant expression of type T is an expression,\n  //  implicitly converted to type T, where the converted\n  //  expression is a constant expression and the implicit conversion\n  //  sequence contains only [... list of conversions ...].\n  // C++1z [stmt.if]p2:\n  //  If the if statement is of the form if constexpr, the value of the\n  //  condition shall be a contextually converted constant expression of type\n  //  bool.\n  ImplicitConversionSequence ICS =\n      CCE == Sema::CCEK_ConstexprIf || CCE == Sema::CCEK_ExplicitBool\n          ? TryContextuallyConvertToBool(S, From)\n          : TryCopyInitialization(S, From, T,\n                                  /*SuppressUserConversions=*/false,\n                                  /*InOverloadResolution=*/false,\n                                  /*AllowObjCWritebackConversion=*/false,\n                                  /*AllowExplicit=*/false);\n  StandardConversionSequence *SCS = nullptr;\n  switch (ICS.getKind()) {\n  case ImplicitConversionSequence::StandardConversion:\n    SCS = &ICS.Standard;\n    break;\n  case ImplicitConversionSequence::UserDefinedConversion:\n    if (T->isRecordType())\n      SCS = &ICS.UserDefined.Before;\n    else\n      SCS = &ICS.UserDefined.After;\n    break;\n  case ImplicitConversionSequence::AmbiguousConversion:\n  case ImplicitConversionSequence::BadConversion:\n    if (!S.DiagnoseMultipleUserDefinedConversion(From, T))\n      return S.Diag(From->getBeginLoc(),\n                    diag::err_typecheck_converted_constant_expression)\n             << From->getType() << From->getSourceRange() << T;\n    return ExprError();\n\n  case ImplicitConversionSequence::EllipsisConversion:\n    llvm_unreachable(\"ellipsis conversion in converted constant expression\");\n  }\n\n  // Check that we would only use permitted conversions.\n  if (!CheckConvertedConstantConversions(S, *SCS)) {\n    return S.Diag(From->getBeginLoc(),\n                  diag::err_typecheck_converted_constant_expression_disallowed)\n           << From->getType() << From->getSourceRange() << T;\n  }\n  // [...] and where the reference binding (if any) binds directly.\n  if (SCS->ReferenceBinding && !SCS->DirectBinding) {\n    return S.Diag(From->getBeginLoc(),\n                  diag::err_typecheck_converted_constant_expression_indirect)\n           << From->getType() << From->getSourceRange() << T;\n  }\n\n  // Usually we can simply apply the ImplicitConversionSequence we formed\n  // earlier, but that's not guaranteed to work when initializing an object of\n  // class type.\n  ExprResult Result;\n  if (T->isRecordType()) {\n    assert(CCE == Sema::CCEK_TemplateArg &&\n           \"unexpected class type converted constant expr\");\n    Result = S.PerformCopyInitialization(\n        InitializedEntity::InitializeTemplateParameter(\n            T, cast<NonTypeTemplateParmDecl>(Dest)),\n        SourceLocation(), From);\n  } else {\n    Result = S.PerformImplicitConversion(From, T, ICS, Sema::AA_Converting);\n  }\n  if (Result.isInvalid())\n    return Result;\n\n  // C++2a [intro.execution]p5:\n  //   A full-expression is [...] a constant-expression [...]\n  Result =\n      S.ActOnFinishFullExpr(Result.get(), From->getExprLoc(),\n                            /*DiscardedValue=*/false, /*IsConstexpr=*/true);\n  if (Result.isInvalid())\n    return Result;\n\n  // Check for a narrowing implicit conversion.\n  bool ReturnPreNarrowingValue = false;\n  APValue PreNarrowingValue;\n  QualType PreNarrowingType;\n  switch (SCS->getNarrowingKind(S.Context, Result.get(), PreNarrowingValue,\n                                PreNarrowingType)) {\n  case NK_Dependent_Narrowing:\n    // Implicit conversion to a narrower type, but the expression is\n    // value-dependent so we can't tell whether it's actually narrowing.\n  case NK_Variable_Narrowing:\n    // Implicit conversion to a narrower type, and the value is not a constant\n    // expression. We'll diagnose this in a moment.\n  case NK_Not_Narrowing:\n    break;\n\n  case NK_Constant_Narrowing:\n    if (CCE == Sema::CCEK_ArrayBound &&\n        PreNarrowingType->isIntegralOrEnumerationType() &&\n        PreNarrowingValue.isInt()) {\n      // Don't diagnose array bound narrowing here; we produce more precise\n      // errors by allowing the un-narrowed value through.\n      ReturnPreNarrowingValue = true;\n      break;\n    }\n    S.Diag(From->getBeginLoc(), diag::ext_cce_narrowing)\n        << CCE << /*Constant*/ 1\n        << PreNarrowingValue.getAsString(S.Context, PreNarrowingType) << T;\n    break;\n\n  case NK_Type_Narrowing:\n    // FIXME: It would be better to diagnose that the expression is not a\n    // constant expression.\n    S.Diag(From->getBeginLoc(), diag::ext_cce_narrowing)\n        << CCE << /*Constant*/ 0 << From->getType() << T;\n    break;\n  }\n\n  if (Result.get()->isValueDependent()) {\n    Value = APValue();\n    return Result;\n  }\n\n  // Check the expression is a constant expression.\n  SmallVector<PartialDiagnosticAt, 8> Notes;\n  Expr::EvalResult Eval;\n  Eval.Diag = &Notes;\n\n  ConstantExprKind Kind;\n  if (CCE == Sema::CCEK_TemplateArg && T->isRecordType())\n    Kind = ConstantExprKind::ClassTemplateArgument;\n  else if (CCE == Sema::CCEK_TemplateArg)\n    Kind = ConstantExprKind::NonClassTemplateArgument;\n  else\n    Kind = ConstantExprKind::Normal;\n\n  if (!Result.get()->EvaluateAsConstantExpr(Eval, S.Context, Kind) ||\n      (RequireInt && !Eval.Val.isInt())) {\n    // The expression can't be folded, so we can't keep it at this position in\n    // the AST.\n    Result = ExprError();\n  } else {\n    Value = Eval.Val;\n\n    if (Notes.empty()) {\n      // It's a constant expression.\n      Expr *E = ConstantExpr::Create(S.Context, Result.get(), Value);\n      if (ReturnPreNarrowingValue)\n        Value = std::move(PreNarrowingValue);\n      return E;\n    }\n  }\n\n  // It's not a constant expression. Produce an appropriate diagnostic.\n  if (Notes.size() == 1 &&\n      Notes[0].second.getDiagID() == diag::note_invalid_subexpr_in_const_expr) {\n    S.Diag(Notes[0].first, diag::err_expr_not_cce) << CCE;\n  } else if (!Notes.empty() && Notes[0].second.getDiagID() ==\n                                   diag::note_constexpr_invalid_template_arg) {\n    Notes[0].second.setDiagID(diag::err_constexpr_invalid_template_arg);\n    for (unsigned I = 0; I < Notes.size(); ++I)\n      S.Diag(Notes[I].first, Notes[I].second);\n  } else {\n    S.Diag(From->getBeginLoc(), diag::err_expr_not_cce)\n        << CCE << From->getSourceRange();\n    for (unsigned I = 0; I < Notes.size(); ++I)\n      S.Diag(Notes[I].first, Notes[I].second);\n  }\n  return ExprError();\n}\n\nExprResult Sema::CheckConvertedConstantExpression(Expr *From, QualType T,\n                                                  APValue &Value, CCEKind CCE,\n                                                  NamedDecl *Dest) {\n  return ::CheckConvertedConstantExpression(*this, From, T, Value, CCE, false,\n                                            Dest);\n}\n\nExprResult Sema::CheckConvertedConstantExpression(Expr *From, QualType T,\n                                                  llvm::APSInt &Value,\n                                                  CCEKind CCE) {\n  assert(T->isIntegralOrEnumerationType() && \"unexpected converted const type\");\n\n  APValue V;\n  auto R = ::CheckConvertedConstantExpression(*this, From, T, V, CCE, true,\n                                              /*Dest=*/nullptr);\n  if (!R.isInvalid() && !R.get()->isValueDependent())\n    Value = V.getInt();\n  return R;\n}\n\n\n/// dropPointerConversions - If the given standard conversion sequence\n/// involves any pointer conversions, remove them.  This may change\n/// the result type of the conversion sequence.\nstatic void dropPointerConversion(StandardConversionSequence &SCS) {\n  if (SCS.Second == ICK_Pointer_Conversion) {\n    SCS.Second = ICK_Identity;\n    SCS.Third = ICK_Identity;\n    SCS.ToTypePtrs[2] = SCS.ToTypePtrs[1] = SCS.ToTypePtrs[0];\n  }\n}\n\n/// TryContextuallyConvertToObjCPointer - Attempt to contextually\n/// convert the expression From to an Objective-C pointer type.\nstatic ImplicitConversionSequence\nTryContextuallyConvertToObjCPointer(Sema &S, Expr *From) {\n  // Do an implicit conversion to 'id'.\n  QualType Ty = S.Context.getObjCIdType();\n  ImplicitConversionSequence ICS\n    = TryImplicitConversion(S, From, Ty,\n                            // FIXME: Are these flags correct?\n                            /*SuppressUserConversions=*/false,\n                            AllowedExplicit::Conversions,\n                            /*InOverloadResolution=*/false,\n                            /*CStyle=*/false,\n                            /*AllowObjCWritebackConversion=*/false,\n                            /*AllowObjCConversionOnExplicit=*/true);\n\n  // Strip off any final conversions to 'id'.\n  switch (ICS.getKind()) {\n  case ImplicitConversionSequence::BadConversion:\n  case ImplicitConversionSequence::AmbiguousConversion:\n  case ImplicitConversionSequence::EllipsisConversion:\n    break;\n\n  case ImplicitConversionSequence::UserDefinedConversion:\n    dropPointerConversion(ICS.UserDefined.After);\n    break;\n\n  case ImplicitConversionSequence::StandardConversion:\n    dropPointerConversion(ICS.Standard);\n    break;\n  }\n\n  return ICS;\n}\n\n/// PerformContextuallyConvertToObjCPointer - Perform a contextual\n/// conversion of the expression From to an Objective-C pointer type.\n/// Returns a valid but null ExprResult if no conversion sequence exists.\nExprResult Sema::PerformContextuallyConvertToObjCPointer(Expr *From) {\n  if (checkPlaceholderForOverload(*this, From))\n    return ExprError();\n\n  QualType Ty = Context.getObjCIdType();\n  ImplicitConversionSequence ICS =\n    TryContextuallyConvertToObjCPointer(*this, From);\n  if (!ICS.isBad())\n    return PerformImplicitConversion(From, Ty, ICS, AA_Converting);\n  return ExprResult();\n}\n\n/// Determine whether the provided type is an integral type, or an enumeration\n/// type of a permitted flavor.\nbool Sema::ICEConvertDiagnoser::match(QualType T) {\n  return AllowScopedEnumerations ? T->isIntegralOrEnumerationType()\n                                 : T->isIntegralOrUnscopedEnumerationType();\n}\n\nstatic ExprResult\ndiagnoseAmbiguousConversion(Sema &SemaRef, SourceLocation Loc, Expr *From,\n                            Sema::ContextualImplicitConverter &Converter,\n                            QualType T, UnresolvedSetImpl &ViableConversions) {\n\n  if (Converter.Suppress)\n    return ExprError();\n\n  Converter.diagnoseAmbiguous(SemaRef, Loc, T) << From->getSourceRange();\n  for (unsigned I = 0, N = ViableConversions.size(); I != N; ++I) {\n    CXXConversionDecl *Conv =\n        cast<CXXConversionDecl>(ViableConversions[I]->getUnderlyingDecl());\n    QualType ConvTy = Conv->getConversionType().getNonReferenceType();\n    Converter.noteAmbiguous(SemaRef, Conv, ConvTy);\n  }\n  return From;\n}\n\nstatic bool\ndiagnoseNoViableConversion(Sema &SemaRef, SourceLocation Loc, Expr *&From,\n                           Sema::ContextualImplicitConverter &Converter,\n                           QualType T, bool HadMultipleCandidates,\n                           UnresolvedSetImpl &ExplicitConversions) {\n  if (ExplicitConversions.size() == 1 && !Converter.Suppress) {\n    DeclAccessPair Found = ExplicitConversions[0];\n    CXXConversionDecl *Conversion =\n        cast<CXXConversionDecl>(Found->getUnderlyingDecl());\n\n    // The user probably meant to invoke the given explicit\n    // conversion; use it.\n    QualType ConvTy = Conversion->getConversionType().getNonReferenceType();\n    std::string TypeStr;\n    ConvTy.getAsStringInternal(TypeStr, SemaRef.getPrintingPolicy());\n\n    Converter.diagnoseExplicitConv(SemaRef, Loc, T, ConvTy)\n        << FixItHint::CreateInsertion(From->getBeginLoc(),\n                                      \"static_cast<\" + TypeStr + \">(\")\n        << FixItHint::CreateInsertion(\n               SemaRef.getLocForEndOfToken(From->getEndLoc()), \")\");\n    Converter.noteExplicitConv(SemaRef, Conversion, ConvTy);\n\n    // If we aren't in a SFINAE context, build a call to the\n    // explicit conversion function.\n    if (SemaRef.isSFINAEContext())\n      return true;\n\n    SemaRef.CheckMemberOperatorAccess(From->getExprLoc(), From, nullptr, Found);\n    ExprResult Result = SemaRef.BuildCXXMemberCallExpr(From, Found, Conversion,\n                                                       HadMultipleCandidates);\n    if (Result.isInvalid())\n      return true;\n    // Record usage of conversion in an implicit cast.\n    From = ImplicitCastExpr::Create(SemaRef.Context, Result.get()->getType(),\n                                    CK_UserDefinedConversion, Result.get(),\n                                    nullptr, Result.get()->getValueKind(),\n                                    SemaRef.CurFPFeatureOverrides());\n  }\n  return false;\n}\n\nstatic bool recordConversion(Sema &SemaRef, SourceLocation Loc, Expr *&From,\n                             Sema::ContextualImplicitConverter &Converter,\n                             QualType T, bool HadMultipleCandidates,\n                             DeclAccessPair &Found) {\n  CXXConversionDecl *Conversion =\n      cast<CXXConversionDecl>(Found->getUnderlyingDecl());\n  SemaRef.CheckMemberOperatorAccess(From->getExprLoc(), From, nullptr, Found);\n\n  QualType ToType = Conversion->getConversionType().getNonReferenceType();\n  if (!Converter.SuppressConversion) {\n    if (SemaRef.isSFINAEContext())\n      return true;\n\n    Converter.diagnoseConversion(SemaRef, Loc, T, ToType)\n        << From->getSourceRange();\n  }\n\n  ExprResult Result = SemaRef.BuildCXXMemberCallExpr(From, Found, Conversion,\n                                                     HadMultipleCandidates);\n  if (Result.isInvalid())\n    return true;\n  // Record usage of conversion in an implicit cast.\n  From = ImplicitCastExpr::Create(SemaRef.Context, Result.get()->getType(),\n                                  CK_UserDefinedConversion, Result.get(),\n                                  nullptr, Result.get()->getValueKind(),\n                                  SemaRef.CurFPFeatureOverrides());\n  return false;\n}\n\nstatic ExprResult finishContextualImplicitConversion(\n    Sema &SemaRef, SourceLocation Loc, Expr *From,\n    Sema::ContextualImplicitConverter &Converter) {\n  if (!Converter.match(From->getType()) && !Converter.Suppress)\n    Converter.diagnoseNoMatch(SemaRef, Loc, From->getType())\n        << From->getSourceRange();\n\n  return SemaRef.DefaultLvalueConversion(From);\n}\n\nstatic void\ncollectViableConversionCandidates(Sema &SemaRef, Expr *From, QualType ToType,\n                                  UnresolvedSetImpl &ViableConversions,\n                                  OverloadCandidateSet &CandidateSet) {\n  for (unsigned I = 0, N = ViableConversions.size(); I != N; ++I) {\n    DeclAccessPair FoundDecl = ViableConversions[I];\n    NamedDecl *D = FoundDecl.getDecl();\n    CXXRecordDecl *ActingContext = cast<CXXRecordDecl>(D->getDeclContext());\n    if (isa<UsingShadowDecl>(D))\n      D = cast<UsingShadowDecl>(D)->getTargetDecl();\n\n    CXXConversionDecl *Conv;\n    FunctionTemplateDecl *ConvTemplate;\n    if ((ConvTemplate = dyn_cast<FunctionTemplateDecl>(D)))\n      Conv = cast<CXXConversionDecl>(ConvTemplate->getTemplatedDecl());\n    else\n      Conv = cast<CXXConversionDecl>(D);\n\n    if (ConvTemplate)\n      SemaRef.AddTemplateConversionCandidate(\n          ConvTemplate, FoundDecl, ActingContext, From, ToType, CandidateSet,\n          /*AllowObjCConversionOnExplicit=*/false, /*AllowExplicit*/ true);\n    else\n      SemaRef.AddConversionCandidate(Conv, FoundDecl, ActingContext, From,\n                                     ToType, CandidateSet,\n                                     /*AllowObjCConversionOnExplicit=*/false,\n                                     /*AllowExplicit*/ true);\n  }\n}\n\n/// Attempt to convert the given expression to a type which is accepted\n/// by the given converter.\n///\n/// This routine will attempt to convert an expression of class type to a\n/// type accepted by the specified converter. In C++11 and before, the class\n/// must have a single non-explicit conversion function converting to a matching\n/// type. In C++1y, there can be multiple such conversion functions, but only\n/// one target type.\n///\n/// \\param Loc The source location of the construct that requires the\n/// conversion.\n///\n/// \\param From The expression we're converting from.\n///\n/// \\param Converter Used to control and diagnose the conversion process.\n///\n/// \\returns The expression, converted to an integral or enumeration type if\n/// successful.\nExprResult Sema::PerformContextualImplicitConversion(\n    SourceLocation Loc, Expr *From, ContextualImplicitConverter &Converter) {\n  // We can't perform any more checking for type-dependent expressions.\n  if (From->isTypeDependent())\n    return From;\n\n  // Process placeholders immediately.\n  if (From->hasPlaceholderType()) {\n    ExprResult result = CheckPlaceholderExpr(From);\n    if (result.isInvalid())\n      return result;\n    From = result.get();\n  }\n\n  // If the expression already has a matching type, we're golden.\n  QualType T = From->getType();\n  if (Converter.match(T))\n    return DefaultLvalueConversion(From);\n\n  // FIXME: Check for missing '()' if T is a function type?\n\n  // We can only perform contextual implicit conversions on objects of class\n  // type.\n  const RecordType *RecordTy = T->getAs<RecordType>();\n  if (!RecordTy || !getLangOpts().CPlusPlus) {\n    if (!Converter.Suppress)\n      Converter.diagnoseNoMatch(*this, Loc, T) << From->getSourceRange();\n    return From;\n  }\n\n  // We must have a complete class type.\n  struct TypeDiagnoserPartialDiag : TypeDiagnoser {\n    ContextualImplicitConverter &Converter;\n    Expr *From;\n\n    TypeDiagnoserPartialDiag(ContextualImplicitConverter &Converter, Expr *From)\n        : Converter(Converter), From(From) {}\n\n    void diagnose(Sema &S, SourceLocation Loc, QualType T) override {\n      Converter.diagnoseIncomplete(S, Loc, T) << From->getSourceRange();\n    }\n  } IncompleteDiagnoser(Converter, From);\n\n  if (Converter.Suppress ? !isCompleteType(Loc, T)\n                         : RequireCompleteType(Loc, T, IncompleteDiagnoser))\n    return From;\n\n  // Look for a conversion to an integral or enumeration type.\n  UnresolvedSet<4>\n      ViableConversions; // These are *potentially* viable in C++1y.\n  UnresolvedSet<4> ExplicitConversions;\n  const auto &Conversions =\n      cast<CXXRecordDecl>(RecordTy->getDecl())->getVisibleConversionFunctions();\n\n  bool HadMultipleCandidates =\n      (std::distance(Conversions.begin(), Conversions.end()) > 1);\n\n  // To check that there is only one target type, in C++1y:\n  QualType ToType;\n  bool HasUniqueTargetType = true;\n\n  // Collect explicit or viable (potentially in C++1y) conversions.\n  for (auto I = Conversions.begin(), E = Conversions.end(); I != E; ++I) {\n    NamedDecl *D = (*I)->getUnderlyingDecl();\n    CXXConversionDecl *Conversion;\n    FunctionTemplateDecl *ConvTemplate = dyn_cast<FunctionTemplateDecl>(D);\n    if (ConvTemplate) {\n      if (getLangOpts().CPlusPlus14)\n        Conversion = cast<CXXConversionDecl>(ConvTemplate->getTemplatedDecl());\n      else\n        continue; // C++11 does not consider conversion operator templates(?).\n    } else\n      Conversion = cast<CXXConversionDecl>(D);\n\n    assert((!ConvTemplate || getLangOpts().CPlusPlus14) &&\n           \"Conversion operator templates are considered potentially \"\n           \"viable in C++1y\");\n\n    QualType CurToType = Conversion->getConversionType().getNonReferenceType();\n    if (Converter.match(CurToType) || ConvTemplate) {\n\n      if (Conversion->isExplicit()) {\n        // FIXME: For C++1y, do we need this restriction?\n        // cf. diagnoseNoViableConversion()\n        if (!ConvTemplate)\n          ExplicitConversions.addDecl(I.getDecl(), I.getAccess());\n      } else {\n        if (!ConvTemplate && getLangOpts().CPlusPlus14) {\n          if (ToType.isNull())\n            ToType = CurToType.getUnqualifiedType();\n          else if (HasUniqueTargetType &&\n                   (CurToType.getUnqualifiedType() != ToType))\n            HasUniqueTargetType = false;\n        }\n        ViableConversions.addDecl(I.getDecl(), I.getAccess());\n      }\n    }\n  }\n\n  if (getLangOpts().CPlusPlus14) {\n    // C++1y [conv]p6:\n    // ... An expression e of class type E appearing in such a context\n    // is said to be contextually implicitly converted to a specified\n    // type T and is well-formed if and only if e can be implicitly\n    // converted to a type T that is determined as follows: E is searched\n    // for conversion functions whose return type is cv T or reference to\n    // cv T such that T is allowed by the context. There shall be\n    // exactly one such T.\n\n    // If no unique T is found:\n    if (ToType.isNull()) {\n      if (diagnoseNoViableConversion(*this, Loc, From, Converter, T,\n                                     HadMultipleCandidates,\n                                     ExplicitConversions))\n        return ExprError();\n      return finishContextualImplicitConversion(*this, Loc, From, Converter);\n    }\n\n    // If more than one unique Ts are found:\n    if (!HasUniqueTargetType)\n      return diagnoseAmbiguousConversion(*this, Loc, From, Converter, T,\n                                         ViableConversions);\n\n    // If one unique T is found:\n    // First, build a candidate set from the previously recorded\n    // potentially viable conversions.\n    OverloadCandidateSet CandidateSet(Loc, OverloadCandidateSet::CSK_Normal);\n    collectViableConversionCandidates(*this, From, ToType, ViableConversions,\n                                      CandidateSet);\n\n    // Then, perform overload resolution over the candidate set.\n    OverloadCandidateSet::iterator Best;\n    switch (CandidateSet.BestViableFunction(*this, Loc, Best)) {\n    case OR_Success: {\n      // Apply this conversion.\n      DeclAccessPair Found =\n          DeclAccessPair::make(Best->Function, Best->FoundDecl.getAccess());\n      if (recordConversion(*this, Loc, From, Converter, T,\n                           HadMultipleCandidates, Found))\n        return ExprError();\n      break;\n    }\n    case OR_Ambiguous:\n      return diagnoseAmbiguousConversion(*this, Loc, From, Converter, T,\n                                         ViableConversions);\n    case OR_No_Viable_Function:\n      if (diagnoseNoViableConversion(*this, Loc, From, Converter, T,\n                                     HadMultipleCandidates,\n                                     ExplicitConversions))\n        return ExprError();\n      LLVM_FALLTHROUGH;\n    case OR_Deleted:\n      // We'll complain below about a non-integral condition type.\n      break;\n    }\n  } else {\n    switch (ViableConversions.size()) {\n    case 0: {\n      if (diagnoseNoViableConversion(*this, Loc, From, Converter, T,\n                                     HadMultipleCandidates,\n                                     ExplicitConversions))\n        return ExprError();\n\n      // We'll complain below about a non-integral condition type.\n      break;\n    }\n    case 1: {\n      // Apply this conversion.\n      DeclAccessPair Found = ViableConversions[0];\n      if (recordConversion(*this, Loc, From, Converter, T,\n                           HadMultipleCandidates, Found))\n        return ExprError();\n      break;\n    }\n    default:\n      return diagnoseAmbiguousConversion(*this, Loc, From, Converter, T,\n                                         ViableConversions);\n    }\n  }\n\n  return finishContextualImplicitConversion(*this, Loc, From, Converter);\n}\n\n/// IsAcceptableNonMemberOperatorCandidate - Determine whether Fn is\n/// an acceptable non-member overloaded operator for a call whose\n/// arguments have types T1 (and, if non-empty, T2). This routine\n/// implements the check in C++ [over.match.oper]p3b2 concerning\n/// enumeration types.\nstatic bool IsAcceptableNonMemberOperatorCandidate(ASTContext &Context,\n                                                   FunctionDecl *Fn,\n                                                   ArrayRef<Expr *> Args) {\n  QualType T1 = Args[0]->getType();\n  QualType T2 = Args.size() > 1 ? Args[1]->getType() : QualType();\n\n  if (T1->isDependentType() || (!T2.isNull() && T2->isDependentType()))\n    return true;\n\n  if (T1->isRecordType() || (!T2.isNull() && T2->isRecordType()))\n    return true;\n\n  const auto *Proto = Fn->getType()->castAs<FunctionProtoType>();\n  if (Proto->getNumParams() < 1)\n    return false;\n\n  if (T1->isEnumeralType()) {\n    QualType ArgType = Proto->getParamType(0).getNonReferenceType();\n    if (Context.hasSameUnqualifiedType(T1, ArgType))\n      return true;\n  }\n\n  if (Proto->getNumParams() < 2)\n    return false;\n\n  if (!T2.isNull() && T2->isEnumeralType()) {\n    QualType ArgType = Proto->getParamType(1).getNonReferenceType();\n    if (Context.hasSameUnqualifiedType(T2, ArgType))\n      return true;\n  }\n\n  return false;\n}\n\n/// AddOverloadCandidate - Adds the given function to the set of\n/// candidate functions, using the given function call arguments.  If\n/// @p SuppressUserConversions, then don't allow user-defined\n/// conversions via constructors or conversion operators.\n///\n/// \\param PartialOverloading true if we are performing \"partial\" overloading\n/// based on an incomplete set of function arguments. This feature is used by\n/// code completion.\nvoid Sema::AddOverloadCandidate(\n    FunctionDecl *Function, DeclAccessPair FoundDecl, ArrayRef<Expr *> Args,\n    OverloadCandidateSet &CandidateSet, bool SuppressUserConversions,\n    bool PartialOverloading, bool AllowExplicit, bool AllowExplicitConversions,\n    ADLCallKind IsADLCandidate, ConversionSequenceList EarlyConversions,\n    OverloadCandidateParamOrder PO) {\n  const FunctionProtoType *Proto\n    = dyn_cast<FunctionProtoType>(Function->getType()->getAs<FunctionType>());\n  assert(Proto && \"Functions without a prototype cannot be overloaded\");\n  assert(!Function->getDescribedFunctionTemplate() &&\n         \"Use AddTemplateOverloadCandidate for function templates\");\n\n  if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(Function)) {\n    if (!isa<CXXConstructorDecl>(Method)) {\n      // If we get here, it's because we're calling a member function\n      // that is named without a member access expression (e.g.,\n      // \"this->f\") that was either written explicitly or created\n      // implicitly. This can happen with a qualified call to a member\n      // function, e.g., X::f(). We use an empty type for the implied\n      // object argument (C++ [over.call.func]p3), and the acting context\n      // is irrelevant.\n      AddMethodCandidate(Method, FoundDecl, Method->getParent(), QualType(),\n                         Expr::Classification::makeSimpleLValue(), Args,\n                         CandidateSet, SuppressUserConversions,\n                         PartialOverloading, EarlyConversions, PO);\n      return;\n    }\n    // We treat a constructor like a non-member function, since its object\n    // argument doesn't participate in overload resolution.\n  }\n\n  if (!CandidateSet.isNewCandidate(Function, PO))\n    return;\n\n  // C++11 [class.copy]p11: [DR1402]\n  //   A defaulted move constructor that is defined as deleted is ignored by\n  //   overload resolution.\n  CXXConstructorDecl *Constructor = dyn_cast<CXXConstructorDecl>(Function);\n  if (Constructor && Constructor->isDefaulted() && Constructor->isDeleted() &&\n      Constructor->isMoveConstructor())\n    return;\n\n  // Overload resolution is always an unevaluated context.\n  EnterExpressionEvaluationContext Unevaluated(\n      *this, Sema::ExpressionEvaluationContext::Unevaluated);\n\n  // C++ [over.match.oper]p3:\n  //   if no operand has a class type, only those non-member functions in the\n  //   lookup set that have a first parameter of type T1 or \"reference to\n  //   (possibly cv-qualified) T1\", when T1 is an enumeration type, or (if there\n  //   is a right operand) a second parameter of type T2 or \"reference to\n  //   (possibly cv-qualified) T2\", when T2 is an enumeration type, are\n  //   candidate functions.\n  if (CandidateSet.getKind() == OverloadCandidateSet::CSK_Operator &&\n      !IsAcceptableNonMemberOperatorCandidate(Context, Function, Args))\n    return;\n\n  // Add this candidate\n  OverloadCandidate &Candidate =\n      CandidateSet.addCandidate(Args.size(), EarlyConversions);\n  Candidate.FoundDecl = FoundDecl;\n  Candidate.Function = Function;\n  Candidate.Viable = true;\n  Candidate.RewriteKind =\n      CandidateSet.getRewriteInfo().getRewriteKind(Function, PO);\n  Candidate.IsSurrogate = false;\n  Candidate.IsADLCandidate = IsADLCandidate;\n  Candidate.IgnoreObjectArgument = false;\n  Candidate.ExplicitCallArguments = Args.size();\n\n  // Explicit functions are not actually candidates at all if we're not\n  // allowing them in this context, but keep them around so we can point\n  // to them in diagnostics.\n  if (!AllowExplicit && ExplicitSpecifier::getFromDecl(Function).isExplicit()) {\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_explicit;\n    return;\n  }\n\n  if (Function->isMultiVersion() && Function->hasAttr<TargetAttr>() &&\n      !Function->getAttr<TargetAttr>()->isDefaultVersion()) {\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_non_default_multiversion_function;\n    return;\n  }\n\n  if (Constructor) {\n    // C++ [class.copy]p3:\n    //   A member function template is never instantiated to perform the copy\n    //   of a class object to an object of its class type.\n    QualType ClassType = Context.getTypeDeclType(Constructor->getParent());\n    if (Args.size() == 1 && Constructor->isSpecializationCopyingObject() &&\n        (Context.hasSameUnqualifiedType(ClassType, Args[0]->getType()) ||\n         IsDerivedFrom(Args[0]->getBeginLoc(), Args[0]->getType(),\n                       ClassType))) {\n      Candidate.Viable = false;\n      Candidate.FailureKind = ovl_fail_illegal_constructor;\n      return;\n    }\n\n    // C++ [over.match.funcs]p8: (proposed DR resolution)\n    //   A constructor inherited from class type C that has a first parameter\n    //   of type \"reference to P\" (including such a constructor instantiated\n    //   from a template) is excluded from the set of candidate functions when\n    //   constructing an object of type cv D if the argument list has exactly\n    //   one argument and D is reference-related to P and P is reference-related\n    //   to C.\n    auto *Shadow = dyn_cast<ConstructorUsingShadowDecl>(FoundDecl.getDecl());\n    if (Shadow && Args.size() == 1 && Constructor->getNumParams() >= 1 &&\n        Constructor->getParamDecl(0)->getType()->isReferenceType()) {\n      QualType P = Constructor->getParamDecl(0)->getType()->getPointeeType();\n      QualType C = Context.getRecordType(Constructor->getParent());\n      QualType D = Context.getRecordType(Shadow->getParent());\n      SourceLocation Loc = Args.front()->getExprLoc();\n      if ((Context.hasSameUnqualifiedType(P, C) || IsDerivedFrom(Loc, P, C)) &&\n          (Context.hasSameUnqualifiedType(D, P) || IsDerivedFrom(Loc, D, P))) {\n        Candidate.Viable = false;\n        Candidate.FailureKind = ovl_fail_inhctor_slice;\n        return;\n      }\n    }\n\n    // Check that the constructor is capable of constructing an object in the\n    // destination address space.\n    if (!Qualifiers::isAddressSpaceSupersetOf(\n            Constructor->getMethodQualifiers().getAddressSpace(),\n            CandidateSet.getDestAS())) {\n      Candidate.Viable = false;\n      Candidate.FailureKind = ovl_fail_object_addrspace_mismatch;\n    }\n  }\n\n  unsigned NumParams = Proto->getNumParams();\n\n  // (C++ 13.3.2p2): A candidate function having fewer than m\n  // parameters is viable only if it has an ellipsis in its parameter\n  // list (8.3.5).\n  if (TooManyArguments(NumParams, Args.size(), PartialOverloading) &&\n      !Proto->isVariadic()) {\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_too_many_arguments;\n    return;\n  }\n\n  // (C++ 13.3.2p2): A candidate function having more than m parameters\n  // is viable only if the (m+1)st parameter has a default argument\n  // (8.3.6). For the purposes of overload resolution, the\n  // parameter list is truncated on the right, so that there are\n  // exactly m parameters.\n  unsigned MinRequiredArgs = Function->getMinRequiredArguments();\n  if (Args.size() < MinRequiredArgs && !PartialOverloading) {\n    // Not enough arguments.\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_too_few_arguments;\n    return;\n  }\n\n  // (CUDA B.1): Check for invalid calls between targets.\n  if (getLangOpts().CUDA)\n    if (const FunctionDecl *Caller = dyn_cast<FunctionDecl>(CurContext))\n      // Skip the check for callers that are implicit members, because in this\n      // case we may not yet know what the member's target is; the target is\n      // inferred for the member automatically, based on the bases and fields of\n      // the class.\n      if (!Caller->isImplicit() && !IsAllowedCUDACall(Caller, Function)) {\n        Candidate.Viable = false;\n        Candidate.FailureKind = ovl_fail_bad_target;\n        return;\n      }\n\n  if (Function->getTrailingRequiresClause()) {\n    ConstraintSatisfaction Satisfaction;\n    if (CheckFunctionConstraints(Function, Satisfaction) ||\n        !Satisfaction.IsSatisfied) {\n      Candidate.Viable = false;\n      Candidate.FailureKind = ovl_fail_constraints_not_satisfied;\n      return;\n    }\n  }\n\n  // Determine the implicit conversion sequences for each of the\n  // arguments.\n  for (unsigned ArgIdx = 0; ArgIdx < Args.size(); ++ArgIdx) {\n    unsigned ConvIdx =\n        PO == OverloadCandidateParamOrder::Reversed ? 1 - ArgIdx : ArgIdx;\n    if (Candidate.Conversions[ConvIdx].isInitialized()) {\n      // We already formed a conversion sequence for this parameter during\n      // template argument deduction.\n    } else if (ArgIdx < NumParams) {\n      // (C++ 13.3.2p3): for F to be a viable function, there shall\n      // exist for each argument an implicit conversion sequence\n      // (13.3.3.1) that converts that argument to the corresponding\n      // parameter of F.\n      QualType ParamType = Proto->getParamType(ArgIdx);\n      Candidate.Conversions[ConvIdx] = TryCopyInitialization(\n          *this, Args[ArgIdx], ParamType, SuppressUserConversions,\n          /*InOverloadResolution=*/true,\n          /*AllowObjCWritebackConversion=*/\n          getLangOpts().ObjCAutoRefCount, AllowExplicitConversions);\n      if (Candidate.Conversions[ConvIdx].isBad()) {\n        Candidate.Viable = false;\n        Candidate.FailureKind = ovl_fail_bad_conversion;\n        return;\n      }\n    } else {\n      // (C++ 13.3.2p2): For the purposes of overload resolution, any\n      // argument for which there is no corresponding parameter is\n      // considered to \"\"match the ellipsis\" (C+ 13.3.3.1.3).\n      Candidate.Conversions[ConvIdx].setEllipsis();\n    }\n  }\n\n  if (EnableIfAttr *FailedAttr =\n          CheckEnableIf(Function, CandidateSet.getLocation(), Args)) {\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_enable_if;\n    Candidate.DeductionFailure.Data = FailedAttr;\n    return;\n  }\n\n  if (LangOpts.OpenCL && isOpenCLDisabledDecl(Function)) {\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_ext_disabled;\n    return;\n  }\n}\n\nObjCMethodDecl *\nSema::SelectBestMethod(Selector Sel, MultiExprArg Args, bool IsInstance,\n                       SmallVectorImpl<ObjCMethodDecl *> &Methods) {\n  if (Methods.size() <= 1)\n    return nullptr;\n\n  for (unsigned b = 0, e = Methods.size(); b < e; b++) {\n    bool Match = true;\n    ObjCMethodDecl *Method = Methods[b];\n    unsigned NumNamedArgs = Sel.getNumArgs();\n    // Method might have more arguments than selector indicates. This is due\n    // to addition of c-style arguments in method.\n    if (Method->param_size() > NumNamedArgs)\n      NumNamedArgs = Method->param_size();\n    if (Args.size() < NumNamedArgs)\n      continue;\n\n    for (unsigned i = 0; i < NumNamedArgs; i++) {\n      // We can't do any type-checking on a type-dependent argument.\n      if (Args[i]->isTypeDependent()) {\n        Match = false;\n        break;\n      }\n\n      ParmVarDecl *param = Method->parameters()[i];\n      Expr *argExpr = Args[i];\n      assert(argExpr && \"SelectBestMethod(): missing expression\");\n\n      // Strip the unbridged-cast placeholder expression off unless it's\n      // a consumed argument.\n      if (argExpr->hasPlaceholderType(BuiltinType::ARCUnbridgedCast) &&\n          !param->hasAttr<CFConsumedAttr>())\n        argExpr = stripARCUnbridgedCast(argExpr);\n\n      // If the parameter is __unknown_anytype, move on to the next method.\n      if (param->getType() == Context.UnknownAnyTy) {\n        Match = false;\n        break;\n      }\n\n      ImplicitConversionSequence ConversionState\n        = TryCopyInitialization(*this, argExpr, param->getType(),\n                                /*SuppressUserConversions*/false,\n                                /*InOverloadResolution=*/true,\n                                /*AllowObjCWritebackConversion=*/\n                                getLangOpts().ObjCAutoRefCount,\n                                /*AllowExplicit*/false);\n      // This function looks for a reasonably-exact match, so we consider\n      // incompatible pointer conversions to be a failure here.\n      if (ConversionState.isBad() ||\n          (ConversionState.isStandard() &&\n           ConversionState.Standard.Second ==\n               ICK_Incompatible_Pointer_Conversion)) {\n        Match = false;\n        break;\n      }\n    }\n    // Promote additional arguments to variadic methods.\n    if (Match && Method->isVariadic()) {\n      for (unsigned i = NumNamedArgs, e = Args.size(); i < e; ++i) {\n        if (Args[i]->isTypeDependent()) {\n          Match = false;\n          break;\n        }\n        ExprResult Arg = DefaultVariadicArgumentPromotion(Args[i], VariadicMethod,\n                                                          nullptr);\n        if (Arg.isInvalid()) {\n          Match = false;\n          break;\n        }\n      }\n    } else {\n      // Check for extra arguments to non-variadic methods.\n      if (Args.size() != NumNamedArgs)\n        Match = false;\n      else if (Match && NumNamedArgs == 0 && Methods.size() > 1) {\n        // Special case when selectors have no argument. In this case, select\n        // one with the most general result type of 'id'.\n        for (unsigned b = 0, e = Methods.size(); b < e; b++) {\n          QualType ReturnT = Methods[b]->getReturnType();\n          if (ReturnT->isObjCIdType())\n            return Methods[b];\n        }\n      }\n    }\n\n    if (Match)\n      return Method;\n  }\n  return nullptr;\n}\n\nstatic bool convertArgsForAvailabilityChecks(\n    Sema &S, FunctionDecl *Function, Expr *ThisArg, SourceLocation CallLoc,\n    ArrayRef<Expr *> Args, Sema::SFINAETrap &Trap, bool MissingImplicitThis,\n    Expr *&ConvertedThis, SmallVectorImpl<Expr *> &ConvertedArgs) {\n  if (ThisArg) {\n    CXXMethodDecl *Method = cast<CXXMethodDecl>(Function);\n    assert(!isa<CXXConstructorDecl>(Method) &&\n           \"Shouldn't have `this` for ctors!\");\n    assert(!Method->isStatic() && \"Shouldn't have `this` for static methods!\");\n    ExprResult R = S.PerformObjectArgumentInitialization(\n        ThisArg, /*Qualifier=*/nullptr, Method, Method);\n    if (R.isInvalid())\n      return false;\n    ConvertedThis = R.get();\n  } else {\n    if (auto *MD = dyn_cast<CXXMethodDecl>(Function)) {\n      (void)MD;\n      assert((MissingImplicitThis || MD->isStatic() ||\n              isa<CXXConstructorDecl>(MD)) &&\n             \"Expected `this` for non-ctor instance methods\");\n    }\n    ConvertedThis = nullptr;\n  }\n\n  // Ignore any variadic arguments. Converting them is pointless, since the\n  // user can't refer to them in the function condition.\n  unsigned ArgSizeNoVarargs = std::min(Function->param_size(), Args.size());\n\n  // Convert the arguments.\n  for (unsigned I = 0; I != ArgSizeNoVarargs; ++I) {\n    ExprResult R;\n    R = S.PerformCopyInitialization(InitializedEntity::InitializeParameter(\n                                        S.Context, Function->getParamDecl(I)),\n                                    SourceLocation(), Args[I]);\n\n    if (R.isInvalid())\n      return false;\n\n    ConvertedArgs.push_back(R.get());\n  }\n\n  if (Trap.hasErrorOccurred())\n    return false;\n\n  // Push default arguments if needed.\n  if (!Function->isVariadic() && Args.size() < Function->getNumParams()) {\n    for (unsigned i = Args.size(), e = Function->getNumParams(); i != e; ++i) {\n      ParmVarDecl *P = Function->getParamDecl(i);\n      if (!P->hasDefaultArg())\n        return false;\n      ExprResult R = S.BuildCXXDefaultArgExpr(CallLoc, Function, P);\n      if (R.isInvalid())\n        return false;\n      ConvertedArgs.push_back(R.get());\n    }\n\n    if (Trap.hasErrorOccurred())\n      return false;\n  }\n  return true;\n}\n\nEnableIfAttr *Sema::CheckEnableIf(FunctionDecl *Function,\n                                  SourceLocation CallLoc,\n                                  ArrayRef<Expr *> Args,\n                                  bool MissingImplicitThis) {\n  auto EnableIfAttrs = Function->specific_attrs<EnableIfAttr>();\n  if (EnableIfAttrs.begin() == EnableIfAttrs.end())\n    return nullptr;\n\n  SFINAETrap Trap(*this);\n  SmallVector<Expr *, 16> ConvertedArgs;\n  // FIXME: We should look into making enable_if late-parsed.\n  Expr *DiscardedThis;\n  if (!convertArgsForAvailabilityChecks(\n          *this, Function, /*ThisArg=*/nullptr, CallLoc, Args, Trap,\n          /*MissingImplicitThis=*/true, DiscardedThis, ConvertedArgs))\n    return *EnableIfAttrs.begin();\n\n  for (auto *EIA : EnableIfAttrs) {\n    APValue Result;\n    // FIXME: This doesn't consider value-dependent cases, because doing so is\n    // very difficult. Ideally, we should handle them more gracefully.\n    if (EIA->getCond()->isValueDependent() ||\n        !EIA->getCond()->EvaluateWithSubstitution(\n            Result, Context, Function, llvm::makeArrayRef(ConvertedArgs)))\n      return EIA;\n\n    if (!Result.isInt() || !Result.getInt().getBoolValue())\n      return EIA;\n  }\n  return nullptr;\n}\n\ntemplate <typename CheckFn>\nstatic bool diagnoseDiagnoseIfAttrsWith(Sema &S, const NamedDecl *ND,\n                                        bool ArgDependent, SourceLocation Loc,\n                                        CheckFn &&IsSuccessful) {\n  SmallVector<const DiagnoseIfAttr *, 8> Attrs;\n  for (const auto *DIA : ND->specific_attrs<DiagnoseIfAttr>()) {\n    if (ArgDependent == DIA->getArgDependent())\n      Attrs.push_back(DIA);\n  }\n\n  // Common case: No diagnose_if attributes, so we can quit early.\n  if (Attrs.empty())\n    return false;\n\n  auto WarningBegin = std::stable_partition(\n      Attrs.begin(), Attrs.end(),\n      [](const DiagnoseIfAttr *DIA) { return DIA->isError(); });\n\n  // Note that diagnose_if attributes are late-parsed, so they appear in the\n  // correct order (unlike enable_if attributes).\n  auto ErrAttr = llvm::find_if(llvm::make_range(Attrs.begin(), WarningBegin),\n                               IsSuccessful);\n  if (ErrAttr != WarningBegin) {\n    const DiagnoseIfAttr *DIA = *ErrAttr;\n    S.Diag(Loc, diag::err_diagnose_if_succeeded) << DIA->getMessage();\n    S.Diag(DIA->getLocation(), diag::note_from_diagnose_if)\n        << DIA->getParent() << DIA->getCond()->getSourceRange();\n    return true;\n  }\n\n  for (const auto *DIA : llvm::make_range(WarningBegin, Attrs.end()))\n    if (IsSuccessful(DIA)) {\n      S.Diag(Loc, diag::warn_diagnose_if_succeeded) << DIA->getMessage();\n      S.Diag(DIA->getLocation(), diag::note_from_diagnose_if)\n          << DIA->getParent() << DIA->getCond()->getSourceRange();\n    }\n\n  return false;\n}\n\nbool Sema::diagnoseArgDependentDiagnoseIfAttrs(const FunctionDecl *Function,\n                                               const Expr *ThisArg,\n                                               ArrayRef<const Expr *> Args,\n                                               SourceLocation Loc) {\n  return diagnoseDiagnoseIfAttrsWith(\n      *this, Function, /*ArgDependent=*/true, Loc,\n      [&](const DiagnoseIfAttr *DIA) {\n        APValue Result;\n        // It's sane to use the same Args for any redecl of this function, since\n        // EvaluateWithSubstitution only cares about the position of each\n        // argument in the arg list, not the ParmVarDecl* it maps to.\n        if (!DIA->getCond()->EvaluateWithSubstitution(\n                Result, Context, cast<FunctionDecl>(DIA->getParent()), Args, ThisArg))\n          return false;\n        return Result.isInt() && Result.getInt().getBoolValue();\n      });\n}\n\nbool Sema::diagnoseArgIndependentDiagnoseIfAttrs(const NamedDecl *ND,\n                                                 SourceLocation Loc) {\n  return diagnoseDiagnoseIfAttrsWith(\n      *this, ND, /*ArgDependent=*/false, Loc,\n      [&](const DiagnoseIfAttr *DIA) {\n        bool Result;\n        return DIA->getCond()->EvaluateAsBooleanCondition(Result, Context) &&\n               Result;\n      });\n}\n\n/// Add all of the function declarations in the given function set to\n/// the overload candidate set.\nvoid Sema::AddFunctionCandidates(const UnresolvedSetImpl &Fns,\n                                 ArrayRef<Expr *> Args,\n                                 OverloadCandidateSet &CandidateSet,\n                                 TemplateArgumentListInfo *ExplicitTemplateArgs,\n                                 bool SuppressUserConversions,\n                                 bool PartialOverloading,\n                                 bool FirstArgumentIsBase) {\n  for (UnresolvedSetIterator F = Fns.begin(), E = Fns.end(); F != E; ++F) {\n    NamedDecl *D = F.getDecl()->getUnderlyingDecl();\n    ArrayRef<Expr *> FunctionArgs = Args;\n\n    FunctionTemplateDecl *FunTmpl = dyn_cast<FunctionTemplateDecl>(D);\n    FunctionDecl *FD =\n        FunTmpl ? FunTmpl->getTemplatedDecl() : cast<FunctionDecl>(D);\n\n    if (isa<CXXMethodDecl>(FD) && !cast<CXXMethodDecl>(FD)->isStatic()) {\n      QualType ObjectType;\n      Expr::Classification ObjectClassification;\n      if (Args.size() > 0) {\n        if (Expr *E = Args[0]) {\n          // Use the explicit base to restrict the lookup:\n          ObjectType = E->getType();\n          // Pointers in the object arguments are implicitly dereferenced, so we\n          // always classify them as l-values.\n          if (!ObjectType.isNull() && ObjectType->isPointerType())\n            ObjectClassification = Expr::Classification::makeSimpleLValue();\n          else\n            ObjectClassification = E->Classify(Context);\n        } // .. else there is an implicit base.\n        FunctionArgs = Args.slice(1);\n      }\n      if (FunTmpl) {\n        AddMethodTemplateCandidate(\n            FunTmpl, F.getPair(),\n            cast<CXXRecordDecl>(FunTmpl->getDeclContext()),\n            ExplicitTemplateArgs, ObjectType, ObjectClassification,\n            FunctionArgs, CandidateSet, SuppressUserConversions,\n            PartialOverloading);\n      } else {\n        AddMethodCandidate(cast<CXXMethodDecl>(FD), F.getPair(),\n                           cast<CXXMethodDecl>(FD)->getParent(), ObjectType,\n                           ObjectClassification, FunctionArgs, CandidateSet,\n                           SuppressUserConversions, PartialOverloading);\n      }\n    } else {\n      // This branch handles both standalone functions and static methods.\n\n      // Slice the first argument (which is the base) when we access\n      // static method as non-static.\n      if (Args.size() > 0 &&\n          (!Args[0] || (FirstArgumentIsBase && isa<CXXMethodDecl>(FD) &&\n                        !isa<CXXConstructorDecl>(FD)))) {\n        assert(cast<CXXMethodDecl>(FD)->isStatic());\n        FunctionArgs = Args.slice(1);\n      }\n      if (FunTmpl) {\n        AddTemplateOverloadCandidate(FunTmpl, F.getPair(),\n                                     ExplicitTemplateArgs, FunctionArgs,\n                                     CandidateSet, SuppressUserConversions,\n                                     PartialOverloading);\n      } else {\n        AddOverloadCandidate(FD, F.getPair(), FunctionArgs, CandidateSet,\n                             SuppressUserConversions, PartialOverloading);\n      }\n    }\n  }\n}\n\n/// AddMethodCandidate - Adds a named decl (which is some kind of\n/// method) as a method candidate to the given overload set.\nvoid Sema::AddMethodCandidate(DeclAccessPair FoundDecl, QualType ObjectType,\n                              Expr::Classification ObjectClassification,\n                              ArrayRef<Expr *> Args,\n                              OverloadCandidateSet &CandidateSet,\n                              bool SuppressUserConversions,\n                              OverloadCandidateParamOrder PO) {\n  NamedDecl *Decl = FoundDecl.getDecl();\n  CXXRecordDecl *ActingContext = cast<CXXRecordDecl>(Decl->getDeclContext());\n\n  if (isa<UsingShadowDecl>(Decl))\n    Decl = cast<UsingShadowDecl>(Decl)->getTargetDecl();\n\n  if (FunctionTemplateDecl *TD = dyn_cast<FunctionTemplateDecl>(Decl)) {\n    assert(isa<CXXMethodDecl>(TD->getTemplatedDecl()) &&\n           \"Expected a member function template\");\n    AddMethodTemplateCandidate(TD, FoundDecl, ActingContext,\n                               /*ExplicitArgs*/ nullptr, ObjectType,\n                               ObjectClassification, Args, CandidateSet,\n                               SuppressUserConversions, false, PO);\n  } else {\n    AddMethodCandidate(cast<CXXMethodDecl>(Decl), FoundDecl, ActingContext,\n                       ObjectType, ObjectClassification, Args, CandidateSet,\n                       SuppressUserConversions, false, None, PO);\n  }\n}\n\n/// AddMethodCandidate - Adds the given C++ member function to the set\n/// of candidate functions, using the given function call arguments\n/// and the object argument (@c Object). For example, in a call\n/// @c o.f(a1,a2), @c Object will contain @c o and @c Args will contain\n/// both @c a1 and @c a2. If @p SuppressUserConversions, then don't\n/// allow user-defined conversions via constructors or conversion\n/// operators.\nvoid\nSema::AddMethodCandidate(CXXMethodDecl *Method, DeclAccessPair FoundDecl,\n                         CXXRecordDecl *ActingContext, QualType ObjectType,\n                         Expr::Classification ObjectClassification,\n                         ArrayRef<Expr *> Args,\n                         OverloadCandidateSet &CandidateSet,\n                         bool SuppressUserConversions,\n                         bool PartialOverloading,\n                         ConversionSequenceList EarlyConversions,\n                         OverloadCandidateParamOrder PO) {\n  const FunctionProtoType *Proto\n    = dyn_cast<FunctionProtoType>(Method->getType()->getAs<FunctionType>());\n  assert(Proto && \"Methods without a prototype cannot be overloaded\");\n  assert(!isa<CXXConstructorDecl>(Method) &&\n         \"Use AddOverloadCandidate for constructors\");\n\n  if (!CandidateSet.isNewCandidate(Method, PO))\n    return;\n\n  // C++11 [class.copy]p23: [DR1402]\n  //   A defaulted move assignment operator that is defined as deleted is\n  //   ignored by overload resolution.\n  if (Method->isDefaulted() && Method->isDeleted() &&\n      Method->isMoveAssignmentOperator())\n    return;\n\n  // Overload resolution is always an unevaluated context.\n  EnterExpressionEvaluationContext Unevaluated(\n      *this, Sema::ExpressionEvaluationContext::Unevaluated);\n\n  // Add this candidate\n  OverloadCandidate &Candidate =\n      CandidateSet.addCandidate(Args.size() + 1, EarlyConversions);\n  Candidate.FoundDecl = FoundDecl;\n  Candidate.Function = Method;\n  Candidate.RewriteKind =\n      CandidateSet.getRewriteInfo().getRewriteKind(Method, PO);\n  Candidate.IsSurrogate = false;\n  Candidate.IgnoreObjectArgument = false;\n  Candidate.ExplicitCallArguments = Args.size();\n\n  unsigned NumParams = Proto->getNumParams();\n\n  // (C++ 13.3.2p2): A candidate function having fewer than m\n  // parameters is viable only if it has an ellipsis in its parameter\n  // list (8.3.5).\n  if (TooManyArguments(NumParams, Args.size(), PartialOverloading) &&\n      !Proto->isVariadic()) {\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_too_many_arguments;\n    return;\n  }\n\n  // (C++ 13.3.2p2): A candidate function having more than m parameters\n  // is viable only if the (m+1)st parameter has a default argument\n  // (8.3.6). For the purposes of overload resolution, the\n  // parameter list is truncated on the right, so that there are\n  // exactly m parameters.\n  unsigned MinRequiredArgs = Method->getMinRequiredArguments();\n  if (Args.size() < MinRequiredArgs && !PartialOverloading) {\n    // Not enough arguments.\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_too_few_arguments;\n    return;\n  }\n\n  Candidate.Viable = true;\n\n  if (Method->isStatic() || ObjectType.isNull())\n    // The implicit object argument is ignored.\n    Candidate.IgnoreObjectArgument = true;\n  else {\n    unsigned ConvIdx = PO == OverloadCandidateParamOrder::Reversed ? 1 : 0;\n    // Determine the implicit conversion sequence for the object\n    // parameter.\n    Candidate.Conversions[ConvIdx] = TryObjectArgumentInitialization(\n        *this, CandidateSet.getLocation(), ObjectType, ObjectClassification,\n        Method, ActingContext);\n    if (Candidate.Conversions[ConvIdx].isBad()) {\n      Candidate.Viable = false;\n      Candidate.FailureKind = ovl_fail_bad_conversion;\n      return;\n    }\n  }\n\n  // (CUDA B.1): Check for invalid calls between targets.\n  if (getLangOpts().CUDA)\n    if (const FunctionDecl *Caller = dyn_cast<FunctionDecl>(CurContext))\n      if (!IsAllowedCUDACall(Caller, Method)) {\n        Candidate.Viable = false;\n        Candidate.FailureKind = ovl_fail_bad_target;\n        return;\n      }\n\n  if (Method->getTrailingRequiresClause()) {\n    ConstraintSatisfaction Satisfaction;\n    if (CheckFunctionConstraints(Method, Satisfaction) ||\n        !Satisfaction.IsSatisfied) {\n      Candidate.Viable = false;\n      Candidate.FailureKind = ovl_fail_constraints_not_satisfied;\n      return;\n    }\n  }\n\n  // Determine the implicit conversion sequences for each of the\n  // arguments.\n  for (unsigned ArgIdx = 0; ArgIdx < Args.size(); ++ArgIdx) {\n    unsigned ConvIdx =\n        PO == OverloadCandidateParamOrder::Reversed ? 0 : (ArgIdx + 1);\n    if (Candidate.Conversions[ConvIdx].isInitialized()) {\n      // We already formed a conversion sequence for this parameter during\n      // template argument deduction.\n    } else if (ArgIdx < NumParams) {\n      // (C++ 13.3.2p3): for F to be a viable function, there shall\n      // exist for each argument an implicit conversion sequence\n      // (13.3.3.1) that converts that argument to the corresponding\n      // parameter of F.\n      QualType ParamType = Proto->getParamType(ArgIdx);\n      Candidate.Conversions[ConvIdx]\n        = TryCopyInitialization(*this, Args[ArgIdx], ParamType,\n                                SuppressUserConversions,\n                                /*InOverloadResolution=*/true,\n                                /*AllowObjCWritebackConversion=*/\n                                  getLangOpts().ObjCAutoRefCount);\n      if (Candidate.Conversions[ConvIdx].isBad()) {\n        Candidate.Viable = false;\n        Candidate.FailureKind = ovl_fail_bad_conversion;\n        return;\n      }\n    } else {\n      // (C++ 13.3.2p2): For the purposes of overload resolution, any\n      // argument for which there is no corresponding parameter is\n      // considered to \"match the ellipsis\" (C+ 13.3.3.1.3).\n      Candidate.Conversions[ConvIdx].setEllipsis();\n    }\n  }\n\n  if (EnableIfAttr *FailedAttr =\n          CheckEnableIf(Method, CandidateSet.getLocation(), Args, true)) {\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_enable_if;\n    Candidate.DeductionFailure.Data = FailedAttr;\n    return;\n  }\n\n  if (Method->isMultiVersion() && Method->hasAttr<TargetAttr>() &&\n      !Method->getAttr<TargetAttr>()->isDefaultVersion()) {\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_non_default_multiversion_function;\n  }\n}\n\n/// Add a C++ member function template as a candidate to the candidate\n/// set, using template argument deduction to produce an appropriate member\n/// function template specialization.\nvoid Sema::AddMethodTemplateCandidate(\n    FunctionTemplateDecl *MethodTmpl, DeclAccessPair FoundDecl,\n    CXXRecordDecl *ActingContext,\n    TemplateArgumentListInfo *ExplicitTemplateArgs, QualType ObjectType,\n    Expr::Classification ObjectClassification, ArrayRef<Expr *> Args,\n    OverloadCandidateSet &CandidateSet, bool SuppressUserConversions,\n    bool PartialOverloading, OverloadCandidateParamOrder PO) {\n  if (!CandidateSet.isNewCandidate(MethodTmpl, PO))\n    return;\n\n  // C++ [over.match.funcs]p7:\n  //   In each case where a candidate is a function template, candidate\n  //   function template specializations are generated using template argument\n  //   deduction (14.8.3, 14.8.2). Those candidates are then handled as\n  //   candidate functions in the usual way.113) A given name can refer to one\n  //   or more function templates and also to a set of overloaded non-template\n  //   functions. In such a case, the candidate functions generated from each\n  //   function template are combined with the set of non-template candidate\n  //   functions.\n  TemplateDeductionInfo Info(CandidateSet.getLocation());\n  FunctionDecl *Specialization = nullptr;\n  ConversionSequenceList Conversions;\n  if (TemplateDeductionResult Result = DeduceTemplateArguments(\n          MethodTmpl, ExplicitTemplateArgs, Args, Specialization, Info,\n          PartialOverloading, [&](ArrayRef<QualType> ParamTypes) {\n            return CheckNonDependentConversions(\n                MethodTmpl, ParamTypes, Args, CandidateSet, Conversions,\n                SuppressUserConversions, ActingContext, ObjectType,\n                ObjectClassification, PO);\n          })) {\n    OverloadCandidate &Candidate =\n        CandidateSet.addCandidate(Conversions.size(), Conversions);\n    Candidate.FoundDecl = FoundDecl;\n    Candidate.Function = MethodTmpl->getTemplatedDecl();\n    Candidate.Viable = false;\n    Candidate.RewriteKind =\n      CandidateSet.getRewriteInfo().getRewriteKind(Candidate.Function, PO);\n    Candidate.IsSurrogate = false;\n    Candidate.IgnoreObjectArgument =\n        cast<CXXMethodDecl>(Candidate.Function)->isStatic() ||\n        ObjectType.isNull();\n    Candidate.ExplicitCallArguments = Args.size();\n    if (Result == TDK_NonDependentConversionFailure)\n      Candidate.FailureKind = ovl_fail_bad_conversion;\n    else {\n      Candidate.FailureKind = ovl_fail_bad_deduction;\n      Candidate.DeductionFailure = MakeDeductionFailureInfo(Context, Result,\n                                                            Info);\n    }\n    return;\n  }\n\n  // Add the function template specialization produced by template argument\n  // deduction as a candidate.\n  assert(Specialization && \"Missing member function template specialization?\");\n  assert(isa<CXXMethodDecl>(Specialization) &&\n         \"Specialization is not a member function?\");\n  AddMethodCandidate(cast<CXXMethodDecl>(Specialization), FoundDecl,\n                     ActingContext, ObjectType, ObjectClassification, Args,\n                     CandidateSet, SuppressUserConversions, PartialOverloading,\n                     Conversions, PO);\n}\n\n/// Determine whether a given function template has a simple explicit specifier\n/// or a non-value-dependent explicit-specification that evaluates to true.\nstatic bool isNonDependentlyExplicit(FunctionTemplateDecl *FTD) {\n  return ExplicitSpecifier::getFromDecl(FTD->getTemplatedDecl()).isExplicit();\n}\n\n/// Add a C++ function template specialization as a candidate\n/// in the candidate set, using template argument deduction to produce\n/// an appropriate function template specialization.\nvoid Sema::AddTemplateOverloadCandidate(\n    FunctionTemplateDecl *FunctionTemplate, DeclAccessPair FoundDecl,\n    TemplateArgumentListInfo *ExplicitTemplateArgs, ArrayRef<Expr *> Args,\n    OverloadCandidateSet &CandidateSet, bool SuppressUserConversions,\n    bool PartialOverloading, bool AllowExplicit, ADLCallKind IsADLCandidate,\n    OverloadCandidateParamOrder PO) {\n  if (!CandidateSet.isNewCandidate(FunctionTemplate, PO))\n    return;\n\n  // If the function template has a non-dependent explicit specification,\n  // exclude it now if appropriate; we are not permitted to perform deduction\n  // and substitution in this case.\n  if (!AllowExplicit && isNonDependentlyExplicit(FunctionTemplate)) {\n    OverloadCandidate &Candidate = CandidateSet.addCandidate();\n    Candidate.FoundDecl = FoundDecl;\n    Candidate.Function = FunctionTemplate->getTemplatedDecl();\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_explicit;\n    return;\n  }\n\n  // C++ [over.match.funcs]p7:\n  //   In each case where a candidate is a function template, candidate\n  //   function template specializations are generated using template argument\n  //   deduction (14.8.3, 14.8.2). Those candidates are then handled as\n  //   candidate functions in the usual way.113) A given name can refer to one\n  //   or more function templates and also to a set of overloaded non-template\n  //   functions. In such a case, the candidate functions generated from each\n  //   function template are combined with the set of non-template candidate\n  //   functions.\n  TemplateDeductionInfo Info(CandidateSet.getLocation());\n  FunctionDecl *Specialization = nullptr;\n  ConversionSequenceList Conversions;\n  if (TemplateDeductionResult Result = DeduceTemplateArguments(\n          FunctionTemplate, ExplicitTemplateArgs, Args, Specialization, Info,\n          PartialOverloading, [&](ArrayRef<QualType> ParamTypes) {\n            return CheckNonDependentConversions(\n                FunctionTemplate, ParamTypes, Args, CandidateSet, Conversions,\n                SuppressUserConversions, nullptr, QualType(), {}, PO);\n          })) {\n    OverloadCandidate &Candidate =\n        CandidateSet.addCandidate(Conversions.size(), Conversions);\n    Candidate.FoundDecl = FoundDecl;\n    Candidate.Function = FunctionTemplate->getTemplatedDecl();\n    Candidate.Viable = false;\n    Candidate.RewriteKind =\n      CandidateSet.getRewriteInfo().getRewriteKind(Candidate.Function, PO);\n    Candidate.IsSurrogate = false;\n    Candidate.IsADLCandidate = IsADLCandidate;\n    // Ignore the object argument if there is one, since we don't have an object\n    // type.\n    Candidate.IgnoreObjectArgument =\n        isa<CXXMethodDecl>(Candidate.Function) &&\n        !isa<CXXConstructorDecl>(Candidate.Function);\n    Candidate.ExplicitCallArguments = Args.size();\n    if (Result == TDK_NonDependentConversionFailure)\n      Candidate.FailureKind = ovl_fail_bad_conversion;\n    else {\n      Candidate.FailureKind = ovl_fail_bad_deduction;\n      Candidate.DeductionFailure = MakeDeductionFailureInfo(Context, Result,\n                                                            Info);\n    }\n    return;\n  }\n\n  // Add the function template specialization produced by template argument\n  // deduction as a candidate.\n  assert(Specialization && \"Missing function template specialization?\");\n  AddOverloadCandidate(\n      Specialization, FoundDecl, Args, CandidateSet, SuppressUserConversions,\n      PartialOverloading, AllowExplicit,\n      /*AllowExplicitConversions*/ false, IsADLCandidate, Conversions, PO);\n}\n\n/// Check that implicit conversion sequences can be formed for each argument\n/// whose corresponding parameter has a non-dependent type, per DR1391's\n/// [temp.deduct.call]p10.\nbool Sema::CheckNonDependentConversions(\n    FunctionTemplateDecl *FunctionTemplate, ArrayRef<QualType> ParamTypes,\n    ArrayRef<Expr *> Args, OverloadCandidateSet &CandidateSet,\n    ConversionSequenceList &Conversions, bool SuppressUserConversions,\n    CXXRecordDecl *ActingContext, QualType ObjectType,\n    Expr::Classification ObjectClassification, OverloadCandidateParamOrder PO) {\n  // FIXME: The cases in which we allow explicit conversions for constructor\n  // arguments never consider calling a constructor template. It's not clear\n  // that is correct.\n  const bool AllowExplicit = false;\n\n  auto *FD = FunctionTemplate->getTemplatedDecl();\n  auto *Method = dyn_cast<CXXMethodDecl>(FD);\n  bool HasThisConversion = Method && !isa<CXXConstructorDecl>(Method);\n  unsigned ThisConversions = HasThisConversion ? 1 : 0;\n\n  Conversions =\n      CandidateSet.allocateConversionSequences(ThisConversions + Args.size());\n\n  // Overload resolution is always an unevaluated context.\n  EnterExpressionEvaluationContext Unevaluated(\n      *this, Sema::ExpressionEvaluationContext::Unevaluated);\n\n  // For a method call, check the 'this' conversion here too. DR1391 doesn't\n  // require that, but this check should never result in a hard error, and\n  // overload resolution is permitted to sidestep instantiations.\n  if (HasThisConversion && !cast<CXXMethodDecl>(FD)->isStatic() &&\n      !ObjectType.isNull()) {\n    unsigned ConvIdx = PO == OverloadCandidateParamOrder::Reversed ? 1 : 0;\n    Conversions[ConvIdx] = TryObjectArgumentInitialization(\n        *this, CandidateSet.getLocation(), ObjectType, ObjectClassification,\n        Method, ActingContext);\n    if (Conversions[ConvIdx].isBad())\n      return true;\n  }\n\n  for (unsigned I = 0, N = std::min(ParamTypes.size(), Args.size()); I != N;\n       ++I) {\n    QualType ParamType = ParamTypes[I];\n    if (!ParamType->isDependentType()) {\n      unsigned ConvIdx = PO == OverloadCandidateParamOrder::Reversed\n                             ? 0\n                             : (ThisConversions + I);\n      Conversions[ConvIdx]\n        = TryCopyInitialization(*this, Args[I], ParamType,\n                                SuppressUserConversions,\n                                /*InOverloadResolution=*/true,\n                                /*AllowObjCWritebackConversion=*/\n                                  getLangOpts().ObjCAutoRefCount,\n                                AllowExplicit);\n      if (Conversions[ConvIdx].isBad())\n        return true;\n    }\n  }\n\n  return false;\n}\n\n/// Determine whether this is an allowable conversion from the result\n/// of an explicit conversion operator to the expected type, per C++\n/// [over.match.conv]p1 and [over.match.ref]p1.\n///\n/// \\param ConvType The return type of the conversion function.\n///\n/// \\param ToType The type we are converting to.\n///\n/// \\param AllowObjCPointerConversion Allow a conversion from one\n/// Objective-C pointer to another.\n///\n/// \\returns true if the conversion is allowable, false otherwise.\nstatic bool isAllowableExplicitConversion(Sema &S,\n                                          QualType ConvType, QualType ToType,\n                                          bool AllowObjCPointerConversion) {\n  QualType ToNonRefType = ToType.getNonReferenceType();\n\n  // Easy case: the types are the same.\n  if (S.Context.hasSameUnqualifiedType(ConvType, ToNonRefType))\n    return true;\n\n  // Allow qualification conversions.\n  bool ObjCLifetimeConversion;\n  if (S.IsQualificationConversion(ConvType, ToNonRefType, /*CStyle*/false,\n                                  ObjCLifetimeConversion))\n    return true;\n\n  // If we're not allowed to consider Objective-C pointer conversions,\n  // we're done.\n  if (!AllowObjCPointerConversion)\n    return false;\n\n  // Is this an Objective-C pointer conversion?\n  bool IncompatibleObjC = false;\n  QualType ConvertedType;\n  return S.isObjCPointerConversion(ConvType, ToNonRefType, ConvertedType,\n                                   IncompatibleObjC);\n}\n\n/// AddConversionCandidate - Add a C++ conversion function as a\n/// candidate in the candidate set (C++ [over.match.conv],\n/// C++ [over.match.copy]). From is the expression we're converting from,\n/// and ToType is the type that we're eventually trying to convert to\n/// (which may or may not be the same type as the type that the\n/// conversion function produces).\nvoid Sema::AddConversionCandidate(\n    CXXConversionDecl *Conversion, DeclAccessPair FoundDecl,\n    CXXRecordDecl *ActingContext, Expr *From, QualType ToType,\n    OverloadCandidateSet &CandidateSet, bool AllowObjCConversionOnExplicit,\n    bool AllowExplicit, bool AllowResultConversion) {\n  assert(!Conversion->getDescribedFunctionTemplate() &&\n         \"Conversion function templates use AddTemplateConversionCandidate\");\n  QualType ConvType = Conversion->getConversionType().getNonReferenceType();\n  if (!CandidateSet.isNewCandidate(Conversion))\n    return;\n\n  // If the conversion function has an undeduced return type, trigger its\n  // deduction now.\n  if (getLangOpts().CPlusPlus14 && ConvType->isUndeducedType()) {\n    if (DeduceReturnType(Conversion, From->getExprLoc()))\n      return;\n    ConvType = Conversion->getConversionType().getNonReferenceType();\n  }\n\n  // If we don't allow any conversion of the result type, ignore conversion\n  // functions that don't convert to exactly (possibly cv-qualified) T.\n  if (!AllowResultConversion &&\n      !Context.hasSameUnqualifiedType(Conversion->getConversionType(), ToType))\n    return;\n\n  // Per C++ [over.match.conv]p1, [over.match.ref]p1, an explicit conversion\n  // operator is only a candidate if its return type is the target type or\n  // can be converted to the target type with a qualification conversion.\n  //\n  // FIXME: Include such functions in the candidate list and explain why we\n  // can't select them.\n  if (Conversion->isExplicit() &&\n      !isAllowableExplicitConversion(*this, ConvType, ToType,\n                                     AllowObjCConversionOnExplicit))\n    return;\n\n  // Overload resolution is always an unevaluated context.\n  EnterExpressionEvaluationContext Unevaluated(\n      *this, Sema::ExpressionEvaluationContext::Unevaluated);\n\n  // Add this candidate\n  OverloadCandidate &Candidate = CandidateSet.addCandidate(1);\n  Candidate.FoundDecl = FoundDecl;\n  Candidate.Function = Conversion;\n  Candidate.IsSurrogate = false;\n  Candidate.IgnoreObjectArgument = false;\n  Candidate.FinalConversion.setAsIdentityConversion();\n  Candidate.FinalConversion.setFromType(ConvType);\n  Candidate.FinalConversion.setAllToTypes(ToType);\n  Candidate.Viable = true;\n  Candidate.ExplicitCallArguments = 1;\n\n  // Explicit functions are not actually candidates at all if we're not\n  // allowing them in this context, but keep them around so we can point\n  // to them in diagnostics.\n  if (!AllowExplicit && Conversion->isExplicit()) {\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_explicit;\n    return;\n  }\n\n  // C++ [over.match.funcs]p4:\n  //   For conversion functions, the function is considered to be a member of\n  //   the class of the implicit implied object argument for the purpose of\n  //   defining the type of the implicit object parameter.\n  //\n  // Determine the implicit conversion sequence for the implicit\n  // object parameter.\n  QualType ImplicitParamType = From->getType();\n  if (const PointerType *FromPtrType = ImplicitParamType->getAs<PointerType>())\n    ImplicitParamType = FromPtrType->getPointeeType();\n  CXXRecordDecl *ConversionContext\n    = cast<CXXRecordDecl>(ImplicitParamType->castAs<RecordType>()->getDecl());\n\n  Candidate.Conversions[0] = TryObjectArgumentInitialization(\n      *this, CandidateSet.getLocation(), From->getType(),\n      From->Classify(Context), Conversion, ConversionContext);\n\n  if (Candidate.Conversions[0].isBad()) {\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_bad_conversion;\n    return;\n  }\n\n  if (Conversion->getTrailingRequiresClause()) {\n    ConstraintSatisfaction Satisfaction;\n    if (CheckFunctionConstraints(Conversion, Satisfaction) ||\n        !Satisfaction.IsSatisfied) {\n      Candidate.Viable = false;\n      Candidate.FailureKind = ovl_fail_constraints_not_satisfied;\n      return;\n    }\n  }\n\n  // We won't go through a user-defined type conversion function to convert a\n  // derived to base as such conversions are given Conversion Rank. They only\n  // go through a copy constructor. 13.3.3.1.2-p4 [over.ics.user]\n  QualType FromCanon\n    = Context.getCanonicalType(From->getType().getUnqualifiedType());\n  QualType ToCanon = Context.getCanonicalType(ToType).getUnqualifiedType();\n  if (FromCanon == ToCanon ||\n      IsDerivedFrom(CandidateSet.getLocation(), FromCanon, ToCanon)) {\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_trivial_conversion;\n    return;\n  }\n\n  // To determine what the conversion from the result of calling the\n  // conversion function to the type we're eventually trying to\n  // convert to (ToType), we need to synthesize a call to the\n  // conversion function and attempt copy initialization from it. This\n  // makes sure that we get the right semantics with respect to\n  // lvalues/rvalues and the type. Fortunately, we can allocate this\n  // call on the stack and we don't need its arguments to be\n  // well-formed.\n  DeclRefExpr ConversionRef(Context, Conversion, false, Conversion->getType(),\n                            VK_LValue, From->getBeginLoc());\n  ImplicitCastExpr ConversionFn(ImplicitCastExpr::OnStack,\n                                Context.getPointerType(Conversion->getType()),\n                                CK_FunctionToPointerDecay, &ConversionRef,\n                                VK_RValue, FPOptionsOverride());\n\n  QualType ConversionType = Conversion->getConversionType();\n  if (!isCompleteType(From->getBeginLoc(), ConversionType)) {\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_bad_final_conversion;\n    return;\n  }\n\n  ExprValueKind VK = Expr::getValueKindForType(ConversionType);\n\n  // Note that it is safe to allocate CallExpr on the stack here because\n  // there are 0 arguments (i.e., nothing is allocated using ASTContext's\n  // allocator).\n  QualType CallResultType = ConversionType.getNonLValueExprType(Context);\n\n  alignas(CallExpr) char Buffer[sizeof(CallExpr) + sizeof(Stmt *)];\n  CallExpr *TheTemporaryCall = CallExpr::CreateTemporary(\n      Buffer, &ConversionFn, CallResultType, VK, From->getBeginLoc());\n\n  ImplicitConversionSequence ICS =\n      TryCopyInitialization(*this, TheTemporaryCall, ToType,\n                            /*SuppressUserConversions=*/true,\n                            /*InOverloadResolution=*/false,\n                            /*AllowObjCWritebackConversion=*/false);\n\n  switch (ICS.getKind()) {\n  case ImplicitConversionSequence::StandardConversion:\n    Candidate.FinalConversion = ICS.Standard;\n\n    // C++ [over.ics.user]p3:\n    //   If the user-defined conversion is specified by a specialization of a\n    //   conversion function template, the second standard conversion sequence\n    //   shall have exact match rank.\n    if (Conversion->getPrimaryTemplate() &&\n        GetConversionRank(ICS.Standard.Second) != ICR_Exact_Match) {\n      Candidate.Viable = false;\n      Candidate.FailureKind = ovl_fail_final_conversion_not_exact;\n      return;\n    }\n\n    // C++0x [dcl.init.ref]p5:\n    //    In the second case, if the reference is an rvalue reference and\n    //    the second standard conversion sequence of the user-defined\n    //    conversion sequence includes an lvalue-to-rvalue conversion, the\n    //    program is ill-formed.\n    if (ToType->isRValueReferenceType() &&\n        ICS.Standard.First == ICK_Lvalue_To_Rvalue) {\n      Candidate.Viable = false;\n      Candidate.FailureKind = ovl_fail_bad_final_conversion;\n      return;\n    }\n    break;\n\n  case ImplicitConversionSequence::BadConversion:\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_bad_final_conversion;\n    return;\n\n  default:\n    llvm_unreachable(\n           \"Can only end up with a standard conversion sequence or failure\");\n  }\n\n  if (EnableIfAttr *FailedAttr =\n          CheckEnableIf(Conversion, CandidateSet.getLocation(), None)) {\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_enable_if;\n    Candidate.DeductionFailure.Data = FailedAttr;\n    return;\n  }\n\n  if (Conversion->isMultiVersion() && Conversion->hasAttr<TargetAttr>() &&\n      !Conversion->getAttr<TargetAttr>()->isDefaultVersion()) {\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_non_default_multiversion_function;\n  }\n}\n\n/// Adds a conversion function template specialization\n/// candidate to the overload set, using template argument deduction\n/// to deduce the template arguments of the conversion function\n/// template from the type that we are converting to (C++\n/// [temp.deduct.conv]).\nvoid Sema::AddTemplateConversionCandidate(\n    FunctionTemplateDecl *FunctionTemplate, DeclAccessPair FoundDecl,\n    CXXRecordDecl *ActingDC, Expr *From, QualType ToType,\n    OverloadCandidateSet &CandidateSet, bool AllowObjCConversionOnExplicit,\n    bool AllowExplicit, bool AllowResultConversion) {\n  assert(isa<CXXConversionDecl>(FunctionTemplate->getTemplatedDecl()) &&\n         \"Only conversion function templates permitted here\");\n\n  if (!CandidateSet.isNewCandidate(FunctionTemplate))\n    return;\n\n  // If the function template has a non-dependent explicit specification,\n  // exclude it now if appropriate; we are not permitted to perform deduction\n  // and substitution in this case.\n  if (!AllowExplicit && isNonDependentlyExplicit(FunctionTemplate)) {\n    OverloadCandidate &Candidate = CandidateSet.addCandidate();\n    Candidate.FoundDecl = FoundDecl;\n    Candidate.Function = FunctionTemplate->getTemplatedDecl();\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_explicit;\n    return;\n  }\n\n  TemplateDeductionInfo Info(CandidateSet.getLocation());\n  CXXConversionDecl *Specialization = nullptr;\n  if (TemplateDeductionResult Result\n        = DeduceTemplateArguments(FunctionTemplate, ToType,\n                                  Specialization, Info)) {\n    OverloadCandidate &Candidate = CandidateSet.addCandidate();\n    Candidate.FoundDecl = FoundDecl;\n    Candidate.Function = FunctionTemplate->getTemplatedDecl();\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_bad_deduction;\n    Candidate.IsSurrogate = false;\n    Candidate.IgnoreObjectArgument = false;\n    Candidate.ExplicitCallArguments = 1;\n    Candidate.DeductionFailure = MakeDeductionFailureInfo(Context, Result,\n                                                          Info);\n    return;\n  }\n\n  // Add the conversion function template specialization produced by\n  // template argument deduction as a candidate.\n  assert(Specialization && \"Missing function template specialization?\");\n  AddConversionCandidate(Specialization, FoundDecl, ActingDC, From, ToType,\n                         CandidateSet, AllowObjCConversionOnExplicit,\n                         AllowExplicit, AllowResultConversion);\n}\n\n/// AddSurrogateCandidate - Adds a \"surrogate\" candidate function that\n/// converts the given @c Object to a function pointer via the\n/// conversion function @c Conversion, and then attempts to call it\n/// with the given arguments (C++ [over.call.object]p2-4). Proto is\n/// the type of function that we'll eventually be calling.\nvoid Sema::AddSurrogateCandidate(CXXConversionDecl *Conversion,\n                                 DeclAccessPair FoundDecl,\n                                 CXXRecordDecl *ActingContext,\n                                 const FunctionProtoType *Proto,\n                                 Expr *Object,\n                                 ArrayRef<Expr *> Args,\n                                 OverloadCandidateSet& CandidateSet) {\n  if (!CandidateSet.isNewCandidate(Conversion))\n    return;\n\n  // Overload resolution is always an unevaluated context.\n  EnterExpressionEvaluationContext Unevaluated(\n      *this, Sema::ExpressionEvaluationContext::Unevaluated);\n\n  OverloadCandidate &Candidate = CandidateSet.addCandidate(Args.size() + 1);\n  Candidate.FoundDecl = FoundDecl;\n  Candidate.Function = nullptr;\n  Candidate.Surrogate = Conversion;\n  Candidate.Viable = true;\n  Candidate.IsSurrogate = true;\n  Candidate.IgnoreObjectArgument = false;\n  Candidate.ExplicitCallArguments = Args.size();\n\n  // Determine the implicit conversion sequence for the implicit\n  // object parameter.\n  ImplicitConversionSequence ObjectInit = TryObjectArgumentInitialization(\n      *this, CandidateSet.getLocation(), Object->getType(),\n      Object->Classify(Context), Conversion, ActingContext);\n  if (ObjectInit.isBad()) {\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_bad_conversion;\n    Candidate.Conversions[0] = ObjectInit;\n    return;\n  }\n\n  // The first conversion is actually a user-defined conversion whose\n  // first conversion is ObjectInit's standard conversion (which is\n  // effectively a reference binding). Record it as such.\n  Candidate.Conversions[0].setUserDefined();\n  Candidate.Conversions[0].UserDefined.Before = ObjectInit.Standard;\n  Candidate.Conversions[0].UserDefined.EllipsisConversion = false;\n  Candidate.Conversions[0].UserDefined.HadMultipleCandidates = false;\n  Candidate.Conversions[0].UserDefined.ConversionFunction = Conversion;\n  Candidate.Conversions[0].UserDefined.FoundConversionFunction = FoundDecl;\n  Candidate.Conversions[0].UserDefined.After\n    = Candidate.Conversions[0].UserDefined.Before;\n  Candidate.Conversions[0].UserDefined.After.setAsIdentityConversion();\n\n  // Find the\n  unsigned NumParams = Proto->getNumParams();\n\n  // (C++ 13.3.2p2): A candidate function having fewer than m\n  // parameters is viable only if it has an ellipsis in its parameter\n  // list (8.3.5).\n  if (Args.size() > NumParams && !Proto->isVariadic()) {\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_too_many_arguments;\n    return;\n  }\n\n  // Function types don't have any default arguments, so just check if\n  // we have enough arguments.\n  if (Args.size() < NumParams) {\n    // Not enough arguments.\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_too_few_arguments;\n    return;\n  }\n\n  // Determine the implicit conversion sequences for each of the\n  // arguments.\n  for (unsigned ArgIdx = 0, N = Args.size(); ArgIdx != N; ++ArgIdx) {\n    if (ArgIdx < NumParams) {\n      // (C++ 13.3.2p3): for F to be a viable function, there shall\n      // exist for each argument an implicit conversion sequence\n      // (13.3.3.1) that converts that argument to the corresponding\n      // parameter of F.\n      QualType ParamType = Proto->getParamType(ArgIdx);\n      Candidate.Conversions[ArgIdx + 1]\n        = TryCopyInitialization(*this, Args[ArgIdx], ParamType,\n                                /*SuppressUserConversions=*/false,\n                                /*InOverloadResolution=*/false,\n                                /*AllowObjCWritebackConversion=*/\n                                  getLangOpts().ObjCAutoRefCount);\n      if (Candidate.Conversions[ArgIdx + 1].isBad()) {\n        Candidate.Viable = false;\n        Candidate.FailureKind = ovl_fail_bad_conversion;\n        return;\n      }\n    } else {\n      // (C++ 13.3.2p2): For the purposes of overload resolution, any\n      // argument for which there is no corresponding parameter is\n      // considered to \"\"match the ellipsis\" (C+ 13.3.3.1.3).\n      Candidate.Conversions[ArgIdx + 1].setEllipsis();\n    }\n  }\n\n  if (EnableIfAttr *FailedAttr =\n          CheckEnableIf(Conversion, CandidateSet.getLocation(), None)) {\n    Candidate.Viable = false;\n    Candidate.FailureKind = ovl_fail_enable_if;\n    Candidate.DeductionFailure.Data = FailedAttr;\n    return;\n  }\n}\n\n/// Add all of the non-member operator function declarations in the given\n/// function set to the overload candidate set.\nvoid Sema::AddNonMemberOperatorCandidates(\n    const UnresolvedSetImpl &Fns, ArrayRef<Expr *> Args,\n    OverloadCandidateSet &CandidateSet,\n    TemplateArgumentListInfo *ExplicitTemplateArgs) {\n  for (UnresolvedSetIterator F = Fns.begin(), E = Fns.end(); F != E; ++F) {\n    NamedDecl *D = F.getDecl()->getUnderlyingDecl();\n    ArrayRef<Expr *> FunctionArgs = Args;\n\n    FunctionTemplateDecl *FunTmpl = dyn_cast<FunctionTemplateDecl>(D);\n    FunctionDecl *FD =\n        FunTmpl ? FunTmpl->getTemplatedDecl() : cast<FunctionDecl>(D);\n\n    // Don't consider rewritten functions if we're not rewriting.\n    if (!CandidateSet.getRewriteInfo().isAcceptableCandidate(FD))\n      continue;\n\n    assert(!isa<CXXMethodDecl>(FD) &&\n           \"unqualified operator lookup found a member function\");\n\n    if (FunTmpl) {\n      AddTemplateOverloadCandidate(FunTmpl, F.getPair(), ExplicitTemplateArgs,\n                                   FunctionArgs, CandidateSet);\n      if (CandidateSet.getRewriteInfo().shouldAddReversed(Context, FD))\n        AddTemplateOverloadCandidate(\n            FunTmpl, F.getPair(), ExplicitTemplateArgs,\n            {FunctionArgs[1], FunctionArgs[0]}, CandidateSet, false, false,\n            true, ADLCallKind::NotADL, OverloadCandidateParamOrder::Reversed);\n    } else {\n      if (ExplicitTemplateArgs)\n        continue;\n      AddOverloadCandidate(FD, F.getPair(), FunctionArgs, CandidateSet);\n      if (CandidateSet.getRewriteInfo().shouldAddReversed(Context, FD))\n        AddOverloadCandidate(FD, F.getPair(),\n                             {FunctionArgs[1], FunctionArgs[0]}, CandidateSet,\n                             false, false, true, false, ADLCallKind::NotADL,\n                             None, OverloadCandidateParamOrder::Reversed);\n    }\n  }\n}\n\n/// Add overload candidates for overloaded operators that are\n/// member functions.\n///\n/// Add the overloaded operator candidates that are member functions\n/// for the operator Op that was used in an operator expression such\n/// as \"x Op y\". , Args/NumArgs provides the operator arguments, and\n/// CandidateSet will store the added overload candidates. (C++\n/// [over.match.oper]).\nvoid Sema::AddMemberOperatorCandidates(OverloadedOperatorKind Op,\n                                       SourceLocation OpLoc,\n                                       ArrayRef<Expr *> Args,\n                                       OverloadCandidateSet &CandidateSet,\n                                       OverloadCandidateParamOrder PO) {\n  DeclarationName OpName = Context.DeclarationNames.getCXXOperatorName(Op);\n\n  // C++ [over.match.oper]p3:\n  //   For a unary operator @ with an operand of a type whose\n  //   cv-unqualified version is T1, and for a binary operator @ with\n  //   a left operand of a type whose cv-unqualified version is T1 and\n  //   a right operand of a type whose cv-unqualified version is T2,\n  //   three sets of candidate functions, designated member\n  //   candidates, non-member candidates and built-in candidates, are\n  //   constructed as follows:\n  QualType T1 = Args[0]->getType();\n\n  //     -- If T1 is a complete class type or a class currently being\n  //        defined, the set of member candidates is the result of the\n  //        qualified lookup of T1::operator@ (13.3.1.1.1); otherwise,\n  //        the set of member candidates is empty.\n  if (const RecordType *T1Rec = T1->getAs<RecordType>()) {\n    // Complete the type if it can be completed.\n    if (!isCompleteType(OpLoc, T1) && !T1Rec->isBeingDefined())\n      return;\n    // If the type is neither complete nor being defined, bail out now.\n    if (!T1Rec->getDecl()->getDefinition())\n      return;\n\n    LookupResult Operators(*this, OpName, OpLoc, LookupOrdinaryName);\n    LookupQualifiedName(Operators, T1Rec->getDecl());\n    Operators.suppressDiagnostics();\n\n    for (LookupResult::iterator Oper = Operators.begin(),\n                             OperEnd = Operators.end();\n         Oper != OperEnd;\n         ++Oper)\n      AddMethodCandidate(Oper.getPair(), Args[0]->getType(),\n                         Args[0]->Classify(Context), Args.slice(1),\n                         CandidateSet, /*SuppressUserConversion=*/false, PO);\n  }\n}\n\n/// AddBuiltinCandidate - Add a candidate for a built-in\n/// operator. ResultTy and ParamTys are the result and parameter types\n/// of the built-in candidate, respectively. Args and NumArgs are the\n/// arguments being passed to the candidate. IsAssignmentOperator\n/// should be true when this built-in candidate is an assignment\n/// operator. NumContextualBoolArguments is the number of arguments\n/// (at the beginning of the argument list) that will be contextually\n/// converted to bool.\nvoid Sema::AddBuiltinCandidate(QualType *ParamTys, ArrayRef<Expr *> Args,\n                               OverloadCandidateSet& CandidateSet,\n                               bool IsAssignmentOperator,\n                               unsigned NumContextualBoolArguments) {\n  // Overload resolution is always an unevaluated context.\n  EnterExpressionEvaluationContext Unevaluated(\n      *this, Sema::ExpressionEvaluationContext::Unevaluated);\n\n  // Add this candidate\n  OverloadCandidate &Candidate = CandidateSet.addCandidate(Args.size());\n  Candidate.FoundDecl = DeclAccessPair::make(nullptr, AS_none);\n  Candidate.Function = nullptr;\n  Candidate.IsSurrogate = false;\n  Candidate.IgnoreObjectArgument = false;\n  std::copy(ParamTys, ParamTys + Args.size(), Candidate.BuiltinParamTypes);\n\n  // Determine the implicit conversion sequences for each of the\n  // arguments.\n  Candidate.Viable = true;\n  Candidate.ExplicitCallArguments = Args.size();\n  for (unsigned ArgIdx = 0, N = Args.size(); ArgIdx != N; ++ArgIdx) {\n    // C++ [over.match.oper]p4:\n    //   For the built-in assignment operators, conversions of the\n    //   left operand are restricted as follows:\n    //     -- no temporaries are introduced to hold the left operand, and\n    //     -- no user-defined conversions are applied to the left\n    //        operand to achieve a type match with the left-most\n    //        parameter of a built-in candidate.\n    //\n    // We block these conversions by turning off user-defined\n    // conversions, since that is the only way that initialization of\n    // a reference to a non-class type can occur from something that\n    // is not of the same type.\n    if (ArgIdx < NumContextualBoolArguments) {\n      assert(ParamTys[ArgIdx] == Context.BoolTy &&\n             \"Contextual conversion to bool requires bool type\");\n      Candidate.Conversions[ArgIdx]\n        = TryContextuallyConvertToBool(*this, Args[ArgIdx]);\n    } else {\n      Candidate.Conversions[ArgIdx]\n        = TryCopyInitialization(*this, Args[ArgIdx], ParamTys[ArgIdx],\n                                ArgIdx == 0 && IsAssignmentOperator,\n                                /*InOverloadResolution=*/false,\n                                /*AllowObjCWritebackConversion=*/\n                                  getLangOpts().ObjCAutoRefCount);\n    }\n    if (Candidate.Conversions[ArgIdx].isBad()) {\n      Candidate.Viable = false;\n      Candidate.FailureKind = ovl_fail_bad_conversion;\n      break;\n    }\n  }\n}\n\nnamespace {\n\n/// BuiltinCandidateTypeSet - A set of types that will be used for the\n/// candidate operator functions for built-in operators (C++\n/// [over.built]). The types are separated into pointer types and\n/// enumeration types.\nclass BuiltinCandidateTypeSet  {\n  /// TypeSet - A set of types.\n  typedef llvm::SetVector<QualType, SmallVector<QualType, 8>,\n                          llvm::SmallPtrSet<QualType, 8>> TypeSet;\n\n  /// PointerTypes - The set of pointer types that will be used in the\n  /// built-in candidates.\n  TypeSet PointerTypes;\n\n  /// MemberPointerTypes - The set of member pointer types that will be\n  /// used in the built-in candidates.\n  TypeSet MemberPointerTypes;\n\n  /// EnumerationTypes - The set of enumeration types that will be\n  /// used in the built-in candidates.\n  TypeSet EnumerationTypes;\n\n  /// The set of vector types that will be used in the built-in\n  /// candidates.\n  TypeSet VectorTypes;\n\n  /// The set of matrix types that will be used in the built-in\n  /// candidates.\n  TypeSet MatrixTypes;\n\n  /// A flag indicating non-record types are viable candidates\n  bool HasNonRecordTypes;\n\n  /// A flag indicating whether either arithmetic or enumeration types\n  /// were present in the candidate set.\n  bool HasArithmeticOrEnumeralTypes;\n\n  /// A flag indicating whether the nullptr type was present in the\n  /// candidate set.\n  bool HasNullPtrType;\n\n  /// Sema - The semantic analysis instance where we are building the\n  /// candidate type set.\n  Sema &SemaRef;\n\n  /// Context - The AST context in which we will build the type sets.\n  ASTContext &Context;\n\n  bool AddPointerWithMoreQualifiedTypeVariants(QualType Ty,\n                                               const Qualifiers &VisibleQuals);\n  bool AddMemberPointerWithMoreQualifiedTypeVariants(QualType Ty);\n\npublic:\n  /// iterator - Iterates through the types that are part of the set.\n  typedef TypeSet::iterator iterator;\n\n  BuiltinCandidateTypeSet(Sema &SemaRef)\n    : HasNonRecordTypes(false),\n      HasArithmeticOrEnumeralTypes(false),\n      HasNullPtrType(false),\n      SemaRef(SemaRef),\n      Context(SemaRef.Context) { }\n\n  void AddTypesConvertedFrom(QualType Ty,\n                             SourceLocation Loc,\n                             bool AllowUserConversions,\n                             bool AllowExplicitConversions,\n                             const Qualifiers &VisibleTypeConversionsQuals);\n\n  llvm::iterator_range<iterator> pointer_types() { return PointerTypes; }\n  llvm::iterator_range<iterator> member_pointer_types() {\n    return MemberPointerTypes;\n  }\n  llvm::iterator_range<iterator> enumeration_types() {\n    return EnumerationTypes;\n  }\n  llvm::iterator_range<iterator> vector_types() { return VectorTypes; }\n  llvm::iterator_range<iterator> matrix_types() { return MatrixTypes; }\n\n  bool containsMatrixType(QualType Ty) const { return MatrixTypes.count(Ty); }\n  bool hasNonRecordTypes() { return HasNonRecordTypes; }\n  bool hasArithmeticOrEnumeralTypes() { return HasArithmeticOrEnumeralTypes; }\n  bool hasNullPtrType() const { return HasNullPtrType; }\n};\n\n} // end anonymous namespace\n\n/// AddPointerWithMoreQualifiedTypeVariants - Add the pointer type @p Ty to\n/// the set of pointer types along with any more-qualified variants of\n/// that type. For example, if @p Ty is \"int const *\", this routine\n/// will add \"int const *\", \"int const volatile *\", \"int const\n/// restrict *\", and \"int const volatile restrict *\" to the set of\n/// pointer types. Returns true if the add of @p Ty itself succeeded,\n/// false otherwise.\n///\n/// FIXME: what to do about extended qualifiers?\nbool\nBuiltinCandidateTypeSet::AddPointerWithMoreQualifiedTypeVariants(QualType Ty,\n                                             const Qualifiers &VisibleQuals) {\n\n  // Insert this type.\n  if (!PointerTypes.insert(Ty))\n    return false;\n\n  QualType PointeeTy;\n  const PointerType *PointerTy = Ty->getAs<PointerType>();\n  bool buildObjCPtr = false;\n  if (!PointerTy) {\n    const ObjCObjectPointerType *PTy = Ty->castAs<ObjCObjectPointerType>();\n    PointeeTy = PTy->getPointeeType();\n    buildObjCPtr = true;\n  } else {\n    PointeeTy = PointerTy->getPointeeType();\n  }\n\n  // Don't add qualified variants of arrays. For one, they're not allowed\n  // (the qualifier would sink to the element type), and for another, the\n  // only overload situation where it matters is subscript or pointer +- int,\n  // and those shouldn't have qualifier variants anyway.\n  if (PointeeTy->isArrayType())\n    return true;\n\n  unsigned BaseCVR = PointeeTy.getCVRQualifiers();\n  bool hasVolatile = VisibleQuals.hasVolatile();\n  bool hasRestrict = VisibleQuals.hasRestrict();\n\n  // Iterate through all strict supersets of BaseCVR.\n  for (unsigned CVR = BaseCVR+1; CVR <= Qualifiers::CVRMask; ++CVR) {\n    if ((CVR | BaseCVR) != CVR) continue;\n    // Skip over volatile if no volatile found anywhere in the types.\n    if ((CVR & Qualifiers::Volatile) && !hasVolatile) continue;\n\n    // Skip over restrict if no restrict found anywhere in the types, or if\n    // the type cannot be restrict-qualified.\n    if ((CVR & Qualifiers::Restrict) &&\n        (!hasRestrict ||\n         (!(PointeeTy->isAnyPointerType() || PointeeTy->isReferenceType()))))\n      continue;\n\n    // Build qualified pointee type.\n    QualType QPointeeTy = Context.getCVRQualifiedType(PointeeTy, CVR);\n\n    // Build qualified pointer type.\n    QualType QPointerTy;\n    if (!buildObjCPtr)\n      QPointerTy = Context.getPointerType(QPointeeTy);\n    else\n      QPointerTy = Context.getObjCObjectPointerType(QPointeeTy);\n\n    // Insert qualified pointer type.\n    PointerTypes.insert(QPointerTy);\n  }\n\n  return true;\n}\n\n/// AddMemberPointerWithMoreQualifiedTypeVariants - Add the pointer type @p Ty\n/// to the set of pointer types along with any more-qualified variants of\n/// that type. For example, if @p Ty is \"int const *\", this routine\n/// will add \"int const *\", \"int const volatile *\", \"int const\n/// restrict *\", and \"int const volatile restrict *\" to the set of\n/// pointer types. Returns true if the add of @p Ty itself succeeded,\n/// false otherwise.\n///\n/// FIXME: what to do about extended qualifiers?\nbool\nBuiltinCandidateTypeSet::AddMemberPointerWithMoreQualifiedTypeVariants(\n    QualType Ty) {\n  // Insert this type.\n  if (!MemberPointerTypes.insert(Ty))\n    return false;\n\n  const MemberPointerType *PointerTy = Ty->getAs<MemberPointerType>();\n  assert(PointerTy && \"type was not a member pointer type!\");\n\n  QualType PointeeTy = PointerTy->getPointeeType();\n  // Don't add qualified variants of arrays. For one, they're not allowed\n  // (the qualifier would sink to the element type), and for another, the\n  // only overload situation where it matters is subscript or pointer +- int,\n  // and those shouldn't have qualifier variants anyway.\n  if (PointeeTy->isArrayType())\n    return true;\n  const Type *ClassTy = PointerTy->getClass();\n\n  // Iterate through all strict supersets of the pointee type's CVR\n  // qualifiers.\n  unsigned BaseCVR = PointeeTy.getCVRQualifiers();\n  for (unsigned CVR = BaseCVR+1; CVR <= Qualifiers::CVRMask; ++CVR) {\n    if ((CVR | BaseCVR) != CVR) continue;\n\n    QualType QPointeeTy = Context.getCVRQualifiedType(PointeeTy, CVR);\n    MemberPointerTypes.insert(\n      Context.getMemberPointerType(QPointeeTy, ClassTy));\n  }\n\n  return true;\n}\n\n/// AddTypesConvertedFrom - Add each of the types to which the type @p\n/// Ty can be implicit converted to the given set of @p Types. We're\n/// primarily interested in pointer types and enumeration types. We also\n/// take member pointer types, for the conditional operator.\n/// AllowUserConversions is true if we should look at the conversion\n/// functions of a class type, and AllowExplicitConversions if we\n/// should also include the explicit conversion functions of a class\n/// type.\nvoid\nBuiltinCandidateTypeSet::AddTypesConvertedFrom(QualType Ty,\n                                               SourceLocation Loc,\n                                               bool AllowUserConversions,\n                                               bool AllowExplicitConversions,\n                                               const Qualifiers &VisibleQuals) {\n  // Only deal with canonical types.\n  Ty = Context.getCanonicalType(Ty);\n\n  // Look through reference types; they aren't part of the type of an\n  // expression for the purposes of conversions.\n  if (const ReferenceType *RefTy = Ty->getAs<ReferenceType>())\n    Ty = RefTy->getPointeeType();\n\n  // If we're dealing with an array type, decay to the pointer.\n  if (Ty->isArrayType())\n    Ty = SemaRef.Context.getArrayDecayedType(Ty);\n\n  // Otherwise, we don't care about qualifiers on the type.\n  Ty = Ty.getLocalUnqualifiedType();\n\n  // Flag if we ever add a non-record type.\n  const RecordType *TyRec = Ty->getAs<RecordType>();\n  HasNonRecordTypes = HasNonRecordTypes || !TyRec;\n\n  // Flag if we encounter an arithmetic type.\n  HasArithmeticOrEnumeralTypes =\n    HasArithmeticOrEnumeralTypes || Ty->isArithmeticType();\n\n  if (Ty->isObjCIdType() || Ty->isObjCClassType())\n    PointerTypes.insert(Ty);\n  else if (Ty->getAs<PointerType>() || Ty->getAs<ObjCObjectPointerType>()) {\n    // Insert our type, and its more-qualified variants, into the set\n    // of types.\n    if (!AddPointerWithMoreQualifiedTypeVariants(Ty, VisibleQuals))\n      return;\n  } else if (Ty->isMemberPointerType()) {\n    // Member pointers are far easier, since the pointee can't be converted.\n    if (!AddMemberPointerWithMoreQualifiedTypeVariants(Ty))\n      return;\n  } else if (Ty->isEnumeralType()) {\n    HasArithmeticOrEnumeralTypes = true;\n    EnumerationTypes.insert(Ty);\n  } else if (Ty->isVectorType()) {\n    // We treat vector types as arithmetic types in many contexts as an\n    // extension.\n    HasArithmeticOrEnumeralTypes = true;\n    VectorTypes.insert(Ty);\n  } else if (Ty->isMatrixType()) {\n    // Similar to vector types, we treat vector types as arithmetic types in\n    // many contexts as an extension.\n    HasArithmeticOrEnumeralTypes = true;\n    MatrixTypes.insert(Ty);\n  } else if (Ty->isNullPtrType()) {\n    HasNullPtrType = true;\n  } else if (AllowUserConversions && TyRec) {\n    // No conversion functions in incomplete types.\n    if (!SemaRef.isCompleteType(Loc, Ty))\n      return;\n\n    CXXRecordDecl *ClassDecl = cast<CXXRecordDecl>(TyRec->getDecl());\n    for (NamedDecl *D : ClassDecl->getVisibleConversionFunctions()) {\n      if (isa<UsingShadowDecl>(D))\n        D = cast<UsingShadowDecl>(D)->getTargetDecl();\n\n      // Skip conversion function templates; they don't tell us anything\n      // about which builtin types we can convert to.\n      if (isa<FunctionTemplateDecl>(D))\n        continue;\n\n      CXXConversionDecl *Conv = cast<CXXConversionDecl>(D);\n      if (AllowExplicitConversions || !Conv->isExplicit()) {\n        AddTypesConvertedFrom(Conv->getConversionType(), Loc, false, false,\n                              VisibleQuals);\n      }\n    }\n  }\n}\n/// Helper function for adjusting address spaces for the pointer or reference\n/// operands of builtin operators depending on the argument.\nstatic QualType AdjustAddressSpaceForBuiltinOperandType(Sema &S, QualType T,\n                                                        Expr *Arg) {\n  return S.Context.getAddrSpaceQualType(T, Arg->getType().getAddressSpace());\n}\n\n/// Helper function for AddBuiltinOperatorCandidates() that adds\n/// the volatile- and non-volatile-qualified assignment operators for the\n/// given type to the candidate set.\nstatic void AddBuiltinAssignmentOperatorCandidates(Sema &S,\n                                                   QualType T,\n                                                   ArrayRef<Expr *> Args,\n                                    OverloadCandidateSet &CandidateSet) {\n  QualType ParamTypes[2];\n\n  // T& operator=(T&, T)\n  ParamTypes[0] = S.Context.getLValueReferenceType(\n      AdjustAddressSpaceForBuiltinOperandType(S, T, Args[0]));\n  ParamTypes[1] = T;\n  S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,\n                        /*IsAssignmentOperator=*/true);\n\n  if (!S.Context.getCanonicalType(T).isVolatileQualified()) {\n    // volatile T& operator=(volatile T&, T)\n    ParamTypes[0] = S.Context.getLValueReferenceType(\n        AdjustAddressSpaceForBuiltinOperandType(S, S.Context.getVolatileType(T),\n                                                Args[0]));\n    ParamTypes[1] = T;\n    S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,\n                          /*IsAssignmentOperator=*/true);\n  }\n}\n\n/// CollectVRQualifiers - This routine returns Volatile/Restrict qualifiers,\n/// if any, found in visible type conversion functions found in ArgExpr's type.\nstatic  Qualifiers CollectVRQualifiers(ASTContext &Context, Expr* ArgExpr) {\n    Qualifiers VRQuals;\n    const RecordType *TyRec;\n    if (const MemberPointerType *RHSMPType =\n        ArgExpr->getType()->getAs<MemberPointerType>())\n      TyRec = RHSMPType->getClass()->getAs<RecordType>();\n    else\n      TyRec = ArgExpr->getType()->getAs<RecordType>();\n    if (!TyRec) {\n      // Just to be safe, assume the worst case.\n      VRQuals.addVolatile();\n      VRQuals.addRestrict();\n      return VRQuals;\n    }\n\n    CXXRecordDecl *ClassDecl = cast<CXXRecordDecl>(TyRec->getDecl());\n    if (!ClassDecl->hasDefinition())\n      return VRQuals;\n\n    for (NamedDecl *D : ClassDecl->getVisibleConversionFunctions()) {\n      if (isa<UsingShadowDecl>(D))\n        D = cast<UsingShadowDecl>(D)->getTargetDecl();\n      if (CXXConversionDecl *Conv = dyn_cast<CXXConversionDecl>(D)) {\n        QualType CanTy = Context.getCanonicalType(Conv->getConversionType());\n        if (const ReferenceType *ResTypeRef = CanTy->getAs<ReferenceType>())\n          CanTy = ResTypeRef->getPointeeType();\n        // Need to go down the pointer/mempointer chain and add qualifiers\n        // as see them.\n        bool done = false;\n        while (!done) {\n          if (CanTy.isRestrictQualified())\n            VRQuals.addRestrict();\n          if (const PointerType *ResTypePtr = CanTy->getAs<PointerType>())\n            CanTy = ResTypePtr->getPointeeType();\n          else if (const MemberPointerType *ResTypeMPtr =\n                CanTy->getAs<MemberPointerType>())\n            CanTy = ResTypeMPtr->getPointeeType();\n          else\n            done = true;\n          if (CanTy.isVolatileQualified())\n            VRQuals.addVolatile();\n          if (VRQuals.hasRestrict() && VRQuals.hasVolatile())\n            return VRQuals;\n        }\n      }\n    }\n    return VRQuals;\n}\n\nnamespace {\n\n/// Helper class to manage the addition of builtin operator overload\n/// candidates. It provides shared state and utility methods used throughout\n/// the process, as well as a helper method to add each group of builtin\n/// operator overloads from the standard to a candidate set.\nclass BuiltinOperatorOverloadBuilder {\n  // Common instance state available to all overload candidate addition methods.\n  Sema &S;\n  ArrayRef<Expr *> Args;\n  Qualifiers VisibleTypeConversionsQuals;\n  bool HasArithmeticOrEnumeralCandidateType;\n  SmallVectorImpl<BuiltinCandidateTypeSet> &CandidateTypes;\n  OverloadCandidateSet &CandidateSet;\n\n  static constexpr int ArithmeticTypesCap = 24;\n  SmallVector<CanQualType, ArithmeticTypesCap> ArithmeticTypes;\n\n  // Define some indices used to iterate over the arithmetic types in\n  // ArithmeticTypes.  The \"promoted arithmetic types\" are the arithmetic\n  // types are that preserved by promotion (C++ [over.built]p2).\n  unsigned FirstIntegralType,\n           LastIntegralType;\n  unsigned FirstPromotedIntegralType,\n           LastPromotedIntegralType;\n  unsigned FirstPromotedArithmeticType,\n           LastPromotedArithmeticType;\n  unsigned NumArithmeticTypes;\n\n  void InitArithmeticTypes() {\n    // Start of promoted types.\n    FirstPromotedArithmeticType = 0;\n    ArithmeticTypes.push_back(S.Context.FloatTy);\n    ArithmeticTypes.push_back(S.Context.DoubleTy);\n    ArithmeticTypes.push_back(S.Context.LongDoubleTy);\n    if (S.Context.getTargetInfo().hasFloat128Type())\n      ArithmeticTypes.push_back(S.Context.Float128Ty);\n\n    // Start of integral types.\n    FirstIntegralType = ArithmeticTypes.size();\n    FirstPromotedIntegralType = ArithmeticTypes.size();\n    ArithmeticTypes.push_back(S.Context.IntTy);\n    ArithmeticTypes.push_back(S.Context.LongTy);\n    ArithmeticTypes.push_back(S.Context.LongLongTy);\n    if (S.Context.getTargetInfo().hasInt128Type() ||\n        (S.Context.getAuxTargetInfo() &&\n         S.Context.getAuxTargetInfo()->hasInt128Type()))\n      ArithmeticTypes.push_back(S.Context.Int128Ty);\n    ArithmeticTypes.push_back(S.Context.UnsignedIntTy);\n    ArithmeticTypes.push_back(S.Context.UnsignedLongTy);\n    ArithmeticTypes.push_back(S.Context.UnsignedLongLongTy);\n    if (S.Context.getTargetInfo().hasInt128Type() ||\n        (S.Context.getAuxTargetInfo() &&\n         S.Context.getAuxTargetInfo()->hasInt128Type()))\n      ArithmeticTypes.push_back(S.Context.UnsignedInt128Ty);\n    LastPromotedIntegralType = ArithmeticTypes.size();\n    LastPromotedArithmeticType = ArithmeticTypes.size();\n    // End of promoted types.\n\n    ArithmeticTypes.push_back(S.Context.BoolTy);\n    ArithmeticTypes.push_back(S.Context.CharTy);\n    ArithmeticTypes.push_back(S.Context.WCharTy);\n    if (S.Context.getLangOpts().Char8)\n      ArithmeticTypes.push_back(S.Context.Char8Ty);\n    ArithmeticTypes.push_back(S.Context.Char16Ty);\n    ArithmeticTypes.push_back(S.Context.Char32Ty);\n    ArithmeticTypes.push_back(S.Context.SignedCharTy);\n    ArithmeticTypes.push_back(S.Context.ShortTy);\n    ArithmeticTypes.push_back(S.Context.UnsignedCharTy);\n    ArithmeticTypes.push_back(S.Context.UnsignedShortTy);\n    LastIntegralType = ArithmeticTypes.size();\n    NumArithmeticTypes = ArithmeticTypes.size();\n    // End of integral types.\n    // FIXME: What about complex? What about half?\n\n    assert(ArithmeticTypes.size() <= ArithmeticTypesCap &&\n           \"Enough inline storage for all arithmetic types.\");\n  }\n\n  /// Helper method to factor out the common pattern of adding overloads\n  /// for '++' and '--' builtin operators.\n  void addPlusPlusMinusMinusStyleOverloads(QualType CandidateTy,\n                                           bool HasVolatile,\n                                           bool HasRestrict) {\n    QualType ParamTypes[2] = {\n      S.Context.getLValueReferenceType(CandidateTy),\n      S.Context.IntTy\n    };\n\n    // Non-volatile version.\n    S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);\n\n    // Use a heuristic to reduce number of builtin candidates in the set:\n    // add volatile version only if there are conversions to a volatile type.\n    if (HasVolatile) {\n      ParamTypes[0] =\n        S.Context.getLValueReferenceType(\n          S.Context.getVolatileType(CandidateTy));\n      S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);\n    }\n\n    // Add restrict version only if there are conversions to a restrict type\n    // and our candidate type is a non-restrict-qualified pointer.\n    if (HasRestrict && CandidateTy->isAnyPointerType() &&\n        !CandidateTy.isRestrictQualified()) {\n      ParamTypes[0]\n        = S.Context.getLValueReferenceType(\n            S.Context.getCVRQualifiedType(CandidateTy, Qualifiers::Restrict));\n      S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);\n\n      if (HasVolatile) {\n        ParamTypes[0]\n          = S.Context.getLValueReferenceType(\n              S.Context.getCVRQualifiedType(CandidateTy,\n                                            (Qualifiers::Volatile |\n                                             Qualifiers::Restrict)));\n        S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);\n      }\n    }\n\n  }\n\n  /// Helper to add an overload candidate for a binary builtin with types \\p L\n  /// and \\p R.\n  void AddCandidate(QualType L, QualType R) {\n    QualType LandR[2] = {L, R};\n    S.AddBuiltinCandidate(LandR, Args, CandidateSet);\n  }\n\npublic:\n  BuiltinOperatorOverloadBuilder(\n    Sema &S, ArrayRef<Expr *> Args,\n    Qualifiers VisibleTypeConversionsQuals,\n    bool HasArithmeticOrEnumeralCandidateType,\n    SmallVectorImpl<BuiltinCandidateTypeSet> &CandidateTypes,\n    OverloadCandidateSet &CandidateSet)\n    : S(S), Args(Args),\n      VisibleTypeConversionsQuals(VisibleTypeConversionsQuals),\n      HasArithmeticOrEnumeralCandidateType(\n        HasArithmeticOrEnumeralCandidateType),\n      CandidateTypes(CandidateTypes),\n      CandidateSet(CandidateSet) {\n\n    InitArithmeticTypes();\n  }\n\n  // Increment is deprecated for bool since C++17.\n  //\n  // C++ [over.built]p3:\n  //\n  //   For every pair (T, VQ), where T is an arithmetic type other\n  //   than bool, and VQ is either volatile or empty, there exist\n  //   candidate operator functions of the form\n  //\n  //       VQ T&      operator++(VQ T&);\n  //       T          operator++(VQ T&, int);\n  //\n  // C++ [over.built]p4:\n  //\n  //   For every pair (T, VQ), where T is an arithmetic type other\n  //   than bool, and VQ is either volatile or empty, there exist\n  //   candidate operator functions of the form\n  //\n  //       VQ T&      operator--(VQ T&);\n  //       T          operator--(VQ T&, int);\n  void addPlusPlusMinusMinusArithmeticOverloads(OverloadedOperatorKind Op) {\n    if (!HasArithmeticOrEnumeralCandidateType)\n      return;\n\n    for (unsigned Arith = 0; Arith < NumArithmeticTypes; ++Arith) {\n      const auto TypeOfT = ArithmeticTypes[Arith];\n      if (TypeOfT == S.Context.BoolTy) {\n        if (Op == OO_MinusMinus)\n          continue;\n        if (Op == OO_PlusPlus && S.getLangOpts().CPlusPlus17)\n          continue;\n      }\n      addPlusPlusMinusMinusStyleOverloads(\n        TypeOfT,\n        VisibleTypeConversionsQuals.hasVolatile(),\n        VisibleTypeConversionsQuals.hasRestrict());\n    }\n  }\n\n  // C++ [over.built]p5:\n  //\n  //   For every pair (T, VQ), where T is a cv-qualified or\n  //   cv-unqualified object type, and VQ is either volatile or\n  //   empty, there exist candidate operator functions of the form\n  //\n  //       T*VQ&      operator++(T*VQ&);\n  //       T*VQ&      operator--(T*VQ&);\n  //       T*         operator++(T*VQ&, int);\n  //       T*         operator--(T*VQ&, int);\n  void addPlusPlusMinusMinusPointerOverloads() {\n    for (QualType PtrTy : CandidateTypes[0].pointer_types()) {\n      // Skip pointer types that aren't pointers to object types.\n      if (!PtrTy->getPointeeType()->isObjectType())\n        continue;\n\n      addPlusPlusMinusMinusStyleOverloads(\n          PtrTy,\n          (!PtrTy.isVolatileQualified() &&\n           VisibleTypeConversionsQuals.hasVolatile()),\n          (!PtrTy.isRestrictQualified() &&\n           VisibleTypeConversionsQuals.hasRestrict()));\n    }\n  }\n\n  // C++ [over.built]p6:\n  //   For every cv-qualified or cv-unqualified object type T, there\n  //   exist candidate operator functions of the form\n  //\n  //       T&         operator*(T*);\n  //\n  // C++ [over.built]p7:\n  //   For every function type T that does not have cv-qualifiers or a\n  //   ref-qualifier, there exist candidate operator functions of the form\n  //       T&         operator*(T*);\n  void addUnaryStarPointerOverloads() {\n    for (QualType ParamTy : CandidateTypes[0].pointer_types()) {\n      QualType PointeeTy = ParamTy->getPointeeType();\n      if (!PointeeTy->isObjectType() && !PointeeTy->isFunctionType())\n        continue;\n\n      if (const FunctionProtoType *Proto =PointeeTy->getAs<FunctionProtoType>())\n        if (Proto->getMethodQuals() || Proto->getRefQualifier())\n          continue;\n\n      S.AddBuiltinCandidate(&ParamTy, Args, CandidateSet);\n    }\n  }\n\n  // C++ [over.built]p9:\n  //  For every promoted arithmetic type T, there exist candidate\n  //  operator functions of the form\n  //\n  //       T         operator+(T);\n  //       T         operator-(T);\n  void addUnaryPlusOrMinusArithmeticOverloads() {\n    if (!HasArithmeticOrEnumeralCandidateType)\n      return;\n\n    for (unsigned Arith = FirstPromotedArithmeticType;\n         Arith < LastPromotedArithmeticType; ++Arith) {\n      QualType ArithTy = ArithmeticTypes[Arith];\n      S.AddBuiltinCandidate(&ArithTy, Args, CandidateSet);\n    }\n\n    // Extension: We also add these operators for vector types.\n    for (QualType VecTy : CandidateTypes[0].vector_types())\n      S.AddBuiltinCandidate(&VecTy, Args, CandidateSet);\n  }\n\n  // C++ [over.built]p8:\n  //   For every type T, there exist candidate operator functions of\n  //   the form\n  //\n  //       T*         operator+(T*);\n  void addUnaryPlusPointerOverloads() {\n    for (QualType ParamTy : CandidateTypes[0].pointer_types())\n      S.AddBuiltinCandidate(&ParamTy, Args, CandidateSet);\n  }\n\n  // C++ [over.built]p10:\n  //   For every promoted integral type T, there exist candidate\n  //   operator functions of the form\n  //\n  //        T         operator~(T);\n  void addUnaryTildePromotedIntegralOverloads() {\n    if (!HasArithmeticOrEnumeralCandidateType)\n      return;\n\n    for (unsigned Int = FirstPromotedIntegralType;\n         Int < LastPromotedIntegralType; ++Int) {\n      QualType IntTy = ArithmeticTypes[Int];\n      S.AddBuiltinCandidate(&IntTy, Args, CandidateSet);\n    }\n\n    // Extension: We also add this operator for vector types.\n    for (QualType VecTy : CandidateTypes[0].vector_types())\n      S.AddBuiltinCandidate(&VecTy, Args, CandidateSet);\n  }\n\n  // C++ [over.match.oper]p16:\n  //   For every pointer to member type T or type std::nullptr_t, there\n  //   exist candidate operator functions of the form\n  //\n  //        bool operator==(T,T);\n  //        bool operator!=(T,T);\n  void addEqualEqualOrNotEqualMemberPointerOrNullptrOverloads() {\n    /// Set of (canonical) types that we've already handled.\n    llvm::SmallPtrSet<QualType, 8> AddedTypes;\n\n    for (unsigned ArgIdx = 0, N = Args.size(); ArgIdx != N; ++ArgIdx) {\n      for (QualType MemPtrTy : CandidateTypes[ArgIdx].member_pointer_types()) {\n        // Don't add the same builtin candidate twice.\n        if (!AddedTypes.insert(S.Context.getCanonicalType(MemPtrTy)).second)\n          continue;\n\n        QualType ParamTypes[2] = {MemPtrTy, MemPtrTy};\n        S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);\n      }\n\n      if (CandidateTypes[ArgIdx].hasNullPtrType()) {\n        CanQualType NullPtrTy = S.Context.getCanonicalType(S.Context.NullPtrTy);\n        if (AddedTypes.insert(NullPtrTy).second) {\n          QualType ParamTypes[2] = { NullPtrTy, NullPtrTy };\n          S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);\n        }\n      }\n    }\n  }\n\n  // C++ [over.built]p15:\n  //\n  //   For every T, where T is an enumeration type or a pointer type,\n  //   there exist candidate operator functions of the form\n  //\n  //        bool       operator<(T, T);\n  //        bool       operator>(T, T);\n  //        bool       operator<=(T, T);\n  //        bool       operator>=(T, T);\n  //        bool       operator==(T, T);\n  //        bool       operator!=(T, T);\n  //           R       operator<=>(T, T)\n  void addGenericBinaryPointerOrEnumeralOverloads() {\n    // C++ [over.match.oper]p3:\n    //   [...]the built-in candidates include all of the candidate operator\n    //   functions defined in 13.6 that, compared to the given operator, [...]\n    //   do not have the same parameter-type-list as any non-template non-member\n    //   candidate.\n    //\n    // Note that in practice, this only affects enumeration types because there\n    // aren't any built-in candidates of record type, and a user-defined operator\n    // must have an operand of record or enumeration type. Also, the only other\n    // overloaded operator with enumeration arguments, operator=,\n    // cannot be overloaded for enumeration types, so this is the only place\n    // where we must suppress candidates like this.\n    llvm::DenseSet<std::pair<CanQualType, CanQualType> >\n      UserDefinedBinaryOperators;\n\n    for (unsigned ArgIdx = 0, N = Args.size(); ArgIdx != N; ++ArgIdx) {\n      if (!CandidateTypes[ArgIdx].enumeration_types().empty()) {\n        for (OverloadCandidateSet::iterator C = CandidateSet.begin(),\n                                         CEnd = CandidateSet.end();\n             C != CEnd; ++C) {\n          if (!C->Viable || !C->Function || C->Function->getNumParams() != 2)\n            continue;\n\n          if (C->Function->isFunctionTemplateSpecialization())\n            continue;\n\n          // We interpret \"same parameter-type-list\" as applying to the\n          // \"synthesized candidate, with the order of the two parameters\n          // reversed\", not to the original function.\n          bool Reversed = C->isReversed();\n          QualType FirstParamType = C->Function->getParamDecl(Reversed ? 1 : 0)\n                                        ->getType()\n                                        .getUnqualifiedType();\n          QualType SecondParamType = C->Function->getParamDecl(Reversed ? 0 : 1)\n                                         ->getType()\n                                         .getUnqualifiedType();\n\n          // Skip if either parameter isn't of enumeral type.\n          if (!FirstParamType->isEnumeralType() ||\n              !SecondParamType->isEnumeralType())\n            continue;\n\n          // Add this operator to the set of known user-defined operators.\n          UserDefinedBinaryOperators.insert(\n            std::make_pair(S.Context.getCanonicalType(FirstParamType),\n                           S.Context.getCanonicalType(SecondParamType)));\n        }\n      }\n    }\n\n    /// Set of (canonical) types that we've already handled.\n    llvm::SmallPtrSet<QualType, 8> AddedTypes;\n\n    for (unsigned ArgIdx = 0, N = Args.size(); ArgIdx != N; ++ArgIdx) {\n      for (QualType PtrTy : CandidateTypes[ArgIdx].pointer_types()) {\n        // Don't add the same builtin candidate twice.\n        if (!AddedTypes.insert(S.Context.getCanonicalType(PtrTy)).second)\n          continue;\n\n        QualType ParamTypes[2] = {PtrTy, PtrTy};\n        S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);\n      }\n      for (QualType EnumTy : CandidateTypes[ArgIdx].enumeration_types()) {\n        CanQualType CanonType = S.Context.getCanonicalType(EnumTy);\n\n        // Don't add the same builtin candidate twice, or if a user defined\n        // candidate exists.\n        if (!AddedTypes.insert(CanonType).second ||\n            UserDefinedBinaryOperators.count(std::make_pair(CanonType,\n                                                            CanonType)))\n          continue;\n        QualType ParamTypes[2] = {EnumTy, EnumTy};\n        S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);\n      }\n    }\n  }\n\n  // C++ [over.built]p13:\n  //\n  //   For every cv-qualified or cv-unqualified object type T\n  //   there exist candidate operator functions of the form\n  //\n  //      T*         operator+(T*, ptrdiff_t);\n  //      T&         operator[](T*, ptrdiff_t);    [BELOW]\n  //      T*         operator-(T*, ptrdiff_t);\n  //      T*         operator+(ptrdiff_t, T*);\n  //      T&         operator[](ptrdiff_t, T*);    [BELOW]\n  //\n  // C++ [over.built]p14:\n  //\n  //   For every T, where T is a pointer to object type, there\n  //   exist candidate operator functions of the form\n  //\n  //      ptrdiff_t  operator-(T, T);\n  void addBinaryPlusOrMinusPointerOverloads(OverloadedOperatorKind Op) {\n    /// Set of (canonical) types that we've already handled.\n    llvm::SmallPtrSet<QualType, 8> AddedTypes;\n\n    for (int Arg = 0; Arg < 2; ++Arg) {\n      QualType AsymmetricParamTypes[2] = {\n        S.Context.getPointerDiffType(),\n        S.Context.getPointerDiffType(),\n      };\n      for (QualType PtrTy : CandidateTypes[Arg].pointer_types()) {\n        QualType PointeeTy = PtrTy->getPointeeType();\n        if (!PointeeTy->isObjectType())\n          continue;\n\n        AsymmetricParamTypes[Arg] = PtrTy;\n        if (Arg == 0 || Op == OO_Plus) {\n          // operator+(T*, ptrdiff_t) or operator-(T*, ptrdiff_t)\n          // T* operator+(ptrdiff_t, T*);\n          S.AddBuiltinCandidate(AsymmetricParamTypes, Args, CandidateSet);\n        }\n        if (Op == OO_Minus) {\n          // ptrdiff_t operator-(T, T);\n          if (!AddedTypes.insert(S.Context.getCanonicalType(PtrTy)).second)\n            continue;\n\n          QualType ParamTypes[2] = {PtrTy, PtrTy};\n          S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);\n        }\n      }\n    }\n  }\n\n  // C++ [over.built]p12:\n  //\n  //   For every pair of promoted arithmetic types L and R, there\n  //   exist candidate operator functions of the form\n  //\n  //        LR         operator*(L, R);\n  //        LR         operator/(L, R);\n  //        LR         operator+(L, R);\n  //        LR         operator-(L, R);\n  //        bool       operator<(L, R);\n  //        bool       operator>(L, R);\n  //        bool       operator<=(L, R);\n  //        bool       operator>=(L, R);\n  //        bool       operator==(L, R);\n  //        bool       operator!=(L, R);\n  //\n  //   where LR is the result of the usual arithmetic conversions\n  //   between types L and R.\n  //\n  // C++ [over.built]p24:\n  //\n  //   For every pair of promoted arithmetic types L and R, there exist\n  //   candidate operator functions of the form\n  //\n  //        LR       operator?(bool, L, R);\n  //\n  //   where LR is the result of the usual arithmetic conversions\n  //   between types L and R.\n  // Our candidates ignore the first parameter.\n  void addGenericBinaryArithmeticOverloads() {\n    if (!HasArithmeticOrEnumeralCandidateType)\n      return;\n\n    for (unsigned Left = FirstPromotedArithmeticType;\n         Left < LastPromotedArithmeticType; ++Left) {\n      for (unsigned Right = FirstPromotedArithmeticType;\n           Right < LastPromotedArithmeticType; ++Right) {\n        QualType LandR[2] = { ArithmeticTypes[Left],\n                              ArithmeticTypes[Right] };\n        S.AddBuiltinCandidate(LandR, Args, CandidateSet);\n      }\n    }\n\n    // Extension: Add the binary operators ==, !=, <, <=, >=, >, *, /, and the\n    // conditional operator for vector types.\n    for (QualType Vec1Ty : CandidateTypes[0].vector_types())\n      for (QualType Vec2Ty : CandidateTypes[1].vector_types()) {\n        QualType LandR[2] = {Vec1Ty, Vec2Ty};\n        S.AddBuiltinCandidate(LandR, Args, CandidateSet);\n      }\n  }\n\n  /// Add binary operator overloads for each candidate matrix type M1, M2:\n  ///  * (M1, M1) -> M1\n  ///  * (M1, M1.getElementType()) -> M1\n  ///  * (M2.getElementType(), M2) -> M2\n  ///  * (M2, M2) -> M2 // Only if M2 is not part of CandidateTypes[0].\n  void addMatrixBinaryArithmeticOverloads() {\n    if (!HasArithmeticOrEnumeralCandidateType)\n      return;\n\n    for (QualType M1 : CandidateTypes[0].matrix_types()) {\n      AddCandidate(M1, cast<MatrixType>(M1)->getElementType());\n      AddCandidate(M1, M1);\n    }\n\n    for (QualType M2 : CandidateTypes[1].matrix_types()) {\n      AddCandidate(cast<MatrixType>(M2)->getElementType(), M2);\n      if (!CandidateTypes[0].containsMatrixType(M2))\n        AddCandidate(M2, M2);\n    }\n  }\n\n  // C++2a [over.built]p14:\n  //\n  //   For every integral type T there exists a candidate operator function\n  //   of the form\n  //\n  //        std::strong_ordering operator<=>(T, T)\n  //\n  // C++2a [over.built]p15:\n  //\n  //   For every pair of floating-point types L and R, there exists a candidate\n  //   operator function of the form\n  //\n  //       std::partial_ordering operator<=>(L, R);\n  //\n  // FIXME: The current specification for integral types doesn't play nice with\n  // the direction of p0946r0, which allows mixed integral and unscoped-enum\n  // comparisons. Under the current spec this can lead to ambiguity during\n  // overload resolution. For example:\n  //\n  //   enum A : int {a};\n  //   auto x = (a <=> (long)42);\n  //\n  //   error: call is ambiguous for arguments 'A' and 'long'.\n  //   note: candidate operator<=>(int, int)\n  //   note: candidate operator<=>(long, long)\n  //\n  // To avoid this error, this function deviates from the specification and adds\n  // the mixed overloads `operator<=>(L, R)` where L and R are promoted\n  // arithmetic types (the same as the generic relational overloads).\n  //\n  // For now this function acts as a placeholder.\n  void addThreeWayArithmeticOverloads() {\n    addGenericBinaryArithmeticOverloads();\n  }\n\n  // C++ [over.built]p17:\n  //\n  //   For every pair of promoted integral types L and R, there\n  //   exist candidate operator functions of the form\n  //\n  //      LR         operator%(L, R);\n  //      LR         operator&(L, R);\n  //      LR         operator^(L, R);\n  //      LR         operator|(L, R);\n  //      L          operator<<(L, R);\n  //      L          operator>>(L, R);\n  //\n  //   where LR is the result of the usual arithmetic conversions\n  //   between types L and R.\n  void addBinaryBitwiseArithmeticOverloads(OverloadedOperatorKind Op) {\n    if (!HasArithmeticOrEnumeralCandidateType)\n      return;\n\n    for (unsigned Left = FirstPromotedIntegralType;\n         Left < LastPromotedIntegralType; ++Left) {\n      for (unsigned Right = FirstPromotedIntegralType;\n           Right < LastPromotedIntegralType; ++Right) {\n        QualType LandR[2] = { ArithmeticTypes[Left],\n                              ArithmeticTypes[Right] };\n        S.AddBuiltinCandidate(LandR, Args, CandidateSet);\n      }\n    }\n  }\n\n  // C++ [over.built]p20:\n  //\n  //   For every pair (T, VQ), where T is an enumeration or\n  //   pointer to member type and VQ is either volatile or\n  //   empty, there exist candidate operator functions of the form\n  //\n  //        VQ T&      operator=(VQ T&, T);\n  void addAssignmentMemberPointerOrEnumeralOverloads() {\n    /// Set of (canonical) types that we've already handled.\n    llvm::SmallPtrSet<QualType, 8> AddedTypes;\n\n    for (unsigned ArgIdx = 0; ArgIdx < 2; ++ArgIdx) {\n      for (QualType EnumTy : CandidateTypes[ArgIdx].enumeration_types()) {\n        if (!AddedTypes.insert(S.Context.getCanonicalType(EnumTy)).second)\n          continue;\n\n        AddBuiltinAssignmentOperatorCandidates(S, EnumTy, Args, CandidateSet);\n      }\n\n      for (QualType MemPtrTy : CandidateTypes[ArgIdx].member_pointer_types()) {\n        if (!AddedTypes.insert(S.Context.getCanonicalType(MemPtrTy)).second)\n          continue;\n\n        AddBuiltinAssignmentOperatorCandidates(S, MemPtrTy, Args, CandidateSet);\n      }\n    }\n  }\n\n  // C++ [over.built]p19:\n  //\n  //   For every pair (T, VQ), where T is any type and VQ is either\n  //   volatile or empty, there exist candidate operator functions\n  //   of the form\n  //\n  //        T*VQ&      operator=(T*VQ&, T*);\n  //\n  // C++ [over.built]p21:\n  //\n  //   For every pair (T, VQ), where T is a cv-qualified or\n  //   cv-unqualified object type and VQ is either volatile or\n  //   empty, there exist candidate operator functions of the form\n  //\n  //        T*VQ&      operator+=(T*VQ&, ptrdiff_t);\n  //        T*VQ&      operator-=(T*VQ&, ptrdiff_t);\n  void addAssignmentPointerOverloads(bool isEqualOp) {\n    /// Set of (canonical) types that we've already handled.\n    llvm::SmallPtrSet<QualType, 8> AddedTypes;\n\n    for (QualType PtrTy : CandidateTypes[0].pointer_types()) {\n      // If this is operator=, keep track of the builtin candidates we added.\n      if (isEqualOp)\n        AddedTypes.insert(S.Context.getCanonicalType(PtrTy));\n      else if (!PtrTy->getPointeeType()->isObjectType())\n        continue;\n\n      // non-volatile version\n      QualType ParamTypes[2] = {\n          S.Context.getLValueReferenceType(PtrTy),\n          isEqualOp ? PtrTy : S.Context.getPointerDiffType(),\n      };\n      S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,\n                            /*IsAssignmentOperator=*/ isEqualOp);\n\n      bool NeedVolatile = !PtrTy.isVolatileQualified() &&\n                          VisibleTypeConversionsQuals.hasVolatile();\n      if (NeedVolatile) {\n        // volatile version\n        ParamTypes[0] =\n            S.Context.getLValueReferenceType(S.Context.getVolatileType(PtrTy));\n        S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,\n                              /*IsAssignmentOperator=*/isEqualOp);\n      }\n\n      if (!PtrTy.isRestrictQualified() &&\n          VisibleTypeConversionsQuals.hasRestrict()) {\n        // restrict version\n        ParamTypes[0] =\n            S.Context.getLValueReferenceType(S.Context.getRestrictType(PtrTy));\n        S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,\n                              /*IsAssignmentOperator=*/isEqualOp);\n\n        if (NeedVolatile) {\n          // volatile restrict version\n          ParamTypes[0] =\n              S.Context.getLValueReferenceType(S.Context.getCVRQualifiedType(\n                  PtrTy, (Qualifiers::Volatile | Qualifiers::Restrict)));\n          S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,\n                                /*IsAssignmentOperator=*/isEqualOp);\n        }\n      }\n    }\n\n    if (isEqualOp) {\n      for (QualType PtrTy : CandidateTypes[1].pointer_types()) {\n        // Make sure we don't add the same candidate twice.\n        if (!AddedTypes.insert(S.Context.getCanonicalType(PtrTy)).second)\n          continue;\n\n        QualType ParamTypes[2] = {\n            S.Context.getLValueReferenceType(PtrTy),\n            PtrTy,\n        };\n\n        // non-volatile version\n        S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,\n                              /*IsAssignmentOperator=*/true);\n\n        bool NeedVolatile = !PtrTy.isVolatileQualified() &&\n                            VisibleTypeConversionsQuals.hasVolatile();\n        if (NeedVolatile) {\n          // volatile version\n          ParamTypes[0] = S.Context.getLValueReferenceType(\n              S.Context.getVolatileType(PtrTy));\n          S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,\n                                /*IsAssignmentOperator=*/true);\n        }\n\n        if (!PtrTy.isRestrictQualified() &&\n            VisibleTypeConversionsQuals.hasRestrict()) {\n          // restrict version\n          ParamTypes[0] = S.Context.getLValueReferenceType(\n              S.Context.getRestrictType(PtrTy));\n          S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,\n                                /*IsAssignmentOperator=*/true);\n\n          if (NeedVolatile) {\n            // volatile restrict version\n            ParamTypes[0] =\n                S.Context.getLValueReferenceType(S.Context.getCVRQualifiedType(\n                    PtrTy, (Qualifiers::Volatile | Qualifiers::Restrict)));\n            S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,\n                                  /*IsAssignmentOperator=*/true);\n          }\n        }\n      }\n    }\n  }\n\n  // C++ [over.built]p18:\n  //\n  //   For every triple (L, VQ, R), where L is an arithmetic type,\n  //   VQ is either volatile or empty, and R is a promoted\n  //   arithmetic type, there exist candidate operator functions of\n  //   the form\n  //\n  //        VQ L&      operator=(VQ L&, R);\n  //        VQ L&      operator*=(VQ L&, R);\n  //        VQ L&      operator/=(VQ L&, R);\n  //        VQ L&      operator+=(VQ L&, R);\n  //        VQ L&      operator-=(VQ L&, R);\n  void addAssignmentArithmeticOverloads(bool isEqualOp) {\n    if (!HasArithmeticOrEnumeralCandidateType)\n      return;\n\n    for (unsigned Left = 0; Left < NumArithmeticTypes; ++Left) {\n      for (unsigned Right = FirstPromotedArithmeticType;\n           Right < LastPromotedArithmeticType; ++Right) {\n        QualType ParamTypes[2];\n        ParamTypes[1] = ArithmeticTypes[Right];\n        auto LeftBaseTy = AdjustAddressSpaceForBuiltinOperandType(\n            S, ArithmeticTypes[Left], Args[0]);\n        // Add this built-in operator as a candidate (VQ is empty).\n        ParamTypes[0] = S.Context.getLValueReferenceType(LeftBaseTy);\n        S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,\n                              /*IsAssignmentOperator=*/isEqualOp);\n\n        // Add this built-in operator as a candidate (VQ is 'volatile').\n        if (VisibleTypeConversionsQuals.hasVolatile()) {\n          ParamTypes[0] = S.Context.getVolatileType(LeftBaseTy);\n          ParamTypes[0] = S.Context.getLValueReferenceType(ParamTypes[0]);\n          S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,\n                                /*IsAssignmentOperator=*/isEqualOp);\n        }\n      }\n    }\n\n    // Extension: Add the binary operators =, +=, -=, *=, /= for vector types.\n    for (QualType Vec1Ty : CandidateTypes[0].vector_types())\n      for (QualType Vec2Ty : CandidateTypes[0].vector_types()) {\n        QualType ParamTypes[2];\n        ParamTypes[1] = Vec2Ty;\n        // Add this built-in operator as a candidate (VQ is empty).\n        ParamTypes[0] = S.Context.getLValueReferenceType(Vec1Ty);\n        S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,\n                              /*IsAssignmentOperator=*/isEqualOp);\n\n        // Add this built-in operator as a candidate (VQ is 'volatile').\n        if (VisibleTypeConversionsQuals.hasVolatile()) {\n          ParamTypes[0] = S.Context.getVolatileType(Vec1Ty);\n          ParamTypes[0] = S.Context.getLValueReferenceType(ParamTypes[0]);\n          S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,\n                                /*IsAssignmentOperator=*/isEqualOp);\n        }\n      }\n  }\n\n  // C++ [over.built]p22:\n  //\n  //   For every triple (L, VQ, R), where L is an integral type, VQ\n  //   is either volatile or empty, and R is a promoted integral\n  //   type, there exist candidate operator functions of the form\n  //\n  //        VQ L&       operator%=(VQ L&, R);\n  //        VQ L&       operator<<=(VQ L&, R);\n  //        VQ L&       operator>>=(VQ L&, R);\n  //        VQ L&       operator&=(VQ L&, R);\n  //        VQ L&       operator^=(VQ L&, R);\n  //        VQ L&       operator|=(VQ L&, R);\n  void addAssignmentIntegralOverloads() {\n    if (!HasArithmeticOrEnumeralCandidateType)\n      return;\n\n    for (unsigned Left = FirstIntegralType; Left < LastIntegralType; ++Left) {\n      for (unsigned Right = FirstPromotedIntegralType;\n           Right < LastPromotedIntegralType; ++Right) {\n        QualType ParamTypes[2];\n        ParamTypes[1] = ArithmeticTypes[Right];\n        auto LeftBaseTy = AdjustAddressSpaceForBuiltinOperandType(\n            S, ArithmeticTypes[Left], Args[0]);\n        // Add this built-in operator as a candidate (VQ is empty).\n        ParamTypes[0] = S.Context.getLValueReferenceType(LeftBaseTy);\n        S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);\n        if (VisibleTypeConversionsQuals.hasVolatile()) {\n          // Add this built-in operator as a candidate (VQ is 'volatile').\n          ParamTypes[0] = LeftBaseTy;\n          ParamTypes[0] = S.Context.getVolatileType(ParamTypes[0]);\n          ParamTypes[0] = S.Context.getLValueReferenceType(ParamTypes[0]);\n          S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);\n        }\n      }\n    }\n  }\n\n  // C++ [over.operator]p23:\n  //\n  //   There also exist candidate operator functions of the form\n  //\n  //        bool        operator!(bool);\n  //        bool        operator&&(bool, bool);\n  //        bool        operator||(bool, bool);\n  void addExclaimOverload() {\n    QualType ParamTy = S.Context.BoolTy;\n    S.AddBuiltinCandidate(&ParamTy, Args, CandidateSet,\n                          /*IsAssignmentOperator=*/false,\n                          /*NumContextualBoolArguments=*/1);\n  }\n  void addAmpAmpOrPipePipeOverload() {\n    QualType ParamTypes[2] = { S.Context.BoolTy, S.Context.BoolTy };\n    S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet,\n                          /*IsAssignmentOperator=*/false,\n                          /*NumContextualBoolArguments=*/2);\n  }\n\n  // C++ [over.built]p13:\n  //\n  //   For every cv-qualified or cv-unqualified object type T there\n  //   exist candidate operator functions of the form\n  //\n  //        T*         operator+(T*, ptrdiff_t);     [ABOVE]\n  //        T&         operator[](T*, ptrdiff_t);\n  //        T*         operator-(T*, ptrdiff_t);     [ABOVE]\n  //        T*         operator+(ptrdiff_t, T*);     [ABOVE]\n  //        T&         operator[](ptrdiff_t, T*);\n  void addSubscriptOverloads() {\n    for (QualType PtrTy : CandidateTypes[0].pointer_types()) {\n      QualType ParamTypes[2] = {PtrTy, S.Context.getPointerDiffType()};\n      QualType PointeeType = PtrTy->getPointeeType();\n      if (!PointeeType->isObjectType())\n        continue;\n\n      // T& operator[](T*, ptrdiff_t)\n      S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);\n    }\n\n    for (QualType PtrTy : CandidateTypes[1].pointer_types()) {\n      QualType ParamTypes[2] = {S.Context.getPointerDiffType(), PtrTy};\n      QualType PointeeType = PtrTy->getPointeeType();\n      if (!PointeeType->isObjectType())\n        continue;\n\n      // T& operator[](ptrdiff_t, T*)\n      S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);\n    }\n  }\n\n  // C++ [over.built]p11:\n  //    For every quintuple (C1, C2, T, CV1, CV2), where C2 is a class type,\n  //    C1 is the same type as C2 or is a derived class of C2, T is an object\n  //    type or a function type, and CV1 and CV2 are cv-qualifier-seqs,\n  //    there exist candidate operator functions of the form\n  //\n  //      CV12 T& operator->*(CV1 C1*, CV2 T C2::*);\n  //\n  //    where CV12 is the union of CV1 and CV2.\n  void addArrowStarOverloads() {\n    for (QualType PtrTy : CandidateTypes[0].pointer_types()) {\n      QualType C1Ty = PtrTy;\n      QualType C1;\n      QualifierCollector Q1;\n      C1 = QualType(Q1.strip(C1Ty->getPointeeType()), 0);\n      if (!isa<RecordType>(C1))\n        continue;\n      // heuristic to reduce number of builtin candidates in the set.\n      // Add volatile/restrict version only if there are conversions to a\n      // volatile/restrict type.\n      if (!VisibleTypeConversionsQuals.hasVolatile() && Q1.hasVolatile())\n        continue;\n      if (!VisibleTypeConversionsQuals.hasRestrict() && Q1.hasRestrict())\n        continue;\n      for (QualType MemPtrTy : CandidateTypes[1].member_pointer_types()) {\n        const MemberPointerType *mptr = cast<MemberPointerType>(MemPtrTy);\n        QualType C2 = QualType(mptr->getClass(), 0);\n        C2 = C2.getUnqualifiedType();\n        if (C1 != C2 && !S.IsDerivedFrom(CandidateSet.getLocation(), C1, C2))\n          break;\n        QualType ParamTypes[2] = {PtrTy, MemPtrTy};\n        // build CV12 T&\n        QualType T = mptr->getPointeeType();\n        if (!VisibleTypeConversionsQuals.hasVolatile() &&\n            T.isVolatileQualified())\n          continue;\n        if (!VisibleTypeConversionsQuals.hasRestrict() &&\n            T.isRestrictQualified())\n          continue;\n        T = Q1.apply(S.Context, T);\n        S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);\n      }\n    }\n  }\n\n  // Note that we don't consider the first argument, since it has been\n  // contextually converted to bool long ago. The candidates below are\n  // therefore added as binary.\n  //\n  // C++ [over.built]p25:\n  //   For every type T, where T is a pointer, pointer-to-member, or scoped\n  //   enumeration type, there exist candidate operator functions of the form\n  //\n  //        T        operator?(bool, T, T);\n  //\n  void addConditionalOperatorOverloads() {\n    /// Set of (canonical) types that we've already handled.\n    llvm::SmallPtrSet<QualType, 8> AddedTypes;\n\n    for (unsigned ArgIdx = 0; ArgIdx < 2; ++ArgIdx) {\n      for (QualType PtrTy : CandidateTypes[ArgIdx].pointer_types()) {\n        if (!AddedTypes.insert(S.Context.getCanonicalType(PtrTy)).second)\n          continue;\n\n        QualType ParamTypes[2] = {PtrTy, PtrTy};\n        S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);\n      }\n\n      for (QualType MemPtrTy : CandidateTypes[ArgIdx].member_pointer_types()) {\n        if (!AddedTypes.insert(S.Context.getCanonicalType(MemPtrTy)).second)\n          continue;\n\n        QualType ParamTypes[2] = {MemPtrTy, MemPtrTy};\n        S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);\n      }\n\n      if (S.getLangOpts().CPlusPlus11) {\n        for (QualType EnumTy : CandidateTypes[ArgIdx].enumeration_types()) {\n          if (!EnumTy->castAs<EnumType>()->getDecl()->isScoped())\n            continue;\n\n          if (!AddedTypes.insert(S.Context.getCanonicalType(EnumTy)).second)\n            continue;\n\n          QualType ParamTypes[2] = {EnumTy, EnumTy};\n          S.AddBuiltinCandidate(ParamTypes, Args, CandidateSet);\n        }\n      }\n    }\n  }\n};\n\n} // end anonymous namespace\n\n/// AddBuiltinOperatorCandidates - Add the appropriate built-in\n/// operator overloads to the candidate set (C++ [over.built]), based\n/// on the operator @p Op and the arguments given. For example, if the\n/// operator is a binary '+', this routine might add \"int\n/// operator+(int, int)\" to cover integer addition.\nvoid Sema::AddBuiltinOperatorCandidates(OverloadedOperatorKind Op,\n                                        SourceLocation OpLoc,\n                                        ArrayRef<Expr *> Args,\n                                        OverloadCandidateSet &CandidateSet) {\n  // Find all of the types that the arguments can convert to, but only\n  // if the operator we're looking at has built-in operator candidates\n  // that make use of these types. Also record whether we encounter non-record\n  // candidate types or either arithmetic or enumeral candidate types.\n  Qualifiers VisibleTypeConversionsQuals;\n  VisibleTypeConversionsQuals.addConst();\n  for (unsigned ArgIdx = 0, N = Args.size(); ArgIdx != N; ++ArgIdx)\n    VisibleTypeConversionsQuals += CollectVRQualifiers(Context, Args[ArgIdx]);\n\n  bool HasNonRecordCandidateType = false;\n  bool HasArithmeticOrEnumeralCandidateType = false;\n  SmallVector<BuiltinCandidateTypeSet, 2> CandidateTypes;\n  for (unsigned ArgIdx = 0, N = Args.size(); ArgIdx != N; ++ArgIdx) {\n    CandidateTypes.emplace_back(*this);\n    CandidateTypes[ArgIdx].AddTypesConvertedFrom(Args[ArgIdx]->getType(),\n                                                 OpLoc,\n                                                 true,\n                                                 (Op == OO_Exclaim ||\n                                                  Op == OO_AmpAmp ||\n                                                  Op == OO_PipePipe),\n                                                 VisibleTypeConversionsQuals);\n    HasNonRecordCandidateType = HasNonRecordCandidateType ||\n        CandidateTypes[ArgIdx].hasNonRecordTypes();\n    HasArithmeticOrEnumeralCandidateType =\n        HasArithmeticOrEnumeralCandidateType ||\n        CandidateTypes[ArgIdx].hasArithmeticOrEnumeralTypes();\n  }\n\n  // Exit early when no non-record types have been added to the candidate set\n  // for any of the arguments to the operator.\n  //\n  // We can't exit early for !, ||, or &&, since there we have always have\n  // 'bool' overloads.\n  if (!HasNonRecordCandidateType &&\n      !(Op == OO_Exclaim || Op == OO_AmpAmp || Op == OO_PipePipe))\n    return;\n\n  // Setup an object to manage the common state for building overloads.\n  BuiltinOperatorOverloadBuilder OpBuilder(*this, Args,\n                                           VisibleTypeConversionsQuals,\n                                           HasArithmeticOrEnumeralCandidateType,\n                                           CandidateTypes, CandidateSet);\n\n  // Dispatch over the operation to add in only those overloads which apply.\n  switch (Op) {\n  case OO_None:\n  case NUM_OVERLOADED_OPERATORS:\n    llvm_unreachable(\"Expected an overloaded operator\");\n\n  case OO_New:\n  case OO_Delete:\n  case OO_Array_New:\n  case OO_Array_Delete:\n  case OO_Call:\n    llvm_unreachable(\n                    \"Special operators don't use AddBuiltinOperatorCandidates\");\n\n  case OO_Comma:\n  case OO_Arrow:\n  case OO_Coawait:\n    // C++ [over.match.oper]p3:\n    //   -- For the operator ',', the unary operator '&', the\n    //      operator '->', or the operator 'co_await', the\n    //      built-in candidates set is empty.\n    break;\n\n  case OO_Plus: // '+' is either unary or binary\n    if (Args.size() == 1)\n      OpBuilder.addUnaryPlusPointerOverloads();\n    LLVM_FALLTHROUGH;\n\n  case OO_Minus: // '-' is either unary or binary\n    if (Args.size() == 1) {\n      OpBuilder.addUnaryPlusOrMinusArithmeticOverloads();\n    } else {\n      OpBuilder.addBinaryPlusOrMinusPointerOverloads(Op);\n      OpBuilder.addGenericBinaryArithmeticOverloads();\n      OpBuilder.addMatrixBinaryArithmeticOverloads();\n    }\n    break;\n\n  case OO_Star: // '*' is either unary or binary\n    if (Args.size() == 1)\n      OpBuilder.addUnaryStarPointerOverloads();\n    else {\n      OpBuilder.addGenericBinaryArithmeticOverloads();\n      OpBuilder.addMatrixBinaryArithmeticOverloads();\n    }\n    break;\n\n  case OO_Slash:\n    OpBuilder.addGenericBinaryArithmeticOverloads();\n    break;\n\n  case OO_PlusPlus:\n  case OO_MinusMinus:\n    OpBuilder.addPlusPlusMinusMinusArithmeticOverloads(Op);\n    OpBuilder.addPlusPlusMinusMinusPointerOverloads();\n    break;\n\n  case OO_EqualEqual:\n  case OO_ExclaimEqual:\n    OpBuilder.addEqualEqualOrNotEqualMemberPointerOrNullptrOverloads();\n    LLVM_FALLTHROUGH;\n\n  case OO_Less:\n  case OO_Greater:\n  case OO_LessEqual:\n  case OO_GreaterEqual:\n    OpBuilder.addGenericBinaryPointerOrEnumeralOverloads();\n    OpBuilder.addGenericBinaryArithmeticOverloads();\n    break;\n\n  case OO_Spaceship:\n    OpBuilder.addGenericBinaryPointerOrEnumeralOverloads();\n    OpBuilder.addThreeWayArithmeticOverloads();\n    break;\n\n  case OO_Percent:\n  case OO_Caret:\n  case OO_Pipe:\n  case OO_LessLess:\n  case OO_GreaterGreater:\n    OpBuilder.addBinaryBitwiseArithmeticOverloads(Op);\n    break;\n\n  case OO_Amp: // '&' is either unary or binary\n    if (Args.size() == 1)\n      // C++ [over.match.oper]p3:\n      //   -- For the operator ',', the unary operator '&', or the\n      //      operator '->', the built-in candidates set is empty.\n      break;\n\n    OpBuilder.addBinaryBitwiseArithmeticOverloads(Op);\n    break;\n\n  case OO_Tilde:\n    OpBuilder.addUnaryTildePromotedIntegralOverloads();\n    break;\n\n  case OO_Equal:\n    OpBuilder.addAssignmentMemberPointerOrEnumeralOverloads();\n    LLVM_FALLTHROUGH;\n\n  case OO_PlusEqual:\n  case OO_MinusEqual:\n    OpBuilder.addAssignmentPointerOverloads(Op == OO_Equal);\n    LLVM_FALLTHROUGH;\n\n  case OO_StarEqual:\n  case OO_SlashEqual:\n    OpBuilder.addAssignmentArithmeticOverloads(Op == OO_Equal);\n    break;\n\n  case OO_PercentEqual:\n  case OO_LessLessEqual:\n  case OO_GreaterGreaterEqual:\n  case OO_AmpEqual:\n  case OO_CaretEqual:\n  case OO_PipeEqual:\n    OpBuilder.addAssignmentIntegralOverloads();\n    break;\n\n  case OO_Exclaim:\n    OpBuilder.addExclaimOverload();\n    break;\n\n  case OO_AmpAmp:\n  case OO_PipePipe:\n    OpBuilder.addAmpAmpOrPipePipeOverload();\n    break;\n\n  case OO_Subscript:\n    OpBuilder.addSubscriptOverloads();\n    break;\n\n  case OO_ArrowStar:\n    OpBuilder.addArrowStarOverloads();\n    break;\n\n  case OO_Conditional:\n    OpBuilder.addConditionalOperatorOverloads();\n    OpBuilder.addGenericBinaryArithmeticOverloads();\n    break;\n  }\n}\n\n/// Add function candidates found via argument-dependent lookup\n/// to the set of overloading candidates.\n///\n/// This routine performs argument-dependent name lookup based on the\n/// given function name (which may also be an operator name) and adds\n/// all of the overload candidates found by ADL to the overload\n/// candidate set (C++ [basic.lookup.argdep]).\nvoid\nSema::AddArgumentDependentLookupCandidates(DeclarationName Name,\n                                           SourceLocation Loc,\n                                           ArrayRef<Expr *> Args,\n                                 TemplateArgumentListInfo *ExplicitTemplateArgs,\n                                           OverloadCandidateSet& CandidateSet,\n                                           bool PartialOverloading) {\n  ADLResult Fns;\n\n  // FIXME: This approach for uniquing ADL results (and removing\n  // redundant candidates from the set) relies on pointer-equality,\n  // which means we need to key off the canonical decl.  However,\n  // always going back to the canonical decl might not get us the\n  // right set of default arguments.  What default arguments are\n  // we supposed to consider on ADL candidates, anyway?\n\n  // FIXME: Pass in the explicit template arguments?\n  ArgumentDependentLookup(Name, Loc, Args, Fns);\n\n  // Erase all of the candidates we already knew about.\n  for (OverloadCandidateSet::iterator Cand = CandidateSet.begin(),\n                                   CandEnd = CandidateSet.end();\n       Cand != CandEnd; ++Cand)\n    if (Cand->Function) {\n      Fns.erase(Cand->Function);\n      if (FunctionTemplateDecl *FunTmpl = Cand->Function->getPrimaryTemplate())\n        Fns.erase(FunTmpl);\n    }\n\n  // For each of the ADL candidates we found, add it to the overload\n  // set.\n  for (ADLResult::iterator I = Fns.begin(), E = Fns.end(); I != E; ++I) {\n    DeclAccessPair FoundDecl = DeclAccessPair::make(*I, AS_none);\n\n    if (FunctionDecl *FD = dyn_cast<FunctionDecl>(*I)) {\n      if (ExplicitTemplateArgs)\n        continue;\n\n      AddOverloadCandidate(\n          FD, FoundDecl, Args, CandidateSet, /*SuppressUserConversions=*/false,\n          PartialOverloading, /*AllowExplicit=*/true,\n          /*AllowExplicitConversions=*/false, ADLCallKind::UsesADL);\n      if (CandidateSet.getRewriteInfo().shouldAddReversed(Context, FD)) {\n        AddOverloadCandidate(\n            FD, FoundDecl, {Args[1], Args[0]}, CandidateSet,\n            /*SuppressUserConversions=*/false, PartialOverloading,\n            /*AllowExplicit=*/true, /*AllowExplicitConversions=*/false,\n            ADLCallKind::UsesADL, None, OverloadCandidateParamOrder::Reversed);\n      }\n    } else {\n      auto *FTD = cast<FunctionTemplateDecl>(*I);\n      AddTemplateOverloadCandidate(\n          FTD, FoundDecl, ExplicitTemplateArgs, Args, CandidateSet,\n          /*SuppressUserConversions=*/false, PartialOverloading,\n          /*AllowExplicit=*/true, ADLCallKind::UsesADL);\n      if (CandidateSet.getRewriteInfo().shouldAddReversed(\n              Context, FTD->getTemplatedDecl())) {\n        AddTemplateOverloadCandidate(\n            FTD, FoundDecl, ExplicitTemplateArgs, {Args[1], Args[0]},\n            CandidateSet, /*SuppressUserConversions=*/false, PartialOverloading,\n            /*AllowExplicit=*/true, ADLCallKind::UsesADL,\n            OverloadCandidateParamOrder::Reversed);\n      }\n    }\n  }\n}\n\nnamespace {\nenum class Comparison { Equal, Better, Worse };\n}\n\n/// Compares the enable_if attributes of two FunctionDecls, for the purposes of\n/// overload resolution.\n///\n/// Cand1's set of enable_if attributes are said to be \"better\" than Cand2's iff\n/// Cand1's first N enable_if attributes have precisely the same conditions as\n/// Cand2's first N enable_if attributes (where N = the number of enable_if\n/// attributes on Cand2), and Cand1 has more than N enable_if attributes.\n///\n/// Note that you can have a pair of candidates such that Cand1's enable_if\n/// attributes are worse than Cand2's, and Cand2's enable_if attributes are\n/// worse than Cand1's.\nstatic Comparison compareEnableIfAttrs(const Sema &S, const FunctionDecl *Cand1,\n                                       const FunctionDecl *Cand2) {\n  // Common case: One (or both) decls don't have enable_if attrs.\n  bool Cand1Attr = Cand1->hasAttr<EnableIfAttr>();\n  bool Cand2Attr = Cand2->hasAttr<EnableIfAttr>();\n  if (!Cand1Attr || !Cand2Attr) {\n    if (Cand1Attr == Cand2Attr)\n      return Comparison::Equal;\n    return Cand1Attr ? Comparison::Better : Comparison::Worse;\n  }\n\n  auto Cand1Attrs = Cand1->specific_attrs<EnableIfAttr>();\n  auto Cand2Attrs = Cand2->specific_attrs<EnableIfAttr>();\n\n  llvm::FoldingSetNodeID Cand1ID, Cand2ID;\n  for (auto Pair : zip_longest(Cand1Attrs, Cand2Attrs)) {\n    Optional<EnableIfAttr *> Cand1A = std::get<0>(Pair);\n    Optional<EnableIfAttr *> Cand2A = std::get<1>(Pair);\n\n    // It's impossible for Cand1 to be better than (or equal to) Cand2 if Cand1\n    // has fewer enable_if attributes than Cand2, and vice versa.\n    if (!Cand1A)\n      return Comparison::Worse;\n    if (!Cand2A)\n      return Comparison::Better;\n\n    Cand1ID.clear();\n    Cand2ID.clear();\n\n    (*Cand1A)->getCond()->Profile(Cand1ID, S.getASTContext(), true);\n    (*Cand2A)->getCond()->Profile(Cand2ID, S.getASTContext(), true);\n    if (Cand1ID != Cand2ID)\n      return Comparison::Worse;\n  }\n\n  return Comparison::Equal;\n}\n\nstatic Comparison\nisBetterMultiversionCandidate(const OverloadCandidate &Cand1,\n                              const OverloadCandidate &Cand2) {\n  if (!Cand1.Function || !Cand1.Function->isMultiVersion() || !Cand2.Function ||\n      !Cand2.Function->isMultiVersion())\n    return Comparison::Equal;\n\n  // If both are invalid, they are equal. If one of them is invalid, the other\n  // is better.\n  if (Cand1.Function->isInvalidDecl()) {\n    if (Cand2.Function->isInvalidDecl())\n      return Comparison::Equal;\n    return Comparison::Worse;\n  }\n  if (Cand2.Function->isInvalidDecl())\n    return Comparison::Better;\n\n  // If this is a cpu_dispatch/cpu_specific multiversion situation, prefer\n  // cpu_dispatch, else arbitrarily based on the identifiers.\n  bool Cand1CPUDisp = Cand1.Function->hasAttr<CPUDispatchAttr>();\n  bool Cand2CPUDisp = Cand2.Function->hasAttr<CPUDispatchAttr>();\n  const auto *Cand1CPUSpec = Cand1.Function->getAttr<CPUSpecificAttr>();\n  const auto *Cand2CPUSpec = Cand2.Function->getAttr<CPUSpecificAttr>();\n\n  if (!Cand1CPUDisp && !Cand2CPUDisp && !Cand1CPUSpec && !Cand2CPUSpec)\n    return Comparison::Equal;\n\n  if (Cand1CPUDisp && !Cand2CPUDisp)\n    return Comparison::Better;\n  if (Cand2CPUDisp && !Cand1CPUDisp)\n    return Comparison::Worse;\n\n  if (Cand1CPUSpec && Cand2CPUSpec) {\n    if (Cand1CPUSpec->cpus_size() != Cand2CPUSpec->cpus_size())\n      return Cand1CPUSpec->cpus_size() < Cand2CPUSpec->cpus_size()\n                 ? Comparison::Better\n                 : Comparison::Worse;\n\n    std::pair<CPUSpecificAttr::cpus_iterator, CPUSpecificAttr::cpus_iterator>\n        FirstDiff = std::mismatch(\n            Cand1CPUSpec->cpus_begin(), Cand1CPUSpec->cpus_end(),\n            Cand2CPUSpec->cpus_begin(),\n            [](const IdentifierInfo *LHS, const IdentifierInfo *RHS) {\n              return LHS->getName() == RHS->getName();\n            });\n\n    assert(FirstDiff.first != Cand1CPUSpec->cpus_end() &&\n           \"Two different cpu-specific versions should not have the same \"\n           \"identifier list, otherwise they'd be the same decl!\");\n    return (*FirstDiff.first)->getName() < (*FirstDiff.second)->getName()\n               ? Comparison::Better\n               : Comparison::Worse;\n  }\n  llvm_unreachable(\"No way to get here unless both had cpu_dispatch\");\n}\n\n/// Compute the type of the implicit object parameter for the given function,\n/// if any. Returns None if there is no implicit object parameter, and a null\n/// QualType if there is a 'matches anything' implicit object parameter.\nstatic Optional<QualType> getImplicitObjectParamType(ASTContext &Context,\n                                                     const FunctionDecl *F) {\n  if (!isa<CXXMethodDecl>(F) || isa<CXXConstructorDecl>(F))\n    return llvm::None;\n\n  auto *M = cast<CXXMethodDecl>(F);\n  // Static member functions' object parameters match all types.\n  if (M->isStatic())\n    return QualType();\n\n  QualType T = M->getThisObjectType();\n  if (M->getRefQualifier() == RQ_RValue)\n    return Context.getRValueReferenceType(T);\n  return Context.getLValueReferenceType(T);\n}\n\nstatic bool haveSameParameterTypes(ASTContext &Context, const FunctionDecl *F1,\n                                   const FunctionDecl *F2, unsigned NumParams) {\n  if (declaresSameEntity(F1, F2))\n    return true;\n\n  auto NextParam = [&](const FunctionDecl *F, unsigned &I, bool First) {\n    if (First) {\n      if (Optional<QualType> T = getImplicitObjectParamType(Context, F))\n        return *T;\n    }\n    assert(I < F->getNumParams());\n    return F->getParamDecl(I++)->getType();\n  };\n\n  unsigned I1 = 0, I2 = 0;\n  for (unsigned I = 0; I != NumParams; ++I) {\n    QualType T1 = NextParam(F1, I1, I == 0);\n    QualType T2 = NextParam(F2, I2, I == 0);\n    if (!T1.isNull() && !T1.isNull() && !Context.hasSameUnqualifiedType(T1, T2))\n      return false;\n  }\n  return true;\n}\n\n/// isBetterOverloadCandidate - Determines whether the first overload\n/// candidate is a better candidate than the second (C++ 13.3.3p1).\nbool clang::isBetterOverloadCandidate(\n    Sema &S, const OverloadCandidate &Cand1, const OverloadCandidate &Cand2,\n    SourceLocation Loc, OverloadCandidateSet::CandidateSetKind Kind) {\n  // Define viable functions to be better candidates than non-viable\n  // functions.\n  if (!Cand2.Viable)\n    return Cand1.Viable;\n  else if (!Cand1.Viable)\n    return false;\n\n  // [CUDA] A function with 'never' preference is marked not viable, therefore\n  // is never shown up here. The worst preference shown up here is 'wrong side',\n  // e.g. an H function called by a HD function in device compilation. This is\n  // valid AST as long as the HD function is not emitted, e.g. it is an inline\n  // function which is called only by an H function. A deferred diagnostic will\n  // be triggered if it is emitted. However a wrong-sided function is still\n  // a viable candidate here.\n  //\n  // If Cand1 can be emitted and Cand2 cannot be emitted in the current\n  // context, Cand1 is better than Cand2. If Cand1 can not be emitted and Cand2\n  // can be emitted, Cand1 is not better than Cand2. This rule should have\n  // precedence over other rules.\n  //\n  // If both Cand1 and Cand2 can be emitted, or neither can be emitted, then\n  // other rules should be used to determine which is better. This is because\n  // host/device based overloading resolution is mostly for determining\n  // viability of a function. If two functions are both viable, other factors\n  // should take precedence in preference, e.g. the standard-defined preferences\n  // like argument conversion ranks or enable_if partial-ordering. The\n  // preference for pass-object-size parameters is probably most similar to a\n  // type-based-overloading decision and so should take priority.\n  //\n  // If other rules cannot determine which is better, CUDA preference will be\n  // used again to determine which is better.\n  //\n  // TODO: Currently IdentifyCUDAPreference does not return correct values\n  // for functions called in global variable initializers due to missing\n  // correct context about device/host. Therefore we can only enforce this\n  // rule when there is a caller. We should enforce this rule for functions\n  // in global variable initializers once proper context is added.\n  //\n  // TODO: We can only enable the hostness based overloading resolution when\n  // -fgpu-exclude-wrong-side-overloads is on since this requires deferring\n  // overloading resolution diagnostics.\n  if (S.getLangOpts().CUDA && Cand1.Function && Cand2.Function &&\n      S.getLangOpts().GPUExcludeWrongSideOverloads) {\n    if (FunctionDecl *Caller = dyn_cast<FunctionDecl>(S.CurContext)) {\n      bool IsCallerImplicitHD = Sema::isCUDAImplicitHostDeviceFunction(Caller);\n      bool IsCand1ImplicitHD =\n          Sema::isCUDAImplicitHostDeviceFunction(Cand1.Function);\n      bool IsCand2ImplicitHD =\n          Sema::isCUDAImplicitHostDeviceFunction(Cand2.Function);\n      auto P1 = S.IdentifyCUDAPreference(Caller, Cand1.Function);\n      auto P2 = S.IdentifyCUDAPreference(Caller, Cand2.Function);\n      assert(P1 != Sema::CFP_Never && P2 != Sema::CFP_Never);\n      // The implicit HD function may be a function in a system header which\n      // is forced by pragma. In device compilation, if we prefer HD candidates\n      // over wrong-sided candidates, overloading resolution may change, which\n      // may result in non-deferrable diagnostics. As a workaround, we let\n      // implicit HD candidates take equal preference as wrong-sided candidates.\n      // This will preserve the overloading resolution.\n      // TODO: We still need special handling of implicit HD functions since\n      // they may incur other diagnostics to be deferred. We should make all\n      // host/device related diagnostics deferrable and remove special handling\n      // of implicit HD functions.\n      auto EmitThreshold =\n          (S.getLangOpts().CUDAIsDevice && IsCallerImplicitHD &&\n           (IsCand1ImplicitHD || IsCand2ImplicitHD))\n              ? Sema::CFP_Never\n              : Sema::CFP_WrongSide;\n      auto Cand1Emittable = P1 > EmitThreshold;\n      auto Cand2Emittable = P2 > EmitThreshold;\n      if (Cand1Emittable && !Cand2Emittable)\n        return true;\n      if (!Cand1Emittable && Cand2Emittable)\n        return false;\n    }\n  }\n\n  // C++ [over.match.best]p1:\n  //\n  //   -- if F is a static member function, ICS1(F) is defined such\n  //      that ICS1(F) is neither better nor worse than ICS1(G) for\n  //      any function G, and, symmetrically, ICS1(G) is neither\n  //      better nor worse than ICS1(F).\n  unsigned StartArg = 0;\n  if (Cand1.IgnoreObjectArgument || Cand2.IgnoreObjectArgument)\n    StartArg = 1;\n\n  auto IsIllFormedConversion = [&](const ImplicitConversionSequence &ICS) {\n    // We don't allow incompatible pointer conversions in C++.\n    if (!S.getLangOpts().CPlusPlus)\n      return ICS.isStandard() &&\n             ICS.Standard.Second == ICK_Incompatible_Pointer_Conversion;\n\n    // The only ill-formed conversion we allow in C++ is the string literal to\n    // char* conversion, which is only considered ill-formed after C++11.\n    return S.getLangOpts().CPlusPlus11 && !S.getLangOpts().WritableStrings &&\n           hasDeprecatedStringLiteralToCharPtrConversion(ICS);\n  };\n\n  // Define functions that don't require ill-formed conversions for a given\n  // argument to be better candidates than functions that do.\n  unsigned NumArgs = Cand1.Conversions.size();\n  assert(Cand2.Conversions.size() == NumArgs && \"Overload candidate mismatch\");\n  bool HasBetterConversion = false;\n  for (unsigned ArgIdx = StartArg; ArgIdx < NumArgs; ++ArgIdx) {\n    bool Cand1Bad = IsIllFormedConversion(Cand1.Conversions[ArgIdx]);\n    bool Cand2Bad = IsIllFormedConversion(Cand2.Conversions[ArgIdx]);\n    if (Cand1Bad != Cand2Bad) {\n      if (Cand1Bad)\n        return false;\n      HasBetterConversion = true;\n    }\n  }\n\n  if (HasBetterConversion)\n    return true;\n\n  // C++ [over.match.best]p1:\n  //   A viable function F1 is defined to be a better function than another\n  //   viable function F2 if for all arguments i, ICSi(F1) is not a worse\n  //   conversion sequence than ICSi(F2), and then...\n  bool HasWorseConversion = false;\n  for (unsigned ArgIdx = StartArg; ArgIdx < NumArgs; ++ArgIdx) {\n    switch (CompareImplicitConversionSequences(S, Loc,\n                                               Cand1.Conversions[ArgIdx],\n                                               Cand2.Conversions[ArgIdx])) {\n    case ImplicitConversionSequence::Better:\n      // Cand1 has a better conversion sequence.\n      HasBetterConversion = true;\n      break;\n\n    case ImplicitConversionSequence::Worse:\n      if (Cand1.Function && Cand2.Function &&\n          Cand1.isReversed() != Cand2.isReversed() &&\n          haveSameParameterTypes(S.Context, Cand1.Function, Cand2.Function,\n                                 NumArgs)) {\n        // Work around large-scale breakage caused by considering reversed\n        // forms of operator== in C++20:\n        //\n        // When comparing a function against a reversed function with the same\n        // parameter types, if we have a better conversion for one argument and\n        // a worse conversion for the other, the implicit conversion sequences\n        // are treated as being equally good.\n        //\n        // This prevents a comparison function from being considered ambiguous\n        // with a reversed form that is written in the same way.\n        //\n        // We diagnose this as an extension from CreateOverloadedBinOp.\n        HasWorseConversion = true;\n        break;\n      }\n\n      // Cand1 can't be better than Cand2.\n      return false;\n\n    case ImplicitConversionSequence::Indistinguishable:\n      // Do nothing.\n      break;\n    }\n  }\n\n  //    -- for some argument j, ICSj(F1) is a better conversion sequence than\n  //       ICSj(F2), or, if not that,\n  if (HasBetterConversion && !HasWorseConversion)\n    return true;\n\n  //   -- the context is an initialization by user-defined conversion\n  //      (see 8.5, 13.3.1.5) and the standard conversion sequence\n  //      from the return type of F1 to the destination type (i.e.,\n  //      the type of the entity being initialized) is a better\n  //      conversion sequence than the standard conversion sequence\n  //      from the return type of F2 to the destination type.\n  if (Kind == OverloadCandidateSet::CSK_InitByUserDefinedConversion &&\n      Cand1.Function && Cand2.Function &&\n      isa<CXXConversionDecl>(Cand1.Function) &&\n      isa<CXXConversionDecl>(Cand2.Function)) {\n    // First check whether we prefer one of the conversion functions over the\n    // other. This only distinguishes the results in non-standard, extension\n    // cases such as the conversion from a lambda closure type to a function\n    // pointer or block.\n    ImplicitConversionSequence::CompareKind Result =\n        compareConversionFunctions(S, Cand1.Function, Cand2.Function);\n    if (Result == ImplicitConversionSequence::Indistinguishable)\n      Result = CompareStandardConversionSequences(S, Loc,\n                                                  Cand1.FinalConversion,\n                                                  Cand2.FinalConversion);\n\n    if (Result != ImplicitConversionSequence::Indistinguishable)\n      return Result == ImplicitConversionSequence::Better;\n\n    // FIXME: Compare kind of reference binding if conversion functions\n    // convert to a reference type used in direct reference binding, per\n    // C++14 [over.match.best]p1 section 2 bullet 3.\n  }\n\n  // FIXME: Work around a defect in the C++17 guaranteed copy elision wording,\n  // as combined with the resolution to CWG issue 243.\n  //\n  // When the context is initialization by constructor ([over.match.ctor] or\n  // either phase of [over.match.list]), a constructor is preferred over\n  // a conversion function.\n  if (Kind == OverloadCandidateSet::CSK_InitByConstructor && NumArgs == 1 &&\n      Cand1.Function && Cand2.Function &&\n      isa<CXXConstructorDecl>(Cand1.Function) !=\n          isa<CXXConstructorDecl>(Cand2.Function))\n    return isa<CXXConstructorDecl>(Cand1.Function);\n\n  //    -- F1 is a non-template function and F2 is a function template\n  //       specialization, or, if not that,\n  bool Cand1IsSpecialization = Cand1.Function &&\n                               Cand1.Function->getPrimaryTemplate();\n  bool Cand2IsSpecialization = Cand2.Function &&\n                               Cand2.Function->getPrimaryTemplate();\n  if (Cand1IsSpecialization != Cand2IsSpecialization)\n    return Cand2IsSpecialization;\n\n  //   -- F1 and F2 are function template specializations, and the function\n  //      template for F1 is more specialized than the template for F2\n  //      according to the partial ordering rules described in 14.5.5.2, or,\n  //      if not that,\n  if (Cand1IsSpecialization && Cand2IsSpecialization) {\n    if (FunctionTemplateDecl *BetterTemplate = S.getMoreSpecializedTemplate(\n            Cand1.Function->getPrimaryTemplate(),\n            Cand2.Function->getPrimaryTemplate(), Loc,\n            isa<CXXConversionDecl>(Cand1.Function) ? TPOC_Conversion\n                                                   : TPOC_Call,\n            Cand1.ExplicitCallArguments, Cand2.ExplicitCallArguments,\n            Cand1.isReversed() ^ Cand2.isReversed()))\n      return BetterTemplate == Cand1.Function->getPrimaryTemplate();\n  }\n\n  //   -\u2014 F1 and F2 are non-template functions with the same\n  //      parameter-type-lists, and F1 is more constrained than F2 [...],\n  if (Cand1.Function && Cand2.Function && !Cand1IsSpecialization &&\n      !Cand2IsSpecialization && Cand1.Function->hasPrototype() &&\n      Cand2.Function->hasPrototype()) {\n    auto *PT1 = cast<FunctionProtoType>(Cand1.Function->getFunctionType());\n    auto *PT2 = cast<FunctionProtoType>(Cand2.Function->getFunctionType());\n    if (PT1->getNumParams() == PT2->getNumParams() &&\n        PT1->isVariadic() == PT2->isVariadic() &&\n        S.FunctionParamTypesAreEqual(PT1, PT2)) {\n      Expr *RC1 = Cand1.Function->getTrailingRequiresClause();\n      Expr *RC2 = Cand2.Function->getTrailingRequiresClause();\n      if (RC1 && RC2) {\n        bool AtLeastAsConstrained1, AtLeastAsConstrained2;\n        if (S.IsAtLeastAsConstrained(Cand1.Function, {RC1}, Cand2.Function,\n                                     {RC2}, AtLeastAsConstrained1) ||\n            S.IsAtLeastAsConstrained(Cand2.Function, {RC2}, Cand1.Function,\n                                     {RC1}, AtLeastAsConstrained2))\n          return false;\n        if (AtLeastAsConstrained1 != AtLeastAsConstrained2)\n          return AtLeastAsConstrained1;\n      } else if (RC1 || RC2) {\n        return RC1 != nullptr;\n      }\n    }\n  }\n\n  //   -- F1 is a constructor for a class D, F2 is a constructor for a base\n  //      class B of D, and for all arguments the corresponding parameters of\n  //      F1 and F2 have the same type.\n  // FIXME: Implement the \"all parameters have the same type\" check.\n  bool Cand1IsInherited =\n      dyn_cast_or_null<ConstructorUsingShadowDecl>(Cand1.FoundDecl.getDecl());\n  bool Cand2IsInherited =\n      dyn_cast_or_null<ConstructorUsingShadowDecl>(Cand2.FoundDecl.getDecl());\n  if (Cand1IsInherited != Cand2IsInherited)\n    return Cand2IsInherited;\n  else if (Cand1IsInherited) {\n    assert(Cand2IsInherited);\n    auto *Cand1Class = cast<CXXRecordDecl>(Cand1.Function->getDeclContext());\n    auto *Cand2Class = cast<CXXRecordDecl>(Cand2.Function->getDeclContext());\n    if (Cand1Class->isDerivedFrom(Cand2Class))\n      return true;\n    if (Cand2Class->isDerivedFrom(Cand1Class))\n      return false;\n    // Inherited from sibling base classes: still ambiguous.\n  }\n\n  //   -- F2 is a rewritten candidate (12.4.1.2) and F1 is not\n  //   -- F1 and F2 are rewritten candidates, and F2 is a synthesized candidate\n  //      with reversed order of parameters and F1 is not\n  //\n  // We rank reversed + different operator as worse than just reversed, but\n  // that comparison can never happen, because we only consider reversing for\n  // the maximally-rewritten operator (== or <=>).\n  if (Cand1.RewriteKind != Cand2.RewriteKind)\n    return Cand1.RewriteKind < Cand2.RewriteKind;\n\n  // Check C++17 tie-breakers for deduction guides.\n  {\n    auto *Guide1 = dyn_cast_or_null<CXXDeductionGuideDecl>(Cand1.Function);\n    auto *Guide2 = dyn_cast_or_null<CXXDeductionGuideDecl>(Cand2.Function);\n    if (Guide1 && Guide2) {\n      //  -- F1 is generated from a deduction-guide and F2 is not\n      if (Guide1->isImplicit() != Guide2->isImplicit())\n        return Guide2->isImplicit();\n\n      //  -- F1 is the copy deduction candidate(16.3.1.8) and F2 is not\n      if (Guide1->isCopyDeductionCandidate())\n        return true;\n    }\n  }\n\n  // Check for enable_if value-based overload resolution.\n  if (Cand1.Function && Cand2.Function) {\n    Comparison Cmp = compareEnableIfAttrs(S, Cand1.Function, Cand2.Function);\n    if (Cmp != Comparison::Equal)\n      return Cmp == Comparison::Better;\n  }\n\n  bool HasPS1 = Cand1.Function != nullptr &&\n                functionHasPassObjectSizeParams(Cand1.Function);\n  bool HasPS2 = Cand2.Function != nullptr &&\n                functionHasPassObjectSizeParams(Cand2.Function);\n  if (HasPS1 != HasPS2 && HasPS1)\n    return true;\n\n  auto MV = isBetterMultiversionCandidate(Cand1, Cand2);\n  if (MV == Comparison::Better)\n    return true;\n  if (MV == Comparison::Worse)\n    return false;\n\n  // If other rules cannot determine which is better, CUDA preference is used\n  // to determine which is better.\n  if (S.getLangOpts().CUDA && Cand1.Function && Cand2.Function) {\n    FunctionDecl *Caller = dyn_cast<FunctionDecl>(S.CurContext);\n    return S.IdentifyCUDAPreference(Caller, Cand1.Function) >\n           S.IdentifyCUDAPreference(Caller, Cand2.Function);\n  }\n\n  return false;\n}\n\n/// Determine whether two declarations are \"equivalent\" for the purposes of\n/// name lookup and overload resolution. This applies when the same internal/no\n/// linkage entity is defined by two modules (probably by textually including\n/// the same header). In such a case, we don't consider the declarations to\n/// declare the same entity, but we also don't want lookups with both\n/// declarations visible to be ambiguous in some cases (this happens when using\n/// a modularized libstdc++).\nbool Sema::isEquivalentInternalLinkageDeclaration(const NamedDecl *A,\n                                                  const NamedDecl *B) {\n  auto *VA = dyn_cast_or_null<ValueDecl>(A);\n  auto *VB = dyn_cast_or_null<ValueDecl>(B);\n  if (!VA || !VB)\n    return false;\n\n  // The declarations must be declaring the same name as an internal linkage\n  // entity in different modules.\n  if (!VA->getDeclContext()->getRedeclContext()->Equals(\n          VB->getDeclContext()->getRedeclContext()) ||\n      getOwningModule(VA) == getOwningModule(VB) ||\n      VA->isExternallyVisible() || VB->isExternallyVisible())\n    return false;\n\n  // Check that the declarations appear to be equivalent.\n  //\n  // FIXME: Checking the type isn't really enough to resolve the ambiguity.\n  // For constants and functions, we should check the initializer or body is\n  // the same. For non-constant variables, we shouldn't allow it at all.\n  if (Context.hasSameType(VA->getType(), VB->getType()))\n    return true;\n\n  // Enum constants within unnamed enumerations will have different types, but\n  // may still be similar enough to be interchangeable for our purposes.\n  if (auto *EA = dyn_cast<EnumConstantDecl>(VA)) {\n    if (auto *EB = dyn_cast<EnumConstantDecl>(VB)) {\n      // Only handle anonymous enums. If the enumerations were named and\n      // equivalent, they would have been merged to the same type.\n      auto *EnumA = cast<EnumDecl>(EA->getDeclContext());\n      auto *EnumB = cast<EnumDecl>(EB->getDeclContext());\n      if (EnumA->hasNameForLinkage() || EnumB->hasNameForLinkage() ||\n          !Context.hasSameType(EnumA->getIntegerType(),\n                               EnumB->getIntegerType()))\n        return false;\n      // Allow this only if the value is the same for both enumerators.\n      return llvm::APSInt::isSameValue(EA->getInitVal(), EB->getInitVal());\n    }\n  }\n\n  // Nothing else is sufficiently similar.\n  return false;\n}\n\nvoid Sema::diagnoseEquivalentInternalLinkageDeclarations(\n    SourceLocation Loc, const NamedDecl *D, ArrayRef<const NamedDecl *> Equiv) {\n  assert(D && \"Unknown declaration\");\n  Diag(Loc, diag::ext_equivalent_internal_linkage_decl_in_modules) << D;\n\n  Module *M = getOwningModule(D);\n  Diag(D->getLocation(), diag::note_equivalent_internal_linkage_decl)\n      << !M << (M ? M->getFullModuleName() : \"\");\n\n  for (auto *E : Equiv) {\n    Module *M = getOwningModule(E);\n    Diag(E->getLocation(), diag::note_equivalent_internal_linkage_decl)\n        << !M << (M ? M->getFullModuleName() : \"\");\n  }\n}\n\n/// Computes the best viable function (C++ 13.3.3)\n/// within an overload candidate set.\n///\n/// \\param Loc The location of the function name (or operator symbol) for\n/// which overload resolution occurs.\n///\n/// \\param Best If overload resolution was successful or found a deleted\n/// function, \\p Best points to the candidate function found.\n///\n/// \\returns The result of overload resolution.\nOverloadingResult\nOverloadCandidateSet::BestViableFunction(Sema &S, SourceLocation Loc,\n                                         iterator &Best) {\n  llvm::SmallVector<OverloadCandidate *, 16> Candidates;\n  std::transform(begin(), end(), std::back_inserter(Candidates),\n                 [](OverloadCandidate &Cand) { return &Cand; });\n\n  // [CUDA] HD->H or HD->D calls are technically not allowed by CUDA but\n  // are accepted by both clang and NVCC. However, during a particular\n  // compilation mode only one call variant is viable. We need to\n  // exclude non-viable overload candidates from consideration based\n  // only on their host/device attributes. Specifically, if one\n  // candidate call is WrongSide and the other is SameSide, we ignore\n  // the WrongSide candidate.\n  // We only need to remove wrong-sided candidates here if\n  // -fgpu-exclude-wrong-side-overloads is off. When\n  // -fgpu-exclude-wrong-side-overloads is on, all candidates are compared\n  // uniformly in isBetterOverloadCandidate.\n  if (S.getLangOpts().CUDA && !S.getLangOpts().GPUExcludeWrongSideOverloads) {\n    const FunctionDecl *Caller = dyn_cast<FunctionDecl>(S.CurContext);\n    bool ContainsSameSideCandidate =\n        llvm::any_of(Candidates, [&](OverloadCandidate *Cand) {\n          // Check viable function only.\n          return Cand->Viable && Cand->Function &&\n                 S.IdentifyCUDAPreference(Caller, Cand->Function) ==\n                     Sema::CFP_SameSide;\n        });\n    if (ContainsSameSideCandidate) {\n      auto IsWrongSideCandidate = [&](OverloadCandidate *Cand) {\n        // Check viable function only to avoid unnecessary data copying/moving.\n        return Cand->Viable && Cand->Function &&\n               S.IdentifyCUDAPreference(Caller, Cand->Function) ==\n                   Sema::CFP_WrongSide;\n      };\n      llvm::erase_if(Candidates, IsWrongSideCandidate);\n    }\n  }\n\n  // Find the best viable function.\n  Best = end();\n  for (auto *Cand : Candidates) {\n    Cand->Best = false;\n    if (Cand->Viable)\n      if (Best == end() ||\n          isBetterOverloadCandidate(S, *Cand, *Best, Loc, Kind))\n        Best = Cand;\n  }\n\n  // If we didn't find any viable functions, abort.\n  if (Best == end())\n    return OR_No_Viable_Function;\n\n  llvm::SmallVector<const NamedDecl *, 4> EquivalentCands;\n\n  llvm::SmallVector<OverloadCandidate*, 4> PendingBest;\n  PendingBest.push_back(&*Best);\n  Best->Best = true;\n\n  // Make sure that this function is better than every other viable\n  // function. If not, we have an ambiguity.\n  while (!PendingBest.empty()) {\n    auto *Curr = PendingBest.pop_back_val();\n    for (auto *Cand : Candidates) {\n      if (Cand->Viable && !Cand->Best &&\n          !isBetterOverloadCandidate(S, *Curr, *Cand, Loc, Kind)) {\n        PendingBest.push_back(Cand);\n        Cand->Best = true;\n\n        if (S.isEquivalentInternalLinkageDeclaration(Cand->Function,\n                                                     Curr->Function))\n          EquivalentCands.push_back(Cand->Function);\n        else\n          Best = end();\n      }\n    }\n  }\n\n  // If we found more than one best candidate, this is ambiguous.\n  if (Best == end())\n    return OR_Ambiguous;\n\n  // Best is the best viable function.\n  if (Best->Function && Best->Function->isDeleted())\n    return OR_Deleted;\n\n  if (!EquivalentCands.empty())\n    S.diagnoseEquivalentInternalLinkageDeclarations(Loc, Best->Function,\n                                                    EquivalentCands);\n\n  return OR_Success;\n}\n\nnamespace {\n\nenum OverloadCandidateKind {\n  oc_function,\n  oc_method,\n  oc_reversed_binary_operator,\n  oc_constructor,\n  oc_implicit_default_constructor,\n  oc_implicit_copy_constructor,\n  oc_implicit_move_constructor,\n  oc_implicit_copy_assignment,\n  oc_implicit_move_assignment,\n  oc_implicit_equality_comparison,\n  oc_inherited_constructor\n};\n\nenum OverloadCandidateSelect {\n  ocs_non_template,\n  ocs_template,\n  ocs_described_template,\n};\n\nstatic std::pair<OverloadCandidateKind, OverloadCandidateSelect>\nClassifyOverloadCandidate(Sema &S, NamedDecl *Found, FunctionDecl *Fn,\n                          OverloadCandidateRewriteKind CRK,\n                          std::string &Description) {\n\n  bool isTemplate = Fn->isTemplateDecl() || Found->isTemplateDecl();\n  if (FunctionTemplateDecl *FunTmpl = Fn->getPrimaryTemplate()) {\n    isTemplate = true;\n    Description = S.getTemplateArgumentBindingsText(\n        FunTmpl->getTemplateParameters(), *Fn->getTemplateSpecializationArgs());\n  }\n\n  OverloadCandidateSelect Select = [&]() {\n    if (!Description.empty())\n      return ocs_described_template;\n    return isTemplate ? ocs_template : ocs_non_template;\n  }();\n\n  OverloadCandidateKind Kind = [&]() {\n    if (Fn->isImplicit() && Fn->getOverloadedOperator() == OO_EqualEqual)\n      return oc_implicit_equality_comparison;\n\n    if (CRK & CRK_Reversed)\n      return oc_reversed_binary_operator;\n\n    if (CXXConstructorDecl *Ctor = dyn_cast<CXXConstructorDecl>(Fn)) {\n      if (!Ctor->isImplicit()) {\n        if (isa<ConstructorUsingShadowDecl>(Found))\n          return oc_inherited_constructor;\n        else\n          return oc_constructor;\n      }\n\n      if (Ctor->isDefaultConstructor())\n        return oc_implicit_default_constructor;\n\n      if (Ctor->isMoveConstructor())\n        return oc_implicit_move_constructor;\n\n      assert(Ctor->isCopyConstructor() &&\n             \"unexpected sort of implicit constructor\");\n      return oc_implicit_copy_constructor;\n    }\n\n    if (CXXMethodDecl *Meth = dyn_cast<CXXMethodDecl>(Fn)) {\n      // This actually gets spelled 'candidate function' for now, but\n      // it doesn't hurt to split it out.\n      if (!Meth->isImplicit())\n        return oc_method;\n\n      if (Meth->isMoveAssignmentOperator())\n        return oc_implicit_move_assignment;\n\n      if (Meth->isCopyAssignmentOperator())\n        return oc_implicit_copy_assignment;\n\n      assert(isa<CXXConversionDecl>(Meth) && \"expected conversion\");\n      return oc_method;\n    }\n\n    return oc_function;\n  }();\n\n  return std::make_pair(Kind, Select);\n}\n\nvoid MaybeEmitInheritedConstructorNote(Sema &S, Decl *FoundDecl) {\n  // FIXME: It'd be nice to only emit a note once per using-decl per overload\n  // set.\n  if (auto *Shadow = dyn_cast<ConstructorUsingShadowDecl>(FoundDecl))\n    S.Diag(FoundDecl->getLocation(),\n           diag::note_ovl_candidate_inherited_constructor)\n      << Shadow->getNominatedBaseClass();\n}\n\n} // end anonymous namespace\n\nstatic bool isFunctionAlwaysEnabled(const ASTContext &Ctx,\n                                    const FunctionDecl *FD) {\n  for (auto *EnableIf : FD->specific_attrs<EnableIfAttr>()) {\n    bool AlwaysTrue;\n    if (EnableIf->getCond()->isValueDependent() ||\n        !EnableIf->getCond()->EvaluateAsBooleanCondition(AlwaysTrue, Ctx))\n      return false;\n    if (!AlwaysTrue)\n      return false;\n  }\n  return true;\n}\n\n/// Returns true if we can take the address of the function.\n///\n/// \\param Complain - If true, we'll emit a diagnostic\n/// \\param InOverloadResolution - For the purposes of emitting a diagnostic, are\n///   we in overload resolution?\n/// \\param Loc - The location of the statement we're complaining about. Ignored\n///   if we're not complaining, or if we're in overload resolution.\nstatic bool checkAddressOfFunctionIsAvailable(Sema &S, const FunctionDecl *FD,\n                                              bool Complain,\n                                              bool InOverloadResolution,\n                                              SourceLocation Loc) {\n  if (!isFunctionAlwaysEnabled(S.Context, FD)) {\n    if (Complain) {\n      if (InOverloadResolution)\n        S.Diag(FD->getBeginLoc(),\n               diag::note_addrof_ovl_candidate_disabled_by_enable_if_attr);\n      else\n        S.Diag(Loc, diag::err_addrof_function_disabled_by_enable_if_attr) << FD;\n    }\n    return false;\n  }\n\n  if (FD->getTrailingRequiresClause()) {\n    ConstraintSatisfaction Satisfaction;\n    if (S.CheckFunctionConstraints(FD, Satisfaction, Loc))\n      return false;\n    if (!Satisfaction.IsSatisfied) {\n      if (Complain) {\n        if (InOverloadResolution)\n          S.Diag(FD->getBeginLoc(),\n                 diag::note_ovl_candidate_unsatisfied_constraints);\n        else\n          S.Diag(Loc, diag::err_addrof_function_constraints_not_satisfied)\n              << FD;\n        S.DiagnoseUnsatisfiedConstraint(Satisfaction);\n      }\n      return false;\n    }\n  }\n\n  auto I = llvm::find_if(FD->parameters(), [](const ParmVarDecl *P) {\n    return P->hasAttr<PassObjectSizeAttr>();\n  });\n  if (I == FD->param_end())\n    return true;\n\n  if (Complain) {\n    // Add one to ParamNo because it's user-facing\n    unsigned ParamNo = std::distance(FD->param_begin(), I) + 1;\n    if (InOverloadResolution)\n      S.Diag(FD->getLocation(),\n             diag::note_ovl_candidate_has_pass_object_size_params)\n          << ParamNo;\n    else\n      S.Diag(Loc, diag::err_address_of_function_with_pass_object_size_params)\n          << FD << ParamNo;\n  }\n  return false;\n}\n\nstatic bool checkAddressOfCandidateIsAvailable(Sema &S,\n                                               const FunctionDecl *FD) {\n  return checkAddressOfFunctionIsAvailable(S, FD, /*Complain=*/true,\n                                           /*InOverloadResolution=*/true,\n                                           /*Loc=*/SourceLocation());\n}\n\nbool Sema::checkAddressOfFunctionIsAvailable(const FunctionDecl *Function,\n                                             bool Complain,\n                                             SourceLocation Loc) {\n  return ::checkAddressOfFunctionIsAvailable(*this, Function, Complain,\n                                             /*InOverloadResolution=*/false,\n                                             Loc);\n}\n\n// Don't print candidates other than the one that matches the calling\n// convention of the call operator, since that is guaranteed to exist.\nstatic bool shouldSkipNotingLambdaConversionDecl(FunctionDecl *Fn) {\n  const auto *ConvD = dyn_cast<CXXConversionDecl>(Fn);\n\n  if (!ConvD)\n    return false;\n  const auto *RD = cast<CXXRecordDecl>(Fn->getParent());\n  if (!RD->isLambda())\n    return false;\n\n  CXXMethodDecl *CallOp = RD->getLambdaCallOperator();\n  CallingConv CallOpCC =\n      CallOp->getType()->getAs<FunctionType>()->getCallConv();\n  QualType ConvRTy = ConvD->getType()->getAs<FunctionType>()->getReturnType();\n  CallingConv ConvToCC =\n      ConvRTy->getPointeeType()->getAs<FunctionType>()->getCallConv();\n\n  return ConvToCC != CallOpCC;\n}\n\n// Notes the location of an overload candidate.\nvoid Sema::NoteOverloadCandidate(NamedDecl *Found, FunctionDecl *Fn,\n                                 OverloadCandidateRewriteKind RewriteKind,\n                                 QualType DestType, bool TakingAddress) {\n  if (TakingAddress && !checkAddressOfCandidateIsAvailable(*this, Fn))\n    return;\n  if (Fn->isMultiVersion() && Fn->hasAttr<TargetAttr>() &&\n      !Fn->getAttr<TargetAttr>()->isDefaultVersion())\n    return;\n  if (shouldSkipNotingLambdaConversionDecl(Fn))\n    return;\n\n  std::string FnDesc;\n  std::pair<OverloadCandidateKind, OverloadCandidateSelect> KSPair =\n      ClassifyOverloadCandidate(*this, Found, Fn, RewriteKind, FnDesc);\n  PartialDiagnostic PD = PDiag(diag::note_ovl_candidate)\n                         << (unsigned)KSPair.first << (unsigned)KSPair.second\n                         << Fn << FnDesc;\n\n  HandleFunctionTypeMismatch(PD, Fn->getType(), DestType);\n  Diag(Fn->getLocation(), PD);\n  MaybeEmitInheritedConstructorNote(*this, Found);\n}\n\nstatic void\nMaybeDiagnoseAmbiguousConstraints(Sema &S, ArrayRef<OverloadCandidate> Cands) {\n  // Perhaps the ambiguity was caused by two atomic constraints that are\n  // 'identical' but not equivalent:\n  //\n  // void foo() requires (sizeof(T) > 4) { } // #1\n  // void foo() requires (sizeof(T) > 4) && T::value { } // #2\n  //\n  // The 'sizeof(T) > 4' constraints are seemingly equivalent and should cause\n  // #2 to subsume #1, but these constraint are not considered equivalent\n  // according to the subsumption rules because they are not the same\n  // source-level construct. This behavior is quite confusing and we should try\n  // to help the user figure out what happened.\n\n  SmallVector<const Expr *, 3> FirstAC, SecondAC;\n  FunctionDecl *FirstCand = nullptr, *SecondCand = nullptr;\n  for (auto I = Cands.begin(), E = Cands.end(); I != E; ++I) {\n    if (!I->Function)\n      continue;\n    SmallVector<const Expr *, 3> AC;\n    if (auto *Template = I->Function->getPrimaryTemplate())\n      Template->getAssociatedConstraints(AC);\n    else\n      I->Function->getAssociatedConstraints(AC);\n    if (AC.empty())\n      continue;\n    if (FirstCand == nullptr) {\n      FirstCand = I->Function;\n      FirstAC = AC;\n    } else if (SecondCand == nullptr) {\n      SecondCand = I->Function;\n      SecondAC = AC;\n    } else {\n      // We have more than one pair of constrained functions - this check is\n      // expensive and we'd rather not try to diagnose it.\n      return;\n    }\n  }\n  if (!SecondCand)\n    return;\n  // The diagnostic can only happen if there are associated constraints on\n  // both sides (there needs to be some identical atomic constraint).\n  if (S.MaybeEmitAmbiguousAtomicConstraintsDiagnostic(FirstCand, FirstAC,\n                                                      SecondCand, SecondAC))\n    // Just show the user one diagnostic, they'll probably figure it out\n    // from here.\n    return;\n}\n\n// Notes the location of all overload candidates designated through\n// OverloadedExpr\nvoid Sema::NoteAllOverloadCandidates(Expr *OverloadedExpr, QualType DestType,\n                                     bool TakingAddress) {\n  assert(OverloadedExpr->getType() == Context.OverloadTy);\n\n  OverloadExpr::FindResult Ovl = OverloadExpr::find(OverloadedExpr);\n  OverloadExpr *OvlExpr = Ovl.Expression;\n\n  for (UnresolvedSetIterator I = OvlExpr->decls_begin(),\n                            IEnd = OvlExpr->decls_end();\n       I != IEnd; ++I) {\n    if (FunctionTemplateDecl *FunTmpl =\n                dyn_cast<FunctionTemplateDecl>((*I)->getUnderlyingDecl()) ) {\n      NoteOverloadCandidate(*I, FunTmpl->getTemplatedDecl(), CRK_None, DestType,\n                            TakingAddress);\n    } else if (FunctionDecl *Fun\n                      = dyn_cast<FunctionDecl>((*I)->getUnderlyingDecl()) ) {\n      NoteOverloadCandidate(*I, Fun, CRK_None, DestType, TakingAddress);\n    }\n  }\n}\n\n/// Diagnoses an ambiguous conversion.  The partial diagnostic is the\n/// \"lead\" diagnostic; it will be given two arguments, the source and\n/// target types of the conversion.\nvoid ImplicitConversionSequence::DiagnoseAmbiguousConversion(\n                                 Sema &S,\n                                 SourceLocation CaretLoc,\n                                 const PartialDiagnostic &PDiag) const {\n  S.Diag(CaretLoc, PDiag)\n    << Ambiguous.getFromType() << Ambiguous.getToType();\n  unsigned CandsShown = 0;\n  AmbiguousConversionSequence::const_iterator I, E;\n  for (I = Ambiguous.begin(), E = Ambiguous.end(); I != E; ++I) {\n    if (CandsShown >= S.Diags.getNumOverloadCandidatesToShow())\n      break;\n    ++CandsShown;\n    S.NoteOverloadCandidate(I->first, I->second);\n  }\n  S.Diags.overloadCandidatesShown(CandsShown);\n  if (I != E)\n    S.Diag(SourceLocation(), diag::note_ovl_too_many_candidates) << int(E - I);\n}\n\nstatic void DiagnoseBadConversion(Sema &S, OverloadCandidate *Cand,\n                                  unsigned I, bool TakingCandidateAddress) {\n  const ImplicitConversionSequence &Conv = Cand->Conversions[I];\n  assert(Conv.isBad());\n  assert(Cand->Function && \"for now, candidate must be a function\");\n  FunctionDecl *Fn = Cand->Function;\n\n  // There's a conversion slot for the object argument if this is a\n  // non-constructor method.  Note that 'I' corresponds the\n  // conversion-slot index.\n  bool isObjectArgument = false;\n  if (isa<CXXMethodDecl>(Fn) && !isa<CXXConstructorDecl>(Fn)) {\n    if (I == 0)\n      isObjectArgument = true;\n    else\n      I--;\n  }\n\n  std::string FnDesc;\n  std::pair<OverloadCandidateKind, OverloadCandidateSelect> FnKindPair =\n      ClassifyOverloadCandidate(S, Cand->FoundDecl, Fn, Cand->getRewriteKind(),\n                                FnDesc);\n\n  Expr *FromExpr = Conv.Bad.FromExpr;\n  QualType FromTy = Conv.Bad.getFromType();\n  QualType ToTy = Conv.Bad.getToType();\n\n  if (FromTy == S.Context.OverloadTy) {\n    assert(FromExpr && \"overload set argument came from implicit argument?\");\n    Expr *E = FromExpr->IgnoreParens();\n    if (isa<UnaryOperator>(E))\n      E = cast<UnaryOperator>(E)->getSubExpr()->IgnoreParens();\n    DeclarationName Name = cast<OverloadExpr>(E)->getName();\n\n    S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_overload)\n        << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc\n        << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << ToTy\n        << Name << I + 1;\n    MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);\n    return;\n  }\n\n  // Do some hand-waving analysis to see if the non-viability is due\n  // to a qualifier mismatch.\n  CanQualType CFromTy = S.Context.getCanonicalType(FromTy);\n  CanQualType CToTy = S.Context.getCanonicalType(ToTy);\n  if (CanQual<ReferenceType> RT = CToTy->getAs<ReferenceType>())\n    CToTy = RT->getPointeeType();\n  else {\n    // TODO: detect and diagnose the full richness of const mismatches.\n    if (CanQual<PointerType> FromPT = CFromTy->getAs<PointerType>())\n      if (CanQual<PointerType> ToPT = CToTy->getAs<PointerType>()) {\n        CFromTy = FromPT->getPointeeType();\n        CToTy = ToPT->getPointeeType();\n      }\n  }\n\n  if (CToTy.getUnqualifiedType() == CFromTy.getUnqualifiedType() &&\n      !CToTy.isAtLeastAsQualifiedAs(CFromTy)) {\n    Qualifiers FromQs = CFromTy.getQualifiers();\n    Qualifiers ToQs = CToTy.getQualifiers();\n\n    if (FromQs.getAddressSpace() != ToQs.getAddressSpace()) {\n      if (isObjectArgument)\n        S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_addrspace_this)\n            << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second\n            << FnDesc << (FromExpr ? FromExpr->getSourceRange() : SourceRange())\n            << FromQs.getAddressSpace() << ToQs.getAddressSpace();\n      else\n        S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_addrspace)\n            << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second\n            << FnDesc << (FromExpr ? FromExpr->getSourceRange() : SourceRange())\n            << FromQs.getAddressSpace() << ToQs.getAddressSpace()\n            << ToTy->isReferenceType() << I + 1;\n      MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);\n      return;\n    }\n\n    if (FromQs.getObjCLifetime() != ToQs.getObjCLifetime()) {\n      S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_ownership)\n          << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc\n          << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << FromTy\n          << FromQs.getObjCLifetime() << ToQs.getObjCLifetime()\n          << (unsigned)isObjectArgument << I + 1;\n      MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);\n      return;\n    }\n\n    if (FromQs.getObjCGCAttr() != ToQs.getObjCGCAttr()) {\n      S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_gc)\n          << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc\n          << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << FromTy\n          << FromQs.getObjCGCAttr() << ToQs.getObjCGCAttr()\n          << (unsigned)isObjectArgument << I + 1;\n      MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);\n      return;\n    }\n\n    if (FromQs.hasUnaligned() != ToQs.hasUnaligned()) {\n      S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_unaligned)\n          << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc\n          << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << FromTy\n          << FromQs.hasUnaligned() << I + 1;\n      MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);\n      return;\n    }\n\n    unsigned CVR = FromQs.getCVRQualifiers() & ~ToQs.getCVRQualifiers();\n    assert(CVR && \"expected qualifiers mismatch\");\n\n    if (isObjectArgument) {\n      S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_cvr_this)\n          << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc\n          << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << FromTy\n          << (CVR - 1);\n    } else {\n      S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_cvr)\n          << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc\n          << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << FromTy\n          << (CVR - 1) << I + 1;\n    }\n    MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);\n    return;\n  }\n\n  if (Conv.Bad.Kind == BadConversionSequence::lvalue_ref_to_rvalue ||\n      Conv.Bad.Kind == BadConversionSequence::rvalue_ref_to_lvalue) {\n    S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_value_category)\n        << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc\n        << (unsigned)isObjectArgument << I + 1\n        << (Conv.Bad.Kind == BadConversionSequence::rvalue_ref_to_lvalue)\n        << (FromExpr ? FromExpr->getSourceRange() : SourceRange());\n    MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);\n    return;\n  }\n\n  // Special diagnostic for failure to convert an initializer list, since\n  // telling the user that it has type void is not useful.\n  if (FromExpr && isa<InitListExpr>(FromExpr)) {\n    S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_list_argument)\n        << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc\n        << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << FromTy\n        << ToTy << (unsigned)isObjectArgument << I + 1;\n    MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);\n    return;\n  }\n\n  // Diagnose references or pointers to incomplete types differently,\n  // since it's far from impossible that the incompleteness triggered\n  // the failure.\n  QualType TempFromTy = FromTy.getNonReferenceType();\n  if (const PointerType *PTy = TempFromTy->getAs<PointerType>())\n    TempFromTy = PTy->getPointeeType();\n  if (TempFromTy->isIncompleteType()) {\n    // Emit the generic diagnostic and, optionally, add the hints to it.\n    S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_conv_incomplete)\n        << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc\n        << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << FromTy\n        << ToTy << (unsigned)isObjectArgument << I + 1\n        << (unsigned)(Cand->Fix.Kind);\n\n    MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);\n    return;\n  }\n\n  // Diagnose base -> derived pointer conversions.\n  unsigned BaseToDerivedConversion = 0;\n  if (const PointerType *FromPtrTy = FromTy->getAs<PointerType>()) {\n    if (const PointerType *ToPtrTy = ToTy->getAs<PointerType>()) {\n      if (ToPtrTy->getPointeeType().isAtLeastAsQualifiedAs(\n                                               FromPtrTy->getPointeeType()) &&\n          !FromPtrTy->getPointeeType()->isIncompleteType() &&\n          !ToPtrTy->getPointeeType()->isIncompleteType() &&\n          S.IsDerivedFrom(SourceLocation(), ToPtrTy->getPointeeType(),\n                          FromPtrTy->getPointeeType()))\n        BaseToDerivedConversion = 1;\n    }\n  } else if (const ObjCObjectPointerType *FromPtrTy\n                                    = FromTy->getAs<ObjCObjectPointerType>()) {\n    if (const ObjCObjectPointerType *ToPtrTy\n                                        = ToTy->getAs<ObjCObjectPointerType>())\n      if (const ObjCInterfaceDecl *FromIface = FromPtrTy->getInterfaceDecl())\n        if (const ObjCInterfaceDecl *ToIface = ToPtrTy->getInterfaceDecl())\n          if (ToPtrTy->getPointeeType().isAtLeastAsQualifiedAs(\n                                                FromPtrTy->getPointeeType()) &&\n              FromIface->isSuperClassOf(ToIface))\n            BaseToDerivedConversion = 2;\n  } else if (const ReferenceType *ToRefTy = ToTy->getAs<ReferenceType>()) {\n    if (ToRefTy->getPointeeType().isAtLeastAsQualifiedAs(FromTy) &&\n        !FromTy->isIncompleteType() &&\n        !ToRefTy->getPointeeType()->isIncompleteType() &&\n        S.IsDerivedFrom(SourceLocation(), ToRefTy->getPointeeType(), FromTy)) {\n      BaseToDerivedConversion = 3;\n    }\n  }\n\n  if (BaseToDerivedConversion) {\n    S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_base_to_derived_conv)\n        << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc\n        << (FromExpr ? FromExpr->getSourceRange() : SourceRange())\n        << (BaseToDerivedConversion - 1) << FromTy << ToTy << I + 1;\n    MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);\n    return;\n  }\n\n  if (isa<ObjCObjectPointerType>(CFromTy) &&\n      isa<PointerType>(CToTy)) {\n      Qualifiers FromQs = CFromTy.getQualifiers();\n      Qualifiers ToQs = CToTy.getQualifiers();\n      if (FromQs.getObjCLifetime() != ToQs.getObjCLifetime()) {\n        S.Diag(Fn->getLocation(), diag::note_ovl_candidate_bad_arc_conv)\n            << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second\n            << FnDesc << (FromExpr ? FromExpr->getSourceRange() : SourceRange())\n            << FromTy << ToTy << (unsigned)isObjectArgument << I + 1;\n        MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);\n        return;\n      }\n  }\n\n  if (TakingCandidateAddress &&\n      !checkAddressOfCandidateIsAvailable(S, Cand->Function))\n    return;\n\n  // Emit the generic diagnostic and, optionally, add the hints to it.\n  PartialDiagnostic FDiag = S.PDiag(diag::note_ovl_candidate_bad_conv);\n  FDiag << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc\n        << (FromExpr ? FromExpr->getSourceRange() : SourceRange()) << FromTy\n        << ToTy << (unsigned)isObjectArgument << I + 1\n        << (unsigned)(Cand->Fix.Kind);\n\n  // If we can fix the conversion, suggest the FixIts.\n  for (std::vector<FixItHint>::iterator HI = Cand->Fix.Hints.begin(),\n       HE = Cand->Fix.Hints.end(); HI != HE; ++HI)\n    FDiag << *HI;\n  S.Diag(Fn->getLocation(), FDiag);\n\n  MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);\n}\n\n/// Additional arity mismatch diagnosis specific to a function overload\n/// candidates. This is not covered by the more general DiagnoseArityMismatch()\n/// over a candidate in any candidate set.\nstatic bool CheckArityMismatch(Sema &S, OverloadCandidate *Cand,\n                               unsigned NumArgs) {\n  FunctionDecl *Fn = Cand->Function;\n  unsigned MinParams = Fn->getMinRequiredArguments();\n\n  // With invalid overloaded operators, it's possible that we think we\n  // have an arity mismatch when in fact it looks like we have the\n  // right number of arguments, because only overloaded operators have\n  // the weird behavior of overloading member and non-member functions.\n  // Just don't report anything.\n  if (Fn->isInvalidDecl() &&\n      Fn->getDeclName().getNameKind() == DeclarationName::CXXOperatorName)\n    return true;\n\n  if (NumArgs < MinParams) {\n    assert((Cand->FailureKind == ovl_fail_too_few_arguments) ||\n           (Cand->FailureKind == ovl_fail_bad_deduction &&\n            Cand->DeductionFailure.Result == Sema::TDK_TooFewArguments));\n  } else {\n    assert((Cand->FailureKind == ovl_fail_too_many_arguments) ||\n           (Cand->FailureKind == ovl_fail_bad_deduction &&\n            Cand->DeductionFailure.Result == Sema::TDK_TooManyArguments));\n  }\n\n  return false;\n}\n\n/// General arity mismatch diagnosis over a candidate in a candidate set.\nstatic void DiagnoseArityMismatch(Sema &S, NamedDecl *Found, Decl *D,\n                                  unsigned NumFormalArgs) {\n  assert(isa<FunctionDecl>(D) &&\n      \"The templated declaration should at least be a function\"\n      \" when diagnosing bad template argument deduction due to too many\"\n      \" or too few arguments\");\n\n  FunctionDecl *Fn = cast<FunctionDecl>(D);\n\n  // TODO: treat calls to a missing default constructor as a special case\n  const auto *FnTy = Fn->getType()->castAs<FunctionProtoType>();\n  unsigned MinParams = Fn->getMinRequiredArguments();\n\n  // at least / at most / exactly\n  unsigned mode, modeCount;\n  if (NumFormalArgs < MinParams) {\n    if (MinParams != FnTy->getNumParams() || FnTy->isVariadic() ||\n        FnTy->isTemplateVariadic())\n      mode = 0; // \"at least\"\n    else\n      mode = 2; // \"exactly\"\n    modeCount = MinParams;\n  } else {\n    if (MinParams != FnTy->getNumParams())\n      mode = 1; // \"at most\"\n    else\n      mode = 2; // \"exactly\"\n    modeCount = FnTy->getNumParams();\n  }\n\n  std::string Description;\n  std::pair<OverloadCandidateKind, OverloadCandidateSelect> FnKindPair =\n      ClassifyOverloadCandidate(S, Found, Fn, CRK_None, Description);\n\n  if (modeCount == 1 && Fn->getParamDecl(0)->getDeclName())\n    S.Diag(Fn->getLocation(), diag::note_ovl_candidate_arity_one)\n        << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second\n        << Description << mode << Fn->getParamDecl(0) << NumFormalArgs;\n  else\n    S.Diag(Fn->getLocation(), diag::note_ovl_candidate_arity)\n        << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second\n        << Description << mode << modeCount << NumFormalArgs;\n\n  MaybeEmitInheritedConstructorNote(S, Found);\n}\n\n/// Arity mismatch diagnosis specific to a function overload candidate.\nstatic void DiagnoseArityMismatch(Sema &S, OverloadCandidate *Cand,\n                                  unsigned NumFormalArgs) {\n  if (!CheckArityMismatch(S, Cand, NumFormalArgs))\n    DiagnoseArityMismatch(S, Cand->FoundDecl, Cand->Function, NumFormalArgs);\n}\n\nstatic TemplateDecl *getDescribedTemplate(Decl *Templated) {\n  if (TemplateDecl *TD = Templated->getDescribedTemplate())\n    return TD;\n  llvm_unreachable(\"Unsupported: Getting the described template declaration\"\n                   \" for bad deduction diagnosis\");\n}\n\n/// Diagnose a failed template-argument deduction.\nstatic void DiagnoseBadDeduction(Sema &S, NamedDecl *Found, Decl *Templated,\n                                 DeductionFailureInfo &DeductionFailure,\n                                 unsigned NumArgs,\n                                 bool TakingCandidateAddress) {\n  TemplateParameter Param = DeductionFailure.getTemplateParameter();\n  NamedDecl *ParamD;\n  (ParamD = Param.dyn_cast<TemplateTypeParmDecl*>()) ||\n  (ParamD = Param.dyn_cast<NonTypeTemplateParmDecl*>()) ||\n  (ParamD = Param.dyn_cast<TemplateTemplateParmDecl*>());\n  switch (DeductionFailure.Result) {\n  case Sema::TDK_Success:\n    llvm_unreachable(\"TDK_success while diagnosing bad deduction\");\n\n  case Sema::TDK_Incomplete: {\n    assert(ParamD && \"no parameter found for incomplete deduction result\");\n    S.Diag(Templated->getLocation(),\n           diag::note_ovl_candidate_incomplete_deduction)\n        << ParamD->getDeclName();\n    MaybeEmitInheritedConstructorNote(S, Found);\n    return;\n  }\n\n  case Sema::TDK_IncompletePack: {\n    assert(ParamD && \"no parameter found for incomplete deduction result\");\n    S.Diag(Templated->getLocation(),\n           diag::note_ovl_candidate_incomplete_deduction_pack)\n        << ParamD->getDeclName()\n        << (DeductionFailure.getFirstArg()->pack_size() + 1)\n        << *DeductionFailure.getFirstArg();\n    MaybeEmitInheritedConstructorNote(S, Found);\n    return;\n  }\n\n  case Sema::TDK_Underqualified: {\n    assert(ParamD && \"no parameter found for bad qualifiers deduction result\");\n    TemplateTypeParmDecl *TParam = cast<TemplateTypeParmDecl>(ParamD);\n\n    QualType Param = DeductionFailure.getFirstArg()->getAsType();\n\n    // Param will have been canonicalized, but it should just be a\n    // qualified version of ParamD, so move the qualifiers to that.\n    QualifierCollector Qs;\n    Qs.strip(Param);\n    QualType NonCanonParam = Qs.apply(S.Context, TParam->getTypeForDecl());\n    assert(S.Context.hasSameType(Param, NonCanonParam));\n\n    // Arg has also been canonicalized, but there's nothing we can do\n    // about that.  It also doesn't matter as much, because it won't\n    // have any template parameters in it (because deduction isn't\n    // done on dependent types).\n    QualType Arg = DeductionFailure.getSecondArg()->getAsType();\n\n    S.Diag(Templated->getLocation(), diag::note_ovl_candidate_underqualified)\n        << ParamD->getDeclName() << Arg << NonCanonParam;\n    MaybeEmitInheritedConstructorNote(S, Found);\n    return;\n  }\n\n  case Sema::TDK_Inconsistent: {\n    assert(ParamD && \"no parameter found for inconsistent deduction result\");\n    int which = 0;\n    if (isa<TemplateTypeParmDecl>(ParamD))\n      which = 0;\n    else if (isa<NonTypeTemplateParmDecl>(ParamD)) {\n      // Deduction might have failed because we deduced arguments of two\n      // different types for a non-type template parameter.\n      // FIXME: Use a different TDK value for this.\n      QualType T1 =\n          DeductionFailure.getFirstArg()->getNonTypeTemplateArgumentType();\n      QualType T2 =\n          DeductionFailure.getSecondArg()->getNonTypeTemplateArgumentType();\n      if (!T1.isNull() && !T2.isNull() && !S.Context.hasSameType(T1, T2)) {\n        S.Diag(Templated->getLocation(),\n               diag::note_ovl_candidate_inconsistent_deduction_types)\n          << ParamD->getDeclName() << *DeductionFailure.getFirstArg() << T1\n          << *DeductionFailure.getSecondArg() << T2;\n        MaybeEmitInheritedConstructorNote(S, Found);\n        return;\n      }\n\n      which = 1;\n    } else {\n      which = 2;\n    }\n\n    // Tweak the diagnostic if the problem is that we deduced packs of\n    // different arities. We'll print the actual packs anyway in case that\n    // includes additional useful information.\n    if (DeductionFailure.getFirstArg()->getKind() == TemplateArgument::Pack &&\n        DeductionFailure.getSecondArg()->getKind() == TemplateArgument::Pack &&\n        DeductionFailure.getFirstArg()->pack_size() !=\n            DeductionFailure.getSecondArg()->pack_size()) {\n      which = 3;\n    }\n\n    S.Diag(Templated->getLocation(),\n           diag::note_ovl_candidate_inconsistent_deduction)\n        << which << ParamD->getDeclName() << *DeductionFailure.getFirstArg()\n        << *DeductionFailure.getSecondArg();\n    MaybeEmitInheritedConstructorNote(S, Found);\n    return;\n  }\n\n  case Sema::TDK_InvalidExplicitArguments:\n    assert(ParamD && \"no parameter found for invalid explicit arguments\");\n    if (ParamD->getDeclName())\n      S.Diag(Templated->getLocation(),\n             diag::note_ovl_candidate_explicit_arg_mismatch_named)\n          << ParamD->getDeclName();\n    else {\n      int index = 0;\n      if (TemplateTypeParmDecl *TTP = dyn_cast<TemplateTypeParmDecl>(ParamD))\n        index = TTP->getIndex();\n      else if (NonTypeTemplateParmDecl *NTTP\n                                  = dyn_cast<NonTypeTemplateParmDecl>(ParamD))\n        index = NTTP->getIndex();\n      else\n        index = cast<TemplateTemplateParmDecl>(ParamD)->getIndex();\n      S.Diag(Templated->getLocation(),\n             diag::note_ovl_candidate_explicit_arg_mismatch_unnamed)\n          << (index + 1);\n    }\n    MaybeEmitInheritedConstructorNote(S, Found);\n    return;\n\n  case Sema::TDK_ConstraintsNotSatisfied: {\n    // Format the template argument list into the argument string.\n    SmallString<128> TemplateArgString;\n    TemplateArgumentList *Args = DeductionFailure.getTemplateArgumentList();\n    TemplateArgString = \" \";\n    TemplateArgString += S.getTemplateArgumentBindingsText(\n        getDescribedTemplate(Templated)->getTemplateParameters(), *Args);\n    if (TemplateArgString.size() == 1)\n      TemplateArgString.clear();\n    S.Diag(Templated->getLocation(),\n           diag::note_ovl_candidate_unsatisfied_constraints)\n        << TemplateArgString;\n\n    S.DiagnoseUnsatisfiedConstraint(\n        static_cast<CNSInfo*>(DeductionFailure.Data)->Satisfaction);\n    return;\n  }\n  case Sema::TDK_TooManyArguments:\n  case Sema::TDK_TooFewArguments:\n    DiagnoseArityMismatch(S, Found, Templated, NumArgs);\n    return;\n\n  case Sema::TDK_InstantiationDepth:\n    S.Diag(Templated->getLocation(),\n           diag::note_ovl_candidate_instantiation_depth);\n    MaybeEmitInheritedConstructorNote(S, Found);\n    return;\n\n  case Sema::TDK_SubstitutionFailure: {\n    // Format the template argument list into the argument string.\n    SmallString<128> TemplateArgString;\n    if (TemplateArgumentList *Args =\n            DeductionFailure.getTemplateArgumentList()) {\n      TemplateArgString = \" \";\n      TemplateArgString += S.getTemplateArgumentBindingsText(\n          getDescribedTemplate(Templated)->getTemplateParameters(), *Args);\n      if (TemplateArgString.size() == 1)\n        TemplateArgString.clear();\n    }\n\n    // If this candidate was disabled by enable_if, say so.\n    PartialDiagnosticAt *PDiag = DeductionFailure.getSFINAEDiagnostic();\n    if (PDiag && PDiag->second.getDiagID() ==\n          diag::err_typename_nested_not_found_enable_if) {\n      // FIXME: Use the source range of the condition, and the fully-qualified\n      //        name of the enable_if template. These are both present in PDiag.\n      S.Diag(PDiag->first, diag::note_ovl_candidate_disabled_by_enable_if)\n        << \"'enable_if'\" << TemplateArgString;\n      return;\n    }\n\n    // We found a specific requirement that disabled the enable_if.\n    if (PDiag && PDiag->second.getDiagID() ==\n        diag::err_typename_nested_not_found_requirement) {\n      S.Diag(Templated->getLocation(),\n             diag::note_ovl_candidate_disabled_by_requirement)\n        << PDiag->second.getStringArg(0) << TemplateArgString;\n      return;\n    }\n\n    // Format the SFINAE diagnostic into the argument string.\n    // FIXME: Add a general mechanism to include a PartialDiagnostic *'s\n    //        formatted message in another diagnostic.\n    SmallString<128> SFINAEArgString;\n    SourceRange R;\n    if (PDiag) {\n      SFINAEArgString = \": \";\n      R = SourceRange(PDiag->first, PDiag->first);\n      PDiag->second.EmitToString(S.getDiagnostics(), SFINAEArgString);\n    }\n\n    S.Diag(Templated->getLocation(),\n           diag::note_ovl_candidate_substitution_failure)\n        << TemplateArgString << SFINAEArgString << R;\n    MaybeEmitInheritedConstructorNote(S, Found);\n    return;\n  }\n\n  case Sema::TDK_DeducedMismatch:\n  case Sema::TDK_DeducedMismatchNested: {\n    // Format the template argument list into the argument string.\n    SmallString<128> TemplateArgString;\n    if (TemplateArgumentList *Args =\n            DeductionFailure.getTemplateArgumentList()) {\n      TemplateArgString = \" \";\n      TemplateArgString += S.getTemplateArgumentBindingsText(\n          getDescribedTemplate(Templated)->getTemplateParameters(), *Args);\n      if (TemplateArgString.size() == 1)\n        TemplateArgString.clear();\n    }\n\n    S.Diag(Templated->getLocation(), diag::note_ovl_candidate_deduced_mismatch)\n        << (*DeductionFailure.getCallArgIndex() + 1)\n        << *DeductionFailure.getFirstArg() << *DeductionFailure.getSecondArg()\n        << TemplateArgString\n        << (DeductionFailure.Result == Sema::TDK_DeducedMismatchNested);\n    break;\n  }\n\n  case Sema::TDK_NonDeducedMismatch: {\n    // FIXME: Provide a source location to indicate what we couldn't match.\n    TemplateArgument FirstTA = *DeductionFailure.getFirstArg();\n    TemplateArgument SecondTA = *DeductionFailure.getSecondArg();\n    if (FirstTA.getKind() == TemplateArgument::Template &&\n        SecondTA.getKind() == TemplateArgument::Template) {\n      TemplateName FirstTN = FirstTA.getAsTemplate();\n      TemplateName SecondTN = SecondTA.getAsTemplate();\n      if (FirstTN.getKind() == TemplateName::Template &&\n          SecondTN.getKind() == TemplateName::Template) {\n        if (FirstTN.getAsTemplateDecl()->getName() ==\n            SecondTN.getAsTemplateDecl()->getName()) {\n          // FIXME: This fixes a bad diagnostic where both templates are named\n          // the same.  This particular case is a bit difficult since:\n          // 1) It is passed as a string to the diagnostic printer.\n          // 2) The diagnostic printer only attempts to find a better\n          //    name for types, not decls.\n          // Ideally, this should folded into the diagnostic printer.\n          S.Diag(Templated->getLocation(),\n                 diag::note_ovl_candidate_non_deduced_mismatch_qualified)\n              << FirstTN.getAsTemplateDecl() << SecondTN.getAsTemplateDecl();\n          return;\n        }\n      }\n    }\n\n    if (TakingCandidateAddress && isa<FunctionDecl>(Templated) &&\n        !checkAddressOfCandidateIsAvailable(S, cast<FunctionDecl>(Templated)))\n      return;\n\n    // FIXME: For generic lambda parameters, check if the function is a lambda\n    // call operator, and if so, emit a prettier and more informative\n    // diagnostic that mentions 'auto' and lambda in addition to\n    // (or instead of?) the canonical template type parameters.\n    S.Diag(Templated->getLocation(),\n           diag::note_ovl_candidate_non_deduced_mismatch)\n        << FirstTA << SecondTA;\n    return;\n  }\n  // TODO: diagnose these individually, then kill off\n  // note_ovl_candidate_bad_deduction, which is uselessly vague.\n  case Sema::TDK_MiscellaneousDeductionFailure:\n    S.Diag(Templated->getLocation(), diag::note_ovl_candidate_bad_deduction);\n    MaybeEmitInheritedConstructorNote(S, Found);\n    return;\n  case Sema::TDK_CUDATargetMismatch:\n    S.Diag(Templated->getLocation(),\n           diag::note_cuda_ovl_candidate_target_mismatch);\n    return;\n  }\n}\n\n/// Diagnose a failed template-argument deduction, for function calls.\nstatic void DiagnoseBadDeduction(Sema &S, OverloadCandidate *Cand,\n                                 unsigned NumArgs,\n                                 bool TakingCandidateAddress) {\n  unsigned TDK = Cand->DeductionFailure.Result;\n  if (TDK == Sema::TDK_TooFewArguments || TDK == Sema::TDK_TooManyArguments) {\n    if (CheckArityMismatch(S, Cand, NumArgs))\n      return;\n  }\n  DiagnoseBadDeduction(S, Cand->FoundDecl, Cand->Function, // pattern\n                       Cand->DeductionFailure, NumArgs, TakingCandidateAddress);\n}\n\n/// CUDA: diagnose an invalid call across targets.\nstatic void DiagnoseBadTarget(Sema &S, OverloadCandidate *Cand) {\n  FunctionDecl *Caller = cast<FunctionDecl>(S.CurContext);\n  FunctionDecl *Callee = Cand->Function;\n\n  Sema::CUDAFunctionTarget CallerTarget = S.IdentifyCUDATarget(Caller),\n                           CalleeTarget = S.IdentifyCUDATarget(Callee);\n\n  std::string FnDesc;\n  std::pair<OverloadCandidateKind, OverloadCandidateSelect> FnKindPair =\n      ClassifyOverloadCandidate(S, Cand->FoundDecl, Callee,\n                                Cand->getRewriteKind(), FnDesc);\n\n  S.Diag(Callee->getLocation(), diag::note_ovl_candidate_bad_target)\n      << (unsigned)FnKindPair.first << (unsigned)ocs_non_template\n      << FnDesc /* Ignored */\n      << CalleeTarget << CallerTarget;\n\n  // This could be an implicit constructor for which we could not infer the\n  // target due to a collsion. Diagnose that case.\n  CXXMethodDecl *Meth = dyn_cast<CXXMethodDecl>(Callee);\n  if (Meth != nullptr && Meth->isImplicit()) {\n    CXXRecordDecl *ParentClass = Meth->getParent();\n    Sema::CXXSpecialMember CSM;\n\n    switch (FnKindPair.first) {\n    default:\n      return;\n    case oc_implicit_default_constructor:\n      CSM = Sema::CXXDefaultConstructor;\n      break;\n    case oc_implicit_copy_constructor:\n      CSM = Sema::CXXCopyConstructor;\n      break;\n    case oc_implicit_move_constructor:\n      CSM = Sema::CXXMoveConstructor;\n      break;\n    case oc_implicit_copy_assignment:\n      CSM = Sema::CXXCopyAssignment;\n      break;\n    case oc_implicit_move_assignment:\n      CSM = Sema::CXXMoveAssignment;\n      break;\n    };\n\n    bool ConstRHS = false;\n    if (Meth->getNumParams()) {\n      if (const ReferenceType *RT =\n              Meth->getParamDecl(0)->getType()->getAs<ReferenceType>()) {\n        ConstRHS = RT->getPointeeType().isConstQualified();\n      }\n    }\n\n    S.inferCUDATargetForImplicitSpecialMember(ParentClass, CSM, Meth,\n                                              /* ConstRHS */ ConstRHS,\n                                              /* Diagnose */ true);\n  }\n}\n\nstatic void DiagnoseFailedEnableIfAttr(Sema &S, OverloadCandidate *Cand) {\n  FunctionDecl *Callee = Cand->Function;\n  EnableIfAttr *Attr = static_cast<EnableIfAttr*>(Cand->DeductionFailure.Data);\n\n  S.Diag(Callee->getLocation(),\n         diag::note_ovl_candidate_disabled_by_function_cond_attr)\n      << Attr->getCond()->getSourceRange() << Attr->getMessage();\n}\n\nstatic void DiagnoseFailedExplicitSpec(Sema &S, OverloadCandidate *Cand) {\n  ExplicitSpecifier ES = ExplicitSpecifier::getFromDecl(Cand->Function);\n  assert(ES.isExplicit() && \"not an explicit candidate\");\n\n  unsigned Kind;\n  switch (Cand->Function->getDeclKind()) {\n  case Decl::Kind::CXXConstructor:\n    Kind = 0;\n    break;\n  case Decl::Kind::CXXConversion:\n    Kind = 1;\n    break;\n  case Decl::Kind::CXXDeductionGuide:\n    Kind = Cand->Function->isImplicit() ? 0 : 2;\n    break;\n  default:\n    llvm_unreachable(\"invalid Decl\");\n  }\n\n  // Note the location of the first (in-class) declaration; a redeclaration\n  // (particularly an out-of-class definition) will typically lack the\n  // 'explicit' specifier.\n  // FIXME: This is probably a good thing to do for all 'candidate' notes.\n  FunctionDecl *First = Cand->Function->getFirstDecl();\n  if (FunctionDecl *Pattern = First->getTemplateInstantiationPattern())\n    First = Pattern->getFirstDecl();\n\n  S.Diag(First->getLocation(),\n         diag::note_ovl_candidate_explicit)\n      << Kind << (ES.getExpr() ? 1 : 0)\n      << (ES.getExpr() ? ES.getExpr()->getSourceRange() : SourceRange());\n}\n\nstatic void DiagnoseOpenCLExtensionDisabled(Sema &S, OverloadCandidate *Cand) {\n  FunctionDecl *Callee = Cand->Function;\n\n  S.Diag(Callee->getLocation(),\n         diag::note_ovl_candidate_disabled_by_extension)\n    << S.getOpenCLExtensionsFromDeclExtMap(Callee);\n}\n\n/// Generates a 'note' diagnostic for an overload candidate.  We've\n/// already generated a primary error at the call site.\n///\n/// It really does need to be a single diagnostic with its caret\n/// pointed at the candidate declaration.  Yes, this creates some\n/// major challenges of technical writing.  Yes, this makes pointing\n/// out problems with specific arguments quite awkward.  It's still\n/// better than generating twenty screens of text for every failed\n/// overload.\n///\n/// It would be great to be able to express per-candidate problems\n/// more richly for those diagnostic clients that cared, but we'd\n/// still have to be just as careful with the default diagnostics.\n/// \\param CtorDestAS Addr space of object being constructed (for ctor\n/// candidates only).\nstatic void NoteFunctionCandidate(Sema &S, OverloadCandidate *Cand,\n                                  unsigned NumArgs,\n                                  bool TakingCandidateAddress,\n                                  LangAS CtorDestAS = LangAS::Default) {\n  FunctionDecl *Fn = Cand->Function;\n  if (shouldSkipNotingLambdaConversionDecl(Fn))\n    return;\n\n  // Note deleted candidates, but only if they're viable.\n  if (Cand->Viable) {\n    if (Fn->isDeleted()) {\n      std::string FnDesc;\n      std::pair<OverloadCandidateKind, OverloadCandidateSelect> FnKindPair =\n          ClassifyOverloadCandidate(S, Cand->FoundDecl, Fn,\n                                    Cand->getRewriteKind(), FnDesc);\n\n      S.Diag(Fn->getLocation(), diag::note_ovl_candidate_deleted)\n          << (unsigned)FnKindPair.first << (unsigned)FnKindPair.second << FnDesc\n          << (Fn->isDeleted() ? (Fn->isDeletedAsWritten() ? 1 : 2) : 0);\n      MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);\n      return;\n    }\n\n    // We don't really have anything else to say about viable candidates.\n    S.NoteOverloadCandidate(Cand->FoundDecl, Fn, Cand->getRewriteKind());\n    return;\n  }\n\n  switch (Cand->FailureKind) {\n  case ovl_fail_too_many_arguments:\n  case ovl_fail_too_few_arguments:\n    return DiagnoseArityMismatch(S, Cand, NumArgs);\n\n  case ovl_fail_bad_deduction:\n    return DiagnoseBadDeduction(S, Cand, NumArgs,\n                                TakingCandidateAddress);\n\n  case ovl_fail_illegal_constructor: {\n    S.Diag(Fn->getLocation(), diag::note_ovl_candidate_illegal_constructor)\n      << (Fn->getPrimaryTemplate() ? 1 : 0);\n    MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);\n    return;\n  }\n\n  case ovl_fail_object_addrspace_mismatch: {\n    Qualifiers QualsForPrinting;\n    QualsForPrinting.setAddressSpace(CtorDestAS);\n    S.Diag(Fn->getLocation(),\n           diag::note_ovl_candidate_illegal_constructor_adrspace_mismatch)\n        << QualsForPrinting;\n    MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);\n    return;\n  }\n\n  case ovl_fail_trivial_conversion:\n  case ovl_fail_bad_final_conversion:\n  case ovl_fail_final_conversion_not_exact:\n    return S.NoteOverloadCandidate(Cand->FoundDecl, Fn, Cand->getRewriteKind());\n\n  case ovl_fail_bad_conversion: {\n    unsigned I = (Cand->IgnoreObjectArgument ? 1 : 0);\n    for (unsigned N = Cand->Conversions.size(); I != N; ++I)\n      if (Cand->Conversions[I].isBad())\n        return DiagnoseBadConversion(S, Cand, I, TakingCandidateAddress);\n\n    // FIXME: this currently happens when we're called from SemaInit\n    // when user-conversion overload fails.  Figure out how to handle\n    // those conditions and diagnose them well.\n    return S.NoteOverloadCandidate(Cand->FoundDecl, Fn, Cand->getRewriteKind());\n  }\n\n  case ovl_fail_bad_target:\n    return DiagnoseBadTarget(S, Cand);\n\n  case ovl_fail_enable_if:\n    return DiagnoseFailedEnableIfAttr(S, Cand);\n\n  case ovl_fail_explicit:\n    return DiagnoseFailedExplicitSpec(S, Cand);\n\n  case ovl_fail_ext_disabled:\n    return DiagnoseOpenCLExtensionDisabled(S, Cand);\n\n  case ovl_fail_inhctor_slice:\n    // It's generally not interesting to note copy/move constructors here.\n    if (cast<CXXConstructorDecl>(Fn)->isCopyOrMoveConstructor())\n      return;\n    S.Diag(Fn->getLocation(),\n           diag::note_ovl_candidate_inherited_constructor_slice)\n      << (Fn->getPrimaryTemplate() ? 1 : 0)\n      << Fn->getParamDecl(0)->getType()->isRValueReferenceType();\n    MaybeEmitInheritedConstructorNote(S, Cand->FoundDecl);\n    return;\n\n  case ovl_fail_addr_not_available: {\n    bool Available = checkAddressOfCandidateIsAvailable(S, Cand->Function);\n    (void)Available;\n    assert(!Available);\n    break;\n  }\n  case ovl_non_default_multiversion_function:\n    // Do nothing, these should simply be ignored.\n    break;\n\n  case ovl_fail_constraints_not_satisfied: {\n    std::string FnDesc;\n    std::pair<OverloadCandidateKind, OverloadCandidateSelect> FnKindPair =\n        ClassifyOverloadCandidate(S, Cand->FoundDecl, Fn,\n                                  Cand->getRewriteKind(), FnDesc);\n\n    S.Diag(Fn->getLocation(),\n           diag::note_ovl_candidate_constraints_not_satisfied)\n        << (unsigned)FnKindPair.first << (unsigned)ocs_non_template\n        << FnDesc /* Ignored */;\n    ConstraintSatisfaction Satisfaction;\n    if (S.CheckFunctionConstraints(Fn, Satisfaction))\n      break;\n    S.DiagnoseUnsatisfiedConstraint(Satisfaction);\n  }\n  }\n}\n\nstatic void NoteSurrogateCandidate(Sema &S, OverloadCandidate *Cand) {\n  if (shouldSkipNotingLambdaConversionDecl(Cand->Surrogate))\n    return;\n\n  // Desugar the type of the surrogate down to a function type,\n  // retaining as many typedefs as possible while still showing\n  // the function type (and, therefore, its parameter types).\n  QualType FnType = Cand->Surrogate->getConversionType();\n  bool isLValueReference = false;\n  bool isRValueReference = false;\n  bool isPointer = false;\n  if (const LValueReferenceType *FnTypeRef =\n        FnType->getAs<LValueReferenceType>()) {\n    FnType = FnTypeRef->getPointeeType();\n    isLValueReference = true;\n  } else if (const RValueReferenceType *FnTypeRef =\n               FnType->getAs<RValueReferenceType>()) {\n    FnType = FnTypeRef->getPointeeType();\n    isRValueReference = true;\n  }\n  if (const PointerType *FnTypePtr = FnType->getAs<PointerType>()) {\n    FnType = FnTypePtr->getPointeeType();\n    isPointer = true;\n  }\n  // Desugar down to a function type.\n  FnType = QualType(FnType->getAs<FunctionType>(), 0);\n  // Reconstruct the pointer/reference as appropriate.\n  if (isPointer) FnType = S.Context.getPointerType(FnType);\n  if (isRValueReference) FnType = S.Context.getRValueReferenceType(FnType);\n  if (isLValueReference) FnType = S.Context.getLValueReferenceType(FnType);\n\n  S.Diag(Cand->Surrogate->getLocation(), diag::note_ovl_surrogate_cand)\n    << FnType;\n}\n\nstatic void NoteBuiltinOperatorCandidate(Sema &S, StringRef Opc,\n                                         SourceLocation OpLoc,\n                                         OverloadCandidate *Cand) {\n  assert(Cand->Conversions.size() <= 2 && \"builtin operator is not binary\");\n  std::string TypeStr(\"operator\");\n  TypeStr += Opc;\n  TypeStr += \"(\";\n  TypeStr += Cand->BuiltinParamTypes[0].getAsString();\n  if (Cand->Conversions.size() == 1) {\n    TypeStr += \")\";\n    S.Diag(OpLoc, diag::note_ovl_builtin_candidate) << TypeStr;\n  } else {\n    TypeStr += \", \";\n    TypeStr += Cand->BuiltinParamTypes[1].getAsString();\n    TypeStr += \")\";\n    S.Diag(OpLoc, diag::note_ovl_builtin_candidate) << TypeStr;\n  }\n}\n\nstatic void NoteAmbiguousUserConversions(Sema &S, SourceLocation OpLoc,\n                                         OverloadCandidate *Cand) {\n  for (const ImplicitConversionSequence &ICS : Cand->Conversions) {\n    if (ICS.isBad()) break; // all meaningless after first invalid\n    if (!ICS.isAmbiguous()) continue;\n\n    ICS.DiagnoseAmbiguousConversion(\n        S, OpLoc, S.PDiag(diag::note_ambiguous_type_conversion));\n  }\n}\n\nstatic SourceLocation GetLocationForCandidate(const OverloadCandidate *Cand) {\n  if (Cand->Function)\n    return Cand->Function->getLocation();\n  if (Cand->IsSurrogate)\n    return Cand->Surrogate->getLocation();\n  return SourceLocation();\n}\n\nstatic unsigned RankDeductionFailure(const DeductionFailureInfo &DFI) {\n  switch ((Sema::TemplateDeductionResult)DFI.Result) {\n  case Sema::TDK_Success:\n  case Sema::TDK_NonDependentConversionFailure:\n    llvm_unreachable(\"non-deduction failure while diagnosing bad deduction\");\n\n  case Sema::TDK_Invalid:\n  case Sema::TDK_Incomplete:\n  case Sema::TDK_IncompletePack:\n    return 1;\n\n  case Sema::TDK_Underqualified:\n  case Sema::TDK_Inconsistent:\n    return 2;\n\n  case Sema::TDK_SubstitutionFailure:\n  case Sema::TDK_DeducedMismatch:\n  case Sema::TDK_ConstraintsNotSatisfied:\n  case Sema::TDK_DeducedMismatchNested:\n  case Sema::TDK_NonDeducedMismatch:\n  case Sema::TDK_MiscellaneousDeductionFailure:\n  case Sema::TDK_CUDATargetMismatch:\n    return 3;\n\n  case Sema::TDK_InstantiationDepth:\n    return 4;\n\n  case Sema::TDK_InvalidExplicitArguments:\n    return 5;\n\n  case Sema::TDK_TooManyArguments:\n  case Sema::TDK_TooFewArguments:\n    return 6;\n  }\n  llvm_unreachable(\"Unhandled deduction result\");\n}\n\nnamespace {\nstruct CompareOverloadCandidatesForDisplay {\n  Sema &S;\n  SourceLocation Loc;\n  size_t NumArgs;\n  OverloadCandidateSet::CandidateSetKind CSK;\n\n  CompareOverloadCandidatesForDisplay(\n      Sema &S, SourceLocation Loc, size_t NArgs,\n      OverloadCandidateSet::CandidateSetKind CSK)\n      : S(S), NumArgs(NArgs), CSK(CSK) {}\n\n  OverloadFailureKind EffectiveFailureKind(const OverloadCandidate *C) const {\n    // If there are too many or too few arguments, that's the high-order bit we\n    // want to sort by, even if the immediate failure kind was something else.\n    if (C->FailureKind == ovl_fail_too_many_arguments ||\n        C->FailureKind == ovl_fail_too_few_arguments)\n      return static_cast<OverloadFailureKind>(C->FailureKind);\n\n    if (C->Function) {\n      if (NumArgs > C->Function->getNumParams() && !C->Function->isVariadic())\n        return ovl_fail_too_many_arguments;\n      if (NumArgs < C->Function->getMinRequiredArguments())\n        return ovl_fail_too_few_arguments;\n    }\n\n    return static_cast<OverloadFailureKind>(C->FailureKind);\n  }\n\n  bool operator()(const OverloadCandidate *L,\n                  const OverloadCandidate *R) {\n    // Fast-path this check.\n    if (L == R) return false;\n\n    // Order first by viability.\n    if (L->Viable) {\n      if (!R->Viable) return true;\n\n      // TODO: introduce a tri-valued comparison for overload\n      // candidates.  Would be more worthwhile if we had a sort\n      // that could exploit it.\n      if (isBetterOverloadCandidate(S, *L, *R, SourceLocation(), CSK))\n        return true;\n      if (isBetterOverloadCandidate(S, *R, *L, SourceLocation(), CSK))\n        return false;\n    } else if (R->Viable)\n      return false;\n\n    assert(L->Viable == R->Viable);\n\n    // Criteria by which we can sort non-viable candidates:\n    if (!L->Viable) {\n      OverloadFailureKind LFailureKind = EffectiveFailureKind(L);\n      OverloadFailureKind RFailureKind = EffectiveFailureKind(R);\n\n      // 1. Arity mismatches come after other candidates.\n      if (LFailureKind == ovl_fail_too_many_arguments ||\n          LFailureKind == ovl_fail_too_few_arguments) {\n        if (RFailureKind == ovl_fail_too_many_arguments ||\n            RFailureKind == ovl_fail_too_few_arguments) {\n          int LDist = std::abs((int)L->getNumParams() - (int)NumArgs);\n          int RDist = std::abs((int)R->getNumParams() - (int)NumArgs);\n          if (LDist == RDist) {\n            if (LFailureKind == RFailureKind)\n              // Sort non-surrogates before surrogates.\n              return !L->IsSurrogate && R->IsSurrogate;\n            // Sort candidates requiring fewer parameters than there were\n            // arguments given after candidates requiring more parameters\n            // than there were arguments given.\n            return LFailureKind == ovl_fail_too_many_arguments;\n          }\n          return LDist < RDist;\n        }\n        return false;\n      }\n      if (RFailureKind == ovl_fail_too_many_arguments ||\n          RFailureKind == ovl_fail_too_few_arguments)\n        return true;\n\n      // 2. Bad conversions come first and are ordered by the number\n      // of bad conversions and quality of good conversions.\n      if (LFailureKind == ovl_fail_bad_conversion) {\n        if (RFailureKind != ovl_fail_bad_conversion)\n          return true;\n\n        // The conversion that can be fixed with a smaller number of changes,\n        // comes first.\n        unsigned numLFixes = L->Fix.NumConversionsFixed;\n        unsigned numRFixes = R->Fix.NumConversionsFixed;\n        numLFixes = (numLFixes == 0) ? UINT_MAX : numLFixes;\n        numRFixes = (numRFixes == 0) ? UINT_MAX : numRFixes;\n        if (numLFixes != numRFixes) {\n          return numLFixes < numRFixes;\n        }\n\n        // If there's any ordering between the defined conversions...\n        // FIXME: this might not be transitive.\n        assert(L->Conversions.size() == R->Conversions.size());\n\n        int leftBetter = 0;\n        unsigned I = (L->IgnoreObjectArgument || R->IgnoreObjectArgument);\n        for (unsigned E = L->Conversions.size(); I != E; ++I) {\n          switch (CompareImplicitConversionSequences(S, Loc,\n                                                     L->Conversions[I],\n                                                     R->Conversions[I])) {\n          case ImplicitConversionSequence::Better:\n            leftBetter++;\n            break;\n\n          case ImplicitConversionSequence::Worse:\n            leftBetter--;\n            break;\n\n          case ImplicitConversionSequence::Indistinguishable:\n            break;\n          }\n        }\n        if (leftBetter > 0) return true;\n        if (leftBetter < 0) return false;\n\n      } else if (RFailureKind == ovl_fail_bad_conversion)\n        return false;\n\n      if (LFailureKind == ovl_fail_bad_deduction) {\n        if (RFailureKind != ovl_fail_bad_deduction)\n          return true;\n\n        if (L->DeductionFailure.Result != R->DeductionFailure.Result)\n          return RankDeductionFailure(L->DeductionFailure)\n               < RankDeductionFailure(R->DeductionFailure);\n      } else if (RFailureKind == ovl_fail_bad_deduction)\n        return false;\n\n      // TODO: others?\n    }\n\n    // Sort everything else by location.\n    SourceLocation LLoc = GetLocationForCandidate(L);\n    SourceLocation RLoc = GetLocationForCandidate(R);\n\n    // Put candidates without locations (e.g. builtins) at the end.\n    if (LLoc.isInvalid()) return false;\n    if (RLoc.isInvalid()) return true;\n\n    return S.SourceMgr.isBeforeInTranslationUnit(LLoc, RLoc);\n  }\n};\n}\n\n/// CompleteNonViableCandidate - Normally, overload resolution only\n/// computes up to the first bad conversion. Produces the FixIt set if\n/// possible.\nstatic void\nCompleteNonViableCandidate(Sema &S, OverloadCandidate *Cand,\n                           ArrayRef<Expr *> Args,\n                           OverloadCandidateSet::CandidateSetKind CSK) {\n  assert(!Cand->Viable);\n\n  // Don't do anything on failures other than bad conversion.\n  if (Cand->FailureKind != ovl_fail_bad_conversion)\n    return;\n\n  // We only want the FixIts if all the arguments can be corrected.\n  bool Unfixable = false;\n  // Use a implicit copy initialization to check conversion fixes.\n  Cand->Fix.setConversionChecker(TryCopyInitialization);\n\n  // Attempt to fix the bad conversion.\n  unsigned ConvCount = Cand->Conversions.size();\n  for (unsigned ConvIdx = (Cand->IgnoreObjectArgument ? 1 : 0); /**/;\n       ++ConvIdx) {\n    assert(ConvIdx != ConvCount && \"no bad conversion in candidate\");\n    if (Cand->Conversions[ConvIdx].isInitialized() &&\n        Cand->Conversions[ConvIdx].isBad()) {\n      Unfixable = !Cand->TryToFixBadConversion(ConvIdx, S);\n      break;\n    }\n  }\n\n  // FIXME: this should probably be preserved from the overload\n  // operation somehow.\n  bool SuppressUserConversions = false;\n\n  unsigned ConvIdx = 0;\n  unsigned ArgIdx = 0;\n  ArrayRef<QualType> ParamTypes;\n  bool Reversed = Cand->isReversed();\n\n  if (Cand->IsSurrogate) {\n    QualType ConvType\n      = Cand->Surrogate->getConversionType().getNonReferenceType();\n    if (const PointerType *ConvPtrType = ConvType->getAs<PointerType>())\n      ConvType = ConvPtrType->getPointeeType();\n    ParamTypes = ConvType->castAs<FunctionProtoType>()->getParamTypes();\n    // Conversion 0 is 'this', which doesn't have a corresponding parameter.\n    ConvIdx = 1;\n  } else if (Cand->Function) {\n    ParamTypes =\n        Cand->Function->getType()->castAs<FunctionProtoType>()->getParamTypes();\n    if (isa<CXXMethodDecl>(Cand->Function) &&\n        !isa<CXXConstructorDecl>(Cand->Function) && !Reversed) {\n      // Conversion 0 is 'this', which doesn't have a corresponding parameter.\n      ConvIdx = 1;\n      if (CSK == OverloadCandidateSet::CSK_Operator &&\n          Cand->Function->getDeclName().getCXXOverloadedOperator() != OO_Call)\n        // Argument 0 is 'this', which doesn't have a corresponding parameter.\n        ArgIdx = 1;\n    }\n  } else {\n    // Builtin operator.\n    assert(ConvCount <= 3);\n    ParamTypes = Cand->BuiltinParamTypes;\n  }\n\n  // Fill in the rest of the conversions.\n  for (unsigned ParamIdx = Reversed ? ParamTypes.size() - 1 : 0;\n       ConvIdx != ConvCount;\n       ++ConvIdx, ++ArgIdx, ParamIdx += (Reversed ? -1 : 1)) {\n    assert(ArgIdx < Args.size() && \"no argument for this arg conversion\");\n    if (Cand->Conversions[ConvIdx].isInitialized()) {\n      // We've already checked this conversion.\n    } else if (ParamIdx < ParamTypes.size()) {\n      if (ParamTypes[ParamIdx]->isDependentType())\n        Cand->Conversions[ConvIdx].setAsIdentityConversion(\n            Args[ArgIdx]->getType());\n      else {\n        Cand->Conversions[ConvIdx] =\n            TryCopyInitialization(S, Args[ArgIdx], ParamTypes[ParamIdx],\n                                  SuppressUserConversions,\n                                  /*InOverloadResolution=*/true,\n                                  /*AllowObjCWritebackConversion=*/\n                                  S.getLangOpts().ObjCAutoRefCount);\n        // Store the FixIt in the candidate if it exists.\n        if (!Unfixable && Cand->Conversions[ConvIdx].isBad())\n          Unfixable = !Cand->TryToFixBadConversion(ConvIdx, S);\n      }\n    } else\n      Cand->Conversions[ConvIdx].setEllipsis();\n  }\n}\n\nSmallVector<OverloadCandidate *, 32> OverloadCandidateSet::CompleteCandidates(\n    Sema &S, OverloadCandidateDisplayKind OCD, ArrayRef<Expr *> Args,\n    SourceLocation OpLoc,\n    llvm::function_ref<bool(OverloadCandidate &)> Filter) {\n  // Sort the candidates by viability and position.  Sorting directly would\n  // be prohibitive, so we make a set of pointers and sort those.\n  SmallVector<OverloadCandidate*, 32> Cands;\n  if (OCD == OCD_AllCandidates) Cands.reserve(size());\n  for (iterator Cand = begin(), LastCand = end(); Cand != LastCand; ++Cand) {\n    if (!Filter(*Cand))\n      continue;\n    switch (OCD) {\n    case OCD_AllCandidates:\n      if (!Cand->Viable) {\n        if (!Cand->Function && !Cand->IsSurrogate) {\n          // This a non-viable builtin candidate.  We do not, in general,\n          // want to list every possible builtin candidate.\n          continue;\n        }\n        CompleteNonViableCandidate(S, Cand, Args, Kind);\n      }\n      break;\n\n    case OCD_ViableCandidates:\n      if (!Cand->Viable)\n        continue;\n      break;\n\n    case OCD_AmbiguousCandidates:\n      if (!Cand->Best)\n        continue;\n      break;\n    }\n\n    Cands.push_back(Cand);\n  }\n\n  llvm::stable_sort(\n      Cands, CompareOverloadCandidatesForDisplay(S, OpLoc, Args.size(), Kind));\n\n  return Cands;\n}\n\nbool OverloadCandidateSet::shouldDeferDiags(Sema &S, ArrayRef<Expr *> Args,\n                                            SourceLocation OpLoc) {\n  bool DeferHint = false;\n  if (S.getLangOpts().CUDA && S.getLangOpts().GPUDeferDiag) {\n    // Defer diagnostic for CUDA/HIP if there are wrong-sided candidates or\n    // host device candidates.\n    auto WrongSidedCands =\n        CompleteCandidates(S, OCD_AllCandidates, Args, OpLoc, [](auto &Cand) {\n          return (Cand.Viable == false &&\n                  Cand.FailureKind == ovl_fail_bad_target) ||\n                 (Cand.Function->template hasAttr<CUDAHostAttr>() &&\n                  Cand.Function->template hasAttr<CUDADeviceAttr>());\n        });\n    DeferHint = !WrongSidedCands.empty();\n  }\n  return DeferHint;\n}\n\n/// When overload resolution fails, prints diagnostic messages containing the\n/// candidates in the candidate set.\nvoid OverloadCandidateSet::NoteCandidates(\n    PartialDiagnosticAt PD, Sema &S, OverloadCandidateDisplayKind OCD,\n    ArrayRef<Expr *> Args, StringRef Opc, SourceLocation OpLoc,\n    llvm::function_ref<bool(OverloadCandidate &)> Filter) {\n\n  auto Cands = CompleteCandidates(S, OCD, Args, OpLoc, Filter);\n\n  S.Diag(PD.first, PD.second, shouldDeferDiags(S, Args, OpLoc));\n\n  NoteCandidates(S, Args, Cands, Opc, OpLoc);\n\n  if (OCD == OCD_AmbiguousCandidates)\n    MaybeDiagnoseAmbiguousConstraints(S, {begin(), end()});\n}\n\nvoid OverloadCandidateSet::NoteCandidates(Sema &S, ArrayRef<Expr *> Args,\n                                          ArrayRef<OverloadCandidate *> Cands,\n                                          StringRef Opc, SourceLocation OpLoc) {\n  bool ReportedAmbiguousConversions = false;\n\n  const OverloadsShown ShowOverloads = S.Diags.getShowOverloads();\n  unsigned CandsShown = 0;\n  auto I = Cands.begin(), E = Cands.end();\n  for (; I != E; ++I) {\n    OverloadCandidate *Cand = *I;\n\n    if (CandsShown >= S.Diags.getNumOverloadCandidatesToShow() &&\n        ShowOverloads == Ovl_Best) {\n      break;\n    }\n    ++CandsShown;\n\n    if (Cand->Function)\n      NoteFunctionCandidate(S, Cand, Args.size(),\n                            /*TakingCandidateAddress=*/false, DestAS);\n    else if (Cand->IsSurrogate)\n      NoteSurrogateCandidate(S, Cand);\n    else {\n      assert(Cand->Viable &&\n             \"Non-viable built-in candidates are not added to Cands.\");\n      // Generally we only see ambiguities including viable builtin\n      // operators if overload resolution got screwed up by an\n      // ambiguous user-defined conversion.\n      //\n      // FIXME: It's quite possible for different conversions to see\n      // different ambiguities, though.\n      if (!ReportedAmbiguousConversions) {\n        NoteAmbiguousUserConversions(S, OpLoc, Cand);\n        ReportedAmbiguousConversions = true;\n      }\n\n      // If this is a viable builtin, print it.\n      NoteBuiltinOperatorCandidate(S, Opc, OpLoc, Cand);\n    }\n  }\n\n  // Inform S.Diags that we've shown an overload set with N elements.  This may\n  // inform the future value of S.Diags.getNumOverloadCandidatesToShow().\n  S.Diags.overloadCandidatesShown(CandsShown);\n\n  if (I != E)\n    S.Diag(OpLoc, diag::note_ovl_too_many_candidates,\n           shouldDeferDiags(S, Args, OpLoc))\n        << int(E - I);\n}\n\nstatic SourceLocation\nGetLocationForCandidate(const TemplateSpecCandidate *Cand) {\n  return Cand->Specialization ? Cand->Specialization->getLocation()\n                              : SourceLocation();\n}\n\nnamespace {\nstruct CompareTemplateSpecCandidatesForDisplay {\n  Sema &S;\n  CompareTemplateSpecCandidatesForDisplay(Sema &S) : S(S) {}\n\n  bool operator()(const TemplateSpecCandidate *L,\n                  const TemplateSpecCandidate *R) {\n    // Fast-path this check.\n    if (L == R)\n      return false;\n\n    // Assuming that both candidates are not matches...\n\n    // Sort by the ranking of deduction failures.\n    if (L->DeductionFailure.Result != R->DeductionFailure.Result)\n      return RankDeductionFailure(L->DeductionFailure) <\n             RankDeductionFailure(R->DeductionFailure);\n\n    // Sort everything else by location.\n    SourceLocation LLoc = GetLocationForCandidate(L);\n    SourceLocation RLoc = GetLocationForCandidate(R);\n\n    // Put candidates without locations (e.g. builtins) at the end.\n    if (LLoc.isInvalid())\n      return false;\n    if (RLoc.isInvalid())\n      return true;\n\n    return S.SourceMgr.isBeforeInTranslationUnit(LLoc, RLoc);\n  }\n};\n}\n\n/// Diagnose a template argument deduction failure.\n/// We are treating these failures as overload failures due to bad\n/// deductions.\nvoid TemplateSpecCandidate::NoteDeductionFailure(Sema &S,\n                                                 bool ForTakingAddress) {\n  DiagnoseBadDeduction(S, FoundDecl, Specialization, // pattern\n                       DeductionFailure, /*NumArgs=*/0, ForTakingAddress);\n}\n\nvoid TemplateSpecCandidateSet::destroyCandidates() {\n  for (iterator i = begin(), e = end(); i != e; ++i) {\n    i->DeductionFailure.Destroy();\n  }\n}\n\nvoid TemplateSpecCandidateSet::clear() {\n  destroyCandidates();\n  Candidates.clear();\n}\n\n/// NoteCandidates - When no template specialization match is found, prints\n/// diagnostic messages containing the non-matching specializations that form\n/// the candidate set.\n/// This is analoguous to OverloadCandidateSet::NoteCandidates() with\n/// OCD == OCD_AllCandidates and Cand->Viable == false.\nvoid TemplateSpecCandidateSet::NoteCandidates(Sema &S, SourceLocation Loc) {\n  // Sort the candidates by position (assuming no candidate is a match).\n  // Sorting directly would be prohibitive, so we make a set of pointers\n  // and sort those.\n  SmallVector<TemplateSpecCandidate *, 32> Cands;\n  Cands.reserve(size());\n  for (iterator Cand = begin(), LastCand = end(); Cand != LastCand; ++Cand) {\n    if (Cand->Specialization)\n      Cands.push_back(Cand);\n    // Otherwise, this is a non-matching builtin candidate.  We do not,\n    // in general, want to list every possible builtin candidate.\n  }\n\n  llvm::sort(Cands, CompareTemplateSpecCandidatesForDisplay(S));\n\n  // FIXME: Perhaps rename OverloadsShown and getShowOverloads()\n  // for generalization purposes (?).\n  const OverloadsShown ShowOverloads = S.Diags.getShowOverloads();\n\n  SmallVectorImpl<TemplateSpecCandidate *>::iterator I, E;\n  unsigned CandsShown = 0;\n  for (I = Cands.begin(), E = Cands.end(); I != E; ++I) {\n    TemplateSpecCandidate *Cand = *I;\n\n    // Set an arbitrary limit on the number of candidates we'll spam\n    // the user with.  FIXME: This limit should depend on details of the\n    // candidate list.\n    if (CandsShown >= 4 && ShowOverloads == Ovl_Best)\n      break;\n    ++CandsShown;\n\n    assert(Cand->Specialization &&\n           \"Non-matching built-in candidates are not added to Cands.\");\n    Cand->NoteDeductionFailure(S, ForTakingAddress);\n  }\n\n  if (I != E)\n    S.Diag(Loc, diag::note_ovl_too_many_candidates) << int(E - I);\n}\n\n// [PossiblyAFunctionType]  -->   [Return]\n// NonFunctionType --> NonFunctionType\n// R (A) --> R(A)\n// R (*)(A) --> R (A)\n// R (&)(A) --> R (A)\n// R (S::*)(A) --> R (A)\nQualType Sema::ExtractUnqualifiedFunctionType(QualType PossiblyAFunctionType) {\n  QualType Ret = PossiblyAFunctionType;\n  if (const PointerType *ToTypePtr =\n    PossiblyAFunctionType->getAs<PointerType>())\n    Ret = ToTypePtr->getPointeeType();\n  else if (const ReferenceType *ToTypeRef =\n    PossiblyAFunctionType->getAs<ReferenceType>())\n    Ret = ToTypeRef->getPointeeType();\n  else if (const MemberPointerType *MemTypePtr =\n    PossiblyAFunctionType->getAs<MemberPointerType>())\n    Ret = MemTypePtr->getPointeeType();\n  Ret =\n    Context.getCanonicalType(Ret).getUnqualifiedType();\n  return Ret;\n}\n\nstatic bool completeFunctionType(Sema &S, FunctionDecl *FD, SourceLocation Loc,\n                                 bool Complain = true) {\n  if (S.getLangOpts().CPlusPlus14 && FD->getReturnType()->isUndeducedType() &&\n      S.DeduceReturnType(FD, Loc, Complain))\n    return true;\n\n  auto *FPT = FD->getType()->castAs<FunctionProtoType>();\n  if (S.getLangOpts().CPlusPlus17 &&\n      isUnresolvedExceptionSpec(FPT->getExceptionSpecType()) &&\n      !S.ResolveExceptionSpec(Loc, FPT))\n    return true;\n\n  return false;\n}\n\nnamespace {\n// A helper class to help with address of function resolution\n// - allows us to avoid passing around all those ugly parameters\nclass AddressOfFunctionResolver {\n  Sema& S;\n  Expr* SourceExpr;\n  const QualType& TargetType;\n  QualType TargetFunctionType; // Extracted function type from target type\n\n  bool Complain;\n  //DeclAccessPair& ResultFunctionAccessPair;\n  ASTContext& Context;\n\n  bool TargetTypeIsNonStaticMemberFunction;\n  bool FoundNonTemplateFunction;\n  bool StaticMemberFunctionFromBoundPointer;\n  bool HasComplained;\n\n  OverloadExpr::FindResult OvlExprInfo;\n  OverloadExpr *OvlExpr;\n  TemplateArgumentListInfo OvlExplicitTemplateArgs;\n  SmallVector<std::pair<DeclAccessPair, FunctionDecl*>, 4> Matches;\n  TemplateSpecCandidateSet FailedCandidates;\n\npublic:\n  AddressOfFunctionResolver(Sema &S, Expr *SourceExpr,\n                            const QualType &TargetType, bool Complain)\n      : S(S), SourceExpr(SourceExpr), TargetType(TargetType),\n        Complain(Complain), Context(S.getASTContext()),\n        TargetTypeIsNonStaticMemberFunction(\n            !!TargetType->getAs<MemberPointerType>()),\n        FoundNonTemplateFunction(false),\n        StaticMemberFunctionFromBoundPointer(false),\n        HasComplained(false),\n        OvlExprInfo(OverloadExpr::find(SourceExpr)),\n        OvlExpr(OvlExprInfo.Expression),\n        FailedCandidates(OvlExpr->getNameLoc(), /*ForTakingAddress=*/true) {\n    ExtractUnqualifiedFunctionTypeFromTargetType();\n\n    if (TargetFunctionType->isFunctionType()) {\n      if (UnresolvedMemberExpr *UME = dyn_cast<UnresolvedMemberExpr>(OvlExpr))\n        if (!UME->isImplicitAccess() &&\n            !S.ResolveSingleFunctionTemplateSpecialization(UME))\n          StaticMemberFunctionFromBoundPointer = true;\n    } else if (OvlExpr->hasExplicitTemplateArgs()) {\n      DeclAccessPair dap;\n      if (FunctionDecl *Fn = S.ResolveSingleFunctionTemplateSpecialization(\n              OvlExpr, false, &dap)) {\n        if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(Fn))\n          if (!Method->isStatic()) {\n            // If the target type is a non-function type and the function found\n            // is a non-static member function, pretend as if that was the\n            // target, it's the only possible type to end up with.\n            TargetTypeIsNonStaticMemberFunction = true;\n\n            // And skip adding the function if its not in the proper form.\n            // We'll diagnose this due to an empty set of functions.\n            if (!OvlExprInfo.HasFormOfMemberPointer)\n              return;\n          }\n\n        Matches.push_back(std::make_pair(dap, Fn));\n      }\n      return;\n    }\n\n    if (OvlExpr->hasExplicitTemplateArgs())\n      OvlExpr->copyTemplateArgumentsInto(OvlExplicitTemplateArgs);\n\n    if (FindAllFunctionsThatMatchTargetTypeExactly()) {\n      // C++ [over.over]p4:\n      //   If more than one function is selected, [...]\n      if (Matches.size() > 1 && !eliminiateSuboptimalOverloadCandidates()) {\n        if (FoundNonTemplateFunction)\n          EliminateAllTemplateMatches();\n        else\n          EliminateAllExceptMostSpecializedTemplate();\n      }\n    }\n\n    if (S.getLangOpts().CUDA && Matches.size() > 1)\n      EliminateSuboptimalCudaMatches();\n  }\n\n  bool hasComplained() const { return HasComplained; }\n\nprivate:\n  bool candidateHasExactlyCorrectType(const FunctionDecl *FD) {\n    QualType Discard;\n    return Context.hasSameUnqualifiedType(TargetFunctionType, FD->getType()) ||\n           S.IsFunctionConversion(FD->getType(), TargetFunctionType, Discard);\n  }\n\n  /// \\return true if A is considered a better overload candidate for the\n  /// desired type than B.\n  bool isBetterCandidate(const FunctionDecl *A, const FunctionDecl *B) {\n    // If A doesn't have exactly the correct type, we don't want to classify it\n    // as \"better\" than anything else. This way, the user is required to\n    // disambiguate for us if there are multiple candidates and no exact match.\n    return candidateHasExactlyCorrectType(A) &&\n           (!candidateHasExactlyCorrectType(B) ||\n            compareEnableIfAttrs(S, A, B) == Comparison::Better);\n  }\n\n  /// \\return true if we were able to eliminate all but one overload candidate,\n  /// false otherwise.\n  bool eliminiateSuboptimalOverloadCandidates() {\n    // Same algorithm as overload resolution -- one pass to pick the \"best\",\n    // another pass to be sure that nothing is better than the best.\n    auto Best = Matches.begin();\n    for (auto I = Matches.begin()+1, E = Matches.end(); I != E; ++I)\n      if (isBetterCandidate(I->second, Best->second))\n        Best = I;\n\n    const FunctionDecl *BestFn = Best->second;\n    auto IsBestOrInferiorToBest = [this, BestFn](\n        const std::pair<DeclAccessPair, FunctionDecl *> &Pair) {\n      return BestFn == Pair.second || isBetterCandidate(BestFn, Pair.second);\n    };\n\n    // Note: We explicitly leave Matches unmodified if there isn't a clear best\n    // option, so we can potentially give the user a better error\n    if (!llvm::all_of(Matches, IsBestOrInferiorToBest))\n      return false;\n    Matches[0] = *Best;\n    Matches.resize(1);\n    return true;\n  }\n\n  bool isTargetTypeAFunction() const {\n    return TargetFunctionType->isFunctionType();\n  }\n\n  // [ToType]     [Return]\n\n  // R (*)(A) --> R (A), IsNonStaticMemberFunction = false\n  // R (&)(A) --> R (A), IsNonStaticMemberFunction = false\n  // R (S::*)(A) --> R (A), IsNonStaticMemberFunction = true\n  void inline ExtractUnqualifiedFunctionTypeFromTargetType() {\n    TargetFunctionType = S.ExtractUnqualifiedFunctionType(TargetType);\n  }\n\n  // return true if any matching specializations were found\n  bool AddMatchingTemplateFunction(FunctionTemplateDecl* FunctionTemplate,\n                                   const DeclAccessPair& CurAccessFunPair) {\n    if (CXXMethodDecl *Method\n              = dyn_cast<CXXMethodDecl>(FunctionTemplate->getTemplatedDecl())) {\n      // Skip non-static function templates when converting to pointer, and\n      // static when converting to member pointer.\n      if (Method->isStatic() == TargetTypeIsNonStaticMemberFunction)\n        return false;\n    }\n    else if (TargetTypeIsNonStaticMemberFunction)\n      return false;\n\n    // C++ [over.over]p2:\n    //   If the name is a function template, template argument deduction is\n    //   done (14.8.2.2), and if the argument deduction succeeds, the\n    //   resulting template argument list is used to generate a single\n    //   function template specialization, which is added to the set of\n    //   overloaded functions considered.\n    FunctionDecl *Specialization = nullptr;\n    TemplateDeductionInfo Info(FailedCandidates.getLocation());\n    if (Sema::TemplateDeductionResult Result\n          = S.DeduceTemplateArguments(FunctionTemplate,\n                                      &OvlExplicitTemplateArgs,\n                                      TargetFunctionType, Specialization,\n                                      Info, /*IsAddressOfFunction*/true)) {\n      // Make a note of the failed deduction for diagnostics.\n      FailedCandidates.addCandidate()\n          .set(CurAccessFunPair, FunctionTemplate->getTemplatedDecl(),\n               MakeDeductionFailureInfo(Context, Result, Info));\n      return false;\n    }\n\n    // Template argument deduction ensures that we have an exact match or\n    // compatible pointer-to-function arguments that would be adjusted by ICS.\n    // This function template specicalization works.\n    assert(S.isSameOrCompatibleFunctionType(\n              Context.getCanonicalType(Specialization->getType()),\n              Context.getCanonicalType(TargetFunctionType)));\n\n    if (!S.checkAddressOfFunctionIsAvailable(Specialization))\n      return false;\n\n    Matches.push_back(std::make_pair(CurAccessFunPair, Specialization));\n    return true;\n  }\n\n  bool AddMatchingNonTemplateFunction(NamedDecl* Fn,\n                                      const DeclAccessPair& CurAccessFunPair) {\n    if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(Fn)) {\n      // Skip non-static functions when converting to pointer, and static\n      // when converting to member pointer.\n      if (Method->isStatic() == TargetTypeIsNonStaticMemberFunction)\n        return false;\n    }\n    else if (TargetTypeIsNonStaticMemberFunction)\n      return false;\n\n    if (FunctionDecl *FunDecl = dyn_cast<FunctionDecl>(Fn)) {\n      if (S.getLangOpts().CUDA)\n        if (FunctionDecl *Caller = dyn_cast<FunctionDecl>(S.CurContext))\n          if (!Caller->isImplicit() && !S.IsAllowedCUDACall(Caller, FunDecl))\n            return false;\n      if (FunDecl->isMultiVersion()) {\n        const auto *TA = FunDecl->getAttr<TargetAttr>();\n        if (TA && !TA->isDefaultVersion())\n          return false;\n      }\n\n      // If any candidate has a placeholder return type, trigger its deduction\n      // now.\n      if (completeFunctionType(S, FunDecl, SourceExpr->getBeginLoc(),\n                               Complain)) {\n        HasComplained |= Complain;\n        return false;\n      }\n\n      if (!S.checkAddressOfFunctionIsAvailable(FunDecl))\n        return false;\n\n      // If we're in C, we need to support types that aren't exactly identical.\n      if (!S.getLangOpts().CPlusPlus ||\n          candidateHasExactlyCorrectType(FunDecl)) {\n        Matches.push_back(std::make_pair(\n            CurAccessFunPair, cast<FunctionDecl>(FunDecl->getCanonicalDecl())));\n        FoundNonTemplateFunction = true;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  bool FindAllFunctionsThatMatchTargetTypeExactly() {\n    bool Ret = false;\n\n    // If the overload expression doesn't have the form of a pointer to\n    // member, don't try to convert it to a pointer-to-member type.\n    if (IsInvalidFormOfPointerToMemberFunction())\n      return false;\n\n    for (UnresolvedSetIterator I = OvlExpr->decls_begin(),\n                               E = OvlExpr->decls_end();\n         I != E; ++I) {\n      // Look through any using declarations to find the underlying function.\n      NamedDecl *Fn = (*I)->getUnderlyingDecl();\n\n      // C++ [over.over]p3:\n      //   Non-member functions and static member functions match\n      //   targets of type \"pointer-to-function\" or \"reference-to-function.\"\n      //   Nonstatic member functions match targets of\n      //   type \"pointer-to-member-function.\"\n      // Note that according to DR 247, the containing class does not matter.\n      if (FunctionTemplateDecl *FunctionTemplate\n                                        = dyn_cast<FunctionTemplateDecl>(Fn)) {\n        if (AddMatchingTemplateFunction(FunctionTemplate, I.getPair()))\n          Ret = true;\n      }\n      // If we have explicit template arguments supplied, skip non-templates.\n      else if (!OvlExpr->hasExplicitTemplateArgs() &&\n               AddMatchingNonTemplateFunction(Fn, I.getPair()))\n        Ret = true;\n    }\n    assert(Ret || Matches.empty());\n    return Ret;\n  }\n\n  void EliminateAllExceptMostSpecializedTemplate() {\n    //   [...] and any given function template specialization F1 is\n    //   eliminated if the set contains a second function template\n    //   specialization whose function template is more specialized\n    //   than the function template of F1 according to the partial\n    //   ordering rules of 14.5.5.2.\n\n    // The algorithm specified above is quadratic. We instead use a\n    // two-pass algorithm (similar to the one used to identify the\n    // best viable function in an overload set) that identifies the\n    // best function template (if it exists).\n\n    UnresolvedSet<4> MatchesCopy; // TODO: avoid!\n    for (unsigned I = 0, E = Matches.size(); I != E; ++I)\n      MatchesCopy.addDecl(Matches[I].second, Matches[I].first.getAccess());\n\n    // TODO: It looks like FailedCandidates does not serve much purpose\n    // here, since the no_viable diagnostic has index 0.\n    UnresolvedSetIterator Result = S.getMostSpecialized(\n        MatchesCopy.begin(), MatchesCopy.end(), FailedCandidates,\n        SourceExpr->getBeginLoc(), S.PDiag(),\n        S.PDiag(diag::err_addr_ovl_ambiguous)\n            << Matches[0].second->getDeclName(),\n        S.PDiag(diag::note_ovl_candidate)\n            << (unsigned)oc_function << (unsigned)ocs_described_template,\n        Complain, TargetFunctionType);\n\n    if (Result != MatchesCopy.end()) {\n      // Make it the first and only element\n      Matches[0].first = Matches[Result - MatchesCopy.begin()].first;\n      Matches[0].second = cast<FunctionDecl>(*Result);\n      Matches.resize(1);\n    } else\n      HasComplained |= Complain;\n  }\n\n  void EliminateAllTemplateMatches() {\n    //   [...] any function template specializations in the set are\n    //   eliminated if the set also contains a non-template function, [...]\n    for (unsigned I = 0, N = Matches.size(); I != N; ) {\n      if (Matches[I].second->getPrimaryTemplate() == nullptr)\n        ++I;\n      else {\n        Matches[I] = Matches[--N];\n        Matches.resize(N);\n      }\n    }\n  }\n\n  void EliminateSuboptimalCudaMatches() {\n    S.EraseUnwantedCUDAMatches(dyn_cast<FunctionDecl>(S.CurContext), Matches);\n  }\n\npublic:\n  void ComplainNoMatchesFound() const {\n    assert(Matches.empty());\n    S.Diag(OvlExpr->getBeginLoc(), diag::err_addr_ovl_no_viable)\n        << OvlExpr->getName() << TargetFunctionType\n        << OvlExpr->getSourceRange();\n    if (FailedCandidates.empty())\n      S.NoteAllOverloadCandidates(OvlExpr, TargetFunctionType,\n                                  /*TakingAddress=*/true);\n    else {\n      // We have some deduction failure messages. Use them to diagnose\n      // the function templates, and diagnose the non-template candidates\n      // normally.\n      for (UnresolvedSetIterator I = OvlExpr->decls_begin(),\n                                 IEnd = OvlExpr->decls_end();\n           I != IEnd; ++I)\n        if (FunctionDecl *Fun =\n                dyn_cast<FunctionDecl>((*I)->getUnderlyingDecl()))\n          if (!functionHasPassObjectSizeParams(Fun))\n            S.NoteOverloadCandidate(*I, Fun, CRK_None, TargetFunctionType,\n                                    /*TakingAddress=*/true);\n      FailedCandidates.NoteCandidates(S, OvlExpr->getBeginLoc());\n    }\n  }\n\n  bool IsInvalidFormOfPointerToMemberFunction() const {\n    return TargetTypeIsNonStaticMemberFunction &&\n      !OvlExprInfo.HasFormOfMemberPointer;\n  }\n\n  void ComplainIsInvalidFormOfPointerToMemberFunction() const {\n      // TODO: Should we condition this on whether any functions might\n      // have matched, or is it more appropriate to do that in callers?\n      // TODO: a fixit wouldn't hurt.\n      S.Diag(OvlExpr->getNameLoc(), diag::err_addr_ovl_no_qualifier)\n        << TargetType << OvlExpr->getSourceRange();\n  }\n\n  bool IsStaticMemberFunctionFromBoundPointer() const {\n    return StaticMemberFunctionFromBoundPointer;\n  }\n\n  void ComplainIsStaticMemberFunctionFromBoundPointer() const {\n    S.Diag(OvlExpr->getBeginLoc(),\n           diag::err_invalid_form_pointer_member_function)\n        << OvlExpr->getSourceRange();\n  }\n\n  void ComplainOfInvalidConversion() const {\n    S.Diag(OvlExpr->getBeginLoc(), diag::err_addr_ovl_not_func_ptrref)\n        << OvlExpr->getName() << TargetType;\n  }\n\n  void ComplainMultipleMatchesFound() const {\n    assert(Matches.size() > 1);\n    S.Diag(OvlExpr->getBeginLoc(), diag::err_addr_ovl_ambiguous)\n        << OvlExpr->getName() << OvlExpr->getSourceRange();\n    S.NoteAllOverloadCandidates(OvlExpr, TargetFunctionType,\n                                /*TakingAddress=*/true);\n  }\n\n  bool hadMultipleCandidates() const { return (OvlExpr->getNumDecls() > 1); }\n\n  int getNumMatches() const { return Matches.size(); }\n\n  FunctionDecl* getMatchingFunctionDecl() const {\n    if (Matches.size() != 1) return nullptr;\n    return Matches[0].second;\n  }\n\n  const DeclAccessPair* getMatchingFunctionAccessPair() const {\n    if (Matches.size() != 1) return nullptr;\n    return &Matches[0].first;\n  }\n};\n}\n\n/// ResolveAddressOfOverloadedFunction - Try to resolve the address of\n/// an overloaded function (C++ [over.over]), where @p From is an\n/// expression with overloaded function type and @p ToType is the type\n/// we're trying to resolve to. For example:\n///\n/// @code\n/// int f(double);\n/// int f(int);\n///\n/// int (*pfd)(double) = f; // selects f(double)\n/// @endcode\n///\n/// This routine returns the resulting FunctionDecl if it could be\n/// resolved, and NULL otherwise. When @p Complain is true, this\n/// routine will emit diagnostics if there is an error.\nFunctionDecl *\nSema::ResolveAddressOfOverloadedFunction(Expr *AddressOfExpr,\n                                         QualType TargetType,\n                                         bool Complain,\n                                         DeclAccessPair &FoundResult,\n                                         bool *pHadMultipleCandidates) {\n  assert(AddressOfExpr->getType() == Context.OverloadTy);\n\n  AddressOfFunctionResolver Resolver(*this, AddressOfExpr, TargetType,\n                                     Complain);\n  int NumMatches = Resolver.getNumMatches();\n  FunctionDecl *Fn = nullptr;\n  bool ShouldComplain = Complain && !Resolver.hasComplained();\n  if (NumMatches == 0 && ShouldComplain) {\n    if (Resolver.IsInvalidFormOfPointerToMemberFunction())\n      Resolver.ComplainIsInvalidFormOfPointerToMemberFunction();\n    else\n      Resolver.ComplainNoMatchesFound();\n  }\n  else if (NumMatches > 1 && ShouldComplain)\n    Resolver.ComplainMultipleMatchesFound();\n  else if (NumMatches == 1) {\n    Fn = Resolver.getMatchingFunctionDecl();\n    assert(Fn);\n    if (auto *FPT = Fn->getType()->getAs<FunctionProtoType>())\n      ResolveExceptionSpec(AddressOfExpr->getExprLoc(), FPT);\n    FoundResult = *Resolver.getMatchingFunctionAccessPair();\n    if (Complain) {\n      if (Resolver.IsStaticMemberFunctionFromBoundPointer())\n        Resolver.ComplainIsStaticMemberFunctionFromBoundPointer();\n      else\n        CheckAddressOfMemberAccess(AddressOfExpr, FoundResult);\n    }\n  }\n\n  if (pHadMultipleCandidates)\n    *pHadMultipleCandidates = Resolver.hadMultipleCandidates();\n  return Fn;\n}\n\n/// Given an expression that refers to an overloaded function, try to\n/// resolve that function to a single function that can have its address taken.\n/// This will modify `Pair` iff it returns non-null.\n///\n/// This routine can only succeed if from all of the candidates in the overload\n/// set for SrcExpr that can have their addresses taken, there is one candidate\n/// that is more constrained than the rest.\nFunctionDecl *\nSema::resolveAddressOfSingleOverloadCandidate(Expr *E, DeclAccessPair &Pair) {\n  OverloadExpr::FindResult R = OverloadExpr::find(E);\n  OverloadExpr *Ovl = R.Expression;\n  bool IsResultAmbiguous = false;\n  FunctionDecl *Result = nullptr;\n  DeclAccessPair DAP;\n  SmallVector<FunctionDecl *, 2> AmbiguousDecls;\n\n  auto CheckMoreConstrained =\n      [&] (FunctionDecl *FD1, FunctionDecl *FD2) -> Optional<bool> {\n        SmallVector<const Expr *, 1> AC1, AC2;\n        FD1->getAssociatedConstraints(AC1);\n        FD2->getAssociatedConstraints(AC2);\n        bool AtLeastAsConstrained1, AtLeastAsConstrained2;\n        if (IsAtLeastAsConstrained(FD1, AC1, FD2, AC2, AtLeastAsConstrained1))\n          return None;\n        if (IsAtLeastAsConstrained(FD2, AC2, FD1, AC1, AtLeastAsConstrained2))\n          return None;\n        if (AtLeastAsConstrained1 == AtLeastAsConstrained2)\n          return None;\n        return AtLeastAsConstrained1;\n      };\n\n  // Don't use the AddressOfResolver because we're specifically looking for\n  // cases where we have one overload candidate that lacks\n  // enable_if/pass_object_size/...\n  for (auto I = Ovl->decls_begin(), E = Ovl->decls_end(); I != E; ++I) {\n    auto *FD = dyn_cast<FunctionDecl>(I->getUnderlyingDecl());\n    if (!FD)\n      return nullptr;\n\n    if (!checkAddressOfFunctionIsAvailable(FD))\n      continue;\n\n    // We have more than one result - see if it is more constrained than the\n    // previous one.\n    if (Result) {\n      Optional<bool> MoreConstrainedThanPrevious = CheckMoreConstrained(FD,\n                                                                        Result);\n      if (!MoreConstrainedThanPrevious) {\n        IsResultAmbiguous = true;\n        AmbiguousDecls.push_back(FD);\n        continue;\n      }\n      if (!*MoreConstrainedThanPrevious)\n        continue;\n      // FD is more constrained - replace Result with it.\n    }\n    IsResultAmbiguous = false;\n    DAP = I.getPair();\n    Result = FD;\n  }\n\n  if (IsResultAmbiguous)\n    return nullptr;\n\n  if (Result) {\n    SmallVector<const Expr *, 1> ResultAC;\n    // We skipped over some ambiguous declarations which might be ambiguous with\n    // the selected result.\n    for (FunctionDecl *Skipped : AmbiguousDecls)\n      if (!CheckMoreConstrained(Skipped, Result).hasValue())\n        return nullptr;\n    Pair = DAP;\n  }\n  return Result;\n}\n\n/// Given an overloaded function, tries to turn it into a non-overloaded\n/// function reference using resolveAddressOfSingleOverloadCandidate. This\n/// will perform access checks, diagnose the use of the resultant decl, and, if\n/// requested, potentially perform a function-to-pointer decay.\n///\n/// Returns false if resolveAddressOfSingleOverloadCandidate fails.\n/// Otherwise, returns true. This may emit diagnostics and return true.\nbool Sema::resolveAndFixAddressOfSingleOverloadCandidate(\n    ExprResult &SrcExpr, bool DoFunctionPointerConverion) {\n  Expr *E = SrcExpr.get();\n  assert(E->getType() == Context.OverloadTy && \"SrcExpr must be an overload\");\n\n  DeclAccessPair DAP;\n  FunctionDecl *Found = resolveAddressOfSingleOverloadCandidate(E, DAP);\n  if (!Found || Found->isCPUDispatchMultiVersion() ||\n      Found->isCPUSpecificMultiVersion())\n    return false;\n\n  // Emitting multiple diagnostics for a function that is both inaccessible and\n  // unavailable is consistent with our behavior elsewhere. So, always check\n  // for both.\n  DiagnoseUseOfDecl(Found, E->getExprLoc());\n  CheckAddressOfMemberAccess(E, DAP);\n  Expr *Fixed = FixOverloadedFunctionReference(E, DAP, Found);\n  if (DoFunctionPointerConverion && Fixed->getType()->isFunctionType())\n    SrcExpr = DefaultFunctionArrayConversion(Fixed, /*Diagnose=*/false);\n  else\n    SrcExpr = Fixed;\n  return true;\n}\n\n/// Given an expression that refers to an overloaded function, try to\n/// resolve that overloaded function expression down to a single function.\n///\n/// This routine can only resolve template-ids that refer to a single function\n/// template, where that template-id refers to a single template whose template\n/// arguments are either provided by the template-id or have defaults,\n/// as described in C++0x [temp.arg.explicit]p3.\n///\n/// If no template-ids are found, no diagnostics are emitted and NULL is\n/// returned.\nFunctionDecl *\nSema::ResolveSingleFunctionTemplateSpecialization(OverloadExpr *ovl,\n                                                  bool Complain,\n                                                  DeclAccessPair *FoundResult) {\n  // C++ [over.over]p1:\n  //   [...] [Note: any redundant set of parentheses surrounding the\n  //   overloaded function name is ignored (5.1). ]\n  // C++ [over.over]p1:\n  //   [...] The overloaded function name can be preceded by the &\n  //   operator.\n\n  // If we didn't actually find any template-ids, we're done.\n  if (!ovl->hasExplicitTemplateArgs())\n    return nullptr;\n\n  TemplateArgumentListInfo ExplicitTemplateArgs;\n  ovl->copyTemplateArgumentsInto(ExplicitTemplateArgs);\n  TemplateSpecCandidateSet FailedCandidates(ovl->getNameLoc());\n\n  // Look through all of the overloaded functions, searching for one\n  // whose type matches exactly.\n  FunctionDecl *Matched = nullptr;\n  for (UnresolvedSetIterator I = ovl->decls_begin(),\n         E = ovl->decls_end(); I != E; ++I) {\n    // C++0x [temp.arg.explicit]p3:\n    //   [...] In contexts where deduction is done and fails, or in contexts\n    //   where deduction is not done, if a template argument list is\n    //   specified and it, along with any default template arguments,\n    //   identifies a single function template specialization, then the\n    //   template-id is an lvalue for the function template specialization.\n    FunctionTemplateDecl *FunctionTemplate\n      = cast<FunctionTemplateDecl>((*I)->getUnderlyingDecl());\n\n    // C++ [over.over]p2:\n    //   If the name is a function template, template argument deduction is\n    //   done (14.8.2.2), and if the argument deduction succeeds, the\n    //   resulting template argument list is used to generate a single\n    //   function template specialization, which is added to the set of\n    //   overloaded functions considered.\n    FunctionDecl *Specialization = nullptr;\n    TemplateDeductionInfo Info(FailedCandidates.getLocation());\n    if (TemplateDeductionResult Result\n          = DeduceTemplateArguments(FunctionTemplate, &ExplicitTemplateArgs,\n                                    Specialization, Info,\n                                    /*IsAddressOfFunction*/true)) {\n      // Make a note of the failed deduction for diagnostics.\n      // TODO: Actually use the failed-deduction info?\n      FailedCandidates.addCandidate()\n          .set(I.getPair(), FunctionTemplate->getTemplatedDecl(),\n               MakeDeductionFailureInfo(Context, Result, Info));\n      continue;\n    }\n\n    assert(Specialization && \"no specialization and no error?\");\n\n    // Multiple matches; we can't resolve to a single declaration.\n    if (Matched) {\n      if (Complain) {\n        Diag(ovl->getExprLoc(), diag::err_addr_ovl_ambiguous)\n          << ovl->getName();\n        NoteAllOverloadCandidates(ovl);\n      }\n      return nullptr;\n    }\n\n    Matched = Specialization;\n    if (FoundResult) *FoundResult = I.getPair();\n  }\n\n  if (Matched &&\n      completeFunctionType(*this, Matched, ovl->getExprLoc(), Complain))\n    return nullptr;\n\n  return Matched;\n}\n\n// Resolve and fix an overloaded expression that can be resolved\n// because it identifies a single function template specialization.\n//\n// Last three arguments should only be supplied if Complain = true\n//\n// Return true if it was logically possible to so resolve the\n// expression, regardless of whether or not it succeeded.  Always\n// returns true if 'complain' is set.\nbool Sema::ResolveAndFixSingleFunctionTemplateSpecialization(\n                      ExprResult &SrcExpr, bool doFunctionPointerConverion,\n                      bool complain, SourceRange OpRangeForComplaining,\n                                           QualType DestTypeForComplaining,\n                                            unsigned DiagIDForComplaining) {\n  assert(SrcExpr.get()->getType() == Context.OverloadTy);\n\n  OverloadExpr::FindResult ovl = OverloadExpr::find(SrcExpr.get());\n\n  DeclAccessPair found;\n  ExprResult SingleFunctionExpression;\n  if (FunctionDecl *fn = ResolveSingleFunctionTemplateSpecialization(\n                           ovl.Expression, /*complain*/ false, &found)) {\n    if (DiagnoseUseOfDecl(fn, SrcExpr.get()->getBeginLoc())) {\n      SrcExpr = ExprError();\n      return true;\n    }\n\n    // It is only correct to resolve to an instance method if we're\n    // resolving a form that's permitted to be a pointer to member.\n    // Otherwise we'll end up making a bound member expression, which\n    // is illegal in all the contexts we resolve like this.\n    if (!ovl.HasFormOfMemberPointer &&\n        isa<CXXMethodDecl>(fn) &&\n        cast<CXXMethodDecl>(fn)->isInstance()) {\n      if (!complain) return false;\n\n      Diag(ovl.Expression->getExprLoc(),\n           diag::err_bound_member_function)\n        << 0 << ovl.Expression->getSourceRange();\n\n      // TODO: I believe we only end up here if there's a mix of\n      // static and non-static candidates (otherwise the expression\n      // would have 'bound member' type, not 'overload' type).\n      // Ideally we would note which candidate was chosen and why\n      // the static candidates were rejected.\n      SrcExpr = ExprError();\n      return true;\n    }\n\n    // Fix the expression to refer to 'fn'.\n    SingleFunctionExpression =\n        FixOverloadedFunctionReference(SrcExpr.get(), found, fn);\n\n    // If desired, do function-to-pointer decay.\n    if (doFunctionPointerConverion) {\n      SingleFunctionExpression =\n        DefaultFunctionArrayLvalueConversion(SingleFunctionExpression.get());\n      if (SingleFunctionExpression.isInvalid()) {\n        SrcExpr = ExprError();\n        return true;\n      }\n    }\n  }\n\n  if (!SingleFunctionExpression.isUsable()) {\n    if (complain) {\n      Diag(OpRangeForComplaining.getBegin(), DiagIDForComplaining)\n        << ovl.Expression->getName()\n        << DestTypeForComplaining\n        << OpRangeForComplaining\n        << ovl.Expression->getQualifierLoc().getSourceRange();\n      NoteAllOverloadCandidates(SrcExpr.get());\n\n      SrcExpr = ExprError();\n      return true;\n    }\n\n    return false;\n  }\n\n  SrcExpr = SingleFunctionExpression;\n  return true;\n}\n\n/// Add a single candidate to the overload set.\nstatic void AddOverloadedCallCandidate(Sema &S,\n                                       DeclAccessPair FoundDecl,\n                                 TemplateArgumentListInfo *ExplicitTemplateArgs,\n                                       ArrayRef<Expr *> Args,\n                                       OverloadCandidateSet &CandidateSet,\n                                       bool PartialOverloading,\n                                       bool KnownValid) {\n  NamedDecl *Callee = FoundDecl.getDecl();\n  if (isa<UsingShadowDecl>(Callee))\n    Callee = cast<UsingShadowDecl>(Callee)->getTargetDecl();\n\n  if (FunctionDecl *Func = dyn_cast<FunctionDecl>(Callee)) {\n    if (ExplicitTemplateArgs) {\n      assert(!KnownValid && \"Explicit template arguments?\");\n      return;\n    }\n    // Prevent ill-formed function decls to be added as overload candidates.\n    if (!dyn_cast<FunctionProtoType>(Func->getType()->getAs<FunctionType>()))\n      return;\n\n    S.AddOverloadCandidate(Func, FoundDecl, Args, CandidateSet,\n                           /*SuppressUserConversions=*/false,\n                           PartialOverloading);\n    return;\n  }\n\n  if (FunctionTemplateDecl *FuncTemplate\n      = dyn_cast<FunctionTemplateDecl>(Callee)) {\n    S.AddTemplateOverloadCandidate(FuncTemplate, FoundDecl,\n                                   ExplicitTemplateArgs, Args, CandidateSet,\n                                   /*SuppressUserConversions=*/false,\n                                   PartialOverloading);\n    return;\n  }\n\n  assert(!KnownValid && \"unhandled case in overloaded call candidate\");\n}\n\n/// Add the overload candidates named by callee and/or found by argument\n/// dependent lookup to the given overload set.\nvoid Sema::AddOverloadedCallCandidates(UnresolvedLookupExpr *ULE,\n                                       ArrayRef<Expr *> Args,\n                                       OverloadCandidateSet &CandidateSet,\n                                       bool PartialOverloading) {\n\n#ifndef NDEBUG\n  // Verify that ArgumentDependentLookup is consistent with the rules\n  // in C++0x [basic.lookup.argdep]p3:\n  //\n  //   Let X be the lookup set produced by unqualified lookup (3.4.1)\n  //   and let Y be the lookup set produced by argument dependent\n  //   lookup (defined as follows). If X contains\n  //\n  //     -- a declaration of a class member, or\n  //\n  //     -- a block-scope function declaration that is not a\n  //        using-declaration, or\n  //\n  //     -- a declaration that is neither a function or a function\n  //        template\n  //\n  //   then Y is empty.\n\n  if (ULE->requiresADL()) {\n    for (UnresolvedLookupExpr::decls_iterator I = ULE->decls_begin(),\n           E = ULE->decls_end(); I != E; ++I) {\n      assert(!(*I)->getDeclContext()->isRecord());\n      assert(isa<UsingShadowDecl>(*I) ||\n             !(*I)->getDeclContext()->isFunctionOrMethod());\n      assert((*I)->getUnderlyingDecl()->isFunctionOrFunctionTemplate());\n    }\n  }\n#endif\n\n  // It would be nice to avoid this copy.\n  TemplateArgumentListInfo TABuffer;\n  TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr;\n  if (ULE->hasExplicitTemplateArgs()) {\n    ULE->copyTemplateArgumentsInto(TABuffer);\n    ExplicitTemplateArgs = &TABuffer;\n  }\n\n  for (UnresolvedLookupExpr::decls_iterator I = ULE->decls_begin(),\n         E = ULE->decls_end(); I != E; ++I)\n    AddOverloadedCallCandidate(*this, I.getPair(), ExplicitTemplateArgs, Args,\n                               CandidateSet, PartialOverloading,\n                               /*KnownValid*/ true);\n\n  if (ULE->requiresADL())\n    AddArgumentDependentLookupCandidates(ULE->getName(), ULE->getExprLoc(),\n                                         Args, ExplicitTemplateArgs,\n                                         CandidateSet, PartialOverloading);\n}\n\n/// Add the call candidates from the given set of lookup results to the given\n/// overload set. Non-function lookup results are ignored.\nvoid Sema::AddOverloadedCallCandidates(\n    LookupResult &R, TemplateArgumentListInfo *ExplicitTemplateArgs,\n    ArrayRef<Expr *> Args, OverloadCandidateSet &CandidateSet) {\n  for (LookupResult::iterator I = R.begin(), E = R.end(); I != E; ++I)\n    AddOverloadedCallCandidate(*this, I.getPair(), ExplicitTemplateArgs, Args,\n                               CandidateSet, false, /*KnownValid*/ false);\n}\n\n/// Determine whether a declaration with the specified name could be moved into\n/// a different namespace.\nstatic bool canBeDeclaredInNamespace(const DeclarationName &Name) {\n  switch (Name.getCXXOverloadedOperator()) {\n  case OO_New: case OO_Array_New:\n  case OO_Delete: case OO_Array_Delete:\n    return false;\n\n  default:\n    return true;\n  }\n}\n\n/// Attempt to recover from an ill-formed use of a non-dependent name in a\n/// template, where the non-dependent name was declared after the template\n/// was defined. This is common in code written for a compilers which do not\n/// correctly implement two-stage name lookup.\n///\n/// Returns true if a viable candidate was found and a diagnostic was issued.\nstatic bool DiagnoseTwoPhaseLookup(\n    Sema &SemaRef, SourceLocation FnLoc, const CXXScopeSpec &SS,\n    LookupResult &R, OverloadCandidateSet::CandidateSetKind CSK,\n    TemplateArgumentListInfo *ExplicitTemplateArgs, ArrayRef<Expr *> Args,\n    CXXRecordDecl **FoundInClass = nullptr) {\n  if (!SemaRef.inTemplateInstantiation() || !SS.isEmpty())\n    return false;\n\n  for (DeclContext *DC = SemaRef.CurContext; DC; DC = DC->getParent()) {\n    if (DC->isTransparentContext())\n      continue;\n\n    SemaRef.LookupQualifiedName(R, DC);\n\n    if (!R.empty()) {\n      R.suppressDiagnostics();\n\n      OverloadCandidateSet Candidates(FnLoc, CSK);\n      SemaRef.AddOverloadedCallCandidates(R, ExplicitTemplateArgs, Args,\n                                          Candidates);\n\n      OverloadCandidateSet::iterator Best;\n      OverloadingResult OR =\n          Candidates.BestViableFunction(SemaRef, FnLoc, Best);\n\n      if (auto *RD = dyn_cast<CXXRecordDecl>(DC)) {\n        // We either found non-function declarations or a best viable function\n        // at class scope. A class-scope lookup result disables ADL. Don't\n        // look past this, but let the caller know that we found something that\n        // either is, or might be, usable in this class.\n        if (FoundInClass) {\n          *FoundInClass = RD;\n          if (OR == OR_Success) {\n            R.clear();\n            R.addDecl(Best->FoundDecl.getDecl(), Best->FoundDecl.getAccess());\n            R.resolveKind();\n          }\n        }\n        return false;\n      }\n\n      if (OR != OR_Success) {\n        // There wasn't a unique best function or function template.\n        return false;\n      }\n\n      // Find the namespaces where ADL would have looked, and suggest\n      // declaring the function there instead.\n      Sema::AssociatedNamespaceSet AssociatedNamespaces;\n      Sema::AssociatedClassSet AssociatedClasses;\n      SemaRef.FindAssociatedClassesAndNamespaces(FnLoc, Args,\n                                                 AssociatedNamespaces,\n                                                 AssociatedClasses);\n      Sema::AssociatedNamespaceSet SuggestedNamespaces;\n      if (canBeDeclaredInNamespace(R.getLookupName())) {\n        DeclContext *Std = SemaRef.getStdNamespace();\n        for (Sema::AssociatedNamespaceSet::iterator\n               it = AssociatedNamespaces.begin(),\n               end = AssociatedNamespaces.end(); it != end; ++it) {\n          // Never suggest declaring a function within namespace 'std'.\n          if (Std && Std->Encloses(*it))\n            continue;\n\n          // Never suggest declaring a function within a namespace with a\n          // reserved name, like __gnu_cxx.\n          NamespaceDecl *NS = dyn_cast<NamespaceDecl>(*it);\n          if (NS &&\n              NS->getQualifiedNameAsString().find(\"__\") != std::string::npos)\n            continue;\n\n          SuggestedNamespaces.insert(*it);\n        }\n      }\n\n      SemaRef.Diag(R.getNameLoc(), diag::err_not_found_by_two_phase_lookup)\n        << R.getLookupName();\n      if (SuggestedNamespaces.empty()) {\n        SemaRef.Diag(Best->Function->getLocation(),\n                     diag::note_not_found_by_two_phase_lookup)\n          << R.getLookupName() << 0;\n      } else if (SuggestedNamespaces.size() == 1) {\n        SemaRef.Diag(Best->Function->getLocation(),\n                     diag::note_not_found_by_two_phase_lookup)\n          << R.getLookupName() << 1 << *SuggestedNamespaces.begin();\n      } else {\n        // FIXME: It would be useful to list the associated namespaces here,\n        // but the diagnostics infrastructure doesn't provide a way to produce\n        // a localized representation of a list of items.\n        SemaRef.Diag(Best->Function->getLocation(),\n                     diag::note_not_found_by_two_phase_lookup)\n          << R.getLookupName() << 2;\n      }\n\n      // Try to recover by calling this function.\n      return true;\n    }\n\n    R.clear();\n  }\n\n  return false;\n}\n\n/// Attempt to recover from ill-formed use of a non-dependent operator in a\n/// template, where the non-dependent operator was declared after the template\n/// was defined.\n///\n/// Returns true if a viable candidate was found and a diagnostic was issued.\nstatic bool\nDiagnoseTwoPhaseOperatorLookup(Sema &SemaRef, OverloadedOperatorKind Op,\n                               SourceLocation OpLoc,\n                               ArrayRef<Expr *> Args) {\n  DeclarationName OpName =\n    SemaRef.Context.DeclarationNames.getCXXOperatorName(Op);\n  LookupResult R(SemaRef, OpName, OpLoc, Sema::LookupOperatorName);\n  return DiagnoseTwoPhaseLookup(SemaRef, OpLoc, CXXScopeSpec(), R,\n                                OverloadCandidateSet::CSK_Operator,\n                                /*ExplicitTemplateArgs=*/nullptr, Args);\n}\n\nnamespace {\nclass BuildRecoveryCallExprRAII {\n  Sema &SemaRef;\npublic:\n  BuildRecoveryCallExprRAII(Sema &S) : SemaRef(S) {\n    assert(SemaRef.IsBuildingRecoveryCallExpr == false);\n    SemaRef.IsBuildingRecoveryCallExpr = true;\n  }\n\n  ~BuildRecoveryCallExprRAII() {\n    SemaRef.IsBuildingRecoveryCallExpr = false;\n  }\n};\n\n}\n\n/// Attempts to recover from a call where no functions were found.\n///\n/// This function will do one of three things:\n///  * Diagnose, recover, and return a recovery expression.\n///  * Diagnose, fail to recover, and return ExprError().\n///  * Do not diagnose, do not recover, and return ExprResult(). The caller is\n///    expected to diagnose as appropriate.\nstatic ExprResult\nBuildRecoveryCallExpr(Sema &SemaRef, Scope *S, Expr *Fn,\n                      UnresolvedLookupExpr *ULE,\n                      SourceLocation LParenLoc,\n                      MutableArrayRef<Expr *> Args,\n                      SourceLocation RParenLoc,\n                      bool EmptyLookup, bool AllowTypoCorrection) {\n  // Do not try to recover if it is already building a recovery call.\n  // This stops infinite loops for template instantiations like\n  //\n  // template <typename T> auto foo(T t) -> decltype(foo(t)) {}\n  // template <typename T> auto foo(T t) -> decltype(foo(&t)) {}\n  if (SemaRef.IsBuildingRecoveryCallExpr)\n    return ExprResult();\n  BuildRecoveryCallExprRAII RCE(SemaRef);\n\n  CXXScopeSpec SS;\n  SS.Adopt(ULE->getQualifierLoc());\n  SourceLocation TemplateKWLoc = ULE->getTemplateKeywordLoc();\n\n  TemplateArgumentListInfo TABuffer;\n  TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr;\n  if (ULE->hasExplicitTemplateArgs()) {\n    ULE->copyTemplateArgumentsInto(TABuffer);\n    ExplicitTemplateArgs = &TABuffer;\n  }\n\n  LookupResult R(SemaRef, ULE->getName(), ULE->getNameLoc(),\n                 Sema::LookupOrdinaryName);\n  CXXRecordDecl *FoundInClass = nullptr;\n  if (DiagnoseTwoPhaseLookup(SemaRef, Fn->getExprLoc(), SS, R,\n                             OverloadCandidateSet::CSK_Normal,\n                             ExplicitTemplateArgs, Args, &FoundInClass)) {\n    // OK, diagnosed a two-phase lookup issue.\n  } else if (EmptyLookup) {\n    // Try to recover from an empty lookup with typo correction.\n    R.clear();\n    NoTypoCorrectionCCC NoTypoValidator{};\n    FunctionCallFilterCCC FunctionCallValidator(SemaRef, Args.size(),\n                                                ExplicitTemplateArgs != nullptr,\n                                                dyn_cast<MemberExpr>(Fn));\n    CorrectionCandidateCallback &Validator =\n        AllowTypoCorrection\n            ? static_cast<CorrectionCandidateCallback &>(FunctionCallValidator)\n            : static_cast<CorrectionCandidateCallback &>(NoTypoValidator);\n    if (SemaRef.DiagnoseEmptyLookup(S, SS, R, Validator, ExplicitTemplateArgs,\n                                    Args))\n      return ExprError();\n  } else if (FoundInClass && SemaRef.getLangOpts().MSVCCompat) {\n    // We found a usable declaration of the name in a dependent base of some\n    // enclosing class.\n    // FIXME: We should also explain why the candidates found by name lookup\n    // were not viable.\n    if (SemaRef.DiagnoseDependentMemberLookup(R))\n      return ExprError();\n  } else {\n    // We had viable candidates and couldn't recover; let the caller diagnose\n    // this.\n    return ExprResult();\n  }\n\n  // If we get here, we should have issued a diagnostic and formed a recovery\n  // lookup result.\n  assert(!R.empty() && \"lookup results empty despite recovery\");\n\n  // If recovery created an ambiguity, just bail out.\n  if (R.isAmbiguous()) {\n    R.suppressDiagnostics();\n    return ExprError();\n  }\n\n  // Build an implicit member call if appropriate.  Just drop the\n  // casts and such from the call, we don't really care.\n  ExprResult NewFn = ExprError();\n  if ((*R.begin())->isCXXClassMember())\n    NewFn = SemaRef.BuildPossibleImplicitMemberExpr(SS, TemplateKWLoc, R,\n                                                    ExplicitTemplateArgs, S);\n  else if (ExplicitTemplateArgs || TemplateKWLoc.isValid())\n    NewFn = SemaRef.BuildTemplateIdExpr(SS, TemplateKWLoc, R, false,\n                                        ExplicitTemplateArgs);\n  else\n    NewFn = SemaRef.BuildDeclarationNameExpr(SS, R, false);\n\n  if (NewFn.isInvalid())\n    return ExprError();\n\n  // This shouldn't cause an infinite loop because we're giving it\n  // an expression with viable lookup results, which should never\n  // end up here.\n  return SemaRef.BuildCallExpr(/*Scope*/ nullptr, NewFn.get(), LParenLoc,\n                               MultiExprArg(Args.data(), Args.size()),\n                               RParenLoc);\n}\n\n/// Constructs and populates an OverloadedCandidateSet from\n/// the given function.\n/// \\returns true when an the ExprResult output parameter has been set.\nbool Sema::buildOverloadedCallSet(Scope *S, Expr *Fn,\n                                  UnresolvedLookupExpr *ULE,\n                                  MultiExprArg Args,\n                                  SourceLocation RParenLoc,\n                                  OverloadCandidateSet *CandidateSet,\n                                  ExprResult *Result) {\n#ifndef NDEBUG\n  if (ULE->requiresADL()) {\n    // To do ADL, we must have found an unqualified name.\n    assert(!ULE->getQualifier() && \"qualified name with ADL\");\n\n    // We don't perform ADL for implicit declarations of builtins.\n    // Verify that this was correctly set up.\n    FunctionDecl *F;\n    if (ULE->decls_begin() != ULE->decls_end() &&\n        ULE->decls_begin() + 1 == ULE->decls_end() &&\n        (F = dyn_cast<FunctionDecl>(*ULE->decls_begin())) &&\n        F->getBuiltinID() && F->isImplicit())\n      llvm_unreachable(\"performing ADL for builtin\");\n\n    // We don't perform ADL in C.\n    assert(getLangOpts().CPlusPlus && \"ADL enabled in C\");\n  }\n#endif\n\n  UnbridgedCastsSet UnbridgedCasts;\n  if (checkArgPlaceholdersForOverload(*this, Args, UnbridgedCasts)) {\n    *Result = ExprError();\n    return true;\n  }\n\n  // Add the functions denoted by the callee to the set of candidate\n  // functions, including those from argument-dependent lookup.\n  AddOverloadedCallCandidates(ULE, Args, *CandidateSet);\n\n  if (getLangOpts().MSVCCompat &&\n      CurContext->isDependentContext() && !isSFINAEContext() &&\n      (isa<FunctionDecl>(CurContext) || isa<CXXRecordDecl>(CurContext))) {\n\n    OverloadCandidateSet::iterator Best;\n    if (CandidateSet->empty() ||\n        CandidateSet->BestViableFunction(*this, Fn->getBeginLoc(), Best) ==\n            OR_No_Viable_Function) {\n      // In Microsoft mode, if we are inside a template class member function\n      // then create a type dependent CallExpr. The goal is to postpone name\n      // lookup to instantiation time to be able to search into type dependent\n      // base classes.\n      CallExpr *CE =\n          CallExpr::Create(Context, Fn, Args, Context.DependentTy, VK_RValue,\n                           RParenLoc, CurFPFeatureOverrides());\n      CE->markDependentForPostponedNameLookup();\n      *Result = CE;\n      return true;\n    }\n  }\n\n  if (CandidateSet->empty())\n    return false;\n\n  UnbridgedCasts.restore();\n  return false;\n}\n\n// Guess at what the return type for an unresolvable overload should be.\nstatic QualType chooseRecoveryType(OverloadCandidateSet &CS,\n                                   OverloadCandidateSet::iterator *Best) {\n  llvm::Optional<QualType> Result;\n  // Adjust Type after seeing a candidate.\n  auto ConsiderCandidate = [&](const OverloadCandidate &Candidate) {\n    if (!Candidate.Function)\n      return;\n    if (Candidate.Function->isInvalidDecl())\n      return;\n    QualType T = Candidate.Function->getReturnType();\n    if (T.isNull())\n      return;\n    if (!Result)\n      Result = T;\n    else if (Result != T)\n      Result = QualType();\n  };\n\n  // Look for an unambiguous type from a progressively larger subset.\n  // e.g. if types disagree, but all *viable* overloads return int, choose int.\n  //\n  // First, consider only the best candidate.\n  if (Best && *Best != CS.end())\n    ConsiderCandidate(**Best);\n  // Next, consider only viable candidates.\n  if (!Result)\n    for (const auto &C : CS)\n      if (C.Viable)\n        ConsiderCandidate(C);\n  // Finally, consider all candidates.\n  if (!Result)\n    for (const auto &C : CS)\n      ConsiderCandidate(C);\n\n  if (!Result)\n    return QualType();\n  auto Value = Result.getValue();\n  if (Value.isNull() || Value->isUndeducedType())\n    return QualType();\n  return Value;\n}\n\n/// FinishOverloadedCallExpr - given an OverloadCandidateSet, builds and returns\n/// the completed call expression. If overload resolution fails, emits\n/// diagnostics and returns ExprError()\nstatic ExprResult FinishOverloadedCallExpr(Sema &SemaRef, Scope *S, Expr *Fn,\n                                           UnresolvedLookupExpr *ULE,\n                                           SourceLocation LParenLoc,\n                                           MultiExprArg Args,\n                                           SourceLocation RParenLoc,\n                                           Expr *ExecConfig,\n                                           OverloadCandidateSet *CandidateSet,\n                                           OverloadCandidateSet::iterator *Best,\n                                           OverloadingResult OverloadResult,\n                                           bool AllowTypoCorrection) {\n  switch (OverloadResult) {\n  case OR_Success: {\n    FunctionDecl *FDecl = (*Best)->Function;\n    SemaRef.CheckUnresolvedLookupAccess(ULE, (*Best)->FoundDecl);\n    if (SemaRef.DiagnoseUseOfDecl(FDecl, ULE->getNameLoc()))\n      return ExprError();\n    Fn = SemaRef.FixOverloadedFunctionReference(Fn, (*Best)->FoundDecl, FDecl);\n    return SemaRef.BuildResolvedCallExpr(Fn, FDecl, LParenLoc, Args, RParenLoc,\n                                         ExecConfig, /*IsExecConfig=*/false,\n                                         (*Best)->IsADLCandidate);\n  }\n\n  case OR_No_Viable_Function: {\n    // Try to recover by looking for viable functions which the user might\n    // have meant to call.\n    ExprResult Recovery = BuildRecoveryCallExpr(SemaRef, S, Fn, ULE, LParenLoc,\n                                                Args, RParenLoc,\n                                                CandidateSet->empty(),\n                                                AllowTypoCorrection);\n    if (Recovery.isInvalid() || Recovery.isUsable())\n      return Recovery;\n\n    // If the user passes in a function that we can't take the address of, we\n    // generally end up emitting really bad error messages. Here, we attempt to\n    // emit better ones.\n    for (const Expr *Arg : Args) {\n      if (!Arg->getType()->isFunctionType())\n        continue;\n      if (auto *DRE = dyn_cast<DeclRefExpr>(Arg->IgnoreParenImpCasts())) {\n        auto *FD = dyn_cast<FunctionDecl>(DRE->getDecl());\n        if (FD &&\n            !SemaRef.checkAddressOfFunctionIsAvailable(FD, /*Complain=*/true,\n                                                       Arg->getExprLoc()))\n          return ExprError();\n      }\n    }\n\n    CandidateSet->NoteCandidates(\n        PartialDiagnosticAt(\n            Fn->getBeginLoc(),\n            SemaRef.PDiag(diag::err_ovl_no_viable_function_in_call)\n                << ULE->getName() << Fn->getSourceRange()),\n        SemaRef, OCD_AllCandidates, Args);\n    break;\n  }\n\n  case OR_Ambiguous:\n    CandidateSet->NoteCandidates(\n        PartialDiagnosticAt(Fn->getBeginLoc(),\n                            SemaRef.PDiag(diag::err_ovl_ambiguous_call)\n                                << ULE->getName() << Fn->getSourceRange()),\n        SemaRef, OCD_AmbiguousCandidates, Args);\n    break;\n\n  case OR_Deleted: {\n    CandidateSet->NoteCandidates(\n        PartialDiagnosticAt(Fn->getBeginLoc(),\n                            SemaRef.PDiag(diag::err_ovl_deleted_call)\n                                << ULE->getName() << Fn->getSourceRange()),\n        SemaRef, OCD_AllCandidates, Args);\n\n    // We emitted an error for the unavailable/deleted function call but keep\n    // the call in the AST.\n    FunctionDecl *FDecl = (*Best)->Function;\n    Fn = SemaRef.FixOverloadedFunctionReference(Fn, (*Best)->FoundDecl, FDecl);\n    return SemaRef.BuildResolvedCallExpr(Fn, FDecl, LParenLoc, Args, RParenLoc,\n                                         ExecConfig, /*IsExecConfig=*/false,\n                                         (*Best)->IsADLCandidate);\n  }\n  }\n\n  // Overload resolution failed, try to recover.\n  SmallVector<Expr *, 8> SubExprs = {Fn};\n  SubExprs.append(Args.begin(), Args.end());\n  return SemaRef.CreateRecoveryExpr(Fn->getBeginLoc(), RParenLoc, SubExprs,\n                                    chooseRecoveryType(*CandidateSet, Best));\n}\n\nstatic void markUnaddressableCandidatesUnviable(Sema &S,\n                                                OverloadCandidateSet &CS) {\n  for (auto I = CS.begin(), E = CS.end(); I != E; ++I) {\n    if (I->Viable &&\n        !S.checkAddressOfFunctionIsAvailable(I->Function, /*Complain=*/false)) {\n      I->Viable = false;\n      I->FailureKind = ovl_fail_addr_not_available;\n    }\n  }\n}\n\n/// BuildOverloadedCallExpr - Given the call expression that calls Fn\n/// (which eventually refers to the declaration Func) and the call\n/// arguments Args/NumArgs, attempt to resolve the function call down\n/// to a specific function. If overload resolution succeeds, returns\n/// the call expression produced by overload resolution.\n/// Otherwise, emits diagnostics and returns ExprError.\nExprResult Sema::BuildOverloadedCallExpr(Scope *S, Expr *Fn,\n                                         UnresolvedLookupExpr *ULE,\n                                         SourceLocation LParenLoc,\n                                         MultiExprArg Args,\n                                         SourceLocation RParenLoc,\n                                         Expr *ExecConfig,\n                                         bool AllowTypoCorrection,\n                                         bool CalleesAddressIsTaken) {\n  OverloadCandidateSet CandidateSet(Fn->getExprLoc(),\n                                    OverloadCandidateSet::CSK_Normal);\n  ExprResult result;\n\n  if (buildOverloadedCallSet(S, Fn, ULE, Args, LParenLoc, &CandidateSet,\n                             &result))\n    return result;\n\n  // If the user handed us something like `(&Foo)(Bar)`, we need to ensure that\n  // functions that aren't addressible are considered unviable.\n  if (CalleesAddressIsTaken)\n    markUnaddressableCandidatesUnviable(*this, CandidateSet);\n\n  OverloadCandidateSet::iterator Best;\n  OverloadingResult OverloadResult =\n      CandidateSet.BestViableFunction(*this, Fn->getBeginLoc(), Best);\n\n  return FinishOverloadedCallExpr(*this, S, Fn, ULE, LParenLoc, Args, RParenLoc,\n                                  ExecConfig, &CandidateSet, &Best,\n                                  OverloadResult, AllowTypoCorrection);\n}\n\nstatic bool IsOverloaded(const UnresolvedSetImpl &Functions) {\n  return Functions.size() > 1 ||\n         (Functions.size() == 1 &&\n          isa<FunctionTemplateDecl>((*Functions.begin())->getUnderlyingDecl()));\n}\n\nExprResult Sema::CreateUnresolvedLookupExpr(CXXRecordDecl *NamingClass,\n                                            NestedNameSpecifierLoc NNSLoc,\n                                            DeclarationNameInfo DNI,\n                                            const UnresolvedSetImpl &Fns,\n                                            bool PerformADL) {\n  return UnresolvedLookupExpr::Create(Context, NamingClass, NNSLoc, DNI,\n                                      PerformADL, IsOverloaded(Fns),\n                                      Fns.begin(), Fns.end());\n}\n\n/// Create a unary operation that may resolve to an overloaded\n/// operator.\n///\n/// \\param OpLoc The location of the operator itself (e.g., '*').\n///\n/// \\param Opc The UnaryOperatorKind that describes this operator.\n///\n/// \\param Fns The set of non-member functions that will be\n/// considered by overload resolution. The caller needs to build this\n/// set based on the context using, e.g.,\n/// LookupOverloadedOperatorName() and ArgumentDependentLookup(). This\n/// set should not contain any member functions; those will be added\n/// by CreateOverloadedUnaryOp().\n///\n/// \\param Input The input argument.\nExprResult\nSema::CreateOverloadedUnaryOp(SourceLocation OpLoc, UnaryOperatorKind Opc,\n                              const UnresolvedSetImpl &Fns,\n                              Expr *Input, bool PerformADL) {\n  OverloadedOperatorKind Op = UnaryOperator::getOverloadedOperator(Opc);\n  assert(Op != OO_None && \"Invalid opcode for overloaded unary operator\");\n  DeclarationName OpName = Context.DeclarationNames.getCXXOperatorName(Op);\n  // TODO: provide better source location info.\n  DeclarationNameInfo OpNameInfo(OpName, OpLoc);\n\n  if (checkPlaceholderForOverload(*this, Input))\n    return ExprError();\n\n  Expr *Args[2] = { Input, nullptr };\n  unsigned NumArgs = 1;\n\n  // For post-increment and post-decrement, add the implicit '0' as\n  // the second argument, so that we know this is a post-increment or\n  // post-decrement.\n  if (Opc == UO_PostInc || Opc == UO_PostDec) {\n    llvm::APSInt Zero(Context.getTypeSize(Context.IntTy), false);\n    Args[1] = IntegerLiteral::Create(Context, Zero, Context.IntTy,\n                                     SourceLocation());\n    NumArgs = 2;\n  }\n\n  ArrayRef<Expr *> ArgsArray(Args, NumArgs);\n\n  if (Input->isTypeDependent()) {\n    if (Fns.empty())\n      return UnaryOperator::Create(Context, Input, Opc, Context.DependentTy,\n                                   VK_RValue, OK_Ordinary, OpLoc, false,\n                                   CurFPFeatureOverrides());\n\n    CXXRecordDecl *NamingClass = nullptr; // lookup ignores member operators\n    ExprResult Fn = CreateUnresolvedLookupExpr(\n        NamingClass, NestedNameSpecifierLoc(), OpNameInfo, Fns);\n    if (Fn.isInvalid())\n      return ExprError();\n    return CXXOperatorCallExpr::Create(Context, Op, Fn.get(), ArgsArray,\n                                       Context.DependentTy, VK_RValue, OpLoc,\n                                       CurFPFeatureOverrides());\n  }\n\n  // Build an empty overload set.\n  OverloadCandidateSet CandidateSet(OpLoc, OverloadCandidateSet::CSK_Operator);\n\n  // Add the candidates from the given function set.\n  AddNonMemberOperatorCandidates(Fns, ArgsArray, CandidateSet);\n\n  // Add operator candidates that are member functions.\n  AddMemberOperatorCandidates(Op, OpLoc, ArgsArray, CandidateSet);\n\n  // Add candidates from ADL.\n  if (PerformADL) {\n    AddArgumentDependentLookupCandidates(OpName, OpLoc, ArgsArray,\n                                         /*ExplicitTemplateArgs*/nullptr,\n                                         CandidateSet);\n  }\n\n  // Add builtin operator candidates.\n  AddBuiltinOperatorCandidates(Op, OpLoc, ArgsArray, CandidateSet);\n\n  bool HadMultipleCandidates = (CandidateSet.size() > 1);\n\n  // Perform overload resolution.\n  OverloadCandidateSet::iterator Best;\n  switch (CandidateSet.BestViableFunction(*this, OpLoc, Best)) {\n  case OR_Success: {\n    // We found a built-in operator or an overloaded operator.\n    FunctionDecl *FnDecl = Best->Function;\n\n    if (FnDecl) {\n      Expr *Base = nullptr;\n      // We matched an overloaded operator. Build a call to that\n      // operator.\n\n      // Convert the arguments.\n      if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(FnDecl)) {\n        CheckMemberOperatorAccess(OpLoc, Args[0], nullptr, Best->FoundDecl);\n\n        ExprResult InputRes =\n          PerformObjectArgumentInitialization(Input, /*Qualifier=*/nullptr,\n                                              Best->FoundDecl, Method);\n        if (InputRes.isInvalid())\n          return ExprError();\n        Base = Input = InputRes.get();\n      } else {\n        // Convert the arguments.\n        ExprResult InputInit\n          = PerformCopyInitialization(InitializedEntity::InitializeParameter(\n                                                      Context,\n                                                      FnDecl->getParamDecl(0)),\n                                      SourceLocation(),\n                                      Input);\n        if (InputInit.isInvalid())\n          return ExprError();\n        Input = InputInit.get();\n      }\n\n      // Build the actual expression node.\n      ExprResult FnExpr = CreateFunctionRefExpr(*this, FnDecl, Best->FoundDecl,\n                                                Base, HadMultipleCandidates,\n                                                OpLoc);\n      if (FnExpr.isInvalid())\n        return ExprError();\n\n      // Determine the result type.\n      QualType ResultTy = FnDecl->getReturnType();\n      ExprValueKind VK = Expr::getValueKindForType(ResultTy);\n      ResultTy = ResultTy.getNonLValueExprType(Context);\n\n      Args[0] = Input;\n      CallExpr *TheCall = CXXOperatorCallExpr::Create(\n          Context, Op, FnExpr.get(), ArgsArray, ResultTy, VK, OpLoc,\n          CurFPFeatureOverrides(), Best->IsADLCandidate);\n\n      if (CheckCallReturnType(FnDecl->getReturnType(), OpLoc, TheCall, FnDecl))\n        return ExprError();\n\n      if (CheckFunctionCall(FnDecl, TheCall,\n                            FnDecl->getType()->castAs<FunctionProtoType>()))\n        return ExprError();\n      return CheckForImmediateInvocation(MaybeBindToTemporary(TheCall), FnDecl);\n    } else {\n      // We matched a built-in operator. Convert the arguments, then\n      // break out so that we will build the appropriate built-in\n      // operator node.\n      ExprResult InputRes = PerformImplicitConversion(\n          Input, Best->BuiltinParamTypes[0], Best->Conversions[0], AA_Passing,\n          CCK_ForBuiltinOverloadedOp);\n      if (InputRes.isInvalid())\n        return ExprError();\n      Input = InputRes.get();\n      break;\n    }\n  }\n\n  case OR_No_Viable_Function:\n    // This is an erroneous use of an operator which can be overloaded by\n    // a non-member function. Check for non-member operators which were\n    // defined too late to be candidates.\n    if (DiagnoseTwoPhaseOperatorLookup(*this, Op, OpLoc, ArgsArray))\n      // FIXME: Recover by calling the found function.\n      return ExprError();\n\n    // No viable function; fall through to handling this as a\n    // built-in operator, which will produce an error message for us.\n    break;\n\n  case OR_Ambiguous:\n    CandidateSet.NoteCandidates(\n        PartialDiagnosticAt(OpLoc,\n                            PDiag(diag::err_ovl_ambiguous_oper_unary)\n                                << UnaryOperator::getOpcodeStr(Opc)\n                                << Input->getType() << Input->getSourceRange()),\n        *this, OCD_AmbiguousCandidates, ArgsArray,\n        UnaryOperator::getOpcodeStr(Opc), OpLoc);\n    return ExprError();\n\n  case OR_Deleted:\n    CandidateSet.NoteCandidates(\n        PartialDiagnosticAt(OpLoc, PDiag(diag::err_ovl_deleted_oper)\n                                       << UnaryOperator::getOpcodeStr(Opc)\n                                       << Input->getSourceRange()),\n        *this, OCD_AllCandidates, ArgsArray, UnaryOperator::getOpcodeStr(Opc),\n        OpLoc);\n    return ExprError();\n  }\n\n  // Either we found no viable overloaded operator or we matched a\n  // built-in operator. In either case, fall through to trying to\n  // build a built-in operation.\n  return CreateBuiltinUnaryOp(OpLoc, Opc, Input);\n}\n\n/// Perform lookup for an overloaded binary operator.\nvoid Sema::LookupOverloadedBinOp(OverloadCandidateSet &CandidateSet,\n                                 OverloadedOperatorKind Op,\n                                 const UnresolvedSetImpl &Fns,\n                                 ArrayRef<Expr *> Args, bool PerformADL) {\n  SourceLocation OpLoc = CandidateSet.getLocation();\n\n  OverloadedOperatorKind ExtraOp =\n      CandidateSet.getRewriteInfo().AllowRewrittenCandidates\n          ? getRewrittenOverloadedOperator(Op)\n          : OO_None;\n\n  // Add the candidates from the given function set. This also adds the\n  // rewritten candidates using these functions if necessary.\n  AddNonMemberOperatorCandidates(Fns, Args, CandidateSet);\n\n  // Add operator candidates that are member functions.\n  AddMemberOperatorCandidates(Op, OpLoc, Args, CandidateSet);\n  if (CandidateSet.getRewriteInfo().shouldAddReversed(Op))\n    AddMemberOperatorCandidates(Op, OpLoc, {Args[1], Args[0]}, CandidateSet,\n                                OverloadCandidateParamOrder::Reversed);\n\n  // In C++20, also add any rewritten member candidates.\n  if (ExtraOp) {\n    AddMemberOperatorCandidates(ExtraOp, OpLoc, Args, CandidateSet);\n    if (CandidateSet.getRewriteInfo().shouldAddReversed(ExtraOp))\n      AddMemberOperatorCandidates(ExtraOp, OpLoc, {Args[1], Args[0]},\n                                  CandidateSet,\n                                  OverloadCandidateParamOrder::Reversed);\n  }\n\n  // Add candidates from ADL. Per [over.match.oper]p2, this lookup is not\n  // performed for an assignment operator (nor for operator[] nor operator->,\n  // which don't get here).\n  if (Op != OO_Equal && PerformADL) {\n    DeclarationName OpName = Context.DeclarationNames.getCXXOperatorName(Op);\n    AddArgumentDependentLookupCandidates(OpName, OpLoc, Args,\n                                         /*ExplicitTemplateArgs*/ nullptr,\n                                         CandidateSet);\n    if (ExtraOp) {\n      DeclarationName ExtraOpName =\n          Context.DeclarationNames.getCXXOperatorName(ExtraOp);\n      AddArgumentDependentLookupCandidates(ExtraOpName, OpLoc, Args,\n                                           /*ExplicitTemplateArgs*/ nullptr,\n                                           CandidateSet);\n    }\n  }\n\n  // Add builtin operator candidates.\n  //\n  // FIXME: We don't add any rewritten candidates here. This is strictly\n  // incorrect; a builtin candidate could be hidden by a non-viable candidate,\n  // resulting in our selecting a rewritten builtin candidate. For example:\n  //\n  //   enum class E { e };\n  //   bool operator!=(E, E) requires false;\n  //   bool k = E::e != E::e;\n  //\n  // ... should select the rewritten builtin candidate 'operator==(E, E)'. But\n  // it seems unreasonable to consider rewritten builtin candidates. A core\n  // issue has been filed proposing to removed this requirement.\n  AddBuiltinOperatorCandidates(Op, OpLoc, Args, CandidateSet);\n}\n\n/// Create a binary operation that may resolve to an overloaded\n/// operator.\n///\n/// \\param OpLoc The location of the operator itself (e.g., '+').\n///\n/// \\param Opc The BinaryOperatorKind that describes this operator.\n///\n/// \\param Fns The set of non-member functions that will be\n/// considered by overload resolution. The caller needs to build this\n/// set based on the context using, e.g.,\n/// LookupOverloadedOperatorName() and ArgumentDependentLookup(). This\n/// set should not contain any member functions; those will be added\n/// by CreateOverloadedBinOp().\n///\n/// \\param LHS Left-hand argument.\n/// \\param RHS Right-hand argument.\n/// \\param PerformADL Whether to consider operator candidates found by ADL.\n/// \\param AllowRewrittenCandidates Whether to consider candidates found by\n///        C++20 operator rewrites.\n/// \\param DefaultedFn If we are synthesizing a defaulted operator function,\n///        the function in question. Such a function is never a candidate in\n///        our overload resolution. This also enables synthesizing a three-way\n///        comparison from < and == as described in C++20 [class.spaceship]p1.\nExprResult Sema::CreateOverloadedBinOp(SourceLocation OpLoc,\n                                       BinaryOperatorKind Opc,\n                                       const UnresolvedSetImpl &Fns, Expr *LHS,\n                                       Expr *RHS, bool PerformADL,\n                                       bool AllowRewrittenCandidates,\n                                       FunctionDecl *DefaultedFn) {\n  Expr *Args[2] = { LHS, RHS };\n  LHS=RHS=nullptr; // Please use only Args instead of LHS/RHS couple\n\n  if (!getLangOpts().CPlusPlus20)\n    AllowRewrittenCandidates = false;\n\n  OverloadedOperatorKind Op = BinaryOperator::getOverloadedOperator(Opc);\n\n  // If either side is type-dependent, create an appropriate dependent\n  // expression.\n  if (Args[0]->isTypeDependent() || Args[1]->isTypeDependent()) {\n    if (Fns.empty()) {\n      // If there are no functions to store, just build a dependent\n      // BinaryOperator or CompoundAssignment.\n      if (BinaryOperator::isCompoundAssignmentOp(Opc))\n        return CompoundAssignOperator::Create(\n            Context, Args[0], Args[1], Opc, Context.DependentTy, VK_LValue,\n            OK_Ordinary, OpLoc, CurFPFeatureOverrides(), Context.DependentTy,\n            Context.DependentTy);\n      return BinaryOperator::Create(Context, Args[0], Args[1], Opc,\n                                    Context.DependentTy, VK_RValue, OK_Ordinary,\n                                    OpLoc, CurFPFeatureOverrides());\n    }\n\n    // FIXME: save results of ADL from here?\n    CXXRecordDecl *NamingClass = nullptr; // lookup ignores member operators\n    // TODO: provide better source location info in DNLoc component.\n    DeclarationName OpName = Context.DeclarationNames.getCXXOperatorName(Op);\n    DeclarationNameInfo OpNameInfo(OpName, OpLoc);\n    ExprResult Fn = CreateUnresolvedLookupExpr(\n        NamingClass, NestedNameSpecifierLoc(), OpNameInfo, Fns, PerformADL);\n    if (Fn.isInvalid())\n      return ExprError();\n    return CXXOperatorCallExpr::Create(Context, Op, Fn.get(), Args,\n                                       Context.DependentTy, VK_RValue, OpLoc,\n                                       CurFPFeatureOverrides());\n  }\n\n  // Always do placeholder-like conversions on the RHS.\n  if (checkPlaceholderForOverload(*this, Args[1]))\n    return ExprError();\n\n  // Do placeholder-like conversion on the LHS; note that we should\n  // not get here with a PseudoObject LHS.\n  assert(Args[0]->getObjectKind() != OK_ObjCProperty);\n  if (checkPlaceholderForOverload(*this, Args[0]))\n    return ExprError();\n\n  // If this is the assignment operator, we only perform overload resolution\n  // if the left-hand side is a class or enumeration type. This is actually\n  // a hack. The standard requires that we do overload resolution between the\n  // various built-in candidates, but as DR507 points out, this can lead to\n  // problems. So we do it this way, which pretty much follows what GCC does.\n  // Note that we go the traditional code path for compound assignment forms.\n  if (Opc == BO_Assign && !Args[0]->getType()->isOverloadableType())\n    return CreateBuiltinBinOp(OpLoc, Opc, Args[0], Args[1]);\n\n  // If this is the .* operator, which is not overloadable, just\n  // create a built-in binary operator.\n  if (Opc == BO_PtrMemD)\n    return CreateBuiltinBinOp(OpLoc, Opc, Args[0], Args[1]);\n\n  // Build the overload set.\n  OverloadCandidateSet CandidateSet(\n      OpLoc, OverloadCandidateSet::CSK_Operator,\n      OverloadCandidateSet::OperatorRewriteInfo(Op, AllowRewrittenCandidates));\n  if (DefaultedFn)\n    CandidateSet.exclude(DefaultedFn);\n  LookupOverloadedBinOp(CandidateSet, Op, Fns, Args, PerformADL);\n\n  bool HadMultipleCandidates = (CandidateSet.size() > 1);\n\n  // Perform overload resolution.\n  OverloadCandidateSet::iterator Best;\n  switch (CandidateSet.BestViableFunction(*this, OpLoc, Best)) {\n    case OR_Success: {\n      // We found a built-in operator or an overloaded operator.\n      FunctionDecl *FnDecl = Best->Function;\n\n      bool IsReversed = Best->isReversed();\n      if (IsReversed)\n        std::swap(Args[0], Args[1]);\n\n      if (FnDecl) {\n        Expr *Base = nullptr;\n        // We matched an overloaded operator. Build a call to that\n        // operator.\n\n        OverloadedOperatorKind ChosenOp =\n            FnDecl->getDeclName().getCXXOverloadedOperator();\n\n        // C++2a [over.match.oper]p9:\n        //   If a rewritten operator== candidate is selected by overload\n        //   resolution for an operator@, its return type shall be cv bool\n        if (Best->RewriteKind && ChosenOp == OO_EqualEqual &&\n            !FnDecl->getReturnType()->isBooleanType()) {\n          bool IsExtension =\n              FnDecl->getReturnType()->isIntegralOrUnscopedEnumerationType();\n          Diag(OpLoc, IsExtension ? diag::ext_ovl_rewrite_equalequal_not_bool\n                                  : diag::err_ovl_rewrite_equalequal_not_bool)\n              << FnDecl->getReturnType() << BinaryOperator::getOpcodeStr(Opc)\n              << Args[0]->getSourceRange() << Args[1]->getSourceRange();\n          Diag(FnDecl->getLocation(), diag::note_declared_at);\n          if (!IsExtension)\n            return ExprError();\n        }\n\n        if (AllowRewrittenCandidates && !IsReversed &&\n            CandidateSet.getRewriteInfo().isReversible()) {\n          // We could have reversed this operator, but didn't. Check if some\n          // reversed form was a viable candidate, and if so, if it had a\n          // better conversion for either parameter. If so, this call is\n          // formally ambiguous, and allowing it is an extension.\n          llvm::SmallVector<FunctionDecl*, 4> AmbiguousWith;\n          for (OverloadCandidate &Cand : CandidateSet) {\n            if (Cand.Viable && Cand.Function && Cand.isReversed() &&\n                haveSameParameterTypes(Context, Cand.Function, FnDecl, 2)) {\n              for (unsigned ArgIdx = 0; ArgIdx < 2; ++ArgIdx) {\n                if (CompareImplicitConversionSequences(\n                        *this, OpLoc, Cand.Conversions[ArgIdx],\n                        Best->Conversions[ArgIdx]) ==\n                    ImplicitConversionSequence::Better) {\n                  AmbiguousWith.push_back(Cand.Function);\n                  break;\n                }\n              }\n            }\n          }\n\n          if (!AmbiguousWith.empty()) {\n            bool AmbiguousWithSelf =\n                AmbiguousWith.size() == 1 &&\n                declaresSameEntity(AmbiguousWith.front(), FnDecl);\n            Diag(OpLoc, diag::ext_ovl_ambiguous_oper_binary_reversed)\n                << BinaryOperator::getOpcodeStr(Opc)\n                << Args[0]->getType() << Args[1]->getType() << AmbiguousWithSelf\n                << Args[0]->getSourceRange() << Args[1]->getSourceRange();\n            if (AmbiguousWithSelf) {\n              Diag(FnDecl->getLocation(),\n                   diag::note_ovl_ambiguous_oper_binary_reversed_self);\n            } else {\n              Diag(FnDecl->getLocation(),\n                   diag::note_ovl_ambiguous_oper_binary_selected_candidate);\n              for (auto *F : AmbiguousWith)\n                Diag(F->getLocation(),\n                     diag::note_ovl_ambiguous_oper_binary_reversed_candidate);\n            }\n          }\n        }\n\n        // Convert the arguments.\n        if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(FnDecl)) {\n          // Best->Access is only meaningful for class members.\n          CheckMemberOperatorAccess(OpLoc, Args[0], Args[1], Best->FoundDecl);\n\n          ExprResult Arg1 =\n            PerformCopyInitialization(\n              InitializedEntity::InitializeParameter(Context,\n                                                     FnDecl->getParamDecl(0)),\n              SourceLocation(), Args[1]);\n          if (Arg1.isInvalid())\n            return ExprError();\n\n          ExprResult Arg0 =\n            PerformObjectArgumentInitialization(Args[0], /*Qualifier=*/nullptr,\n                                                Best->FoundDecl, Method);\n          if (Arg0.isInvalid())\n            return ExprError();\n          Base = Args[0] = Arg0.getAs<Expr>();\n          Args[1] = RHS = Arg1.getAs<Expr>();\n        } else {\n          // Convert the arguments.\n          ExprResult Arg0 = PerformCopyInitialization(\n            InitializedEntity::InitializeParameter(Context,\n                                                   FnDecl->getParamDecl(0)),\n            SourceLocation(), Args[0]);\n          if (Arg0.isInvalid())\n            return ExprError();\n\n          ExprResult Arg1 =\n            PerformCopyInitialization(\n              InitializedEntity::InitializeParameter(Context,\n                                                     FnDecl->getParamDecl(1)),\n              SourceLocation(), Args[1]);\n          if (Arg1.isInvalid())\n            return ExprError();\n          Args[0] = LHS = Arg0.getAs<Expr>();\n          Args[1] = RHS = Arg1.getAs<Expr>();\n        }\n\n        // Build the actual expression node.\n        ExprResult FnExpr = CreateFunctionRefExpr(*this, FnDecl,\n                                                  Best->FoundDecl, Base,\n                                                  HadMultipleCandidates, OpLoc);\n        if (FnExpr.isInvalid())\n          return ExprError();\n\n        // Determine the result type.\n        QualType ResultTy = FnDecl->getReturnType();\n        ExprValueKind VK = Expr::getValueKindForType(ResultTy);\n        ResultTy = ResultTy.getNonLValueExprType(Context);\n\n        CXXOperatorCallExpr *TheCall = CXXOperatorCallExpr::Create(\n            Context, ChosenOp, FnExpr.get(), Args, ResultTy, VK, OpLoc,\n            CurFPFeatureOverrides(), Best->IsADLCandidate);\n\n        if (CheckCallReturnType(FnDecl->getReturnType(), OpLoc, TheCall,\n                                FnDecl))\n          return ExprError();\n\n        ArrayRef<const Expr *> ArgsArray(Args, 2);\n        const Expr *ImplicitThis = nullptr;\n        // Cut off the implicit 'this'.\n        if (isa<CXXMethodDecl>(FnDecl)) {\n          ImplicitThis = ArgsArray[0];\n          ArgsArray = ArgsArray.slice(1);\n        }\n\n        // Check for a self move.\n        if (Op == OO_Equal)\n          DiagnoseSelfMove(Args[0], Args[1], OpLoc);\n\n        if (ImplicitThis) {\n          QualType ThisType = Context.getPointerType(ImplicitThis->getType());\n          QualType ThisTypeFromDecl = Context.getPointerType(\n              cast<CXXMethodDecl>(FnDecl)->getThisObjectType());\n\n          CheckArgAlignment(OpLoc, FnDecl, \"'this'\", ThisType,\n                            ThisTypeFromDecl);\n        }\n\n        checkCall(FnDecl, nullptr, ImplicitThis, ArgsArray,\n                  isa<CXXMethodDecl>(FnDecl), OpLoc, TheCall->getSourceRange(),\n                  VariadicDoesNotApply);\n\n        ExprResult R = MaybeBindToTemporary(TheCall);\n        if (R.isInvalid())\n          return ExprError();\n\n        R = CheckForImmediateInvocation(R, FnDecl);\n        if (R.isInvalid())\n          return ExprError();\n\n        // For a rewritten candidate, we've already reversed the arguments\n        // if needed. Perform the rest of the rewrite now.\n        if ((Best->RewriteKind & CRK_DifferentOperator) ||\n            (Op == OO_Spaceship && IsReversed)) {\n          if (Op == OO_ExclaimEqual) {\n            assert(ChosenOp == OO_EqualEqual && \"unexpected operator name\");\n            R = CreateBuiltinUnaryOp(OpLoc, UO_LNot, R.get());\n          } else {\n            assert(ChosenOp == OO_Spaceship && \"unexpected operator name\");\n            llvm::APSInt Zero(Context.getTypeSize(Context.IntTy), false);\n            Expr *ZeroLiteral =\n                IntegerLiteral::Create(Context, Zero, Context.IntTy, OpLoc);\n\n            Sema::CodeSynthesisContext Ctx;\n            Ctx.Kind = Sema::CodeSynthesisContext::RewritingOperatorAsSpaceship;\n            Ctx.Entity = FnDecl;\n            pushCodeSynthesisContext(Ctx);\n\n            R = CreateOverloadedBinOp(\n                OpLoc, Opc, Fns, IsReversed ? ZeroLiteral : R.get(),\n                IsReversed ? R.get() : ZeroLiteral, PerformADL,\n                /*AllowRewrittenCandidates=*/false);\n\n            popCodeSynthesisContext();\n          }\n          if (R.isInvalid())\n            return ExprError();\n        } else {\n          assert(ChosenOp == Op && \"unexpected operator name\");\n        }\n\n        // Make a note in the AST if we did any rewriting.\n        if (Best->RewriteKind != CRK_None)\n          R = new (Context) CXXRewrittenBinaryOperator(R.get(), IsReversed);\n\n        return R;\n      } else {\n        // We matched a built-in operator. Convert the arguments, then\n        // break out so that we will build the appropriate built-in\n        // operator node.\n        ExprResult ArgsRes0 = PerformImplicitConversion(\n            Args[0], Best->BuiltinParamTypes[0], Best->Conversions[0],\n            AA_Passing, CCK_ForBuiltinOverloadedOp);\n        if (ArgsRes0.isInvalid())\n          return ExprError();\n        Args[0] = ArgsRes0.get();\n\n        ExprResult ArgsRes1 = PerformImplicitConversion(\n            Args[1], Best->BuiltinParamTypes[1], Best->Conversions[1],\n            AA_Passing, CCK_ForBuiltinOverloadedOp);\n        if (ArgsRes1.isInvalid())\n          return ExprError();\n        Args[1] = ArgsRes1.get();\n        break;\n      }\n    }\n\n    case OR_No_Viable_Function: {\n      // C++ [over.match.oper]p9:\n      //   If the operator is the operator , [...] and there are no\n      //   viable functions, then the operator is assumed to be the\n      //   built-in operator and interpreted according to clause 5.\n      if (Opc == BO_Comma)\n        break;\n\n      // When defaulting an 'operator<=>', we can try to synthesize a three-way\n      // compare result using '==' and '<'.\n      if (DefaultedFn && Opc == BO_Cmp) {\n        ExprResult E = BuildSynthesizedThreeWayComparison(OpLoc, Fns, Args[0],\n                                                          Args[1], DefaultedFn);\n        if (E.isInvalid() || E.isUsable())\n          return E;\n      }\n\n      // For class as left operand for assignment or compound assignment\n      // operator do not fall through to handling in built-in, but report that\n      // no overloaded assignment operator found\n      ExprResult Result = ExprError();\n      StringRef OpcStr = BinaryOperator::getOpcodeStr(Opc);\n      auto Cands = CandidateSet.CompleteCandidates(*this, OCD_AllCandidates,\n                                                   Args, OpLoc);\n      if (Args[0]->getType()->isRecordType() &&\n          Opc >= BO_Assign && Opc <= BO_OrAssign) {\n        Diag(OpLoc,  diag::err_ovl_no_viable_oper)\n             << BinaryOperator::getOpcodeStr(Opc)\n             << Args[0]->getSourceRange() << Args[1]->getSourceRange();\n        if (Args[0]->getType()->isIncompleteType()) {\n          Diag(OpLoc, diag::note_assign_lhs_incomplete)\n            << Args[0]->getType()\n            << Args[0]->getSourceRange() << Args[1]->getSourceRange();\n        }\n      } else {\n        // This is an erroneous use of an operator which can be overloaded by\n        // a non-member function. Check for non-member operators which were\n        // defined too late to be candidates.\n        if (DiagnoseTwoPhaseOperatorLookup(*this, Op, OpLoc, Args))\n          // FIXME: Recover by calling the found function.\n          return ExprError();\n\n        // No viable function; try to create a built-in operation, which will\n        // produce an error. Then, show the non-viable candidates.\n        Result = CreateBuiltinBinOp(OpLoc, Opc, Args[0], Args[1]);\n      }\n      assert(Result.isInvalid() &&\n             \"C++ binary operator overloading is missing candidates!\");\n      CandidateSet.NoteCandidates(*this, Args, Cands, OpcStr, OpLoc);\n      return Result;\n    }\n\n    case OR_Ambiguous:\n      CandidateSet.NoteCandidates(\n          PartialDiagnosticAt(OpLoc, PDiag(diag::err_ovl_ambiguous_oper_binary)\n                                         << BinaryOperator::getOpcodeStr(Opc)\n                                         << Args[0]->getType()\n                                         << Args[1]->getType()\n                                         << Args[0]->getSourceRange()\n                                         << Args[1]->getSourceRange()),\n          *this, OCD_AmbiguousCandidates, Args, BinaryOperator::getOpcodeStr(Opc),\n          OpLoc);\n      return ExprError();\n\n    case OR_Deleted:\n      if (isImplicitlyDeleted(Best->Function)) {\n        FunctionDecl *DeletedFD = Best->Function;\n        DefaultedFunctionKind DFK = getDefaultedFunctionKind(DeletedFD);\n        if (DFK.isSpecialMember()) {\n          Diag(OpLoc, diag::err_ovl_deleted_special_oper)\n            << Args[0]->getType() << DFK.asSpecialMember();\n        } else {\n          assert(DFK.isComparison());\n          Diag(OpLoc, diag::err_ovl_deleted_comparison)\n            << Args[0]->getType() << DeletedFD;\n        }\n\n        // The user probably meant to call this special member. Just\n        // explain why it's deleted.\n        NoteDeletedFunction(DeletedFD);\n        return ExprError();\n      }\n      CandidateSet.NoteCandidates(\n          PartialDiagnosticAt(\n              OpLoc, PDiag(diag::err_ovl_deleted_oper)\n                         << getOperatorSpelling(Best->Function->getDeclName()\n                                                    .getCXXOverloadedOperator())\n                         << Args[0]->getSourceRange()\n                         << Args[1]->getSourceRange()),\n          *this, OCD_AllCandidates, Args, BinaryOperator::getOpcodeStr(Opc),\n          OpLoc);\n      return ExprError();\n  }\n\n  // We matched a built-in operator; build it.\n  return CreateBuiltinBinOp(OpLoc, Opc, Args[0], Args[1]);\n}\n\nExprResult Sema::BuildSynthesizedThreeWayComparison(\n    SourceLocation OpLoc, const UnresolvedSetImpl &Fns, Expr *LHS, Expr *RHS,\n    FunctionDecl *DefaultedFn) {\n  const ComparisonCategoryInfo *Info =\n      Context.CompCategories.lookupInfoForType(DefaultedFn->getReturnType());\n  // If we're not producing a known comparison category type, we can't\n  // synthesize a three-way comparison. Let the caller diagnose this.\n  if (!Info)\n    return ExprResult((Expr*)nullptr);\n\n  // If we ever want to perform this synthesis more generally, we will need to\n  // apply the temporary materialization conversion to the operands.\n  assert(LHS->isGLValue() && RHS->isGLValue() &&\n         \"cannot use prvalue expressions more than once\");\n  Expr *OrigLHS = LHS;\n  Expr *OrigRHS = RHS;\n\n  // Replace the LHS and RHS with OpaqueValueExprs; we're going to refer to\n  // each of them multiple times below.\n  LHS = new (Context)\n      OpaqueValueExpr(LHS->getExprLoc(), LHS->getType(), LHS->getValueKind(),\n                      LHS->getObjectKind(), LHS);\n  RHS = new (Context)\n      OpaqueValueExpr(RHS->getExprLoc(), RHS->getType(), RHS->getValueKind(),\n                      RHS->getObjectKind(), RHS);\n\n  ExprResult Eq = CreateOverloadedBinOp(OpLoc, BO_EQ, Fns, LHS, RHS, true, true,\n                                        DefaultedFn);\n  if (Eq.isInvalid())\n    return ExprError();\n\n  ExprResult Less = CreateOverloadedBinOp(OpLoc, BO_LT, Fns, LHS, RHS, true,\n                                          true, DefaultedFn);\n  if (Less.isInvalid())\n    return ExprError();\n\n  ExprResult Greater;\n  if (Info->isPartial()) {\n    Greater = CreateOverloadedBinOp(OpLoc, BO_LT, Fns, RHS, LHS, true, true,\n                                    DefaultedFn);\n    if (Greater.isInvalid())\n      return ExprError();\n  }\n\n  // Form the list of comparisons we're going to perform.\n  struct Comparison {\n    ExprResult Cmp;\n    ComparisonCategoryResult Result;\n  } Comparisons[4] =\n  { {Eq, Info->isStrong() ? ComparisonCategoryResult::Equal\n                          : ComparisonCategoryResult::Equivalent},\n    {Less, ComparisonCategoryResult::Less},\n    {Greater, ComparisonCategoryResult::Greater},\n    {ExprResult(), ComparisonCategoryResult::Unordered},\n  };\n\n  int I = Info->isPartial() ? 3 : 2;\n\n  // Combine the comparisons with suitable conditional expressions.\n  ExprResult Result;\n  for (; I >= 0; --I) {\n    // Build a reference to the comparison category constant.\n    auto *VI = Info->lookupValueInfo(Comparisons[I].Result);\n    // FIXME: Missing a constant for a comparison category. Diagnose this?\n    if (!VI)\n      return ExprResult((Expr*)nullptr);\n    ExprResult ThisResult =\n        BuildDeclarationNameExpr(CXXScopeSpec(), DeclarationNameInfo(), VI->VD);\n    if (ThisResult.isInvalid())\n      return ExprError();\n\n    // Build a conditional unless this is the final case.\n    if (Result.get()) {\n      Result = ActOnConditionalOp(OpLoc, OpLoc, Comparisons[I].Cmp.get(),\n                                  ThisResult.get(), Result.get());\n      if (Result.isInvalid())\n        return ExprError();\n    } else {\n      Result = ThisResult;\n    }\n  }\n\n  // Build a PseudoObjectExpr to model the rewriting of an <=> operator, and to\n  // bind the OpaqueValueExprs before they're (repeatedly) used.\n  Expr *SyntacticForm = BinaryOperator::Create(\n      Context, OrigLHS, OrigRHS, BO_Cmp, Result.get()->getType(),\n      Result.get()->getValueKind(), Result.get()->getObjectKind(), OpLoc,\n      CurFPFeatureOverrides());\n  Expr *SemanticForm[] = {LHS, RHS, Result.get()};\n  return PseudoObjectExpr::Create(Context, SyntacticForm, SemanticForm, 2);\n}\n\nExprResult\nSema::CreateOverloadedArraySubscriptExpr(SourceLocation LLoc,\n                                         SourceLocation RLoc,\n                                         Expr *Base, Expr *Idx) {\n  Expr *Args[2] = { Base, Idx };\n  DeclarationName OpName =\n      Context.DeclarationNames.getCXXOperatorName(OO_Subscript);\n\n  // If either side is type-dependent, create an appropriate dependent\n  // expression.\n  if (Args[0]->isTypeDependent() || Args[1]->isTypeDependent()) {\n\n    CXXRecordDecl *NamingClass = nullptr; // lookup ignores member operators\n    // CHECKME: no 'operator' keyword?\n    DeclarationNameInfo OpNameInfo(OpName, LLoc);\n    OpNameInfo.setCXXOperatorNameRange(SourceRange(LLoc, RLoc));\n    ExprResult Fn = CreateUnresolvedLookupExpr(\n        NamingClass, NestedNameSpecifierLoc(), OpNameInfo, UnresolvedSet<0>());\n    if (Fn.isInvalid())\n      return ExprError();\n    // Can't add any actual overloads yet\n\n    return CXXOperatorCallExpr::Create(Context, OO_Subscript, Fn.get(), Args,\n                                       Context.DependentTy, VK_RValue, RLoc,\n                                       CurFPFeatureOverrides());\n  }\n\n  // Handle placeholders on both operands.\n  if (checkPlaceholderForOverload(*this, Args[0]))\n    return ExprError();\n  if (checkPlaceholderForOverload(*this, Args[1]))\n    return ExprError();\n\n  // Build an empty overload set.\n  OverloadCandidateSet CandidateSet(LLoc, OverloadCandidateSet::CSK_Operator);\n\n  // Subscript can only be overloaded as a member function.\n\n  // Add operator candidates that are member functions.\n  AddMemberOperatorCandidates(OO_Subscript, LLoc, Args, CandidateSet);\n\n  // Add builtin operator candidates.\n  AddBuiltinOperatorCandidates(OO_Subscript, LLoc, Args, CandidateSet);\n\n  bool HadMultipleCandidates = (CandidateSet.size() > 1);\n\n  // Perform overload resolution.\n  OverloadCandidateSet::iterator Best;\n  switch (CandidateSet.BestViableFunction(*this, LLoc, Best)) {\n    case OR_Success: {\n      // We found a built-in operator or an overloaded operator.\n      FunctionDecl *FnDecl = Best->Function;\n\n      if (FnDecl) {\n        // We matched an overloaded operator. Build a call to that\n        // operator.\n\n        CheckMemberOperatorAccess(LLoc, Args[0], Args[1], Best->FoundDecl);\n\n        // Convert the arguments.\n        CXXMethodDecl *Method = cast<CXXMethodDecl>(FnDecl);\n        ExprResult Arg0 =\n          PerformObjectArgumentInitialization(Args[0], /*Qualifier=*/nullptr,\n                                              Best->FoundDecl, Method);\n        if (Arg0.isInvalid())\n          return ExprError();\n        Args[0] = Arg0.get();\n\n        // Convert the arguments.\n        ExprResult InputInit\n          = PerformCopyInitialization(InitializedEntity::InitializeParameter(\n                                                      Context,\n                                                      FnDecl->getParamDecl(0)),\n                                      SourceLocation(),\n                                      Args[1]);\n        if (InputInit.isInvalid())\n          return ExprError();\n\n        Args[1] = InputInit.getAs<Expr>();\n\n        // Build the actual expression node.\n        DeclarationNameInfo OpLocInfo(OpName, LLoc);\n        OpLocInfo.setCXXOperatorNameRange(SourceRange(LLoc, RLoc));\n        ExprResult FnExpr = CreateFunctionRefExpr(*this, FnDecl,\n                                                  Best->FoundDecl,\n                                                  Base,\n                                                  HadMultipleCandidates,\n                                                  OpLocInfo.getLoc(),\n                                                  OpLocInfo.getInfo());\n        if (FnExpr.isInvalid())\n          return ExprError();\n\n        // Determine the result type\n        QualType ResultTy = FnDecl->getReturnType();\n        ExprValueKind VK = Expr::getValueKindForType(ResultTy);\n        ResultTy = ResultTy.getNonLValueExprType(Context);\n\n        CXXOperatorCallExpr *TheCall = CXXOperatorCallExpr::Create(\n            Context, OO_Subscript, FnExpr.get(), Args, ResultTy, VK, RLoc,\n            CurFPFeatureOverrides());\n        if (CheckCallReturnType(FnDecl->getReturnType(), LLoc, TheCall, FnDecl))\n          return ExprError();\n\n        if (CheckFunctionCall(Method, TheCall,\n                              Method->getType()->castAs<FunctionProtoType>()))\n          return ExprError();\n\n        return MaybeBindToTemporary(TheCall);\n      } else {\n        // We matched a built-in operator. Convert the arguments, then\n        // break out so that we will build the appropriate built-in\n        // operator node.\n        ExprResult ArgsRes0 = PerformImplicitConversion(\n            Args[0], Best->BuiltinParamTypes[0], Best->Conversions[0],\n            AA_Passing, CCK_ForBuiltinOverloadedOp);\n        if (ArgsRes0.isInvalid())\n          return ExprError();\n        Args[0] = ArgsRes0.get();\n\n        ExprResult ArgsRes1 = PerformImplicitConversion(\n            Args[1], Best->BuiltinParamTypes[1], Best->Conversions[1],\n            AA_Passing, CCK_ForBuiltinOverloadedOp);\n        if (ArgsRes1.isInvalid())\n          return ExprError();\n        Args[1] = ArgsRes1.get();\n\n        break;\n      }\n    }\n\n    case OR_No_Viable_Function: {\n      PartialDiagnostic PD = CandidateSet.empty()\n          ? (PDiag(diag::err_ovl_no_oper)\n             << Args[0]->getType() << /*subscript*/ 0\n             << Args[0]->getSourceRange() << Args[1]->getSourceRange())\n          : (PDiag(diag::err_ovl_no_viable_subscript)\n             << Args[0]->getType() << Args[0]->getSourceRange()\n             << Args[1]->getSourceRange());\n      CandidateSet.NoteCandidates(PartialDiagnosticAt(LLoc, PD), *this,\n                                  OCD_AllCandidates, Args, \"[]\", LLoc);\n      return ExprError();\n    }\n\n    case OR_Ambiguous:\n      CandidateSet.NoteCandidates(\n          PartialDiagnosticAt(LLoc, PDiag(diag::err_ovl_ambiguous_oper_binary)\n                                        << \"[]\" << Args[0]->getType()\n                                        << Args[1]->getType()\n                                        << Args[0]->getSourceRange()\n                                        << Args[1]->getSourceRange()),\n          *this, OCD_AmbiguousCandidates, Args, \"[]\", LLoc);\n      return ExprError();\n\n    case OR_Deleted:\n      CandidateSet.NoteCandidates(\n          PartialDiagnosticAt(LLoc, PDiag(diag::err_ovl_deleted_oper)\n                                        << \"[]\" << Args[0]->getSourceRange()\n                                        << Args[1]->getSourceRange()),\n          *this, OCD_AllCandidates, Args, \"[]\", LLoc);\n      return ExprError();\n    }\n\n  // We matched a built-in operator; build it.\n  return CreateBuiltinArraySubscriptExpr(Args[0], LLoc, Args[1], RLoc);\n}\n\n/// BuildCallToMemberFunction - Build a call to a member\n/// function. MemExpr is the expression that refers to the member\n/// function (and includes the object parameter), Args/NumArgs are the\n/// arguments to the function call (not including the object\n/// parameter). The caller needs to validate that the member\n/// expression refers to a non-static member function or an overloaded\n/// member function.\nExprResult Sema::BuildCallToMemberFunction(Scope *S, Expr *MemExprE,\n                                           SourceLocation LParenLoc,\n                                           MultiExprArg Args,\n                                           SourceLocation RParenLoc,\n                                           bool AllowRecovery) {\n  assert(MemExprE->getType() == Context.BoundMemberTy ||\n         MemExprE->getType() == Context.OverloadTy);\n\n  // Dig out the member expression. This holds both the object\n  // argument and the member function we're referring to.\n  Expr *NakedMemExpr = MemExprE->IgnoreParens();\n\n  // Determine whether this is a call to a pointer-to-member function.\n  if (BinaryOperator *op = dyn_cast<BinaryOperator>(NakedMemExpr)) {\n    assert(op->getType() == Context.BoundMemberTy);\n    assert(op->getOpcode() == BO_PtrMemD || op->getOpcode() == BO_PtrMemI);\n\n    QualType fnType =\n      op->getRHS()->getType()->castAs<MemberPointerType>()->getPointeeType();\n\n    const FunctionProtoType *proto = fnType->castAs<FunctionProtoType>();\n    QualType resultType = proto->getCallResultType(Context);\n    ExprValueKind valueKind = Expr::getValueKindForType(proto->getReturnType());\n\n    // Check that the object type isn't more qualified than the\n    // member function we're calling.\n    Qualifiers funcQuals = proto->getMethodQuals();\n\n    QualType objectType = op->getLHS()->getType();\n    if (op->getOpcode() == BO_PtrMemI)\n      objectType = objectType->castAs<PointerType>()->getPointeeType();\n    Qualifiers objectQuals = objectType.getQualifiers();\n\n    Qualifiers difference = objectQuals - funcQuals;\n    difference.removeObjCGCAttr();\n    difference.removeAddressSpace();\n    if (difference) {\n      std::string qualsString = difference.getAsString();\n      Diag(LParenLoc, diag::err_pointer_to_member_call_drops_quals)\n        << fnType.getUnqualifiedType()\n        << qualsString\n        << (qualsString.find(' ') == std::string::npos ? 1 : 2);\n    }\n\n    CXXMemberCallExpr *call = CXXMemberCallExpr::Create(\n        Context, MemExprE, Args, resultType, valueKind, RParenLoc,\n        CurFPFeatureOverrides(), proto->getNumParams());\n\n    if (CheckCallReturnType(proto->getReturnType(), op->getRHS()->getBeginLoc(),\n                            call, nullptr))\n      return ExprError();\n\n    if (ConvertArgumentsForCall(call, op, nullptr, proto, Args, RParenLoc))\n      return ExprError();\n\n    if (CheckOtherCall(call, proto))\n      return ExprError();\n\n    return MaybeBindToTemporary(call);\n  }\n\n  // We only try to build a recovery expr at this level if we can preserve\n  // the return type, otherwise we return ExprError() and let the caller\n  // recover.\n  auto BuildRecoveryExpr = [&](QualType Type) {\n    if (!AllowRecovery)\n      return ExprError();\n    std::vector<Expr *> SubExprs = {MemExprE};\n    llvm::for_each(Args, [&SubExprs](Expr *E) { SubExprs.push_back(E); });\n    return CreateRecoveryExpr(MemExprE->getBeginLoc(), RParenLoc, SubExprs,\n                              Type);\n  };\n  if (isa<CXXPseudoDestructorExpr>(NakedMemExpr))\n    return CallExpr::Create(Context, MemExprE, Args, Context.VoidTy, VK_RValue,\n                            RParenLoc, CurFPFeatureOverrides());\n\n  UnbridgedCastsSet UnbridgedCasts;\n  if (checkArgPlaceholdersForOverload(*this, Args, UnbridgedCasts))\n    return ExprError();\n\n  MemberExpr *MemExpr;\n  CXXMethodDecl *Method = nullptr;\n  DeclAccessPair FoundDecl = DeclAccessPair::make(nullptr, AS_public);\n  NestedNameSpecifier *Qualifier = nullptr;\n  if (isa<MemberExpr>(NakedMemExpr)) {\n    MemExpr = cast<MemberExpr>(NakedMemExpr);\n    Method = cast<CXXMethodDecl>(MemExpr->getMemberDecl());\n    FoundDecl = MemExpr->getFoundDecl();\n    Qualifier = MemExpr->getQualifier();\n    UnbridgedCasts.restore();\n  } else {\n    UnresolvedMemberExpr *UnresExpr = cast<UnresolvedMemberExpr>(NakedMemExpr);\n    Qualifier = UnresExpr->getQualifier();\n\n    QualType ObjectType = UnresExpr->getBaseType();\n    Expr::Classification ObjectClassification\n      = UnresExpr->isArrow()? Expr::Classification::makeSimpleLValue()\n                            : UnresExpr->getBase()->Classify(Context);\n\n    // Add overload candidates\n    OverloadCandidateSet CandidateSet(UnresExpr->getMemberLoc(),\n                                      OverloadCandidateSet::CSK_Normal);\n\n    // FIXME: avoid copy.\n    TemplateArgumentListInfo TemplateArgsBuffer, *TemplateArgs = nullptr;\n    if (UnresExpr->hasExplicitTemplateArgs()) {\n      UnresExpr->copyTemplateArgumentsInto(TemplateArgsBuffer);\n      TemplateArgs = &TemplateArgsBuffer;\n    }\n\n    for (UnresolvedMemberExpr::decls_iterator I = UnresExpr->decls_begin(),\n           E = UnresExpr->decls_end(); I != E; ++I) {\n\n      NamedDecl *Func = *I;\n      CXXRecordDecl *ActingDC = cast<CXXRecordDecl>(Func->getDeclContext());\n      if (isa<UsingShadowDecl>(Func))\n        Func = cast<UsingShadowDecl>(Func)->getTargetDecl();\n\n\n      // Microsoft supports direct constructor calls.\n      if (getLangOpts().MicrosoftExt && isa<CXXConstructorDecl>(Func)) {\n        AddOverloadCandidate(cast<CXXConstructorDecl>(Func), I.getPair(), Args,\n                             CandidateSet,\n                             /*SuppressUserConversions*/ false);\n      } else if ((Method = dyn_cast<CXXMethodDecl>(Func))) {\n        // If explicit template arguments were provided, we can't call a\n        // non-template member function.\n        if (TemplateArgs)\n          continue;\n\n        AddMethodCandidate(Method, I.getPair(), ActingDC, ObjectType,\n                           ObjectClassification, Args, CandidateSet,\n                           /*SuppressUserConversions=*/false);\n      } else {\n        AddMethodTemplateCandidate(\n            cast<FunctionTemplateDecl>(Func), I.getPair(), ActingDC,\n            TemplateArgs, ObjectType, ObjectClassification, Args, CandidateSet,\n            /*SuppressUserConversions=*/false);\n      }\n    }\n\n    DeclarationName DeclName = UnresExpr->getMemberName();\n\n    UnbridgedCasts.restore();\n\n    OverloadCandidateSet::iterator Best;\n    bool Succeeded = false;\n    switch (CandidateSet.BestViableFunction(*this, UnresExpr->getBeginLoc(),\n                                            Best)) {\n    case OR_Success:\n      Method = cast<CXXMethodDecl>(Best->Function);\n      FoundDecl = Best->FoundDecl;\n      CheckUnresolvedMemberAccess(UnresExpr, Best->FoundDecl);\n      if (DiagnoseUseOfDecl(Best->FoundDecl, UnresExpr->getNameLoc()))\n        break;\n      // If FoundDecl is different from Method (such as if one is a template\n      // and the other a specialization), make sure DiagnoseUseOfDecl is\n      // called on both.\n      // FIXME: This would be more comprehensively addressed by modifying\n      // DiagnoseUseOfDecl to accept both the FoundDecl and the decl\n      // being used.\n      if (Method != FoundDecl.getDecl() &&\n                      DiagnoseUseOfDecl(Method, UnresExpr->getNameLoc()))\n        break;\n      Succeeded = true;\n      break;\n\n    case OR_No_Viable_Function:\n      CandidateSet.NoteCandidates(\n          PartialDiagnosticAt(\n              UnresExpr->getMemberLoc(),\n              PDiag(diag::err_ovl_no_viable_member_function_in_call)\n                  << DeclName << MemExprE->getSourceRange()),\n          *this, OCD_AllCandidates, Args);\n      break;\n    case OR_Ambiguous:\n      CandidateSet.NoteCandidates(\n          PartialDiagnosticAt(UnresExpr->getMemberLoc(),\n                              PDiag(diag::err_ovl_ambiguous_member_call)\n                                  << DeclName << MemExprE->getSourceRange()),\n          *this, OCD_AmbiguousCandidates, Args);\n      break;\n    case OR_Deleted:\n      CandidateSet.NoteCandidates(\n          PartialDiagnosticAt(UnresExpr->getMemberLoc(),\n                              PDiag(diag::err_ovl_deleted_member_call)\n                                  << DeclName << MemExprE->getSourceRange()),\n          *this, OCD_AllCandidates, Args);\n      break;\n    }\n    // Overload resolution fails, try to recover.\n    if (!Succeeded)\n      return BuildRecoveryExpr(chooseRecoveryType(CandidateSet, &Best));\n\n    MemExprE = FixOverloadedFunctionReference(MemExprE, FoundDecl, Method);\n\n    // If overload resolution picked a static member, build a\n    // non-member call based on that function.\n    if (Method->isStatic()) {\n      return BuildResolvedCallExpr(MemExprE, Method, LParenLoc, Args,\n                                   RParenLoc);\n    }\n\n    MemExpr = cast<MemberExpr>(MemExprE->IgnoreParens());\n  }\n\n  QualType ResultType = Method->getReturnType();\n  ExprValueKind VK = Expr::getValueKindForType(ResultType);\n  ResultType = ResultType.getNonLValueExprType(Context);\n\n  assert(Method && \"Member call to something that isn't a method?\");\n  const auto *Proto = Method->getType()->castAs<FunctionProtoType>();\n  CXXMemberCallExpr *TheCall = CXXMemberCallExpr::Create(\n      Context, MemExprE, Args, ResultType, VK, RParenLoc,\n      CurFPFeatureOverrides(), Proto->getNumParams());\n\n  // Check for a valid return type.\n  if (CheckCallReturnType(Method->getReturnType(), MemExpr->getMemberLoc(),\n                          TheCall, Method))\n    return BuildRecoveryExpr(ResultType);\n\n  // Convert the object argument (for a non-static member function call).\n  // We only need to do this if there was actually an overload; otherwise\n  // it was done at lookup.\n  if (!Method->isStatic()) {\n    ExprResult ObjectArg =\n      PerformObjectArgumentInitialization(MemExpr->getBase(), Qualifier,\n                                          FoundDecl, Method);\n    if (ObjectArg.isInvalid())\n      return ExprError();\n    MemExpr->setBase(ObjectArg.get());\n  }\n\n  // Convert the rest of the arguments\n  if (ConvertArgumentsForCall(TheCall, MemExpr, Method, Proto, Args,\n                              RParenLoc))\n    return BuildRecoveryExpr(ResultType);\n\n  DiagnoseSentinelCalls(Method, LParenLoc, Args);\n\n  if (CheckFunctionCall(Method, TheCall, Proto))\n    return ExprError();\n\n  // In the case the method to call was not selected by the overloading\n  // resolution process, we still need to handle the enable_if attribute. Do\n  // that here, so it will not hide previous -- and more relevant -- errors.\n  if (auto *MemE = dyn_cast<MemberExpr>(NakedMemExpr)) {\n    if (const EnableIfAttr *Attr =\n            CheckEnableIf(Method, LParenLoc, Args, true)) {\n      Diag(MemE->getMemberLoc(),\n           diag::err_ovl_no_viable_member_function_in_call)\n          << Method << Method->getSourceRange();\n      Diag(Method->getLocation(),\n           diag::note_ovl_candidate_disabled_by_function_cond_attr)\n          << Attr->getCond()->getSourceRange() << Attr->getMessage();\n      return ExprError();\n    }\n  }\n\n  if ((isa<CXXConstructorDecl>(CurContext) ||\n       isa<CXXDestructorDecl>(CurContext)) &&\n      TheCall->getMethodDecl()->isPure()) {\n    const CXXMethodDecl *MD = TheCall->getMethodDecl();\n\n    if (isa<CXXThisExpr>(MemExpr->getBase()->IgnoreParenCasts()) &&\n        MemExpr->performsVirtualDispatch(getLangOpts())) {\n      Diag(MemExpr->getBeginLoc(),\n           diag::warn_call_to_pure_virtual_member_function_from_ctor_dtor)\n          << MD->getDeclName() << isa<CXXDestructorDecl>(CurContext)\n          << MD->getParent();\n\n      Diag(MD->getBeginLoc(), diag::note_previous_decl) << MD->getDeclName();\n      if (getLangOpts().AppleKext)\n        Diag(MemExpr->getBeginLoc(), diag::note_pure_qualified_call_kext)\n            << MD->getParent() << MD->getDeclName();\n    }\n  }\n\n  if (CXXDestructorDecl *DD =\n          dyn_cast<CXXDestructorDecl>(TheCall->getMethodDecl())) {\n    // a->A::f() doesn't go through the vtable, except in AppleKext mode.\n    bool CallCanBeVirtual = !MemExpr->hasQualifier() || getLangOpts().AppleKext;\n    CheckVirtualDtorCall(DD, MemExpr->getBeginLoc(), /*IsDelete=*/false,\n                         CallCanBeVirtual, /*WarnOnNonAbstractTypes=*/true,\n                         MemExpr->getMemberLoc());\n  }\n\n  return CheckForImmediateInvocation(MaybeBindToTemporary(TheCall),\n                                     TheCall->getMethodDecl());\n}\n\n/// BuildCallToObjectOfClassType - Build a call to an object of class\n/// type (C++ [over.call.object]), which can end up invoking an\n/// overloaded function call operator (@c operator()) or performing a\n/// user-defined conversion on the object argument.\nExprResult\nSema::BuildCallToObjectOfClassType(Scope *S, Expr *Obj,\n                                   SourceLocation LParenLoc,\n                                   MultiExprArg Args,\n                                   SourceLocation RParenLoc) {\n  if (checkPlaceholderForOverload(*this, Obj))\n    return ExprError();\n  ExprResult Object = Obj;\n\n  UnbridgedCastsSet UnbridgedCasts;\n  if (checkArgPlaceholdersForOverload(*this, Args, UnbridgedCasts))\n    return ExprError();\n\n  assert(Object.get()->getType()->isRecordType() &&\n         \"Requires object type argument\");\n\n  // C++ [over.call.object]p1:\n  //  If the primary-expression E in the function call syntax\n  //  evaluates to a class object of type \"cv T\", then the set of\n  //  candidate functions includes at least the function call\n  //  operators of T. The function call operators of T are obtained by\n  //  ordinary lookup of the name operator() in the context of\n  //  (E).operator().\n  OverloadCandidateSet CandidateSet(LParenLoc,\n                                    OverloadCandidateSet::CSK_Operator);\n  DeclarationName OpName = Context.DeclarationNames.getCXXOperatorName(OO_Call);\n\n  if (RequireCompleteType(LParenLoc, Object.get()->getType(),\n                          diag::err_incomplete_object_call, Object.get()))\n    return true;\n\n  const auto *Record = Object.get()->getType()->castAs<RecordType>();\n  LookupResult R(*this, OpName, LParenLoc, LookupOrdinaryName);\n  LookupQualifiedName(R, Record->getDecl());\n  R.suppressDiagnostics();\n\n  for (LookupResult::iterator Oper = R.begin(), OperEnd = R.end();\n       Oper != OperEnd; ++Oper) {\n    AddMethodCandidate(Oper.getPair(), Object.get()->getType(),\n                       Object.get()->Classify(Context), Args, CandidateSet,\n                       /*SuppressUserConversion=*/false);\n  }\n\n  // C++ [over.call.object]p2:\n  //   In addition, for each (non-explicit in C++0x) conversion function\n  //   declared in T of the form\n  //\n  //        operator conversion-type-id () cv-qualifier;\n  //\n  //   where cv-qualifier is the same cv-qualification as, or a\n  //   greater cv-qualification than, cv, and where conversion-type-id\n  //   denotes the type \"pointer to function of (P1,...,Pn) returning\n  //   R\", or the type \"reference to pointer to function of\n  //   (P1,...,Pn) returning R\", or the type \"reference to function\n  //   of (P1,...,Pn) returning R\", a surrogate call function [...]\n  //   is also considered as a candidate function. Similarly,\n  //   surrogate call functions are added to the set of candidate\n  //   functions for each conversion function declared in an\n  //   accessible base class provided the function is not hidden\n  //   within T by another intervening declaration.\n  const auto &Conversions =\n      cast<CXXRecordDecl>(Record->getDecl())->getVisibleConversionFunctions();\n  for (auto I = Conversions.begin(), E = Conversions.end(); I != E; ++I) {\n    NamedDecl *D = *I;\n    CXXRecordDecl *ActingContext = cast<CXXRecordDecl>(D->getDeclContext());\n    if (isa<UsingShadowDecl>(D))\n      D = cast<UsingShadowDecl>(D)->getTargetDecl();\n\n    // Skip over templated conversion functions; they aren't\n    // surrogates.\n    if (isa<FunctionTemplateDecl>(D))\n      continue;\n\n    CXXConversionDecl *Conv = cast<CXXConversionDecl>(D);\n    if (!Conv->isExplicit()) {\n      // Strip the reference type (if any) and then the pointer type (if\n      // any) to get down to what might be a function type.\n      QualType ConvType = Conv->getConversionType().getNonReferenceType();\n      if (const PointerType *ConvPtrType = ConvType->getAs<PointerType>())\n        ConvType = ConvPtrType->getPointeeType();\n\n      if (const FunctionProtoType *Proto = ConvType->getAs<FunctionProtoType>())\n      {\n        AddSurrogateCandidate(Conv, I.getPair(), ActingContext, Proto,\n                              Object.get(), Args, CandidateSet);\n      }\n    }\n  }\n\n  bool HadMultipleCandidates = (CandidateSet.size() > 1);\n\n  // Perform overload resolution.\n  OverloadCandidateSet::iterator Best;\n  switch (CandidateSet.BestViableFunction(*this, Object.get()->getBeginLoc(),\n                                          Best)) {\n  case OR_Success:\n    // Overload resolution succeeded; we'll build the appropriate call\n    // below.\n    break;\n\n  case OR_No_Viable_Function: {\n    PartialDiagnostic PD =\n        CandidateSet.empty()\n            ? (PDiag(diag::err_ovl_no_oper)\n               << Object.get()->getType() << /*call*/ 1\n               << Object.get()->getSourceRange())\n            : (PDiag(diag::err_ovl_no_viable_object_call)\n               << Object.get()->getType() << Object.get()->getSourceRange());\n    CandidateSet.NoteCandidates(\n        PartialDiagnosticAt(Object.get()->getBeginLoc(), PD), *this,\n        OCD_AllCandidates, Args);\n    break;\n  }\n  case OR_Ambiguous:\n    CandidateSet.NoteCandidates(\n        PartialDiagnosticAt(Object.get()->getBeginLoc(),\n                            PDiag(diag::err_ovl_ambiguous_object_call)\n                                << Object.get()->getType()\n                                << Object.get()->getSourceRange()),\n        *this, OCD_AmbiguousCandidates, Args);\n    break;\n\n  case OR_Deleted:\n    CandidateSet.NoteCandidates(\n        PartialDiagnosticAt(Object.get()->getBeginLoc(),\n                            PDiag(diag::err_ovl_deleted_object_call)\n                                << Object.get()->getType()\n                                << Object.get()->getSourceRange()),\n        *this, OCD_AllCandidates, Args);\n    break;\n  }\n\n  if (Best == CandidateSet.end())\n    return true;\n\n  UnbridgedCasts.restore();\n\n  if (Best->Function == nullptr) {\n    // Since there is no function declaration, this is one of the\n    // surrogate candidates. Dig out the conversion function.\n    CXXConversionDecl *Conv\n      = cast<CXXConversionDecl>(\n                         Best->Conversions[0].UserDefined.ConversionFunction);\n\n    CheckMemberOperatorAccess(LParenLoc, Object.get(), nullptr,\n                              Best->FoundDecl);\n    if (DiagnoseUseOfDecl(Best->FoundDecl, LParenLoc))\n      return ExprError();\n    assert(Conv == Best->FoundDecl.getDecl() &&\n             \"Found Decl & conversion-to-functionptr should be same, right?!\");\n    // We selected one of the surrogate functions that converts the\n    // object parameter to a function pointer. Perform the conversion\n    // on the object argument, then let BuildCallExpr finish the job.\n\n    // Create an implicit member expr to refer to the conversion operator.\n    // and then call it.\n    ExprResult Call = BuildCXXMemberCallExpr(Object.get(), Best->FoundDecl,\n                                             Conv, HadMultipleCandidates);\n    if (Call.isInvalid())\n      return ExprError();\n    // Record usage of conversion in an implicit cast.\n    Call = ImplicitCastExpr::Create(\n        Context, Call.get()->getType(), CK_UserDefinedConversion, Call.get(),\n        nullptr, VK_RValue, CurFPFeatureOverrides());\n\n    return BuildCallExpr(S, Call.get(), LParenLoc, Args, RParenLoc);\n  }\n\n  CheckMemberOperatorAccess(LParenLoc, Object.get(), nullptr, Best->FoundDecl);\n\n  // We found an overloaded operator(). Build a CXXOperatorCallExpr\n  // that calls this method, using Object for the implicit object\n  // parameter and passing along the remaining arguments.\n  CXXMethodDecl *Method = cast<CXXMethodDecl>(Best->Function);\n\n  // An error diagnostic has already been printed when parsing the declaration.\n  if (Method->isInvalidDecl())\n    return ExprError();\n\n  const auto *Proto = Method->getType()->castAs<FunctionProtoType>();\n  unsigned NumParams = Proto->getNumParams();\n\n  DeclarationNameInfo OpLocInfo(\n               Context.DeclarationNames.getCXXOperatorName(OO_Call), LParenLoc);\n  OpLocInfo.setCXXOperatorNameRange(SourceRange(LParenLoc, RParenLoc));\n  ExprResult NewFn = CreateFunctionRefExpr(*this, Method, Best->FoundDecl,\n                                           Obj, HadMultipleCandidates,\n                                           OpLocInfo.getLoc(),\n                                           OpLocInfo.getInfo());\n  if (NewFn.isInvalid())\n    return true;\n\n  // The number of argument slots to allocate in the call. If we have default\n  // arguments we need to allocate space for them as well. We additionally\n  // need one more slot for the object parameter.\n  unsigned NumArgsSlots = 1 + std::max<unsigned>(Args.size(), NumParams);\n\n  // Build the full argument list for the method call (the implicit object\n  // parameter is placed at the beginning of the list).\n  SmallVector<Expr *, 8> MethodArgs(NumArgsSlots);\n\n  bool IsError = false;\n\n  // Initialize the implicit object parameter.\n  ExprResult ObjRes =\n    PerformObjectArgumentInitialization(Object.get(), /*Qualifier=*/nullptr,\n                                        Best->FoundDecl, Method);\n  if (ObjRes.isInvalid())\n    IsError = true;\n  else\n    Object = ObjRes;\n  MethodArgs[0] = Object.get();\n\n  // Check the argument types.\n  for (unsigned i = 0; i != NumParams; i++) {\n    Expr *Arg;\n    if (i < Args.size()) {\n      Arg = Args[i];\n\n      // Pass the argument.\n\n      ExprResult InputInit\n        = PerformCopyInitialization(InitializedEntity::InitializeParameter(\n                                                    Context,\n                                                    Method->getParamDecl(i)),\n                                    SourceLocation(), Arg);\n\n      IsError |= InputInit.isInvalid();\n      Arg = InputInit.getAs<Expr>();\n    } else {\n      ExprResult DefArg\n        = BuildCXXDefaultArgExpr(LParenLoc, Method, Method->getParamDecl(i));\n      if (DefArg.isInvalid()) {\n        IsError = true;\n        break;\n      }\n\n      Arg = DefArg.getAs<Expr>();\n    }\n\n    MethodArgs[i + 1] = Arg;\n  }\n\n  // If this is a variadic call, handle args passed through \"...\".\n  if (Proto->isVariadic()) {\n    // Promote the arguments (C99 6.5.2.2p7).\n    for (unsigned i = NumParams, e = Args.size(); i < e; i++) {\n      ExprResult Arg = DefaultVariadicArgumentPromotion(Args[i], VariadicMethod,\n                                                        nullptr);\n      IsError |= Arg.isInvalid();\n      MethodArgs[i + 1] = Arg.get();\n    }\n  }\n\n  if (IsError)\n    return true;\n\n  DiagnoseSentinelCalls(Method, LParenLoc, Args);\n\n  // Once we've built TheCall, all of the expressions are properly owned.\n  QualType ResultTy = Method->getReturnType();\n  ExprValueKind VK = Expr::getValueKindForType(ResultTy);\n  ResultTy = ResultTy.getNonLValueExprType(Context);\n\n  CXXOperatorCallExpr *TheCall = CXXOperatorCallExpr::Create(\n      Context, OO_Call, NewFn.get(), MethodArgs, ResultTy, VK, RParenLoc,\n      CurFPFeatureOverrides());\n\n  if (CheckCallReturnType(Method->getReturnType(), LParenLoc, TheCall, Method))\n    return true;\n\n  if (CheckFunctionCall(Method, TheCall, Proto))\n    return true;\n\n  return CheckForImmediateInvocation(MaybeBindToTemporary(TheCall), Method);\n}\n\n/// BuildOverloadedArrowExpr - Build a call to an overloaded @c operator->\n///  (if one exists), where @c Base is an expression of class type and\n/// @c Member is the name of the member we're trying to find.\nExprResult\nSema::BuildOverloadedArrowExpr(Scope *S, Expr *Base, SourceLocation OpLoc,\n                               bool *NoArrowOperatorFound) {\n  assert(Base->getType()->isRecordType() &&\n         \"left-hand side must have class type\");\n\n  if (checkPlaceholderForOverload(*this, Base))\n    return ExprError();\n\n  SourceLocation Loc = Base->getExprLoc();\n\n  // C++ [over.ref]p1:\n  //\n  //   [...] An expression x->m is interpreted as (x.operator->())->m\n  //   for a class object x of type T if T::operator->() exists and if\n  //   the operator is selected as the best match function by the\n  //   overload resolution mechanism (13.3).\n  DeclarationName OpName =\n    Context.DeclarationNames.getCXXOperatorName(OO_Arrow);\n  OverloadCandidateSet CandidateSet(Loc, OverloadCandidateSet::CSK_Operator);\n\n  if (RequireCompleteType(Loc, Base->getType(),\n                          diag::err_typecheck_incomplete_tag, Base))\n    return ExprError();\n\n  LookupResult R(*this, OpName, OpLoc, LookupOrdinaryName);\n  LookupQualifiedName(R, Base->getType()->castAs<RecordType>()->getDecl());\n  R.suppressDiagnostics();\n\n  for (LookupResult::iterator Oper = R.begin(), OperEnd = R.end();\n       Oper != OperEnd; ++Oper) {\n    AddMethodCandidate(Oper.getPair(), Base->getType(), Base->Classify(Context),\n                       None, CandidateSet, /*SuppressUserConversion=*/false);\n  }\n\n  bool HadMultipleCandidates = (CandidateSet.size() > 1);\n\n  // Perform overload resolution.\n  OverloadCandidateSet::iterator Best;\n  switch (CandidateSet.BestViableFunction(*this, OpLoc, Best)) {\n  case OR_Success:\n    // Overload resolution succeeded; we'll build the call below.\n    break;\n\n  case OR_No_Viable_Function: {\n    auto Cands = CandidateSet.CompleteCandidates(*this, OCD_AllCandidates, Base);\n    if (CandidateSet.empty()) {\n      QualType BaseType = Base->getType();\n      if (NoArrowOperatorFound) {\n        // Report this specific error to the caller instead of emitting a\n        // diagnostic, as requested.\n        *NoArrowOperatorFound = true;\n        return ExprError();\n      }\n      Diag(OpLoc, diag::err_typecheck_member_reference_arrow)\n        << BaseType << Base->getSourceRange();\n      if (BaseType->isRecordType() && !BaseType->isPointerType()) {\n        Diag(OpLoc, diag::note_typecheck_member_reference_suggestion)\n          << FixItHint::CreateReplacement(OpLoc, \".\");\n      }\n    } else\n      Diag(OpLoc, diag::err_ovl_no_viable_oper)\n        << \"operator->\" << Base->getSourceRange();\n    CandidateSet.NoteCandidates(*this, Base, Cands);\n    return ExprError();\n  }\n  case OR_Ambiguous:\n    CandidateSet.NoteCandidates(\n        PartialDiagnosticAt(OpLoc, PDiag(diag::err_ovl_ambiguous_oper_unary)\n                                       << \"->\" << Base->getType()\n                                       << Base->getSourceRange()),\n        *this, OCD_AmbiguousCandidates, Base);\n    return ExprError();\n\n  case OR_Deleted:\n    CandidateSet.NoteCandidates(\n        PartialDiagnosticAt(OpLoc, PDiag(diag::err_ovl_deleted_oper)\n                                       << \"->\" << Base->getSourceRange()),\n        *this, OCD_AllCandidates, Base);\n    return ExprError();\n  }\n\n  CheckMemberOperatorAccess(OpLoc, Base, nullptr, Best->FoundDecl);\n\n  // Convert the object parameter.\n  CXXMethodDecl *Method = cast<CXXMethodDecl>(Best->Function);\n  ExprResult BaseResult =\n    PerformObjectArgumentInitialization(Base, /*Qualifier=*/nullptr,\n                                        Best->FoundDecl, Method);\n  if (BaseResult.isInvalid())\n    return ExprError();\n  Base = BaseResult.get();\n\n  // Build the operator call.\n  ExprResult FnExpr = CreateFunctionRefExpr(*this, Method, Best->FoundDecl,\n                                            Base, HadMultipleCandidates, OpLoc);\n  if (FnExpr.isInvalid())\n    return ExprError();\n\n  QualType ResultTy = Method->getReturnType();\n  ExprValueKind VK = Expr::getValueKindForType(ResultTy);\n  ResultTy = ResultTy.getNonLValueExprType(Context);\n  CXXOperatorCallExpr *TheCall =\n      CXXOperatorCallExpr::Create(Context, OO_Arrow, FnExpr.get(), Base,\n                                  ResultTy, VK, OpLoc, CurFPFeatureOverrides());\n\n  if (CheckCallReturnType(Method->getReturnType(), OpLoc, TheCall, Method))\n    return ExprError();\n\n  if (CheckFunctionCall(Method, TheCall,\n                        Method->getType()->castAs<FunctionProtoType>()))\n    return ExprError();\n\n  return MaybeBindToTemporary(TheCall);\n}\n\n/// BuildLiteralOperatorCall - Build a UserDefinedLiteral by creating a call to\n/// a literal operator described by the provided lookup results.\nExprResult Sema::BuildLiteralOperatorCall(LookupResult &R,\n                                          DeclarationNameInfo &SuffixInfo,\n                                          ArrayRef<Expr*> Args,\n                                          SourceLocation LitEndLoc,\n                                       TemplateArgumentListInfo *TemplateArgs) {\n  SourceLocation UDSuffixLoc = SuffixInfo.getCXXLiteralOperatorNameLoc();\n\n  OverloadCandidateSet CandidateSet(UDSuffixLoc,\n                                    OverloadCandidateSet::CSK_Normal);\n  AddNonMemberOperatorCandidates(R.asUnresolvedSet(), Args, CandidateSet,\n                                 TemplateArgs);\n\n  bool HadMultipleCandidates = (CandidateSet.size() > 1);\n\n  // Perform overload resolution. This will usually be trivial, but might need\n  // to perform substitutions for a literal operator template.\n  OverloadCandidateSet::iterator Best;\n  switch (CandidateSet.BestViableFunction(*this, UDSuffixLoc, Best)) {\n  case OR_Success:\n  case OR_Deleted:\n    break;\n\n  case OR_No_Viable_Function:\n    CandidateSet.NoteCandidates(\n        PartialDiagnosticAt(UDSuffixLoc,\n                            PDiag(diag::err_ovl_no_viable_function_in_call)\n                                << R.getLookupName()),\n        *this, OCD_AllCandidates, Args);\n    return ExprError();\n\n  case OR_Ambiguous:\n    CandidateSet.NoteCandidates(\n        PartialDiagnosticAt(R.getNameLoc(), PDiag(diag::err_ovl_ambiguous_call)\n                                                << R.getLookupName()),\n        *this, OCD_AmbiguousCandidates, Args);\n    return ExprError();\n  }\n\n  FunctionDecl *FD = Best->Function;\n  ExprResult Fn = CreateFunctionRefExpr(*this, FD, Best->FoundDecl,\n                                        nullptr, HadMultipleCandidates,\n                                        SuffixInfo.getLoc(),\n                                        SuffixInfo.getInfo());\n  if (Fn.isInvalid())\n    return true;\n\n  // Check the argument types. This should almost always be a no-op, except\n  // that array-to-pointer decay is applied to string literals.\n  Expr *ConvArgs[2];\n  for (unsigned ArgIdx = 0, N = Args.size(); ArgIdx != N; ++ArgIdx) {\n    ExprResult InputInit = PerformCopyInitialization(\n      InitializedEntity::InitializeParameter(Context, FD->getParamDecl(ArgIdx)),\n      SourceLocation(), Args[ArgIdx]);\n    if (InputInit.isInvalid())\n      return true;\n    ConvArgs[ArgIdx] = InputInit.get();\n  }\n\n  QualType ResultTy = FD->getReturnType();\n  ExprValueKind VK = Expr::getValueKindForType(ResultTy);\n  ResultTy = ResultTy.getNonLValueExprType(Context);\n\n  UserDefinedLiteral *UDL = UserDefinedLiteral::Create(\n      Context, Fn.get(), llvm::makeArrayRef(ConvArgs, Args.size()), ResultTy,\n      VK, LitEndLoc, UDSuffixLoc, CurFPFeatureOverrides());\n\n  if (CheckCallReturnType(FD->getReturnType(), UDSuffixLoc, UDL, FD))\n    return ExprError();\n\n  if (CheckFunctionCall(FD, UDL, nullptr))\n    return ExprError();\n\n  return CheckForImmediateInvocation(MaybeBindToTemporary(UDL), FD);\n}\n\n/// Build a call to 'begin' or 'end' for a C++11 for-range statement. If the\n/// given LookupResult is non-empty, it is assumed to describe a member which\n/// will be invoked. Otherwise, the function will be found via argument\n/// dependent lookup.\n/// CallExpr is set to a valid expression and FRS_Success returned on success,\n/// otherwise CallExpr is set to ExprError() and some non-success value\n/// is returned.\nSema::ForRangeStatus\nSema::BuildForRangeBeginEndCall(SourceLocation Loc,\n                                SourceLocation RangeLoc,\n                                const DeclarationNameInfo &NameInfo,\n                                LookupResult &MemberLookup,\n                                OverloadCandidateSet *CandidateSet,\n                                Expr *Range, ExprResult *CallExpr) {\n  Scope *S = nullptr;\n\n  CandidateSet->clear(OverloadCandidateSet::CSK_Normal);\n  if (!MemberLookup.empty()) {\n    ExprResult MemberRef =\n        BuildMemberReferenceExpr(Range, Range->getType(), Loc,\n                                 /*IsPtr=*/false, CXXScopeSpec(),\n                                 /*TemplateKWLoc=*/SourceLocation(),\n                                 /*FirstQualifierInScope=*/nullptr,\n                                 MemberLookup,\n                                 /*TemplateArgs=*/nullptr, S);\n    if (MemberRef.isInvalid()) {\n      *CallExpr = ExprError();\n      return FRS_DiagnosticIssued;\n    }\n    *CallExpr = BuildCallExpr(S, MemberRef.get(), Loc, None, Loc, nullptr);\n    if (CallExpr->isInvalid()) {\n      *CallExpr = ExprError();\n      return FRS_DiagnosticIssued;\n    }\n  } else {\n    ExprResult FnR = CreateUnresolvedLookupExpr(/*NamingClass=*/nullptr,\n                                                NestedNameSpecifierLoc(),\n                                                NameInfo, UnresolvedSet<0>());\n    if (FnR.isInvalid())\n      return FRS_DiagnosticIssued;\n    UnresolvedLookupExpr *Fn = cast<UnresolvedLookupExpr>(FnR.get());\n\n    bool CandidateSetError = buildOverloadedCallSet(S, Fn, Fn, Range, Loc,\n                                                    CandidateSet, CallExpr);\n    if (CandidateSet->empty() || CandidateSetError) {\n      *CallExpr = ExprError();\n      return FRS_NoViableFunction;\n    }\n    OverloadCandidateSet::iterator Best;\n    OverloadingResult OverloadResult =\n        CandidateSet->BestViableFunction(*this, Fn->getBeginLoc(), Best);\n\n    if (OverloadResult == OR_No_Viable_Function) {\n      *CallExpr = ExprError();\n      return FRS_NoViableFunction;\n    }\n    *CallExpr = FinishOverloadedCallExpr(*this, S, Fn, Fn, Loc, Range,\n                                         Loc, nullptr, CandidateSet, &Best,\n                                         OverloadResult,\n                                         /*AllowTypoCorrection=*/false);\n    if (CallExpr->isInvalid() || OverloadResult != OR_Success) {\n      *CallExpr = ExprError();\n      return FRS_DiagnosticIssued;\n    }\n  }\n  return FRS_Success;\n}\n\n\n/// FixOverloadedFunctionReference - E is an expression that refers to\n/// a C++ overloaded function (possibly with some parentheses and\n/// perhaps a '&' around it). We have resolved the overloaded function\n/// to the function declaration Fn, so patch up the expression E to\n/// refer (possibly indirectly) to Fn. Returns the new expr.\nExpr *Sema::FixOverloadedFunctionReference(Expr *E, DeclAccessPair Found,\n                                           FunctionDecl *Fn) {\n  if (ParenExpr *PE = dyn_cast<ParenExpr>(E)) {\n    Expr *SubExpr = FixOverloadedFunctionReference(PE->getSubExpr(),\n                                                   Found, Fn);\n    if (SubExpr == PE->getSubExpr())\n      return PE;\n\n    return new (Context) ParenExpr(PE->getLParen(), PE->getRParen(), SubExpr);\n  }\n\n  if (ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(E)) {\n    Expr *SubExpr = FixOverloadedFunctionReference(ICE->getSubExpr(),\n                                                   Found, Fn);\n    assert(Context.hasSameType(ICE->getSubExpr()->getType(),\n                               SubExpr->getType()) &&\n           \"Implicit cast type cannot be determined from overload\");\n    assert(ICE->path_empty() && \"fixing up hierarchy conversion?\");\n    if (SubExpr == ICE->getSubExpr())\n      return ICE;\n\n    return ImplicitCastExpr::Create(Context, ICE->getType(), ICE->getCastKind(),\n                                    SubExpr, nullptr, ICE->getValueKind(),\n                                    CurFPFeatureOverrides());\n  }\n\n  if (auto *GSE = dyn_cast<GenericSelectionExpr>(E)) {\n    if (!GSE->isResultDependent()) {\n      Expr *SubExpr =\n          FixOverloadedFunctionReference(GSE->getResultExpr(), Found, Fn);\n      if (SubExpr == GSE->getResultExpr())\n        return GSE;\n\n      // Replace the resulting type information before rebuilding the generic\n      // selection expression.\n      ArrayRef<Expr *> A = GSE->getAssocExprs();\n      SmallVector<Expr *, 4> AssocExprs(A.begin(), A.end());\n      unsigned ResultIdx = GSE->getResultIndex();\n      AssocExprs[ResultIdx] = SubExpr;\n\n      return GenericSelectionExpr::Create(\n          Context, GSE->getGenericLoc(), GSE->getControllingExpr(),\n          GSE->getAssocTypeSourceInfos(), AssocExprs, GSE->getDefaultLoc(),\n          GSE->getRParenLoc(), GSE->containsUnexpandedParameterPack(),\n          ResultIdx);\n    }\n    // Rather than fall through to the unreachable, return the original generic\n    // selection expression.\n    return GSE;\n  }\n\n  if (UnaryOperator *UnOp = dyn_cast<UnaryOperator>(E)) {\n    assert(UnOp->getOpcode() == UO_AddrOf &&\n           \"Can only take the address of an overloaded function\");\n    if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(Fn)) {\n      if (Method->isStatic()) {\n        // Do nothing: static member functions aren't any different\n        // from non-member functions.\n      } else {\n        // Fix the subexpression, which really has to be an\n        // UnresolvedLookupExpr holding an overloaded member function\n        // or template.\n        Expr *SubExpr = FixOverloadedFunctionReference(UnOp->getSubExpr(),\n                                                       Found, Fn);\n        if (SubExpr == UnOp->getSubExpr())\n          return UnOp;\n\n        assert(isa<DeclRefExpr>(SubExpr)\n               && \"fixed to something other than a decl ref\");\n        assert(cast<DeclRefExpr>(SubExpr)->getQualifier()\n               && \"fixed to a member ref with no nested name qualifier\");\n\n        // We have taken the address of a pointer to member\n        // function. Perform the computation here so that we get the\n        // appropriate pointer to member type.\n        QualType ClassType\n          = Context.getTypeDeclType(cast<RecordDecl>(Method->getDeclContext()));\n        QualType MemPtrType\n          = Context.getMemberPointerType(Fn->getType(), ClassType.getTypePtr());\n        // Under the MS ABI, lock down the inheritance model now.\n        if (Context.getTargetInfo().getCXXABI().isMicrosoft())\n          (void)isCompleteType(UnOp->getOperatorLoc(), MemPtrType);\n\n        return UnaryOperator::Create(\n            Context, SubExpr, UO_AddrOf, MemPtrType, VK_RValue, OK_Ordinary,\n            UnOp->getOperatorLoc(), false, CurFPFeatureOverrides());\n      }\n    }\n    Expr *SubExpr = FixOverloadedFunctionReference(UnOp->getSubExpr(),\n                                                   Found, Fn);\n    if (SubExpr == UnOp->getSubExpr())\n      return UnOp;\n\n    return UnaryOperator::Create(Context, SubExpr, UO_AddrOf,\n                                 Context.getPointerType(SubExpr->getType()),\n                                 VK_RValue, OK_Ordinary, UnOp->getOperatorLoc(),\n                                 false, CurFPFeatureOverrides());\n  }\n\n  if (UnresolvedLookupExpr *ULE = dyn_cast<UnresolvedLookupExpr>(E)) {\n    // FIXME: avoid copy.\n    TemplateArgumentListInfo TemplateArgsBuffer, *TemplateArgs = nullptr;\n    if (ULE->hasExplicitTemplateArgs()) {\n      ULE->copyTemplateArgumentsInto(TemplateArgsBuffer);\n      TemplateArgs = &TemplateArgsBuffer;\n    }\n\n    DeclRefExpr *DRE =\n        BuildDeclRefExpr(Fn, Fn->getType(), VK_LValue, ULE->getNameInfo(),\n                         ULE->getQualifierLoc(), Found.getDecl(),\n                         ULE->getTemplateKeywordLoc(), TemplateArgs);\n    DRE->setHadMultipleCandidates(ULE->getNumDecls() > 1);\n    return DRE;\n  }\n\n  if (UnresolvedMemberExpr *MemExpr = dyn_cast<UnresolvedMemberExpr>(E)) {\n    // FIXME: avoid copy.\n    TemplateArgumentListInfo TemplateArgsBuffer, *TemplateArgs = nullptr;\n    if (MemExpr->hasExplicitTemplateArgs()) {\n      MemExpr->copyTemplateArgumentsInto(TemplateArgsBuffer);\n      TemplateArgs = &TemplateArgsBuffer;\n    }\n\n    Expr *Base;\n\n    // If we're filling in a static method where we used to have an\n    // implicit member access, rewrite to a simple decl ref.\n    if (MemExpr->isImplicitAccess()) {\n      if (cast<CXXMethodDecl>(Fn)->isStatic()) {\n        DeclRefExpr *DRE = BuildDeclRefExpr(\n            Fn, Fn->getType(), VK_LValue, MemExpr->getNameInfo(),\n            MemExpr->getQualifierLoc(), Found.getDecl(),\n            MemExpr->getTemplateKeywordLoc(), TemplateArgs);\n        DRE->setHadMultipleCandidates(MemExpr->getNumDecls() > 1);\n        return DRE;\n      } else {\n        SourceLocation Loc = MemExpr->getMemberLoc();\n        if (MemExpr->getQualifier())\n          Loc = MemExpr->getQualifierLoc().getBeginLoc();\n        Base =\n            BuildCXXThisExpr(Loc, MemExpr->getBaseType(), /*IsImplicit=*/true);\n      }\n    } else\n      Base = MemExpr->getBase();\n\n    ExprValueKind valueKind;\n    QualType type;\n    if (cast<CXXMethodDecl>(Fn)->isStatic()) {\n      valueKind = VK_LValue;\n      type = Fn->getType();\n    } else {\n      valueKind = VK_RValue;\n      type = Context.BoundMemberTy;\n    }\n\n    return BuildMemberExpr(\n        Base, MemExpr->isArrow(), MemExpr->getOperatorLoc(),\n        MemExpr->getQualifierLoc(), MemExpr->getTemplateKeywordLoc(), Fn, Found,\n        /*HadMultipleCandidates=*/true, MemExpr->getMemberNameInfo(),\n        type, valueKind, OK_Ordinary, TemplateArgs);\n  }\n\n  llvm_unreachable(\"Invalid reference to overloaded function\");\n}\n\nExprResult Sema::FixOverloadedFunctionReference(ExprResult E,\n                                                DeclAccessPair Found,\n                                                FunctionDecl *Fn) {\n  return FixOverloadedFunctionReference(E.get(), Found, Fn);\n}\n"}}, "reports": [{"events": [{"location": {"col": 10, "file": 14, "line": 587}, "message": "'DFIArguments' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaOverload.cpp", "reportHash": "85b7cdf08cf5de757c22cf3f9f203090", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 14, "line": 593}, "message": "'DFIParamWithArguments' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaOverload.cpp", "reportHash": "74e55a86b52c8a1f3195eb8e084731fd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 14, "line": 598}, "message": "'DFIDeducedMismatchArgs' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaOverload.cpp", "reportHash": "cc5b735c97d70925448c92eb08baf839", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 14, "line": 604}, "message": "'CNSInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaOverload.cpp", "reportHash": "a582cd1781aad86a025be5b7145a9dec", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
