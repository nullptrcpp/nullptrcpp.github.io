<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "content": "//===- llvm/ADT/DenseMap.h - Dense probed hash table ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DenseMap class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_DENSEMAP_H\n#define LLVM_ADT_DENSEMAP_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/EpochTracker.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/MemAlloc.h\"\n#include \"llvm/Support/ReverseIteration.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <initializer_list>\n#include <iterator>\n#include <new>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\nnamespace detail {\n\n// We extend a pair to allow users to override the bucket type with their own\n// implementation without requiring two members.\ntemplate <typename KeyT, typename ValueT>\nstruct DenseMapPair : public std::pair<KeyT, ValueT> {\n  using std::pair<KeyT, ValueT>::pair;\n\n  KeyT &getFirst() { return std::pair<KeyT, ValueT>::first; }\n  const KeyT &getFirst() const { return std::pair<KeyT, ValueT>::first; }\n  ValueT &getSecond() { return std::pair<KeyT, ValueT>::second; }\n  const ValueT &getSecond() const { return std::pair<KeyT, ValueT>::second; }\n};\n\n} // end namespace detail\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename Bucket = llvm::detail::DenseMapPair<KeyT, ValueT>,\n          bool IsConst = false>\nclass DenseMapIterator;\n\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nclass DenseMapBase : public DebugEpochBase {\n  template <typename T>\n  using const_arg_type_t = typename const_pointer_or_const_ref<T>::type;\n\npublic:\n  using size_type = unsigned;\n  using key_type = KeyT;\n  using mapped_type = ValueT;\n  using value_type = BucketT;\n\n  using iterator = DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT>;\n  using const_iterator =\n      DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT, true>;\n\n  inline iterator begin() {\n    // When the map is empty, avoid the overhead of advancing/retreating past\n    // empty buckets.\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline iterator end() {\n    return makeIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n  inline const_iterator begin() const {\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeConstIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeConstIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline const_iterator end() const {\n    return makeConstIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n\n  LLVM_NODISCARD bool empty() const {\n    return getNumEntries() == 0;\n  }\n  unsigned size() const { return getNumEntries(); }\n\n  /// Grow the densemap so that it can contain at least \\p NumEntries items\n  /// before resizing again.\n  void reserve(size_type NumEntries) {\n    auto NumBuckets = getMinBucketToReserveForEntries(NumEntries);\n    incrementEpoch();\n    if (NumBuckets > getNumBuckets())\n      grow(NumBuckets);\n  }\n\n  void clear() {\n    incrementEpoch();\n    if (getNumEntries() == 0 && getNumTombstones() == 0) return;\n\n    // If the capacity of the array is huge, and the # elements used is small,\n    // shrink the array.\n    if (getNumEntries() * 4 < getNumBuckets() && getNumBuckets() > 64) {\n      shrink_and_clear();\n      return;\n    }\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    if (std::is_trivially_destructible<ValueT>::value) {\n      // Use a simpler loop when values don't need destruction.\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P)\n        P->getFirst() = EmptyKey;\n    } else {\n      unsigned NumEntries = getNumEntries();\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey)) {\n          if (!KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n            P->getSecond().~ValueT();\n            --NumEntries;\n          }\n          P->getFirst() = EmptyKey;\n        }\n      }\n      assert(NumEntries == 0 && \"Node count imbalance!\");\n    }\n    setNumEntries(0);\n    setNumTombstones(0);\n  }\n\n  /// Return 1 if the specified key is in the map, 0 otherwise.\n  size_type count(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    return LookupBucketFor(Val, TheBucket) ? 1 : 0;\n  }\n\n  iterator find(const_arg_type_t<KeyT> Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  const_iterator find(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// Alternate version of find() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template<class LookupKeyT>\n  iterator find_as(const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  template<class LookupKeyT>\n  const_iterator find_as(const LookupKeyT &Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueT lookup(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return TheBucket->getSecond();\n    return ValueT();\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &KV) {\n    return try_emplace(KV.first, KV.second);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(std::pair<KeyT, ValueT> &&KV) {\n    return try_emplace(std::move(KV.first), std::move(KV.second));\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(KeyT &&Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket =\n        InsertIntoBucket(TheBucket, std::move(Key), std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(const KeyT &Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucket(TheBucket, Key, std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// Alternate version of insert() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(std::pair<KeyT, ValueT> &&KV,\n                                      const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucketWithLookup(TheBucket, std::move(KV.first),\n                                           std::move(KV.second), Val);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// insert - Range insertion of pairs.\n  template<typename InputIt>\n  void insert(InputIt I, InputIt E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  bool erase(const KeyT &Val) {\n    BucketT *TheBucket;\n    if (!LookupBucketFor(Val, TheBucket))\n      return false; // not in map.\n\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n    return true;\n  }\n  void erase(iterator I) {\n    BucketT *TheBucket = &*I;\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n  }\n\n  value_type& FindAndConstruct(const KeyT &Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, Key);\n  }\n\n  ValueT &operator[](const KeyT &Key) {\n    return FindAndConstruct(Key).second;\n  }\n\n  value_type& FindAndConstruct(KeyT &&Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, std::move(Key));\n  }\n\n  ValueT &operator[](KeyT &&Key) {\n    return FindAndConstruct(std::move(Key)).second;\n  }\n\n  /// isPointerIntoBucketsArray - Return true if the specified pointer points\n  /// somewhere into the DenseMap's array of buckets (i.e. either to a key or\n  /// value in the DenseMap).\n  bool isPointerIntoBucketsArray(const void *Ptr) const {\n    return Ptr >= getBuckets() && Ptr < getBucketsEnd();\n  }\n\n  /// getPointerIntoBucketsArray() - Return an opaque pointer into the buckets\n  /// array.  In conjunction with the previous method, this can be used to\n  /// determine whether an insertion caused the DenseMap to reallocate.\n  const void *getPointerIntoBucketsArray() const { return getBuckets(); }\n\nprotected:\n  DenseMapBase() = default;\n\n  void destroyAll() {\n    if (getNumBuckets() == 0) // Nothing to do.\n      return;\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n      if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(P->getFirst(), TombstoneKey))\n        P->getSecond().~ValueT();\n      P->getFirst().~KeyT();\n    }\n  }\n\n  void initEmpty() {\n    setNumEntries(0);\n    setNumTombstones(0);\n\n    assert((getNumBuckets() & (getNumBuckets()-1)) == 0 &&\n           \"# initial buckets must be a power of two!\");\n    const KeyT EmptyKey = getEmptyKey();\n    for (BucketT *B = getBuckets(), *E = getBucketsEnd(); B != E; ++B)\n      ::new (&B->getFirst()) KeyT(EmptyKey);\n  }\n\n  /// Returns the number of buckets to allocate to ensure that the DenseMap can\n  /// accommodate \\p NumEntries without need to grow().\n  unsigned getMinBucketToReserveForEntries(unsigned NumEntries) {\n    // Ensure that \"NumEntries * 4 < NumBuckets * 3\"\n    if (NumEntries == 0)\n      return 0;\n    // +1 is required because of the strict equality.\n    // For example if NumEntries is 48, we need to return 401.\n    return NextPowerOf2(NumEntries * 4 / 3 + 1);\n  }\n\n  void moveFromOldBuckets(BucketT *OldBucketsBegin, BucketT *OldBucketsEnd) {\n    initEmpty();\n\n    // Insert all the old elements.\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    for (BucketT *B = OldBucketsBegin, *E = OldBucketsEnd; B != E; ++B) {\n      if (!KeyInfoT::isEqual(B->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(B->getFirst(), TombstoneKey)) {\n        // Insert the key/value into the new table.\n        BucketT *DestBucket;\n        bool FoundVal = LookupBucketFor(B->getFirst(), DestBucket);\n        (void)FoundVal; // silence warning.\n        assert(!FoundVal && \"Key already in new map?\");\n        DestBucket->getFirst() = std::move(B->getFirst());\n        ::new (&DestBucket->getSecond()) ValueT(std::move(B->getSecond()));\n        incrementNumEntries();\n\n        // Free the value.\n        B->getSecond().~ValueT();\n      }\n      B->getFirst().~KeyT();\n    }\n  }\n\n  template <typename OtherBaseT>\n  void copyFrom(\n      const DenseMapBase<OtherBaseT, KeyT, ValueT, KeyInfoT, BucketT> &other) {\n    assert(&other != this);\n    assert(getNumBuckets() == other.getNumBuckets());\n\n    setNumEntries(other.getNumEntries());\n    setNumTombstones(other.getNumTombstones());\n\n    if (std::is_trivially_copyable<KeyT>::value &&\n        std::is_trivially_copyable<ValueT>::value)\n      memcpy(reinterpret_cast<void *>(getBuckets()), other.getBuckets(),\n             getNumBuckets() * sizeof(BucketT));\n    else\n      for (size_t i = 0; i < getNumBuckets(); ++i) {\n        ::new (&getBuckets()[i].getFirst())\n            KeyT(other.getBuckets()[i].getFirst());\n        if (!KeyInfoT::isEqual(getBuckets()[i].getFirst(), getEmptyKey()) &&\n            !KeyInfoT::isEqual(getBuckets()[i].getFirst(), getTombstoneKey()))\n          ::new (&getBuckets()[i].getSecond())\n              ValueT(other.getBuckets()[i].getSecond());\n      }\n  }\n\n  static unsigned getHashValue(const KeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  template<typename LookupKeyT>\n  static unsigned getHashValue(const LookupKeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  static const KeyT getEmptyKey() {\n    static_assert(std::is_base_of<DenseMapBase, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    return KeyInfoT::getEmptyKey();\n  }\n\n  static const KeyT getTombstoneKey() {\n    return KeyInfoT::getTombstoneKey();\n  }\n\nprivate:\n  iterator makeIterator(BucketT *P, BucketT *E,\n                        DebugEpochBase &Epoch,\n                        bool NoAdvance=false) {\n    if (shouldReverseIterate<KeyT>()) {\n      BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return iterator(B, E, Epoch, NoAdvance);\n    }\n    return iterator(P, E, Epoch, NoAdvance);\n  }\n\n  const_iterator makeConstIterator(const BucketT *P, const BucketT *E,\n                                   const DebugEpochBase &Epoch,\n                                   const bool NoAdvance=false) const {\n    if (shouldReverseIterate<KeyT>()) {\n      const BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return const_iterator(B, E, Epoch, NoAdvance);\n    }\n    return const_iterator(P, E, Epoch, NoAdvance);\n  }\n\n  unsigned getNumEntries() const {\n    return static_cast<const DerivedT *>(this)->getNumEntries();\n  }\n\n  void setNumEntries(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumEntries(Num);\n  }\n\n  void incrementNumEntries() {\n    setNumEntries(getNumEntries() + 1);\n  }\n\n  void decrementNumEntries() {\n    setNumEntries(getNumEntries() - 1);\n  }\n\n  unsigned getNumTombstones() const {\n    return static_cast<const DerivedT *>(this)->getNumTombstones();\n  }\n\n  void setNumTombstones(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumTombstones(Num);\n  }\n\n  void incrementNumTombstones() {\n    setNumTombstones(getNumTombstones() + 1);\n  }\n\n  void decrementNumTombstones() {\n    setNumTombstones(getNumTombstones() - 1);\n  }\n\n  const BucketT *getBuckets() const {\n    return static_cast<const DerivedT *>(this)->getBuckets();\n  }\n\n  BucketT *getBuckets() {\n    return static_cast<DerivedT *>(this)->getBuckets();\n  }\n\n  unsigned getNumBuckets() const {\n    return static_cast<const DerivedT *>(this)->getNumBuckets();\n  }\n\n  BucketT *getBucketsEnd() {\n    return getBuckets() + getNumBuckets();\n  }\n\n  const BucketT *getBucketsEnd() const {\n    return getBuckets() + getNumBuckets();\n  }\n\n  void grow(unsigned AtLeast) {\n    static_cast<DerivedT *>(this)->grow(AtLeast);\n  }\n\n  void shrink_and_clear() {\n    static_cast<DerivedT *>(this)->shrink_and_clear();\n  }\n\n  template <typename KeyArg, typename... ValueArgs>\n  BucketT *InsertIntoBucket(BucketT *TheBucket, KeyArg &&Key,\n                            ValueArgs &&... Values) {\n    TheBucket = InsertIntoBucketImpl(Key, Key, TheBucket);\n\n    TheBucket->getFirst() = std::forward<KeyArg>(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::forward<ValueArgs>(Values)...);\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketWithLookup(BucketT *TheBucket, KeyT &&Key,\n                                      ValueT &&Value, LookupKeyT &Lookup) {\n    TheBucket = InsertIntoBucketImpl(Key, Lookup, TheBucket);\n\n    TheBucket->getFirst() = std::move(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::move(Value));\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketImpl(const KeyT &Key, const LookupKeyT &Lookup,\n                                BucketT *TheBucket) {\n    incrementEpoch();\n\n    // If the load of the hash table is more than 3/4, or if fewer than 1/8 of\n    // the buckets are empty (meaning that many are filled with tombstones),\n    // grow the table.\n    //\n    // The later case is tricky.  For example, if we had one empty bucket with\n    // tons of tombstones, failing lookups (e.g. for insertion) would have to\n    // probe almost the entire table until it found the empty bucket.  If the\n    // table completely filled with tombstones, no lookup would ever succeed,\n    // causing infinite loops in lookup.\n    unsigned NewNumEntries = getNumEntries() + 1;\n    unsigned NumBuckets = getNumBuckets();\n    if (LLVM_UNLIKELY(NewNumEntries * 4 >= NumBuckets * 3)) {\n      this->grow(NumBuckets * 2);\n      LookupBucketFor(Lookup, TheBucket);\n      NumBuckets = getNumBuckets();\n    } else if (LLVM_UNLIKELY(NumBuckets-(NewNumEntries+getNumTombstones()) <=\n                             NumBuckets/8)) {\n      this->grow(NumBuckets);\n      LookupBucketFor(Lookup, TheBucket);\n    }\n    assert(TheBucket);\n\n    // Only update the state after we've grown our bucket space appropriately\n    // so that when growing buckets we have self-consistent entry count.\n    incrementNumEntries();\n\n    // If we are writing over a tombstone, remember this.\n    const KeyT EmptyKey = getEmptyKey();\n    if (!KeyInfoT::isEqual(TheBucket->getFirst(), EmptyKey))\n      decrementNumTombstones();\n\n    return TheBucket;\n  }\n\n  /// LookupBucketFor - Lookup the appropriate bucket for Val, returning it in\n  /// FoundBucket.  If the bucket contains the key and a value, this returns\n  /// true, otherwise it returns a bucket with an empty marker or tombstone and\n  /// returns false.\n  template<typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val,\n                       const BucketT *&FoundBucket) const {\n    const BucketT *BucketsPtr = getBuckets();\n    const unsigned NumBuckets = getNumBuckets();\n\n    if (NumBuckets == 0) {\n      FoundBucket = nullptr;\n      return false;\n    }\n\n    // FoundTombstone - Keep track of whether we find a tombstone while probing.\n    const BucketT *FoundTombstone = nullptr;\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    assert(!KeyInfoT::isEqual(Val, EmptyKey) &&\n           !KeyInfoT::isEqual(Val, TombstoneKey) &&\n           \"Empty/Tombstone value shouldn't be inserted into map!\");\n\n    unsigned BucketNo = getHashValue(Val) & (NumBuckets-1);\n    unsigned ProbeAmt = 1;\n    while (true) {\n      const BucketT *ThisBucket = BucketsPtr + BucketNo;\n      // Found Val's bucket?  If so, return it.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(Val, ThisBucket->getFirst()))) {\n        FoundBucket = ThisBucket;\n        return true;\n      }\n\n      // If we found an empty bucket, the key doesn't exist in the set.\n      // Insert it and return the default value.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(ThisBucket->getFirst(), EmptyKey))) {\n        // If we've already seen a tombstone while probing, fill it in instead\n        // of the empty bucket we eventually probed to.\n        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;\n        return false;\n      }\n\n      // If this is a tombstone, remember it.  If Val ends up not in the map, we\n      // prefer to return it than something that would require more probing.\n      if (KeyInfoT::isEqual(ThisBucket->getFirst(), TombstoneKey) &&\n          !FoundTombstone)\n        FoundTombstone = ThisBucket;  // Remember the first tombstone found.\n\n      // Otherwise, it's a hash collision or a tombstone, continue quadratic\n      // probing.\n      BucketNo += ProbeAmt++;\n      BucketNo &= (NumBuckets-1);\n    }\n  }\n\n  template <typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val, BucketT *&FoundBucket) {\n    const BucketT *ConstFoundBucket;\n    bool Result = const_cast<const DenseMapBase *>(this)\n      ->LookupBucketFor(Val, ConstFoundBucket);\n    FoundBucket = const_cast<BucketT *>(ConstFoundBucket);\n    return Result;\n  }\n\npublic:\n  /// Return the approximate size (in bytes) of the actual map.\n  /// This is just the raw memory used by DenseMap.\n  /// If entries are pointers to objects, the size of the referenced objects\n  /// are not included.\n  size_t getMemorySize() const {\n    return getNumBuckets() * sizeof(BucketT);\n  }\n};\n\n/// Equality comparison for DenseMap.\n///\n/// Iterates over elements of LHS confirming that each (key, value) pair in LHS\n/// is also in RHS, and that no additional pairs are in RHS.\n/// Equivalent to N calls to RHS.find and N value comparisons. Amortized\n/// complexity is linear, worst case is O(N^2) (if every hash collides).\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator==(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  for (auto &KV : LHS) {\n    auto I = RHS.find(KV.first);\n    if (I == RHS.end() || I->second != KV.second)\n      return false;\n  }\n\n  return true;\n}\n\n/// Inequality comparison for DenseMap.\n///\n/// Equivalent to !(LHS == RHS). See operator== for performance notes.\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator!=(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  return !(LHS == RHS);\n}\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass DenseMap : public DenseMapBase<DenseMap<KeyT, ValueT, KeyInfoT, BucketT>,\n                                     KeyT, ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  BucketT *Buckets;\n  unsigned NumEntries;\n  unsigned NumTombstones;\n  unsigned NumBuckets;\n\npublic:\n  /// Create a DenseMap with an optional \\p InitialReserve that guarantee that\n  /// this number of elements can be inserted in the map without grow()\n  explicit DenseMap(unsigned InitialReserve = 0) { init(InitialReserve); }\n\n  DenseMap(const DenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  DenseMap(DenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  DenseMap(const InputIt &I, const InputIt &E) {\n    init(std::distance(I, E));\n    this->insert(I, E);\n  }\n\n  DenseMap(std::initializer_list<typename BaseT::value_type> Vals) {\n    init(Vals.size());\n    this->insert(Vals.begin(), Vals.end());\n  }\n\n  ~DenseMap() {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n  }\n\n  void swap(DenseMap& RHS) {\n    this->incrementEpoch();\n    RHS.incrementEpoch();\n    std::swap(Buckets, RHS.Buckets);\n    std::swap(NumEntries, RHS.NumEntries);\n    std::swap(NumTombstones, RHS.NumTombstones);\n    std::swap(NumBuckets, RHS.NumBuckets);\n  }\n\n  DenseMap& operator=(const DenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  DenseMap& operator=(DenseMap &&other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const DenseMap& other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    if (allocateBuckets(other.NumBuckets)) {\n      this->BaseT::copyFrom(other);\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void init(unsigned InitNumEntries) {\n    auto InitBuckets = BaseT::getMinBucketToReserveForEntries(InitNumEntries);\n    if (allocateBuckets(InitBuckets)) {\n      this->BaseT::initEmpty();\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void grow(unsigned AtLeast) {\n    unsigned OldNumBuckets = NumBuckets;\n    BucketT *OldBuckets = Buckets;\n\n    allocateBuckets(std::max<unsigned>(64, static_cast<unsigned>(NextPowerOf2(AtLeast-1))));\n    assert(Buckets);\n    if (!OldBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    this->moveFromOldBuckets(OldBuckets, OldBuckets+OldNumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldBuckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldNumBuckets = NumBuckets;\n    unsigned OldNumEntries = NumEntries;\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldNumEntries)\n      NewNumBuckets = std::max(64, 1 << (Log2_32_Ceil(OldNumEntries) + 1));\n    if (NewNumBuckets == NumBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocate_buffer(Buckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  BucketT *getBuckets() const {\n    return Buckets;\n  }\n\n  unsigned getNumBuckets() const {\n    return NumBuckets;\n  }\n\n  bool allocateBuckets(unsigned Num) {\n    NumBuckets = Num;\n    if (NumBuckets == 0) {\n      Buckets = nullptr;\n      return false;\n    }\n\n    Buckets = static_cast<BucketT *>(\n        allocate_buffer(sizeof(BucketT) * NumBuckets, alignof(BucketT)));\n    return true;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, unsigned InlineBuckets = 4,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass SmallDenseMap\n    : public DenseMapBase<\n          SmallDenseMap<KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT>, KeyT,\n          ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  static_assert(isPowerOf2_64(InlineBuckets),\n                \"InlineBuckets must be a power of 2.\");\n\n  unsigned Small : 1;\n  unsigned NumEntries : 31;\n  unsigned NumTombstones;\n\n  struct LargeRep {\n    BucketT *Buckets;\n    unsigned NumBuckets;\n  };\n\n  /// A \"union\" of an inline bucket array and the struct representing\n  /// a large bucket. This union will be discriminated by the 'Small' bit.\n  AlignedCharArrayUnion<BucketT[InlineBuckets], LargeRep> storage;\n\npublic:\n  explicit SmallDenseMap(unsigned NumInitBuckets = 0) {\n    init(NumInitBuckets);\n  }\n\n  SmallDenseMap(const SmallDenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  SmallDenseMap(SmallDenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  SmallDenseMap(const InputIt &I, const InputIt &E) {\n    init(NextPowerOf2(std::distance(I, E)));\n    this->insert(I, E);\n  }\n\n  ~SmallDenseMap() {\n    this->destroyAll();\n    deallocateBuckets();\n  }\n\n  void swap(SmallDenseMap& RHS) {\n    unsigned TmpNumEntries = RHS.NumEntries;\n    RHS.NumEntries = NumEntries;\n    NumEntries = TmpNumEntries;\n    std::swap(NumTombstones, RHS.NumTombstones);\n\n    const KeyT EmptyKey = this->getEmptyKey();\n    const KeyT TombstoneKey = this->getTombstoneKey();\n    if (Small && RHS.Small) {\n      // If we're swapping inline bucket arrays, we have to cope with some of\n      // the tricky bits of DenseMap's storage system: the buckets are not\n      // fully initialized. Thus we swap every key, but we may have\n      // a one-directional move of the value.\n      for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n        BucketT *LHSB = &getInlineBuckets()[i],\n                *RHSB = &RHS.getInlineBuckets()[i];\n        bool hasLHSValue = (!KeyInfoT::isEqual(LHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(LHSB->getFirst(), TombstoneKey));\n        bool hasRHSValue = (!KeyInfoT::isEqual(RHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(RHSB->getFirst(), TombstoneKey));\n        if (hasLHSValue && hasRHSValue) {\n          // Swap together if we can...\n          std::swap(*LHSB, *RHSB);\n          continue;\n        }\n        // Swap separately and handle any asymmetry.\n        std::swap(LHSB->getFirst(), RHSB->getFirst());\n        if (hasLHSValue) {\n          ::new (&RHSB->getSecond()) ValueT(std::move(LHSB->getSecond()));\n          LHSB->getSecond().~ValueT();\n        } else if (hasRHSValue) {\n          ::new (&LHSB->getSecond()) ValueT(std::move(RHSB->getSecond()));\n          RHSB->getSecond().~ValueT();\n        }\n      }\n      return;\n    }\n    if (!Small && !RHS.Small) {\n      std::swap(getLargeRep()->Buckets, RHS.getLargeRep()->Buckets);\n      std::swap(getLargeRep()->NumBuckets, RHS.getLargeRep()->NumBuckets);\n      return;\n    }\n\n    SmallDenseMap &SmallSide = Small ? *this : RHS;\n    SmallDenseMap &LargeSide = Small ? RHS : *this;\n\n    // First stash the large side's rep and move the small side across.\n    LargeRep TmpRep = std::move(*LargeSide.getLargeRep());\n    LargeSide.getLargeRep()->~LargeRep();\n    LargeSide.Small = true;\n    // This is similar to the standard move-from-old-buckets, but the bucket\n    // count hasn't actually rotated in this case. So we have to carefully\n    // move construct the keys and values into their new locations, but there\n    // is no need to re-hash things.\n    for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n      BucketT *NewB = &LargeSide.getInlineBuckets()[i],\n              *OldB = &SmallSide.getInlineBuckets()[i];\n      ::new (&NewB->getFirst()) KeyT(std::move(OldB->getFirst()));\n      OldB->getFirst().~KeyT();\n      if (!KeyInfoT::isEqual(NewB->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(NewB->getFirst(), TombstoneKey)) {\n        ::new (&NewB->getSecond()) ValueT(std::move(OldB->getSecond()));\n        OldB->getSecond().~ValueT();\n      }\n    }\n\n    // The hard part of moving the small buckets across is done, just move\n    // the TmpRep into its new home.\n    SmallSide.Small = false;\n    new (SmallSide.getLargeRep()) LargeRep(std::move(TmpRep));\n  }\n\n  SmallDenseMap& operator=(const SmallDenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  SmallDenseMap& operator=(SmallDenseMap &&other) {\n    this->destroyAll();\n    deallocateBuckets();\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const SmallDenseMap& other) {\n    this->destroyAll();\n    deallocateBuckets();\n    Small = true;\n    if (other.getNumBuckets() > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(other.getNumBuckets()));\n    }\n    this->BaseT::copyFrom(other);\n  }\n\n  void init(unsigned InitBuckets) {\n    Small = true;\n    if (InitBuckets > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(InitBuckets));\n    }\n    this->BaseT::initEmpty();\n  }\n\n  void grow(unsigned AtLeast) {\n    if (AtLeast > InlineBuckets)\n      AtLeast = std::max<unsigned>(64, NextPowerOf2(AtLeast-1));\n\n    if (Small) {\n      // First move the inline buckets into a temporary storage.\n      AlignedCharArrayUnion<BucketT[InlineBuckets]> TmpStorage;\n      BucketT *TmpBegin = reinterpret_cast<BucketT *>(&TmpStorage);\n      BucketT *TmpEnd = TmpBegin;\n\n      // Loop over the buckets, moving non-empty, non-tombstones into the\n      // temporary storage. Have the loop move the TmpEnd forward as it goes.\n      const KeyT EmptyKey = this->getEmptyKey();\n      const KeyT TombstoneKey = this->getTombstoneKey();\n      for (BucketT *P = getBuckets(), *E = P + InlineBuckets; P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n            !KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n          assert(size_t(TmpEnd - TmpBegin) < InlineBuckets &&\n                 \"Too many inline buckets!\");\n          ::new (&TmpEnd->getFirst()) KeyT(std::move(P->getFirst()));\n          ::new (&TmpEnd->getSecond()) ValueT(std::move(P->getSecond()));\n          ++TmpEnd;\n          P->getSecond().~ValueT();\n        }\n        P->getFirst().~KeyT();\n      }\n\n      // AtLeast == InlineBuckets can happen if there are many tombstones,\n      // and grow() is used to remove them. Usually we always switch to the\n      // large rep here.\n      if (AtLeast > InlineBuckets) {\n        Small = false;\n        new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n      }\n      this->moveFromOldBuckets(TmpBegin, TmpEnd);\n      return;\n    }\n\n    LargeRep OldRep = std::move(*getLargeRep());\n    getLargeRep()->~LargeRep();\n    if (AtLeast <= InlineBuckets) {\n      Small = true;\n    } else {\n      new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n    }\n\n    this->moveFromOldBuckets(OldRep.Buckets, OldRep.Buckets+OldRep.NumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldRep.Buckets, sizeof(BucketT) * OldRep.NumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldSize = this->size();\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldSize) {\n      NewNumBuckets = 1 << (Log2_32_Ceil(OldSize) + 1);\n      if (NewNumBuckets > InlineBuckets && NewNumBuckets < 64u)\n        NewNumBuckets = 64;\n    }\n    if ((Small && NewNumBuckets <= InlineBuckets) ||\n        (!Small && NewNumBuckets == getLargeRep()->NumBuckets)) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocateBuckets();\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    // NumEntries is hardcoded to be 31 bits wide.\n    assert(Num < (1U << 31) && \"Cannot support more than 1<<31 entries\");\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  const BucketT *getInlineBuckets() const {\n    assert(Small);\n    // Note that this cast does not violate aliasing rules as we assert that\n    // the memory's dynamic type is the small, inline bucket buffer, and the\n    // 'storage' is a POD containing a char buffer.\n    return reinterpret_cast<const BucketT *>(&storage);\n  }\n\n  BucketT *getInlineBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getInlineBuckets());\n  }\n\n  const LargeRep *getLargeRep() const {\n    assert(!Small);\n    // Note, same rule about aliasing as with getInlineBuckets.\n    return reinterpret_cast<const LargeRep *>(&storage);\n  }\n\n  LargeRep *getLargeRep() {\n    return const_cast<LargeRep *>(\n      const_cast<const SmallDenseMap *>(this)->getLargeRep());\n  }\n\n  const BucketT *getBuckets() const {\n    return Small ? getInlineBuckets() : getLargeRep()->Buckets;\n  }\n\n  BucketT *getBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getBuckets());\n  }\n\n  unsigned getNumBuckets() const {\n    return Small ? InlineBuckets : getLargeRep()->NumBuckets;\n  }\n\n  void deallocateBuckets() {\n    if (Small)\n      return;\n\n    deallocate_buffer(getLargeRep()->Buckets,\n                      sizeof(BucketT) * getLargeRep()->NumBuckets,\n                      alignof(BucketT));\n    getLargeRep()->~LargeRep();\n  }\n\n  LargeRep allocateBuckets(unsigned Num) {\n    assert(Num > InlineBuckets && \"Must allocate more buckets than are inline\");\n    LargeRep Rep = {static_cast<BucketT *>(allocate_buffer(\n                        sizeof(BucketT) * Num, alignof(BucketT))),\n                    Num};\n    return Rep;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT, typename Bucket,\n          bool IsConst>\nclass DenseMapIterator : DebugEpochBase::HandleBase {\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, true>;\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, false>;\n\npublic:\n  using difference_type = ptrdiff_t;\n  using value_type =\n      typename std::conditional<IsConst, const Bucket, Bucket>::type;\n  using pointer = value_type *;\n  using reference = value_type &;\n  using iterator_category = std::forward_iterator_tag;\n\nprivate:\n  pointer Ptr = nullptr;\n  pointer End = nullptr;\n\npublic:\n  DenseMapIterator() = default;\n\n  DenseMapIterator(pointer Pos, pointer E, const DebugEpochBase &Epoch,\n                   bool NoAdvance = false)\n      : DebugEpochBase::HandleBase(&Epoch), Ptr(Pos), End(E) {\n    assert(isHandleInSync() && \"invalid construction!\");\n\n    if (NoAdvance) return;\n    if (shouldReverseIterate<KeyT>()) {\n      RetreatPastEmptyBuckets();\n      return;\n    }\n    AdvancePastEmptyBuckets();\n  }\n\n  // Converting ctor from non-const iterators to const iterators. SFINAE'd out\n  // for const iterator destinations so it doesn't end up as a user defined copy\n  // constructor.\n  template <bool IsConstSrc,\n            typename = std::enable_if_t<!IsConstSrc && IsConst>>\n  DenseMapIterator(\n      const DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, IsConstSrc> &I)\n      : DebugEpochBase::HandleBase(I), Ptr(I.Ptr), End(I.End) {}\n\n  reference operator*() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return Ptr[-1];\n    return *Ptr;\n  }\n  pointer operator->() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return &(Ptr[-1]);\n    return Ptr;\n  }\n\n  friend bool operator==(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    assert((!LHS.Ptr || LHS.isHandleInSync()) && \"handle not in sync!\");\n    assert((!RHS.Ptr || RHS.isHandleInSync()) && \"handle not in sync!\");\n    assert(LHS.getEpochAddress() == RHS.getEpochAddress() &&\n           \"comparing incomparable iterators!\");\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  friend bool operator!=(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    return !(LHS == RHS);\n  }\n\n  inline DenseMapIterator& operator++() {  // Preincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"incrementing end() iterator\");\n    if (shouldReverseIterate<KeyT>()) {\n      --Ptr;\n      RetreatPastEmptyBuckets();\n      return *this;\n    }\n    ++Ptr;\n    AdvancePastEmptyBuckets();\n    return *this;\n  }\n  DenseMapIterator operator++(int) {  // Postincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    DenseMapIterator tmp = *this; ++*this; return tmp;\n  }\n\nprivate:\n  void AdvancePastEmptyBuckets() {\n    assert(Ptr <= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr->getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr->getFirst(), Tombstone)))\n      ++Ptr;\n  }\n\n  void RetreatPastEmptyBuckets() {\n    assert(Ptr >= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr[-1].getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr[-1].getFirst(), Tombstone)))\n      --Ptr;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT>\ninline size_t capacity_in_bytes(const DenseMap<KeyT, ValueT, KeyInfoT> &X) {\n  return X.getMemorySize();\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_DENSEMAP_H\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "content": "//===- llvm/ADT/FoldingSet.h - Uniquing Hash Set ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a hash set that can be used to remove duplication of nodes\n// in a graph.  This code was originally created by Chris Lattner for use with\n// SelectionDAGCSEMap, but was isolated to provide use across the llvm code set.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_FOLDINGSET_H\n#define LLVM_ADT_FOLDINGSET_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <utility>\n\nnamespace llvm {\n\n/// This folding set used for two purposes:\n///   1. Given information about a node we want to create, look up the unique\n///      instance of the node in the set.  If the node already exists, return\n///      it, otherwise return the bucket it should be inserted into.\n///   2. Given a node that has already been created, remove it from the set.\n///\n/// This class is implemented as a single-link chained hash table, where the\n/// \"buckets\" are actually the nodes themselves (the next pointer is in the\n/// node).  The last node points back to the bucket to simplify node removal.\n///\n/// Any node that is to be included in the folding set must be a subclass of\n/// FoldingSetNode.  The node class must also define a Profile method used to\n/// establish the unique bits of data for the node.  The Profile method is\n/// passed a FoldingSetNodeID object which is used to gather the bits.  Just\n/// call one of the Add* functions defined in the FoldingSetBase::NodeID class.\n/// NOTE: That the folding set does not own the nodes and it is the\n/// responsibility of the user to dispose of the nodes.\n///\n/// Eg.\n///    class MyNode : public FoldingSetNode {\n///    private:\n///      std::string Name;\n///      unsigned Value;\n///    public:\n///      MyNode(const char *N, unsigned V) : Name(N), Value(V) {}\n///       ...\n///      void Profile(FoldingSetNodeID &ID) const {\n///        ID.AddString(Name);\n///        ID.AddInteger(Value);\n///      }\n///      ...\n///    };\n///\n/// To define the folding set itself use the FoldingSet template;\n///\n/// Eg.\n///    FoldingSet<MyNode> MyFoldingSet;\n///\n/// Four public methods are available to manipulate the folding set;\n///\n/// 1) If you have an existing node that you want add to the set but unsure\n/// that the node might already exist then call;\n///\n///    MyNode *M = MyFoldingSet.GetOrInsertNode(N);\n///\n/// If The result is equal to the input then the node has been inserted.\n/// Otherwise, the result is the node existing in the folding set, and the\n/// input can be discarded (use the result instead.)\n///\n/// 2) If you are ready to construct a node but want to check if it already\n/// exists, then call FindNodeOrInsertPos with a FoldingSetNodeID of the bits to\n/// check;\n///\n///   FoldingSetNodeID ID;\n///   ID.AddString(Name);\n///   ID.AddInteger(Value);\n///   void *InsertPoint;\n///\n///    MyNode *M = MyFoldingSet.FindNodeOrInsertPos(ID, InsertPoint);\n///\n/// If found then M will be non-NULL, else InsertPoint will point to where it\n/// should be inserted using InsertNode.\n///\n/// 3) If you get a NULL result from FindNodeOrInsertPos then you can insert a\n/// new node with InsertNode;\n///\n///    MyFoldingSet.InsertNode(M, InsertPoint);\n///\n/// 4) Finally, if you want to remove a node from the folding set call;\n///\n///    bool WasRemoved = MyFoldingSet.RemoveNode(M);\n///\n/// The result indicates whether the node existed in the folding set.\n\nclass FoldingSetNodeID;\nclass StringRef;\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetBase - Implements the folding set functionality.  The main\n/// structure is an array of buckets.  Each bucket is indexed by the hash of\n/// the nodes it contains.  The bucket itself points to the nodes contained\n/// in the bucket via a singly linked list.  The last node in the list points\n/// back to the bucket to facilitate node removal.\n///\nclass FoldingSetBase {\nprotected:\n  /// Buckets - Array of bucket chains.\n  void **Buckets;\n\n  /// NumBuckets - Length of the Buckets array.  Always a power of 2.\n  unsigned NumBuckets;\n\n  /// NumNodes - Number of nodes in the folding set. Growth occurs when NumNodes\n  /// is greater than twice the number of buckets.\n  unsigned NumNodes;\n\n  explicit FoldingSetBase(unsigned Log2InitSize = 6);\n  FoldingSetBase(FoldingSetBase &&Arg);\n  FoldingSetBase &operator=(FoldingSetBase &&RHS);\n  ~FoldingSetBase();\n\npublic:\n  //===--------------------------------------------------------------------===//\n  /// Node - This class is used to maintain the singly linked bucket list in\n  /// a folding set.\n  class Node {\n  private:\n    // NextInFoldingSetBucket - next link in the bucket list.\n    void *NextInFoldingSetBucket = nullptr;\n\n  public:\n    Node() = default;\n\n    // Accessors\n    void *getNextInBucket() const { return NextInFoldingSetBucket; }\n    void SetNextInBucket(void *N) { NextInFoldingSetBucket = N; }\n  };\n\n  /// clear - Remove all nodes from the folding set.\n  void clear();\n\n  /// size - Returns the number of nodes in the folding set.\n  unsigned size() const { return NumNodes; }\n\n  /// empty - Returns true if there are no nodes in the folding set.\n  bool empty() const { return NumNodes == 0; }\n\n  /// capacity - Returns the number of nodes permitted in the folding set\n  /// before a rebucket operation is performed.\n  unsigned capacity() {\n    // We allow a load factor of up to 2.0,\n    // so that means our capacity is NumBuckets * 2\n    return NumBuckets * 2;\n  }\n\nprotected:\n  /// Functions provided by the derived class to compute folding properties.\n  /// This is effectively a vtable for FoldingSetBase, except that we don't\n  /// actually store a pointer to it in the object.\n  struct FoldingSetInfo {\n    /// GetNodeProfile - Instantiations of the FoldingSet template implement\n    /// this function to gather data bits for the given node.\n    void (*GetNodeProfile)(const FoldingSetBase *Self, Node *N,\n                           FoldingSetNodeID &ID);\n\n    /// NodeEquals - Instantiations of the FoldingSet template implement\n    /// this function to compare the given node with the given ID.\n    bool (*NodeEquals)(const FoldingSetBase *Self, Node *N,\n                       const FoldingSetNodeID &ID, unsigned IDHash,\n                       FoldingSetNodeID &TempID);\n\n    /// ComputeNodeHash - Instantiations of the FoldingSet template implement\n    /// this function to compute a hash value for the given node.\n    unsigned (*ComputeNodeHash)(const FoldingSetBase *Self, Node *N,\n                                FoldingSetNodeID &TempID);\n  };\n\nprivate:\n  /// GrowHashTable - Double the size of the hash table and rehash everything.\n  void GrowHashTable(const FoldingSetInfo &Info);\n\n  /// GrowBucketCount - resize the hash table and rehash everything.\n  /// NewBucketCount must be a power of two, and must be greater than the old\n  /// bucket count.\n  void GrowBucketCount(unsigned NewBucketCount, const FoldingSetInfo &Info);\n\nprotected:\n  // The below methods are protected to encourage subclasses to provide a more\n  // type-safe API.\n\n  /// reserve - Increase the number of buckets such that adding the\n  /// EltCount-th node won't cause a rebucket operation. reserve is permitted\n  /// to allocate more space than requested by EltCount.\n  void reserve(unsigned EltCount, const FoldingSetInfo &Info);\n\n  /// RemoveNode - Remove a node from the folding set, returning true if one\n  /// was removed or false if the node was not in the folding set.\n  bool RemoveNode(Node *N);\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and return\n  /// it instead.\n  Node *GetOrInsertNode(Node *N, const FoldingSetInfo &Info);\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  Node *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos,\n                            const FoldingSetInfo &Info);\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(Node *N, void *InsertPos, const FoldingSetInfo &Info);\n};\n\n//===----------------------------------------------------------------------===//\n\n/// DefaultFoldingSetTrait - This class provides default implementations\n/// for FoldingSetTrait implementations.\ntemplate<typename T> struct DefaultFoldingSetTrait {\n  static void Profile(const T &X, FoldingSetNodeID &ID) {\n    X.Profile(ID);\n  }\n  static void Profile(T &X, FoldingSetNodeID &ID) {\n    X.Profile(ID);\n  }\n\n  // Equals - Test if the profile for X would match ID, using TempID\n  // to compute a temporary ID if necessary. The default implementation\n  // just calls Profile and does a regular comparison. Implementations\n  // can override this to provide more efficient implementations.\n  static inline bool Equals(T &X, const FoldingSetNodeID &ID, unsigned IDHash,\n                            FoldingSetNodeID &TempID);\n\n  // ComputeHash - Compute a hash value for X, using TempID to\n  // compute a temporary ID if necessary. The default implementation\n  // just calls Profile and does a regular hash computation.\n  // Implementations can override this to provide more efficient\n  // implementations.\n  static inline unsigned ComputeHash(T &X, FoldingSetNodeID &TempID);\n};\n\n/// FoldingSetTrait - This trait class is used to define behavior of how\n/// to \"profile\" (in the FoldingSet parlance) an object of a given type.\n/// The default behavior is to invoke a 'Profile' method on an object, but\n/// through template specialization the behavior can be tailored for specific\n/// types.  Combined with the FoldingSetNodeWrapper class, one can add objects\n/// to FoldingSets that were not originally designed to have that behavior.\ntemplate<typename T> struct FoldingSetTrait\n  : public DefaultFoldingSetTrait<T> {};\n\n/// DefaultContextualFoldingSetTrait - Like DefaultFoldingSetTrait, but\n/// for ContextualFoldingSets.\ntemplate<typename T, typename Ctx>\nstruct DefaultContextualFoldingSetTrait {\n  static void Profile(T &X, FoldingSetNodeID &ID, Ctx Context) {\n    X.Profile(ID, Context);\n  }\n\n  static inline bool Equals(T &X, const FoldingSetNodeID &ID, unsigned IDHash,\n                            FoldingSetNodeID &TempID, Ctx Context);\n  static inline unsigned ComputeHash(T &X, FoldingSetNodeID &TempID,\n                                     Ctx Context);\n};\n\n/// ContextualFoldingSetTrait - Like FoldingSetTrait, but for\n/// ContextualFoldingSets.\ntemplate<typename T, typename Ctx> struct ContextualFoldingSetTrait\n  : public DefaultContextualFoldingSetTrait<T, Ctx> {};\n\n//===--------------------------------------------------------------------===//\n/// FoldingSetNodeIDRef - This class describes a reference to an interned\n/// FoldingSetNodeID, which can be a useful to store node id data rather\n/// than using plain FoldingSetNodeIDs, since the 32-element SmallVector\n/// is often much larger than necessary, and the possibility of heap\n/// allocation means it requires a non-trivial destructor call.\nclass FoldingSetNodeIDRef {\n  const unsigned *Data = nullptr;\n  size_t Size = 0;\n\npublic:\n  FoldingSetNodeIDRef() = default;\n  FoldingSetNodeIDRef(const unsigned *D, size_t S) : Data(D), Size(S) {}\n\n  /// ComputeHash - Compute a strong hash value for this FoldingSetNodeIDRef,\n  /// used to lookup the node in the FoldingSetBase.\n  unsigned ComputeHash() const;\n\n  bool operator==(FoldingSetNodeIDRef) const;\n\n  bool operator!=(FoldingSetNodeIDRef RHS) const { return !(*this == RHS); }\n\n  /// Used to compare the \"ordering\" of two nodes as defined by the\n  /// profiled bits and their ordering defined by memcmp().\n  bool operator<(FoldingSetNodeIDRef) const;\n\n  const unsigned *getData() const { return Data; }\n  size_t getSize() const { return Size; }\n};\n\n//===--------------------------------------------------------------------===//\n/// FoldingSetNodeID - This class is used to gather all the unique data bits of\n/// a node.  When all the bits are gathered this class is used to produce a\n/// hash value for the node.\nclass FoldingSetNodeID {\n  /// Bits - Vector of all the data bits that make the node unique.\n  /// Use a SmallVector to avoid a heap allocation in the common case.\n  SmallVector<unsigned, 32> Bits;\n\npublic:\n  FoldingSetNodeID() = default;\n\n  FoldingSetNodeID(FoldingSetNodeIDRef Ref)\n    : Bits(Ref.getData(), Ref.getData() + Ref.getSize()) {}\n\n  /// Add* - Add various data types to Bit data.\n  void AddPointer(const void *Ptr);\n  void AddInteger(signed I);\n  void AddInteger(unsigned I);\n  void AddInteger(long I);\n  void AddInteger(unsigned long I);\n  void AddInteger(long long I);\n  void AddInteger(unsigned long long I);\n  void AddBoolean(bool B) { AddInteger(B ? 1U : 0U); }\n  void AddString(StringRef String);\n  void AddNodeID(const FoldingSetNodeID &ID);\n\n  template <typename T>\n  inline void Add(const T &x) { FoldingSetTrait<T>::Profile(x, *this); }\n\n  /// clear - Clear the accumulated profile, allowing this FoldingSetNodeID\n  /// object to be used to compute a new profile.\n  inline void clear() { Bits.clear(); }\n\n  /// ComputeHash - Compute a strong hash value for this FoldingSetNodeID, used\n  /// to lookup the node in the FoldingSetBase.\n  unsigned ComputeHash() const;\n\n  /// operator== - Used to compare two nodes to each other.\n  bool operator==(const FoldingSetNodeID &RHS) const;\n  bool operator==(const FoldingSetNodeIDRef RHS) const;\n\n  bool operator!=(const FoldingSetNodeID &RHS) const { return !(*this == RHS); }\n  bool operator!=(const FoldingSetNodeIDRef RHS) const { return !(*this ==RHS);}\n\n  /// Used to compare the \"ordering\" of two nodes as defined by the\n  /// profiled bits and their ordering defined by memcmp().\n  bool operator<(const FoldingSetNodeID &RHS) const;\n  bool operator<(const FoldingSetNodeIDRef RHS) const;\n\n  /// Intern - Copy this node's data to a memory region allocated from the\n  /// given allocator and return a FoldingSetNodeIDRef describing the\n  /// interned data.\n  FoldingSetNodeIDRef Intern(BumpPtrAllocator &Allocator) const;\n};\n\n// Convenience type to hide the implementation of the folding set.\nusing FoldingSetNode = FoldingSetBase::Node;\ntemplate<class T> class FoldingSetIterator;\ntemplate<class T> class FoldingSetBucketIterator;\n\n// Definitions of FoldingSetTrait and ContextualFoldingSetTrait functions, which\n// require the definition of FoldingSetNodeID.\ntemplate<typename T>\ninline bool\nDefaultFoldingSetTrait<T>::Equals(T &X, const FoldingSetNodeID &ID,\n                                  unsigned /*IDHash*/,\n                                  FoldingSetNodeID &TempID) {\n  FoldingSetTrait<T>::Profile(X, TempID);\n  return TempID == ID;\n}\ntemplate<typename T>\ninline unsigned\nDefaultFoldingSetTrait<T>::ComputeHash(T &X, FoldingSetNodeID &TempID) {\n  FoldingSetTrait<T>::Profile(X, TempID);\n  return TempID.ComputeHash();\n}\ntemplate<typename T, typename Ctx>\ninline bool\nDefaultContextualFoldingSetTrait<T, Ctx>::Equals(T &X,\n                                                 const FoldingSetNodeID &ID,\n                                                 unsigned /*IDHash*/,\n                                                 FoldingSetNodeID &TempID,\n                                                 Ctx Context) {\n  ContextualFoldingSetTrait<T, Ctx>::Profile(X, TempID, Context);\n  return TempID == ID;\n}\ntemplate<typename T, typename Ctx>\ninline unsigned\nDefaultContextualFoldingSetTrait<T, Ctx>::ComputeHash(T &X,\n                                                      FoldingSetNodeID &TempID,\n                                                      Ctx Context) {\n  ContextualFoldingSetTrait<T, Ctx>::Profile(X, TempID, Context);\n  return TempID.ComputeHash();\n}\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetImpl - An implementation detail that lets us share code between\n/// FoldingSet and ContextualFoldingSet.\ntemplate <class Derived, class T> class FoldingSetImpl : public FoldingSetBase {\nprotected:\n  explicit FoldingSetImpl(unsigned Log2InitSize)\n      : FoldingSetBase(Log2InitSize) {}\n\n  FoldingSetImpl(FoldingSetImpl &&Arg) = default;\n  FoldingSetImpl &operator=(FoldingSetImpl &&RHS) = default;\n  ~FoldingSetImpl() = default;\n\npublic:\n  using iterator = FoldingSetIterator<T>;\n\n  iterator begin() { return iterator(Buckets); }\n  iterator end() { return iterator(Buckets+NumBuckets); }\n\n  using const_iterator = FoldingSetIterator<const T>;\n\n  const_iterator begin() const { return const_iterator(Buckets); }\n  const_iterator end() const { return const_iterator(Buckets+NumBuckets); }\n\n  using bucket_iterator = FoldingSetBucketIterator<T>;\n\n  bucket_iterator bucket_begin(unsigned hash) {\n    return bucket_iterator(Buckets + (hash & (NumBuckets-1)));\n  }\n\n  bucket_iterator bucket_end(unsigned hash) {\n    return bucket_iterator(Buckets + (hash & (NumBuckets-1)), true);\n  }\n\n  /// reserve - Increase the number of buckets such that adding the\n  /// EltCount-th node won't cause a rebucket operation. reserve is permitted\n  /// to allocate more space than requested by EltCount.\n  void reserve(unsigned EltCount) {\n    return FoldingSetBase::reserve(EltCount, Derived::getFoldingSetInfo());\n  }\n\n  /// RemoveNode - Remove a node from the folding set, returning true if one\n  /// was removed or false if the node was not in the folding set.\n  bool RemoveNode(T *N) {\n    return FoldingSetBase::RemoveNode(N);\n  }\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and\n  /// return it instead.\n  T *GetOrInsertNode(T *N) {\n    return static_cast<T *>(\n        FoldingSetBase::GetOrInsertNode(N, Derived::getFoldingSetInfo()));\n  }\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {\n    return static_cast<T *>(FoldingSetBase::FindNodeOrInsertPos(\n        ID, InsertPos, Derived::getFoldingSetInfo()));\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(T *N, void *InsertPos) {\n    FoldingSetBase::InsertNode(N, InsertPos, Derived::getFoldingSetInfo());\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.\n  void InsertNode(T *N) {\n    T *Inserted = GetOrInsertNode(N);\n    (void)Inserted;\n    assert(Inserted == N && \"Node already inserted!\");\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSet - This template class is used to instantiate a specialized\n/// implementation of the folding set to the node class T.  T must be a\n/// subclass of FoldingSetNode and implement a Profile function.\n///\n/// Note that this set type is movable and move-assignable. However, its\n/// moved-from state is not a valid state for anything other than\n/// move-assigning and destroying. This is primarily to enable movable APIs\n/// that incorporate these objects.\ntemplate <class T>\nclass FoldingSet : public FoldingSetImpl<FoldingSet<T>, T> {\n  using Super = FoldingSetImpl<FoldingSet, T>;\n  using Node = typename Super::Node;\n\n  /// GetNodeProfile - Each instantiation of the FoldingSet needs to provide a\n  /// way to convert nodes into a unique specifier.\n  static void GetNodeProfile(const FoldingSetBase *, Node *N,\n                             FoldingSetNodeID &ID) {\n    T *TN = static_cast<T *>(N);\n    FoldingSetTrait<T>::Profile(*TN, ID);\n  }\n\n  /// NodeEquals - Instantiations may optionally provide a way to compare a\n  /// node with a specified ID.\n  static bool NodeEquals(const FoldingSetBase *, Node *N,\n                         const FoldingSetNodeID &ID, unsigned IDHash,\n                         FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return FoldingSetTrait<T>::Equals(*TN, ID, IDHash, TempID);\n  }\n\n  /// ComputeNodeHash - Instantiations may optionally provide a way to compute a\n  /// hash value directly from a node.\n  static unsigned ComputeNodeHash(const FoldingSetBase *, Node *N,\n                                  FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return FoldingSetTrait<T>::ComputeHash(*TN, TempID);\n  }\n\n  static const FoldingSetBase::FoldingSetInfo &getFoldingSetInfo() {\n    static constexpr FoldingSetBase::FoldingSetInfo Info = {\n        GetNodeProfile, NodeEquals, ComputeNodeHash};\n    return Info;\n  }\n  friend Super;\n\npublic:\n  explicit FoldingSet(unsigned Log2InitSize = 6) : Super(Log2InitSize) {}\n  FoldingSet(FoldingSet &&Arg) = default;\n  FoldingSet &operator=(FoldingSet &&RHS) = default;\n};\n\n//===----------------------------------------------------------------------===//\n/// ContextualFoldingSet - This template class is a further refinement\n/// of FoldingSet which provides a context argument when calling\n/// Profile on its nodes.  Currently, that argument is fixed at\n/// initialization time.\n///\n/// T must be a subclass of FoldingSetNode and implement a Profile\n/// function with signature\n///   void Profile(FoldingSetNodeID &, Ctx);\ntemplate <class T, class Ctx>\nclass ContextualFoldingSet\n    : public FoldingSetImpl<ContextualFoldingSet<T, Ctx>, T> {\n  // Unfortunately, this can't derive from FoldingSet<T> because the\n  // construction of the vtable for FoldingSet<T> requires\n  // FoldingSet<T>::GetNodeProfile to be instantiated, which in turn\n  // requires a single-argument T::Profile().\n\n  using Super = FoldingSetImpl<ContextualFoldingSet, T>;\n  using Node = typename Super::Node;\n\n  Ctx Context;\n\n  static const Ctx &getContext(const FoldingSetBase *Base) {\n    return static_cast<const ContextualFoldingSet*>(Base)->Context;\n  }\n\n  /// GetNodeProfile - Each instantiatation of the FoldingSet needs to provide a\n  /// way to convert nodes into a unique specifier.\n  static void GetNodeProfile(const FoldingSetBase *Base, Node *N,\n                             FoldingSetNodeID &ID) {\n    T *TN = static_cast<T *>(N);\n    ContextualFoldingSetTrait<T, Ctx>::Profile(*TN, ID, getContext(Base));\n  }\n\n  static bool NodeEquals(const FoldingSetBase *Base, Node *N,\n                         const FoldingSetNodeID &ID, unsigned IDHash,\n                         FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return ContextualFoldingSetTrait<T, Ctx>::Equals(*TN, ID, IDHash, TempID,\n                                                     getContext(Base));\n  }\n\n  static unsigned ComputeNodeHash(const FoldingSetBase *Base, Node *N,\n                                  FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return ContextualFoldingSetTrait<T, Ctx>::ComputeHash(*TN, TempID,\n                                                          getContext(Base));\n  }\n\n  static const FoldingSetBase::FoldingSetInfo &getFoldingSetInfo() {\n    static constexpr FoldingSetBase::FoldingSetInfo Info = {\n        GetNodeProfile, NodeEquals, ComputeNodeHash};\n    return Info;\n  }\n  friend Super;\n\npublic:\n  explicit ContextualFoldingSet(Ctx Context, unsigned Log2InitSize = 6)\n      : Super(Log2InitSize), Context(Context) {}\n\n  Ctx getContext() const { return Context; }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetVector - This template class combines a FoldingSet and a vector\n/// to provide the interface of FoldingSet but with deterministic iteration\n/// order based on the insertion order. T must be a subclass of FoldingSetNode\n/// and implement a Profile function.\ntemplate <class T, class VectorT = SmallVector<T*, 8>>\nclass FoldingSetVector {\n  FoldingSet<T> Set;\n  VectorT Vector;\n\npublic:\n  explicit FoldingSetVector(unsigned Log2InitSize = 6) : Set(Log2InitSize) {}\n\n  using iterator = pointee_iterator<typename VectorT::iterator>;\n\n  iterator begin() { return Vector.begin(); }\n  iterator end()   { return Vector.end(); }\n\n  using const_iterator = pointee_iterator<typename VectorT::const_iterator>;\n\n  const_iterator begin() const { return Vector.begin(); }\n  const_iterator end()   const { return Vector.end(); }\n\n  /// clear - Remove all nodes from the folding set.\n  void clear() { Set.clear(); Vector.clear(); }\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {\n    return Set.FindNodeOrInsertPos(ID, InsertPos);\n  }\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and\n  /// return it instead.\n  T *GetOrInsertNode(T *N) {\n    T *Result = Set.GetOrInsertNode(N);\n    if (Result == N) Vector.push_back(N);\n    return Result;\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(T *N, void *InsertPos) {\n    Set.InsertNode(N, InsertPos);\n    Vector.push_back(N);\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.\n  void InsertNode(T *N) {\n    Set.InsertNode(N);\n    Vector.push_back(N);\n  }\n\n  /// size - Returns the number of nodes in the folding set.\n  unsigned size() const { return Set.size(); }\n\n  /// empty - Returns true if there are no nodes in the folding set.\n  bool empty() const { return Set.empty(); }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetIteratorImpl - This is the common iterator support shared by all\n/// folding sets, which knows how to walk the folding set hash table.\nclass FoldingSetIteratorImpl {\nprotected:\n  FoldingSetNode *NodePtr;\n\n  FoldingSetIteratorImpl(void **Bucket);\n\n  void advance();\n\npublic:\n  bool operator==(const FoldingSetIteratorImpl &RHS) const {\n    return NodePtr == RHS.NodePtr;\n  }\n  bool operator!=(const FoldingSetIteratorImpl &RHS) const {\n    return NodePtr != RHS.NodePtr;\n  }\n};\n\ntemplate <class T> class FoldingSetIterator : public FoldingSetIteratorImpl {\npublic:\n  explicit FoldingSetIterator(void **Bucket) : FoldingSetIteratorImpl(Bucket) {}\n\n  T &operator*() const {\n    return *static_cast<T*>(NodePtr);\n  }\n\n  T *operator->() const {\n    return static_cast<T*>(NodePtr);\n  }\n\n  inline FoldingSetIterator &operator++() {          // Preincrement\n    advance();\n    return *this;\n  }\n  FoldingSetIterator operator++(int) {        // Postincrement\n    FoldingSetIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetBucketIteratorImpl - This is the common bucket iterator support\n/// shared by all folding sets, which knows how to walk a particular bucket\n/// of a folding set hash table.\nclass FoldingSetBucketIteratorImpl {\nprotected:\n  void *Ptr;\n\n  explicit FoldingSetBucketIteratorImpl(void **Bucket);\n\n  FoldingSetBucketIteratorImpl(void **Bucket, bool) : Ptr(Bucket) {}\n\n  void advance() {\n    void *Probe = static_cast<FoldingSetNode*>(Ptr)->getNextInBucket();\n    uintptr_t x = reinterpret_cast<uintptr_t>(Probe) & ~0x1;\n    Ptr = reinterpret_cast<void*>(x);\n  }\n\npublic:\n  bool operator==(const FoldingSetBucketIteratorImpl &RHS) const {\n    return Ptr == RHS.Ptr;\n  }\n  bool operator!=(const FoldingSetBucketIteratorImpl &RHS) const {\n    return Ptr != RHS.Ptr;\n  }\n};\n\ntemplate <class T>\nclass FoldingSetBucketIterator : public FoldingSetBucketIteratorImpl {\npublic:\n  explicit FoldingSetBucketIterator(void **Bucket) :\n    FoldingSetBucketIteratorImpl(Bucket) {}\n\n  FoldingSetBucketIterator(void **Bucket, bool) :\n    FoldingSetBucketIteratorImpl(Bucket, true) {}\n\n  T &operator*() const { return *static_cast<T*>(Ptr); }\n  T *operator->() const { return static_cast<T*>(Ptr); }\n\n  inline FoldingSetBucketIterator &operator++() { // Preincrement\n    advance();\n    return *this;\n  }\n  FoldingSetBucketIterator operator++(int) {      // Postincrement\n    FoldingSetBucketIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetNodeWrapper - This template class is used to \"wrap\" arbitrary\n/// types in an enclosing object so that they can be inserted into FoldingSets.\ntemplate <typename T>\nclass FoldingSetNodeWrapper : public FoldingSetNode {\n  T data;\n\npublic:\n  template <typename... Ts>\n  explicit FoldingSetNodeWrapper(Ts &&... Args)\n      : data(std::forward<Ts>(Args)...) {}\n\n  void Profile(FoldingSetNodeID &ID) { FoldingSetTrait<T>::Profile(data, ID); }\n\n  T &getValue() { return data; }\n  const T &getValue() const { return data; }\n\n  operator T&() { return data; }\n  operator const T&() const { return data; }\n};\n\n//===----------------------------------------------------------------------===//\n/// FastFoldingSetNode - This is a subclass of FoldingSetNode which stores\n/// a FoldingSetNodeID value rather than requiring the node to recompute it\n/// each time it is needed. This trades space for speed (which can be\n/// significant if the ID is long), and it also permits nodes to drop\n/// information that would otherwise only be required for recomputing an ID.\nclass FastFoldingSetNode : public FoldingSetNode {\n  FoldingSetNodeID FastID;\n\nprotected:\n  explicit FastFoldingSetNode(const FoldingSetNodeID &ID) : FastID(ID) {}\n\npublic:\n  void Profile(FoldingSetNodeID &ID) const { ID.AddNodeID(FastID); }\n};\n\n//===----------------------------------------------------------------------===//\n// Partial specializations of FoldingSetTrait.\n\ntemplate<typename T> struct FoldingSetTrait<T*> {\n  static inline void Profile(T *X, FoldingSetNodeID &ID) {\n    ID.AddPointer(X);\n  }\n};\ntemplate <typename T1, typename T2>\nstruct FoldingSetTrait<std::pair<T1, T2>> {\n  static inline void Profile(const std::pair<T1, T2> &P,\n                             FoldingSetNodeID &ID) {\n    ID.Add(P.first);\n    ID.Add(P.second);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_FOLDINGSET_H\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "content": "//===- llvm/ADT/PointerUnion.h - Discriminated Union of 2 Ptrs --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the PointerUnion class, which is a discriminated union of\n// pointer types.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_POINTERUNION_H\n#define LLVM_ADT_POINTERUNION_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\nnamespace llvm {\n\ntemplate <typename T> struct PointerUnionTypeSelectorReturn {\n  using Return = T;\n};\n\n/// Get a type based on whether two types are the same or not.\n///\n/// For:\n///\n/// \\code\n///   using Ret = typename PointerUnionTypeSelector<T1, T2, EQ, NE>::Return;\n/// \\endcode\n///\n/// Ret will be EQ type if T1 is same as T2 or NE type otherwise.\ntemplate <typename T1, typename T2, typename RET_EQ, typename RET_NE>\nstruct PointerUnionTypeSelector {\n  using Return = typename PointerUnionTypeSelectorReturn<RET_NE>::Return;\n};\n\ntemplate <typename T, typename RET_EQ, typename RET_NE>\nstruct PointerUnionTypeSelector<T, T, RET_EQ, RET_NE> {\n  using Return = typename PointerUnionTypeSelectorReturn<RET_EQ>::Return;\n};\n\ntemplate <typename T1, typename T2, typename RET_EQ, typename RET_NE>\nstruct PointerUnionTypeSelectorReturn<\n    PointerUnionTypeSelector<T1, T2, RET_EQ, RET_NE>> {\n  using Return =\n      typename PointerUnionTypeSelector<T1, T2, RET_EQ, RET_NE>::Return;\n};\n\nnamespace pointer_union_detail {\n  /// Determine the number of bits required to store integers with values < n.\n  /// This is ceil(log2(n)).\n  constexpr int bitsRequired(unsigned n) {\n    return n > 1 ? 1 + bitsRequired((n + 1) / 2) : 0;\n  }\n\n  template <typename... Ts> constexpr int lowBitsAvailable() {\n    return std::min<int>({PointerLikeTypeTraits<Ts>::NumLowBitsAvailable...});\n  }\n\n  /// Find the index of a type in a list of types. TypeIndex<T, Us...>::Index\n  /// is the index of T in Us, or sizeof...(Us) if T does not appear in the\n  /// list.\n  template <typename T, typename ...Us> struct TypeIndex;\n  template <typename T, typename ...Us> struct TypeIndex<T, T, Us...> {\n    static constexpr int Index = 0;\n  };\n  template <typename T, typename U, typename... Us>\n  struct TypeIndex<T, U, Us...> {\n    static constexpr int Index = 1 + TypeIndex<T, Us...>::Index;\n  };\n  template <typename T> struct TypeIndex<T> {\n    static constexpr int Index = 0;\n  };\n\n  /// Find the first type in a list of types.\n  template <typename T, typename...> struct GetFirstType {\n    using type = T;\n  };\n\n  /// Provide PointerLikeTypeTraits for void* that is used by PointerUnion\n  /// for the template arguments.\n  template <typename ...PTs> class PointerUnionUIntTraits {\n  public:\n    static inline void *getAsVoidPointer(void *P) { return P; }\n    static inline void *getFromVoidPointer(void *P) { return P; }\n    static constexpr int NumLowBitsAvailable = lowBitsAvailable<PTs...>();\n  };\n\n  template <typename Derived, typename ValTy, int I, typename ...Types>\n  class PointerUnionMembers;\n\n  template <typename Derived, typename ValTy, int I>\n  class PointerUnionMembers<Derived, ValTy, I> {\n  protected:\n    ValTy Val;\n    PointerUnionMembers() = default;\n    PointerUnionMembers(ValTy Val) : Val(Val) {}\n\n    friend struct PointerLikeTypeTraits<Derived>;\n  };\n\n  template <typename Derived, typename ValTy, int I, typename Type,\n            typename ...Types>\n  class PointerUnionMembers<Derived, ValTy, I, Type, Types...>\n      : public PointerUnionMembers<Derived, ValTy, I + 1, Types...> {\n    using Base = PointerUnionMembers<Derived, ValTy, I + 1, Types...>;\n  public:\n    using Base::Base;\n    PointerUnionMembers() = default;\n    PointerUnionMembers(Type V)\n        : Base(ValTy(const_cast<void *>(\n                         PointerLikeTypeTraits<Type>::getAsVoidPointer(V)),\n                     I)) {}\n\n    using Base::operator=;\n    Derived &operator=(Type V) {\n      this->Val = ValTy(\n          const_cast<void *>(PointerLikeTypeTraits<Type>::getAsVoidPointer(V)),\n          I);\n      return static_cast<Derived &>(*this);\n    };\n  };\n}\n\n/// A discriminated union of two or more pointer types, with the discriminator\n/// in the low bit of the pointer.\n///\n/// This implementation is extremely efficient in space due to leveraging the\n/// low bits of the pointer, while exposing a natural and type-safe API.\n///\n/// Common use patterns would be something like this:\n///    PointerUnion<int*, float*> P;\n///    P = (int*)0;\n///    printf(\"%d %d\", P.is<int*>(), P.is<float*>());  // prints \"1 0\"\n///    X = P.get<int*>();     // ok.\n///    Y = P.get<float*>();   // runtime assertion failure.\n///    Z = P.get<double*>();  // compile time failure.\n///    P = (float*)0;\n///    Y = P.get<float*>();   // ok.\n///    X = P.get<int*>();     // runtime assertion failure.\ntemplate <typename... PTs>\nclass PointerUnion\n    : public pointer_union_detail::PointerUnionMembers<\n          PointerUnion<PTs...>,\n          PointerIntPair<\n              void *, pointer_union_detail::bitsRequired(sizeof...(PTs)), int,\n              pointer_union_detail::PointerUnionUIntTraits<PTs...>>,\n          0, PTs...> {\n  // The first type is special because we want to directly cast a pointer to a\n  // default-initialized union to a pointer to the first type. But we don't\n  // want PointerUnion to be a 'template <typename First, typename ...Rest>'\n  // because it's much more convenient to have a name for the whole pack. So\n  // split off the first type here.\n  using First = typename pointer_union_detail::GetFirstType<PTs...>::type;\n  using Base = typename PointerUnion::PointerUnionMembers;\n\npublic:\n  PointerUnion() = default;\n\n  PointerUnion(std::nullptr_t) : PointerUnion() {}\n  using Base::Base;\n\n  /// Test if the pointer held in the union is null, regardless of\n  /// which type it is.\n  bool isNull() const { return !this->Val.getPointer(); }\n\n  explicit operator bool() const { return !isNull(); }\n\n  /// Test if the Union currently holds the type matching T.\n  template <typename T> bool is() const {\n    constexpr int Index = pointer_union_detail::TypeIndex<T, PTs...>::Index;\n    static_assert(Index < sizeof...(PTs),\n                  \"PointerUnion::is<T> given type not in the union\");\n    return this->Val.getInt() == Index;\n  }\n\n  /// Returns the value of the specified pointer type.\n  ///\n  /// If the specified pointer type is incorrect, assert.\n  template <typename T> T get() const {\n    assert(is<T>() && \"Invalid accessor called\");\n    return PointerLikeTypeTraits<T>::getFromVoidPointer(this->Val.getPointer());\n  }\n\n  /// Returns the current pointer if it is of the specified pointer type,\n  /// otherwise returns null.\n  template <typename T> T dyn_cast() const {\n    if (is<T>())\n      return get<T>();\n    return T();\n  }\n\n  /// If the union is set to the first pointer type get an address pointing to\n  /// it.\n  First const *getAddrOfPtr1() const {\n    return const_cast<PointerUnion *>(this)->getAddrOfPtr1();\n  }\n\n  /// If the union is set to the first pointer type get an address pointing to\n  /// it.\n  First *getAddrOfPtr1() {\n    assert(is<First>() && \"Val is not the first pointer\");\n    assert(\n        PointerLikeTypeTraits<First>::getAsVoidPointer(get<First>()) ==\n            this->Val.getPointer() &&\n        \"Can't get the address because PointerLikeTypeTraits changes the ptr\");\n    return const_cast<First *>(\n        reinterpret_cast<const First *>(this->Val.getAddrOfPointer()));\n  }\n\n  /// Assignment from nullptr which just clears the union.\n  const PointerUnion &operator=(std::nullptr_t) {\n    this->Val.initWithPointer(nullptr);\n    return *this;\n  }\n\n  /// Assignment from elements of the union.\n  using Base::operator=;\n\n  void *getOpaqueValue() const { return this->Val.getOpaqueValue(); }\n  static inline PointerUnion getFromOpaqueValue(void *VP) {\n    PointerUnion V;\n    V.Val = decltype(V.Val)::getFromOpaqueValue(VP);\n    return V;\n  }\n};\n\ntemplate <typename ...PTs>\nbool operator==(PointerUnion<PTs...> lhs, PointerUnion<PTs...> rhs) {\n  return lhs.getOpaqueValue() == rhs.getOpaqueValue();\n}\n\ntemplate <typename ...PTs>\nbool operator!=(PointerUnion<PTs...> lhs, PointerUnion<PTs...> rhs) {\n  return lhs.getOpaqueValue() != rhs.getOpaqueValue();\n}\n\ntemplate <typename ...PTs>\nbool operator<(PointerUnion<PTs...> lhs, PointerUnion<PTs...> rhs) {\n  return lhs.getOpaqueValue() < rhs.getOpaqueValue();\n}\n\n// Teach SmallPtrSet that PointerUnion is \"basically a pointer\", that has\n// # low bits available = min(PT1bits,PT2bits)-1.\ntemplate <typename ...PTs>\nstruct PointerLikeTypeTraits<PointerUnion<PTs...>> {\n  static inline void *getAsVoidPointer(const PointerUnion<PTs...> &P) {\n    return P.getOpaqueValue();\n  }\n\n  static inline PointerUnion<PTs...> getFromVoidPointer(void *P) {\n    return PointerUnion<PTs...>::getFromOpaqueValue(P);\n  }\n\n  // The number of bits available are the min of the pointer types minus the\n  // bits needed for the discriminator.\n  static constexpr int NumLowBitsAvailable = PointerLikeTypeTraits<decltype(\n      PointerUnion<PTs...>::Val)>::NumLowBitsAvailable;\n};\n\n// Teach DenseMap how to use PointerUnions as keys.\ntemplate <typename ...PTs> struct DenseMapInfo<PointerUnion<PTs...>> {\n  using Union = PointerUnion<PTs...>;\n  using FirstInfo =\n      DenseMapInfo<typename pointer_union_detail::GetFirstType<PTs...>::type>;\n\n  static inline Union getEmptyKey() { return Union(FirstInfo::getEmptyKey()); }\n\n  static inline Union getTombstoneKey() {\n    return Union(FirstInfo::getTombstoneKey());\n  }\n\n  static unsigned getHashValue(const Union &UnionVal) {\n    intptr_t key = (intptr_t)UnionVal.getOpaqueValue();\n    return DenseMapInfo<intptr_t>::getHashValue(key);\n  }\n\n  static bool isEqual(const Union &LHS, const Union &RHS) {\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_POINTERUNION_H\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "content": "//===- llvm/ADT/SmallPtrSet.h - 'Normally small' pointer set ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the SmallPtrSet class.  See the doxygen comment for\n// SmallPtrSetImplBase for more details on the algorithm used.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SMALLPTRSET_H\n#define LLVM_ADT_SMALLPTRSET_H\n\n#include \"llvm/ADT/EpochTracker.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ReverseIteration.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdlib>\n#include <cstring>\n#include <initializer_list>\n#include <iterator>\n#include <utility>\n\nnamespace llvm {\n\n/// SmallPtrSetImplBase - This is the common code shared among all the\n/// SmallPtrSet<>'s, which is almost everything.  SmallPtrSet has two modes, one\n/// for small and one for large sets.\n///\n/// Small sets use an array of pointers allocated in the SmallPtrSet object,\n/// which is treated as a simple array of pointers.  When a pointer is added to\n/// the set, the array is scanned to see if the element already exists, if not\n/// the element is 'pushed back' onto the array.  If we run out of space in the\n/// array, we grow into the 'large set' case.  SmallSet should be used when the\n/// sets are often small.  In this case, no memory allocation is used, and only\n/// light-weight and cache-efficient scanning is used.\n///\n/// Large sets use a classic exponentially-probed hash table.  Empty buckets are\n/// represented with an illegal pointer value (-1) to allow null pointers to be\n/// inserted.  Tombstones are represented with another illegal pointer value\n/// (-2), to allow deletion.  The hash table is resized when the table is 3/4 or\n/// more.  When this happens, the table is doubled in size.\n///\nclass SmallPtrSetImplBase : public DebugEpochBase {\n  friend class SmallPtrSetIteratorImpl;\n\nprotected:\n  /// SmallArray - Points to a fixed size set of buckets, used in 'small mode'.\n  const void **SmallArray;\n  /// CurArray - This is the current set of buckets.  If equal to SmallArray,\n  /// then the set is in 'small mode'.\n  const void **CurArray;\n  /// CurArraySize - The allocated size of CurArray, always a power of two.\n  unsigned CurArraySize;\n\n  /// Number of elements in CurArray that contain a value or are a tombstone.\n  /// If small, all these elements are at the beginning of CurArray and the rest\n  /// is uninitialized.\n  unsigned NumNonEmpty;\n  /// Number of tombstones in CurArray.\n  unsigned NumTombstones;\n\n  // Helpers to copy and move construct a SmallPtrSet.\n  SmallPtrSetImplBase(const void **SmallStorage,\n                      const SmallPtrSetImplBase &that);\n  SmallPtrSetImplBase(const void **SmallStorage, unsigned SmallSize,\n                      SmallPtrSetImplBase &&that);\n\n  explicit SmallPtrSetImplBase(const void **SmallStorage, unsigned SmallSize)\n      : SmallArray(SmallStorage), CurArray(SmallStorage),\n        CurArraySize(SmallSize), NumNonEmpty(0), NumTombstones(0) {\n    assert(SmallSize && (SmallSize & (SmallSize-1)) == 0 &&\n           \"Initial size must be a power of two!\");\n  }\n\n  ~SmallPtrSetImplBase() {\n    if (!isSmall())\n      free(CurArray);\n  }\n\npublic:\n  using size_type = unsigned;\n\n  SmallPtrSetImplBase &operator=(const SmallPtrSetImplBase &) = delete;\n\n  LLVM_NODISCARD bool empty() const { return size() == 0; }\n  size_type size() const { return NumNonEmpty - NumTombstones; }\n\n  void clear() {\n    incrementEpoch();\n    // If the capacity of the array is huge, and the # elements used is small,\n    // shrink the array.\n    if (!isSmall()) {\n      if (size() * 4 < CurArraySize && CurArraySize > 32)\n        return shrink_and_clear();\n      // Fill the array with empty markers.\n      memset(CurArray, -1, CurArraySize * sizeof(void *));\n    }\n\n    NumNonEmpty = 0;\n    NumTombstones = 0;\n  }\n\nprotected:\n  static void *getTombstoneMarker() { return reinterpret_cast<void*>(-2); }\n\n  static void *getEmptyMarker() {\n    // Note that -1 is chosen to make clear() efficiently implementable with\n    // memset and because it's not a valid pointer value.\n    return reinterpret_cast<void*>(-1);\n  }\n\n  const void **EndPointer() const {\n    return isSmall() ? CurArray + NumNonEmpty : CurArray + CurArraySize;\n  }\n\n  /// insert_imp - This returns true if the pointer was new to the set, false if\n  /// it was already in the set.  This is hidden from the client so that the\n  /// derived class can check that the right type of pointer is passed in.\n  std::pair<const void *const *, bool> insert_imp(const void *Ptr) {\n    if (isSmall()) {\n      // Check to see if it is already in the set.\n      const void **LastTombstone = nullptr;\n      for (const void **APtr = SmallArray, **E = SmallArray + NumNonEmpty;\n           APtr != E; ++APtr) {\n        const void *Value = *APtr;\n        if (Value == Ptr)\n          return std::make_pair(APtr, false);\n        if (Value == getTombstoneMarker())\n          LastTombstone = APtr;\n      }\n\n      // Did we find any tombstone marker?\n      if (LastTombstone != nullptr) {\n        *LastTombstone = Ptr;\n        --NumTombstones;\n        incrementEpoch();\n        return std::make_pair(LastTombstone, true);\n      }\n\n      // Nope, there isn't.  If we stay small, just 'pushback' now.\n      if (NumNonEmpty < CurArraySize) {\n        SmallArray[NumNonEmpty++] = Ptr;\n        incrementEpoch();\n        return std::make_pair(SmallArray + (NumNonEmpty - 1), true);\n      }\n      // Otherwise, hit the big set case, which will call grow.\n    }\n    return insert_imp_big(Ptr);\n  }\n\n  /// erase_imp - If the set contains the specified pointer, remove it and\n  /// return true, otherwise return false.  This is hidden from the client so\n  /// that the derived class can check that the right type of pointer is passed\n  /// in.\n  bool erase_imp(const void * Ptr) {\n    const void *const *P = find_imp(Ptr);\n    if (P == EndPointer())\n      return false;\n\n    const void **Loc = const_cast<const void **>(P);\n    assert(*Loc == Ptr && \"broken find!\");\n    *Loc = getTombstoneMarker();\n    NumTombstones++;\n    return true;\n  }\n\n  /// Returns the raw pointer needed to construct an iterator.  If element not\n  /// found, this will be EndPointer.  Otherwise, it will be a pointer to the\n  /// slot which stores Ptr;\n  const void *const * find_imp(const void * Ptr) const {\n    if (isSmall()) {\n      // Linear search for the item.\n      for (const void *const *APtr = SmallArray,\n                      *const *E = SmallArray + NumNonEmpty; APtr != E; ++APtr)\n        if (*APtr == Ptr)\n          return APtr;\n      return EndPointer();\n    }\n\n    // Big set case.\n    auto *Bucket = FindBucketFor(Ptr);\n    if (*Bucket == Ptr)\n      return Bucket;\n    return EndPointer();\n  }\n\nprivate:\n  bool isSmall() const { return CurArray == SmallArray; }\n\n  std::pair<const void *const *, bool> insert_imp_big(const void *Ptr);\n\n  const void * const *FindBucketFor(const void *Ptr) const;\n  void shrink_and_clear();\n\n  /// Grow - Allocate a larger backing store for the buckets and move it over.\n  void Grow(unsigned NewSize);\n\nprotected:\n  /// swap - Swaps the elements of two sets.\n  /// Note: This method assumes that both sets have the same small size.\n  void swap(SmallPtrSetImplBase &RHS);\n\n  void CopyFrom(const SmallPtrSetImplBase &RHS);\n  void MoveFrom(unsigned SmallSize, SmallPtrSetImplBase &&RHS);\n\nprivate:\n  /// Code shared by MoveFrom() and move constructor.\n  void MoveHelper(unsigned SmallSize, SmallPtrSetImplBase &&RHS);\n  /// Code shared by CopyFrom() and copy constructor.\n  void CopyHelper(const SmallPtrSetImplBase &RHS);\n};\n\n/// SmallPtrSetIteratorImpl - This is the common base class shared between all\n/// instances of SmallPtrSetIterator.\nclass SmallPtrSetIteratorImpl {\nprotected:\n  const void *const *Bucket;\n  const void *const *End;\n\npublic:\n  explicit SmallPtrSetIteratorImpl(const void *const *BP, const void*const *E)\n    : Bucket(BP), End(E) {\n    if (shouldReverseIterate()) {\n      RetreatIfNotValid();\n      return;\n    }\n    AdvanceIfNotValid();\n  }\n\n  bool operator==(const SmallPtrSetIteratorImpl &RHS) const {\n    return Bucket == RHS.Bucket;\n  }\n  bool operator!=(const SmallPtrSetIteratorImpl &RHS) const {\n    return Bucket != RHS.Bucket;\n  }\n\nprotected:\n  /// AdvanceIfNotValid - If the current bucket isn't valid, advance to a bucket\n  /// that is.   This is guaranteed to stop because the end() bucket is marked\n  /// valid.\n  void AdvanceIfNotValid() {\n    assert(Bucket <= End);\n    while (Bucket != End &&\n           (*Bucket == SmallPtrSetImplBase::getEmptyMarker() ||\n            *Bucket == SmallPtrSetImplBase::getTombstoneMarker()))\n      ++Bucket;\n  }\n  void RetreatIfNotValid() {\n    assert(Bucket >= End);\n    while (Bucket != End &&\n           (Bucket[-1] == SmallPtrSetImplBase::getEmptyMarker() ||\n            Bucket[-1] == SmallPtrSetImplBase::getTombstoneMarker())) {\n      --Bucket;\n    }\n  }\n};\n\n/// SmallPtrSetIterator - This implements a const_iterator for SmallPtrSet.\ntemplate <typename PtrTy>\nclass SmallPtrSetIterator : public SmallPtrSetIteratorImpl,\n                            DebugEpochBase::HandleBase {\n  using PtrTraits = PointerLikeTypeTraits<PtrTy>;\n\npublic:\n  using value_type = PtrTy;\n  using reference = PtrTy;\n  using pointer = PtrTy;\n  using difference_type = std::ptrdiff_t;\n  using iterator_category = std::forward_iterator_tag;\n\n  explicit SmallPtrSetIterator(const void *const *BP, const void *const *E,\n                               const DebugEpochBase &Epoch)\n      : SmallPtrSetIteratorImpl(BP, E), DebugEpochBase::HandleBase(&Epoch) {}\n\n  // Most methods are provided by the base class.\n\n  const PtrTy operator*() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    if (shouldReverseIterate()) {\n      assert(Bucket > End);\n      return PtrTraits::getFromVoidPointer(const_cast<void *>(Bucket[-1]));\n    }\n    assert(Bucket < End);\n    return PtrTraits::getFromVoidPointer(const_cast<void*>(*Bucket));\n  }\n\n  inline SmallPtrSetIterator& operator++() {          // Preincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    if (shouldReverseIterate()) {\n      --Bucket;\n      RetreatIfNotValid();\n      return *this;\n    }\n    ++Bucket;\n    AdvanceIfNotValid();\n    return *this;\n  }\n\n  SmallPtrSetIterator operator++(int) {        // Postincrement\n    SmallPtrSetIterator tmp = *this;\n    ++*this;\n    return tmp;\n  }\n};\n\n/// RoundUpToPowerOfTwo - This is a helper template that rounds N up to the next\n/// power of two (which means N itself if N is already a power of two).\ntemplate<unsigned N>\nstruct RoundUpToPowerOfTwo;\n\n/// RoundUpToPowerOfTwoH - If N is not a power of two, increase it.  This is a\n/// helper template used to implement RoundUpToPowerOfTwo.\ntemplate<unsigned N, bool isPowerTwo>\nstruct RoundUpToPowerOfTwoH {\n  enum { Val = N };\n};\ntemplate<unsigned N>\nstruct RoundUpToPowerOfTwoH<N, false> {\n  enum {\n    // We could just use NextVal = N+1, but this converges faster.  N|(N-1) sets\n    // the right-most zero bits to one all at once, e.g. 0b0011000 -> 0b0011111.\n    Val = RoundUpToPowerOfTwo<(N|(N-1)) + 1>::Val\n  };\n};\n\ntemplate<unsigned N>\nstruct RoundUpToPowerOfTwo {\n  enum { Val = RoundUpToPowerOfTwoH<N, (N&(N-1)) == 0>::Val };\n};\n\n/// A templated base class for \\c SmallPtrSet which provides the\n/// typesafe interface that is common across all small sizes.\n///\n/// This is particularly useful for passing around between interface boundaries\n/// to avoid encoding a particular small size in the interface boundary.\ntemplate <typename PtrType>\nclass SmallPtrSetImpl : public SmallPtrSetImplBase {\n  using ConstPtrType = typename add_const_past_pointer<PtrType>::type;\n  using PtrTraits = PointerLikeTypeTraits<PtrType>;\n  using ConstPtrTraits = PointerLikeTypeTraits<ConstPtrType>;\n\nprotected:\n  // Forward constructors to the base.\n  using SmallPtrSetImplBase::SmallPtrSetImplBase;\n\npublic:\n  using iterator = SmallPtrSetIterator<PtrType>;\n  using const_iterator = SmallPtrSetIterator<PtrType>;\n  using key_type = ConstPtrType;\n  using value_type = PtrType;\n\n  SmallPtrSetImpl(const SmallPtrSetImpl &) = delete;\n\n  /// Inserts Ptr if and only if there is no element in the container equal to\n  /// Ptr. The bool component of the returned pair is true if and only if the\n  /// insertion takes place, and the iterator component of the pair points to\n  /// the element equal to Ptr.\n  std::pair<iterator, bool> insert(PtrType Ptr) {\n    auto p = insert_imp(PtrTraits::getAsVoidPointer(Ptr));\n    return std::make_pair(makeIterator(p.first), p.second);\n  }\n\n  /// Insert the given pointer with an iterator hint that is ignored. This is\n  /// identical to calling insert(Ptr), but allows SmallPtrSet to be used by\n  /// std::insert_iterator and std::inserter().\n  iterator insert(iterator, PtrType Ptr) {\n    return insert(Ptr).first;\n  }\n\n  /// erase - If the set contains the specified pointer, remove it and return\n  /// true, otherwise return false.\n  bool erase(PtrType Ptr) {\n    return erase_imp(PtrTraits::getAsVoidPointer(Ptr));\n  }\n  /// count - Return 1 if the specified pointer is in the set, 0 otherwise.\n  size_type count(ConstPtrType Ptr) const {\n    return find_imp(ConstPtrTraits::getAsVoidPointer(Ptr)) != EndPointer();\n  }\n  iterator find(ConstPtrType Ptr) const {\n    return makeIterator(find_imp(ConstPtrTraits::getAsVoidPointer(Ptr)));\n  }\n  bool contains(ConstPtrType Ptr) const {\n    return find_imp(ConstPtrTraits::getAsVoidPointer(Ptr)) != EndPointer();\n  }\n\n  template <typename IterT>\n  void insert(IterT I, IterT E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  void insert(std::initializer_list<PtrType> IL) {\n    insert(IL.begin(), IL.end());\n  }\n\n  iterator begin() const {\n    if (shouldReverseIterate())\n      return makeIterator(EndPointer() - 1);\n    return makeIterator(CurArray);\n  }\n  iterator end() const { return makeIterator(EndPointer()); }\n\nprivate:\n  /// Create an iterator that dereferences to same place as the given pointer.\n  iterator makeIterator(const void *const *P) const {\n    if (shouldReverseIterate())\n      return iterator(P == EndPointer() ? CurArray : P + 1, CurArray, *this);\n    return iterator(P, EndPointer(), *this);\n  }\n};\n\n/// Equality comparison for SmallPtrSet.\n///\n/// Iterates over elements of LHS confirming that each value from LHS is also in\n/// RHS, and that no additional values are in RHS.\ntemplate <typename PtrType>\nbool operator==(const SmallPtrSetImpl<PtrType> &LHS,\n                const SmallPtrSetImpl<PtrType> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  for (const auto *KV : LHS)\n    if (!RHS.count(KV))\n      return false;\n\n  return true;\n}\n\n/// Inequality comparison for SmallPtrSet.\n///\n/// Equivalent to !(LHS == RHS).\ntemplate <typename PtrType>\nbool operator!=(const SmallPtrSetImpl<PtrType> &LHS,\n                const SmallPtrSetImpl<PtrType> &RHS) {\n  return !(LHS == RHS);\n}\n\n/// SmallPtrSet - This class implements a set which is optimized for holding\n/// SmallSize or less elements.  This internally rounds up SmallSize to the next\n/// power of two if it is not already a power of two.  See the comments above\n/// SmallPtrSetImplBase for details of the algorithm.\ntemplate<class PtrType, unsigned SmallSize>\nclass SmallPtrSet : public SmallPtrSetImpl<PtrType> {\n  // In small mode SmallPtrSet uses linear search for the elements, so it is\n  // not a good idea to choose this value too high. You may consider using a\n  // DenseSet<> instead if you expect many elements in the set.\n  static_assert(SmallSize <= 32, \"SmallSize should be small\");\n\n  using BaseT = SmallPtrSetImpl<PtrType>;\n\n  // Make sure that SmallSize is a power of two, round up if not.\n  enum { SmallSizePowTwo = RoundUpToPowerOfTwo<SmallSize>::Val };\n  /// SmallStorage - Fixed size storage used in 'small mode'.\n  const void *SmallStorage[SmallSizePowTwo];\n\npublic:\n  SmallPtrSet() : BaseT(SmallStorage, SmallSizePowTwo) {}\n  SmallPtrSet(const SmallPtrSet &that) : BaseT(SmallStorage, that) {}\n  SmallPtrSet(SmallPtrSet &&that)\n      : BaseT(SmallStorage, SmallSizePowTwo, std::move(that)) {}\n\n  template<typename It>\n  SmallPtrSet(It I, It E) : BaseT(SmallStorage, SmallSizePowTwo) {\n    this->insert(I, E);\n  }\n\n  SmallPtrSet(std::initializer_list<PtrType> IL)\n      : BaseT(SmallStorage, SmallSizePowTwo) {\n    this->insert(IL.begin(), IL.end());\n  }\n\n  SmallPtrSet<PtrType, SmallSize> &\n  operator=(const SmallPtrSet<PtrType, SmallSize> &RHS) {\n    if (&RHS != this)\n      this->CopyFrom(RHS);\n    return *this;\n  }\n\n  SmallPtrSet<PtrType, SmallSize> &\n  operator=(SmallPtrSet<PtrType, SmallSize> &&RHS) {\n    if (&RHS != this)\n      this->MoveFrom(SmallSizePowTwo, std::move(RHS));\n    return *this;\n  }\n\n  SmallPtrSet<PtrType, SmallSize> &\n  operator=(std::initializer_list<PtrType> IL) {\n    this->clear();\n    this->insert(IL.begin(), IL.end());\n    return *this;\n  }\n\n  /// swap - Swaps the elements of two sets.\n  void swap(SmallPtrSet<PtrType, SmallSize> &RHS) {\n    SmallPtrSetImplBase::swap(RHS);\n  }\n};\n\n} // end namespace llvm\n\nnamespace std {\n\n  /// Implement std::swap in terms of SmallPtrSet swap.\n  template<class T, unsigned N>\n  inline void swap(llvm::SmallPtrSet<T, N> &LHS, llvm::SmallPtrSet<T, N> &RHS) {\n    LHS.swap(RHS);\n  }\n\n} // end namespace std\n\n#endif // LLVM_ADT_SMALLPTRSET_H\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallSet.h", "content": "//===- llvm/ADT/SmallSet.h - 'Normally small' sets --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the SmallSet class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SMALLSET_H\n#define LLVM_ADT_SMALLSET_H\n\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cstddef>\n#include <functional>\n#include <set>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\n/// SmallSetIterator - This class implements a const_iterator for SmallSet by\n/// delegating to the underlying SmallVector or Set iterators.\ntemplate <typename T, unsigned N, typename C>\nclass SmallSetIterator\n    : public iterator_facade_base<SmallSetIterator<T, N, C>,\n                                  std::forward_iterator_tag, T> {\nprivate:\n  using SetIterTy = typename std::set<T, C>::const_iterator;\n  using VecIterTy = typename SmallVector<T, N>::const_iterator;\n  using SelfTy = SmallSetIterator<T, N, C>;\n\n  /// Iterators to the parts of the SmallSet containing the data. They are set\n  /// depending on isSmall.\n  union {\n    SetIterTy SetIter;\n    VecIterTy VecIter;\n  };\n\n  bool isSmall;\n\npublic:\n  SmallSetIterator(SetIterTy SetIter) : SetIter(SetIter), isSmall(false) {}\n\n  SmallSetIterator(VecIterTy VecIter) : VecIter(VecIter), isSmall(true) {}\n\n  // Spell out destructor, copy/move constructor and assignment operators for\n  // MSVC STL, where set<T>::const_iterator is not trivially copy constructible.\n  ~SmallSetIterator() {\n    if (isSmall)\n      VecIter.~VecIterTy();\n    else\n      SetIter.~SetIterTy();\n  }\n\n  SmallSetIterator(const SmallSetIterator &Other) : isSmall(Other.isSmall) {\n    if (isSmall)\n      VecIter = Other.VecIter;\n    else\n      // Use placement new, to make sure SetIter is properly constructed, even\n      // if it is not trivially copy-able (e.g. in MSVC).\n      new (&SetIter) SetIterTy(Other.SetIter);\n  }\n\n  SmallSetIterator(SmallSetIterator &&Other) : isSmall(Other.isSmall) {\n    if (isSmall)\n      VecIter = std::move(Other.VecIter);\n    else\n      // Use placement new, to make sure SetIter is properly constructed, even\n      // if it is not trivially copy-able (e.g. in MSVC).\n      new (&SetIter) SetIterTy(std::move(Other.SetIter));\n  }\n\n  SmallSetIterator& operator=(const SmallSetIterator& Other) {\n    // Call destructor for SetIter, so it gets properly destroyed if it is\n    // not trivially destructible in case we are setting VecIter.\n    if (!isSmall)\n      SetIter.~SetIterTy();\n\n    isSmall = Other.isSmall;\n    if (isSmall)\n      VecIter = Other.VecIter;\n    else\n      new (&SetIter) SetIterTy(Other.SetIter);\n    return *this;\n  }\n\n  SmallSetIterator& operator=(SmallSetIterator&& Other) {\n    // Call destructor for SetIter, so it gets properly destroyed if it is\n    // not trivially destructible in case we are setting VecIter.\n    if (!isSmall)\n      SetIter.~SetIterTy();\n\n    isSmall = Other.isSmall;\n    if (isSmall)\n      VecIter = std::move(Other.VecIter);\n    else\n      new (&SetIter) SetIterTy(std::move(Other.SetIter));\n    return *this;\n  }\n\n  bool operator==(const SmallSetIterator &RHS) const {\n    if (isSmall != RHS.isSmall)\n      return false;\n    if (isSmall)\n      return VecIter == RHS.VecIter;\n    return SetIter == RHS.SetIter;\n  }\n\n  SmallSetIterator &operator++() { // Preincrement\n    if (isSmall)\n      VecIter++;\n    else\n      SetIter++;\n    return *this;\n  }\n\n  const T &operator*() const { return isSmall ? *VecIter : *SetIter; }\n};\n\n/// SmallSet - This maintains a set of unique values, optimizing for the case\n/// when the set is small (less than N).  In this case, the set can be\n/// maintained with no mallocs.  If the set gets large, we expand to using an\n/// std::set to maintain reasonable lookup times.\ntemplate <typename T, unsigned N, typename C = std::less<T>>\nclass SmallSet {\n  /// Use a SmallVector to hold the elements here (even though it will never\n  /// reach its 'large' stage) to avoid calling the default ctors of elements\n  /// we will never use.\n  SmallVector<T, N> Vector;\n  std::set<T, C> Set;\n\n  using VIterator = typename SmallVector<T, N>::const_iterator;\n  using mutable_iterator = typename SmallVector<T, N>::iterator;\n\n  // In small mode SmallPtrSet uses linear search for the elements, so it is\n  // not a good idea to choose this value too high. You may consider using a\n  // DenseSet<> instead if you expect many elements in the set.\n  static_assert(N <= 32, \"N should be small\");\n\npublic:\n  using size_type = size_t;\n  using const_iterator = SmallSetIterator<T, N, C>;\n\n  SmallSet() = default;\n\n  LLVM_NODISCARD bool empty() const {\n    return Vector.empty() && Set.empty();\n  }\n\n  size_type size() const {\n    return isSmall() ? Vector.size() : Set.size();\n  }\n\n  /// count - Return 1 if the element is in the set, 0 otherwise.\n  size_type count(const T &V) const {\n    if (isSmall()) {\n      // Since the collection is small, just do a linear search.\n      return vfind(V) == Vector.end() ? 0 : 1;\n    } else {\n      return Set.count(V);\n    }\n  }\n\n  /// insert - Insert an element into the set if it isn't already there.\n  /// Returns true if the element is inserted (it was not in the set before).\n  /// The first value of the returned pair is unused and provided for\n  /// partial compatibility with the standard library self-associative container\n  /// concept.\n  // FIXME: Add iterators that abstract over the small and large form, and then\n  // return those here.\n  std::pair<NoneType, bool> insert(const T &V) {\n    if (!isSmall())\n      return std::make_pair(None, Set.insert(V).second);\n\n    VIterator I = vfind(V);\n    if (I != Vector.end())    // Don't reinsert if it already exists.\n      return std::make_pair(None, false);\n    if (Vector.size() < N) {\n      Vector.push_back(V);\n      return std::make_pair(None, true);\n    }\n\n    // Otherwise, grow from vector to set.\n    while (!Vector.empty()) {\n      Set.insert(Vector.back());\n      Vector.pop_back();\n    }\n    Set.insert(V);\n    return std::make_pair(None, true);\n  }\n\n  template <typename IterT>\n  void insert(IterT I, IterT E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  bool erase(const T &V) {\n    if (!isSmall())\n      return Set.erase(V);\n    for (mutable_iterator I = Vector.begin(), E = Vector.end(); I != E; ++I)\n      if (*I == V) {\n        Vector.erase(I);\n        return true;\n      }\n    return false;\n  }\n\n  void clear() {\n    Vector.clear();\n    Set.clear();\n  }\n\n  const_iterator begin() const {\n    if (isSmall())\n      return {Vector.begin()};\n    return {Set.begin()};\n  }\n\n  const_iterator end() const {\n    if (isSmall())\n      return {Vector.end()};\n    return {Set.end()};\n  }\n\n  /// Check if the SmallSet contains the given element.\n  bool contains(const T &V) const {\n    if (isSmall())\n      return vfind(V) != Vector.end();\n    return Set.find(V) != Set.end();\n  }\n\nprivate:\n  bool isSmall() const { return Set.empty(); }\n\n  VIterator vfind(const T &V) const {\n    for (VIterator I = Vector.begin(), E = Vector.end(); I != E; ++I)\n      if (*I == V)\n        return I;\n    return Vector.end();\n  }\n};\n\n/// If this set is of pointer values, transparently switch over to using\n/// SmallPtrSet for performance.\ntemplate <typename PointeeType, unsigned N>\nclass SmallSet<PointeeType*, N> : public SmallPtrSet<PointeeType*, N> {};\n\n/// Equality comparison for SmallSet.\n///\n/// Iterates over elements of LHS confirming that each element is also a member\n/// of RHS, and that RHS contains no additional values.\n/// Equivalent to N calls to RHS.count.\n/// For small-set mode amortized complexity is O(N^2)\n/// For large-set mode amortized complexity is linear, worst case is O(N^2) (if\n/// every hash collides).\ntemplate <typename T, unsigned LN, unsigned RN, typename C>\nbool operator==(const SmallSet<T, LN, C> &LHS, const SmallSet<T, RN, C> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  // All elements in LHS must also be in RHS\n  return all_of(LHS, [&RHS](const T &E) { return RHS.count(E); });\n}\n\n/// Inequality comparison for SmallSet.\n///\n/// Equivalent to !(LHS == RHS). See operator== for performance notes.\ntemplate <typename T, unsigned LN, unsigned RN, typename C>\nbool operator!=(const SmallSet<T, LN, C> &LHS, const SmallSet<T, RN, C> &RHS) {\n  return !(LHS == RHS);\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_SMALLSET_H\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h", "content": "//===- llvm/ADT/SparseBitVector.h - Efficient Sparse BitVector --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the SparseBitVector class.  See the doxygen comment for\n// SparseBitVector for more details on the algorithm used.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SPARSEBITVECTOR_H\n#define LLVM_ADT_SPARSEBITVECTOR_H\n\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <climits>\n#include <cstring>\n#include <iterator>\n#include <list>\n\nnamespace llvm {\n\n/// SparseBitVector is an implementation of a bitvector that is sparse by only\n/// storing the elements that have non-zero bits set.  In order to make this\n/// fast for the most common cases, SparseBitVector is implemented as a linked\n/// list of SparseBitVectorElements.  We maintain a pointer to the last\n/// SparseBitVectorElement accessed (in the form of a list iterator), in order\n/// to make multiple in-order test/set constant time after the first one is\n/// executed.  Note that using vectors to store SparseBitVectorElement's does\n/// not work out very well because it causes insertion in the middle to take\n/// enormous amounts of time with a large amount of bits.  Other structures that\n/// have better worst cases for insertion in the middle (various balanced trees,\n/// etc) do not perform as well in practice as a linked list with this iterator\n/// kept up to date.  They are also significantly more memory intensive.\n\ntemplate <unsigned ElementSize = 128> struct SparseBitVectorElement {\npublic:\n  using BitWord = unsigned long;\n  using size_type = unsigned;\n  enum {\n    BITWORD_SIZE = sizeof(BitWord) * CHAR_BIT,\n    BITWORDS_PER_ELEMENT = (ElementSize + BITWORD_SIZE - 1) / BITWORD_SIZE,\n    BITS_PER_ELEMENT = ElementSize\n  };\n\nprivate:\n  // Index of Element in terms of where first bit starts.\n  unsigned ElementIndex;\n  BitWord Bits[BITWORDS_PER_ELEMENT];\n\n  SparseBitVectorElement() {\n    ElementIndex = ~0U;\n    memset(&Bits[0], 0, sizeof (BitWord) * BITWORDS_PER_ELEMENT);\n  }\n\npublic:\n  explicit SparseBitVectorElement(unsigned Idx) {\n    ElementIndex = Idx;\n    memset(&Bits[0], 0, sizeof (BitWord) * BITWORDS_PER_ELEMENT);\n  }\n\n  // Comparison.\n  bool operator==(const SparseBitVectorElement &RHS) const {\n    if (ElementIndex != RHS.ElementIndex)\n      return false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i)\n      if (Bits[i] != RHS.Bits[i])\n        return false;\n    return true;\n  }\n\n  bool operator!=(const SparseBitVectorElement &RHS) const {\n    return !(*this == RHS);\n  }\n\n  // Return the bits that make up word Idx in our element.\n  BitWord word(unsigned Idx) const {\n    assert(Idx < BITWORDS_PER_ELEMENT);\n    return Bits[Idx];\n  }\n\n  unsigned index() const {\n    return ElementIndex;\n  }\n\n  bool empty() const {\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i)\n      if (Bits[i])\n        return false;\n    return true;\n  }\n\n  void set(unsigned Idx) {\n    Bits[Idx / BITWORD_SIZE] |= 1L << (Idx % BITWORD_SIZE);\n  }\n\n  bool test_and_set(unsigned Idx) {\n    bool old = test(Idx);\n    if (!old) {\n      set(Idx);\n      return true;\n    }\n    return false;\n  }\n\n  void reset(unsigned Idx) {\n    Bits[Idx / BITWORD_SIZE] &= ~(1L << (Idx % BITWORD_SIZE));\n  }\n\n  bool test(unsigned Idx) const {\n    return Bits[Idx / BITWORD_SIZE] & (1L << (Idx % BITWORD_SIZE));\n  }\n\n  size_type count() const {\n    unsigned NumBits = 0;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i)\n      NumBits += countPopulation(Bits[i]);\n    return NumBits;\n  }\n\n  /// find_first - Returns the index of the first set bit.\n  int find_first() const {\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i)\n      if (Bits[i] != 0)\n        return i * BITWORD_SIZE + countTrailingZeros(Bits[i]);\n    llvm_unreachable(\"Illegal empty element\");\n  }\n\n  /// find_last - Returns the index of the last set bit.\n  int find_last() const {\n    for (unsigned I = 0; I < BITWORDS_PER_ELEMENT; ++I) {\n      unsigned Idx = BITWORDS_PER_ELEMENT - I - 1;\n      if (Bits[Idx] != 0)\n        return Idx * BITWORD_SIZE + BITWORD_SIZE -\n               countLeadingZeros(Bits[Idx]) - 1;\n    }\n    llvm_unreachable(\"Illegal empty element\");\n  }\n\n  /// find_next - Returns the index of the next set bit starting from the\n  /// \"Curr\" bit. Returns -1 if the next set bit is not found.\n  int find_next(unsigned Curr) const {\n    if (Curr >= BITS_PER_ELEMENT)\n      return -1;\n\n    unsigned WordPos = Curr / BITWORD_SIZE;\n    unsigned BitPos = Curr % BITWORD_SIZE;\n    BitWord Copy = Bits[WordPos];\n    assert(WordPos <= BITWORDS_PER_ELEMENT\n           && \"Word Position outside of element\");\n\n    // Mask off previous bits.\n    Copy &= ~0UL << BitPos;\n\n    if (Copy != 0)\n      return WordPos * BITWORD_SIZE + countTrailingZeros(Copy);\n\n    // Check subsequent words.\n    for (unsigned i = WordPos+1; i < BITWORDS_PER_ELEMENT; ++i)\n      if (Bits[i] != 0)\n        return i * BITWORD_SIZE + countTrailingZeros(Bits[i]);\n    return -1;\n  }\n\n  // Union this element with RHS and return true if this one changed.\n  bool unionWith(const SparseBitVectorElement &RHS) {\n    bool changed = false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      BitWord old = changed ? 0 : Bits[i];\n\n      Bits[i] |= RHS.Bits[i];\n      if (!changed && old != Bits[i])\n        changed = true;\n    }\n    return changed;\n  }\n\n  // Return true if we have any bits in common with RHS\n  bool intersects(const SparseBitVectorElement &RHS) const {\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      if (RHS.Bits[i] & Bits[i])\n        return true;\n    }\n    return false;\n  }\n\n  // Intersect this Element with RHS and return true if this one changed.\n  // BecameZero is set to true if this element became all-zero bits.\n  bool intersectWith(const SparseBitVectorElement &RHS,\n                     bool &BecameZero) {\n    bool changed = false;\n    bool allzero = true;\n\n    BecameZero = false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      BitWord old = changed ? 0 : Bits[i];\n\n      Bits[i] &= RHS.Bits[i];\n      if (Bits[i] != 0)\n        allzero = false;\n\n      if (!changed && old != Bits[i])\n        changed = true;\n    }\n    BecameZero = allzero;\n    return changed;\n  }\n\n  // Intersect this Element with the complement of RHS and return true if this\n  // one changed.  BecameZero is set to true if this element became all-zero\n  // bits.\n  bool intersectWithComplement(const SparseBitVectorElement &RHS,\n                               bool &BecameZero) {\n    bool changed = false;\n    bool allzero = true;\n\n    BecameZero = false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      BitWord old = changed ? 0 : Bits[i];\n\n      Bits[i] &= ~RHS.Bits[i];\n      if (Bits[i] != 0)\n        allzero = false;\n\n      if (!changed && old != Bits[i])\n        changed = true;\n    }\n    BecameZero = allzero;\n    return changed;\n  }\n\n  // Three argument version of intersectWithComplement that intersects\n  // RHS1 & ~RHS2 into this element\n  void intersectWithComplement(const SparseBitVectorElement &RHS1,\n                               const SparseBitVectorElement &RHS2,\n                               bool &BecameZero) {\n    bool allzero = true;\n\n    BecameZero = false;\n    for (unsigned i = 0; i < BITWORDS_PER_ELEMENT; ++i) {\n      Bits[i] = RHS1.Bits[i] & ~RHS2.Bits[i];\n      if (Bits[i] != 0)\n        allzero = false;\n    }\n    BecameZero = allzero;\n  }\n};\n\ntemplate <unsigned ElementSize = 128>\nclass SparseBitVector {\n  using ElementList = std::list<SparseBitVectorElement<ElementSize>>;\n  using ElementListIter = typename ElementList::iterator;\n  using ElementListConstIter = typename ElementList::const_iterator;\n  enum {\n    BITWORD_SIZE = SparseBitVectorElement<ElementSize>::BITWORD_SIZE\n  };\n\n  ElementList Elements;\n  // Pointer to our current Element. This has no visible effect on the external\n  // state of a SparseBitVector, it's just used to improve performance in the\n  // common case of testing/modifying bits with similar indices.\n  mutable ElementListIter CurrElementIter;\n\n  // This is like std::lower_bound, except we do linear searching from the\n  // current position.\n  ElementListIter FindLowerBoundImpl(unsigned ElementIndex) const {\n\n    // We cache a non-const iterator so we're forced to resort to const_cast to\n    // get the begin/end in the case where 'this' is const. To avoid duplication\n    // of code with the only difference being whether the const cast is present\n    // 'this' is always const in this particular function and we sort out the\n    // difference in FindLowerBound and FindLowerBoundConst.\n    ElementListIter Begin =\n        const_cast<SparseBitVector<ElementSize> *>(this)->Elements.begin();\n    ElementListIter End =\n        const_cast<SparseBitVector<ElementSize> *>(this)->Elements.end();\n\n    if (Elements.empty()) {\n      CurrElementIter = Begin;\n      return CurrElementIter;\n    }\n\n    // Make sure our current iterator is valid.\n    if (CurrElementIter == End)\n      --CurrElementIter;\n\n    // Search from our current iterator, either backwards or forwards,\n    // depending on what element we are looking for.\n    ElementListIter ElementIter = CurrElementIter;\n    if (CurrElementIter->index() == ElementIndex) {\n      return ElementIter;\n    } else if (CurrElementIter->index() > ElementIndex) {\n      while (ElementIter != Begin\n             && ElementIter->index() > ElementIndex)\n        --ElementIter;\n    } else {\n      while (ElementIter != End &&\n             ElementIter->index() < ElementIndex)\n        ++ElementIter;\n    }\n    CurrElementIter = ElementIter;\n    return ElementIter;\n  }\n  ElementListConstIter FindLowerBoundConst(unsigned ElementIndex) const {\n    return FindLowerBoundImpl(ElementIndex);\n  }\n  ElementListIter FindLowerBound(unsigned ElementIndex) {\n    return FindLowerBoundImpl(ElementIndex);\n  }\n\n  // Iterator to walk set bits in the bitmap.  This iterator is a lot uglier\n  // than it would be, in order to be efficient.\n  class SparseBitVectorIterator {\n  private:\n    bool AtEnd;\n\n    const SparseBitVector<ElementSize> *BitVector = nullptr;\n\n    // Current element inside of bitmap.\n    ElementListConstIter Iter;\n\n    // Current bit number inside of our bitmap.\n    unsigned BitNumber;\n\n    // Current word number inside of our element.\n    unsigned WordNumber;\n\n    // Current bits from the element.\n    typename SparseBitVectorElement<ElementSize>::BitWord Bits;\n\n    // Move our iterator to the first non-zero bit in the bitmap.\n    void AdvanceToFirstNonZero() {\n      if (AtEnd)\n        return;\n      if (BitVector->Elements.empty()) {\n        AtEnd = true;\n        return;\n      }\n      Iter = BitVector->Elements.begin();\n      BitNumber = Iter->index() * ElementSize;\n      unsigned BitPos = Iter->find_first();\n      BitNumber += BitPos;\n      WordNumber = (BitNumber % ElementSize) / BITWORD_SIZE;\n      Bits = Iter->word(WordNumber);\n      Bits >>= BitPos % BITWORD_SIZE;\n    }\n\n    // Move our iterator to the next non-zero bit.\n    void AdvanceToNextNonZero() {\n      if (AtEnd)\n        return;\n\n      while (Bits && !(Bits & 1)) {\n        Bits >>= 1;\n        BitNumber += 1;\n      }\n\n      // See if we ran out of Bits in this word.\n      if (!Bits) {\n        int NextSetBitNumber = Iter->find_next(BitNumber % ElementSize) ;\n        // If we ran out of set bits in this element, move to next element.\n        if (NextSetBitNumber == -1 || (BitNumber % ElementSize == 0)) {\n          ++Iter;\n          WordNumber = 0;\n\n          // We may run out of elements in the bitmap.\n          if (Iter == BitVector->Elements.end()) {\n            AtEnd = true;\n            return;\n          }\n          // Set up for next non-zero word in bitmap.\n          BitNumber = Iter->index() * ElementSize;\n          NextSetBitNumber = Iter->find_first();\n          BitNumber += NextSetBitNumber;\n          WordNumber = (BitNumber % ElementSize) / BITWORD_SIZE;\n          Bits = Iter->word(WordNumber);\n          Bits >>= NextSetBitNumber % BITWORD_SIZE;\n        } else {\n          WordNumber = (NextSetBitNumber % ElementSize) / BITWORD_SIZE;\n          Bits = Iter->word(WordNumber);\n          Bits >>= NextSetBitNumber % BITWORD_SIZE;\n          BitNumber = Iter->index() * ElementSize;\n          BitNumber += NextSetBitNumber;\n        }\n      }\n    }\n\n  public:\n    SparseBitVectorIterator() = default;\n\n    SparseBitVectorIterator(const SparseBitVector<ElementSize> *RHS,\n                            bool end = false):BitVector(RHS) {\n      Iter = BitVector->Elements.begin();\n      BitNumber = 0;\n      Bits = 0;\n      WordNumber = ~0;\n      AtEnd = end;\n      AdvanceToFirstNonZero();\n    }\n\n    // Preincrement.\n    inline SparseBitVectorIterator& operator++() {\n      ++BitNumber;\n      Bits >>= 1;\n      AdvanceToNextNonZero();\n      return *this;\n    }\n\n    // Postincrement.\n    inline SparseBitVectorIterator operator++(int) {\n      SparseBitVectorIterator tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    // Return the current set bit number.\n    unsigned operator*() const {\n      return BitNumber;\n    }\n\n    bool operator==(const SparseBitVectorIterator &RHS) const {\n      // If they are both at the end, ignore the rest of the fields.\n      if (AtEnd && RHS.AtEnd)\n        return true;\n      // Otherwise they are the same if they have the same bit number and\n      // bitmap.\n      return AtEnd == RHS.AtEnd && RHS.BitNumber == BitNumber;\n    }\n\n    bool operator!=(const SparseBitVectorIterator &RHS) const {\n      return !(*this == RHS);\n    }\n  };\n\npublic:\n  using iterator = SparseBitVectorIterator;\n\n  SparseBitVector() : Elements(), CurrElementIter(Elements.begin()) {}\n\n  SparseBitVector(const SparseBitVector &RHS)\n      : Elements(RHS.Elements), CurrElementIter(Elements.begin()) {}\n  SparseBitVector(SparseBitVector &&RHS)\n      : Elements(std::move(RHS.Elements)), CurrElementIter(Elements.begin()) {}\n\n  // Clear.\n  void clear() {\n    Elements.clear();\n  }\n\n  // Assignment\n  SparseBitVector& operator=(const SparseBitVector& RHS) {\n    if (this == &RHS)\n      return *this;\n\n    Elements = RHS.Elements;\n    CurrElementIter = Elements.begin();\n    return *this;\n  }\n  SparseBitVector &operator=(SparseBitVector &&RHS) {\n    Elements = std::move(RHS.Elements);\n    CurrElementIter = Elements.begin();\n    return *this;\n  }\n\n  // Test, Reset, and Set a bit in the bitmap.\n  bool test(unsigned Idx) const {\n    if (Elements.empty())\n      return false;\n\n    unsigned ElementIndex = Idx / ElementSize;\n    ElementListConstIter ElementIter = FindLowerBoundConst(ElementIndex);\n\n    // If we can't find an element that is supposed to contain this bit, there\n    // is nothing more to do.\n    if (ElementIter == Elements.end() ||\n        ElementIter->index() != ElementIndex)\n      return false;\n    return ElementIter->test(Idx % ElementSize);\n  }\n\n  void reset(unsigned Idx) {\n    if (Elements.empty())\n      return;\n\n    unsigned ElementIndex = Idx / ElementSize;\n    ElementListIter ElementIter = FindLowerBound(ElementIndex);\n\n    // If we can't find an element that is supposed to contain this bit, there\n    // is nothing more to do.\n    if (ElementIter == Elements.end() ||\n        ElementIter->index() != ElementIndex)\n      return;\n    ElementIter->reset(Idx % ElementSize);\n\n    // When the element is zeroed out, delete it.\n    if (ElementIter->empty()) {\n      ++CurrElementIter;\n      Elements.erase(ElementIter);\n    }\n  }\n\n  void set(unsigned Idx) {\n    unsigned ElementIndex = Idx / ElementSize;\n    ElementListIter ElementIter;\n    if (Elements.empty()) {\n      ElementIter = Elements.emplace(Elements.end(), ElementIndex);\n    } else {\n      ElementIter = FindLowerBound(ElementIndex);\n\n      if (ElementIter == Elements.end() ||\n          ElementIter->index() != ElementIndex) {\n        // We may have hit the beginning of our SparseBitVector, in which case,\n        // we may need to insert right after this element, which requires moving\n        // the current iterator forward one, because insert does insert before.\n        if (ElementIter != Elements.end() &&\n            ElementIter->index() < ElementIndex)\n          ++ElementIter;\n        ElementIter = Elements.emplace(ElementIter, ElementIndex);\n      }\n    }\n    CurrElementIter = ElementIter;\n\n    ElementIter->set(Idx % ElementSize);\n  }\n\n  bool test_and_set(unsigned Idx) {\n    bool old = test(Idx);\n    if (!old) {\n      set(Idx);\n      return true;\n    }\n    return false;\n  }\n\n  bool operator!=(const SparseBitVector &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool operator==(const SparseBitVector &RHS) const {\n    ElementListConstIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    for (; Iter1 != Elements.end() && Iter2 != RHS.Elements.end();\n         ++Iter1, ++Iter2) {\n      if (*Iter1 != *Iter2)\n        return false;\n    }\n    return Iter1 == Elements.end() && Iter2 == RHS.Elements.end();\n  }\n\n  // Union our bitmap with the RHS and return true if we changed.\n  bool operator|=(const SparseBitVector &RHS) {\n    if (this == &RHS)\n      return false;\n\n    bool changed = false;\n    ElementListIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    // If RHS is empty, we are done\n    if (RHS.Elements.empty())\n      return false;\n\n    while (Iter2 != RHS.Elements.end()) {\n      if (Iter1 == Elements.end() || Iter1->index() > Iter2->index()) {\n        Elements.insert(Iter1, *Iter2);\n        ++Iter2;\n        changed = true;\n      } else if (Iter1->index() == Iter2->index()) {\n        changed |= Iter1->unionWith(*Iter2);\n        ++Iter1;\n        ++Iter2;\n      } else {\n        ++Iter1;\n      }\n    }\n    CurrElementIter = Elements.begin();\n    return changed;\n  }\n\n  // Intersect our bitmap with the RHS and return true if ours changed.\n  bool operator&=(const SparseBitVector &RHS) {\n    if (this == &RHS)\n      return false;\n\n    bool changed = false;\n    ElementListIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    // Check if both bitmaps are empty.\n    if (Elements.empty() && RHS.Elements.empty())\n      return false;\n\n    // Loop through, intersecting as we go, erasing elements when necessary.\n    while (Iter2 != RHS.Elements.end()) {\n      if (Iter1 == Elements.end()) {\n        CurrElementIter = Elements.begin();\n        return changed;\n      }\n\n      if (Iter1->index() > Iter2->index()) {\n        ++Iter2;\n      } else if (Iter1->index() == Iter2->index()) {\n        bool BecameZero;\n        changed |= Iter1->intersectWith(*Iter2, BecameZero);\n        if (BecameZero) {\n          ElementListIter IterTmp = Iter1;\n          ++Iter1;\n          Elements.erase(IterTmp);\n        } else {\n          ++Iter1;\n        }\n        ++Iter2;\n      } else {\n        ElementListIter IterTmp = Iter1;\n        ++Iter1;\n        Elements.erase(IterTmp);\n        changed = true;\n      }\n    }\n    if (Iter1 != Elements.end()) {\n      Elements.erase(Iter1, Elements.end());\n      changed = true;\n    }\n    CurrElementIter = Elements.begin();\n    return changed;\n  }\n\n  // Intersect our bitmap with the complement of the RHS and return true\n  // if ours changed.\n  bool intersectWithComplement(const SparseBitVector &RHS) {\n    if (this == &RHS) {\n      if (!empty()) {\n        clear();\n        return true;\n      }\n      return false;\n    }\n\n    bool changed = false;\n    ElementListIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    // If either our bitmap or RHS is empty, we are done\n    if (Elements.empty() || RHS.Elements.empty())\n      return false;\n\n    // Loop through, intersecting as we go, erasing elements when necessary.\n    while (Iter2 != RHS.Elements.end()) {\n      if (Iter1 == Elements.end()) {\n        CurrElementIter = Elements.begin();\n        return changed;\n      }\n\n      if (Iter1->index() > Iter2->index()) {\n        ++Iter2;\n      } else if (Iter1->index() == Iter2->index()) {\n        bool BecameZero;\n        changed |= Iter1->intersectWithComplement(*Iter2, BecameZero);\n        if (BecameZero) {\n          ElementListIter IterTmp = Iter1;\n          ++Iter1;\n          Elements.erase(IterTmp);\n        } else {\n          ++Iter1;\n        }\n        ++Iter2;\n      } else {\n        ++Iter1;\n      }\n    }\n    CurrElementIter = Elements.begin();\n    return changed;\n  }\n\n  bool intersectWithComplement(const SparseBitVector<ElementSize> *RHS) const {\n    return intersectWithComplement(*RHS);\n  }\n\n  //  Three argument version of intersectWithComplement.\n  //  Result of RHS1 & ~RHS2 is stored into this bitmap.\n  void intersectWithComplement(const SparseBitVector<ElementSize> &RHS1,\n                               const SparseBitVector<ElementSize> &RHS2)\n  {\n    if (this == &RHS1) {\n      intersectWithComplement(RHS2);\n      return;\n    } else if (this == &RHS2) {\n      SparseBitVector RHS2Copy(RHS2);\n      intersectWithComplement(RHS1, RHS2Copy);\n      return;\n    }\n\n    Elements.clear();\n    CurrElementIter = Elements.begin();\n    ElementListConstIter Iter1 = RHS1.Elements.begin();\n    ElementListConstIter Iter2 = RHS2.Elements.begin();\n\n    // If RHS1 is empty, we are done\n    // If RHS2 is empty, we still have to copy RHS1\n    if (RHS1.Elements.empty())\n      return;\n\n    // Loop through, intersecting as we go, erasing elements when necessary.\n    while (Iter2 != RHS2.Elements.end()) {\n      if (Iter1 == RHS1.Elements.end())\n        return;\n\n      if (Iter1->index() > Iter2->index()) {\n        ++Iter2;\n      } else if (Iter1->index() == Iter2->index()) {\n        bool BecameZero = false;\n        Elements.emplace_back(Iter1->index());\n        Elements.back().intersectWithComplement(*Iter1, *Iter2, BecameZero);\n        if (BecameZero)\n          Elements.pop_back();\n        ++Iter1;\n        ++Iter2;\n      } else {\n        Elements.push_back(*Iter1++);\n      }\n    }\n\n    // copy the remaining elements\n    std::copy(Iter1, RHS1.Elements.end(), std::back_inserter(Elements));\n  }\n\n  void intersectWithComplement(const SparseBitVector<ElementSize> *RHS1,\n                               const SparseBitVector<ElementSize> *RHS2) {\n    intersectWithComplement(*RHS1, *RHS2);\n  }\n\n  bool intersects(const SparseBitVector<ElementSize> *RHS) const {\n    return intersects(*RHS);\n  }\n\n  // Return true if we share any bits in common with RHS\n  bool intersects(const SparseBitVector<ElementSize> &RHS) const {\n    ElementListConstIter Iter1 = Elements.begin();\n    ElementListConstIter Iter2 = RHS.Elements.begin();\n\n    // Check if both bitmaps are empty.\n    if (Elements.empty() && RHS.Elements.empty())\n      return false;\n\n    // Loop through, intersecting stopping when we hit bits in common.\n    while (Iter2 != RHS.Elements.end()) {\n      if (Iter1 == Elements.end())\n        return false;\n\n      if (Iter1->index() > Iter2->index()) {\n        ++Iter2;\n      } else if (Iter1->index() == Iter2->index()) {\n        if (Iter1->intersects(*Iter2))\n          return true;\n        ++Iter1;\n        ++Iter2;\n      } else {\n        ++Iter1;\n      }\n    }\n    return false;\n  }\n\n  // Return true iff all bits set in this SparseBitVector are\n  // also set in RHS.\n  bool contains(const SparseBitVector<ElementSize> &RHS) const {\n    SparseBitVector<ElementSize> Result(*this);\n    Result &= RHS;\n    return (Result == RHS);\n  }\n\n  // Return the first set bit in the bitmap.  Return -1 if no bits are set.\n  int find_first() const {\n    if (Elements.empty())\n      return -1;\n    const SparseBitVectorElement<ElementSize> &First = *(Elements.begin());\n    return (First.index() * ElementSize) + First.find_first();\n  }\n\n  // Return the last set bit in the bitmap.  Return -1 if no bits are set.\n  int find_last() const {\n    if (Elements.empty())\n      return -1;\n    const SparseBitVectorElement<ElementSize> &Last = *(Elements.rbegin());\n    return (Last.index() * ElementSize) + Last.find_last();\n  }\n\n  // Return true if the SparseBitVector is empty\n  bool empty() const {\n    return Elements.empty();\n  }\n\n  unsigned count() const {\n    unsigned BitCount = 0;\n    for (ElementListConstIter Iter = Elements.begin();\n         Iter != Elements.end();\n         ++Iter)\n      BitCount += Iter->count();\n\n    return BitCount;\n  }\n\n  iterator begin() const {\n    return iterator(this);\n  }\n\n  iterator end() const {\n    return iterator(this, true);\n  }\n};\n\n// Convenience functions to allow Or and And without dereferencing in the user\n// code.\n\ntemplate <unsigned ElementSize>\ninline bool operator |=(SparseBitVector<ElementSize> &LHS,\n                        const SparseBitVector<ElementSize> *RHS) {\n  return LHS |= *RHS;\n}\n\ntemplate <unsigned ElementSize>\ninline bool operator |=(SparseBitVector<ElementSize> *LHS,\n                        const SparseBitVector<ElementSize> &RHS) {\n  return LHS->operator|=(RHS);\n}\n\ntemplate <unsigned ElementSize>\ninline bool operator &=(SparseBitVector<ElementSize> *LHS,\n                        const SparseBitVector<ElementSize> &RHS) {\n  return LHS->operator&=(RHS);\n}\n\ntemplate <unsigned ElementSize>\ninline bool operator &=(SparseBitVector<ElementSize> &LHS,\n                        const SparseBitVector<ElementSize> *RHS) {\n  return LHS &= *RHS;\n}\n\n// Convenience functions for infix union, intersection, difference operators.\n\ntemplate <unsigned ElementSize>\ninline SparseBitVector<ElementSize>\noperator|(const SparseBitVector<ElementSize> &LHS,\n          const SparseBitVector<ElementSize> &RHS) {\n  SparseBitVector<ElementSize> Result(LHS);\n  Result |= RHS;\n  return Result;\n}\n\ntemplate <unsigned ElementSize>\ninline SparseBitVector<ElementSize>\noperator&(const SparseBitVector<ElementSize> &LHS,\n          const SparseBitVector<ElementSize> &RHS) {\n  SparseBitVector<ElementSize> Result(LHS);\n  Result &= RHS;\n  return Result;\n}\n\ntemplate <unsigned ElementSize>\ninline SparseBitVector<ElementSize>\noperator-(const SparseBitVector<ElementSize> &LHS,\n          const SparseBitVector<ElementSize> &RHS) {\n  SparseBitVector<ElementSize> Result;\n  Result.intersectWithComplement(LHS, RHS);\n  return Result;\n}\n\n// Dump a SparseBitVector to a stream\ntemplate <unsigned ElementSize>\nvoid dump(const SparseBitVector<ElementSize> &LHS, raw_ostream &out) {\n  out << \"[\";\n\n  typename SparseBitVector<ElementSize>::iterator bi = LHS.begin(),\n    be = LHS.end();\n  if (bi != be) {\n    out << *bi;\n    for (++bi; bi != be; ++bi) {\n      out << \" \" << *bi;\n    }\n  }\n  out << \"]\\n\";\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_SPARSEBITVECTOR_H\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist.h", "content": "//==-- llvm/ADT/ilist.h - Intrusive Linked List Template ---------*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines classes to implement an intrusive doubly linked list class\n// (i.e. each node of the list must contain a next and previous field for the\n// list.\n//\n// The ilist class itself should be a plug in replacement for list.  This list\n// replacement does not provide a constant time size() method, so be careful to\n// use empty() when you really want to know if it's empty.\n//\n// The ilist class is implemented as a circular list.  The list itself contains\n// a sentinel node, whose Next points at begin() and whose Prev points at\n// rbegin().  The sentinel node itself serves as end() and rend().\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ILIST_H\n#define LLVM_ADT_ILIST_H\n\n#include \"llvm/ADT/simple_ilist.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n\nnamespace llvm {\n\n/// Use delete by default for iplist and ilist.\n///\n/// Specialize this to get different behaviour for ownership-related API.  (If\n/// you really want ownership semantics, consider using std::list or building\n/// something like \\a BumpPtrList.)\n///\n/// \\see ilist_noalloc_traits\ntemplate <typename NodeTy> struct ilist_alloc_traits {\n  static void deleteNode(NodeTy *V) { delete V; }\n};\n\n/// Custom traits to do nothing on deletion.\n///\n/// Specialize ilist_alloc_traits to inherit from this to disable the\n/// non-intrusive deletion in iplist (which implies ownership).\n///\n/// If you want purely intrusive semantics with no callbacks, consider using \\a\n/// simple_ilist instead.\n///\n/// \\code\n/// template <>\n/// struct ilist_alloc_traits<MyType> : ilist_noalloc_traits<MyType> {};\n/// \\endcode\ntemplate <typename NodeTy> struct ilist_noalloc_traits {\n  static void deleteNode(NodeTy *V) {}\n};\n\n/// Callbacks do nothing by default in iplist and ilist.\n///\n/// Specialize this for to use callbacks for when nodes change their list\n/// membership.\ntemplate <typename NodeTy> struct ilist_callback_traits {\n  void addNodeToList(NodeTy *) {}\n  void removeNodeFromList(NodeTy *) {}\n\n  /// Callback before transferring nodes to this list. The nodes may already be\n  /// in this same list.\n  template <class Iterator>\n  void transferNodesFromList(ilist_callback_traits &OldList, Iterator /*first*/,\n                             Iterator /*last*/) {\n    (void)OldList;\n  }\n};\n\n/// A fragment for template traits for intrusive list that provides default\n/// node related operations.\n///\n/// TODO: Remove this layer of indirection.  It's not necessary.\ntemplate <typename NodeTy>\nstruct ilist_node_traits : ilist_alloc_traits<NodeTy>,\n                           ilist_callback_traits<NodeTy> {};\n\n/// Template traits for intrusive list.\n///\n/// Customize callbacks and allocation semantics.\ntemplate <typename NodeTy>\nstruct ilist_traits : public ilist_node_traits<NodeTy> {};\n\n/// Const traits should never be instantiated.\ntemplate <typename Ty> struct ilist_traits<const Ty> {};\n\nnamespace ilist_detail {\n\ntemplate <class T> T &make();\n\n/// Type trait to check for a traits class that has a getNext member (as a\n/// canary for any of the ilist_nextprev_traits API).\ntemplate <class TraitsT, class NodeT> struct HasGetNext {\n  typedef char Yes[1];\n  typedef char No[2];\n  template <size_t N> struct SFINAE {};\n\n  template <class U>\n  static Yes &test(U *I, decltype(I->getNext(&make<NodeT>())) * = 0);\n  template <class> static No &test(...);\n\npublic:\n  static const bool value = sizeof(test<TraitsT>(nullptr)) == sizeof(Yes);\n};\n\n/// Type trait to check for a traits class that has a createSentinel member (as\n/// a canary for any of the ilist_sentinel_traits API).\ntemplate <class TraitsT> struct HasCreateSentinel {\n  typedef char Yes[1];\n  typedef char No[2];\n\n  template <class U>\n  static Yes &test(U *I, decltype(I->createSentinel()) * = 0);\n  template <class> static No &test(...);\n\npublic:\n  static const bool value = sizeof(test<TraitsT>(nullptr)) == sizeof(Yes);\n};\n\n/// Type trait to check for a traits class that has a createNode member.\n/// Allocation should be managed in a wrapper class, instead of in\n/// ilist_traits.\ntemplate <class TraitsT, class NodeT> struct HasCreateNode {\n  typedef char Yes[1];\n  typedef char No[2];\n  template <size_t N> struct SFINAE {};\n\n  template <class U>\n  static Yes &test(U *I, decltype(I->createNode(make<NodeT>())) * = 0);\n  template <class> static No &test(...);\n\npublic:\n  static const bool value = sizeof(test<TraitsT>(nullptr)) == sizeof(Yes);\n};\n\ntemplate <class TraitsT, class NodeT> struct HasObsoleteCustomization {\n  static const bool value = HasGetNext<TraitsT, NodeT>::value ||\n                            HasCreateSentinel<TraitsT>::value ||\n                            HasCreateNode<TraitsT, NodeT>::value;\n};\n\n} // end namespace ilist_detail\n\n//===----------------------------------------------------------------------===//\n//\n/// A wrapper around an intrusive list with callbacks and non-intrusive\n/// ownership.\n///\n/// This wraps a purely intrusive list (like simple_ilist) with a configurable\n/// traits class.  The traits can implement callbacks and customize the\n/// ownership semantics.\n///\n/// This is a subset of ilist functionality that can safely be used on nodes of\n/// polymorphic types, i.e. a heterogeneous list with a common base class that\n/// holds the next/prev pointers.  The only state of the list itself is an\n/// ilist_sentinel, which holds pointers to the first and last nodes in the\n/// list.\ntemplate <class IntrusiveListT, class TraitsT>\nclass iplist_impl : public TraitsT, IntrusiveListT {\n  typedef IntrusiveListT base_list_type;\n\npublic:\n  typedef typename base_list_type::pointer pointer;\n  typedef typename base_list_type::const_pointer const_pointer;\n  typedef typename base_list_type::reference reference;\n  typedef typename base_list_type::const_reference const_reference;\n  typedef typename base_list_type::value_type value_type;\n  typedef typename base_list_type::size_type size_type;\n  typedef typename base_list_type::difference_type difference_type;\n  typedef typename base_list_type::iterator iterator;\n  typedef typename base_list_type::const_iterator const_iterator;\n  typedef typename base_list_type::reverse_iterator reverse_iterator;\n  typedef\n      typename base_list_type::const_reverse_iterator const_reverse_iterator;\n\nprivate:\n  // TODO: Drop this assertion and the transitive type traits anytime after\n  // v4.0 is branched (i.e,. keep them for one release to help out-of-tree code\n  // update).\n  static_assert(\n      !ilist_detail::HasObsoleteCustomization<TraitsT, value_type>::value,\n      \"ilist customization points have changed!\");\n\n  static bool op_less(const_reference L, const_reference R) { return L < R; }\n  static bool op_equal(const_reference L, const_reference R) { return L == R; }\n\npublic:\n  iplist_impl() = default;\n\n  iplist_impl(const iplist_impl &) = delete;\n  iplist_impl &operator=(const iplist_impl &) = delete;\n\n  iplist_impl(iplist_impl &&X)\n      : TraitsT(std::move(static_cast<TraitsT &>(X))),\n        IntrusiveListT(std::move(static_cast<IntrusiveListT &>(X))) {}\n  iplist_impl &operator=(iplist_impl &&X) {\n    *static_cast<TraitsT *>(this) = std::move(static_cast<TraitsT &>(X));\n    *static_cast<IntrusiveListT *>(this) =\n        std::move(static_cast<IntrusiveListT &>(X));\n    return *this;\n  }\n\n  ~iplist_impl() { clear(); }\n\n  // Miscellaneous inspection routines.\n  size_type max_size() const { return size_type(-1); }\n\n  using base_list_type::begin;\n  using base_list_type::end;\n  using base_list_type::rbegin;\n  using base_list_type::rend;\n  using base_list_type::empty;\n  using base_list_type::front;\n  using base_list_type::back;\n\n  void swap(iplist_impl &RHS) {\n    assert(0 && \"Swap does not use list traits callback correctly yet!\");\n    base_list_type::swap(RHS);\n  }\n\n  iterator insert(iterator where, pointer New) {\n    this->addNodeToList(New); // Notify traits that we added a node...\n    return base_list_type::insert(where, *New);\n  }\n\n  iterator insert(iterator where, const_reference New) {\n    return this->insert(where, new value_type(New));\n  }\n\n  iterator insertAfter(iterator where, pointer New) {\n    if (empty())\n      return insert(begin(), New);\n    else\n      return insert(++where, New);\n  }\n\n  /// Clone another list.\n  template <class Cloner> void cloneFrom(const iplist_impl &L2, Cloner clone) {\n    clear();\n    for (const_reference V : L2)\n      push_back(clone(V));\n  }\n\n  pointer remove(iterator &IT) {\n    pointer Node = &*IT++;\n    this->removeNodeFromList(Node); // Notify traits that we removed a node...\n    base_list_type::remove(*Node);\n    return Node;\n  }\n\n  pointer remove(const iterator &IT) {\n    iterator MutIt = IT;\n    return remove(MutIt);\n  }\n\n  pointer remove(pointer IT) { return remove(iterator(IT)); }\n  pointer remove(reference IT) { return remove(iterator(IT)); }\n\n  // erase - remove a node from the controlled sequence... and delete it.\n  iterator erase(iterator where) {\n    this->deleteNode(remove(where));\n    return where;\n  }\n\n  iterator erase(pointer IT) { return erase(iterator(IT)); }\n  iterator erase(reference IT) { return erase(iterator(IT)); }\n\n  /// Remove all nodes from the list like clear(), but do not call\n  /// removeNodeFromList() or deleteNode().\n  ///\n  /// This should only be used immediately before freeing nodes in bulk to\n  /// avoid traversing the list and bringing all the nodes into cache.\n  void clearAndLeakNodesUnsafely() { base_list_type::clear(); }\n\nprivate:\n  // transfer - The heart of the splice function.  Move linked list nodes from\n  // [first, last) into position.\n  //\n  void transfer(iterator position, iplist_impl &L2, iterator first, iterator last) {\n    if (position == last)\n      return;\n\n    // Notify traits we moved the nodes...\n    this->transferNodesFromList(L2, first, last);\n\n    base_list_type::splice(position, L2, first, last);\n  }\n\npublic:\n  //===----------------------------------------------------------------------===\n  // Functionality derived from other functions defined above...\n  //\n\n  using base_list_type::size;\n\n  iterator erase(iterator first, iterator last) {\n    while (first != last)\n      first = erase(first);\n    return last;\n  }\n\n  void clear() { erase(begin(), end()); }\n\n  // Front and back inserters...\n  void push_front(pointer val) { insert(begin(), val); }\n  void push_back(pointer val) { insert(end(), val); }\n  void pop_front() {\n    assert(!empty() && \"pop_front() on empty list!\");\n    erase(begin());\n  }\n  void pop_back() {\n    assert(!empty() && \"pop_back() on empty list!\");\n    iterator t = end(); erase(--t);\n  }\n\n  // Special forms of insert...\n  template<class InIt> void insert(iterator where, InIt first, InIt last) {\n    for (; first != last; ++first) insert(where, *first);\n  }\n\n  // Splice members - defined in terms of transfer...\n  void splice(iterator where, iplist_impl &L2) {\n    if (!L2.empty())\n      transfer(where, L2, L2.begin(), L2.end());\n  }\n  void splice(iterator where, iplist_impl &L2, iterator first) {\n    iterator last = first; ++last;\n    if (where == first || where == last) return; // No change\n    transfer(where, L2, first, last);\n  }\n  void splice(iterator where, iplist_impl &L2, iterator first, iterator last) {\n    if (first != last) transfer(where, L2, first, last);\n  }\n  void splice(iterator where, iplist_impl &L2, reference N) {\n    splice(where, L2, iterator(N));\n  }\n  void splice(iterator where, iplist_impl &L2, pointer N) {\n    splice(where, L2, iterator(N));\n  }\n\n  template <class Compare>\n  void merge(iplist_impl &Right, Compare comp) {\n    if (this == &Right)\n      return;\n    this->transferNodesFromList(Right, Right.begin(), Right.end());\n    base_list_type::merge(Right, comp);\n  }\n  void merge(iplist_impl &Right) { return merge(Right, op_less); }\n\n  using base_list_type::sort;\n\n  /// Get the previous node, or \\c nullptr for the list head.\n  pointer getPrevNode(reference N) const {\n    auto I = N.getIterator();\n    if (I == begin())\n      return nullptr;\n    return &*std::prev(I);\n  }\n  /// Get the previous node, or \\c nullptr for the list head.\n  const_pointer getPrevNode(const_reference N) const {\n    return getPrevNode(const_cast<reference >(N));\n  }\n\n  /// Get the next node, or \\c nullptr for the list tail.\n  pointer getNextNode(reference N) const {\n    auto Next = std::next(N.getIterator());\n    if (Next == end())\n      return nullptr;\n    return &*Next;\n  }\n  /// Get the next node, or \\c nullptr for the list tail.\n  const_pointer getNextNode(const_reference N) const {\n    return getNextNode(const_cast<reference >(N));\n  }\n};\n\n/// An intrusive list with ownership and callbacks specified/controlled by\n/// ilist_traits, only with API safe for polymorphic types.\n///\n/// The \\p Options parameters are the same as those for \\a simple_ilist.  See\n/// there for a description of what's available.\ntemplate <class T, class... Options>\nclass iplist\n    : public iplist_impl<simple_ilist<T, Options...>, ilist_traits<T>> {\n  using iplist_impl_type = typename iplist::iplist_impl;\n\npublic:\n  iplist() = default;\n\n  iplist(const iplist &X) = delete;\n  iplist &operator=(const iplist &X) = delete;\n\n  iplist(iplist &&X) : iplist_impl_type(std::move(X)) {}\n  iplist &operator=(iplist &&X) {\n    *static_cast<iplist_impl_type *>(this) = std::move(X);\n    return *this;\n  }\n};\n\ntemplate <class T, class... Options> using ilist = iplist<T, Options...>;\n\n} // end namespace llvm\n\nnamespace std {\n\n  // Ensure that swap uses the fast list swap...\n  template<class Ty>\n  void swap(llvm::iplist<Ty> &Left, llvm::iplist<Ty> &Right) {\n    Left.swap(Right);\n  }\n\n} // end namespace std\n\n#endif // LLVM_ADT_ILIST_H\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/simple_ilist.h", "content": "//===- llvm/ADT/simple_ilist.h - Simple Intrusive List ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SIMPLE_ILIST_H\n#define LLVM_ADT_SIMPLE_ILIST_H\n\n#include \"llvm/ADT/ilist_base.h\"\n#include \"llvm/ADT/ilist_iterator.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/ilist_node_options.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <functional>\n#include <iterator>\n#include <utility>\n\nnamespace llvm {\n\n/// A simple intrusive list implementation.\n///\n/// This is a simple intrusive list for a \\c T that inherits from \\c\n/// ilist_node<T>.  The list never takes ownership of anything inserted in it.\n///\n/// Unlike \\a iplist<T> and \\a ilist<T>, \\a simple_ilist<T> never deletes\n/// values, and has no callback traits.\n///\n/// The API for adding nodes include \\a push_front(), \\a push_back(), and \\a\n/// insert().  These all take values by reference (not by pointer), except for\n/// the range version of \\a insert().\n///\n/// There are three sets of API for discarding nodes from the list: \\a\n/// remove(), which takes a reference to the node to remove, \\a erase(), which\n/// takes an iterator or iterator range and returns the next one, and \\a\n/// clear(), which empties out the container.  All three are constant time\n/// operations.  None of these deletes any nodes; in particular, if there is a\n/// single node in the list, then these have identical semantics:\n/// \\li \\c L.remove(L.front());\n/// \\li \\c L.erase(L.begin());\n/// \\li \\c L.clear();\n///\n/// As a convenience for callers, there are parallel APIs that take a \\c\n/// Disposer (such as \\c std::default_delete<T>): \\a removeAndDispose(), \\a\n/// eraseAndDispose(), and \\a clearAndDispose().  These have different names\n/// because the extra semantic is otherwise non-obvious.  They are equivalent\n/// to calling \\a std::for_each() on the range to be discarded.\n///\n/// The currently available \\p Options customize the nodes in the list.  The\n/// same options must be specified in the \\a ilist_node instantiation for\n/// compatibility (although the order is irrelevant).\n/// \\li Use \\a ilist_tag to designate which ilist_node for a given \\p T this\n/// list should use.  This is useful if a type \\p T is part of multiple,\n/// independent lists simultaneously.\n/// \\li Use \\a ilist_sentinel_tracking to always (or never) track whether a\n/// node is a sentinel.  Specifying \\c true enables the \\a\n/// ilist_node::isSentinel() API.  Unlike \\a ilist_node::isKnownSentinel(),\n/// which is only appropriate for assertions, \\a ilist_node::isSentinel() is\n/// appropriate for real logic.\n///\n/// Here are examples of \\p Options usage:\n/// \\li \\c simple_ilist<T> gives the defaults.  \\li \\c\n/// simple_ilist<T,ilist_sentinel_tracking<true>> enables the \\a\n/// ilist_node::isSentinel() API.\n/// \\li \\c simple_ilist<T,ilist_tag<A>,ilist_sentinel_tracking<false>>\n/// specifies a tag of A and that tracking should be off (even when\n/// LLVM_ENABLE_ABI_BREAKING_CHECKS are enabled).\n/// \\li \\c simple_ilist<T,ilist_sentinel_tracking<false>,ilist_tag<A>> is\n/// equivalent to the last.\n///\n/// See \\a is_valid_option for steps on adding a new option.\ntemplate <typename T, class... Options>\nclass simple_ilist\n    : ilist_detail::compute_node_options<T, Options...>::type::list_base_type,\n      ilist_detail::SpecificNodeAccess<\n          typename ilist_detail::compute_node_options<T, Options...>::type> {\n  static_assert(ilist_detail::check_options<Options...>::value,\n                \"Unrecognized node option!\");\n  using OptionsT =\n      typename ilist_detail::compute_node_options<T, Options...>::type;\n  using list_base_type = typename OptionsT::list_base_type;\n  ilist_sentinel<OptionsT> Sentinel;\n\npublic:\n  using value_type = typename OptionsT::value_type;\n  using pointer = typename OptionsT::pointer;\n  using reference = typename OptionsT::reference;\n  using const_pointer = typename OptionsT::const_pointer;\n  using const_reference = typename OptionsT::const_reference;\n  using iterator = ilist_iterator<OptionsT, false, false>;\n  using const_iterator = ilist_iterator<OptionsT, false, true>;\n  using reverse_iterator = ilist_iterator<OptionsT, true, false>;\n  using const_reverse_iterator = ilist_iterator<OptionsT, true, true>;\n  using size_type = size_t;\n  using difference_type = ptrdiff_t;\n\n  simple_ilist() = default;\n  ~simple_ilist() = default;\n\n  // No copy constructors.\n  simple_ilist(const simple_ilist &) = delete;\n  simple_ilist &operator=(const simple_ilist &) = delete;\n\n  // Move constructors.\n  simple_ilist(simple_ilist &&X) { splice(end(), X); }\n  simple_ilist &operator=(simple_ilist &&X) {\n    clear();\n    splice(end(), X);\n    return *this;\n  }\n\n  iterator begin() { return ++iterator(Sentinel); }\n  const_iterator begin() const { return ++const_iterator(Sentinel); }\n  iterator end() { return iterator(Sentinel); }\n  const_iterator end() const { return const_iterator(Sentinel); }\n  reverse_iterator rbegin() { return ++reverse_iterator(Sentinel); }\n  const_reverse_iterator rbegin() const {\n    return ++const_reverse_iterator(Sentinel);\n  }\n  reverse_iterator rend() { return reverse_iterator(Sentinel); }\n  const_reverse_iterator rend() const {\n    return const_reverse_iterator(Sentinel);\n  }\n\n  /// Check if the list is empty in constant time.\n  LLVM_NODISCARD bool empty() const { return Sentinel.empty(); }\n\n  /// Calculate the size of the list in linear time.\n  LLVM_NODISCARD size_type size() const {\n    return std::distance(begin(), end());\n  }\n\n  reference front() { return *begin(); }\n  const_reference front() const { return *begin(); }\n  reference back() { return *rbegin(); }\n  const_reference back() const { return *rbegin(); }\n\n  /// Insert a node at the front; never copies.\n  void push_front(reference Node) { insert(begin(), Node); }\n\n  /// Insert a node at the back; never copies.\n  void push_back(reference Node) { insert(end(), Node); }\n\n  /// Remove the node at the front; never deletes.\n  void pop_front() { erase(begin()); }\n\n  /// Remove the node at the back; never deletes.\n  void pop_back() { erase(--end()); }\n\n  /// Swap with another list in place using std::swap.\n  void swap(simple_ilist &X) { std::swap(*this, X); }\n\n  /// Insert a node by reference; never copies.\n  iterator insert(iterator I, reference Node) {\n    list_base_type::insertBefore(*I.getNodePtr(), *this->getNodePtr(&Node));\n    return iterator(&Node);\n  }\n\n  /// Insert a range of nodes; never copies.\n  template <class Iterator>\n  void insert(iterator I, Iterator First, Iterator Last) {\n    for (; First != Last; ++First)\n      insert(I, *First);\n  }\n\n  /// Clone another list.\n  template <class Cloner, class Disposer>\n  void cloneFrom(const simple_ilist &L2, Cloner clone, Disposer dispose) {\n    clearAndDispose(dispose);\n    for (const_reference V : L2)\n      push_back(*clone(V));\n  }\n\n  /// Remove a node by reference; never deletes.\n  ///\n  /// \\see \\a erase() for removing by iterator.\n  /// \\see \\a removeAndDispose() if the node should be deleted.\n  void remove(reference N) { list_base_type::remove(*this->getNodePtr(&N)); }\n\n  /// Remove a node by reference and dispose of it.\n  template <class Disposer>\n  void removeAndDispose(reference N, Disposer dispose) {\n    remove(N);\n    dispose(&N);\n  }\n\n  /// Remove a node by iterator; never deletes.\n  ///\n  /// \\see \\a remove() for removing by reference.\n  /// \\see \\a eraseAndDispose() it the node should be deleted.\n  iterator erase(iterator I) {\n    assert(I != end() && \"Cannot remove end of list!\");\n    remove(*I++);\n    return I;\n  }\n\n  /// Remove a range of nodes; never deletes.\n  ///\n  /// \\see \\a eraseAndDispose() if the nodes should be deleted.\n  iterator erase(iterator First, iterator Last) {\n    list_base_type::removeRange(*First.getNodePtr(), *Last.getNodePtr());\n    return Last;\n  }\n\n  /// Remove a node by iterator and dispose of it.\n  template <class Disposer>\n  iterator eraseAndDispose(iterator I, Disposer dispose) {\n    auto Next = std::next(I);\n    erase(I);\n    dispose(&*I);\n    return Next;\n  }\n\n  /// Remove a range of nodes and dispose of them.\n  template <class Disposer>\n  iterator eraseAndDispose(iterator First, iterator Last, Disposer dispose) {\n    while (First != Last)\n      First = eraseAndDispose(First, dispose);\n    return Last;\n  }\n\n  /// Clear the list; never deletes.\n  ///\n  /// \\see \\a clearAndDispose() if the nodes should be deleted.\n  void clear() { Sentinel.reset(); }\n\n  /// Clear the list and dispose of the nodes.\n  template <class Disposer> void clearAndDispose(Disposer dispose) {\n    eraseAndDispose(begin(), end(), dispose);\n  }\n\n  /// Splice in another list.\n  void splice(iterator I, simple_ilist &L2) {\n    splice(I, L2, L2.begin(), L2.end());\n  }\n\n  /// Splice in a node from another list.\n  void splice(iterator I, simple_ilist &L2, iterator Node) {\n    splice(I, L2, Node, std::next(Node));\n  }\n\n  /// Splice in a range of nodes from another list.\n  void splice(iterator I, simple_ilist &, iterator First, iterator Last) {\n    list_base_type::transferBefore(*I.getNodePtr(), *First.getNodePtr(),\n                                   *Last.getNodePtr());\n  }\n\n  /// Merge in another list.\n  ///\n  /// \\pre \\c this and \\p RHS are sorted.\n  ///@{\n  void merge(simple_ilist &RHS) { merge(RHS, std::less<T>()); }\n  template <class Compare> void merge(simple_ilist &RHS, Compare comp);\n  ///@}\n\n  /// Sort the list.\n  ///@{\n  void sort() { sort(std::less<T>()); }\n  template <class Compare> void sort(Compare comp);\n  ///@}\n};\n\ntemplate <class T, class... Options>\ntemplate <class Compare>\nvoid simple_ilist<T, Options...>::merge(simple_ilist &RHS, Compare comp) {\n  if (this == &RHS || RHS.empty())\n    return;\n  iterator LI = begin(), LE = end();\n  iterator RI = RHS.begin(), RE = RHS.end();\n  while (LI != LE) {\n    if (comp(*RI, *LI)) {\n      // Transfer a run of at least size 1 from RHS to LHS.\n      iterator RunStart = RI++;\n      RI = std::find_if(RI, RE, [&](reference RV) { return !comp(RV, *LI); });\n      splice(LI, RHS, RunStart, RI);\n      if (RI == RE)\n        return;\n    }\n    ++LI;\n  }\n  // Transfer the remaining RHS nodes once LHS is finished.\n  splice(LE, RHS, RI, RE);\n}\n\ntemplate <class T, class... Options>\ntemplate <class Compare>\nvoid simple_ilist<T, Options...>::sort(Compare comp) {\n  // Vacuously sorted.\n  if (empty() || std::next(begin()) == end())\n    return;\n\n  // Split the list in the middle.\n  iterator Center = begin(), End = begin();\n  while (End != end() && ++End != end()) {\n    ++Center;\n    ++End;\n  }\n  simple_ilist RHS;\n  RHS.splice(RHS.end(), *this, Center, end());\n\n  // Sort the sublists and merge back together.\n  sort(comp);\n  RHS.sort(comp);\n  merge(RHS, comp);\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_SIMPLE_ILIST_H\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "content": "//==- include/llvm/CodeGen/AccelTable.h - Accelerator Tables -----*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains support for writing accelerator tables.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_ACCELTABLE_H\n#define LLVM_CODEGEN_ACCELTABLE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/CodeGen/DIE.h\"\n#include \"llvm/CodeGen/DwarfStringPoolEntry.h\"\n#include \"llvm/MC/MCSymbol.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/DJB.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\n/// The DWARF and Apple accelerator tables are an indirect hash table optimized\n/// for null lookup rather than access to known data. The Apple accelerator\n/// tables are a precursor of the newer DWARF v5 accelerator tables. Both\n/// formats share common design ideas.\n///\n/// The Apple accelerator table are output into an on-disk format that looks\n/// like this:\n///\n/// .------------------.\n/// |  HEADER          |\n/// |------------------|\n/// |  BUCKETS         |\n/// |------------------|\n/// |  HASHES          |\n/// |------------------|\n/// |  OFFSETS         |\n/// |------------------|\n/// |  DATA            |\n/// `------------------'\n///\n/// The header contains a magic number, version, type of hash function,\n/// the number of buckets, total number of hashes, and room for a special struct\n/// of data and the length of that struct.\n///\n/// The buckets contain an index (e.g. 6) into the hashes array. The hashes\n/// section contains all of the 32-bit hash values in contiguous memory, and the\n/// offsets contain the offset into the data area for the particular hash.\n///\n/// For a lookup example, we could hash a function name and take it modulo the\n/// number of buckets giving us our bucket. From there we take the bucket value\n/// as an index into the hashes table and look at each successive hash as long\n/// as the hash value is still the same modulo result (bucket value) as earlier.\n/// If we have a match we look at that same entry in the offsets table and grab\n/// the offset in the data for our final match.\n///\n/// The DWARF v5 accelerator table consists of zero or more name indices that\n/// are output into an on-disk format that looks like this:\n///\n/// .------------------.\n/// |  HEADER          |\n/// |------------------|\n/// |  CU LIST         |\n/// |------------------|\n/// |  LOCAL TU LIST   |\n/// |------------------|\n/// |  FOREIGN TU LIST |\n/// |------------------|\n/// |  HASH TABLE      |\n/// |------------------|\n/// |  NAME TABLE      |\n/// |------------------|\n/// |  ABBREV TABLE    |\n/// |------------------|\n/// |  ENTRY POOL      |\n/// `------------------'\n///\n/// For the full documentation please refer to the DWARF 5 standard.\n///\n///\n/// This file defines the class template AccelTable, which is represents an\n/// abstract view of an Accelerator table, without any notion of an on-disk\n/// layout. This class is parameterized by an entry type, which should derive\n/// from AccelTableData. This is the type of individual entries in the table,\n/// and it should store the data necessary to emit them. AppleAccelTableData is\n/// the base class for Apple Accelerator Table entries, which have a uniform\n/// structure based on a sequence of Atoms. There are different sub-classes\n/// derived from AppleAccelTable, which differ in the set of Atoms and how they\n/// obtain their values.\n///\n/// An Apple Accelerator Table can be serialized by calling emitAppleAccelTable\n/// function.\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass DwarfCompileUnit;\nclass DwarfDebug;\n\n/// Interface which the different types of accelerator table data have to\n/// conform. It serves as a base class for different values of the template\n/// argument of the AccelTable class template.\nclass AccelTableData {\npublic:\n  virtual ~AccelTableData() = default;\n\n  bool operator<(const AccelTableData &Other) const {\n    return order() < Other.order();\n  }\n\n    // Subclasses should implement:\n    // static uint32_t hash(StringRef Name);\n\n#ifndef NDEBUG\n  virtual void print(raw_ostream &OS) const = 0;\n#endif\nprotected:\n  virtual uint64_t order() const = 0;\n};\n\n/// A base class holding non-template-dependant functionality of the AccelTable\n/// class. Clients should not use this class directly but rather instantiate\n/// AccelTable with a type derived from AccelTableData.\nclass AccelTableBase {\npublic:\n  using HashFn = uint32_t(StringRef);\n\n  /// Represents a group of entries with identical name (and hence, hash value).\n  struct HashData {\n    DwarfStringPoolEntryRef Name;\n    uint32_t HashValue;\n    std::vector<AccelTableData *> Values;\n    MCSymbol *Sym;\n\n    HashData(DwarfStringPoolEntryRef Name, HashFn *Hash)\n        : Name(Name), HashValue(Hash(Name.getString())) {}\n\n#ifndef NDEBUG\n    void print(raw_ostream &OS) const;\n    void dump() const { print(dbgs()); }\n#endif\n  };\n  using HashList = std::vector<HashData *>;\n  using BucketList = std::vector<HashList>;\n\nprotected:\n  /// Allocator for HashData and Values.\n  BumpPtrAllocator Allocator;\n\n  using StringEntries = StringMap<HashData, BumpPtrAllocator &>;\n  StringEntries Entries;\n\n  HashFn *Hash;\n  uint32_t BucketCount;\n  uint32_t UniqueHashCount;\n\n  HashList Hashes;\n  BucketList Buckets;\n\n  void computeBucketCount();\n\n  AccelTableBase(HashFn *Hash) : Entries(Allocator), Hash(Hash) {}\n\npublic:\n  void finalize(AsmPrinter *Asm, StringRef Prefix);\n  ArrayRef<HashList> getBuckets() const { return Buckets; }\n  uint32_t getBucketCount() const { return BucketCount; }\n  uint32_t getUniqueHashCount() const { return UniqueHashCount; }\n  uint32_t getUniqueNameCount() const { return Entries.size(); }\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const;\n  void dump() const { print(dbgs()); }\n#endif\n\n  AccelTableBase(const AccelTableBase &) = delete;\n  void operator=(const AccelTableBase &) = delete;\n};\n\n/// This class holds an abstract representation of an Accelerator Table,\n/// consisting of a sequence of buckets, each bucket containint a sequence of\n/// HashData entries. The class is parameterized by the type of entries it\n/// holds. The type template parameter also defines the hash function to use for\n/// hashing names.\ntemplate <typename DataT> class AccelTable : public AccelTableBase {\npublic:\n  AccelTable() : AccelTableBase(DataT::hash) {}\n\n  template <typename... Types>\n  void addName(DwarfStringPoolEntryRef Name, Types &&... Args);\n};\n\ntemplate <typename AccelTableDataT>\ntemplate <typename... Types>\nvoid AccelTable<AccelTableDataT>::addName(DwarfStringPoolEntryRef Name,\n                                          Types &&... Args) {\n  assert(Buckets.empty() && \"Already finalized!\");\n  // If the string is in the list already then add this die to the list\n  // otherwise add a new one.\n  auto Iter = Entries.try_emplace(Name.getString(), Name, Hash).first;\n  assert(Iter->second.Name == Name);\n  Iter->second.Values.push_back(\n      new (Allocator) AccelTableDataT(std::forward<Types>(Args)...));\n}\n\n/// A base class for different implementations of Data classes for Apple\n/// Accelerator Tables. The columns in the table are defined by the static Atoms\n/// variable defined on the subclasses.\nclass AppleAccelTableData : public AccelTableData {\npublic:\n  /// An Atom defines the form of the data in an Apple accelerator table.\n  /// Conceptually it is a column in the accelerator consisting of a type and a\n  /// specification of the form of its data.\n  struct Atom {\n    /// Atom Type.\n    const uint16_t Type;\n    /// DWARF Form.\n    const uint16_t Form;\n\n    constexpr Atom(uint16_t Type, uint16_t Form) : Type(Type), Form(Form) {}\n\n#ifndef NDEBUG\n    void print(raw_ostream &OS) const;\n    void dump() const { print(dbgs()); }\n#endif\n  };\n  // Subclasses should define:\n  // static constexpr Atom Atoms[];\n\n  virtual void emit(AsmPrinter *Asm) const = 0;\n\n  static uint32_t hash(StringRef Buffer) { return djbHash(Buffer); }\n};\n\n/// The Data class implementation for DWARF v5 accelerator table. Unlike the\n/// Apple Data classes, this class is just a DIE wrapper, and does not know to\n/// serialize itself. The complete serialization logic is in the\n/// emitDWARF5AccelTable function.\nclass DWARF5AccelTableData : public AccelTableData {\npublic:\n  static uint32_t hash(StringRef Name) { return caseFoldingDjbHash(Name); }\n\n  DWARF5AccelTableData(const DIE &Die) : Die(Die) {}\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\n\n  const DIE &getDie() const { return Die; }\n  uint64_t getDieOffset() const { return Die.getOffset(); }\n  unsigned getDieTag() const { return Die.getTag(); }\n\nprotected:\n  const DIE &Die;\n\n  uint64_t order() const override { return Die.getOffset(); }\n};\n\nclass DWARF5AccelTableStaticData : public AccelTableData {\npublic:\n  static uint32_t hash(StringRef Name) { return caseFoldingDjbHash(Name); }\n\n  DWARF5AccelTableStaticData(uint64_t DieOffset, unsigned DieTag,\n                             unsigned CUIndex)\n      : DieOffset(DieOffset), DieTag(DieTag), CUIndex(CUIndex) {}\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\n\n  uint64_t getDieOffset() const { return DieOffset; }\n  unsigned getDieTag() const { return DieTag; }\n  unsigned getCUIndex() const { return CUIndex; }\n\nprotected:\n  uint64_t DieOffset;\n  unsigned DieTag;\n  unsigned CUIndex;\n\n  uint64_t order() const override { return DieOffset; }\n};\n\nvoid emitAppleAccelTableImpl(AsmPrinter *Asm, AccelTableBase &Contents,\n                             StringRef Prefix, const MCSymbol *SecBegin,\n                             ArrayRef<AppleAccelTableData::Atom> Atoms);\n\n/// Emit an Apple Accelerator Table consisting of entries in the specified\n/// AccelTable. The DataT template parameter should be derived from\n/// AppleAccelTableData.\ntemplate <typename DataT>\nvoid emitAppleAccelTable(AsmPrinter *Asm, AccelTable<DataT> &Contents,\n                         StringRef Prefix, const MCSymbol *SecBegin) {\n  static_assert(std::is_convertible<DataT *, AppleAccelTableData *>::value, \"\");\n  emitAppleAccelTableImpl(Asm, Contents, Prefix, SecBegin, DataT::Atoms);\n}\n\nvoid emitDWARF5AccelTable(AsmPrinter *Asm,\n                          AccelTable<DWARF5AccelTableData> &Contents,\n                          const DwarfDebug &DD,\n                          ArrayRef<std::unique_ptr<DwarfCompileUnit>> CUs);\n\nvoid emitDWARF5AccelTable(\n    AsmPrinter *Asm, AccelTable<DWARF5AccelTableStaticData> &Contents,\n    ArrayRef<MCSymbol *> CUs,\n    llvm::function_ref<unsigned(const DWARF5AccelTableStaticData &)>\n        getCUIndexForEntry);\n\n/// Accelerator table data implementation for simple Apple accelerator tables\n/// with just a DIE reference.\nclass AppleAccelTableOffsetData : public AppleAccelTableData {\npublic:\n  AppleAccelTableOffsetData(const DIE &D) : Die(D) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\nprotected:\n  uint64_t order() const override { return Die.getOffset(); }\n\n  const DIE &Die;\n};\n\n/// Accelerator table data implementation for Apple type accelerator tables.\nclass AppleAccelTableTypeData : public AppleAccelTableOffsetData {\npublic:\n  AppleAccelTableTypeData(const DIE &D) : AppleAccelTableOffsetData(D) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4),\n      Atom(dwarf::DW_ATOM_die_tag, dwarf::DW_FORM_data2),\n      Atom(dwarf::DW_ATOM_type_flags, dwarf::DW_FORM_data1)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\n};\n\n/// Accelerator table data implementation for simple Apple accelerator tables\n/// with a DIE offset but no actual DIE pointer.\nclass AppleAccelTableStaticOffsetData : public AppleAccelTableData {\npublic:\n  AppleAccelTableStaticOffsetData(uint32_t Offset) : Offset(Offset) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\nprotected:\n  uint64_t order() const override { return Offset; }\n\n  uint32_t Offset;\n};\n\n/// Accelerator table data implementation for type accelerator tables with\n/// a DIE offset but no actual DIE pointer.\nclass AppleAccelTableStaticTypeData : public AppleAccelTableStaticOffsetData {\npublic:\n  AppleAccelTableStaticTypeData(uint32_t Offset, uint16_t Tag,\n                                bool ObjCClassIsImplementation,\n                                uint32_t QualifiedNameHash)\n      : AppleAccelTableStaticOffsetData(Offset),\n        QualifiedNameHash(QualifiedNameHash), Tag(Tag),\n        ObjCClassIsImplementation(ObjCClassIsImplementation) {}\n\n  void emit(AsmPrinter *Asm) const override;\n\n  static constexpr Atom Atoms[] = {\n      Atom(dwarf::DW_ATOM_die_offset, dwarf::DW_FORM_data4),\n      Atom(dwarf::DW_ATOM_die_tag, dwarf::DW_FORM_data2),\n      Atom(5, dwarf::DW_FORM_data1), Atom(6, dwarf::DW_FORM_data4)};\n\n#ifndef NDEBUG\n  void print(raw_ostream &OS) const override;\n#endif\nprotected:\n  uint64_t order() const override { return Offset; }\n\n  uint32_t QualifiedNameHash;\n  uint16_t Tag;\n  bool ObjCClassIsImplementation;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_ACCELTABLE_H\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "content": "//===- lib/CodeGen/DIE.h - DWARF Info Entries -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Data structures for DWARF info entries.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_DIE_H\n#define LLVM_CODEGEN_DIE_H\n\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/CodeGen/DwarfStringPoolEntry.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <new>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass DIE;\nclass DIEUnit;\nclass DwarfCompileUnit;\nclass MCExpr;\nclass MCSection;\nclass MCSymbol;\nclass raw_ostream;\n\n//===--------------------------------------------------------------------===//\n/// Dwarf abbreviation data, describes one attribute of a Dwarf abbreviation.\nclass DIEAbbrevData {\n  /// Dwarf attribute code.\n  dwarf::Attribute Attribute;\n\n  /// Dwarf form code.\n  dwarf::Form Form;\n\n  /// Dwarf attribute value for DW_FORM_implicit_const\n  int64_t Value = 0;\n\npublic:\n  DIEAbbrevData(dwarf::Attribute A, dwarf::Form F)\n      : Attribute(A), Form(F) {}\n  DIEAbbrevData(dwarf::Attribute A, int64_t V)\n      : Attribute(A), Form(dwarf::DW_FORM_implicit_const), Value(V) {}\n\n  /// Accessors.\n  /// @{\n  dwarf::Attribute getAttribute() const { return Attribute; }\n  dwarf::Form getForm() const { return Form; }\n  int64_t getValue() const { return Value; }\n  /// @}\n\n  /// Used to gather unique data for the abbreviation folding set.\n  void Profile(FoldingSetNodeID &ID) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Dwarf abbreviation, describes the organization of a debug information\n/// object.\nclass DIEAbbrev : public FoldingSetNode {\n  /// Unique number for node.\n  unsigned Number = 0;\n\n  /// Dwarf tag code.\n  dwarf::Tag Tag;\n\n  /// Whether or not this node has children.\n  ///\n  /// This cheats a bit in all of the uses since the values in the standard\n  /// are 0 and 1 for no children and children respectively.\n  bool Children;\n\n  /// Raw data bytes for abbreviation.\n  SmallVector<DIEAbbrevData, 12> Data;\n\npublic:\n  DIEAbbrev(dwarf::Tag T, bool C) : Tag(T), Children(C) {}\n\n  /// Accessors.\n  /// @{\n  dwarf::Tag getTag() const { return Tag; }\n  unsigned getNumber() const { return Number; }\n  bool hasChildren() const { return Children; }\n  const SmallVectorImpl<DIEAbbrevData> &getData() const { return Data; }\n  void setChildrenFlag(bool hasChild) { Children = hasChild; }\n  void setNumber(unsigned N) { Number = N; }\n  /// @}\n\n  /// Adds another set of attribute information to the abbreviation.\n  void AddAttribute(dwarf::Attribute Attribute, dwarf::Form Form) {\n    Data.push_back(DIEAbbrevData(Attribute, Form));\n  }\n\n  /// Adds attribute with DW_FORM_implicit_const value\n  void AddImplicitConstAttribute(dwarf::Attribute Attribute, int64_t Value) {\n    Data.push_back(DIEAbbrevData(Attribute, Value));\n  }\n\n  /// Used to gather unique data for the abbreviation folding set.\n  void Profile(FoldingSetNodeID &ID) const;\n\n  /// Print the abbreviation using the specified asm printer.\n  void Emit(const AsmPrinter *AP) const;\n\n  void print(raw_ostream &O) const;\n  void dump() const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Helps unique DIEAbbrev objects and assigns abbreviation numbers.\n///\n/// This class will unique the DIE abbreviations for a llvm::DIE object and\n/// assign a unique abbreviation number to each unique DIEAbbrev object it\n/// finds. The resulting collection of DIEAbbrev objects can then be emitted\n/// into the .debug_abbrev section.\nclass DIEAbbrevSet {\n  /// The bump allocator to use when creating DIEAbbrev objects in the uniqued\n  /// storage container.\n  BumpPtrAllocator &Alloc;\n  /// FoldingSet that uniques the abbreviations.\n  FoldingSet<DIEAbbrev> AbbreviationsSet;\n  /// A list of all the unique abbreviations in use.\n  std::vector<DIEAbbrev *> Abbreviations;\n\npublic:\n  DIEAbbrevSet(BumpPtrAllocator &A) : Alloc(A) {}\n  ~DIEAbbrevSet();\n\n  /// Generate the abbreviation declaration for a DIE and return a pointer to\n  /// the generated abbreviation.\n  ///\n  /// \\param Die the debug info entry to generate the abbreviation for.\n  /// \\returns A reference to the uniqued abbreviation declaration that is\n  /// owned by this class.\n  DIEAbbrev &uniqueAbbreviation(DIE &Die);\n\n  /// Print all abbreviations using the specified asm printer.\n  void Emit(const AsmPrinter *AP, MCSection *Section) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// An integer value DIE.\n///\nclass DIEInteger {\n  uint64_t Integer;\n\npublic:\n  explicit DIEInteger(uint64_t I) : Integer(I) {}\n\n  /// Choose the best form for integer.\n  static dwarf::Form BestForm(bool IsSigned, uint64_t Int) {\n    if (IsSigned) {\n      const int64_t SignedInt = Int;\n      if ((char)Int == SignedInt)\n        return dwarf::DW_FORM_data1;\n      if ((short)Int == SignedInt)\n        return dwarf::DW_FORM_data2;\n      if ((int)Int == SignedInt)\n        return dwarf::DW_FORM_data4;\n    } else {\n      if ((unsigned char)Int == Int)\n        return dwarf::DW_FORM_data1;\n      if ((unsigned short)Int == Int)\n        return dwarf::DW_FORM_data2;\n      if ((unsigned int)Int == Int)\n        return dwarf::DW_FORM_data4;\n    }\n    return dwarf::DW_FORM_data8;\n  }\n\n  uint64_t getValue() const { return Integer; }\n  void setValue(uint64_t Val) { Integer = Val; }\n\n  void emitValue(const AsmPrinter *Asm, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// An expression DIE.\nclass DIEExpr {\n  const MCExpr *Expr;\n\npublic:\n  explicit DIEExpr(const MCExpr *E) : Expr(E) {}\n\n  /// Get MCExpr.\n  const MCExpr *getValue() const { return Expr; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A label DIE.\nclass DIELabel {\n  const MCSymbol *Label;\n\npublic:\n  explicit DIELabel(const MCSymbol *L) : Label(L) {}\n\n  /// Get MCSymbol.\n  const MCSymbol *getValue() const { return Label; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A BaseTypeRef DIE.\nclass DIEBaseTypeRef {\n  const DwarfCompileUnit *CU;\n  const uint64_t Index;\n  static constexpr unsigned ULEB128PadSize = 4;\n\npublic:\n  explicit DIEBaseTypeRef(const DwarfCompileUnit *TheCU, uint64_t Idx)\n    : CU(TheCU), Index(Idx) {}\n\n  /// EmitValue - Emit base type reference.\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  /// SizeOf - Determine size of the base type reference in bytes.\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n  uint64_t getIndex() const { return Index; }\n};\n\n//===--------------------------------------------------------------------===//\n/// A simple label difference DIE.\n///\nclass DIEDelta {\n  const MCSymbol *LabelHi;\n  const MCSymbol *LabelLo;\n\npublic:\n  DIEDelta(const MCSymbol *Hi, const MCSymbol *Lo) : LabelHi(Hi), LabelLo(Lo) {}\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A container for string pool string values.\n///\n/// This class is used with the DW_FORM_strp and DW_FORM_GNU_str_index forms.\nclass DIEString {\n  DwarfStringPoolEntryRef S;\n\npublic:\n  DIEString(DwarfStringPoolEntryRef S) : S(S) {}\n\n  /// Grab the string out of the object.\n  StringRef getString() const { return S.getString(); }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A container for inline string values.\n///\n/// This class is used with the DW_FORM_string form.\nclass DIEInlineString {\n  StringRef S;\n\npublic:\n  template <typename Allocator>\n  explicit DIEInlineString(StringRef Str, Allocator &A) : S(Str.copy(A)) {}\n\n  ~DIEInlineString() = default;\n\n  /// Grab the string out of the object.\n  StringRef getString() const { return S; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A pointer to another debug information entry.  An instance of this class can\n/// also be used as a proxy for a debug information entry not yet defined\n/// (ie. types.)\nclass DIEEntry {\n  DIE *Entry;\n\npublic:\n  DIEEntry() = delete;\n  explicit DIEEntry(DIE &E) : Entry(&E) {}\n\n  DIE &getEntry() const { return *Entry; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Represents a pointer to a location list in the debug_loc\n/// section.\nclass DIELocList {\n  /// Index into the .debug_loc vector.\n  size_t Index;\n\npublic:\n  DIELocList(size_t I) : Index(I) {}\n\n  /// Grab the current index out.\n  size_t getValue() const { return Index; }\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A BaseTypeRef DIE.\nclass DIEAddrOffset {\n  DIEInteger Addr;\n  DIEDelta Offset;\n\npublic:\n  explicit DIEAddrOffset(uint64_t Idx, const MCSymbol *Hi, const MCSymbol *Lo)\n      : Addr(Idx), Offset(Hi, Lo) {}\n\n  void emitValue(const AsmPrinter *AP, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// A debug information entry value. Some of these roughly correlate\n/// to DWARF attribute classes.\nclass DIEBlock;\nclass DIELoc;\nclass DIEValue {\npublic:\n  enum Type {\n    isNone,\n#define HANDLE_DIEVALUE(T) is##T,\n#include \"llvm/CodeGen/DIEValue.def\"\n  };\n\nprivate:\n  /// Type of data stored in the value.\n  Type Ty = isNone;\n  dwarf::Attribute Attribute = (dwarf::Attribute)0;\n  dwarf::Form Form = (dwarf::Form)0;\n\n  /// Storage for the value.\n  ///\n  /// All values that aren't standard layout (or are larger than 8 bytes)\n  /// should be stored by reference instead of by value.\n  using ValTy =\n      AlignedCharArrayUnion<DIEInteger, DIEString, DIEExpr, DIELabel,\n                            DIEDelta *, DIEEntry, DIEBlock *, DIELoc *,\n                            DIELocList, DIEBaseTypeRef *, DIEAddrOffset *>;\n\n  static_assert(sizeof(ValTy) <= sizeof(uint64_t) ||\n                    sizeof(ValTy) <= sizeof(void *),\n                \"Expected all large types to be stored via pointer\");\n\n  /// Underlying stored value.\n  ValTy Val;\n\n  template <class T> void construct(T V) {\n    static_assert(std::is_standard_layout<T>::value ||\n                      std::is_pointer<T>::value,\n                  \"Expected standard layout or pointer\");\n    new (reinterpret_cast<void *>(&Val)) T(V);\n  }\n\n  template <class T> T *get() { return reinterpret_cast<T *>(&Val); }\n  template <class T> const T *get() const {\n    return reinterpret_cast<const T *>(&Val);\n  }\n  template <class T> void destruct() { get<T>()->~T(); }\n\n  /// Destroy the underlying value.\n  ///\n  /// This should get optimized down to a no-op.  We could skip it if we could\n  /// add a static assert on \\a std::is_trivially_copyable(), but we currently\n  /// support versions of GCC that don't understand that.\n  void destroyVal() {\n    switch (Ty) {\n    case isNone:\n      return;\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  case is##T:                                                                  \\\n    destruct<DIE##T>();                                                        \\\n    return;\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  case is##T:                                                                  \\\n    destruct<const DIE##T *>();                                                \\\n    return;\n#include \"llvm/CodeGen/DIEValue.def\"\n    }\n  }\n\n  /// Copy the underlying value.\n  ///\n  /// This should get optimized down to a simple copy.  We need to actually\n  /// construct the value, rather than calling memcpy, to satisfy strict\n  /// aliasing rules.\n  void copyVal(const DIEValue &X) {\n    switch (Ty) {\n    case isNone:\n      return;\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  case is##T:                                                                  \\\n    construct<DIE##T>(*X.get<DIE##T>());                                       \\\n    return;\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  case is##T:                                                                  \\\n    construct<const DIE##T *>(*X.get<const DIE##T *>());                       \\\n    return;\n#include \"llvm/CodeGen/DIEValue.def\"\n    }\n  }\n\npublic:\n  DIEValue() = default;\n\n  DIEValue(const DIEValue &X) : Ty(X.Ty), Attribute(X.Attribute), Form(X.Form) {\n    copyVal(X);\n  }\n\n  DIEValue &operator=(const DIEValue &X) {\n    destroyVal();\n    Ty = X.Ty;\n    Attribute = X.Attribute;\n    Form = X.Form;\n    copyVal(X);\n    return *this;\n  }\n\n  ~DIEValue() { destroyVal(); }\n\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  DIEValue(dwarf::Attribute Attribute, dwarf::Form Form, const DIE##T &V)      \\\n      : Ty(is##T), Attribute(Attribute), Form(Form) {                          \\\n    construct<DIE##T>(V);                                                      \\\n  }\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  DIEValue(dwarf::Attribute Attribute, dwarf::Form Form, const DIE##T *V)      \\\n      : Ty(is##T), Attribute(Attribute), Form(Form) {                          \\\n    assert(V && \"Expected valid value\");                                       \\\n    construct<const DIE##T *>(V);                                              \\\n  }\n#include \"llvm/CodeGen/DIEValue.def\"\n\n  /// Accessors.\n  /// @{\n  Type getType() const { return Ty; }\n  dwarf::Attribute getAttribute() const { return Attribute; }\n  dwarf::Form getForm() const { return Form; }\n  explicit operator bool() const { return Ty; }\n  /// @}\n\n#define HANDLE_DIEVALUE_SMALL(T)                                               \\\n  const DIE##T &getDIE##T() const {                                            \\\n    assert(getType() == is##T && \"Expected \" #T);                              \\\n    return *get<DIE##T>();                                                     \\\n  }\n#define HANDLE_DIEVALUE_LARGE(T)                                               \\\n  const DIE##T &getDIE##T() const {                                            \\\n    assert(getType() == is##T && \"Expected \" #T);                              \\\n    return **get<const DIE##T *>();                                            \\\n  }\n#include \"llvm/CodeGen/DIEValue.def\"\n\n  /// Emit value via the Dwarf writer.\n  void emitValue(const AsmPrinter *AP) const;\n\n  /// Return the size of a value in bytes.\n  unsigned SizeOf(const AsmPrinter *AP) const;\n\n  void print(raw_ostream &O) const;\n  void dump() const;\n};\n\nstruct IntrusiveBackListNode {\n  PointerIntPair<IntrusiveBackListNode *, 1> Next;\n\n  IntrusiveBackListNode() : Next(this, true) {}\n\n  IntrusiveBackListNode *getNext() const {\n    return Next.getInt() ? nullptr : Next.getPointer();\n  }\n};\n\nstruct IntrusiveBackListBase {\n  using Node = IntrusiveBackListNode;\n\n  Node *Last = nullptr;\n\n  bool empty() const { return !Last; }\n\n  void push_back(Node &N) {\n    assert(N.Next.getPointer() == &N && \"Expected unlinked node\");\n    assert(N.Next.getInt() == true && \"Expected unlinked node\");\n\n    if (Last) {\n      N.Next = Last->Next;\n      Last->Next.setPointerAndInt(&N, false);\n    }\n    Last = &N;\n  }\n\n  void push_front(Node &N) {\n    assert(N.Next.getPointer() == &N && \"Expected unlinked node\");\n    assert(N.Next.getInt() == true && \"Expected unlinked node\");\n\n    if (Last) {\n      N.Next.setPointerAndInt(Last->Next.getPointer(), false);\n      Last->Next.setPointerAndInt(&N, true);\n    } else {\n      Last = &N;\n    }\n  }\n};\n\ntemplate <class T> class IntrusiveBackList : IntrusiveBackListBase {\npublic:\n  using IntrusiveBackListBase::empty;\n\n  void push_back(T &N) { IntrusiveBackListBase::push_back(N); }\n  void push_front(T &N) { IntrusiveBackListBase::push_front(N); }\n  T &back() { return *static_cast<T *>(Last); }\n  const T &back() const { return *static_cast<T *>(Last); }\n  T &front() {\n    return *static_cast<T *>(Last ? Last->Next.getPointer() : nullptr);\n  }\n  const T &front() const {\n    return *static_cast<T *>(Last ? Last->Next.getPointer() : nullptr);\n  }\n\n  void takeNodes(IntrusiveBackList<T> &Other) {\n    if (Other.empty())\n      return;\n\n    T *FirstNode = static_cast<T *>(Other.Last->Next.getPointer());\n    T *IterNode = FirstNode;\n    do {\n      // Keep a pointer to the node and increment the iterator.\n      T *TmpNode = IterNode;\n      IterNode = static_cast<T *>(IterNode->Next.getPointer());\n\n      // Unlink the node and push it back to this list.\n      TmpNode->Next.setPointerAndInt(TmpNode, true);\n      push_back(*TmpNode);\n    } while (IterNode != FirstNode);\n\n    Other.Last = nullptr;\n  }\n\n  class const_iterator;\n  class iterator\n      : public iterator_facade_base<iterator, std::forward_iterator_tag, T> {\n    friend class const_iterator;\n\n    Node *N = nullptr;\n\n  public:\n    iterator() = default;\n    explicit iterator(T *N) : N(N) {}\n\n    iterator &operator++() {\n      N = N->getNext();\n      return *this;\n    }\n\n    explicit operator bool() const { return N; }\n    T &operator*() const { return *static_cast<T *>(N); }\n\n    bool operator==(const iterator &X) const { return N == X.N; }\n  };\n\n  class const_iterator\n      : public iterator_facade_base<const_iterator, std::forward_iterator_tag,\n                                    const T> {\n    const Node *N = nullptr;\n\n  public:\n    const_iterator() = default;\n    // Placate MSVC by explicitly scoping 'iterator'.\n    const_iterator(typename IntrusiveBackList<T>::iterator X) : N(X.N) {}\n    explicit const_iterator(const T *N) : N(N) {}\n\n    const_iterator &operator++() {\n      N = N->getNext();\n      return *this;\n    }\n\n    explicit operator bool() const { return N; }\n    const T &operator*() const { return *static_cast<const T *>(N); }\n\n    bool operator==(const const_iterator &X) const { return N == X.N; }\n  };\n\n  iterator begin() {\n    return Last ? iterator(static_cast<T *>(Last->Next.getPointer())) : end();\n  }\n  const_iterator begin() const {\n    return const_cast<IntrusiveBackList *>(this)->begin();\n  }\n  iterator end() { return iterator(); }\n  const_iterator end() const { return const_iterator(); }\n\n  static iterator toIterator(T &N) { return iterator(&N); }\n  static const_iterator toIterator(const T &N) { return const_iterator(&N); }\n};\n\n/// A list of DIE values.\n///\n/// This is a singly-linked list, but instead of reversing the order of\n/// insertion, we keep a pointer to the back of the list so we can push in\n/// order.\n///\n/// There are two main reasons to choose a linked list over a customized\n/// vector-like data structure.\n///\n///  1. For teardown efficiency, we want DIEs to be BumpPtrAllocated.  Using a\n///     linked list here makes this way easier to accomplish.\n///  2. Carrying an extra pointer per \\a DIEValue isn't expensive.  45% of DIEs\n///     have 2 or fewer values, and 90% have 5 or fewer.  A vector would be\n///     over-allocated by 50% on average anyway, the same cost as the\n///     linked-list node.\nclass DIEValueList {\n  struct Node : IntrusiveBackListNode {\n    DIEValue V;\n\n    explicit Node(DIEValue V) : V(V) {}\n  };\n\n  using ListTy = IntrusiveBackList<Node>;\n\n  ListTy List;\n\npublic:\n  class const_value_iterator;\n  class value_iterator\n      : public iterator_adaptor_base<value_iterator, ListTy::iterator,\n                                     std::forward_iterator_tag, DIEValue> {\n    friend class const_value_iterator;\n\n    using iterator_adaptor =\n        iterator_adaptor_base<value_iterator, ListTy::iterator,\n                              std::forward_iterator_tag, DIEValue>;\n\n  public:\n    value_iterator() = default;\n    explicit value_iterator(ListTy::iterator X) : iterator_adaptor(X) {}\n\n    explicit operator bool() const { return bool(wrapped()); }\n    DIEValue &operator*() const { return wrapped()->V; }\n  };\n\n  class const_value_iterator : public iterator_adaptor_base<\n                                   const_value_iterator, ListTy::const_iterator,\n                                   std::forward_iterator_tag, const DIEValue> {\n    using iterator_adaptor =\n        iterator_adaptor_base<const_value_iterator, ListTy::const_iterator,\n                              std::forward_iterator_tag, const DIEValue>;\n\n  public:\n    const_value_iterator() = default;\n    const_value_iterator(DIEValueList::value_iterator X)\n        : iterator_adaptor(X.wrapped()) {}\n    explicit const_value_iterator(ListTy::const_iterator X)\n        : iterator_adaptor(X) {}\n\n    explicit operator bool() const { return bool(wrapped()); }\n    const DIEValue &operator*() const { return wrapped()->V; }\n  };\n\n  using value_range = iterator_range<value_iterator>;\n  using const_value_range = iterator_range<const_value_iterator>;\n\n  value_iterator addValue(BumpPtrAllocator &Alloc, const DIEValue &V) {\n    List.push_back(*new (Alloc) Node(V));\n    return value_iterator(ListTy::toIterator(List.back()));\n  }\n  template <class T>\n  value_iterator addValue(BumpPtrAllocator &Alloc, dwarf::Attribute Attribute,\n                    dwarf::Form Form, T &&Value) {\n    return addValue(Alloc, DIEValue(Attribute, Form, std::forward<T>(Value)));\n  }\n\n  /// Take ownership of the nodes in \\p Other, and append them to the back of\n  /// the list.\n  void takeValues(DIEValueList &Other) { List.takeNodes(Other.List); }\n\n  value_range values() {\n    return make_range(value_iterator(List.begin()), value_iterator(List.end()));\n  }\n  const_value_range values() const {\n    return make_range(const_value_iterator(List.begin()),\n                      const_value_iterator(List.end()));\n  }\n};\n\n//===--------------------------------------------------------------------===//\n/// A structured debug information entry.  Has an abbreviation which\n/// describes its organization.\nclass DIE : IntrusiveBackListNode, public DIEValueList {\n  friend class IntrusiveBackList<DIE>;\n  friend class DIEUnit;\n\n  /// Dwarf unit relative offset.\n  unsigned Offset = 0;\n  /// Size of instance + children.\n  unsigned Size = 0;\n  unsigned AbbrevNumber = ~0u;\n  /// Dwarf tag code.\n  dwarf::Tag Tag = (dwarf::Tag)0;\n  /// Set to true to force a DIE to emit an abbreviation that says it has\n  /// children even when it doesn't. This is used for unit testing purposes.\n  bool ForceChildren = false;\n  /// Children DIEs.\n  IntrusiveBackList<DIE> Children;\n\n  /// The owner is either the parent DIE for children of other DIEs, or a\n  /// DIEUnit which contains this DIE as its unit DIE.\n  PointerUnion<DIE *, DIEUnit *> Owner;\n\n  explicit DIE(dwarf::Tag Tag) : Tag(Tag) {}\n\npublic:\n  DIE() = delete;\n  DIE(const DIE &RHS) = delete;\n  DIE(DIE &&RHS) = delete;\n  DIE &operator=(const DIE &RHS) = delete;\n  DIE &operator=(const DIE &&RHS) = delete;\n\n  static DIE *get(BumpPtrAllocator &Alloc, dwarf::Tag Tag) {\n    return new (Alloc) DIE(Tag);\n  }\n\n  // Accessors.\n  unsigned getAbbrevNumber() const { return AbbrevNumber; }\n  dwarf::Tag getTag() const { return Tag; }\n  /// Get the compile/type unit relative offset of this DIE.\n  unsigned getOffset() const { return Offset; }\n  unsigned getSize() const { return Size; }\n  bool hasChildren() const { return ForceChildren || !Children.empty(); }\n  void setForceChildren(bool B) { ForceChildren = B; }\n\n  using child_iterator = IntrusiveBackList<DIE>::iterator;\n  using const_child_iterator = IntrusiveBackList<DIE>::const_iterator;\n  using child_range = iterator_range<child_iterator>;\n  using const_child_range = iterator_range<const_child_iterator>;\n\n  child_range children() {\n    return make_range(Children.begin(), Children.end());\n  }\n  const_child_range children() const {\n    return make_range(Children.begin(), Children.end());\n  }\n\n  DIE *getParent() const;\n\n  /// Generate the abbreviation for this DIE.\n  ///\n  /// Calculate the abbreviation for this, which should be uniqued and\n  /// eventually used to call \\a setAbbrevNumber().\n  DIEAbbrev generateAbbrev() const;\n\n  /// Set the abbreviation number for this DIE.\n  void setAbbrevNumber(unsigned I) { AbbrevNumber = I; }\n\n  /// Get the absolute offset within the .debug_info or .debug_types section\n  /// for this DIE.\n  uint64_t getDebugSectionOffset() const;\n\n  /// Compute the offset of this DIE and all its children.\n  ///\n  /// This function gets called just before we are going to generate the debug\n  /// information and gives each DIE a chance to figure out its CU relative DIE\n  /// offset, unique its abbreviation and fill in the abbreviation code, and\n  /// return the unit offset that points to where the next DIE will be emitted\n  /// within the debug unit section. After this function has been called for all\n  /// DIE objects, the DWARF can be generated since all DIEs will be able to\n  /// properly refer to other DIE objects since all DIEs have calculated their\n  /// offsets.\n  ///\n  /// \\param AP AsmPrinter to use when calculating sizes.\n  /// \\param AbbrevSet the abbreviation used to unique DIE abbreviations.\n  /// \\param CUOffset the compile/type unit relative offset in bytes.\n  /// \\returns the offset for the DIE that follows this DIE within the\n  /// current compile/type unit.\n  unsigned computeOffsetsAndAbbrevs(const AsmPrinter *AP,\n                                    DIEAbbrevSet &AbbrevSet, unsigned CUOffset);\n\n  /// Climb up the parent chain to get the compile unit or type unit DIE that\n  /// this DIE belongs to.\n  ///\n  /// \\returns the compile or type unit DIE that owns this DIE, or NULL if\n  /// this DIE hasn't been added to a unit DIE.\n  const DIE *getUnitDie() const;\n\n  /// Climb up the parent chain to get the compile unit or type unit that this\n  /// DIE belongs to.\n  ///\n  /// \\returns the DIEUnit that represents the compile or type unit that owns\n  /// this DIE, or NULL if this DIE hasn't been added to a unit DIE.\n  DIEUnit *getUnit() const;\n\n  void setOffset(unsigned O) { Offset = O; }\n  void setSize(unsigned S) { Size = S; }\n\n  /// Add a child to the DIE.\n  DIE &addChild(DIE *Child) {\n    assert(!Child->getParent() && \"Child should be orphaned\");\n    Child->Owner = this;\n    Children.push_back(*Child);\n    return Children.back();\n  }\n\n  DIE &addChildFront(DIE *Child) {\n    assert(!Child->getParent() && \"Child should be orphaned\");\n    Child->Owner = this;\n    Children.push_front(*Child);\n    return Children.front();\n  }\n\n  /// Find a value in the DIE with the attribute given.\n  ///\n  /// Returns a default-constructed DIEValue (where \\a DIEValue::getType()\n  /// gives \\a DIEValue::isNone) if no such attribute exists.\n  DIEValue findAttribute(dwarf::Attribute Attribute) const;\n\n  void print(raw_ostream &O, unsigned IndentCount = 0) const;\n  void dump() const;\n};\n\n//===--------------------------------------------------------------------===//\n/// Represents a compile or type unit.\nclass DIEUnit {\n  /// The compile unit or type unit DIE. This variable must be an instance of\n  /// DIE so that we can calculate the DIEUnit from any DIE by traversing the\n  /// parent backchain and getting the Unit DIE, and then casting itself to a\n  /// DIEUnit. This allows us to be able to find the DIEUnit for any DIE without\n  /// having to store a pointer to the DIEUnit in each DIE instance.\n  DIE Die;\n  /// The section this unit will be emitted in. This may or may not be set to\n  /// a valid section depending on the client that is emitting DWARF.\n  MCSection *Section;\n  uint64_t Offset; /// .debug_info or .debug_types absolute section offset.\nprotected:\n  virtual ~DIEUnit() = default;\n\npublic:\n  explicit DIEUnit(dwarf::Tag UnitTag);\n  DIEUnit(const DIEUnit &RHS) = delete;\n  DIEUnit(DIEUnit &&RHS) = delete;\n  void operator=(const DIEUnit &RHS) = delete;\n  void operator=(const DIEUnit &&RHS) = delete;\n  /// Set the section that this DIEUnit will be emitted into.\n  ///\n  /// This function is used by some clients to set the section. Not all clients\n  /// that emit DWARF use this section variable.\n  void setSection(MCSection *Section) {\n    assert(!this->Section);\n    this->Section = Section;\n  }\n\n  virtual const MCSymbol *getCrossSectionRelativeBaseAddress() const {\n    return nullptr;\n  }\n\n  /// Return the section that this DIEUnit will be emitted into.\n  ///\n  /// \\returns Section pointer which can be NULL.\n  MCSection *getSection() const { return Section; }\n  void setDebugSectionOffset(uint64_t O) { Offset = O; }\n  uint64_t getDebugSectionOffset() const { return Offset; }\n  DIE &getUnitDie() { return Die; }\n  const DIE &getUnitDie() const { return Die; }\n};\n\nstruct BasicDIEUnit final : DIEUnit {\n  explicit BasicDIEUnit(dwarf::Tag UnitTag) : DIEUnit(UnitTag) {}\n};\n\n//===--------------------------------------------------------------------===//\n/// DIELoc - Represents an expression location.\n//\nclass DIELoc : public DIEValueList {\n  mutable unsigned Size = 0; // Size in bytes excluding size header.\n\npublic:\n  DIELoc() = default;\n\n  /// ComputeSize - Calculate the size of the location expression.\n  ///\n  unsigned ComputeSize(const AsmPrinter *AP) const;\n\n  // TODO: move setSize() and Size to DIEValueList.\n  void setSize(unsigned size) { Size = size; }\n\n  /// BestForm - Choose the best form for data.\n  ///\n  dwarf::Form BestForm(unsigned DwarfVersion) const {\n    if (DwarfVersion > 3)\n      return dwarf::DW_FORM_exprloc;\n    // Pre-DWARF4 location expressions were blocks and not exprloc.\n    if ((unsigned char)Size == Size)\n      return dwarf::DW_FORM_block1;\n    if ((unsigned short)Size == Size)\n      return dwarf::DW_FORM_block2;\n    if ((unsigned int)Size == Size)\n      return dwarf::DW_FORM_block4;\n    return dwarf::DW_FORM_block;\n  }\n\n  void emitValue(const AsmPrinter *Asm, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n//===--------------------------------------------------------------------===//\n/// DIEBlock - Represents a block of values.\n//\nclass DIEBlock : public DIEValueList {\n  mutable unsigned Size = 0; // Size in bytes excluding size header.\n\npublic:\n  DIEBlock() = default;\n\n  /// ComputeSize - Calculate the size of the location expression.\n  ///\n  unsigned ComputeSize(const AsmPrinter *AP) const;\n\n  // TODO: move setSize() and Size to DIEValueList.\n  void setSize(unsigned size) { Size = size; }\n\n  /// BestForm - Choose the best form for data.\n  ///\n  dwarf::Form BestForm() const {\n    if ((unsigned char)Size == Size)\n      return dwarf::DW_FORM_block1;\n    if ((unsigned short)Size == Size)\n      return dwarf::DW_FORM_block2;\n    if ((unsigned int)Size == Size)\n      return dwarf::DW_FORM_block4;\n    return dwarf::DW_FORM_block;\n  }\n\n  void emitValue(const AsmPrinter *Asm, dwarf::Form Form) const;\n  unsigned SizeOf(const AsmPrinter *AP, dwarf::Form Form) const;\n\n  void print(raw_ostream &O) const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_DIE_H\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h", "content": "//===-- llvm/CodeGen/DebugHandlerBase.h -----------------------*- C++ -*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Common functionality for different debug information format backends.\n// LLVM currently supports DWARF and CodeView.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_DEBUGHANDLERBASE_H\n#define LLVM_CODEGEN_DEBUGHANDLERBASE_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/CodeGen/AsmPrinterHandler.h\"\n#include \"llvm/CodeGen/DbgEntityHistoryCalculator.h\"\n#include \"llvm/CodeGen/LexicalScopes.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/IR/DebugLoc.h\"\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass MachineInstr;\nclass MachineModuleInfo;\n\n/// Represents the location at which a variable is stored.\nstruct DbgVariableLocation {\n  /// Base register.\n  unsigned Register;\n\n  /// Chain of offsetted loads necessary to load the value if it lives in\n  /// memory. Every load except for the last is pointer-sized.\n  SmallVector<int64_t, 1> LoadChain;\n\n  /// Present if the location is part of a larger variable.\n  llvm::Optional<llvm::DIExpression::FragmentInfo> FragmentInfo;\n\n  /// Extract a VariableLocation from a MachineInstr.\n  /// This will only work if Instruction is a debug value instruction\n  /// and the associated DIExpression is in one of the supported forms.\n  /// If these requirements are not met, the returned Optional will not\n  /// have a value.\n  static Optional<DbgVariableLocation>\n  extractFromMachineInstruction(const MachineInstr &Instruction);\n};\n\n/// Base class for debug information backends. Common functionality related to\n/// tracking which variables and scopes are alive at a given PC live here.\nclass DebugHandlerBase : public AsmPrinterHandler {\nprotected:\n  DebugHandlerBase(AsmPrinter *A);\n\n  /// Target of debug info emission.\n  AsmPrinter *Asm;\n\n  /// Collected machine module information.\n  MachineModuleInfo *MMI;\n\n  /// Previous instruction's location information. This is used to\n  /// determine label location to indicate scope boundaries in debug info.\n  /// We track the previous instruction's source location (if not line 0),\n  /// whether it was a label, and its parent BB.\n  DebugLoc PrevInstLoc;\n  MCSymbol *PrevLabel = nullptr;\n  const MachineBasicBlock *PrevInstBB = nullptr;\n\n  /// This location indicates end of function prologue and beginning of\n  /// function body.\n  DebugLoc PrologEndLoc;\n\n  /// If nonnull, stores the current machine instruction we're processing.\n  const MachineInstr *CurMI = nullptr;\n\n  LexicalScopes LScopes;\n\n  /// History of DBG_VALUE and clobber instructions for each user\n  /// variable.  Variables are listed in order of appearance.\n  DbgValueHistoryMap DbgValues;\n\n  /// Mapping of inlined labels and DBG_LABEL machine instruction.\n  DbgLabelInstrMap DbgLabels;\n\n  /// Maps instruction with label emitted before instruction.\n  /// FIXME: Make this private from DwarfDebug, we have the necessary accessors\n  /// for it.\n  DenseMap<const MachineInstr *, MCSymbol *> LabelsBeforeInsn;\n\n  /// Maps instruction with label emitted after instruction.\n  DenseMap<const MachineInstr *, MCSymbol *> LabelsAfterInsn;\n\n  /// Indentify instructions that are marking the beginning of or\n  /// ending of a scope.\n  void identifyScopeMarkers();\n\n  /// Ensure that a label will be emitted before MI.\n  void requestLabelBeforeInsn(const MachineInstr *MI) {\n    LabelsBeforeInsn.insert(std::make_pair(MI, nullptr));\n  }\n\n  /// Ensure that a label will be emitted after MI.\n  void requestLabelAfterInsn(const MachineInstr *MI) {\n    LabelsAfterInsn.insert(std::make_pair(MI, nullptr));\n  }\n\n  virtual void beginFunctionImpl(const MachineFunction *MF) = 0;\n  virtual void endFunctionImpl(const MachineFunction *MF) = 0;\n  virtual void skippedNonDebugFunction() {}\n\nprivate:\n  InstructionOrdering InstOrdering;\n\n  // AsmPrinterHandler overrides.\npublic:\n  void beginModule(Module *M) override;\n\n  void beginInstruction(const MachineInstr *MI) override;\n  void endInstruction() override;\n\n  void beginFunction(const MachineFunction *MF) override;\n  void endFunction(const MachineFunction *MF) override;\n\n  void beginBasicBlock(const MachineBasicBlock &MBB) override;\n  void endBasicBlock(const MachineBasicBlock &MBB) override;\n\n  /// Return Label preceding the instruction.\n  MCSymbol *getLabelBeforeInsn(const MachineInstr *MI);\n\n  /// Return Label immediately following the instruction.\n  MCSymbol *getLabelAfterInsn(const MachineInstr *MI);\n\n  /// If this type is derived from a base type then return base type size.\n  static uint64_t getBaseTypeSize(const DIType *Ty);\n\n  /// Return true if type encoding is unsigned.\n  static bool isUnsignedDIType(const DIType *Ty);\n\n  const InstructionOrdering &getInstOrdering() const { return InstOrdering; }\n};\n\n} // namespace llvm\n\n#endif\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DwarfStringPoolEntry.h", "content": "//===- llvm/CodeGen/DwarfStringPoolEntry.h - String pool entry --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_DWARFSTRINGPOOLENTRY_H\n#define LLVM_CODEGEN_DWARFSTRINGPOOLENTRY_H\n\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/StringMap.h\"\n\nnamespace llvm {\n\nclass MCSymbol;\n\n/// Data for a string pool entry.\nstruct DwarfStringPoolEntry {\n  static constexpr unsigned NotIndexed = -1;\n\n  MCSymbol *Symbol;\n  uint64_t Offset;\n  unsigned Index;\n\n  bool isIndexed() const { return Index != NotIndexed; }\n};\n\n/// String pool entry reference.\nclass DwarfStringPoolEntryRef {\n  PointerIntPair<const StringMapEntry<DwarfStringPoolEntry> *, 1, bool>\n      MapEntryAndIndexed;\n\n  const StringMapEntry<DwarfStringPoolEntry> *getMapEntry() const {\n    return MapEntryAndIndexed.getPointer();\n  }\n\npublic:\n  DwarfStringPoolEntryRef() = default;\n  DwarfStringPoolEntryRef(const StringMapEntry<DwarfStringPoolEntry> &Entry,\n                          bool Indexed)\n      : MapEntryAndIndexed(&Entry, Indexed) {}\n\n  explicit operator bool() const { return getMapEntry(); }\n  MCSymbol *getSymbol() const {\n    assert(getMapEntry()->second.Symbol && \"No symbol available!\");\n    return getMapEntry()->second.Symbol;\n  }\n  uint64_t getOffset() const { return getMapEntry()->second.Offset; }\n  bool isIndexed() const { return MapEntryAndIndexed.getInt(); }\n  unsigned getIndex() const {\n    assert(isIndexed());\n    assert(getMapEntry()->getValue().isIndexed());\n    return getMapEntry()->second.Index;\n  }\n  StringRef getString() const { return getMapEntry()->first(); }\n  /// Return the entire string pool entry for convenience.\n  DwarfStringPoolEntry getEntry() const { return getMapEntry()->getValue(); }\n\n  bool operator==(const DwarfStringPoolEntryRef &X) const {\n    return getMapEntry() == X.getMapEntry();\n  }\n  bool operator!=(const DwarfStringPoolEntryRef &X) const {\n    return getMapEntry() != X.getMapEntry();\n  }\n};\n\n} // end namespace llvm\n\n#endif\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h", "content": "//===- llvm/CodeGen/MachineBasicBlock.h -------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Collect the sequence of machine instructions for a basic block.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEBASICBLOCK_H\n#define LLVM_CODEGEN_MACHINEBASICBLOCK_H\n\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/ADT/SparseBitVector.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/CodeGen/MachineInstrBundleIterator.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/MC/LaneBitmask.h\"\n#include \"llvm/Support/BranchProbability.h\"\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iterator>\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\nclass BasicBlock;\nclass MachineFunction;\nclass MCSymbol;\nclass ModuleSlotTracker;\nclass Pass;\nclass Printable;\nclass SlotIndexes;\nclass StringRef;\nclass raw_ostream;\nclass LiveIntervals;\nclass TargetRegisterClass;\nclass TargetRegisterInfo;\n\n// This structure uniquely identifies a basic block section.\n// Possible values are\n//  {Type: Default, Number: (unsigned)} (These are regular section IDs)\n//  {Type: Exception, Number: 0}  (ExceptionSectionID)\n//  {Type: Cold, Number: 0}  (ColdSectionID)\nstruct MBBSectionID {\n  enum SectionType {\n    Default = 0, // Regular section (these sections are distinguished by the\n                 // Number field).\n    Exception,   // Special section type for exception handling blocks\n    Cold,        // Special section type for cold blocks\n  } Type;\n  unsigned Number;\n\n  MBBSectionID(unsigned N) : Type(Default), Number(N) {}\n\n  // Special unique sections for cold and exception blocks.\n  const static MBBSectionID ColdSectionID;\n  const static MBBSectionID ExceptionSectionID;\n\n  bool operator==(const MBBSectionID &Other) const {\n    return Type == Other.Type && Number == Other.Number;\n  }\n\n  bool operator!=(const MBBSectionID &Other) const { return !(*this == Other); }\n\nprivate:\n  // This is only used to construct the special cold and exception sections.\n  MBBSectionID(SectionType T) : Type(T), Number(0) {}\n};\n\ntemplate <> struct ilist_traits<MachineInstr> {\nprivate:\n  friend class MachineBasicBlock; // Set by the owning MachineBasicBlock.\n\n  MachineBasicBlock *Parent;\n\n  using instr_iterator =\n      simple_ilist<MachineInstr, ilist_sentinel_tracking<true>>::iterator;\n\npublic:\n  void addNodeToList(MachineInstr *N);\n  void removeNodeFromList(MachineInstr *N);\n  void transferNodesFromList(ilist_traits &FromList, instr_iterator First,\n                             instr_iterator Last);\n  void deleteNode(MachineInstr *MI);\n};\n\nclass MachineBasicBlock\n    : public ilist_node_with_parent<MachineBasicBlock, MachineFunction> {\npublic:\n  /// Pair of physical register and lane mask.\n  /// This is not simply a std::pair typedef because the members should be named\n  /// clearly as they both have an integer type.\n  struct RegisterMaskPair {\n  public:\n    MCPhysReg PhysReg;\n    LaneBitmask LaneMask;\n\n    RegisterMaskPair(MCPhysReg PhysReg, LaneBitmask LaneMask)\n        : PhysReg(PhysReg), LaneMask(LaneMask) {}\n  };\n\nprivate:\n  using Instructions = ilist<MachineInstr, ilist_sentinel_tracking<true>>;\n\n  Instructions Insts;\n  const BasicBlock *BB;\n  int Number;\n  MachineFunction *xParent;\n\n  /// Keep track of the predecessor / successor basic blocks.\n  std::vector<MachineBasicBlock *> Predecessors;\n  std::vector<MachineBasicBlock *> Successors;\n\n  /// Keep track of the probabilities to the successors. This vector has the\n  /// same order as Successors, or it is empty if we don't use it (disable\n  /// optimization).\n  std::vector<BranchProbability> Probs;\n  using probability_iterator = std::vector<BranchProbability>::iterator;\n  using const_probability_iterator =\n      std::vector<BranchProbability>::const_iterator;\n\n  Optional<uint64_t> IrrLoopHeaderWeight;\n\n  /// Keep track of the physical registers that are livein of the basicblock.\n  using LiveInVector = std::vector<RegisterMaskPair>;\n  LiveInVector LiveIns;\n\n  /// Alignment of the basic block. One if the basic block does not need to be\n  /// aligned.\n  Align Alignment;\n\n  /// Indicate that this basic block is entered via an exception handler.\n  bool IsEHPad = false;\n\n  /// Indicate that this basic block is potentially the target of an indirect\n  /// branch.\n  bool AddressTaken = false;\n\n  /// Indicate that this basic block needs its symbol be emitted regardless of\n  /// whether the flow just falls-through to it.\n  bool LabelMustBeEmitted = false;\n\n  /// Indicate that this basic block is the entry block of an EH scope, i.e.,\n  /// the block that used to have a catchpad or cleanuppad instruction in the\n  /// LLVM IR.\n  bool IsEHScopeEntry = false;\n\n  /// Indicates if this is a target block of a catchret.\n  bool IsEHCatchretTarget = false;\n\n  /// Indicate that this basic block is the entry block of an EH funclet.\n  bool IsEHFuncletEntry = false;\n\n  /// Indicate that this basic block is the entry block of a cleanup funclet.\n  bool IsCleanupFuncletEntry = false;\n\n  /// With basic block sections, this stores the Section ID of the basic block.\n  MBBSectionID SectionID{0};\n\n  // Indicate that this basic block begins a section.\n  bool IsBeginSection = false;\n\n  // Indicate that this basic block ends a section.\n  bool IsEndSection = false;\n\n  /// Indicate that this basic block is the indirect dest of an INLINEASM_BR.\n  bool IsInlineAsmBrIndirectTarget = false;\n\n  /// since getSymbol is a relatively heavy-weight operation, the symbol\n  /// is only computed once and is cached.\n  mutable MCSymbol *CachedMCSymbol = nullptr;\n\n  /// Cached MCSymbol for this block (used if IsEHCatchRetTarget).\n  mutable MCSymbol *CachedEHCatchretMCSymbol = nullptr;\n\n  /// Marks the end of the basic block. Used during basic block sections to\n  /// calculate the size of the basic block, or the BB section ending with it.\n  mutable MCSymbol *CachedEndMCSymbol = nullptr;\n\n  // Intrusive list support\n  MachineBasicBlock() = default;\n\n  explicit MachineBasicBlock(MachineFunction &MF, const BasicBlock *BB);\n\n  ~MachineBasicBlock();\n\n  // MachineBasicBlocks are allocated and owned by MachineFunction.\n  friend class MachineFunction;\n\npublic:\n  /// Return the LLVM basic block that this instance corresponded to originally.\n  /// Note that this may be NULL if this instance does not correspond directly\n  /// to an LLVM basic block.\n  const BasicBlock *getBasicBlock() const { return BB; }\n\n  /// Return the name of the corresponding LLVM basic block, or an empty string.\n  StringRef getName() const;\n\n  /// Return a formatted string to identify this block and its parent function.\n  std::string getFullName() const;\n\n  /// Test whether this block is potentially the target of an indirect branch.\n  bool hasAddressTaken() const { return AddressTaken; }\n\n  /// Set this block to reflect that it potentially is the target of an indirect\n  /// branch.\n  void setHasAddressTaken() { AddressTaken = true; }\n\n  /// Test whether this block must have its label emitted.\n  bool hasLabelMustBeEmitted() const { return LabelMustBeEmitted; }\n\n  /// Set this block to reflect that, regardless how we flow to it, we need\n  /// its label be emitted.\n  void setLabelMustBeEmitted() { LabelMustBeEmitted = true; }\n\n  /// Return the MachineFunction containing this basic block.\n  const MachineFunction *getParent() const { return xParent; }\n  MachineFunction *getParent() { return xParent; }\n\n  using instr_iterator = Instructions::iterator;\n  using const_instr_iterator = Instructions::const_iterator;\n  using reverse_instr_iterator = Instructions::reverse_iterator;\n  using const_reverse_instr_iterator = Instructions::const_reverse_iterator;\n\n  using iterator = MachineInstrBundleIterator<MachineInstr>;\n  using const_iterator = MachineInstrBundleIterator<const MachineInstr>;\n  using reverse_iterator = MachineInstrBundleIterator<MachineInstr, true>;\n  using const_reverse_iterator =\n      MachineInstrBundleIterator<const MachineInstr, true>;\n\n  unsigned size() const { return (unsigned)Insts.size(); }\n  bool empty() const { return Insts.empty(); }\n\n  MachineInstr       &instr_front()       { return Insts.front(); }\n  MachineInstr       &instr_back()        { return Insts.back();  }\n  const MachineInstr &instr_front() const { return Insts.front(); }\n  const MachineInstr &instr_back()  const { return Insts.back();  }\n\n  MachineInstr       &front()             { return Insts.front(); }\n  MachineInstr       &back()              { return *--end();      }\n  const MachineInstr &front()       const { return Insts.front(); }\n  const MachineInstr &back()        const { return *--end();      }\n\n  instr_iterator                instr_begin()       { return Insts.begin();  }\n  const_instr_iterator          instr_begin() const { return Insts.begin();  }\n  instr_iterator                  instr_end()       { return Insts.end();    }\n  const_instr_iterator            instr_end() const { return Insts.end();    }\n  reverse_instr_iterator       instr_rbegin()       { return Insts.rbegin(); }\n  const_reverse_instr_iterator instr_rbegin() const { return Insts.rbegin(); }\n  reverse_instr_iterator       instr_rend  ()       { return Insts.rend();   }\n  const_reverse_instr_iterator instr_rend  () const { return Insts.rend();   }\n\n  using instr_range = iterator_range<instr_iterator>;\n  using const_instr_range = iterator_range<const_instr_iterator>;\n  instr_range instrs() { return instr_range(instr_begin(), instr_end()); }\n  const_instr_range instrs() const {\n    return const_instr_range(instr_begin(), instr_end());\n  }\n\n  iterator                begin()       { return instr_begin();  }\n  const_iterator          begin() const { return instr_begin();  }\n  iterator                end  ()       { return instr_end();    }\n  const_iterator          end  () const { return instr_end();    }\n  reverse_iterator rbegin() {\n    return reverse_iterator::getAtBundleBegin(instr_rbegin());\n  }\n  const_reverse_iterator rbegin() const {\n    return const_reverse_iterator::getAtBundleBegin(instr_rbegin());\n  }\n  reverse_iterator rend() { return reverse_iterator(instr_rend()); }\n  const_reverse_iterator rend() const {\n    return const_reverse_iterator(instr_rend());\n  }\n\n  /// Support for MachineInstr::getNextNode().\n  static Instructions MachineBasicBlock::*getSublistAccess(MachineInstr *) {\n    return &MachineBasicBlock::Insts;\n  }\n\n  inline iterator_range<iterator> terminators() {\n    return make_range(getFirstTerminator(), end());\n  }\n  inline iterator_range<const_iterator> terminators() const {\n    return make_range(getFirstTerminator(), end());\n  }\n\n  /// Returns a range that iterates over the phis in the basic block.\n  inline iterator_range<iterator> phis() {\n    return make_range(begin(), getFirstNonPHI());\n  }\n  inline iterator_range<const_iterator> phis() const {\n    return const_cast<MachineBasicBlock *>(this)->phis();\n  }\n\n  // Machine-CFG iterators\n  using pred_iterator = std::vector<MachineBasicBlock *>::iterator;\n  using const_pred_iterator = std::vector<MachineBasicBlock *>::const_iterator;\n  using succ_iterator = std::vector<MachineBasicBlock *>::iterator;\n  using const_succ_iterator = std::vector<MachineBasicBlock *>::const_iterator;\n  using pred_reverse_iterator =\n      std::vector<MachineBasicBlock *>::reverse_iterator;\n  using const_pred_reverse_iterator =\n      std::vector<MachineBasicBlock *>::const_reverse_iterator;\n  using succ_reverse_iterator =\n      std::vector<MachineBasicBlock *>::reverse_iterator;\n  using const_succ_reverse_iterator =\n      std::vector<MachineBasicBlock *>::const_reverse_iterator;\n  pred_iterator        pred_begin()       { return Predecessors.begin(); }\n  const_pred_iterator  pred_begin() const { return Predecessors.begin(); }\n  pred_iterator        pred_end()         { return Predecessors.end();   }\n  const_pred_iterator  pred_end()   const { return Predecessors.end();   }\n  pred_reverse_iterator        pred_rbegin()\n                                          { return Predecessors.rbegin();}\n  const_pred_reverse_iterator  pred_rbegin() const\n                                          { return Predecessors.rbegin();}\n  pred_reverse_iterator        pred_rend()\n                                          { return Predecessors.rend();  }\n  const_pred_reverse_iterator  pred_rend()   const\n                                          { return Predecessors.rend();  }\n  unsigned             pred_size()  const {\n    return (unsigned)Predecessors.size();\n  }\n  bool                 pred_empty() const { return Predecessors.empty(); }\n  succ_iterator        succ_begin()       { return Successors.begin();   }\n  const_succ_iterator  succ_begin() const { return Successors.begin();   }\n  succ_iterator        succ_end()         { return Successors.end();     }\n  const_succ_iterator  succ_end()   const { return Successors.end();     }\n  succ_reverse_iterator        succ_rbegin()\n                                          { return Successors.rbegin();  }\n  const_succ_reverse_iterator  succ_rbegin() const\n                                          { return Successors.rbegin();  }\n  succ_reverse_iterator        succ_rend()\n                                          { return Successors.rend();    }\n  const_succ_reverse_iterator  succ_rend()   const\n                                          { return Successors.rend();    }\n  unsigned             succ_size()  const {\n    return (unsigned)Successors.size();\n  }\n  bool                 succ_empty() const { return Successors.empty();   }\n\n  inline iterator_range<pred_iterator> predecessors() {\n    return make_range(pred_begin(), pred_end());\n  }\n  inline iterator_range<const_pred_iterator> predecessors() const {\n    return make_range(pred_begin(), pred_end());\n  }\n  inline iterator_range<succ_iterator> successors() {\n    return make_range(succ_begin(), succ_end());\n  }\n  inline iterator_range<const_succ_iterator> successors() const {\n    return make_range(succ_begin(), succ_end());\n  }\n\n  // LiveIn management methods.\n\n  /// Adds the specified register as a live in. Note that it is an error to add\n  /// the same register to the same set more than once unless the intention is\n  /// to call sortUniqueLiveIns after all registers are added.\n  void addLiveIn(MCRegister PhysReg,\n                 LaneBitmask LaneMask = LaneBitmask::getAll()) {\n    LiveIns.push_back(RegisterMaskPair(PhysReg, LaneMask));\n  }\n  void addLiveIn(const RegisterMaskPair &RegMaskPair) {\n    LiveIns.push_back(RegMaskPair);\n  }\n\n  /// Sorts and uniques the LiveIns vector. It can be significantly faster to do\n  /// this than repeatedly calling isLiveIn before calling addLiveIn for every\n  /// LiveIn insertion.\n  void sortUniqueLiveIns();\n\n  /// Clear live in list.\n  void clearLiveIns();\n\n  /// Add PhysReg as live in to this block, and ensure that there is a copy of\n  /// PhysReg to a virtual register of class RC. Return the virtual register\n  /// that is a copy of the live in PhysReg.\n  Register addLiveIn(MCRegister PhysReg, const TargetRegisterClass *RC);\n\n  /// Remove the specified register from the live in set.\n  void removeLiveIn(MCPhysReg Reg,\n                    LaneBitmask LaneMask = LaneBitmask::getAll());\n\n  /// Return true if the specified register is in the live in set.\n  bool isLiveIn(MCPhysReg Reg,\n                LaneBitmask LaneMask = LaneBitmask::getAll()) const;\n\n  // Iteration support for live in sets.  These sets are kept in sorted\n  // order by their register number.\n  using livein_iterator = LiveInVector::const_iterator;\n#ifndef NDEBUG\n  /// Unlike livein_begin, this method does not check that the liveness\n  /// information is accurate. Still for debug purposes it may be useful\n  /// to have iterators that won't assert if the liveness information\n  /// is not current.\n  livein_iterator livein_begin_dbg() const { return LiveIns.begin(); }\n  iterator_range<livein_iterator> liveins_dbg() const {\n    return make_range(livein_begin_dbg(), livein_end());\n  }\n#endif\n  livein_iterator livein_begin() const;\n  livein_iterator livein_end()   const { return LiveIns.end(); }\n  bool            livein_empty() const { return LiveIns.empty(); }\n  iterator_range<livein_iterator> liveins() const {\n    return make_range(livein_begin(), livein_end());\n  }\n\n  /// Remove entry from the livein set and return iterator to the next.\n  livein_iterator removeLiveIn(livein_iterator I);\n\n  /// Get the clobber mask for the start of this basic block. Funclets use this\n  /// to prevent register allocation across funclet transitions.\n  const uint32_t *getBeginClobberMask(const TargetRegisterInfo *TRI) const;\n\n  /// Get the clobber mask for the end of the basic block.\n  /// \\see getBeginClobberMask()\n  const uint32_t *getEndClobberMask(const TargetRegisterInfo *TRI) const;\n\n  /// Return alignment of the basic block.\n  Align getAlignment() const { return Alignment; }\n\n  /// Set alignment of the basic block.\n  void setAlignment(Align A) { Alignment = A; }\n\n  /// Returns true if the block is a landing pad. That is this basic block is\n  /// entered via an exception handler.\n  bool isEHPad() const { return IsEHPad; }\n\n  /// Indicates the block is a landing pad.  That is this basic block is entered\n  /// via an exception handler.\n  void setIsEHPad(bool V = true) { IsEHPad = V; }\n\n  bool hasEHPadSuccessor() const;\n\n  /// Returns true if this is the entry block of the function.\n  bool isEntryBlock() const;\n\n  /// Returns true if this is the entry block of an EH scope, i.e., the block\n  /// that used to have a catchpad or cleanuppad instruction in the LLVM IR.\n  bool isEHScopeEntry() const { return IsEHScopeEntry; }\n\n  /// Indicates if this is the entry block of an EH scope, i.e., the block that\n  /// that used to have a catchpad or cleanuppad instruction in the LLVM IR.\n  void setIsEHScopeEntry(bool V = true) { IsEHScopeEntry = V; }\n\n  /// Returns true if this is a target block of a catchret.\n  bool isEHCatchretTarget() const { return IsEHCatchretTarget; }\n\n  /// Indicates if this is a target block of a catchret.\n  void setIsEHCatchretTarget(bool V = true) { IsEHCatchretTarget = V; }\n\n  /// Returns true if this is the entry block of an EH funclet.\n  bool isEHFuncletEntry() const { return IsEHFuncletEntry; }\n\n  /// Indicates if this is the entry block of an EH funclet.\n  void setIsEHFuncletEntry(bool V = true) { IsEHFuncletEntry = V; }\n\n  /// Returns true if this is the entry block of a cleanup funclet.\n  bool isCleanupFuncletEntry() const { return IsCleanupFuncletEntry; }\n\n  /// Indicates if this is the entry block of a cleanup funclet.\n  void setIsCleanupFuncletEntry(bool V = true) { IsCleanupFuncletEntry = V; }\n\n  /// Returns true if this block begins any section.\n  bool isBeginSection() const { return IsBeginSection; }\n\n  /// Returns true if this block ends any section.\n  bool isEndSection() const { return IsEndSection; }\n\n  void setIsBeginSection(bool V = true) { IsBeginSection = V; }\n\n  void setIsEndSection(bool V = true) { IsEndSection = V; }\n\n  /// Returns the section ID of this basic block.\n  MBBSectionID getSectionID() const { return SectionID; }\n\n  /// Returns the unique section ID number of this basic block.\n  unsigned getSectionIDNum() const {\n    return ((unsigned)MBBSectionID::SectionType::Cold) -\n           ((unsigned)SectionID.Type) + SectionID.Number;\n  }\n\n  /// Sets the section ID for this basic block.\n  void setSectionID(MBBSectionID V) { SectionID = V; }\n\n  /// Returns the MCSymbol marking the end of this basic block.\n  MCSymbol *getEndSymbol() const;\n\n  /// Returns true if this block may have an INLINEASM_BR (overestimate, by\n  /// checking if any of the successors are indirect targets of any inlineasm_br\n  /// in the function).\n  bool mayHaveInlineAsmBr() const;\n\n  /// Returns true if this is the indirect dest of an INLINEASM_BR.\n  bool isInlineAsmBrIndirectTarget() const {\n    return IsInlineAsmBrIndirectTarget;\n  }\n\n  /// Indicates if this is the indirect dest of an INLINEASM_BR.\n  void setIsInlineAsmBrIndirectTarget(bool V = true) {\n    IsInlineAsmBrIndirectTarget = V;\n  }\n\n  /// Returns true if it is legal to hoist instructions into this block.\n  bool isLegalToHoistInto() const;\n\n  // Code Layout methods.\n\n  /// Move 'this' block before or after the specified block.  This only moves\n  /// the block, it does not modify the CFG or adjust potential fall-throughs at\n  /// the end of the block.\n  void moveBefore(MachineBasicBlock *NewAfter);\n  void moveAfter(MachineBasicBlock *NewBefore);\n\n  /// Returns true if this and MBB belong to the same section.\n  bool sameSection(const MachineBasicBlock *MBB) const {\n    return getSectionID() == MBB->getSectionID();\n  }\n\n  /// Update the terminator instructions in block to account for changes to\n  /// block layout which may have been made. PreviousLayoutSuccessor should be\n  /// set to the block which may have been used as fallthrough before the block\n  /// layout was modified.  If the block previously fell through to that block,\n  /// it may now need a branch. If it previously branched to another block, it\n  /// may now be able to fallthrough to the current layout successor.\n  void updateTerminator(MachineBasicBlock *PreviousLayoutSuccessor);\n\n  // Machine-CFG mutators\n\n  /// Add Succ as a successor of this MachineBasicBlock.  The Predecessors list\n  /// of Succ is automatically updated. PROB parameter is stored in\n  /// Probabilities list. The default probability is set as unknown. Mixing\n  /// known and unknown probabilities in successor list is not allowed. When all\n  /// successors have unknown probabilities, 1 / N is returned as the\n  /// probability for each successor, where N is the number of successors.\n  ///\n  /// Note that duplicate Machine CFG edges are not allowed.\n  void addSuccessor(MachineBasicBlock *Succ,\n                    BranchProbability Prob = BranchProbability::getUnknown());\n\n  /// Add Succ as a successor of this MachineBasicBlock.  The Predecessors list\n  /// of Succ is automatically updated. The probability is not provided because\n  /// BPI is not available (e.g. -O0 is used), in which case edge probabilities\n  /// won't be used. Using this interface can save some space.\n  void addSuccessorWithoutProb(MachineBasicBlock *Succ);\n\n  /// Set successor probability of a given iterator.\n  void setSuccProbability(succ_iterator I, BranchProbability Prob);\n\n  /// Normalize probabilities of all successors so that the sum of them becomes\n  /// one. This is usually done when the current update on this MBB is done, and\n  /// the sum of its successors' probabilities is not guaranteed to be one. The\n  /// user is responsible for the correct use of this function.\n  /// MBB::removeSuccessor() has an option to do this automatically.\n  void normalizeSuccProbs() {\n    BranchProbability::normalizeProbabilities(Probs.begin(), Probs.end());\n  }\n\n  /// Validate successors' probabilities and check if the sum of them is\n  /// approximate one. This only works in DEBUG mode.\n  void validateSuccProbs() const;\n\n  /// Remove successor from the successors list of this MachineBasicBlock. The\n  /// Predecessors list of Succ is automatically updated.\n  /// If NormalizeSuccProbs is true, then normalize successors' probabilities\n  /// after the successor is removed.\n  void removeSuccessor(MachineBasicBlock *Succ,\n                       bool NormalizeSuccProbs = false);\n\n  /// Remove specified successor from the successors list of this\n  /// MachineBasicBlock. The Predecessors list of Succ is automatically updated.\n  /// If NormalizeSuccProbs is true, then normalize successors' probabilities\n  /// after the successor is removed.\n  /// Return the iterator to the element after the one removed.\n  succ_iterator removeSuccessor(succ_iterator I,\n                                bool NormalizeSuccProbs = false);\n\n  /// Replace successor OLD with NEW and update probability info.\n  void replaceSuccessor(MachineBasicBlock *Old, MachineBasicBlock *New);\n\n  /// Copy a successor (and any probability info) from original block to this\n  /// block's. Uses an iterator into the original blocks successors.\n  ///\n  /// This is useful when doing a partial clone of successors. Afterward, the\n  /// probabilities may need to be normalized.\n  void copySuccessor(MachineBasicBlock *Orig, succ_iterator I);\n\n  /// Split the old successor into old plus new and updates the probability\n  /// info.\n  void splitSuccessor(MachineBasicBlock *Old, MachineBasicBlock *New,\n                      bool NormalizeSuccProbs = false);\n\n  /// Transfers all the successors from MBB to this machine basic block (i.e.,\n  /// copies all the successors FromMBB and remove all the successors from\n  /// FromMBB).\n  void transferSuccessors(MachineBasicBlock *FromMBB);\n\n  /// Transfers all the successors, as in transferSuccessors, and update PHI\n  /// operands in the successor blocks which refer to FromMBB to refer to this.\n  void transferSuccessorsAndUpdatePHIs(MachineBasicBlock *FromMBB);\n\n  /// move all pseudo probes in this block to the end of /c ToMBB To and tag\n  /// them dangling.\n  void moveAndDanglePseudoProbes(MachineBasicBlock *ToMBB);\n\n  /// Return true if any of the successors have probabilities attached to them.\n  bool hasSuccessorProbabilities() const { return !Probs.empty(); }\n\n  /// Return true if the specified MBB is a predecessor of this block.\n  bool isPredecessor(const MachineBasicBlock *MBB) const;\n\n  /// Return true if the specified MBB is a successor of this block.\n  bool isSuccessor(const MachineBasicBlock *MBB) const;\n\n  /// Return true if the specified MBB will be emitted immediately after this\n  /// block, such that if this block exits by falling through, control will\n  /// transfer to the specified MBB. Note that MBB need not be a successor at\n  /// all, for example if this block ends with an unconditional branch to some\n  /// other block.\n  bool isLayoutSuccessor(const MachineBasicBlock *MBB) const;\n\n  /// Return the fallthrough block if the block can implicitly\n  /// transfer control to the block after it by falling off the end of\n  /// it.  This should return null if it can reach the block after\n  /// it, but it uses an explicit branch to do so (e.g., a table\n  /// jump).  Non-null return  is a conservative answer.\n  MachineBasicBlock *getFallThrough();\n\n  /// Return true if the block can implicitly transfer control to the\n  /// block after it by falling off the end of it.  This should return\n  /// false if it can reach the block after it, but it uses an\n  /// explicit branch to do so (e.g., a table jump).  True is a\n  /// conservative answer.\n  bool canFallThrough();\n\n  /// Returns a pointer to the first instruction in this block that is not a\n  /// PHINode instruction. When adding instructions to the beginning of the\n  /// basic block, they should be added before the returned value, not before\n  /// the first instruction, which might be PHI.\n  /// Returns end() is there's no non-PHI instruction.\n  iterator getFirstNonPHI();\n\n  /// Return the first instruction in MBB after I that is not a PHI or a label.\n  /// This is the correct point to insert lowered copies at the beginning of a\n  /// basic block that must be before any debugging information.\n  iterator SkipPHIsAndLabels(iterator I);\n\n  /// Return the first instruction in MBB after I that is not a PHI, label or\n  /// debug.  This is the correct point to insert copies at the beginning of a\n  /// basic block.\n  iterator SkipPHIsLabelsAndDebug(iterator I);\n\n  /// Returns an iterator to the first terminator instruction of this basic\n  /// block. If a terminator does not exist, it returns end().\n  iterator getFirstTerminator();\n  const_iterator getFirstTerminator() const {\n    return const_cast<MachineBasicBlock *>(this)->getFirstTerminator();\n  }\n\n  /// Same getFirstTerminator but it ignores bundles and return an\n  /// instr_iterator instead.\n  instr_iterator getFirstInstrTerminator();\n\n  /// Returns an iterator to the first non-debug instruction in the basic block,\n  /// or end(). Skip any pseudo probe operation if \\c SkipPseudoOp is true.\n  /// Pseudo probes are like debug instructions which do not turn into real\n  /// machine code. We try to use the function to skip both debug instructions\n  /// and pseudo probe operations to avoid API proliferation. This should work\n  /// most of the time when considering optimizing the rest of code in the\n  /// block, except for certain cases where pseudo probes are designed to block\n  /// the optimizations. For example, code merge like optimizations are supposed\n  /// to be blocked by pseudo probes for better AutoFDO profile quality.\n  /// Therefore, they should be considered as a valid instruction when this\n  /// function is called in a context of such optimizations. On the other hand,\n  /// \\c SkipPseudoOp should be true when it's used in optimizations that\n  /// unlikely hurt profile quality, e.g., without block merging.\n  /// TODO: flip the default value of \\c SkipPseudoOp to maximize code quality\n  /// with pseudo probes.\n  iterator getFirstNonDebugInstr(bool SkipPseudoOp = false);\n  const_iterator getFirstNonDebugInstr(bool SkipPseudoOp = false) const {\n    return const_cast<MachineBasicBlock *>(this)->getFirstNonDebugInstr(\n        SkipPseudoOp);\n  }\n\n  /// Returns an iterator to the last non-debug instruction in the basic block,\n  /// or end(). Skip any pseudo operation if \\c SkipPseudoOp is true.\n  /// Pseudo probes are like debug instructions which do not turn into real\n  /// machine code. We try to use the function to skip both debug instructions\n  /// and pseudo probe operations to avoid API proliferation. This should work\n  /// most of the time when considering optimizing the rest of code in the\n  /// block, except for certain cases where pseudo probes are designed to block\n  /// the optimizations. For example, code merge like optimizations are supposed\n  /// to be blocked by pseudo probes for better AutoFDO profile quality.\n  /// Therefore, they should be considered as a valid instruction when this\n  /// function is called in a context of such optimizations. On the other hand,\n  /// \\c SkipPseudoOp should be true when it's used in optimizations that\n  /// unlikely hurt profile quality, e.g., without block merging.\n  iterator getLastNonDebugInstr(bool SkipPseudoOp = false);\n  const_iterator getLastNonDebugInstr(bool SkipPseudoOp = false) const {\n    return const_cast<MachineBasicBlock *>(this)->getLastNonDebugInstr(\n        SkipPseudoOp);\n  }\n\n  /// Convenience function that returns true if the block ends in a return\n  /// instruction.\n  bool isReturnBlock() const {\n    return !empty() && back().isReturn();\n  }\n\n  /// Convenience function that returns true if the bock ends in a EH scope\n  /// return instruction.\n  bool isEHScopeReturnBlock() const {\n    return !empty() && back().isEHScopeReturn();\n  }\n\n  /// Split a basic block into 2 pieces at \\p SplitPoint. A new block will be\n  /// inserted after this block, and all instructions after \\p SplitInst moved\n  /// to it (\\p SplitInst will be in the original block). If \\p LIS is provided,\n  /// LiveIntervals will be appropriately updated. \\return the newly inserted\n  /// block.\n  ///\n  /// If \\p UpdateLiveIns is true, this will ensure the live ins list is\n  /// accurate, including for physreg uses/defs in the original block.\n  MachineBasicBlock *splitAt(MachineInstr &SplitInst, bool UpdateLiveIns = true,\n                             LiveIntervals *LIS = nullptr);\n\n  /// Split the critical edge from this block to the given successor block, and\n  /// return the newly created block, or null if splitting is not possible.\n  ///\n  /// This function updates LiveVariables, MachineDominatorTree, and\n  /// MachineLoopInfo, as applicable.\n  MachineBasicBlock *\n  SplitCriticalEdge(MachineBasicBlock *Succ, Pass &P,\n                    std::vector<SparseBitVector<>> *LiveInSets = nullptr);\n\n  /// Check if the edge between this block and the given successor \\p\n  /// Succ, can be split. If this returns true a subsequent call to\n  /// SplitCriticalEdge is guaranteed to return a valid basic block if\n  /// no changes occurred in the meantime.\n  bool canSplitCriticalEdge(const MachineBasicBlock *Succ) const;\n\n  void pop_front() { Insts.pop_front(); }\n  void pop_back() { Insts.pop_back(); }\n  void push_back(MachineInstr *MI) { Insts.push_back(MI); }\n\n  /// Insert MI into the instruction list before I, possibly inside a bundle.\n  ///\n  /// If the insertion point is inside a bundle, MI will be added to the bundle,\n  /// otherwise MI will not be added to any bundle. That means this function\n  /// alone can't be used to prepend or append instructions to bundles. See\n  /// MIBundleBuilder::insert() for a more reliable way of doing that.\n  instr_iterator insert(instr_iterator I, MachineInstr *M);\n\n  /// Insert a range of instructions into the instruction list before I.\n  template<typename IT>\n  void insert(iterator I, IT S, IT E) {\n    assert((I == end() || I->getParent() == this) &&\n           \"iterator points outside of basic block\");\n    Insts.insert(I.getInstrIterator(), S, E);\n  }\n\n  /// Insert MI into the instruction list before I.\n  iterator insert(iterator I, MachineInstr *MI) {\n    assert((I == end() || I->getParent() == this) &&\n           \"iterator points outside of basic block\");\n    assert(!MI->isBundledWithPred() && !MI->isBundledWithSucc() &&\n           \"Cannot insert instruction with bundle flags\");\n    return Insts.insert(I.getInstrIterator(), MI);\n  }\n\n  /// Insert MI into the instruction list after I.\n  iterator insertAfter(iterator I, MachineInstr *MI) {\n    assert((I == end() || I->getParent() == this) &&\n           \"iterator points outside of basic block\");\n    assert(!MI->isBundledWithPred() && !MI->isBundledWithSucc() &&\n           \"Cannot insert instruction with bundle flags\");\n    return Insts.insertAfter(I.getInstrIterator(), MI);\n  }\n\n  /// If I is bundled then insert MI into the instruction list after the end of\n  /// the bundle, otherwise insert MI immediately after I.\n  instr_iterator insertAfterBundle(instr_iterator I, MachineInstr *MI) {\n    assert((I == instr_end() || I->getParent() == this) &&\n           \"iterator points outside of basic block\");\n    assert(!MI->isBundledWithPred() && !MI->isBundledWithSucc() &&\n           \"Cannot insert instruction with bundle flags\");\n    while (I->isBundledWithSucc())\n      ++I;\n    return Insts.insertAfter(I, MI);\n  }\n\n  /// Remove an instruction from the instruction list and delete it.\n  ///\n  /// If the instruction is part of a bundle, the other instructions in the\n  /// bundle will still be bundled after removing the single instruction.\n  instr_iterator erase(instr_iterator I);\n\n  /// Remove an instruction from the instruction list and delete it.\n  ///\n  /// If the instruction is part of a bundle, the other instructions in the\n  /// bundle will still be bundled after removing the single instruction.\n  instr_iterator erase_instr(MachineInstr *I) {\n    return erase(instr_iterator(I));\n  }\n\n  /// Remove a range of instructions from the instruction list and delete them.\n  iterator erase(iterator I, iterator E) {\n    return Insts.erase(I.getInstrIterator(), E.getInstrIterator());\n  }\n\n  /// Remove an instruction or bundle from the instruction list and delete it.\n  ///\n  /// If I points to a bundle of instructions, they are all erased.\n  iterator erase(iterator I) {\n    return erase(I, std::next(I));\n  }\n\n  /// Remove an instruction from the instruction list and delete it.\n  ///\n  /// If I is the head of a bundle of instructions, the whole bundle will be\n  /// erased.\n  iterator erase(MachineInstr *I) {\n    return erase(iterator(I));\n  }\n\n  /// Remove the unbundled instruction from the instruction list without\n  /// deleting it.\n  ///\n  /// This function can not be used to remove bundled instructions, use\n  /// remove_instr to remove individual instructions from a bundle.\n  MachineInstr *remove(MachineInstr *I) {\n    assert(!I->isBundled() && \"Cannot remove bundled instructions\");\n    return Insts.remove(instr_iterator(I));\n  }\n\n  /// Remove the possibly bundled instruction from the instruction list\n  /// without deleting it.\n  ///\n  /// If the instruction is part of a bundle, the other instructions in the\n  /// bundle will still be bundled after removing the single instruction.\n  MachineInstr *remove_instr(MachineInstr *I);\n\n  void clear() {\n    Insts.clear();\n  }\n\n  /// Take an instruction from MBB 'Other' at the position From, and insert it\n  /// into this MBB right before 'Where'.\n  ///\n  /// If From points to a bundle of instructions, the whole bundle is moved.\n  void splice(iterator Where, MachineBasicBlock *Other, iterator From) {\n    // The range splice() doesn't allow noop moves, but this one does.\n    if (Where != From)\n      splice(Where, Other, From, std::next(From));\n  }\n\n  /// Take a block of instructions from MBB 'Other' in the range [From, To),\n  /// and insert them into this MBB right before 'Where'.\n  ///\n  /// The instruction at 'Where' must not be included in the range of\n  /// instructions to move.\n  void splice(iterator Where, MachineBasicBlock *Other,\n              iterator From, iterator To) {\n    Insts.splice(Where.getInstrIterator(), Other->Insts,\n                 From.getInstrIterator(), To.getInstrIterator());\n  }\n\n  /// This method unlinks 'this' from the containing function, and returns it,\n  /// but does not delete it.\n  MachineBasicBlock *removeFromParent();\n\n  /// This method unlinks 'this' from the containing function and deletes it.\n  void eraseFromParent();\n\n  /// Given a machine basic block that branched to 'Old', change the code and\n  /// CFG so that it branches to 'New' instead.\n  void ReplaceUsesOfBlockWith(MachineBasicBlock *Old, MachineBasicBlock *New);\n\n  /// Update all phi nodes in this basic block to refer to basic block \\p New\n  /// instead of basic block \\p Old.\n  void replacePhiUsesWith(MachineBasicBlock *Old, MachineBasicBlock *New);\n\n  /// Find the next valid DebugLoc starting at MBBI, skipping any DBG_VALUE\n  /// and DBG_LABEL instructions.  Return UnknownLoc if there is none.\n  DebugLoc findDebugLoc(instr_iterator MBBI);\n  DebugLoc findDebugLoc(iterator MBBI) {\n    return findDebugLoc(MBBI.getInstrIterator());\n  }\n\n  /// Has exact same behavior as @ref findDebugLoc (it also\n  /// searches from the first to the last MI of this MBB) except\n  /// that this takes reverse iterator.\n  DebugLoc rfindDebugLoc(reverse_instr_iterator MBBI);\n  DebugLoc rfindDebugLoc(reverse_iterator MBBI) {\n    return rfindDebugLoc(MBBI.getInstrIterator());\n  }\n\n  /// Find the previous valid DebugLoc preceding MBBI, skipping and DBG_VALUE\n  /// instructions.  Return UnknownLoc if there is none.\n  DebugLoc findPrevDebugLoc(instr_iterator MBBI);\n  DebugLoc findPrevDebugLoc(iterator MBBI) {\n    return findPrevDebugLoc(MBBI.getInstrIterator());\n  }\n\n  /// Has exact same behavior as @ref findPrevDebugLoc (it also\n  /// searches from the last to the first MI of this MBB) except\n  /// that this takes reverse iterator.\n  DebugLoc rfindPrevDebugLoc(reverse_instr_iterator MBBI);\n  DebugLoc rfindPrevDebugLoc(reverse_iterator MBBI) {\n    return rfindPrevDebugLoc(MBBI.getInstrIterator());\n  }\n\n  /// Find and return the merged DebugLoc of the branch instructions of the\n  /// block. Return UnknownLoc if there is none.\n  DebugLoc findBranchDebugLoc();\n\n  /// Possible outcome of a register liveness query to computeRegisterLiveness()\n  enum LivenessQueryResult {\n    LQR_Live,   ///< Register is known to be (at least partially) live.\n    LQR_Dead,   ///< Register is known to be fully dead.\n    LQR_Unknown ///< Register liveness not decidable from local neighborhood.\n  };\n\n  /// Return whether (physical) register \\p Reg has been defined and not\n  /// killed as of just before \\p Before.\n  ///\n  /// Search is localised to a neighborhood of \\p Neighborhood instructions\n  /// before (searching for defs or kills) and \\p Neighborhood instructions\n  /// after (searching just for defs) \\p Before.\n  ///\n  /// \\p Reg must be a physical register.\n  LivenessQueryResult computeRegisterLiveness(const TargetRegisterInfo *TRI,\n                                              MCRegister Reg,\n                                              const_iterator Before,\n                                              unsigned Neighborhood = 10) const;\n\n  // Debugging methods.\n  void dump() const;\n  void print(raw_ostream &OS, const SlotIndexes * = nullptr,\n             bool IsStandalone = true) const;\n  void print(raw_ostream &OS, ModuleSlotTracker &MST,\n             const SlotIndexes * = nullptr, bool IsStandalone = true) const;\n\n  enum PrintNameFlag {\n    PrintNameIr = (1 << 0), ///< Add IR name where available\n    PrintNameAttributes = (1 << 1), ///< Print attributes\n  };\n\n  void printName(raw_ostream &os, unsigned printNameFlags = PrintNameIr,\n                 ModuleSlotTracker *moduleSlotTracker = nullptr) const;\n\n  // Printing method used by LoopInfo.\n  void printAsOperand(raw_ostream &OS, bool PrintType = true) const;\n\n  /// MachineBasicBlocks are uniquely numbered at the function level, unless\n  /// they're not in a MachineFunction yet, in which case this will return -1.\n  int getNumber() const { return Number; }\n  void setNumber(int N) { Number = N; }\n\n  /// Return the MCSymbol for this basic block.\n  MCSymbol *getSymbol() const;\n\n  /// Return the EHCatchret Symbol for this basic block.\n  MCSymbol *getEHCatchretSymbol() const;\n\n  Optional<uint64_t> getIrrLoopHeaderWeight() const {\n    return IrrLoopHeaderWeight;\n  }\n\n  void setIrrLoopHeaderWeight(uint64_t Weight) {\n    IrrLoopHeaderWeight = Weight;\n  }\n\nprivate:\n  /// Return probability iterator corresponding to the I successor iterator.\n  probability_iterator getProbabilityIterator(succ_iterator I);\n  const_probability_iterator\n  getProbabilityIterator(const_succ_iterator I) const;\n\n  friend class MachineBranchProbabilityInfo;\n  friend class MIPrinter;\n\n  /// Return probability of the edge from this block to MBB. This method should\n  /// NOT be called directly, but by using getEdgeProbability method from\n  /// MachineBranchProbabilityInfo class.\n  BranchProbability getSuccProbability(const_succ_iterator Succ) const;\n\n  // Methods used to maintain doubly linked list of blocks...\n  friend struct ilist_callback_traits<MachineBasicBlock>;\n\n  // Machine-CFG mutators\n\n  /// Add Pred as a predecessor of this MachineBasicBlock. Don't do this\n  /// unless you know what you're doing, because it doesn't update Pred's\n  /// successors list. Use Pred->addSuccessor instead.\n  void addPredecessor(MachineBasicBlock *Pred);\n\n  /// Remove Pred as a predecessor of this MachineBasicBlock. Don't do this\n  /// unless you know what you're doing, because it doesn't update Pred's\n  /// successors list. Use Pred->removeSuccessor instead.\n  void removePredecessor(MachineBasicBlock *Pred);\n};\n\nraw_ostream& operator<<(raw_ostream &OS, const MachineBasicBlock &MBB);\n\n/// Prints a machine basic block reference.\n///\n/// The format is:\n///   %bb.5           - a machine basic block with MBB.getNumber() == 5.\n///\n/// Usage: OS << printMBBReference(MBB) << '\\n';\nPrintable printMBBReference(const MachineBasicBlock &MBB);\n\n// This is useful when building IndexedMaps keyed on basic block pointers.\nstruct MBB2NumberFunctor {\n  using argument_type = const MachineBasicBlock *;\n  unsigned operator()(const MachineBasicBlock *MBB) const {\n    return MBB->getNumber();\n  }\n};\n\n//===--------------------------------------------------------------------===//\n// GraphTraits specializations for machine basic block graphs (machine-CFGs)\n//===--------------------------------------------------------------------===//\n\n// Provide specializations of GraphTraits to be able to treat a\n// MachineFunction as a graph of MachineBasicBlocks.\n//\n\ntemplate <> struct GraphTraits<MachineBasicBlock *> {\n  using NodeRef = MachineBasicBlock *;\n  using ChildIteratorType = MachineBasicBlock::succ_iterator;\n\n  static NodeRef getEntryNode(MachineBasicBlock *BB) { return BB; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->succ_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->succ_end(); }\n};\n\ntemplate <> struct GraphTraits<const MachineBasicBlock *> {\n  using NodeRef = const MachineBasicBlock *;\n  using ChildIteratorType = MachineBasicBlock::const_succ_iterator;\n\n  static NodeRef getEntryNode(const MachineBasicBlock *BB) { return BB; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->succ_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->succ_end(); }\n};\n\n// Provide specializations of GraphTraits to be able to treat a\n// MachineFunction as a graph of MachineBasicBlocks and to walk it\n// in inverse order.  Inverse order for a function is considered\n// to be when traversing the predecessor edges of a MBB\n// instead of the successor edges.\n//\ntemplate <> struct GraphTraits<Inverse<MachineBasicBlock*>> {\n  using NodeRef = MachineBasicBlock *;\n  using ChildIteratorType = MachineBasicBlock::pred_iterator;\n\n  static NodeRef getEntryNode(Inverse<MachineBasicBlock *> G) {\n    return G.Graph;\n  }\n\n  static ChildIteratorType child_begin(NodeRef N) { return N->pred_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->pred_end(); }\n};\n\ntemplate <> struct GraphTraits<Inverse<const MachineBasicBlock*>> {\n  using NodeRef = const MachineBasicBlock *;\n  using ChildIteratorType = MachineBasicBlock::const_pred_iterator;\n\n  static NodeRef getEntryNode(Inverse<const MachineBasicBlock *> G) {\n    return G.Graph;\n  }\n\n  static ChildIteratorType child_begin(NodeRef N) { return N->pred_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->pred_end(); }\n};\n\n/// MachineInstrSpan provides an interface to get an iteration range\n/// containing the instruction it was initialized with, along with all\n/// those instructions inserted prior to or following that instruction\n/// at some point after the MachineInstrSpan is constructed.\nclass MachineInstrSpan {\n  MachineBasicBlock &MBB;\n  MachineBasicBlock::iterator I, B, E;\n\npublic:\n  MachineInstrSpan(MachineBasicBlock::iterator I, MachineBasicBlock *BB)\n      : MBB(*BB), I(I), B(I == MBB.begin() ? MBB.end() : std::prev(I)),\n        E(std::next(I)) {\n    assert(I == BB->end() || I->getParent() == BB);\n  }\n\n  MachineBasicBlock::iterator begin() {\n    return B == MBB.end() ? MBB.begin() : std::next(B);\n  }\n  MachineBasicBlock::iterator end() { return E; }\n  bool empty() { return begin() == end(); }\n\n  MachineBasicBlock::iterator getInitial() { return I; }\n};\n\n/// Increment \\p It until it points to a non-debug instruction or to \\p End\n/// and return the resulting iterator. This function should only be used\n/// MachineBasicBlock::{iterator, const_iterator, instr_iterator,\n/// const_instr_iterator} and the respective reverse iterators.\ntemplate <typename IterT>\ninline IterT skipDebugInstructionsForward(IterT It, IterT End,\n                                          bool SkipPseudoOp = false) {\n  while (It != End &&\n         (It->isDebugInstr() || (SkipPseudoOp && It->isPseudoProbe())))\n    ++It;\n  return It;\n}\n\n/// Decrement \\p It until it points to a non-debug instruction or to \\p Begin\n/// and return the resulting iterator. This function should only be used\n/// MachineBasicBlock::{iterator, const_iterator, instr_iterator,\n/// const_instr_iterator} and the respective reverse iterators.\ntemplate <class IterT>\ninline IterT skipDebugInstructionsBackward(IterT It, IterT Begin,\n                                           bool SkipPseudoOp = false) {\n  while (It != Begin &&\n         (It->isDebugInstr() || (SkipPseudoOp && It->isPseudoProbe())))\n    --It;\n  return It;\n}\n\n/// Increment \\p It, then continue incrementing it while it points to a debug\n/// instruction. A replacement for std::next.\ntemplate <typename IterT>\ninline IterT next_nodbg(IterT It, IterT End, bool SkipPseudoOp = false) {\n  return skipDebugInstructionsForward(std::next(It), End, SkipPseudoOp);\n}\n\n/// Decrement \\p It, then continue decrementing it while it points to a debug\n/// instruction. A replacement for std::prev.\ntemplate <typename IterT>\ninline IterT prev_nodbg(IterT It, IterT Begin, bool SkipPseudoOp = false) {\n  return skipDebugInstructionsBackward(std::prev(It), Begin, SkipPseudoOp);\n}\n\n/// Construct a range iterator which begins at \\p It and moves forwards until\n/// \\p End is reached, skipping any debug instructions.\ntemplate <typename IterT>\ninline auto instructionsWithoutDebug(IterT It, IterT End,\n                                     bool SkipPseudoOp = false) {\n  return make_filter_range(make_range(It, End), [=](const MachineInstr &MI) {\n    return !MI.isDebugInstr() && !(SkipPseudoOp && MI.isPseudoProbe());\n  });\n}\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_MACHINEBASICBLOCK_H\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h", "content": "//===- llvm/CodeGen/MachineFunction.h ---------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Collect native machine code for a function.  This class contains a list of\n// MachineBasicBlock instances that make up the current compiled function.\n//\n// This class also contains pointers to various classes which hold\n// target-specific information about the generated code.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEFUNCTION_H\n#define LLVM_CODEGEN_MACHINEFUNCTION_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Analysis/EHPersonalities.h\"\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/CodeGen/MachineMemOperand.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/ArrayRecycler.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Recycler.h\"\n#include \"llvm/Target/TargetOptions.h\"\n#include <cassert>\n#include <cstdint>\n#include <memory>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass BasicBlock;\nclass BlockAddress;\nclass DataLayout;\nclass DebugLoc;\nstruct DenormalMode;\nclass DIExpression;\nclass DILocalVariable;\nclass DILocation;\nclass Function;\nclass GISelChangeObserver;\nclass GlobalValue;\nclass LLVMTargetMachine;\nclass MachineConstantPool;\nclass MachineFrameInfo;\nclass MachineFunction;\nclass MachineJumpTableInfo;\nclass MachineModuleInfo;\nclass MachineRegisterInfo;\nclass MCContext;\nclass MCInstrDesc;\nclass MCSymbol;\nclass MCSection;\nclass Pass;\nclass PseudoSourceValueManager;\nclass raw_ostream;\nclass SlotIndexes;\nclass StringRef;\nclass TargetRegisterClass;\nclass TargetSubtargetInfo;\nstruct WasmEHFuncInfo;\nstruct WinEHFuncInfo;\n\ntemplate <> struct ilist_alloc_traits<MachineBasicBlock> {\n  void deleteNode(MachineBasicBlock *MBB);\n};\n\ntemplate <> struct ilist_callback_traits<MachineBasicBlock> {\n  void addNodeToList(MachineBasicBlock* N);\n  void removeNodeFromList(MachineBasicBlock* N);\n\n  template <class Iterator>\n  void transferNodesFromList(ilist_callback_traits &OldList, Iterator, Iterator) {\n    assert(this == &OldList && \"never transfer MBBs between functions\");\n  }\n};\n\n/// MachineFunctionInfo - This class can be derived from and used by targets to\n/// hold private target-specific information for each MachineFunction.  Objects\n/// of type are accessed/created with MF::getInfo and destroyed when the\n/// MachineFunction is destroyed.\nstruct MachineFunctionInfo {\n  virtual ~MachineFunctionInfo();\n\n  /// Factory function: default behavior is to call new using the\n  /// supplied allocator.\n  ///\n  /// This function can be overridden in a derive class.\n  template<typename Ty>\n  static Ty *create(BumpPtrAllocator &Allocator, MachineFunction &MF) {\n    return new (Allocator.Allocate<Ty>()) Ty(MF);\n  }\n};\n\n/// Properties which a MachineFunction may have at a given point in time.\n/// Each of these has checking code in the MachineVerifier, and passes can\n/// require that a property be set.\nclass MachineFunctionProperties {\n  // Possible TODO: Allow targets to extend this (perhaps by allowing the\n  // constructor to specify the size of the bit vector)\n  // Possible TODO: Allow requiring the negative (e.g. VRegsAllocated could be\n  // stated as the negative of \"has vregs\"\n\npublic:\n  // The properties are stated in \"positive\" form; i.e. a pass could require\n  // that the property hold, but not that it does not hold.\n\n  // Property descriptions:\n  // IsSSA: True when the machine function is in SSA form and virtual registers\n  //  have a single def.\n  // NoPHIs: The machine function does not contain any PHI instruction.\n  // TracksLiveness: True when tracking register liveness accurately.\n  //  While this property is set, register liveness information in basic block\n  //  live-in lists and machine instruction operands (e.g. kill flags, implicit\n  //  defs) is accurate. This means it can be used to change the code in ways\n  //  that affect the values in registers, for example by the register\n  //  scavenger.\n  //  When this property is clear, liveness is no longer reliable.\n  // NoVRegs: The machine function does not use any virtual registers.\n  // Legalized: In GlobalISel: the MachineLegalizer ran and all pre-isel generic\n  //  instructions have been legalized; i.e., all instructions are now one of:\n  //   - generic and always legal (e.g., COPY)\n  //   - target-specific\n  //   - legal pre-isel generic instructions.\n  // RegBankSelected: In GlobalISel: the RegBankSelect pass ran and all generic\n  //  virtual registers have been assigned to a register bank.\n  // Selected: In GlobalISel: the InstructionSelect pass ran and all pre-isel\n  //  generic instructions have been eliminated; i.e., all instructions are now\n  //  target-specific or non-pre-isel generic instructions (e.g., COPY).\n  //  Since only pre-isel generic instructions can have generic virtual register\n  //  operands, this also means that all generic virtual registers have been\n  //  constrained to virtual registers (assigned to register classes) and that\n  //  all sizes attached to them have been eliminated.\n  // TiedOpsRewritten: The twoaddressinstruction pass will set this flag, it\n  //  means that tied-def have been rewritten to meet the RegConstraint.\n  enum class Property : unsigned {\n    IsSSA,\n    NoPHIs,\n    TracksLiveness,\n    NoVRegs,\n    FailedISel,\n    Legalized,\n    RegBankSelected,\n    Selected,\n    TiedOpsRewritten,\n    LastProperty = TiedOpsRewritten,\n  };\n\n  bool hasProperty(Property P) const {\n    return Properties[static_cast<unsigned>(P)];\n  }\n\n  MachineFunctionProperties &set(Property P) {\n    Properties.set(static_cast<unsigned>(P));\n    return *this;\n  }\n\n  MachineFunctionProperties &reset(Property P) {\n    Properties.reset(static_cast<unsigned>(P));\n    return *this;\n  }\n\n  /// Reset all the properties.\n  MachineFunctionProperties &reset() {\n    Properties.reset();\n    return *this;\n  }\n\n  MachineFunctionProperties &set(const MachineFunctionProperties &MFP) {\n    Properties |= MFP.Properties;\n    return *this;\n  }\n\n  MachineFunctionProperties &reset(const MachineFunctionProperties &MFP) {\n    Properties.reset(MFP.Properties);\n    return *this;\n  }\n\n  // Returns true if all properties set in V (i.e. required by a pass) are set\n  // in this.\n  bool verifyRequiredProperties(const MachineFunctionProperties &V) const {\n    return !V.Properties.test(Properties);\n  }\n\n  /// Print the MachineFunctionProperties in human-readable form.\n  void print(raw_ostream &OS) const;\n\nprivate:\n  BitVector Properties =\n      BitVector(static_cast<unsigned>(Property::LastProperty)+1);\n};\n\nstruct SEHHandler {\n  /// Filter or finally function. Null indicates a catch-all.\n  const Function *FilterOrFinally;\n\n  /// Address of block to recover at. Null for a finally handler.\n  const BlockAddress *RecoverBA;\n};\n\n/// This structure is used to retain landing pad info for the current function.\nstruct LandingPadInfo {\n  MachineBasicBlock *LandingPadBlock;      // Landing pad block.\n  SmallVector<MCSymbol *, 1> BeginLabels;  // Labels prior to invoke.\n  SmallVector<MCSymbol *, 1> EndLabels;    // Labels after invoke.\n  SmallVector<SEHHandler, 1> SEHHandlers;  // SEH handlers active at this lpad.\n  MCSymbol *LandingPadLabel = nullptr;     // Label at beginning of landing pad.\n  std::vector<int> TypeIds;                // List of type ids (filters negative).\n\n  explicit LandingPadInfo(MachineBasicBlock *MBB)\n      : LandingPadBlock(MBB) {}\n};\n\nclass MachineFunction {\n  Function &F;\n  const LLVMTargetMachine &Target;\n  const TargetSubtargetInfo *STI;\n  MCContext &Ctx;\n  MachineModuleInfo &MMI;\n\n  // RegInfo - Information about each register in use in the function.\n  MachineRegisterInfo *RegInfo;\n\n  // Used to keep track of target-specific per-machine function information for\n  // the target implementation.\n  MachineFunctionInfo *MFInfo;\n\n  // Keep track of objects allocated on the stack.\n  MachineFrameInfo *FrameInfo;\n\n  // Keep track of constants which are spilled to memory\n  MachineConstantPool *ConstantPool;\n\n  // Keep track of jump tables for switch instructions\n  MachineJumpTableInfo *JumpTableInfo;\n\n  // Keep track of the function section.\n  MCSection *Section = nullptr;\n\n  // Keeps track of Wasm exception handling related data. This will be null for\n  // functions that aren't using a wasm EH personality.\n  WasmEHFuncInfo *WasmEHInfo = nullptr;\n\n  // Keeps track of Windows exception handling related data. This will be null\n  // for functions that aren't using a funclet-based EH personality.\n  WinEHFuncInfo *WinEHInfo = nullptr;\n\n  // Function-level unique numbering for MachineBasicBlocks.  When a\n  // MachineBasicBlock is inserted into a MachineFunction is it automatically\n  // numbered and this vector keeps track of the mapping from ID's to MBB's.\n  std::vector<MachineBasicBlock*> MBBNumbering;\n\n  // Unary encoding of basic block symbols is used to reduce size of \".strtab\".\n  // Basic block number 'i' gets a prefix of length 'i'.  The ith character also\n  // denotes the type of basic block number 'i'.  Return blocks are marked with\n  // 'r', landing pads with 'l' and regular blocks with 'a'.\n  std::vector<char> BBSectionsSymbolPrefix;\n\n  // Pool-allocate MachineFunction-lifetime and IR objects.\n  BumpPtrAllocator Allocator;\n\n  // Allocation management for instructions in function.\n  Recycler<MachineInstr> InstructionRecycler;\n\n  // Allocation management for operand arrays on instructions.\n  ArrayRecycler<MachineOperand> OperandRecycler;\n\n  // Allocation management for basic blocks in function.\n  Recycler<MachineBasicBlock> BasicBlockRecycler;\n\n  // List of machine basic blocks in function\n  using BasicBlockListType = ilist<MachineBasicBlock>;\n  BasicBlockListType BasicBlocks;\n\n  /// FunctionNumber - This provides a unique ID for each function emitted in\n  /// this translation unit.\n  ///\n  unsigned FunctionNumber;\n\n  /// Alignment - The alignment of the function.\n  Align Alignment;\n\n  /// ExposesReturnsTwice - True if the function calls setjmp or related\n  /// functions with attribute \"returns twice\", but doesn't have\n  /// the attribute itself.\n  /// This is used to limit optimizations which cannot reason\n  /// about the control flow of such functions.\n  bool ExposesReturnsTwice = false;\n\n  /// True if the function includes any inline assembly.\n  bool HasInlineAsm = false;\n\n  /// True if any WinCFI instruction have been emitted in this function.\n  bool HasWinCFI = false;\n\n  /// Current high-level properties of the IR of the function (e.g. is in SSA\n  /// form or whether registers have been allocated)\n  MachineFunctionProperties Properties;\n\n  // Allocation management for pseudo source values.\n  std::unique_ptr<PseudoSourceValueManager> PSVManager;\n\n  /// List of moves done by a function's prolog.  Used to construct frame maps\n  /// by debug and exception handling consumers.\n  std::vector<MCCFIInstruction> FrameInstructions;\n\n  /// List of basic blocks immediately following calls to _setjmp. Used to\n  /// construct a table of valid longjmp targets for Windows Control Flow Guard.\n  std::vector<MCSymbol *> LongjmpTargets;\n\n  /// List of basic blocks that are the target of catchrets. Used to construct\n  /// a table of valid targets for Windows EHCont Guard.\n  std::vector<MCSymbol *> CatchretTargets;\n\n  /// \\name Exception Handling\n  /// \\{\n\n  /// List of LandingPadInfo describing the landing pad information.\n  std::vector<LandingPadInfo> LandingPads;\n\n  /// Map a landing pad's EH symbol to the call site indexes.\n  DenseMap<MCSymbol*, SmallVector<unsigned, 4>> LPadToCallSiteMap;\n\n  /// Map a landing pad to its index.\n  DenseMap<const MachineBasicBlock *, unsigned> WasmLPadToIndexMap;\n\n  /// Map of invoke call site index values to associated begin EH_LABEL.\n  DenseMap<MCSymbol*, unsigned> CallSiteMap;\n\n  /// CodeView label annotations.\n  std::vector<std::pair<MCSymbol *, MDNode *>> CodeViewAnnotations;\n\n  bool CallsEHReturn = false;\n  bool CallsUnwindInit = false;\n  bool HasEHCatchret = false;\n  bool HasEHScopes = false;\n  bool HasEHFunclets = false;\n\n  /// Section Type for basic blocks, only relevant with basic block sections.\n  BasicBlockSection BBSectionsType = BasicBlockSection::None;\n\n  /// List of C++ TypeInfo used.\n  std::vector<const GlobalValue *> TypeInfos;\n\n  /// List of typeids encoding filters used.\n  std::vector<unsigned> FilterIds;\n\n  /// List of the indices in FilterIds corresponding to filter terminators.\n  std::vector<unsigned> FilterEnds;\n\n  EHPersonality PersonalityTypeCache = EHPersonality::Unknown;\n\n  /// \\}\n\n  /// Clear all the members of this MachineFunction, but the ones used\n  /// to initialize again the MachineFunction.\n  /// More specifically, this deallocates all the dynamically allocated\n  /// objects and get rid of all the XXXInfo data structure, but keep\n  /// unchanged the references to Fn, Target, MMI, and FunctionNumber.\n  void clear();\n  /// Allocate and initialize the different members.\n  /// In particular, the XXXInfo data structure.\n  /// \\pre Fn, Target, MMI, and FunctionNumber are properly set.\n  void init();\n\npublic:\n  struct VariableDbgInfo {\n    const DILocalVariable *Var;\n    const DIExpression *Expr;\n    // The Slot can be negative for fixed stack objects.\n    int Slot;\n    const DILocation *Loc;\n\n    VariableDbgInfo(const DILocalVariable *Var, const DIExpression *Expr,\n                    int Slot, const DILocation *Loc)\n        : Var(Var), Expr(Expr), Slot(Slot), Loc(Loc) {}\n  };\n\n  class Delegate {\n    virtual void anchor();\n\n  public:\n    virtual ~Delegate() = default;\n    /// Callback after an insertion. This should not modify the MI directly.\n    virtual void MF_HandleInsertion(MachineInstr &MI) = 0;\n    /// Callback before a removal. This should not modify the MI directly.\n    virtual void MF_HandleRemoval(MachineInstr &MI) = 0;\n  };\n\n  /// Structure used to represent pair of argument number after call lowering\n  /// and register used to transfer that argument.\n  /// For now we support only cases when argument is transferred through one\n  /// register.\n  struct ArgRegPair {\n    Register Reg;\n    uint16_t ArgNo;\n    ArgRegPair(Register R, unsigned Arg) : Reg(R), ArgNo(Arg) {\n      assert(Arg < (1 << 16) && \"Arg out of range\");\n    }\n  };\n  /// Vector of call argument and its forwarding register.\n  using CallSiteInfo = SmallVector<ArgRegPair, 1>;\n  using CallSiteInfoImpl = SmallVectorImpl<ArgRegPair>;\n\nprivate:\n  Delegate *TheDelegate = nullptr;\n  GISelChangeObserver *Observer = nullptr;\n\n  using CallSiteInfoMap = DenseMap<const MachineInstr *, CallSiteInfo>;\n  /// Map a call instruction to call site arguments forwarding info.\n  CallSiteInfoMap CallSitesInfo;\n\n  /// A helper function that returns call site info for a give call\n  /// instruction if debug entry value support is enabled.\n  CallSiteInfoMap::iterator getCallSiteInfo(const MachineInstr *MI);\n\n  // Callbacks for insertion and removal.\n  void handleInsertion(MachineInstr &MI);\n  void handleRemoval(MachineInstr &MI);\n  friend struct ilist_traits<MachineInstr>;\n\npublic:\n  using VariableDbgInfoMapTy = SmallVector<VariableDbgInfo, 4>;\n  VariableDbgInfoMapTy VariableDbgInfos;\n\n  /// A count of how many instructions in the function have had numbers\n  /// assigned to them. Used for debug value tracking, to determine the\n  /// next instruction number.\n  unsigned DebugInstrNumberingCount = 0;\n\n  /// Set value of DebugInstrNumberingCount field. Avoid using this unless\n  /// you're deserializing this data.\n  void setDebugInstrNumberingCount(unsigned Num);\n\n  /// Pair of instruction number and operand number.\n  using DebugInstrOperandPair = std::pair<unsigned, unsigned>;\n\n  /// Substitution map: from one <inst,operand> pair to another. Used to\n  /// record changes in where a value is defined, so that debug variable\n  /// locations can find it later.\n  std::map<DebugInstrOperandPair, DebugInstrOperandPair>\n      DebugValueSubstitutions;\n\n  /// Create a substitution between one <instr,operand> value to a different,\n  /// new value.\n  void makeDebugValueSubstitution(DebugInstrOperandPair, DebugInstrOperandPair);\n\n  /// Create substitutions for any tracked values in \\p Old, to point at\n  /// \\p New. Needed when we re-create an instruction during optimization,\n  /// which has the same signature (i.e., def operands in the same place) but\n  /// a modified instruction type, flags, or otherwise. An example: X86 moves\n  /// are sometimes transformed into equivalent LEAs.\n  /// If the two instructions are not the same opcode, limit which operands to\n  /// examine for substitutions to the first N operands by setting\n  /// \\p MaxOperand.\n  void substituteDebugValuesForInst(const MachineInstr &Old, MachineInstr &New,\n                                    unsigned MaxOperand = UINT_MAX);\n\n  MachineFunction(Function &F, const LLVMTargetMachine &Target,\n                  const TargetSubtargetInfo &STI, unsigned FunctionNum,\n                  MachineModuleInfo &MMI);\n  MachineFunction(const MachineFunction &) = delete;\n  MachineFunction &operator=(const MachineFunction &) = delete;\n  ~MachineFunction();\n\n  /// Reset the instance as if it was just created.\n  void reset() {\n    clear();\n    init();\n  }\n\n  /// Reset the currently registered delegate - otherwise assert.\n  void resetDelegate(Delegate *delegate) {\n    assert(TheDelegate == delegate &&\n           \"Only the current delegate can perform reset!\");\n    TheDelegate = nullptr;\n  }\n\n  /// Set the delegate. resetDelegate must be called before attempting\n  /// to set.\n  void setDelegate(Delegate *delegate) {\n    assert(delegate && !TheDelegate &&\n           \"Attempted to set delegate to null, or to change it without \"\n           \"first resetting it!\");\n\n    TheDelegate = delegate;\n  }\n\n  void setObserver(GISelChangeObserver *O) { Observer = O; }\n\n  GISelChangeObserver *getObserver() const { return Observer; }\n\n  MachineModuleInfo &getMMI() const { return MMI; }\n  MCContext &getContext() const { return Ctx; }\n\n  /// Returns the Section this function belongs to.\n  MCSection *getSection() const { return Section; }\n\n  /// Indicates the Section this function belongs to.\n  void setSection(MCSection *S) { Section = S; }\n\n  PseudoSourceValueManager &getPSVManager() const { return *PSVManager; }\n\n  /// Return the DataLayout attached to the Module associated to this MF.\n  const DataLayout &getDataLayout() const;\n\n  /// Return the LLVM function that this machine code represents\n  Function &getFunction() { return F; }\n\n  /// Return the LLVM function that this machine code represents\n  const Function &getFunction() const { return F; }\n\n  /// getName - Return the name of the corresponding LLVM function.\n  StringRef getName() const;\n\n  /// getFunctionNumber - Return a unique ID for the current function.\n  unsigned getFunctionNumber() const { return FunctionNumber; }\n\n  /// Returns true if this function has basic block sections enabled.\n  bool hasBBSections() const {\n    return (BBSectionsType == BasicBlockSection::All ||\n            BBSectionsType == BasicBlockSection::List ||\n            BBSectionsType == BasicBlockSection::Preset);\n  }\n\n  /// Returns true if basic block labels are to be generated for this function.\n  bool hasBBLabels() const {\n    return BBSectionsType == BasicBlockSection::Labels;\n  }\n\n  void setBBSectionsType(BasicBlockSection V) { BBSectionsType = V; }\n\n  /// Assign IsBeginSection IsEndSection fields for basic blocks in this\n  /// function.\n  void assignBeginEndSections();\n\n  /// getTarget - Return the target machine this machine code is compiled with\n  const LLVMTargetMachine &getTarget() const { return Target; }\n\n  /// getSubtarget - Return the subtarget for which this machine code is being\n  /// compiled.\n  const TargetSubtargetInfo &getSubtarget() const { return *STI; }\n\n  /// getSubtarget - This method returns a pointer to the specified type of\n  /// TargetSubtargetInfo.  In debug builds, it verifies that the object being\n  /// returned is of the correct type.\n  template<typename STC> const STC &getSubtarget() const {\n    return *static_cast<const STC *>(STI);\n  }\n\n  /// getRegInfo - Return information about the registers currently in use.\n  MachineRegisterInfo &getRegInfo() { return *RegInfo; }\n  const MachineRegisterInfo &getRegInfo() const { return *RegInfo; }\n\n  /// getFrameInfo - Return the frame info object for the current function.\n  /// This object contains information about objects allocated on the stack\n  /// frame of the current function in an abstract way.\n  MachineFrameInfo &getFrameInfo() { return *FrameInfo; }\n  const MachineFrameInfo &getFrameInfo() const { return *FrameInfo; }\n\n  /// getJumpTableInfo - Return the jump table info object for the current\n  /// function.  This object contains information about jump tables in the\n  /// current function.  If the current function has no jump tables, this will\n  /// return null.\n  const MachineJumpTableInfo *getJumpTableInfo() const { return JumpTableInfo; }\n  MachineJumpTableInfo *getJumpTableInfo() { return JumpTableInfo; }\n\n  /// getOrCreateJumpTableInfo - Get the JumpTableInfo for this function, if it\n  /// does already exist, allocate one.\n  MachineJumpTableInfo *getOrCreateJumpTableInfo(unsigned JTEntryKind);\n\n  /// getConstantPool - Return the constant pool object for the current\n  /// function.\n  MachineConstantPool *getConstantPool() { return ConstantPool; }\n  const MachineConstantPool *getConstantPool() const { return ConstantPool; }\n\n  /// getWasmEHFuncInfo - Return information about how the current function uses\n  /// Wasm exception handling. Returns null for functions that don't use wasm\n  /// exception handling.\n  const WasmEHFuncInfo *getWasmEHFuncInfo() const { return WasmEHInfo; }\n  WasmEHFuncInfo *getWasmEHFuncInfo() { return WasmEHInfo; }\n\n  /// getWinEHFuncInfo - Return information about how the current function uses\n  /// Windows exception handling. Returns null for functions that don't use\n  /// funclets for exception handling.\n  const WinEHFuncInfo *getWinEHFuncInfo() const { return WinEHInfo; }\n  WinEHFuncInfo *getWinEHFuncInfo() { return WinEHInfo; }\n\n  /// getAlignment - Return the alignment of the function.\n  Align getAlignment() const { return Alignment; }\n\n  /// setAlignment - Set the alignment of the function.\n  void setAlignment(Align A) { Alignment = A; }\n\n  /// ensureAlignment - Make sure the function is at least A bytes aligned.\n  void ensureAlignment(Align A) {\n    if (Alignment < A)\n      Alignment = A;\n  }\n\n  /// exposesReturnsTwice - Returns true if the function calls setjmp or\n  /// any other similar functions with attribute \"returns twice\" without\n  /// having the attribute itself.\n  bool exposesReturnsTwice() const {\n    return ExposesReturnsTwice;\n  }\n\n  /// setCallsSetJmp - Set a flag that indicates if there's a call to\n  /// a \"returns twice\" function.\n  void setExposesReturnsTwice(bool B) {\n    ExposesReturnsTwice = B;\n  }\n\n  /// Returns true if the function contains any inline assembly.\n  bool hasInlineAsm() const {\n    return HasInlineAsm;\n  }\n\n  /// Set a flag that indicates that the function contains inline assembly.\n  void setHasInlineAsm(bool B) {\n    HasInlineAsm = B;\n  }\n\n  bool hasWinCFI() const {\n    return HasWinCFI;\n  }\n  void setHasWinCFI(bool v) { HasWinCFI = v; }\n\n  /// True if this function needs frame moves for debug or exceptions.\n  bool needsFrameMoves() const;\n\n  /// Get the function properties\n  const MachineFunctionProperties &getProperties() const { return Properties; }\n  MachineFunctionProperties &getProperties() { return Properties; }\n\n  /// getInfo - Keep track of various per-function pieces of information for\n  /// backends that would like to do so.\n  ///\n  template<typename Ty>\n  Ty *getInfo() {\n    if (!MFInfo)\n      MFInfo = Ty::template create<Ty>(Allocator, *this);\n    return static_cast<Ty*>(MFInfo);\n  }\n\n  template<typename Ty>\n  const Ty *getInfo() const {\n     return const_cast<MachineFunction*>(this)->getInfo<Ty>();\n  }\n\n  /// Returns the denormal handling type for the default rounding mode of the\n  /// function.\n  DenormalMode getDenormalMode(const fltSemantics &FPType) const;\n\n  /// getBlockNumbered - MachineBasicBlocks are automatically numbered when they\n  /// are inserted into the machine function.  The block number for a machine\n  /// basic block can be found by using the MBB::getNumber method, this method\n  /// provides the inverse mapping.\n  MachineBasicBlock *getBlockNumbered(unsigned N) const {\n    assert(N < MBBNumbering.size() && \"Illegal block number\");\n    assert(MBBNumbering[N] && \"Block was removed from the machine function!\");\n    return MBBNumbering[N];\n  }\n\n  /// Should we be emitting segmented stack stuff for the function\n  bool shouldSplitStack() const;\n\n  /// getNumBlockIDs - Return the number of MBB ID's allocated.\n  unsigned getNumBlockIDs() const { return (unsigned)MBBNumbering.size(); }\n\n  /// RenumberBlocks - This discards all of the MachineBasicBlock numbers and\n  /// recomputes them.  This guarantees that the MBB numbers are sequential,\n  /// dense, and match the ordering of the blocks within the function.  If a\n  /// specific MachineBasicBlock is specified, only that block and those after\n  /// it are renumbered.\n  void RenumberBlocks(MachineBasicBlock *MBBFrom = nullptr);\n\n  /// print - Print out the MachineFunction in a format suitable for debugging\n  /// to the specified stream.\n  void print(raw_ostream &OS, const SlotIndexes* = nullptr) const;\n\n  /// viewCFG - This function is meant for use from the debugger.  You can just\n  /// say 'call F->viewCFG()' and a ghostview window should pop up from the\n  /// program, displaying the CFG of the current function with the code for each\n  /// basic block inside.  This depends on there being a 'dot' and 'gv' program\n  /// in your path.\n  void viewCFG() const;\n\n  /// viewCFGOnly - This function is meant for use from the debugger.  It works\n  /// just like viewCFG, but it does not include the contents of basic blocks\n  /// into the nodes, just the label.  If you are only interested in the CFG\n  /// this can make the graph smaller.\n  ///\n  void viewCFGOnly() const;\n\n  /// dump - Print the current MachineFunction to cerr, useful for debugger use.\n  void dump() const;\n\n  /// Run the current MachineFunction through the machine code verifier, useful\n  /// for debugger use.\n  /// \\returns true if no problems were found.\n  bool verify(Pass *p = nullptr, const char *Banner = nullptr,\n              bool AbortOnError = true) const;\n\n  // Provide accessors for the MachineBasicBlock list...\n  using iterator = BasicBlockListType::iterator;\n  using const_iterator = BasicBlockListType::const_iterator;\n  using const_reverse_iterator = BasicBlockListType::const_reverse_iterator;\n  using reverse_iterator = BasicBlockListType::reverse_iterator;\n\n  /// Support for MachineBasicBlock::getNextNode().\n  static BasicBlockListType MachineFunction::*\n  getSublistAccess(MachineBasicBlock *) {\n    return &MachineFunction::BasicBlocks;\n  }\n\n  /// addLiveIn - Add the specified physical register as a live-in value and\n  /// create a corresponding virtual register for it.\n  Register addLiveIn(MCRegister PReg, const TargetRegisterClass *RC);\n\n  //===--------------------------------------------------------------------===//\n  // BasicBlock accessor functions.\n  //\n  iterator                 begin()       { return BasicBlocks.begin(); }\n  const_iterator           begin() const { return BasicBlocks.begin(); }\n  iterator                 end  ()       { return BasicBlocks.end();   }\n  const_iterator           end  () const { return BasicBlocks.end();   }\n\n  reverse_iterator        rbegin()       { return BasicBlocks.rbegin(); }\n  const_reverse_iterator  rbegin() const { return BasicBlocks.rbegin(); }\n  reverse_iterator        rend  ()       { return BasicBlocks.rend();   }\n  const_reverse_iterator  rend  () const { return BasicBlocks.rend();   }\n\n  unsigned                  size() const { return (unsigned)BasicBlocks.size();}\n  bool                     empty() const { return BasicBlocks.empty(); }\n  const MachineBasicBlock &front() const { return BasicBlocks.front(); }\n        MachineBasicBlock &front()       { return BasicBlocks.front(); }\n  const MachineBasicBlock & back() const { return BasicBlocks.back(); }\n        MachineBasicBlock & back()       { return BasicBlocks.back(); }\n\n  void push_back (MachineBasicBlock *MBB) { BasicBlocks.push_back (MBB); }\n  void push_front(MachineBasicBlock *MBB) { BasicBlocks.push_front(MBB); }\n  void insert(iterator MBBI, MachineBasicBlock *MBB) {\n    BasicBlocks.insert(MBBI, MBB);\n  }\n  void splice(iterator InsertPt, iterator MBBI) {\n    BasicBlocks.splice(InsertPt, BasicBlocks, MBBI);\n  }\n  void splice(iterator InsertPt, MachineBasicBlock *MBB) {\n    BasicBlocks.splice(InsertPt, BasicBlocks, MBB);\n  }\n  void splice(iterator InsertPt, iterator MBBI, iterator MBBE) {\n    BasicBlocks.splice(InsertPt, BasicBlocks, MBBI, MBBE);\n  }\n\n  void remove(iterator MBBI) { BasicBlocks.remove(MBBI); }\n  void remove(MachineBasicBlock *MBBI) { BasicBlocks.remove(MBBI); }\n  void erase(iterator MBBI) { BasicBlocks.erase(MBBI); }\n  void erase(MachineBasicBlock *MBBI) { BasicBlocks.erase(MBBI); }\n\n  template <typename Comp>\n  void sort(Comp comp) {\n    BasicBlocks.sort(comp);\n  }\n\n  /// Return the number of \\p MachineInstrs in this \\p MachineFunction.\n  unsigned getInstructionCount() const {\n    unsigned InstrCount = 0;\n    for (const MachineBasicBlock &MBB : BasicBlocks)\n      InstrCount += MBB.size();\n    return InstrCount;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Internal functions used to automatically number MachineBasicBlocks\n\n  /// Adds the MBB to the internal numbering. Returns the unique number\n  /// assigned to the MBB.\n  unsigned addToMBBNumbering(MachineBasicBlock *MBB) {\n    MBBNumbering.push_back(MBB);\n    return (unsigned)MBBNumbering.size()-1;\n  }\n\n  /// removeFromMBBNumbering - Remove the specific machine basic block from our\n  /// tracker, this is only really to be used by the MachineBasicBlock\n  /// implementation.\n  void removeFromMBBNumbering(unsigned N) {\n    assert(N < MBBNumbering.size() && \"Illegal basic block #\");\n    MBBNumbering[N] = nullptr;\n  }\n\n  /// CreateMachineInstr - Allocate a new MachineInstr. Use this instead\n  /// of `new MachineInstr'.\n  MachineInstr *CreateMachineInstr(const MCInstrDesc &MCID, const DebugLoc &DL,\n                                   bool NoImplicit = false);\n\n  /// Create a new MachineInstr which is a copy of \\p Orig, identical in all\n  /// ways except the instruction has no parent, prev, or next. Bundling flags\n  /// are reset.\n  ///\n  /// Note: Clones a single instruction, not whole instruction bundles.\n  /// Does not perform target specific adjustments; consider using\n  /// TargetInstrInfo::duplicate() instead.\n  MachineInstr *CloneMachineInstr(const MachineInstr *Orig);\n\n  /// Clones instruction or the whole instruction bundle \\p Orig and insert\n  /// into \\p MBB before \\p InsertBefore.\n  ///\n  /// Note: Does not perform target specific adjustments; consider using\n  /// TargetInstrInfo::duplicate() intead.\n  MachineInstr &CloneMachineInstrBundle(MachineBasicBlock &MBB,\n      MachineBasicBlock::iterator InsertBefore, const MachineInstr &Orig);\n\n  /// DeleteMachineInstr - Delete the given MachineInstr.\n  void DeleteMachineInstr(MachineInstr *MI);\n\n  /// CreateMachineBasicBlock - Allocate a new MachineBasicBlock. Use this\n  /// instead of `new MachineBasicBlock'.\n  MachineBasicBlock *CreateMachineBasicBlock(const BasicBlock *bb = nullptr);\n\n  /// DeleteMachineBasicBlock - Delete the given MachineBasicBlock.\n  void DeleteMachineBasicBlock(MachineBasicBlock *MBB);\n\n  /// getMachineMemOperand - Allocate a new MachineMemOperand.\n  /// MachineMemOperands are owned by the MachineFunction and need not be\n  /// explicitly deallocated.\n  MachineMemOperand *getMachineMemOperand(\n      MachinePointerInfo PtrInfo, MachineMemOperand::Flags f, uint64_t s,\n      Align base_alignment, const AAMDNodes &AAInfo = AAMDNodes(),\n      const MDNode *Ranges = nullptr, SyncScope::ID SSID = SyncScope::System,\n      AtomicOrdering Ordering = AtomicOrdering::NotAtomic,\n      AtomicOrdering FailureOrdering = AtomicOrdering::NotAtomic);\n\n  /// getMachineMemOperand - Allocate a new MachineMemOperand by copying\n  /// an existing one, adjusting by an offset and using the given size.\n  /// MachineMemOperands are owned by the MachineFunction and need not be\n  /// explicitly deallocated.\n  MachineMemOperand *getMachineMemOperand(const MachineMemOperand *MMO,\n                                          int64_t Offset, uint64_t Size);\n\n  /// getMachineMemOperand - Allocate a new MachineMemOperand by copying\n  /// an existing one, replacing only the MachinePointerInfo and size.\n  /// MachineMemOperands are owned by the MachineFunction and need not be\n  /// explicitly deallocated.\n  MachineMemOperand *getMachineMemOperand(const MachineMemOperand *MMO,\n                                          MachinePointerInfo &PtrInfo,\n                                          uint64_t Size);\n\n  /// Allocate a new MachineMemOperand by copying an existing one,\n  /// replacing only AliasAnalysis information. MachineMemOperands are owned\n  /// by the MachineFunction and need not be explicitly deallocated.\n  MachineMemOperand *getMachineMemOperand(const MachineMemOperand *MMO,\n                                          const AAMDNodes &AAInfo);\n\n  /// Allocate a new MachineMemOperand by copying an existing one,\n  /// replacing the flags. MachineMemOperands are owned\n  /// by the MachineFunction and need not be explicitly deallocated.\n  MachineMemOperand *getMachineMemOperand(const MachineMemOperand *MMO,\n                                          MachineMemOperand::Flags Flags);\n\n  using OperandCapacity = ArrayRecycler<MachineOperand>::Capacity;\n\n  /// Allocate an array of MachineOperands. This is only intended for use by\n  /// internal MachineInstr functions.\n  MachineOperand *allocateOperandArray(OperandCapacity Cap) {\n    return OperandRecycler.allocate(Cap, Allocator);\n  }\n\n  /// Dellocate an array of MachineOperands and recycle the memory. This is\n  /// only intended for use by internal MachineInstr functions.\n  /// Cap must be the same capacity that was used to allocate the array.\n  void deallocateOperandArray(OperandCapacity Cap, MachineOperand *Array) {\n    OperandRecycler.deallocate(Cap, Array);\n  }\n\n  /// Allocate and initialize a register mask with @p NumRegister bits.\n  uint32_t *allocateRegMask();\n\n  ArrayRef<int> allocateShuffleMask(ArrayRef<int> Mask);\n\n  /// Allocate and construct an extra info structure for a `MachineInstr`.\n  ///\n  /// This is allocated on the function's allocator and so lives the life of\n  /// the function.\n  MachineInstr::ExtraInfo *createMIExtraInfo(\n      ArrayRef<MachineMemOperand *> MMOs, MCSymbol *PreInstrSymbol = nullptr,\n      MCSymbol *PostInstrSymbol = nullptr, MDNode *HeapAllocMarker = nullptr);\n\n  /// Allocate a string and populate it with the given external symbol name.\n  const char *createExternalSymbolName(StringRef Name);\n\n  //===--------------------------------------------------------------------===//\n  // Label Manipulation.\n\n  /// getJTISymbol - Return the MCSymbol for the specified non-empty jump table.\n  /// If isLinkerPrivate is specified, an 'l' label is returned, otherwise a\n  /// normal 'L' label is returned.\n  MCSymbol *getJTISymbol(unsigned JTI, MCContext &Ctx,\n                         bool isLinkerPrivate = false) const;\n\n  /// getPICBaseSymbol - Return a function-local symbol to represent the PIC\n  /// base.\n  MCSymbol *getPICBaseSymbol() const;\n\n  /// Returns a reference to a list of cfi instructions in the function's\n  /// prologue.  Used to construct frame maps for debug and exception handling\n  /// comsumers.\n  const std::vector<MCCFIInstruction> &getFrameInstructions() const {\n    return FrameInstructions;\n  }\n\n  LLVM_NODISCARD unsigned addFrameInst(const MCCFIInstruction &Inst);\n\n  /// Returns a reference to a list of symbols immediately following calls to\n  /// _setjmp in the function. Used to construct the longjmp target table used\n  /// by Windows Control Flow Guard.\n  const std::vector<MCSymbol *> &getLongjmpTargets() const {\n    return LongjmpTargets;\n  }\n\n  /// Add the specified symbol to the list of valid longjmp targets for Windows\n  /// Control Flow Guard.\n  void addLongjmpTarget(MCSymbol *Target) { LongjmpTargets.push_back(Target); }\n\n  /// Returns a reference to a list of symbols that we have catchrets.\n  /// Used to construct the catchret target table used by Windows EHCont Guard.\n  const std::vector<MCSymbol *> &getCatchretTargets() const {\n    return CatchretTargets;\n  }\n\n  /// Add the specified symbol to the list of valid catchret targets for Windows\n  /// EHCont Guard.\n  void addCatchretTarget(MCSymbol *Target) {\n    CatchretTargets.push_back(Target);\n  }\n\n  /// \\name Exception Handling\n  /// \\{\n\n  bool callsEHReturn() const { return CallsEHReturn; }\n  void setCallsEHReturn(bool b) { CallsEHReturn = b; }\n\n  bool callsUnwindInit() const { return CallsUnwindInit; }\n  void setCallsUnwindInit(bool b) { CallsUnwindInit = b; }\n\n  bool hasEHCatchret() const { return HasEHCatchret; }\n  void setHasEHCatchret(bool V) { HasEHCatchret = V; }\n\n  bool hasEHScopes() const { return HasEHScopes; }\n  void setHasEHScopes(bool V) { HasEHScopes = V; }\n\n  bool hasEHFunclets() const { return HasEHFunclets; }\n  void setHasEHFunclets(bool V) { HasEHFunclets = V; }\n\n  /// Find or create an LandingPadInfo for the specified MachineBasicBlock.\n  LandingPadInfo &getOrCreateLandingPadInfo(MachineBasicBlock *LandingPad);\n\n  /// Remap landing pad labels and remove any deleted landing pads.\n  void tidyLandingPads(DenseMap<MCSymbol *, uintptr_t> *LPMap = nullptr,\n                       bool TidyIfNoBeginLabels = true);\n\n  /// Return a reference to the landing pad info for the current function.\n  const std::vector<LandingPadInfo> &getLandingPads() const {\n    return LandingPads;\n  }\n\n  /// Provide the begin and end labels of an invoke style call and associate it\n  /// with a try landing pad block.\n  void addInvoke(MachineBasicBlock *LandingPad,\n                 MCSymbol *BeginLabel, MCSymbol *EndLabel);\n\n  /// Add a new panding pad, and extract the exception handling information from\n  /// the landingpad instruction. Returns the label ID for the landing pad\n  /// entry.\n  MCSymbol *addLandingPad(MachineBasicBlock *LandingPad);\n\n  /// Provide the catch typeinfo for a landing pad.\n  void addCatchTypeInfo(MachineBasicBlock *LandingPad,\n                        ArrayRef<const GlobalValue *> TyInfo);\n\n  /// Provide the filter typeinfo for a landing pad.\n  void addFilterTypeInfo(MachineBasicBlock *LandingPad,\n                         ArrayRef<const GlobalValue *> TyInfo);\n\n  /// Add a cleanup action for a landing pad.\n  void addCleanup(MachineBasicBlock *LandingPad);\n\n  void addSEHCatchHandler(MachineBasicBlock *LandingPad, const Function *Filter,\n                          const BlockAddress *RecoverBA);\n\n  void addSEHCleanupHandler(MachineBasicBlock *LandingPad,\n                            const Function *Cleanup);\n\n  /// Return the type id for the specified typeinfo.  This is function wide.\n  unsigned getTypeIDFor(const GlobalValue *TI);\n\n  /// Return the id of the filter encoded by TyIds.  This is function wide.\n  int getFilterIDFor(std::vector<unsigned> &TyIds);\n\n  /// Map the landing pad's EH symbol to the call site indexes.\n  void setCallSiteLandingPad(MCSymbol *Sym, ArrayRef<unsigned> Sites);\n\n  /// Map the landing pad to its index. Used for Wasm exception handling.\n  void setWasmLandingPadIndex(const MachineBasicBlock *LPad, unsigned Index) {\n    WasmLPadToIndexMap[LPad] = Index;\n  }\n\n  /// Returns true if the landing pad has an associate index in wasm EH.\n  bool hasWasmLandingPadIndex(const MachineBasicBlock *LPad) const {\n    return WasmLPadToIndexMap.count(LPad);\n  }\n\n  /// Get the index in wasm EH for a given landing pad.\n  unsigned getWasmLandingPadIndex(const MachineBasicBlock *LPad) const {\n    assert(hasWasmLandingPadIndex(LPad));\n    return WasmLPadToIndexMap.lookup(LPad);\n  }\n\n  /// Get the call site indexes for a landing pad EH symbol.\n  SmallVectorImpl<unsigned> &getCallSiteLandingPad(MCSymbol *Sym) {\n    assert(hasCallSiteLandingPad(Sym) &&\n           \"missing call site number for landing pad!\");\n    return LPadToCallSiteMap[Sym];\n  }\n\n  /// Return true if the landing pad Eh symbol has an associated call site.\n  bool hasCallSiteLandingPad(MCSymbol *Sym) {\n    return !LPadToCallSiteMap[Sym].empty();\n  }\n\n  /// Map the begin label for a call site.\n  void setCallSiteBeginLabel(MCSymbol *BeginLabel, unsigned Site) {\n    CallSiteMap[BeginLabel] = Site;\n  }\n\n  /// Get the call site number for a begin label.\n  unsigned getCallSiteBeginLabel(MCSymbol *BeginLabel) const {\n    assert(hasCallSiteBeginLabel(BeginLabel) &&\n           \"Missing call site number for EH_LABEL!\");\n    return CallSiteMap.lookup(BeginLabel);\n  }\n\n  /// Return true if the begin label has a call site number associated with it.\n  bool hasCallSiteBeginLabel(MCSymbol *BeginLabel) const {\n    return CallSiteMap.count(BeginLabel);\n  }\n\n  /// Record annotations associated with a particular label.\n  void addCodeViewAnnotation(MCSymbol *Label, MDNode *MD) {\n    CodeViewAnnotations.push_back({Label, MD});\n  }\n\n  ArrayRef<std::pair<MCSymbol *, MDNode *>> getCodeViewAnnotations() const {\n    return CodeViewAnnotations;\n  }\n\n  /// Return a reference to the C++ typeinfo for the current function.\n  const std::vector<const GlobalValue *> &getTypeInfos() const {\n    return TypeInfos;\n  }\n\n  /// Return a reference to the typeids encoding filters used in the current\n  /// function.\n  const std::vector<unsigned> &getFilterIds() const {\n    return FilterIds;\n  }\n\n  /// \\}\n\n  /// Collect information used to emit debugging information of a variable.\n  void setVariableDbgInfo(const DILocalVariable *Var, const DIExpression *Expr,\n                          int Slot, const DILocation *Loc) {\n    VariableDbgInfos.emplace_back(Var, Expr, Slot, Loc);\n  }\n\n  VariableDbgInfoMapTy &getVariableDbgInfo() { return VariableDbgInfos; }\n  const VariableDbgInfoMapTy &getVariableDbgInfo() const {\n    return VariableDbgInfos;\n  }\n\n  /// Start tracking the arguments passed to the call \\p CallI.\n  void addCallArgsForwardingRegs(const MachineInstr *CallI,\n                                 CallSiteInfoImpl &&CallInfo) {\n    assert(CallI->isCandidateForCallSiteEntry());\n    bool Inserted =\n        CallSitesInfo.try_emplace(CallI, std::move(CallInfo)).second;\n    (void)Inserted;\n    assert(Inserted && \"Call site info not unique\");\n  }\n\n  const CallSiteInfoMap &getCallSitesInfo() const {\n    return CallSitesInfo;\n  }\n\n  /// Following functions update call site info. They should be called before\n  /// removing, replacing or copying call instruction.\n\n  /// Erase the call site info for \\p MI. It is used to remove a call\n  /// instruction from the instruction stream.\n  void eraseCallSiteInfo(const MachineInstr *MI);\n  /// Copy the call site info from \\p Old to \\ New. Its usage is when we are\n  /// making a copy of the instruction that will be inserted at different point\n  /// of the instruction stream.\n  void copyCallSiteInfo(const MachineInstr *Old,\n                        const MachineInstr *New);\n\n  const std::vector<char> &getBBSectionsSymbolPrefix() const {\n    return BBSectionsSymbolPrefix;\n  }\n\n  /// Move the call site info from \\p Old to \\New call site info. This function\n  /// is used when we are replacing one call instruction with another one to\n  /// the same callee.\n  void moveCallSiteInfo(const MachineInstr *Old,\n                        const MachineInstr *New);\n\n  unsigned getNewDebugInstrNum() {\n    return ++DebugInstrNumberingCount;\n  }\n};\n\n//===--------------------------------------------------------------------===//\n// GraphTraits specializations for function basic block graphs (CFGs)\n//===--------------------------------------------------------------------===//\n\n// Provide specializations of GraphTraits to be able to treat a\n// machine function as a graph of machine basic blocks... these are\n// the same as the machine basic block iterators, except that the root\n// node is implicitly the first node of the function.\n//\ntemplate <> struct GraphTraits<MachineFunction*> :\n  public GraphTraits<MachineBasicBlock*> {\n  static NodeRef getEntryNode(MachineFunction *F) { return &F->front(); }\n\n  // nodes_iterator/begin/end - Allow iteration over all nodes in the graph\n  using nodes_iterator = pointer_iterator<MachineFunction::iterator>;\n\n  static nodes_iterator nodes_begin(MachineFunction *F) {\n    return nodes_iterator(F->begin());\n  }\n\n  static nodes_iterator nodes_end(MachineFunction *F) {\n    return nodes_iterator(F->end());\n  }\n\n  static unsigned       size       (MachineFunction *F) { return F->size(); }\n};\ntemplate <> struct GraphTraits<const MachineFunction*> :\n  public GraphTraits<const MachineBasicBlock*> {\n  static NodeRef getEntryNode(const MachineFunction *F) { return &F->front(); }\n\n  // nodes_iterator/begin/end - Allow iteration over all nodes in the graph\n  using nodes_iterator = pointer_iterator<MachineFunction::const_iterator>;\n\n  static nodes_iterator nodes_begin(const MachineFunction *F) {\n    return nodes_iterator(F->begin());\n  }\n\n  static nodes_iterator nodes_end  (const MachineFunction *F) {\n    return nodes_iterator(F->end());\n  }\n\n  static unsigned       size       (const MachineFunction *F)  {\n    return F->size();\n  }\n};\n\n// Provide specializations of GraphTraits to be able to treat a function as a\n// graph of basic blocks... and to walk it in inverse order.  Inverse order for\n// a function is considered to be when traversing the predecessor edges of a BB\n// instead of the successor edges.\n//\ntemplate <> struct GraphTraits<Inverse<MachineFunction*>> :\n  public GraphTraits<Inverse<MachineBasicBlock*>> {\n  static NodeRef getEntryNode(Inverse<MachineFunction *> G) {\n    return &G.Graph->front();\n  }\n};\ntemplate <> struct GraphTraits<Inverse<const MachineFunction*>> :\n  public GraphTraits<Inverse<const MachineBasicBlock*>> {\n  static NodeRef getEntryNode(Inverse<const MachineFunction *> G) {\n    return &G.Graph->front();\n  }\n};\n\nclass MachineFunctionAnalysisManager;\nvoid verifyMachineFunction(MachineFunctionAnalysisManager *,\n                           const std::string &Banner,\n                           const MachineFunction &MF);\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_MACHINEFUNCTION_H\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h", "content": "//===-- MachineFunctionPass.h - Pass for MachineFunctions --------*-C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the MachineFunctionPass class.  MachineFunctionPass's are\n// just FunctionPass's, except they operate on machine code as part of a code\n// generator.  Because they operate on machine code, not the LLVM\n// representation, MachineFunctionPass's are not allowed to modify the LLVM\n// representation.  Due to this limitation, the MachineFunctionPass class takes\n// care of declaring that no LLVM passes are invalidated.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEFUNCTIONPASS_H\n#define LLVM_CODEGEN_MACHINEFUNCTIONPASS_H\n\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/Pass.h\"\n\nnamespace llvm {\n\n/// MachineFunctionPass - This class adapts the FunctionPass interface to\n/// allow convenient creation of passes that operate on the MachineFunction\n/// representation. Instead of overriding runOnFunction, subclasses\n/// override runOnMachineFunction.\nclass MachineFunctionPass : public FunctionPass {\npublic:\n  bool doInitialization(Module&) override {\n    // Cache the properties info at module-init time so we don't have to\n    // construct them for every function.\n    RequiredProperties = getRequiredProperties();\n    SetProperties = getSetProperties();\n    ClearedProperties = getClearedProperties();\n    return false;\n  }\nprotected:\n  explicit MachineFunctionPass(char &ID) : FunctionPass(ID) {}\n\n  /// runOnMachineFunction - This method must be overloaded to perform the\n  /// desired machine code transformation or analysis.\n  ///\n  virtual bool runOnMachineFunction(MachineFunction &MF) = 0;\n\n  /// getAnalysisUsage - Subclasses that override getAnalysisUsage\n  /// must call this.\n  ///\n  /// For MachineFunctionPasses, calling AU.preservesCFG() indicates that\n  /// the pass does not modify the MachineBasicBlock CFG.\n  ///\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n\n  virtual MachineFunctionProperties getRequiredProperties() const {\n    return MachineFunctionProperties();\n  }\n  virtual MachineFunctionProperties getSetProperties() const {\n    return MachineFunctionProperties();\n  }\n  virtual MachineFunctionProperties getClearedProperties() const {\n    return MachineFunctionProperties();\n  }\n\nprivate:\n  MachineFunctionProperties RequiredProperties;\n  MachineFunctionProperties SetProperties;\n  MachineFunctionProperties ClearedProperties;\n\n  /// createPrinterPass - Get a machine function printer pass.\n  Pass *createPrinterPass(raw_ostream &O,\n                          const std::string &Banner) const override;\n\n  bool runOnFunction(Function &F) override;\n};\n\n} // End llvm namespace\n\n#endif\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h", "content": "//==- llvm/CodeGen/MachineMemOperand.h - MachineMemOperand class -*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the MachineMemOperand class, which is a\n// description of a memory reference. It is used to help track dependencies\n// in the backend.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_MACHINEMEMOPERAND_H\n#define LLVM_CODEGEN_MACHINEMEMOPERAND_H\n\n#include \"llvm/ADT/BitmaskEnum.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/CodeGen/PseudoSourceValue.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Value.h\" // PointerLikeTypeTraits<Value*>\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/DataTypes.h\"\n\nnamespace llvm {\n\nclass FoldingSetNodeID;\nclass MDNode;\nclass raw_ostream;\nclass MachineFunction;\nclass ModuleSlotTracker;\n\n/// This class contains a discriminated union of information about pointers in\n/// memory operands, relating them back to LLVM IR or to virtual locations (such\n/// as frame indices) that are exposed during codegen.\nstruct MachinePointerInfo {\n  /// This is the IR pointer value for the access, or it is null if unknown.\n  /// If this is null, then the access is to a pointer in the default address\n  /// space.\n  PointerUnion<const Value *, const PseudoSourceValue *> V;\n\n  /// Offset - This is an offset from the base Value*.\n  int64_t Offset;\n\n  uint8_t StackID;\n\n  unsigned AddrSpace = 0;\n\n  explicit MachinePointerInfo(const Value *v, int64_t offset = 0,\n                              uint8_t ID = 0)\n      : V(v), Offset(offset), StackID(ID) {\n    AddrSpace = v ? v->getType()->getPointerAddressSpace() : 0;\n  }\n\n  explicit MachinePointerInfo(const PseudoSourceValue *v, int64_t offset = 0,\n                              uint8_t ID = 0)\n      : V(v), Offset(offset), StackID(ID) {\n    AddrSpace = v ? v->getAddressSpace() : 0;\n  }\n\n  explicit MachinePointerInfo(unsigned AddressSpace = 0, int64_t offset = 0)\n      : V((const Value *)nullptr), Offset(offset), StackID(0),\n        AddrSpace(AddressSpace) {}\n\n  explicit MachinePointerInfo(\n    PointerUnion<const Value *, const PseudoSourceValue *> v,\n    int64_t offset = 0,\n    uint8_t ID = 0)\n    : V(v), Offset(offset), StackID(ID) {\n    if (V) {\n      if (const auto *ValPtr = V.dyn_cast<const Value*>())\n        AddrSpace = ValPtr->getType()->getPointerAddressSpace();\n      else\n        AddrSpace = V.get<const PseudoSourceValue*>()->getAddressSpace();\n    }\n  }\n\n  MachinePointerInfo getWithOffset(int64_t O) const {\n    if (V.isNull())\n      return MachinePointerInfo(AddrSpace, Offset + O);\n    if (V.is<const Value*>())\n      return MachinePointerInfo(V.get<const Value*>(), Offset + O, StackID);\n    return MachinePointerInfo(V.get<const PseudoSourceValue*>(), Offset + O,\n                              StackID);\n  }\n\n  /// Return true if memory region [V, V+Offset+Size) is known to be\n  /// dereferenceable.\n  bool isDereferenceable(unsigned Size, LLVMContext &C,\n                         const DataLayout &DL) const;\n\n  /// Return the LLVM IR address space number that this pointer points into.\n  unsigned getAddrSpace() const;\n\n  /// Return a MachinePointerInfo record that refers to the constant pool.\n  static MachinePointerInfo getConstantPool(MachineFunction &MF);\n\n  /// Return a MachinePointerInfo record that refers to the specified\n  /// FrameIndex.\n  static MachinePointerInfo getFixedStack(MachineFunction &MF, int FI,\n                                          int64_t Offset = 0);\n\n  /// Return a MachinePointerInfo record that refers to a jump table entry.\n  static MachinePointerInfo getJumpTable(MachineFunction &MF);\n\n  /// Return a MachinePointerInfo record that refers to a GOT entry.\n  static MachinePointerInfo getGOT(MachineFunction &MF);\n\n  /// Stack pointer relative access.\n  static MachinePointerInfo getStack(MachineFunction &MF, int64_t Offset,\n                                     uint8_t ID = 0);\n\n  /// Stack memory without other information.\n  static MachinePointerInfo getUnknownStack(MachineFunction &MF);\n};\n\n\n//===----------------------------------------------------------------------===//\n/// A description of a memory reference used in the backend.\n/// Instead of holding a StoreInst or LoadInst, this class holds the address\n/// Value of the reference along with a byte size and offset. This allows it\n/// to describe lowered loads and stores. Also, the special PseudoSourceValue\n/// objects can be used to represent loads and stores to memory locations\n/// that aren't explicit in the regular LLVM IR.\n///\nclass MachineMemOperand {\npublic:\n  /// Flags values. These may be or'd together.\n  enum Flags : uint16_t {\n    // No flags set.\n    MONone = 0,\n    /// The memory access reads data.\n    MOLoad = 1u << 0,\n    /// The memory access writes data.\n    MOStore = 1u << 1,\n    /// The memory access is volatile.\n    MOVolatile = 1u << 2,\n    /// The memory access is non-temporal.\n    MONonTemporal = 1u << 3,\n    /// The memory access is dereferenceable (i.e., doesn't trap).\n    MODereferenceable = 1u << 4,\n    /// The memory access always returns the same value (or traps).\n    MOInvariant = 1u << 5,\n\n    // Reserved for use by target-specific passes.\n    // Targets may override getSerializableMachineMemOperandTargetFlags() to\n    // enable MIR serialization/parsing of these flags.  If more of these flags\n    // are added, the MIR printing/parsing code will need to be updated as well.\n    MOTargetFlag1 = 1u << 6,\n    MOTargetFlag2 = 1u << 7,\n    MOTargetFlag3 = 1u << 8,\n\n    LLVM_MARK_AS_BITMASK_ENUM(/* LargestFlag = */ MOTargetFlag3)\n  };\n\nprivate:\n  /// Atomic information for this memory operation.\n  struct MachineAtomicInfo {\n    /// Synchronization scope ID for this memory operation.\n    unsigned SSID : 8;            // SyncScope::ID\n    /// Atomic ordering requirements for this memory operation. For cmpxchg\n    /// atomic operations, atomic ordering requirements when store occurs.\n    unsigned Ordering : 4;        // enum AtomicOrdering\n    /// For cmpxchg atomic operations, atomic ordering requirements when store\n    /// does not occur.\n    unsigned FailureOrdering : 4; // enum AtomicOrdering\n  };\n\n  MachinePointerInfo PtrInfo;\n  uint64_t Size;\n  Flags FlagVals;\n  Align BaseAlign;\n  MachineAtomicInfo AtomicInfo;\n  AAMDNodes AAInfo;\n  const MDNode *Ranges;\n\npublic:\n  /// Construct a MachineMemOperand object with the specified PtrInfo, flags,\n  /// size, and base alignment. For atomic operations the synchronization scope\n  /// and atomic ordering requirements must also be specified. For cmpxchg\n  /// atomic operations the atomic ordering requirements when store does not\n  /// occur must also be specified.\n  MachineMemOperand(MachinePointerInfo PtrInfo, Flags flags, uint64_t s,\n                    Align a, const AAMDNodes &AAInfo = AAMDNodes(),\n                    const MDNode *Ranges = nullptr,\n                    SyncScope::ID SSID = SyncScope::System,\n                    AtomicOrdering Ordering = AtomicOrdering::NotAtomic,\n                    AtomicOrdering FailureOrdering = AtomicOrdering::NotAtomic);\n\n  const MachinePointerInfo &getPointerInfo() const { return PtrInfo; }\n\n  /// Return the base address of the memory access. This may either be a normal\n  /// LLVM IR Value, or one of the special values used in CodeGen.\n  /// Special values are those obtained via\n  /// PseudoSourceValue::getFixedStack(int), PseudoSourceValue::getStack, and\n  /// other PseudoSourceValue member functions which return objects which stand\n  /// for frame/stack pointer relative references and other special references\n  /// which are not representable in the high-level IR.\n  const Value *getValue() const { return PtrInfo.V.dyn_cast<const Value*>(); }\n\n  const PseudoSourceValue *getPseudoValue() const {\n    return PtrInfo.V.dyn_cast<const PseudoSourceValue*>();\n  }\n\n  const void *getOpaqueValue() const { return PtrInfo.V.getOpaqueValue(); }\n\n  /// Return the raw flags of the source value, \\see Flags.\n  Flags getFlags() const { return FlagVals; }\n\n  /// Bitwise OR the current flags with the given flags.\n  void setFlags(Flags f) { FlagVals |= f; }\n\n  /// For normal values, this is a byte offset added to the base address.\n  /// For PseudoSourceValue::FPRel values, this is the FrameIndex number.\n  int64_t getOffset() const { return PtrInfo.Offset; }\n\n  unsigned getAddrSpace() const { return PtrInfo.getAddrSpace(); }\n\n  /// Return the size in bytes of the memory reference.\n  uint64_t getSize() const { return Size; }\n\n  /// Return the size in bits of the memory reference.\n  uint64_t getSizeInBits() const { return Size * 8; }\n\n  LLVM_ATTRIBUTE_DEPRECATED(uint64_t getAlignment() const,\n                            \"Use getAlign instead\");\n\n  /// Return the minimum known alignment in bytes of the actual memory\n  /// reference.\n  Align getAlign() const;\n\n  LLVM_ATTRIBUTE_DEPRECATED(uint64_t getBaseAlignment() const,\n                            \"Use getBaseAlign instead\") {\n    return BaseAlign.value();\n  }\n\n  /// Return the minimum known alignment in bytes of the base address, without\n  /// the offset.\n  Align getBaseAlign() const { return BaseAlign; }\n\n  /// Return the AA tags for the memory reference.\n  AAMDNodes getAAInfo() const { return AAInfo; }\n\n  /// Return the range tag for the memory reference.\n  const MDNode *getRanges() const { return Ranges; }\n\n  /// Returns the synchronization scope ID for this memory operation.\n  SyncScope::ID getSyncScopeID() const {\n    return static_cast<SyncScope::ID>(AtomicInfo.SSID);\n  }\n\n  /// Return the atomic ordering requirements for this memory operation. For\n  /// cmpxchg atomic operations, return the atomic ordering requirements when\n  /// store occurs.\n  AtomicOrdering getOrdering() const {\n    return static_cast<AtomicOrdering>(AtomicInfo.Ordering);\n  }\n\n  /// For cmpxchg atomic operations, return the atomic ordering requirements\n  /// when store does not occur.\n  AtomicOrdering getFailureOrdering() const {\n    return static_cast<AtomicOrdering>(AtomicInfo.FailureOrdering);\n  }\n\n  bool isLoad() const { return FlagVals & MOLoad; }\n  bool isStore() const { return FlagVals & MOStore; }\n  bool isVolatile() const { return FlagVals & MOVolatile; }\n  bool isNonTemporal() const { return FlagVals & MONonTemporal; }\n  bool isDereferenceable() const { return FlagVals & MODereferenceable; }\n  bool isInvariant() const { return FlagVals & MOInvariant; }\n\n  /// Returns true if this operation has an atomic ordering requirement of\n  /// unordered or higher, false otherwise.\n  bool isAtomic() const { return getOrdering() != AtomicOrdering::NotAtomic; }\n\n  /// Returns true if this memory operation doesn't have any ordering\n  /// constraints other than normal aliasing. Volatile and (ordered) atomic\n  /// memory operations can't be reordered. \n  bool isUnordered() const {\n    return (getOrdering() == AtomicOrdering::NotAtomic ||\n            getOrdering() == AtomicOrdering::Unordered) &&\n           !isVolatile();\n  }\n\n  /// Update this MachineMemOperand to reflect the alignment of MMO, if it has a\n  /// greater alignment. This must only be used when the new alignment applies\n  /// to all users of this MachineMemOperand.\n  void refineAlignment(const MachineMemOperand *MMO);\n\n  /// Change the SourceValue for this MachineMemOperand. This should only be\n  /// used when an object is being relocated and all references to it are being\n  /// updated.\n  void setValue(const Value *NewSV) { PtrInfo.V = NewSV; }\n  void setValue(const PseudoSourceValue *NewSV) { PtrInfo.V = NewSV; }\n  void setOffset(int64_t NewOffset) { PtrInfo.Offset = NewOffset; }\n\n  /// Profile - Gather unique data for the object.\n  ///\n  void Profile(FoldingSetNodeID &ID) const;\n\n  /// Support for operator<<.\n  /// @{\n  void print(raw_ostream &OS, ModuleSlotTracker &MST,\n             SmallVectorImpl<StringRef> &SSNs, const LLVMContext &Context,\n             const MachineFrameInfo *MFI, const TargetInstrInfo *TII) const;\n  /// @}\n\n  friend bool operator==(const MachineMemOperand &LHS,\n                         const MachineMemOperand &RHS) {\n    return LHS.getValue() == RHS.getValue() &&\n           LHS.getPseudoValue() == RHS.getPseudoValue() &&\n           LHS.getSize() == RHS.getSize() &&\n           LHS.getOffset() == RHS.getOffset() &&\n           LHS.getFlags() == RHS.getFlags() &&\n           LHS.getAAInfo() == RHS.getAAInfo() &&\n           LHS.getRanges() == RHS.getRanges() &&\n           LHS.getAlign() == RHS.getAlign() &&\n           LHS.getAddrSpace() == RHS.getAddrSpace();\n  }\n\n  friend bool operator!=(const MachineMemOperand &LHS,\n                         const MachineMemOperand &RHS) {\n    return !(LHS == RHS);\n  }\n};\n\n} // End llvm namespace\n\n#endif\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/PBQPRAConstraint.h", "content": "//===- llvm/CodeGen/PBQPRAConstraint.h --------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the PBQPBuilder interface, for classes which build PBQP\n// instances to represent register allocation problems, and the RegAllocPBQP\n// interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_PBQPRACONSTRAINT_H\n#define LLVM_CODEGEN_PBQPRACONSTRAINT_H\n\n#include <algorithm>\n#include <memory>\n#include <vector>\n\nnamespace llvm {\n\nnamespace PBQP {\nnamespace RegAlloc {\n\n// Forward declare PBQP graph class.\nclass PBQPRAGraph;\n\n} // end namespace RegAlloc\n} // end namespace PBQP\n\nusing PBQPRAGraph = PBQP::RegAlloc::PBQPRAGraph;\n\n/// Abstract base for classes implementing PBQP register allocation\n///        constraints (e.g. Spill-costs, interference, coalescing).\nclass PBQPRAConstraint {\npublic:\n  virtual ~PBQPRAConstraint() = 0;\n  virtual void apply(PBQPRAGraph &G) = 0;\n\nprivate:\n  virtual void anchor();\n};\n\n/// PBQP register allocation constraint composer.\n///\n///   Constraints added to this list will be applied, in the order that they are\n/// added, to the PBQP graph.\nclass PBQPRAConstraintList : public PBQPRAConstraint {\npublic:\n  void apply(PBQPRAGraph &G) override {\n    for (auto &C : Constraints)\n      C->apply(G);\n  }\n\n  void addConstraint(std::unique_ptr<PBQPRAConstraint> C) {\n    if (C)\n      Constraints.push_back(std::move(C));\n  }\n\nprivate:\n  std::vector<std::unique_ptr<PBQPRAConstraint>> Constraints;\n\n  void anchor() override;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_PBQPRACONSTRAINT_H\n"}, "41": {"id": 41, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/PseudoSourceValue.h", "content": "//===-- llvm/CodeGen/PseudoSourceValue.h ------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the PseudoSourceValue class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_PSEUDOSOURCEVALUE_H\n#define LLVM_CODEGEN_PSEUDOSOURCEVALUE_H\n\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/IR/ValueMap.h\"\n#include <map>\n\nnamespace llvm {\n\nclass GlobalValue;\nclass MachineFrameInfo;\nclass MachineMemOperand;\nclass MIRFormatter;\nclass PseudoSourceValue;\nclass raw_ostream;\nclass TargetInstrInfo;\n\nraw_ostream &operator<<(raw_ostream &OS, const PseudoSourceValue* PSV);\n\n/// Special value supplied for machine level alias analysis. It indicates that\n/// a memory access references the functions stack frame (e.g., a spill slot),\n/// below the stack frame (e.g., argument space), or constant pool.\nclass PseudoSourceValue {\npublic:\n  enum PSVKind : unsigned {\n    Stack,\n    GOT,\n    JumpTable,\n    ConstantPool,\n    FixedStack,\n    GlobalValueCallEntry,\n    ExternalSymbolCallEntry,\n    TargetCustom\n  };\n\nprivate:\n  unsigned Kind;\n  unsigned AddressSpace;\n  friend raw_ostream &llvm::operator<<(raw_ostream &OS,\n                                       const PseudoSourceValue* PSV);\n\n  friend class MachineMemOperand; // For printCustom().\n  friend class MIRFormatter;      // For printCustom().\n\n  /// Implement printing for PseudoSourceValue. This is called from\n  /// Value::print or Value's operator<<.\n  virtual void printCustom(raw_ostream &O) const;\n\npublic:\n  explicit PseudoSourceValue(unsigned Kind, const TargetInstrInfo &TII);\n\n  virtual ~PseudoSourceValue();\n\n  unsigned kind() const { return Kind; }\n\n  bool isStack() const { return Kind == Stack; }\n  bool isGOT() const { return Kind == GOT; }\n  bool isConstantPool() const { return Kind == ConstantPool; }\n  bool isJumpTable() const { return Kind == JumpTable; }\n\n  unsigned getAddressSpace() const { return AddressSpace; }\n\n  unsigned getTargetCustom() const {\n    return (Kind >= TargetCustom) ? ((Kind+1) - TargetCustom) : 0;\n  }\n\n  /// Test whether the memory pointed to by this PseudoSourceValue has a\n  /// constant value.\n  virtual bool isConstant(const MachineFrameInfo *) const;\n\n  /// Test whether the memory pointed to by this PseudoSourceValue may also be\n  /// pointed to by an LLVM IR Value.\n  virtual bool isAliased(const MachineFrameInfo *) const;\n\n  /// Return true if the memory pointed to by this PseudoSourceValue can ever\n  /// alias an LLVM IR Value.\n  virtual bool mayAlias(const MachineFrameInfo *) const;\n};\n\n/// A specialized PseudoSourceValue for holding FixedStack values, which must\n/// include a frame index.\nclass FixedStackPseudoSourceValue : public PseudoSourceValue {\n  const int FI;\n\npublic:\n  explicit FixedStackPseudoSourceValue(int FI, const TargetInstrInfo &TII)\n      : PseudoSourceValue(FixedStack, TII), FI(FI) {}\n\n  static bool classof(const PseudoSourceValue *V) {\n    return V->kind() == FixedStack;\n  }\n\n  bool isConstant(const MachineFrameInfo *MFI) const override;\n\n  bool isAliased(const MachineFrameInfo *MFI) const override;\n\n  bool mayAlias(const MachineFrameInfo *) const override;\n\n  void printCustom(raw_ostream &OS) const override;\n\n  int getFrameIndex() const { return FI; }\n};\n\nclass CallEntryPseudoSourceValue : public PseudoSourceValue {\nprotected:\n  CallEntryPseudoSourceValue(unsigned Kind, const TargetInstrInfo &TII);\n\npublic:\n  bool isConstant(const MachineFrameInfo *) const override;\n  bool isAliased(const MachineFrameInfo *) const override;\n  bool mayAlias(const MachineFrameInfo *) const override;\n};\n\n/// A specialized pseudo source value for holding GlobalValue values.\nclass GlobalValuePseudoSourceValue : public CallEntryPseudoSourceValue {\n  const GlobalValue *GV;\n\npublic:\n  GlobalValuePseudoSourceValue(const GlobalValue *GV,\n                               const TargetInstrInfo &TII);\n\n  static bool classof(const PseudoSourceValue *V) {\n    return V->kind() == GlobalValueCallEntry;\n  }\n\n  const GlobalValue *getValue() const { return GV; }\n};\n\n/// A specialized pseudo source value for holding external symbol values.\nclass ExternalSymbolPseudoSourceValue : public CallEntryPseudoSourceValue {\n  const char *ES;\n\npublic:\n  ExternalSymbolPseudoSourceValue(const char *ES, const TargetInstrInfo &TII);\n\n  static bool classof(const PseudoSourceValue *V) {\n    return V->kind() == ExternalSymbolCallEntry;\n  }\n\n  const char *getSymbol() const { return ES; }\n};\n\n/// Manages creation of pseudo source values.\nclass PseudoSourceValueManager {\n  const TargetInstrInfo &TII;\n  const PseudoSourceValue StackPSV, GOTPSV, JumpTablePSV, ConstantPoolPSV;\n  std::map<int, std::unique_ptr<FixedStackPseudoSourceValue>> FSValues;\n  StringMap<std::unique_ptr<const ExternalSymbolPseudoSourceValue>>\n      ExternalCallEntries;\n  ValueMap<const GlobalValue *,\n           std::unique_ptr<const GlobalValuePseudoSourceValue>>\n      GlobalCallEntries;\n\npublic:\n  PseudoSourceValueManager(const TargetInstrInfo &TII);\n\n  /// Return a pseudo source value referencing the area below the stack frame of\n  /// a function, e.g., the argument space.\n  const PseudoSourceValue *getStack();\n\n  /// Return a pseudo source value referencing the global offset table\n  /// (or something the like).\n  const PseudoSourceValue *getGOT();\n\n  /// Return a pseudo source value referencing the constant pool. Since constant\n  /// pools are constant, this doesn't need to identify a specific constant\n  /// pool entry.\n  const PseudoSourceValue *getConstantPool();\n\n  /// Return a pseudo source value referencing a jump table. Since jump tables\n  /// are constant, this doesn't need to identify a specific jump table.\n  const PseudoSourceValue *getJumpTable();\n\n  /// Return a pseudo source value referencing a fixed stack frame entry,\n  /// e.g., a spill slot.\n  const PseudoSourceValue *getFixedStack(int FI);\n\n  const PseudoSourceValue *getGlobalValueCallEntry(const GlobalValue *GV);\n\n  const PseudoSourceValue *getExternalSymbolCallEntry(const char *ES);\n};\n\n} // end namespace llvm\n\n#endif\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h", "content": "//==- CodeGen/TargetRegisterInfo.h - Target Register Information -*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file describes an abstract interface used to get information about a\n// target machines register file.  This information is used for a variety of\n// purposed, especially register allocation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_TARGETREGISTERINFO_H\n#define LLVM_CODEGEN_TARGETREGISTERINFO_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n#include \"llvm/IR/CallingConv.h\"\n#include \"llvm/MC/LaneBitmask.h\"\n#include \"llvm/MC/MCRegisterInfo.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MachineValueType.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/Printable.h\"\n#include <cassert>\n#include <cstdint>\n#include <functional>\n\nnamespace llvm {\n\nclass BitVector;\nclass DIExpression;\nclass LiveRegMatrix;\nclass MachineFunction;\nclass MachineInstr;\nclass RegScavenger;\nclass VirtRegMap;\nclass LiveIntervals;\nclass LiveInterval;\n\nclass TargetRegisterClass {\npublic:\n  using iterator = const MCPhysReg *;\n  using const_iterator = const MCPhysReg *;\n  using sc_iterator = const TargetRegisterClass* const *;\n\n  // Instance variables filled by tablegen, do not use!\n  const MCRegisterClass *MC;\n  const uint32_t *SubClassMask;\n  const uint16_t *SuperRegIndices;\n  const LaneBitmask LaneMask;\n  /// Classes with a higher priority value are assigned first by register\n  /// allocators using a greedy heuristic. The value is in the range [0,63].\n  const uint8_t AllocationPriority;\n  /// Whether the class supports two (or more) disjunct subregister indices.\n  const bool HasDisjunctSubRegs;\n  /// Whether a combination of subregisters can cover every register in the\n  /// class. See also the CoveredBySubRegs description in Target.td.\n  const bool CoveredBySubRegs;\n  const sc_iterator SuperClasses;\n  ArrayRef<MCPhysReg> (*OrderFunc)(const MachineFunction&);\n\n  /// Return the register class ID number.\n  unsigned getID() const { return MC->getID(); }\n\n  /// begin/end - Return all of the registers in this class.\n  ///\n  iterator       begin() const { return MC->begin(); }\n  iterator         end() const { return MC->end(); }\n\n  /// Return the number of registers in this class.\n  unsigned getNumRegs() const { return MC->getNumRegs(); }\n\n  iterator_range<SmallVectorImpl<MCPhysReg>::const_iterator>\n  getRegisters() const {\n    return make_range(MC->begin(), MC->end());\n  }\n\n  /// Return the specified register in the class.\n  MCRegister getRegister(unsigned i) const {\n    return MC->getRegister(i);\n  }\n\n  /// Return true if the specified register is included in this register class.\n  /// This does not include virtual registers.\n  bool contains(Register Reg) const {\n    /// FIXME: Historically this function has returned false when given vregs\n    ///        but it should probably only receive physical registers\n    if (!Reg.isPhysical())\n      return false;\n    return MC->contains(Reg.asMCReg());\n  }\n\n  /// Return true if both registers are in this class.\n  bool contains(Register Reg1, Register Reg2) const {\n    /// FIXME: Historically this function has returned false when given a vregs\n    ///        but it should probably only receive physical registers\n    if (!Reg1.isPhysical() || !Reg2.isPhysical())\n      return false;\n    return MC->contains(Reg1.asMCReg(), Reg2.asMCReg());\n  }\n\n  /// Return the cost of copying a value between two registers in this class.\n  /// A negative number means the register class is very expensive\n  /// to copy e.g. status flag register classes.\n  int getCopyCost() const { return MC->getCopyCost(); }\n\n  /// Return true if this register class may be used to create virtual\n  /// registers.\n  bool isAllocatable() const { return MC->isAllocatable(); }\n\n  /// Return true if the specified TargetRegisterClass\n  /// is a proper sub-class of this TargetRegisterClass.\n  bool hasSubClass(const TargetRegisterClass *RC) const {\n    return RC != this && hasSubClassEq(RC);\n  }\n\n  /// Returns true if RC is a sub-class of or equal to this class.\n  bool hasSubClassEq(const TargetRegisterClass *RC) const {\n    unsigned ID = RC->getID();\n    return (SubClassMask[ID / 32] >> (ID % 32)) & 1;\n  }\n\n  /// Return true if the specified TargetRegisterClass is a\n  /// proper super-class of this TargetRegisterClass.\n  bool hasSuperClass(const TargetRegisterClass *RC) const {\n    return RC->hasSubClass(this);\n  }\n\n  /// Returns true if RC is a super-class of or equal to this class.\n  bool hasSuperClassEq(const TargetRegisterClass *RC) const {\n    return RC->hasSubClassEq(this);\n  }\n\n  /// Returns a bit vector of subclasses, including this one.\n  /// The vector is indexed by class IDs.\n  ///\n  /// To use it, consider the returned array as a chunk of memory that\n  /// contains an array of bits of size NumRegClasses. Each 32-bit chunk\n  /// contains a bitset of the ID of the subclasses in big-endian style.\n\n  /// I.e., the representation of the memory from left to right at the\n  /// bit level looks like:\n  /// [31 30 ... 1 0] [ 63 62 ... 33 32] ...\n  ///                     [ XXX NumRegClasses NumRegClasses - 1 ... ]\n  /// Where the number represents the class ID and XXX bits that\n  /// should be ignored.\n  ///\n  /// See the implementation of hasSubClassEq for an example of how it\n  /// can be used.\n  const uint32_t *getSubClassMask() const {\n    return SubClassMask;\n  }\n\n  /// Returns a 0-terminated list of sub-register indices that project some\n  /// super-register class into this register class. The list has an entry for\n  /// each Idx such that:\n  ///\n  ///   There exists SuperRC where:\n  ///     For all Reg in SuperRC:\n  ///       this->contains(Reg:Idx)\n  const uint16_t *getSuperRegIndices() const {\n    return SuperRegIndices;\n  }\n\n  /// Returns a NULL-terminated list of super-classes.  The\n  /// classes are ordered by ID which is also a topological ordering from large\n  /// to small classes.  The list does NOT include the current class.\n  sc_iterator getSuperClasses() const {\n    return SuperClasses;\n  }\n\n  /// Return true if this TargetRegisterClass is a subset\n  /// class of at least one other TargetRegisterClass.\n  bool isASubClass() const {\n    return SuperClasses[0] != nullptr;\n  }\n\n  /// Returns the preferred order for allocating registers from this register\n  /// class in MF. The raw order comes directly from the .td file and may\n  /// include reserved registers that are not allocatable.\n  /// Register allocators should also make sure to allocate\n  /// callee-saved registers only after all the volatiles are used. The\n  /// RegisterClassInfo class provides filtered allocation orders with\n  /// callee-saved registers moved to the end.\n  ///\n  /// The MachineFunction argument can be used to tune the allocatable\n  /// registers based on the characteristics of the function, subtarget, or\n  /// other criteria.\n  ///\n  /// By default, this method returns all registers in the class.\n  ArrayRef<MCPhysReg> getRawAllocationOrder(const MachineFunction &MF) const {\n    return OrderFunc ? OrderFunc(MF) : makeArrayRef(begin(), getNumRegs());\n  }\n\n  /// Returns the combination of all lane masks of register in this class.\n  /// The lane masks of the registers are the combination of all lane masks\n  /// of their subregisters. Returns 1 if there are no subregisters.\n  LaneBitmask getLaneMask() const {\n    return LaneMask;\n  }\n};\n\n/// Extra information, not in MCRegisterDesc, about registers.\n/// These are used by codegen, not by MC.\nstruct TargetRegisterInfoDesc {\n  const uint8_t *CostPerUse; // Extra cost of instructions using register.\n  unsigned NumCosts; // Number of cost values associated with each register.\n  const bool\n      *InAllocatableClass; // Register belongs to an allocatable regclass.\n};\n\n/// Each TargetRegisterClass has a per register weight, and weight\n/// limit which must be less than the limits of its pressure sets.\nstruct RegClassWeight {\n  unsigned RegWeight;\n  unsigned WeightLimit;\n};\n\n/// TargetRegisterInfo base class - We assume that the target defines a static\n/// array of TargetRegisterDesc objects that represent all of the machine\n/// registers that the target has.  As such, we simply have to track a pointer\n/// to this array so that we can turn register number into a register\n/// descriptor.\n///\nclass TargetRegisterInfo : public MCRegisterInfo {\npublic:\n  using regclass_iterator = const TargetRegisterClass * const *;\n  using vt_iterator = const MVT::SimpleValueType *;\n  struct RegClassInfo {\n    unsigned RegSize, SpillSize, SpillAlignment;\n    vt_iterator VTList;\n  };\nprivate:\n  const TargetRegisterInfoDesc *InfoDesc;     // Extra desc array for codegen\n  const char *const *SubRegIndexNames;        // Names of subreg indexes.\n  // Pointer to array of lane masks, one per sub-reg index.\n  const LaneBitmask *SubRegIndexLaneMasks;\n\n  regclass_iterator RegClassBegin, RegClassEnd;   // List of regclasses\n  LaneBitmask CoveringLanes;\n  const RegClassInfo *const RCInfos;\n  unsigned HwMode;\n\nprotected:\n  TargetRegisterInfo(const TargetRegisterInfoDesc *ID,\n                     regclass_iterator RCB,\n                     regclass_iterator RCE,\n                     const char *const *SRINames,\n                     const LaneBitmask *SRILaneMasks,\n                     LaneBitmask CoveringLanes,\n                     const RegClassInfo *const RCIs,\n                     unsigned Mode = 0);\n  virtual ~TargetRegisterInfo();\n\npublic:\n  // Register numbers can represent physical registers, virtual registers, and\n  // sometimes stack slots. The unsigned values are divided into these ranges:\n  //\n  //   0           Not a register, can be used as a sentinel.\n  //   [1;2^30)    Physical registers assigned by TableGen.\n  //   [2^30;2^31) Stack slots. (Rarely used.)\n  //   [2^31;2^32) Virtual registers assigned by MachineRegisterInfo.\n  //\n  // Further sentinels can be allocated from the small negative integers.\n  // DenseMapInfo<unsigned> uses -1u and -2u.\n\n  /// Return the size in bits of a register from class RC.\n  unsigned getRegSizeInBits(const TargetRegisterClass &RC) const {\n    return getRegClassInfo(RC).RegSize;\n  }\n\n  /// Return the size in bytes of the stack slot allocated to hold a spilled\n  /// copy of a register from class RC.\n  unsigned getSpillSize(const TargetRegisterClass &RC) const {\n    return getRegClassInfo(RC).SpillSize / 8;\n  }\n\n  /// Return the minimum required alignment in bytes for a spill slot for\n  /// a register of this class.\n  unsigned getSpillAlignment(const TargetRegisterClass &RC) const {\n    return getRegClassInfo(RC).SpillAlignment / 8;\n  }\n\n  /// Return the minimum required alignment in bytes for a spill slot for\n  /// a register of this class.\n  Align getSpillAlign(const TargetRegisterClass &RC) const {\n    return Align(getRegClassInfo(RC).SpillAlignment / 8);\n  }\n\n  /// Return true if the given TargetRegisterClass has the ValueType T.\n  bool isTypeLegalForClass(const TargetRegisterClass &RC, MVT T) const {\n    for (auto I = legalclasstypes_begin(RC); *I != MVT::Other; ++I)\n      if (MVT(*I) == T)\n        return true;\n    return false;\n  }\n\n  /// Loop over all of the value types that can be represented by values\n  /// in the given register class.\n  vt_iterator legalclasstypes_begin(const TargetRegisterClass &RC) const {\n    return getRegClassInfo(RC).VTList;\n  }\n\n  vt_iterator legalclasstypes_end(const TargetRegisterClass &RC) const {\n    vt_iterator I = legalclasstypes_begin(RC);\n    while (*I != MVT::Other)\n      ++I;\n    return I;\n  }\n\n  /// Returns the Register Class of a physical register of the given type,\n  /// picking the most sub register class of the right type that contains this\n  /// physreg.\n  const TargetRegisterClass *getMinimalPhysRegClass(MCRegister Reg,\n                                                    MVT VT = MVT::Other) const;\n\n  /// Return the maximal subclass of the given register class that is\n  /// allocatable or NULL.\n  const TargetRegisterClass *\n    getAllocatableClass(const TargetRegisterClass *RC) const;\n\n  /// Returns a bitset indexed by register number indicating if a register is\n  /// allocatable or not. If a register class is specified, returns the subset\n  /// for the class.\n  BitVector getAllocatableSet(const MachineFunction &MF,\n                              const TargetRegisterClass *RC = nullptr) const;\n\n  /// Get a list of cost values for all registers that correspond to the index\n  /// returned by RegisterCostTableIndex.\n  ArrayRef<uint8_t> getRegisterCosts(const MachineFunction &MF) const {\n    unsigned Idx = getRegisterCostTableIndex(MF);\n    unsigned NumRegs = getNumRegs();\n    assert(Idx < InfoDesc->NumCosts && \"CostPerUse index out of bounds\");\n\n    return makeArrayRef(&InfoDesc->CostPerUse[Idx * NumRegs], NumRegs);\n  }\n\n  /// Return true if the register is in the allocation of any register class.\n  bool isInAllocatableClass(MCRegister RegNo) const {\n    return InfoDesc->InAllocatableClass[RegNo];\n  }\n\n  /// Return the human-readable symbolic target-specific\n  /// name for the specified SubRegIndex.\n  const char *getSubRegIndexName(unsigned SubIdx) const {\n    assert(SubIdx && SubIdx < getNumSubRegIndices() &&\n           \"This is not a subregister index\");\n    return SubRegIndexNames[SubIdx-1];\n  }\n\n  /// Return a bitmask representing the parts of a register that are covered by\n  /// SubIdx \\see LaneBitmask.\n  ///\n  /// SubIdx == 0 is allowed, it has the lane mask ~0u.\n  LaneBitmask getSubRegIndexLaneMask(unsigned SubIdx) const {\n    assert(SubIdx < getNumSubRegIndices() && \"This is not a subregister index\");\n    return SubRegIndexLaneMasks[SubIdx];\n  }\n\n  /// Try to find one or more subregister indexes to cover \\p LaneMask.\n  ///\n  /// If this is possible, returns true and appends the best matching set of\n  /// indexes to \\p Indexes. If this is not possible, returns false.\n  bool getCoveringSubRegIndexes(const MachineRegisterInfo &MRI,\n                                const TargetRegisterClass *RC,\n                                LaneBitmask LaneMask,\n                                SmallVectorImpl<unsigned> &Indexes) const;\n\n  /// The lane masks returned by getSubRegIndexLaneMask() above can only be\n  /// used to determine if sub-registers overlap - they can't be used to\n  /// determine if a set of sub-registers completely cover another\n  /// sub-register.\n  ///\n  /// The X86 general purpose registers have two lanes corresponding to the\n  /// sub_8bit and sub_8bit_hi sub-registers. Both sub_32bit and sub_16bit have\n  /// lane masks '3', but the sub_16bit sub-register doesn't fully cover the\n  /// sub_32bit sub-register.\n  ///\n  /// On the other hand, the ARM NEON lanes fully cover their registers: The\n  /// dsub_0 sub-register is completely covered by the ssub_0 and ssub_1 lanes.\n  /// This is related to the CoveredBySubRegs property on register definitions.\n  ///\n  /// This function returns a bit mask of lanes that completely cover their\n  /// sub-registers. More precisely, given:\n  ///\n  ///   Covering = getCoveringLanes();\n  ///   MaskA = getSubRegIndexLaneMask(SubA);\n  ///   MaskB = getSubRegIndexLaneMask(SubB);\n  ///\n  /// If (MaskA & ~(MaskB & Covering)) == 0, then SubA is completely covered by\n  /// SubB.\n  LaneBitmask getCoveringLanes() const { return CoveringLanes; }\n\n  /// Returns true if the two registers are equal or alias each other.\n  /// The registers may be virtual registers.\n  bool regsOverlap(Register regA, Register regB) const {\n    if (regA == regB) return true;\n    if (!regA.isPhysical() || !regB.isPhysical())\n      return false;\n\n    // Regunits are numerically ordered. Find a common unit.\n    MCRegUnitIterator RUA(regA.asMCReg(), this);\n    MCRegUnitIterator RUB(regB.asMCReg(), this);\n    do {\n      if (*RUA == *RUB) return true;\n      if (*RUA < *RUB) ++RUA;\n      else             ++RUB;\n    } while (RUA.isValid() && RUB.isValid());\n    return false;\n  }\n\n  /// Returns true if Reg contains RegUnit.\n  bool hasRegUnit(MCRegister Reg, Register RegUnit) const {\n    for (MCRegUnitIterator Units(Reg, this); Units.isValid(); ++Units)\n      if (Register(*Units) == RegUnit)\n        return true;\n    return false;\n  }\n\n  /// Returns the original SrcReg unless it is the target of a copy-like\n  /// operation, in which case we chain backwards through all such operations\n  /// to the ultimate source register.  If a physical register is encountered,\n  /// we stop the search.\n  virtual Register lookThruCopyLike(Register SrcReg,\n                                    const MachineRegisterInfo *MRI) const;\n\n  /// Find the original SrcReg unless it is the target of a copy-like operation,\n  /// in which case we chain backwards through all such operations to the\n  /// ultimate source register. If a physical register is encountered, we stop\n  /// the search.\n  /// Return the original SrcReg if all the definitions in the chain only have\n  /// one user and not a physical register.\n  virtual Register\n  lookThruSingleUseCopyChain(Register SrcReg,\n                             const MachineRegisterInfo *MRI) const;\n\n  /// Return a null-terminated list of all of the callee-saved registers on\n  /// this target. The register should be in the order of desired callee-save\n  /// stack frame offset. The first register is closest to the incoming stack\n  /// pointer if stack grows down, and vice versa.\n  /// Notice: This function does not take into account disabled CSRs.\n  ///         In most cases you will want to use instead the function\n  ///         getCalleeSavedRegs that is implemented in MachineRegisterInfo.\n  virtual const MCPhysReg*\n  getCalleeSavedRegs(const MachineFunction *MF) const = 0;\n\n  /// Return a mask of call-preserved registers for the given calling convention\n  /// on the current function. The mask should include all call-preserved\n  /// aliases. This is used by the register allocator to determine which\n  /// registers can be live across a call.\n  ///\n  /// The mask is an array containing (TRI::getNumRegs()+31)/32 entries.\n  /// A set bit indicates that all bits of the corresponding register are\n  /// preserved across the function call.  The bit mask is expected to be\n  /// sub-register complete, i.e. if A is preserved, so are all its\n  /// sub-registers.\n  ///\n  /// Bits are numbered from the LSB, so the bit for physical register Reg can\n  /// be found as (Mask[Reg / 32] >> Reg % 32) & 1.\n  ///\n  /// A NULL pointer means that no register mask will be used, and call\n  /// instructions should use implicit-def operands to indicate call clobbered\n  /// registers.\n  ///\n  virtual const uint32_t *getCallPreservedMask(const MachineFunction &MF,\n                                               CallingConv::ID) const {\n    // The default mask clobbers everything.  All targets should override.\n    return nullptr;\n  }\n\n  /// Return a register mask for the registers preserved by the unwinder,\n  /// or nullptr if no custom mask is needed.\n  virtual const uint32_t *\n  getCustomEHPadPreservedMask(const MachineFunction &MF) const {\n    return nullptr;\n  }\n\n  /// Return a register mask that clobbers everything.\n  virtual const uint32_t *getNoPreservedMask() const {\n    llvm_unreachable(\"target does not provide no preserved mask\");\n  }\n\n  /// Return a list of all of the registers which are clobbered \"inside\" a call\n  /// to the given function. For example, these might be needed for PLT\n  /// sequences of long-branch veneers.\n  virtual ArrayRef<MCPhysReg>\n  getIntraCallClobberedRegs(const MachineFunction *MF) const {\n    return {};\n  }\n\n  /// Return true if all bits that are set in mask \\p mask0 are also set in\n  /// \\p mask1.\n  bool regmaskSubsetEqual(const uint32_t *mask0, const uint32_t *mask1) const;\n\n  /// Return all the call-preserved register masks defined for this target.\n  virtual ArrayRef<const uint32_t *> getRegMasks() const = 0;\n  virtual ArrayRef<const char *> getRegMaskNames() const = 0;\n\n  /// Returns a bitset indexed by physical register number indicating if a\n  /// register is a special register that has particular uses and should be\n  /// considered unavailable at all times, e.g. stack pointer, return address.\n  /// A reserved register:\n  /// - is not allocatable\n  /// - is considered always live\n  /// - is ignored by liveness tracking\n  /// It is often necessary to reserve the super registers of a reserved\n  /// register as well, to avoid them getting allocated indirectly. You may use\n  /// markSuperRegs() and checkAllSuperRegsMarked() in this case.\n  virtual BitVector getReservedRegs(const MachineFunction &MF) const = 0;\n\n  /// Returns false if we can't guarantee that Physreg, specified as an IR asm\n  /// clobber constraint, will be preserved across the statement.\n  virtual bool isAsmClobberable(const MachineFunction &MF,\n                                MCRegister PhysReg) const {\n    return true;\n  }\n\n  /// Returns true if PhysReg cannot be written to in inline asm statements.\n  virtual bool isInlineAsmReadOnlyReg(const MachineFunction &MF,\n                                      unsigned PhysReg) const {\n    return false;\n  }\n\n  /// Returns true if PhysReg is unallocatable and constant throughout the\n  /// function.  Used by MachineRegisterInfo::isConstantPhysReg().\n  virtual bool isConstantPhysReg(MCRegister PhysReg) const { return false; }\n\n  /// Returns true if the register class is considered divergent.\n  virtual bool isDivergentRegClass(const TargetRegisterClass *RC) const {\n    return false;\n  }\n\n  /// Physical registers that may be modified within a function but are\n  /// guaranteed to be restored before any uses. This is useful for targets that\n  /// have call sequences where a GOT register may be updated by the caller\n  /// prior to a call and is guaranteed to be restored (also by the caller)\n  /// after the call.\n  virtual bool isCallerPreservedPhysReg(MCRegister PhysReg,\n                                        const MachineFunction &MF) const {\n    return false;\n  }\n\n  /// This is a wrapper around getCallPreservedMask().\n  /// Return true if the register is preserved after the call.\n  virtual bool isCalleeSavedPhysReg(MCRegister PhysReg,\n                                    const MachineFunction &MF) const;\n\n  /// Prior to adding the live-out mask to a stackmap or patchpoint\n  /// instruction, provide the target the opportunity to adjust it (mainly to\n  /// remove pseudo-registers that should be ignored).\n  virtual void adjustStackMapLiveOutMask(uint32_t *Mask) const {}\n\n  /// Return a super-register of the specified register\n  /// Reg so its sub-register of index SubIdx is Reg.\n  MCRegister getMatchingSuperReg(MCRegister Reg, unsigned SubIdx,\n                                 const TargetRegisterClass *RC) const {\n    return MCRegisterInfo::getMatchingSuperReg(Reg, SubIdx, RC->MC);\n  }\n\n  /// Return a subclass of the specified register\n  /// class A so that each register in it has a sub-register of the\n  /// specified sub-register index which is in the specified register class B.\n  ///\n  /// TableGen will synthesize missing A sub-classes.\n  virtual const TargetRegisterClass *\n  getMatchingSuperRegClass(const TargetRegisterClass *A,\n                           const TargetRegisterClass *B, unsigned Idx) const;\n\n  // For a copy-like instruction that defines a register of class DefRC with\n  // subreg index DefSubReg, reading from another source with class SrcRC and\n  // subregister SrcSubReg return true if this is a preferable copy\n  // instruction or an earlier use should be used.\n  virtual bool shouldRewriteCopySrc(const TargetRegisterClass *DefRC,\n                                    unsigned DefSubReg,\n                                    const TargetRegisterClass *SrcRC,\n                                    unsigned SrcSubReg) const;\n\n  /// Returns the largest legal sub-class of RC that\n  /// supports the sub-register index Idx.\n  /// If no such sub-class exists, return NULL.\n  /// If all registers in RC already have an Idx sub-register, return RC.\n  ///\n  /// TableGen generates a version of this function that is good enough in most\n  /// cases.  Targets can override if they have constraints that TableGen\n  /// doesn't understand.  For example, the x86 sub_8bit sub-register index is\n  /// supported by the full GR32 register class in 64-bit mode, but only by the\n  /// GR32_ABCD regiister class in 32-bit mode.\n  ///\n  /// TableGen will synthesize missing RC sub-classes.\n  virtual const TargetRegisterClass *\n  getSubClassWithSubReg(const TargetRegisterClass *RC, unsigned Idx) const {\n    assert(Idx == 0 && \"Target has no sub-registers\");\n    return RC;\n  }\n\n  /// Return the subregister index you get from composing\n  /// two subregister indices.\n  ///\n  /// The special null sub-register index composes as the identity.\n  ///\n  /// If R:a:b is the same register as R:c, then composeSubRegIndices(a, b)\n  /// returns c. Note that composeSubRegIndices does not tell you about illegal\n  /// compositions. If R does not have a subreg a, or R:a does not have a subreg\n  /// b, composeSubRegIndices doesn't tell you.\n  ///\n  /// The ARM register Q0 has two D subregs dsub_0:D0 and dsub_1:D1. It also has\n  /// ssub_0:S0 - ssub_3:S3 subregs.\n  /// If you compose subreg indices dsub_1, ssub_0 you get ssub_2.\n  unsigned composeSubRegIndices(unsigned a, unsigned b) const {\n    if (!a) return b;\n    if (!b) return a;\n    return composeSubRegIndicesImpl(a, b);\n  }\n\n  /// Transforms a LaneMask computed for one subregister to the lanemask that\n  /// would have been computed when composing the subsubregisters with IdxA\n  /// first. @sa composeSubRegIndices()\n  LaneBitmask composeSubRegIndexLaneMask(unsigned IdxA,\n                                         LaneBitmask Mask) const {\n    if (!IdxA)\n      return Mask;\n    return composeSubRegIndexLaneMaskImpl(IdxA, Mask);\n  }\n\n  /// Transform a lanemask given for a virtual register to the corresponding\n  /// lanemask before using subregister with index \\p IdxA.\n  /// This is the reverse of composeSubRegIndexLaneMask(), assuming Mask is a\n  /// valie lane mask (no invalid bits set) the following holds:\n  /// X0 = composeSubRegIndexLaneMask(Idx, Mask)\n  /// X1 = reverseComposeSubRegIndexLaneMask(Idx, X0)\n  /// => X1 == Mask\n  LaneBitmask reverseComposeSubRegIndexLaneMask(unsigned IdxA,\n                                                LaneBitmask LaneMask) const {\n    if (!IdxA)\n      return LaneMask;\n    return reverseComposeSubRegIndexLaneMaskImpl(IdxA, LaneMask);\n  }\n\n  /// Debugging helper: dump register in human readable form to dbgs() stream.\n  static void dumpReg(Register Reg, unsigned SubRegIndex = 0,\n                      const TargetRegisterInfo *TRI = nullptr);\n\nprotected:\n  /// Overridden by TableGen in targets that have sub-registers.\n  virtual unsigned composeSubRegIndicesImpl(unsigned, unsigned) const {\n    llvm_unreachable(\"Target has no sub-registers\");\n  }\n\n  /// Overridden by TableGen in targets that have sub-registers.\n  virtual LaneBitmask\n  composeSubRegIndexLaneMaskImpl(unsigned, LaneBitmask) const {\n    llvm_unreachable(\"Target has no sub-registers\");\n  }\n\n  virtual LaneBitmask reverseComposeSubRegIndexLaneMaskImpl(unsigned,\n                                                            LaneBitmask) const {\n    llvm_unreachable(\"Target has no sub-registers\");\n  }\n\n  /// Return the register cost table index. This implementation is sufficient\n  /// for most architectures and can be overriden by targets in case there are\n  /// multiple cost values associated with each register.\n  virtual unsigned getRegisterCostTableIndex(const MachineFunction &MF) const {\n    return 0;\n  }\n\npublic:\n  /// Find a common super-register class if it exists.\n  ///\n  /// Find a register class, SuperRC and two sub-register indices, PreA and\n  /// PreB, such that:\n  ///\n  ///   1. PreA + SubA == PreB + SubB  (using composeSubRegIndices()), and\n  ///\n  ///   2. For all Reg in SuperRC: Reg:PreA in RCA and Reg:PreB in RCB, and\n  ///\n  ///   3. SuperRC->getSize() >= max(RCA->getSize(), RCB->getSize()).\n  ///\n  /// SuperRC will be chosen such that no super-class of SuperRC satisfies the\n  /// requirements, and there is no register class with a smaller spill size\n  /// that satisfies the requirements.\n  ///\n  /// SubA and SubB must not be 0. Use getMatchingSuperRegClass() instead.\n  ///\n  /// Either of the PreA and PreB sub-register indices may be returned as 0. In\n  /// that case, the returned register class will be a sub-class of the\n  /// corresponding argument register class.\n  ///\n  /// The function returns NULL if no register class can be found.\n  const TargetRegisterClass*\n  getCommonSuperRegClass(const TargetRegisterClass *RCA, unsigned SubA,\n                         const TargetRegisterClass *RCB, unsigned SubB,\n                         unsigned &PreA, unsigned &PreB) const;\n\n  //===--------------------------------------------------------------------===//\n  // Register Class Information\n  //\nprotected:\n  const RegClassInfo &getRegClassInfo(const TargetRegisterClass &RC) const {\n    return RCInfos[getNumRegClasses() * HwMode + RC.getID()];\n  }\n\npublic:\n  /// Register class iterators\n  regclass_iterator regclass_begin() const { return RegClassBegin; }\n  regclass_iterator regclass_end() const { return RegClassEnd; }\n  iterator_range<regclass_iterator> regclasses() const {\n    return make_range(regclass_begin(), regclass_end());\n  }\n\n  unsigned getNumRegClasses() const {\n    return (unsigned)(regclass_end()-regclass_begin());\n  }\n\n  /// Returns the register class associated with the enumeration value.\n  /// See class MCOperandInfo.\n  const TargetRegisterClass *getRegClass(unsigned i) const {\n    assert(i < getNumRegClasses() && \"Register Class ID out of range\");\n    return RegClassBegin[i];\n  }\n\n  /// Returns the name of the register class.\n  const char *getRegClassName(const TargetRegisterClass *Class) const {\n    return MCRegisterInfo::getRegClassName(Class->MC);\n  }\n\n  /// Find the largest common subclass of A and B.\n  /// Return NULL if there is no common subclass.\n  const TargetRegisterClass *\n  getCommonSubClass(const TargetRegisterClass *A,\n                    const TargetRegisterClass *B) const;\n\n  /// Returns a TargetRegisterClass used for pointer values.\n  /// If a target supports multiple different pointer register classes,\n  /// kind specifies which one is indicated.\n  virtual const TargetRegisterClass *\n  getPointerRegClass(const MachineFunction &MF, unsigned Kind=0) const {\n    llvm_unreachable(\"Target didn't implement getPointerRegClass!\");\n  }\n\n  /// Returns a legal register class to copy a register in the specified class\n  /// to or from. If it is possible to copy the register directly without using\n  /// a cross register class copy, return the specified RC. Returns NULL if it\n  /// is not possible to copy between two registers of the specified class.\n  virtual const TargetRegisterClass *\n  getCrossCopyRegClass(const TargetRegisterClass *RC) const {\n    return RC;\n  }\n\n  /// Returns the largest super class of RC that is legal to use in the current\n  /// sub-target and has the same spill size.\n  /// The returned register class can be used to create virtual registers which\n  /// means that all its registers can be copied and spilled.\n  virtual const TargetRegisterClass *\n  getLargestLegalSuperClass(const TargetRegisterClass *RC,\n                            const MachineFunction &) const {\n    /// The default implementation is very conservative and doesn't allow the\n    /// register allocator to inflate register classes.\n    return RC;\n  }\n\n  /// Return the register pressure \"high water mark\" for the specific register\n  /// class. The scheduler is in high register pressure mode (for the specific\n  /// register class) if it goes over the limit.\n  ///\n  /// Note: this is the old register pressure model that relies on a manually\n  /// specified representative register class per value type.\n  virtual unsigned getRegPressureLimit(const TargetRegisterClass *RC,\n                                       MachineFunction &MF) const {\n    return 0;\n  }\n\n  /// Return a heuristic for the machine scheduler to compare the profitability\n  /// of increasing one register pressure set versus another.  The scheduler\n  /// will prefer increasing the register pressure of the set which returns\n  /// the largest value for this function.\n  virtual unsigned getRegPressureSetScore(const MachineFunction &MF,\n                                          unsigned PSetID) const {\n    return PSetID;\n  }\n\n  /// Get the weight in units of pressure for this register class.\n  virtual const RegClassWeight &getRegClassWeight(\n    const TargetRegisterClass *RC) const = 0;\n\n  /// Returns size in bits of a phys/virtual/generic register.\n  unsigned getRegSizeInBits(Register Reg, const MachineRegisterInfo &MRI) const;\n\n  /// Get the weight in units of pressure for this register unit.\n  virtual unsigned getRegUnitWeight(unsigned RegUnit) const = 0;\n\n  /// Get the number of dimensions of register pressure.\n  virtual unsigned getNumRegPressureSets() const = 0;\n\n  /// Get the name of this register unit pressure set.\n  virtual const char *getRegPressureSetName(unsigned Idx) const = 0;\n\n  /// Get the register unit pressure limit for this dimension.\n  /// This limit must be adjusted dynamically for reserved registers.\n  virtual unsigned getRegPressureSetLimit(const MachineFunction &MF,\n                                          unsigned Idx) const = 0;\n\n  /// Get the dimensions of register pressure impacted by this register class.\n  /// Returns a -1 terminated array of pressure set IDs.\n  virtual const int *getRegClassPressureSets(\n    const TargetRegisterClass *RC) const = 0;\n\n  /// Get the dimensions of register pressure impacted by this register unit.\n  /// Returns a -1 terminated array of pressure set IDs.\n  virtual const int *getRegUnitPressureSets(unsigned RegUnit) const = 0;\n\n  /// Get a list of 'hint' registers that the register allocator should try\n  /// first when allocating a physical register for the virtual register\n  /// VirtReg. These registers are effectively moved to the front of the\n  /// allocation order. If true is returned, regalloc will try to only use\n  /// hints to the greatest extent possible even if it means spilling.\n  ///\n  /// The Order argument is the allocation order for VirtReg's register class\n  /// as returned from RegisterClassInfo::getOrder(). The hint registers must\n  /// come from Order, and they must not be reserved.\n  ///\n  /// The default implementation of this function will only add target\n  /// independent register allocation hints. Targets that override this\n  /// function should typically call this default implementation as well and\n  /// expect to see generic copy hints added.\n  virtual bool\n  getRegAllocationHints(Register VirtReg, ArrayRef<MCPhysReg> Order,\n                        SmallVectorImpl<MCPhysReg> &Hints,\n                        const MachineFunction &MF,\n                        const VirtRegMap *VRM = nullptr,\n                        const LiveRegMatrix *Matrix = nullptr) const;\n\n  /// A callback to allow target a chance to update register allocation hints\n  /// when a register is \"changed\" (e.g. coalesced) to another register.\n  /// e.g. On ARM, some virtual registers should target register pairs,\n  /// if one of pair is coalesced to another register, the allocation hint of\n  /// the other half of the pair should be changed to point to the new register.\n  virtual void updateRegAllocHint(Register Reg, Register NewReg,\n                                  MachineFunction &MF) const {\n    // Do nothing.\n  }\n\n  /// Allow the target to reverse allocation order of local live ranges. This\n  /// will generally allocate shorter local live ranges first. For targets with\n  /// many registers, this could reduce regalloc compile time by a large\n  /// factor. It is disabled by default for three reasons:\n  /// (1) Top-down allocation is simpler and easier to debug for targets that\n  /// don't benefit from reversing the order.\n  /// (2) Bottom-up allocation could result in poor evicition decisions on some\n  /// targets affecting the performance of compiled code.\n  /// (3) Bottom-up allocation is no longer guaranteed to optimally color.\n  virtual bool reverseLocalAssignment() const { return false; }\n\n  /// Allow the target to override the cost of using a callee-saved register for\n  /// the first time. Default value of 0 means we will use a callee-saved\n  /// register if it is available.\n  virtual unsigned getCSRFirstUseCost() const { return 0; }\n\n  /// Returns true if the target requires (and can make use of) the register\n  /// scavenger.\n  virtual bool requiresRegisterScavenging(const MachineFunction &MF) const {\n    return false;\n  }\n\n  /// Returns true if the target wants to use frame pointer based accesses to\n  /// spill to the scavenger emergency spill slot.\n  virtual bool useFPForScavengingIndex(const MachineFunction &MF) const {\n    return true;\n  }\n\n  /// Returns true if the target requires post PEI scavenging of registers for\n  /// materializing frame index constants.\n  virtual bool requiresFrameIndexScavenging(const MachineFunction &MF) const {\n    return false;\n  }\n\n  /// Returns true if the target requires using the RegScavenger directly for\n  /// frame elimination despite using requiresFrameIndexScavenging.\n  virtual bool requiresFrameIndexReplacementScavenging(\n      const MachineFunction &MF) const {\n    return false;\n  }\n\n  /// Returns true if the target wants the LocalStackAllocation pass to be run\n  /// and virtual base registers used for more efficient stack access.\n  virtual bool requiresVirtualBaseRegisters(const MachineFunction &MF) const {\n    return false;\n  }\n\n  /// Return true if target has reserved a spill slot in the stack frame of\n  /// the given function for the specified register. e.g. On x86, if the frame\n  /// register is required, the first fixed stack object is reserved as its\n  /// spill slot. This tells PEI not to create a new stack frame\n  /// object for the given register. It should be called only after\n  /// determineCalleeSaves().\n  virtual bool hasReservedSpillSlot(const MachineFunction &MF, Register Reg,\n                                    int &FrameIdx) const {\n    return false;\n  }\n\n  /// Returns true if the live-ins should be tracked after register allocation.\n  virtual bool trackLivenessAfterRegAlloc(const MachineFunction &MF) const {\n    return true;\n  }\n\n  /// True if the stack can be realigned for the target.\n  virtual bool canRealignStack(const MachineFunction &MF) const;\n\n  /// True if storage within the function requires the stack pointer to be\n  /// aligned more than the normal calling convention calls for.\n  /// This cannot be overriden by the target, but canRealignStack can be\n  /// overridden.\n  bool needsStackRealignment(const MachineFunction &MF) const;\n\n  /// Get the offset from the referenced frame index in the instruction,\n  /// if there is one.\n  virtual int64_t getFrameIndexInstrOffset(const MachineInstr *MI,\n                                           int Idx) const {\n    return 0;\n  }\n\n  /// Returns true if the instruction's frame index reference would be better\n  /// served by a base register other than FP or SP.\n  /// Used by LocalStackFrameAllocation to determine which frame index\n  /// references it should create new base registers for.\n  virtual bool needsFrameBaseReg(MachineInstr *MI, int64_t Offset) const {\n    return false;\n  }\n\n  /// Insert defining instruction(s) for a pointer to FrameIdx before\n  /// insertion point I. Return materialized frame pointer.\n  virtual Register materializeFrameBaseRegister(MachineBasicBlock *MBB,\n                                                int FrameIdx,\n                                                int64_t Offset) const {\n    llvm_unreachable(\"materializeFrameBaseRegister does not exist on this \"\n                     \"target\");\n  }\n\n  /// Resolve a frame index operand of an instruction\n  /// to reference the indicated base register plus offset instead.\n  virtual void resolveFrameIndex(MachineInstr &MI, Register BaseReg,\n                                 int64_t Offset) const {\n    llvm_unreachable(\"resolveFrameIndex does not exist on this target\");\n  }\n\n  /// Determine whether a given base register plus offset immediate is\n  /// encodable to resolve a frame index.\n  virtual bool isFrameOffsetLegal(const MachineInstr *MI, Register BaseReg,\n                                  int64_t Offset) const {\n    llvm_unreachable(\"isFrameOffsetLegal does not exist on this target\");\n  }\n\n  /// Gets the DWARF expression opcodes for \\p Offset.\n  virtual void getOffsetOpcodes(const StackOffset &Offset,\n                                SmallVectorImpl<uint64_t> &Ops) const;\n\n  /// Prepends a DWARF expression for \\p Offset to DIExpression \\p Expr.\n  DIExpression *\n  prependOffsetExpression(const DIExpression *Expr, unsigned PrependFlags,\n                          const StackOffset &Offset) const;\n\n  /// Spill the register so it can be used by the register scavenger.\n  /// Return true if the register was spilled, false otherwise.\n  /// If this function does not spill the register, the scavenger\n  /// will instead spill it to the emergency spill slot.\n  virtual bool saveScavengerRegister(MachineBasicBlock &MBB,\n                                     MachineBasicBlock::iterator I,\n                                     MachineBasicBlock::iterator &UseMI,\n                                     const TargetRegisterClass *RC,\n                                     Register Reg) const {\n    return false;\n  }\n\n  /// This method must be overriden to eliminate abstract frame indices from\n  /// instructions which may use them. The instruction referenced by the\n  /// iterator contains an MO_FrameIndex operand which must be eliminated by\n  /// this method. This method may modify or replace the specified instruction,\n  /// as long as it keeps the iterator pointing at the finished product.\n  /// SPAdj is the SP adjustment due to call frame setup instruction.\n  /// FIOperandNum is the FI operand number.\n  virtual void eliminateFrameIndex(MachineBasicBlock::iterator MI,\n                                   int SPAdj, unsigned FIOperandNum,\n                                   RegScavenger *RS = nullptr) const = 0;\n\n  /// Return the assembly name for \\p Reg.\n  virtual StringRef getRegAsmName(MCRegister Reg) const {\n    // FIXME: We are assuming that the assembly name is equal to the TableGen\n    // name converted to lower case\n    //\n    // The TableGen name is the name of the definition for this register in the\n    // target's tablegen files.  For example, the TableGen name of\n    // def EAX : Register <...>; is \"EAX\"\n    return StringRef(getName(Reg));\n  }\n\n  //===--------------------------------------------------------------------===//\n  /// Subtarget Hooks\n\n  /// SrcRC and DstRC will be morphed into NewRC if this returns true.\n  virtual bool shouldCoalesce(MachineInstr *MI,\n                              const TargetRegisterClass *SrcRC,\n                              unsigned SubReg,\n                              const TargetRegisterClass *DstRC,\n                              unsigned DstSubReg,\n                              const TargetRegisterClass *NewRC,\n                              LiveIntervals &LIS) const\n  { return true; }\n\n  /// Region split has a high compile time cost especially for large live range.\n  /// This method is used to decide whether or not \\p VirtReg should\n  /// go through this expensive splitting heuristic.\n  virtual bool shouldRegionSplitForVirtReg(const MachineFunction &MF,\n                                           const LiveInterval &VirtReg) const;\n\n  /// Last chance recoloring has a high compile time cost especially for\n  /// targets with a lot of registers.\n  /// This method is used to decide whether or not \\p VirtReg should\n  /// go through this expensive heuristic.\n  /// When this target hook is hit, by returning false, there is a high\n  /// chance that the register allocation will fail altogether (usually with\n  /// \"ran out of registers\").\n  /// That said, this error usually points to another problem in the\n  /// optimization pipeline.\n  virtual bool\n  shouldUseLastChanceRecoloringForVirtReg(const MachineFunction &MF,\n                                          const LiveInterval &VirtReg) const {\n    return true;\n  }\n\n  /// Deferred spilling delays the spill insertion of a virtual register\n  /// after every other allocation. By deferring the spilling, it is\n  /// sometimes possible to eliminate that spilling altogether because\n  /// something else could have been eliminated, thus leaving some space\n  /// for the virtual register.\n  /// However, this comes with a compile time impact because it adds one\n  /// more stage to the greedy register allocator.\n  /// This method is used to decide whether \\p VirtReg should use the deferred\n  /// spilling stage instead of being spilled right away.\n  virtual bool\n  shouldUseDeferredSpillingForVirtReg(const MachineFunction &MF,\n                                      const LiveInterval &VirtReg) const {\n    return false;\n  }\n\n  //===--------------------------------------------------------------------===//\n  /// Debug information queries.\n\n  /// getFrameRegister - This method should return the register used as a base\n  /// for values allocated in the current stack frame.\n  virtual Register getFrameRegister(const MachineFunction &MF) const = 0;\n\n  /// Mark a register and all its aliases as reserved in the given set.\n  void markSuperRegs(BitVector &RegisterSet, MCRegister Reg) const;\n\n  /// Returns true if for every register in the set all super registers are part\n  /// of the set as well.\n  bool checkAllSuperRegsMarked(const BitVector &RegisterSet,\n      ArrayRef<MCPhysReg> Exceptions = ArrayRef<MCPhysReg>()) const;\n\n  virtual const TargetRegisterClass *\n  getConstrainedRegClassForOperand(const MachineOperand &MO,\n                                   const MachineRegisterInfo &MRI) const {\n    return nullptr;\n  }\n\n  /// Returns the physical register number of sub-register \"Index\"\n  /// for physical register RegNo. Return zero if the sub-register does not\n  /// exist.\n  inline MCRegister getSubReg(MCRegister Reg, unsigned Idx) const {\n    return static_cast<const MCRegisterInfo *>(this)->getSubReg(Reg, Idx);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                           SuperRegClassIterator\n//===----------------------------------------------------------------------===//\n//\n// Iterate over the possible super-registers for a given register class. The\n// iterator will visit a list of pairs (Idx, Mask) corresponding to the\n// possible classes of super-registers.\n//\n// Each bit mask will have at least one set bit, and each set bit in Mask\n// corresponds to a SuperRC such that:\n//\n//   For all Reg in SuperRC: Reg:Idx is in RC.\n//\n// The iterator can include (O, RC->getSubClassMask()) as the first entry which\n// also satisfies the above requirement, assuming Reg:0 == Reg.\n//\nclass SuperRegClassIterator {\n  const unsigned RCMaskWords;\n  unsigned SubReg = 0;\n  const uint16_t *Idx;\n  const uint32_t *Mask;\n\npublic:\n  /// Create a SuperRegClassIterator that visits all the super-register classes\n  /// of RC. When IncludeSelf is set, also include the (0, sub-classes) entry.\n  SuperRegClassIterator(const TargetRegisterClass *RC,\n                        const TargetRegisterInfo *TRI,\n                        bool IncludeSelf = false)\n    : RCMaskWords((TRI->getNumRegClasses() + 31) / 32),\n      Idx(RC->getSuperRegIndices()), Mask(RC->getSubClassMask()) {\n    if (!IncludeSelf)\n      ++*this;\n  }\n\n  /// Returns true if this iterator is still pointing at a valid entry.\n  bool isValid() const { return Idx; }\n\n  /// Returns the current sub-register index.\n  unsigned getSubReg() const { return SubReg; }\n\n  /// Returns the bit mask of register classes that getSubReg() projects into\n  /// RC.\n  /// See TargetRegisterClass::getSubClassMask() for how to use it.\n  const uint32_t *getMask() const { return Mask; }\n\n  /// Advance iterator to the next entry.\n  void operator++() {\n    assert(isValid() && \"Cannot move iterator past end.\");\n    Mask += RCMaskWords;\n    SubReg = *Idx++;\n    if (!SubReg)\n      Idx = nullptr;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                           BitMaskClassIterator\n//===----------------------------------------------------------------------===//\n/// This class encapuslates the logic to iterate over bitmask returned by\n/// the various RegClass related APIs.\n/// E.g., this class can be used to iterate over the subclasses provided by\n/// TargetRegisterClass::getSubClassMask or SuperRegClassIterator::getMask.\nclass BitMaskClassIterator {\n  /// Total number of register classes.\n  const unsigned NumRegClasses;\n  /// Base index of CurrentChunk.\n  /// In other words, the number of bit we read to get at the\n  /// beginning of that chunck.\n  unsigned Base = 0;\n  /// Adjust base index of CurrentChunk.\n  /// Base index + how many bit we read within CurrentChunk.\n  unsigned Idx = 0;\n  /// Current register class ID.\n  unsigned ID = 0;\n  /// Mask we are iterating over.\n  const uint32_t *Mask;\n  /// Current chunk of the Mask we are traversing.\n  uint32_t CurrentChunk;\n\n  /// Move ID to the next set bit.\n  void moveToNextID() {\n    // If the current chunk of memory is empty, move to the next one,\n    // while making sure we do not go pass the number of register\n    // classes.\n    while (!CurrentChunk) {\n      // Move to the next chunk.\n      Base += 32;\n      if (Base >= NumRegClasses) {\n        ID = NumRegClasses;\n        return;\n      }\n      CurrentChunk = *++Mask;\n      Idx = Base;\n    }\n    // Otherwise look for the first bit set from the right\n    // (representation of the class ID is big endian).\n    // See getSubClassMask for more details on the representation.\n    unsigned Offset = countTrailingZeros(CurrentChunk);\n    // Add the Offset to the adjusted base number of this chunk: Idx.\n    // This is the ID of the register class.\n    ID = Idx + Offset;\n\n    // Consume the zeros, if any, and the bit we just read\n    // so that we are at the right spot for the next call.\n    // Do not do Offset + 1 because Offset may be 31 and 32\n    // will be UB for the shift, though in that case we could\n    // have make the chunk being equal to 0, but that would\n    // have introduced a if statement.\n    moveNBits(Offset);\n    moveNBits(1);\n  }\n\n  /// Move \\p NumBits Bits forward in CurrentChunk.\n  void moveNBits(unsigned NumBits) {\n    assert(NumBits < 32 && \"Undefined behavior spotted!\");\n    // Consume the bit we read for the next call.\n    CurrentChunk >>= NumBits;\n    // Adjust the base for the chunk.\n    Idx += NumBits;\n  }\n\npublic:\n  /// Create a BitMaskClassIterator that visits all the register classes\n  /// represented by \\p Mask.\n  ///\n  /// \\pre \\p Mask != nullptr\n  BitMaskClassIterator(const uint32_t *Mask, const TargetRegisterInfo &TRI)\n      : NumRegClasses(TRI.getNumRegClasses()), Mask(Mask), CurrentChunk(*Mask) {\n    // Move to the first ID.\n    moveToNextID();\n  }\n\n  /// Returns true if this iterator is still pointing at a valid entry.\n  bool isValid() const { return getID() != NumRegClasses; }\n\n  /// Returns the current register class ID.\n  unsigned getID() const { return ID; }\n\n  /// Advance iterator to the next entry.\n  void operator++() {\n    assert(isValid() && \"Cannot move iterator past end.\");\n    moveToNextID();\n  }\n};\n\n// This is useful when building IndexedMaps keyed on virtual registers\nstruct VirtReg2IndexFunctor {\n  using argument_type = Register;\n  unsigned operator()(Register Reg) const {\n    return Register::virtReg2Index(Reg);\n  }\n};\n\n/// Prints virtual and physical registers with or without a TRI instance.\n///\n/// The format is:\n///   %noreg          - NoRegister\n///   %5              - a virtual register.\n///   %5:sub_8bit     - a virtual register with sub-register index (with TRI).\n///   %eax            - a physical register\n///   %physreg17      - a physical register when no TRI instance given.\n///\n/// Usage: OS << printReg(Reg, TRI, SubRegIdx) << '\\n';\nPrintable printReg(Register Reg, const TargetRegisterInfo *TRI = nullptr,\n                   unsigned SubIdx = 0,\n                   const MachineRegisterInfo *MRI = nullptr);\n\n/// Create Printable object to print register units on a \\ref raw_ostream.\n///\n/// Register units are named after their root registers:\n///\n///   al      - Single root.\n///   fp0~st7 - Dual roots.\n///\n/// Usage: OS << printRegUnit(Unit, TRI) << '\\n';\nPrintable printRegUnit(unsigned Unit, const TargetRegisterInfo *TRI);\n\n/// Create Printable object to print virtual registers and physical\n/// registers on a \\ref raw_ostream.\nPrintable printVRegOrUnit(unsigned VRegOrUnit, const TargetRegisterInfo *TRI);\n\n/// Create Printable object to print register classes or register banks\n/// on a \\ref raw_ostream.\nPrintable printRegClassOrBank(Register Reg, const MachineRegisterInfo &RegInfo,\n                              const TargetRegisterInfo *TRI);\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_TARGETREGISTERINFO_H\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Argument.h", "content": "//===-- llvm/Argument.h - Definition of the Argument class ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the Argument class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_ARGUMENT_H\n#define LLVM_IR_ARGUMENT_H\n\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/Value.h\"\n\nnamespace llvm {\n\n/// This class represents an incoming formal argument to a Function. A formal\n/// argument, since it is ``formal'', does not contain an actual value but\n/// instead represents the type, argument number, and attributes of an argument\n/// for a specific function. When used in the body of said function, the\n/// argument of course represents the value of the actual argument that the\n/// function was called with.\nclass Argument final : public Value {\n  Function *Parent;\n  unsigned ArgNo;\n\n  friend class Function;\n  void setParent(Function *parent);\n\npublic:\n  /// Argument constructor.\n  explicit Argument(Type *Ty, const Twine &Name = \"\", Function *F = nullptr,\n                    unsigned ArgNo = 0);\n\n  inline const Function *getParent() const { return Parent; }\n  inline       Function *getParent()       { return Parent; }\n\n  /// Return the index of this formal argument in its containing function.\n  ///\n  /// For example in \"void foo(int a, float b)\" a is 0 and b is 1.\n  unsigned getArgNo() const {\n    assert(Parent && \"can't get number of unparented arg\");\n    return ArgNo;\n  }\n\n  /// Return true if this argument has the nonnull attribute. Also returns true\n  /// if at least one byte is known to be dereferenceable and the pointer is in\n  /// addrspace(0).\n  /// If AllowUndefOrPoison is true, respect the semantics of nonnull attribute\n  /// and return true even if the argument can be undef or poison.\n  bool hasNonNullAttr(bool AllowUndefOrPoison = true) const;\n\n  /// If this argument has the dereferenceable attribute, return the number of\n  /// bytes known to be dereferenceable. Otherwise, zero is returned.\n  uint64_t getDereferenceableBytes() const;\n\n  /// If this argument has the dereferenceable_or_null attribute, return the\n  /// number of bytes known to be dereferenceable. Otherwise, zero is returned.\n  uint64_t getDereferenceableOrNullBytes() const;\n\n  /// Return true if this argument has the byval attribute.\n  bool hasByValAttr() const;\n\n  /// Return true if this argument has the byref attribute.\n  bool hasByRefAttr() const;\n\n  /// Return true if this argument has the swiftself attribute.\n  bool hasSwiftSelfAttr() const;\n\n  /// Return true if this argument has the swifterror attribute.\n  bool hasSwiftErrorAttr() const;\n\n  /// Return true if this argument has the byval, inalloca, or preallocated\n  /// attribute. These attributes represent arguments being passed by value,\n  /// with an associated copy between the caller and callee\n  bool hasPassPointeeByValueCopyAttr() const;\n\n  /// If this argument satisfies has hasPassPointeeByValueAttr, return the\n  /// in-memory ABI size copied to the stack for the call. Otherwise, return 0.\n  uint64_t getPassPointeeByValueCopySize(const DataLayout &DL) const;\n\n  /// Return true if this argument has the byval, sret, inalloca, preallocated,\n  /// or byref attribute. These attributes represent arguments being passed by\n  /// value (which may or may not involve a stack copy)\n  bool hasPointeeInMemoryValueAttr() const;\n\n  /// If hasPointeeInMemoryValueAttr returns true, the in-memory ABI type is\n  /// returned. Otherwise, nullptr.\n  Type *getPointeeInMemoryValueType() const;\n\n  /// If this is a byval or inalloca argument, return its alignment.\n  /// FIXME: Remove this function once transition to Align is over.\n  /// Use getParamAlign() instead.\n  unsigned getParamAlignment() const;\n\n  /// If this is a byval or inalloca argument, return its alignment.\n  MaybeAlign getParamAlign() const;\n\n  /// If this is a byval argument, return its type.\n  Type *getParamByValType() const;\n\n  /// If this is an sret argument, return its type.\n  Type *getParamStructRetType() const;\n\n  /// If this is a byref argument, return its type.\n  Type *getParamByRefType() const;\n\n  /// Return true if this argument has the nest attribute.\n  bool hasNestAttr() const;\n\n  /// Return true if this argument has the noalias attribute.\n  bool hasNoAliasAttr() const;\n\n  /// Return true if this argument has the nocapture attribute.\n  bool hasNoCaptureAttr() const;\n\n  /// Return true if this argument has the sret attribute.\n  bool hasStructRetAttr() const;\n\n  /// Return true if this argument has the inreg attribute.\n  bool hasInRegAttr() const;\n\n  /// Return true if this argument has the returned attribute.\n  bool hasReturnedAttr() const;\n\n  /// Return true if this argument has the readonly or readnone attribute.\n  bool onlyReadsMemory() const;\n\n  /// Return true if this argument has the inalloca attribute.\n  bool hasInAllocaAttr() const;\n\n  /// Return true if this argument has the preallocated attribute.\n  bool hasPreallocatedAttr() const;\n\n  /// Return true if this argument has the zext attribute.\n  bool hasZExtAttr() const;\n\n  /// Return true if this argument has the sext attribute.\n  bool hasSExtAttr() const;\n\n  /// Add attributes to an argument.\n  void addAttrs(AttrBuilder &B);\n\n  void addAttr(Attribute::AttrKind Kind);\n\n  void addAttr(Attribute Attr);\n\n  /// Remove attributes from an argument.\n  void removeAttr(Attribute::AttrKind Kind);\n\n  /// Check if an argument has a given attribute.\n  bool hasAttribute(Attribute::AttrKind Kind) const;\n\n  Attribute getAttribute(Attribute::AttrKind Kind) const;\n\n  /// Method for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Value *V) {\n    return V->getValueID() == ArgumentVal;\n  }\n};\n\n} // End llvm namespace\n\n#endif\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "content": "//===- llvm/Attributes.h - Container for Attributes -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// This file contains the simple types necessary to represent the\n/// attributes associated with functions and their calls.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_ATTRIBUTES_H\n#define LLVM_IR_ATTRIBUTES_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <bitset>\n#include <cassert>\n#include <cstdint>\n#include <map>\n#include <string>\n#include <utility>\n\nnamespace llvm {\n\nclass AttrBuilder;\nclass AttributeImpl;\nclass AttributeListImpl;\nclass AttributeSetNode;\ntemplate<typename T> struct DenseMapInfo;\nclass FoldingSetNodeID;\nclass Function;\nclass LLVMContext;\nclass Type;\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// Functions, function parameters, and return types can have attributes\n/// to indicate how they should be treated by optimizations and code\n/// generation. This class represents one of those attributes. It's light-weight\n/// and should be passed around by-value.\nclass Attribute {\npublic:\n  /// This enumeration lists the attributes that can be associated with\n  /// parameters, function results, or the function itself.\n  ///\n  /// Note: The `uwtable' attribute is about the ABI or the user mandating an\n  /// entry in the unwind table. The `nounwind' attribute is about an exception\n  /// passing by the function.\n  ///\n  /// In a theoretical system that uses tables for profiling and SjLj for\n  /// exceptions, they would be fully independent. In a normal system that uses\n  /// tables for both, the semantics are:\n  ///\n  /// nil                = Needs an entry because an exception might pass by.\n  /// nounwind           = No need for an entry\n  /// uwtable            = Needs an entry because the ABI says so and because\n  ///                      an exception might pass by.\n  /// uwtable + nounwind = Needs an entry because the ABI says so.\n\n  enum AttrKind {\n    // IR-Level Attributes\n    None,                  ///< No attributes have been set\n    #define GET_ATTR_NAMES\n    #define ATTRIBUTE_ENUM(ENUM_NAME, OTHER) ENUM_NAME,\n    #include \"llvm/IR/Attributes.inc\"\n    EndAttrKinds,          ///< Sentinal value useful for loops\n    EmptyKey,              ///< Use as Empty key for DenseMap of AttrKind\n    TombstoneKey,          ///< Use as Tombstone key for DenseMap of AttrKind\n  };\n\nprivate:\n  AttributeImpl *pImpl = nullptr;\n\n  Attribute(AttributeImpl *A) : pImpl(A) {}\n\npublic:\n  Attribute() = default;\n\n  //===--------------------------------------------------------------------===//\n  // Attribute Construction\n  //===--------------------------------------------------------------------===//\n\n  /// Return a uniquified Attribute object.\n  static Attribute get(LLVMContext &Context, AttrKind Kind, uint64_t Val = 0);\n  static Attribute get(LLVMContext &Context, StringRef Kind,\n                       StringRef Val = StringRef());\n  static Attribute get(LLVMContext &Context, AttrKind Kind, Type *Ty);\n\n  /// Return a uniquified Attribute object that has the specific\n  /// alignment set.\n  static Attribute getWithAlignment(LLVMContext &Context, Align Alignment);\n  static Attribute getWithStackAlignment(LLVMContext &Context, Align Alignment);\n  static Attribute getWithDereferenceableBytes(LLVMContext &Context,\n                                              uint64_t Bytes);\n  static Attribute getWithDereferenceableOrNullBytes(LLVMContext &Context,\n                                                     uint64_t Bytes);\n  static Attribute getWithAllocSizeArgs(LLVMContext &Context,\n                                        unsigned ElemSizeArg,\n                                        const Optional<unsigned> &NumElemsArg);\n  static Attribute getWithByValType(LLVMContext &Context, Type *Ty);\n  static Attribute getWithStructRetType(LLVMContext &Context, Type *Ty);\n  static Attribute getWithByRefType(LLVMContext &Context, Type *Ty);\n  static Attribute getWithPreallocatedType(LLVMContext &Context, Type *Ty);\n\n  /// For a typed attribute, return the equivalent attribute with the type\n  /// changed to \\p ReplacementTy.\n  Attribute getWithNewType(LLVMContext &Context, Type *ReplacementTy) {\n    assert(isTypeAttribute() && \"this requires a typed attribute\");\n    return get(Context, getKindAsEnum(), ReplacementTy);\n  }\n\n  static Attribute::AttrKind getAttrKindFromName(StringRef AttrName);\n\n  static StringRef getNameFromAttrKind(Attribute::AttrKind AttrKind);\n\n  /// Return true if and only if the attribute has an Argument.\n  static bool doesAttrKindHaveArgument(Attribute::AttrKind AttrKind);\n\n  /// Return true if the provided string matches the IR name of an attribute.\n  /// example: \"noalias\" return true but not \"NoAlias\"\n  static bool isExistingAttribute(StringRef Name);\n\n  //===--------------------------------------------------------------------===//\n  // Attribute Accessors\n  //===--------------------------------------------------------------------===//\n\n  /// Return true if the attribute is an Attribute::AttrKind type.\n  bool isEnumAttribute() const;\n\n  /// Return true if the attribute is an integer attribute.\n  bool isIntAttribute() const;\n\n  /// Return true if the attribute is a string (target-dependent)\n  /// attribute.\n  bool isStringAttribute() const;\n\n  /// Return true if the attribute is a type attribute.\n  bool isTypeAttribute() const;\n\n  /// Return true if the attribute is any kind of attribute.\n  bool isValid() const { return pImpl; }\n\n  /// Return true if the attribute is present.\n  bool hasAttribute(AttrKind Val) const;\n\n  /// Return true if the target-dependent attribute is present.\n  bool hasAttribute(StringRef Val) const;\n\n  /// Return the attribute's kind as an enum (Attribute::AttrKind). This\n  /// requires the attribute to be an enum or integer attribute.\n  Attribute::AttrKind getKindAsEnum() const;\n\n  /// Return the attribute's value as an integer. This requires that the\n  /// attribute be an integer attribute.\n  uint64_t getValueAsInt() const;\n\n  /// Return the attribute's kind as a string. This requires the\n  /// attribute to be a string attribute.\n  StringRef getKindAsString() const;\n\n  /// Return the attribute's value as a string. This requires the\n  /// attribute to be a string attribute.\n  StringRef getValueAsString() const;\n\n  /// Return the attribute's value as a Type. This requires the attribute to be\n  /// a type attribute.\n  Type *getValueAsType() const;\n\n  /// Returns the alignment field of an attribute as a byte alignment\n  /// value.\n  MaybeAlign getAlignment() const;\n\n  /// Returns the stack alignment field of an attribute as a byte\n  /// alignment value.\n  MaybeAlign getStackAlignment() const;\n\n  /// Returns the number of dereferenceable bytes from the\n  /// dereferenceable attribute.\n  uint64_t getDereferenceableBytes() const;\n\n  /// Returns the number of dereferenceable_or_null bytes from the\n  /// dereferenceable_or_null attribute.\n  uint64_t getDereferenceableOrNullBytes() const;\n\n  /// Returns the argument numbers for the allocsize attribute (or pair(0, 0)\n  /// if not known).\n  std::pair<unsigned, Optional<unsigned>> getAllocSizeArgs() const;\n\n  /// The Attribute is converted to a string of equivalent mnemonic. This\n  /// is, presumably, for writing out the mnemonics for the assembly writer.\n  std::string getAsString(bool InAttrGrp = false) const;\n\n  /// Equality and non-equality operators.\n  bool operator==(Attribute A) const { return pImpl == A.pImpl; }\n  bool operator!=(Attribute A) const { return pImpl != A.pImpl; }\n\n  /// Less-than operator. Useful for sorting the attributes list.\n  bool operator<(Attribute A) const;\n\n  void Profile(FoldingSetNodeID &ID) const;\n\n  /// Return a raw pointer that uniquely identifies this attribute.\n  void *getRawPointer() const {\n    return pImpl;\n  }\n\n  /// Get an attribute from a raw pointer created by getRawPointer.\n  static Attribute fromRawPointer(void *RawPtr) {\n    return Attribute(reinterpret_cast<AttributeImpl*>(RawPtr));\n  }\n};\n\n// Specialized opaque value conversions.\ninline LLVMAttributeRef wrap(Attribute Attr) {\n  return reinterpret_cast<LLVMAttributeRef>(Attr.getRawPointer());\n}\n\n// Specialized opaque value conversions.\ninline Attribute unwrap(LLVMAttributeRef Attr) {\n  return Attribute::fromRawPointer(Attr);\n}\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// This class holds the attributes for a particular argument, parameter,\n/// function, or return value. It is an immutable value type that is cheap to\n/// copy. Adding and removing enum attributes is intended to be fast, but adding\n/// and removing string or integer attributes involves a FoldingSet lookup.\nclass AttributeSet {\n  friend AttributeListImpl;\n  template <typename Ty> friend struct DenseMapInfo;\n\n  // TODO: Extract AvailableAttrs from AttributeSetNode and store them here.\n  // This will allow an efficient implementation of addAttribute and\n  // removeAttribute for enum attrs.\n\n  /// Private implementation pointer.\n  AttributeSetNode *SetNode = nullptr;\n\nprivate:\n  explicit AttributeSet(AttributeSetNode *ASN) : SetNode(ASN) {}\n\npublic:\n  /// AttributeSet is a trivially copyable value type.\n  AttributeSet() = default;\n  AttributeSet(const AttributeSet &) = default;\n  ~AttributeSet() = default;\n\n  static AttributeSet get(LLVMContext &C, const AttrBuilder &B);\n  static AttributeSet get(LLVMContext &C, ArrayRef<Attribute> Attrs);\n\n  bool operator==(const AttributeSet &O) const { return SetNode == O.SetNode; }\n  bool operator!=(const AttributeSet &O) const { return !(*this == O); }\n\n  /// Add an argument attribute. Returns a new set because attribute sets are\n  /// immutable.\n  LLVM_NODISCARD AttributeSet addAttribute(LLVMContext &C,\n                                           Attribute::AttrKind Kind) const;\n\n  /// Add a target-dependent attribute. Returns a new set because attribute sets\n  /// are immutable.\n  LLVM_NODISCARD AttributeSet addAttribute(LLVMContext &C, StringRef Kind,\n                                           StringRef Value = StringRef()) const;\n\n  /// Add attributes to the attribute set. Returns a new set because attribute\n  /// sets are immutable.\n  LLVM_NODISCARD AttributeSet addAttributes(LLVMContext &C,\n                                            AttributeSet AS) const;\n\n  /// Remove the specified attribute from this set. Returns a new set because\n  /// attribute sets are immutable.\n  LLVM_NODISCARD AttributeSet removeAttribute(LLVMContext &C,\n                                              Attribute::AttrKind Kind) const;\n\n  /// Remove the specified attribute from this set. Returns a new set because\n  /// attribute sets are immutable.\n  LLVM_NODISCARD AttributeSet removeAttribute(LLVMContext &C,\n                                              StringRef Kind) const;\n\n  /// Remove the specified attributes from this set. Returns a new set because\n  /// attribute sets are immutable.\n  LLVM_NODISCARD AttributeSet\n  removeAttributes(LLVMContext &C, const AttrBuilder &AttrsToRemove) const;\n\n  /// Return the number of attributes in this set.\n  unsigned getNumAttributes() const;\n\n  /// Return true if attributes exists in this set.\n  bool hasAttributes() const { return SetNode != nullptr; }\n\n  /// Return true if the attribute exists in this set.\n  bool hasAttribute(Attribute::AttrKind Kind) const;\n\n  /// Return true if the attribute exists in this set.\n  bool hasAttribute(StringRef Kind) const;\n\n  /// Return the attribute object.\n  Attribute getAttribute(Attribute::AttrKind Kind) const;\n\n  /// Return the target-dependent attribute object.\n  Attribute getAttribute(StringRef Kind) const;\n\n  MaybeAlign getAlignment() const;\n  MaybeAlign getStackAlignment() const;\n  uint64_t getDereferenceableBytes() const;\n  uint64_t getDereferenceableOrNullBytes() const;\n  Type *getByValType() const;\n  Type *getStructRetType() const;\n  Type *getByRefType() const;\n  Type *getPreallocatedType() const;\n  std::pair<unsigned, Optional<unsigned>> getAllocSizeArgs() const;\n  std::string getAsString(bool InAttrGrp = false) const;\n\n  using iterator = const Attribute *;\n\n  iterator begin() const;\n  iterator end() const;\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  void dump() const;\n#endif\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// Provide DenseMapInfo for AttributeSet.\ntemplate <> struct DenseMapInfo<AttributeSet> {\n  static AttributeSet getEmptyKey() {\n    auto Val = static_cast<uintptr_t>(-1);\n    Val <<= PointerLikeTypeTraits<void *>::NumLowBitsAvailable;\n    return AttributeSet(reinterpret_cast<AttributeSetNode *>(Val));\n  }\n\n  static AttributeSet getTombstoneKey() {\n    auto Val = static_cast<uintptr_t>(-2);\n    Val <<= PointerLikeTypeTraits<void *>::NumLowBitsAvailable;\n    return AttributeSet(reinterpret_cast<AttributeSetNode *>(Val));\n  }\n\n  static unsigned getHashValue(AttributeSet AS) {\n    return (unsigned((uintptr_t)AS.SetNode) >> 4) ^\n           (unsigned((uintptr_t)AS.SetNode) >> 9);\n  }\n\n  static bool isEqual(AttributeSet LHS, AttributeSet RHS) { return LHS == RHS; }\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// This class holds the attributes for a function, its return value, and\n/// its parameters. You access the attributes for each of them via an index into\n/// the AttributeList object. The function attributes are at index\n/// `AttributeList::FunctionIndex', the return value is at index\n/// `AttributeList::ReturnIndex', and the attributes for the parameters start at\n/// index `AttributeList::FirstArgIndex'.\nclass AttributeList {\npublic:\n  enum AttrIndex : unsigned {\n    ReturnIndex = 0U,\n    FunctionIndex = ~0U,\n    FirstArgIndex = 1,\n  };\n\nprivate:\n  friend class AttrBuilder;\n  friend class AttributeListImpl;\n  friend class AttributeSet;\n  friend class AttributeSetNode;\n  template <typename Ty> friend struct DenseMapInfo;\n\n  /// The attributes that we are managing. This can be null to represent\n  /// the empty attributes list.\n  AttributeListImpl *pImpl = nullptr;\n\npublic:\n  /// Create an AttributeList with the specified parameters in it.\n  static AttributeList get(LLVMContext &C,\n                           ArrayRef<std::pair<unsigned, Attribute>> Attrs);\n  static AttributeList get(LLVMContext &C,\n                           ArrayRef<std::pair<unsigned, AttributeSet>> Attrs);\n\n  /// Create an AttributeList from attribute sets for a function, its\n  /// return value, and all of its arguments.\n  static AttributeList get(LLVMContext &C, AttributeSet FnAttrs,\n                           AttributeSet RetAttrs,\n                           ArrayRef<AttributeSet> ArgAttrs);\n\nprivate:\n  explicit AttributeList(AttributeListImpl *LI) : pImpl(LI) {}\n\n  static AttributeList getImpl(LLVMContext &C, ArrayRef<AttributeSet> AttrSets);\n\n  AttributeList setAttributes(LLVMContext &C, unsigned Index,\n                              AttributeSet Attrs) const;\n\npublic:\n  AttributeList() = default;\n\n  //===--------------------------------------------------------------------===//\n  // AttributeList Construction and Mutation\n  //===--------------------------------------------------------------------===//\n\n  /// Return an AttributeList with the specified parameters in it.\n  static AttributeList get(LLVMContext &C, ArrayRef<AttributeList> Attrs);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           ArrayRef<Attribute::AttrKind> Kinds);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           ArrayRef<Attribute::AttrKind> Kinds,\n                           ArrayRef<uint64_t> Values);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           ArrayRef<StringRef> Kind);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           const AttrBuilder &B);\n\n  /// Add an attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addAttribute(LLVMContext &C, unsigned Index,\n                                            Attribute::AttrKind Kind) const;\n\n  /// Add an attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addAttribute(LLVMContext &C, unsigned Index, StringRef Kind,\n               StringRef Value = StringRef()) const;\n\n  /// Add an attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addAttribute(LLVMContext &C, unsigned Index,\n                                            Attribute A) const;\n\n  /// Add attributes to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addAttributes(LLVMContext &C, unsigned Index,\n                                             const AttrBuilder &B) const;\n\n  /// Add an argument attribute to the list. Returns a new list because\n  /// attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addParamAttribute(\n      LLVMContext &C, unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return addAttribute(C, ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Add an argument attribute to the list. Returns a new list because\n  /// attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addParamAttribute(LLVMContext &C, unsigned ArgNo, StringRef Kind,\n                    StringRef Value = StringRef()) const {\n    return addAttribute(C, ArgNo + FirstArgIndex, Kind, Value);\n  }\n\n  /// Add an attribute to the attribute list at the given arg indices. Returns a\n  /// new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addParamAttribute(LLVMContext &C,\n                                                 ArrayRef<unsigned> ArgNos,\n                                                 Attribute A) const;\n\n  /// Add an argument attribute to the list. Returns a new list because\n  /// attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addParamAttributes(LLVMContext &C,\n                                                  unsigned ArgNo,\n                                                  const AttrBuilder &B) const {\n    return addAttributes(C, ArgNo + FirstArgIndex, B);\n  }\n\n  /// Remove the specified attribute at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttribute(LLVMContext &C, unsigned Index,\n                                               Attribute::AttrKind Kind) const;\n\n  /// Remove the specified attribute at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttribute(LLVMContext &C, unsigned Index,\n                                               StringRef Kind) const;\n\n  /// Remove the specified attributes at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttributes(\n      LLVMContext &C, unsigned Index, const AttrBuilder &AttrsToRemove) const;\n\n  /// Remove all attributes at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttributes(LLVMContext &C,\n                                                unsigned Index) const;\n\n  /// Remove the specified attribute at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttribute(\n      LLVMContext &C, unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return removeAttribute(C, ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Remove the specified attribute at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttribute(LLVMContext &C,\n                                                    unsigned ArgNo,\n                                                    StringRef Kind) const {\n    return removeAttribute(C, ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Remove the specified attribute at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttributes(\n      LLVMContext &C, unsigned ArgNo, const AttrBuilder &AttrsToRemove) const {\n    return removeAttributes(C, ArgNo + FirstArgIndex, AttrsToRemove);\n  }\n\n  /// Remove all attributes at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttributes(LLVMContext &C,\n                                                     unsigned ArgNo) const {\n    return removeAttributes(C, ArgNo + FirstArgIndex);\n  }\n\n  /// Replace the type contained by attribute \\p AttrKind at index \\p ArgNo wih\n  /// \\p ReplacementTy, preserving all other attributes.\n  LLVM_NODISCARD AttributeList replaceAttributeType(LLVMContext &C,\n                                                    unsigned ArgNo,\n                                                    Attribute::AttrKind Kind,\n                                                    Type *ReplacementTy) const {\n    Attribute Attr = getAttribute(ArgNo, Kind);\n    auto Attrs = removeAttribute(C, ArgNo, Kind);\n    return Attrs.addAttribute(C, ArgNo, Attr.getWithNewType(C, ReplacementTy));\n  }\n\n  /// \\brief Add the dereferenceable attribute to the attribute set at the given\n  /// index. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableAttr(LLVMContext &C,\n                                                      unsigned Index,\n                                                      uint64_t Bytes) const;\n\n  /// \\brief Add the dereferenceable attribute to the attribute set at the given\n  /// arg index. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableParamAttr(\n      LLVMContext &C, unsigned ArgNo, uint64_t Bytes) const {\n    return addDereferenceableAttr(C, ArgNo + FirstArgIndex, Bytes);\n  }\n\n  /// Add the dereferenceable_or_null attribute to the attribute set at\n  /// the given index. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableOrNullAttr(\n      LLVMContext &C, unsigned Index, uint64_t Bytes) const;\n\n  /// Add the dereferenceable_or_null attribute to the attribute set at\n  /// the given arg index. Returns a new list because attribute lists are\n  /// immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableOrNullParamAttr(\n      LLVMContext &C, unsigned ArgNo, uint64_t Bytes) const {\n    return addDereferenceableOrNullAttr(C, ArgNo + FirstArgIndex, Bytes);\n  }\n\n  /// Add the allocsize attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addAllocSizeAttr(LLVMContext &C, unsigned Index, unsigned ElemSizeArg,\n                   const Optional<unsigned> &NumElemsArg);\n\n  /// Add the allocsize attribute to the attribute set at the given arg index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addAllocSizeParamAttr(LLVMContext &C, unsigned ArgNo, unsigned ElemSizeArg,\n                        const Optional<unsigned> &NumElemsArg) {\n    return addAllocSizeAttr(C, ArgNo + FirstArgIndex, ElemSizeArg, NumElemsArg);\n  }\n\n  //===--------------------------------------------------------------------===//\n  // AttributeList Accessors\n  //===--------------------------------------------------------------------===//\n\n  /// The attributes for the specified index are returned.\n  AttributeSet getAttributes(unsigned Index) const;\n\n  /// The attributes for the argument or parameter at the given index are\n  /// returned.\n  AttributeSet getParamAttributes(unsigned ArgNo) const;\n\n  /// The attributes for the ret value are returned.\n  AttributeSet getRetAttributes() const;\n\n  /// The function attributes are returned.\n  AttributeSet getFnAttributes() const;\n\n  /// Return true if the attribute exists at the given index.\n  bool hasAttribute(unsigned Index, Attribute::AttrKind Kind) const;\n\n  /// Return true if the attribute exists at the given index.\n  bool hasAttribute(unsigned Index, StringRef Kind) const;\n\n  /// Return true if attribute exists at the given index.\n  bool hasAttributes(unsigned Index) const;\n\n  /// Return true if the attribute exists for the given argument\n  bool hasParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return hasAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return true if the attribute exists for the given argument\n  bool hasParamAttr(unsigned ArgNo, StringRef Kind) const {\n    return hasAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return true if attributes exists for the given argument\n  bool hasParamAttrs(unsigned ArgNo) const {\n    return hasAttributes(ArgNo + FirstArgIndex);\n  }\n\n  /// Equivalent to hasAttribute(AttributeList::FunctionIndex, Kind) but\n  /// may be faster.\n  bool hasFnAttribute(Attribute::AttrKind Kind) const;\n\n  /// Equivalent to hasAttribute(AttributeList::FunctionIndex, Kind) but\n  /// may be faster.\n  bool hasFnAttribute(StringRef Kind) const;\n\n  /// Equivalent to hasAttribute(ArgNo + FirstArgIndex, Kind).\n  bool hasParamAttribute(unsigned ArgNo, Attribute::AttrKind Kind) const;\n\n  /// Return true if the specified attribute is set for at least one\n  /// parameter or for the return value. If Index is not nullptr, the index\n  /// of a parameter with the specified attribute is provided.\n  bool hasAttrSomewhere(Attribute::AttrKind Kind,\n                        unsigned *Index = nullptr) const;\n\n  /// Return the attribute object that exists at the given index.\n  Attribute getAttribute(unsigned Index, Attribute::AttrKind Kind) const;\n\n  /// Return the attribute object that exists at the given index.\n  Attribute getAttribute(unsigned Index, StringRef Kind) const;\n\n  /// Return the attribute object that exists at the arg index.\n  Attribute getParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return getAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return the attribute object that exists at the given index.\n  Attribute getParamAttr(unsigned ArgNo, StringRef Kind) const {\n    return getAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return the alignment of the return value.\n  MaybeAlign getRetAlignment() const;\n\n  /// Return the alignment for the specified function parameter.\n  MaybeAlign getParamAlignment(unsigned ArgNo) const;\n\n  /// Return the byval type for the specified function parameter.\n  Type *getParamByValType(unsigned ArgNo) const;\n\n  /// Return the sret type for the specified function parameter.\n  Type *getParamStructRetType(unsigned ArgNo) const;\n\n  /// Return the byref type for the specified function parameter.\n  Type *getParamByRefType(unsigned ArgNo) const;\n\n  /// Return the preallocated type for the specified function parameter.\n  Type *getParamPreallocatedType(unsigned ArgNo) const;\n\n  /// Get the stack alignment.\n  MaybeAlign getStackAlignment(unsigned Index) const;\n\n  /// Get the number of dereferenceable bytes (or zero if unknown).\n  uint64_t getDereferenceableBytes(unsigned Index) const;\n\n  /// Get the number of dereferenceable bytes (or zero if unknown) of an\n  /// arg.\n  uint64_t getParamDereferenceableBytes(unsigned ArgNo) const {\n    return getDereferenceableBytes(ArgNo + FirstArgIndex);\n  }\n\n  /// Get the number of dereferenceable_or_null bytes (or zero if\n  /// unknown).\n  uint64_t getDereferenceableOrNullBytes(unsigned Index) const;\n\n  /// Get the number of dereferenceable_or_null bytes (or zero if\n  /// unknown) of an arg.\n  uint64_t getParamDereferenceableOrNullBytes(unsigned ArgNo) const {\n    return getDereferenceableOrNullBytes(ArgNo + FirstArgIndex);\n  }\n\n  /// Get the allocsize argument numbers (or pair(0, 0) if unknown).\n  std::pair<unsigned, Optional<unsigned>>\n  getAllocSizeArgs(unsigned Index) const;\n\n  /// Return the attributes at the index as a string.\n  std::string getAsString(unsigned Index, bool InAttrGrp = false) const;\n\n  //===--------------------------------------------------------------------===//\n  // AttributeList Introspection\n  //===--------------------------------------------------------------------===//\n\n  using iterator = const AttributeSet *;\n\n  iterator begin() const;\n  iterator end() const;\n\n  unsigned getNumAttrSets() const;\n\n  /// Use these to iterate over the valid attribute indices.\n  unsigned index_begin() const { return AttributeList::FunctionIndex; }\n  unsigned index_end() const { return getNumAttrSets() - 1; }\n\n  /// operator==/!= - Provide equality predicates.\n  bool operator==(const AttributeList &RHS) const { return pImpl == RHS.pImpl; }\n  bool operator!=(const AttributeList &RHS) const { return pImpl != RHS.pImpl; }\n\n  /// Return a raw pointer that uniquely identifies this attribute list.\n  void *getRawPointer() const {\n    return pImpl;\n  }\n\n  /// Return true if there are no attributes.\n  bool isEmpty() const { return pImpl == nullptr; }\n\n  void dump() const;\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// Provide DenseMapInfo for AttributeList.\ntemplate <> struct DenseMapInfo<AttributeList> {\n  static AttributeList getEmptyKey() {\n    auto Val = static_cast<uintptr_t>(-1);\n    Val <<= PointerLikeTypeTraits<void*>::NumLowBitsAvailable;\n    return AttributeList(reinterpret_cast<AttributeListImpl *>(Val));\n  }\n\n  static AttributeList getTombstoneKey() {\n    auto Val = static_cast<uintptr_t>(-2);\n    Val <<= PointerLikeTypeTraits<void*>::NumLowBitsAvailable;\n    return AttributeList(reinterpret_cast<AttributeListImpl *>(Val));\n  }\n\n  static unsigned getHashValue(AttributeList AS) {\n    return (unsigned((uintptr_t)AS.pImpl) >> 4) ^\n           (unsigned((uintptr_t)AS.pImpl) >> 9);\n  }\n\n  static bool isEqual(AttributeList LHS, AttributeList RHS) {\n    return LHS == RHS;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// This class is used in conjunction with the Attribute::get method to\n/// create an Attribute object. The object itself is uniquified. The Builder's\n/// value, however, is not. So this can be used as a quick way to test for\n/// equality, presence of attributes, etc.\nclass AttrBuilder {\n  std::bitset<Attribute::EndAttrKinds> Attrs;\n  std::map<std::string, std::string, std::less<>> TargetDepAttrs;\n  MaybeAlign Alignment;\n  MaybeAlign StackAlignment;\n  uint64_t DerefBytes = 0;\n  uint64_t DerefOrNullBytes = 0;\n  uint64_t AllocSizeArgs = 0;\n  Type *ByValType = nullptr;\n  Type *StructRetType = nullptr;\n  Type *ByRefType = nullptr;\n  Type *PreallocatedType = nullptr;\n\npublic:\n  AttrBuilder() = default;\n\n  AttrBuilder(const Attribute &A) {\n    addAttribute(A);\n  }\n\n  AttrBuilder(AttributeList AS, unsigned Idx);\n  AttrBuilder(AttributeSet AS);\n\n  void clear();\n\n  /// Add an attribute to the builder.\n  AttrBuilder &addAttribute(Attribute::AttrKind Val) {\n    assert((unsigned)Val < Attribute::EndAttrKinds &&\n           \"Attribute out of range!\");\n    assert(!Attribute::doesAttrKindHaveArgument(Val) &&\n           \"Adding integer attribute without adding a value!\");\n    Attrs[Val] = true;\n    return *this;\n  }\n\n  /// Add the Attribute object to the builder.\n  AttrBuilder &addAttribute(Attribute A);\n\n  /// Add the target-dependent attribute to the builder.\n  AttrBuilder &addAttribute(StringRef A, StringRef V = StringRef());\n\n  /// Remove an attribute from the builder.\n  AttrBuilder &removeAttribute(Attribute::AttrKind Val);\n\n  /// Remove the attributes from the builder.\n  AttrBuilder &removeAttributes(AttributeList A, uint64_t WithoutIndex);\n\n  /// Remove the target-dependent attribute to the builder.\n  AttrBuilder &removeAttribute(StringRef A);\n\n  /// Add the attributes from the builder.\n  AttrBuilder &merge(const AttrBuilder &B);\n\n  /// Remove the attributes from the builder.\n  AttrBuilder &remove(const AttrBuilder &B);\n\n  /// Return true if the builder has any attribute that's in the\n  /// specified builder.\n  bool overlaps(const AttrBuilder &B) const;\n\n  /// Return true if the builder has the specified attribute.\n  bool contains(Attribute::AttrKind A) const {\n    assert((unsigned)A < Attribute::EndAttrKinds && \"Attribute out of range!\");\n    return Attrs[A];\n  }\n\n  /// Return true if the builder has the specified target-dependent\n  /// attribute.\n  bool contains(StringRef A) const;\n\n  /// Return true if the builder has IR-level attributes.\n  bool hasAttributes() const;\n\n  /// Return true if the builder has any attribute that's in the\n  /// specified attribute.\n  bool hasAttributes(AttributeList A, uint64_t Index) const;\n\n  /// Return true if the builder has an alignment attribute.\n  bool hasAlignmentAttr() const;\n\n  /// Retrieve the alignment attribute, if it exists.\n  MaybeAlign getAlignment() const { return Alignment; }\n\n  /// Retrieve the stack alignment attribute, if it exists.\n  MaybeAlign getStackAlignment() const { return StackAlignment; }\n\n  /// Retrieve the number of dereferenceable bytes, if the\n  /// dereferenceable attribute exists (zero is returned otherwise).\n  uint64_t getDereferenceableBytes() const { return DerefBytes; }\n\n  /// Retrieve the number of dereferenceable_or_null bytes, if the\n  /// dereferenceable_or_null attribute exists (zero is returned otherwise).\n  uint64_t getDereferenceableOrNullBytes() const { return DerefOrNullBytes; }\n\n  /// Retrieve the byval type.\n  Type *getByValType() const { return ByValType; }\n\n  /// Retrieve the sret type.\n  Type *getStructRetType() const { return StructRetType; }\n\n  /// Retrieve the byref type.\n  Type *getByRefType() const { return ByRefType; }\n\n  /// Retrieve the preallocated type.\n  Type *getPreallocatedType() const { return PreallocatedType; }\n\n  /// Retrieve the allocsize args, if the allocsize attribute exists.  If it\n  /// doesn't exist, pair(0, 0) is returned.\n  std::pair<unsigned, Optional<unsigned>> getAllocSizeArgs() const;\n\n  /// This turns an alignment into the form used internally in Attribute.\n  /// This call has no effect if Align is not set.\n  AttrBuilder &addAlignmentAttr(MaybeAlign Align);\n\n  /// This turns an int alignment (which must be a power of 2) into the\n  /// form used internally in Attribute.\n  /// This call has no effect if Align is 0.\n  /// Deprecated, use the version using a MaybeAlign.\n  inline AttrBuilder &addAlignmentAttr(unsigned Align) {\n    return addAlignmentAttr(MaybeAlign(Align));\n  }\n\n  /// This turns a stack alignment into the form used internally in Attribute.\n  /// This call has no effect if Align is not set.\n  AttrBuilder &addStackAlignmentAttr(MaybeAlign Align);\n\n  /// This turns an int stack alignment (which must be a power of 2) into\n  /// the form used internally in Attribute.\n  /// This call has no effect if Align is 0.\n  /// Deprecated, use the version using a MaybeAlign.\n  inline AttrBuilder &addStackAlignmentAttr(unsigned Align) {\n    return addStackAlignmentAttr(MaybeAlign(Align));\n  }\n\n  /// This turns the number of dereferenceable bytes into the form used\n  /// internally in Attribute.\n  AttrBuilder &addDereferenceableAttr(uint64_t Bytes);\n\n  /// This turns the number of dereferenceable_or_null bytes into the\n  /// form used internally in Attribute.\n  AttrBuilder &addDereferenceableOrNullAttr(uint64_t Bytes);\n\n  /// This turns one (or two) ints into the form used internally in Attribute.\n  AttrBuilder &addAllocSizeAttr(unsigned ElemSizeArg,\n                                const Optional<unsigned> &NumElemsArg);\n\n  /// This turns a byval type into the form used internally in Attribute.\n  AttrBuilder &addByValAttr(Type *Ty);\n\n  /// This turns a sret type into the form used internally in Attribute.\n  AttrBuilder &addStructRetAttr(Type *Ty);\n\n  /// This turns a byref type into the form used internally in Attribute.\n  AttrBuilder &addByRefAttr(Type *Ty);\n\n  /// This turns a preallocated type into the form used internally in Attribute.\n  AttrBuilder &addPreallocatedAttr(Type *Ty);\n\n  /// Add an allocsize attribute, using the representation returned by\n  /// Attribute.getIntValue().\n  AttrBuilder &addAllocSizeAttrFromRawRepr(uint64_t RawAllocSizeRepr);\n\n  /// Return true if the builder contains no target-independent\n  /// attributes.\n  bool empty() const { return Attrs.none(); }\n\n  // Iterators for target-dependent attributes.\n  using td_type = std::pair<std::string, std::string>;\n  using td_iterator = decltype(TargetDepAttrs)::iterator;\n  using td_const_iterator = decltype(TargetDepAttrs)::const_iterator;\n  using td_range = iterator_range<td_iterator>;\n  using td_const_range = iterator_range<td_const_iterator>;\n\n  td_iterator td_begin() { return TargetDepAttrs.begin(); }\n  td_iterator td_end() { return TargetDepAttrs.end(); }\n\n  td_const_iterator td_begin() const { return TargetDepAttrs.begin(); }\n  td_const_iterator td_end() const { return TargetDepAttrs.end(); }\n\n  td_range td_attrs() { return td_range(td_begin(), td_end()); }\n\n  td_const_range td_attrs() const {\n    return td_const_range(td_begin(), td_end());\n  }\n\n  bool td_empty() const { return TargetDepAttrs.empty(); }\n\n  bool operator==(const AttrBuilder &B) const;\n  bool operator!=(const AttrBuilder &B) const { return !(*this == B); }\n};\n\nnamespace AttributeFuncs {\n\n/// Which attributes cannot be applied to a type.\nAttrBuilder typeIncompatible(Type *Ty);\n\n/// \\returns Return true if the two functions have compatible target-independent\n/// attributes for inlining purposes.\nbool areInlineCompatible(const Function &Caller, const Function &Callee);\n\n\n/// Checks  if there are any incompatible function attributes between\n/// \\p A and \\p B.\n///\n/// \\param [in] A - The first function to be compared with.\n/// \\param [in] B - The second function to be compared with.\n/// \\returns true if the functions have compatible attributes.\nbool areOutlineCompatible(const Function &A, const Function &B);\n\n/// Merge caller's and callee's attributes.\nvoid mergeAttributesForInlining(Function &Caller, const Function &Callee);\n\n/// Merges the functions attributes from \\p ToMerge into function \\p Base.\n///\n/// \\param [in,out] Base - The function being merged into.\n/// \\param [in] ToMerge - The function to merge attributes from.\nvoid mergeAttributesForOutlining(Function &Base, const Function &ToMerge);\n\n} // end namespace AttributeFuncs\n\n} // end namespace llvm\n\n#endif // LLVM_IR_ATTRIBUTES_H\n"}, "45": {"id": 45, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Comdat.h", "content": "//===- llvm/IR/Comdat.h - Comdat definitions --------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// @file\n/// This file contains the declaration of the Comdat class, which represents a\n/// single COMDAT in LLVM.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_COMDAT_H\n#define LLVM_IR_COMDAT_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n\nnamespace llvm {\n\nclass raw_ostream;\nclass StringRef;\ntemplate <typename ValueTy> class StringMapEntry;\n\n// This is a Name X SelectionKind pair. The reason for having this be an\n// independent object instead of just adding the name and the SelectionKind\n// to a GlobalObject is that it is invalid to have two Comdats with the same\n// name but different SelectionKind. This structure makes that unrepresentable.\nclass Comdat {\npublic:\n  enum SelectionKind {\n    Any,          ///< The linker may choose any COMDAT.\n    ExactMatch,   ///< The data referenced by the COMDAT must be the same.\n    Largest,      ///< The linker will choose the largest COMDAT.\n    NoDuplicates, ///< No other Module may specify this COMDAT.\n    SameSize,     ///< The data referenced by the COMDAT must be the same size.\n  };\n\n  Comdat(const Comdat &) = delete;\n  Comdat(Comdat &&C);\n\n  SelectionKind getSelectionKind() const { return SK; }\n  void setSelectionKind(SelectionKind Val) { SK = Val; }\n  StringRef getName() const;\n  void print(raw_ostream &OS, bool IsForDebug = false) const;\n  void dump() const;\n\nprivate:\n  friend class Module;\n\n  Comdat();\n\n  // Points to the map in Module.\n  StringMapEntry<Comdat> *Name = nullptr;\n  SelectionKind SK = Any;\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_SIMPLE_CONVERSION_FUNCTIONS(Comdat, LLVMComdatRef)\n\ninline raw_ostream &operator<<(raw_ostream &OS, const Comdat &C) {\n  C.print(OS);\n  return OS;\n}\n\n} // end namespace llvm\n\n#endif // LLVM_IR_COMDAT_H\n"}, "46": {"id": 46, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Constants.h", "content": "//===-- llvm/Constants.h - Constant class subclass definitions --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// @file\n/// This file contains the declarations for the subclasses of Constant,\n/// which represent the different flavors of constant values that live in LLVM.\n/// Note that Constants are immutable (once created they never change) and are\n/// fully shared by structural equivalence.  This means that two structurally\n/// equivalent constants will always have the same address.  Constants are\n/// created on demand as needed and never deleted: thus clients don't have to\n/// worry about the lifetime of the objects.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_CONSTANTS_H\n#define LLVM_IR_CONSTANTS_H\n\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/OperandTraits.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\nnamespace llvm {\n\ntemplate <class ConstantClass> struct ConstantAggrKeyType;\n\n/// Base class for constants with no operands.\n///\n/// These constants have no operands; they represent their data directly.\n/// Since they can be in use by unrelated modules (and are never based on\n/// GlobalValues), it never makes sense to RAUW them.\nclass ConstantData : public Constant {\n  friend class Constant;\n\n  Value *handleOperandChangeImpl(Value *From, Value *To) {\n    llvm_unreachable(\"Constant data does not have operands!\");\n  }\n\nprotected:\n  explicit ConstantData(Type *Ty, ValueTy VT) : Constant(Ty, VT, nullptr, 0) {}\n\n  void *operator new(size_t s) { return User::operator new(s, 0); }\n\npublic:\n  ConstantData(const ConstantData &) = delete;\n\n  /// Methods to support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Value *V) {\n    return V->getValueID() >= ConstantDataFirstVal &&\n           V->getValueID() <= ConstantDataLastVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// This is the shared class of boolean and integer constants. This class\n/// represents both boolean and integral constants.\n/// Class for constant integers.\nclass ConstantInt final : public ConstantData {\n  friend class Constant;\n\n  APInt Val;\n\n  ConstantInt(IntegerType *Ty, const APInt& V);\n\n  void destroyConstantImpl();\n\npublic:\n  ConstantInt(const ConstantInt &) = delete;\n\n  static ConstantInt *getTrue(LLVMContext &Context);\n  static ConstantInt *getFalse(LLVMContext &Context);\n  static ConstantInt *getBool(LLVMContext &Context, bool V);\n  static Constant *getTrue(Type *Ty);\n  static Constant *getFalse(Type *Ty);\n  static Constant *getBool(Type *Ty, bool V);\n\n  /// If Ty is a vector type, return a Constant with a splat of the given\n  /// value. Otherwise return a ConstantInt for the given value.\n  static Constant *get(Type *Ty, uint64_t V, bool isSigned = false);\n\n  /// Return a ConstantInt with the specified integer value for the specified\n  /// type. If the type is wider than 64 bits, the value will be zero-extended\n  /// to fit the type, unless isSigned is true, in which case the value will\n  /// be interpreted as a 64-bit signed integer and sign-extended to fit\n  /// the type.\n  /// Get a ConstantInt for a specific value.\n  static ConstantInt *get(IntegerType *Ty, uint64_t V,\n                          bool isSigned = false);\n\n  /// Return a ConstantInt with the specified value for the specified type. The\n  /// value V will be canonicalized to a an unsigned APInt. Accessing it with\n  /// either getSExtValue() or getZExtValue() will yield a correctly sized and\n  /// signed value for the type Ty.\n  /// Get a ConstantInt for a specific signed value.\n  static ConstantInt *getSigned(IntegerType *Ty, int64_t V);\n  static Constant *getSigned(Type *Ty, int64_t V);\n\n  /// Return a ConstantInt with the specified value and an implied Type. The\n  /// type is the integer type that corresponds to the bit width of the value.\n  static ConstantInt *get(LLVMContext &Context, const APInt &V);\n\n  /// Return a ConstantInt constructed from the string strStart with the given\n  /// radix.\n  static ConstantInt *get(IntegerType *Ty, StringRef Str,\n                          uint8_t radix);\n\n  /// If Ty is a vector type, return a Constant with a splat of the given\n  /// value. Otherwise return a ConstantInt for the given value.\n  static Constant *get(Type* Ty, const APInt& V);\n\n  /// Return the constant as an APInt value reference. This allows clients to\n  /// obtain a full-precision copy of the value.\n  /// Return the constant's value.\n  inline const APInt &getValue() const {\n    return Val;\n  }\n\n  /// getBitWidth - Return the bitwidth of this constant.\n  unsigned getBitWidth() const { return Val.getBitWidth(); }\n\n  /// Return the constant as a 64-bit unsigned integer value after it\n  /// has been zero extended as appropriate for the type of this constant. Note\n  /// that this method can assert if the value does not fit in 64 bits.\n  /// Return the zero extended value.\n  inline uint64_t getZExtValue() const {\n    return Val.getZExtValue();\n  }\n\n  /// Return the constant as a 64-bit integer value after it has been sign\n  /// extended as appropriate for the type of this constant. Note that\n  /// this method can assert if the value does not fit in 64 bits.\n  /// Return the sign extended value.\n  inline int64_t getSExtValue() const {\n    return Val.getSExtValue();\n  }\n\n  /// Return the constant as an llvm::MaybeAlign.\n  /// Note that this method can assert if the value does not fit in 64 bits or\n  /// is not a power of two.\n  inline MaybeAlign getMaybeAlignValue() const {\n    return MaybeAlign(getZExtValue());\n  }\n\n  /// Return the constant as an llvm::Align, interpreting `0` as `Align(1)`.\n  /// Note that this method can assert if the value does not fit in 64 bits or\n  /// is not a power of two.\n  inline Align getAlignValue() const {\n    return getMaybeAlignValue().valueOrOne();\n  }\n\n  /// A helper method that can be used to determine if the constant contained\n  /// within is equal to a constant.  This only works for very small values,\n  /// because this is all that can be represented with all types.\n  /// Determine if this constant's value is same as an unsigned char.\n  bool equalsInt(uint64_t V) const {\n    return Val == V;\n  }\n\n  /// getType - Specialize the getType() method to always return an IntegerType,\n  /// which reduces the amount of casting needed in parts of the compiler.\n  ///\n  inline IntegerType *getType() const {\n    return cast<IntegerType>(Value::getType());\n  }\n\n  /// This static method returns true if the type Ty is big enough to\n  /// represent the value V. This can be used to avoid having the get method\n  /// assert when V is larger than Ty can represent. Note that there are two\n  /// versions of this method, one for unsigned and one for signed integers.\n  /// Although ConstantInt canonicalizes everything to an unsigned integer,\n  /// the signed version avoids callers having to convert a signed quantity\n  /// to the appropriate unsigned type before calling the method.\n  /// @returns true if V is a valid value for type Ty\n  /// Determine if the value is in range for the given type.\n  static bool isValueValidForType(Type *Ty, uint64_t V);\n  static bool isValueValidForType(Type *Ty, int64_t V);\n\n  bool isNegative() const { return Val.isNegative(); }\n\n  /// This is just a convenience method to make client code smaller for a\n  /// common code. It also correctly performs the comparison without the\n  /// potential for an assertion from getZExtValue().\n  bool isZero() const {\n    return Val.isNullValue();\n  }\n\n  /// This is just a convenience method to make client code smaller for a\n  /// common case. It also correctly performs the comparison without the\n  /// potential for an assertion from getZExtValue().\n  /// Determine if the value is one.\n  bool isOne() const {\n    return Val.isOneValue();\n  }\n\n  /// This function will return true iff every bit in this constant is set\n  /// to true.\n  /// @returns true iff this constant's bits are all set to true.\n  /// Determine if the value is all ones.\n  bool isMinusOne() const {\n    return Val.isAllOnesValue();\n  }\n\n  /// This function will return true iff this constant represents the largest\n  /// value that may be represented by the constant's type.\n  /// @returns true iff this is the largest value that may be represented\n  /// by this type.\n  /// Determine if the value is maximal.\n  bool isMaxValue(bool isSigned) const {\n    if (isSigned)\n      return Val.isMaxSignedValue();\n    else\n      return Val.isMaxValue();\n  }\n\n  /// This function will return true iff this constant represents the smallest\n  /// value that may be represented by this constant's type.\n  /// @returns true if this is the smallest value that may be represented by\n  /// this type.\n  /// Determine if the value is minimal.\n  bool isMinValue(bool isSigned) const {\n    if (isSigned)\n      return Val.isMinSignedValue();\n    else\n      return Val.isMinValue();\n  }\n\n  /// This function will return true iff this constant represents a value with\n  /// active bits bigger than 64 bits or a value greater than the given uint64_t\n  /// value.\n  /// @returns true iff this constant is greater or equal to the given number.\n  /// Determine if the value is greater or equal to the given number.\n  bool uge(uint64_t Num) const {\n    return Val.uge(Num);\n  }\n\n  /// getLimitedValue - If the value is smaller than the specified limit,\n  /// return it, otherwise return the limit value.  This causes the value\n  /// to saturate to the limit.\n  /// @returns the min of the value of the constant and the specified value\n  /// Get the constant's value with a saturation limit\n  uint64_t getLimitedValue(uint64_t Limit = ~0ULL) const {\n    return Val.getLimitedValue(Limit);\n  }\n\n  /// Methods to support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantIntVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// ConstantFP - Floating Point Values [float, double]\n///\nclass ConstantFP final : public ConstantData {\n  friend class Constant;\n\n  APFloat Val;\n\n  ConstantFP(Type *Ty, const APFloat& V);\n\n  void destroyConstantImpl();\n\npublic:\n  ConstantFP(const ConstantFP &) = delete;\n\n  /// Floating point negation must be implemented with f(x) = -0.0 - x. This\n  /// method returns the negative zero constant for floating point or vector\n  /// floating point types; for all other types, it returns the null value.\n  static Constant *getZeroValueForNegation(Type *Ty);\n\n  /// This returns a ConstantFP, or a vector containing a splat of a ConstantFP,\n  /// for the specified value in the specified type. This should only be used\n  /// for simple constant values like 2.0/1.0 etc, that are known-valid both as\n  /// host double and as the target format.\n  static Constant *get(Type* Ty, double V);\n\n  /// If Ty is a vector type, return a Constant with a splat of the given\n  /// value. Otherwise return a ConstantFP for the given value.\n  static Constant *get(Type *Ty, const APFloat &V);\n\n  static Constant *get(Type* Ty, StringRef Str);\n  static ConstantFP *get(LLVMContext &Context, const APFloat &V);\n  static Constant *getNaN(Type *Ty, bool Negative = false, uint64_t Payload = 0);\n  static Constant *getQNaN(Type *Ty, bool Negative = false,\n                           APInt *Payload = nullptr);\n  static Constant *getSNaN(Type *Ty, bool Negative = false,\n                           APInt *Payload = nullptr);\n  static Constant *getNegativeZero(Type *Ty);\n  static Constant *getInfinity(Type *Ty, bool Negative = false);\n\n  /// Return true if Ty is big enough to represent V.\n  static bool isValueValidForType(Type *Ty, const APFloat &V);\n  inline const APFloat &getValueAPF() const { return Val; }\n  inline const APFloat &getValue() const { return Val; }\n\n  /// Return true if the value is positive or negative zero.\n  bool isZero() const { return Val.isZero(); }\n\n  /// Return true if the sign bit is set.\n  bool isNegative() const { return Val.isNegative(); }\n\n  /// Return true if the value is infinity\n  bool isInfinity() const { return Val.isInfinity(); }\n\n  /// Return true if the value is a NaN.\n  bool isNaN() const { return Val.isNaN(); }\n\n  /// We don't rely on operator== working on double values, as it returns true\n  /// for things that are clearly not equal, like -0.0 and 0.0.\n  /// As such, this method can be used to do an exact bit-for-bit comparison of\n  /// two floating point values.  The version with a double operand is retained\n  /// because it's so convenient to write isExactlyValue(2.0), but please use\n  /// it only for simple constants.\n  bool isExactlyValue(const APFloat &V) const;\n\n  bool isExactlyValue(double V) const {\n    bool ignored;\n    APFloat FV(V);\n    FV.convert(Val.getSemantics(), APFloat::rmNearestTiesToEven, &ignored);\n    return isExactlyValue(FV);\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantFPVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// All zero aggregate value\n///\nclass ConstantAggregateZero final : public ConstantData {\n  friend class Constant;\n\n  explicit ConstantAggregateZero(Type *Ty)\n      : ConstantData(Ty, ConstantAggregateZeroVal) {}\n\n  void destroyConstantImpl();\n\npublic:\n  ConstantAggregateZero(const ConstantAggregateZero &) = delete;\n\n  static ConstantAggregateZero *get(Type *Ty);\n\n  /// If this CAZ has array or vector type, return a zero with the right element\n  /// type.\n  Constant *getSequentialElement() const;\n\n  /// If this CAZ has struct type, return a zero with the right element type for\n  /// the specified element.\n  Constant *getStructElement(unsigned Elt) const;\n\n  /// Return a zero of the right value for the specified GEP index if we can,\n  /// otherwise return null (e.g. if C is a ConstantExpr).\n  Constant *getElementValue(Constant *C) const;\n\n  /// Return a zero of the right value for the specified GEP index.\n  Constant *getElementValue(unsigned Idx) const;\n\n  /// Return the number of elements in the array, vector, or struct.\n  unsigned getNumElements() const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  ///\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantAggregateZeroVal;\n  }\n};\n\n/// Base class for aggregate constants (with operands).\n///\n/// These constants are aggregates of other constants, which are stored as\n/// operands.\n///\n/// Subclasses are \\a ConstantStruct, \\a ConstantArray, and \\a\n/// ConstantVector.\n///\n/// \\note Some subclasses of \\a ConstantData are semantically aggregates --\n/// such as \\a ConstantDataArray -- but are not subclasses of this because they\n/// use operands.\nclass ConstantAggregate : public Constant {\nprotected:\n  ConstantAggregate(Type *T, ValueTy VT, ArrayRef<Constant *> V);\n\npublic:\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Constant);\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() >= ConstantAggregateFirstVal &&\n           V->getValueID() <= ConstantAggregateLastVal;\n  }\n};\n\ntemplate <>\nstruct OperandTraits<ConstantAggregate>\n    : public VariadicOperandTraits<ConstantAggregate> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(ConstantAggregate, Constant)\n\n//===----------------------------------------------------------------------===//\n/// ConstantArray - Constant Array Declarations\n///\nclass ConstantArray final : public ConstantAggregate {\n  friend struct ConstantAggrKeyType<ConstantArray>;\n  friend class Constant;\n\n  ConstantArray(ArrayType *T, ArrayRef<Constant *> Val);\n\n  void destroyConstantImpl();\n  Value *handleOperandChangeImpl(Value *From, Value *To);\n\npublic:\n  // ConstantArray accessors\n  static Constant *get(ArrayType *T, ArrayRef<Constant*> V);\n\nprivate:\n  static Constant *getImpl(ArrayType *T, ArrayRef<Constant *> V);\n\npublic:\n  /// Specialize the getType() method to always return an ArrayType,\n  /// which reduces the amount of casting needed in parts of the compiler.\n  inline ArrayType *getType() const {\n    return cast<ArrayType>(Value::getType());\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantArrayVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Constant Struct Declarations\n//\nclass ConstantStruct final : public ConstantAggregate {\n  friend struct ConstantAggrKeyType<ConstantStruct>;\n  friend class Constant;\n\n  ConstantStruct(StructType *T, ArrayRef<Constant *> Val);\n\n  void destroyConstantImpl();\n  Value *handleOperandChangeImpl(Value *From, Value *To);\n\npublic:\n  // ConstantStruct accessors\n  static Constant *get(StructType *T, ArrayRef<Constant*> V);\n\n  template <typename... Csts>\n  static std::enable_if_t<are_base_of<Constant, Csts...>::value, Constant *>\n  get(StructType *T, Csts *... Vs) {\n    SmallVector<Constant *, 8> Values({Vs...});\n    return get(T, Values);\n  }\n\n  /// Return an anonymous struct that has the specified elements.\n  /// If the struct is possibly empty, then you must specify a context.\n  static Constant *getAnon(ArrayRef<Constant*> V, bool Packed = false) {\n    return get(getTypeForElements(V, Packed), V);\n  }\n  static Constant *getAnon(LLVMContext &Ctx,\n                           ArrayRef<Constant*> V, bool Packed = false) {\n    return get(getTypeForElements(Ctx, V, Packed), V);\n  }\n\n  /// Return an anonymous struct type to use for a constant with the specified\n  /// set of elements. The list must not be empty.\n  static StructType *getTypeForElements(ArrayRef<Constant*> V,\n                                        bool Packed = false);\n  /// This version of the method allows an empty list.\n  static StructType *getTypeForElements(LLVMContext &Ctx,\n                                        ArrayRef<Constant*> V,\n                                        bool Packed = false);\n\n  /// Specialization - reduce amount of casting.\n  inline StructType *getType() const {\n    return cast<StructType>(Value::getType());\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantStructVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// Constant Vector Declarations\n///\nclass ConstantVector final : public ConstantAggregate {\n  friend struct ConstantAggrKeyType<ConstantVector>;\n  friend class Constant;\n\n  ConstantVector(VectorType *T, ArrayRef<Constant *> Val);\n\n  void destroyConstantImpl();\n  Value *handleOperandChangeImpl(Value *From, Value *To);\n\npublic:\n  // ConstantVector accessors\n  static Constant *get(ArrayRef<Constant*> V);\n\nprivate:\n  static Constant *getImpl(ArrayRef<Constant *> V);\n\npublic:\n  /// Return a ConstantVector with the specified constant in each element.\n  /// Note that this might not return an instance of ConstantVector\n  static Constant *getSplat(ElementCount EC, Constant *Elt);\n\n  /// Specialize the getType() method to always return a FixedVectorType,\n  /// which reduces the amount of casting needed in parts of the compiler.\n  inline FixedVectorType *getType() const {\n    return cast<FixedVectorType>(Value::getType());\n  }\n\n  /// If all elements of the vector constant have the same value, return that\n  /// value. Otherwise, return nullptr. Ignore undefined elements by setting\n  /// AllowUndefs to true.\n  Constant *getSplatValue(bool AllowUndefs = false) const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantVectorVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// A constant pointer value that points to null\n///\nclass ConstantPointerNull final : public ConstantData {\n  friend class Constant;\n\n  explicit ConstantPointerNull(PointerType *T)\n      : ConstantData(T, Value::ConstantPointerNullVal) {}\n\n  void destroyConstantImpl();\n\npublic:\n  ConstantPointerNull(const ConstantPointerNull &) = delete;\n\n  /// Static factory methods - Return objects of the specified value\n  static ConstantPointerNull *get(PointerType *T);\n\n  /// Specialize the getType() method to always return an PointerType,\n  /// which reduces the amount of casting needed in parts of the compiler.\n  inline PointerType *getType() const {\n    return cast<PointerType>(Value::getType());\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantPointerNullVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// ConstantDataSequential - A vector or array constant whose element type is a\n/// simple 1/2/4/8-byte integer or float/double, and whose elements are just\n/// simple data values (i.e. ConstantInt/ConstantFP).  This Constant node has no\n/// operands because it stores all of the elements of the constant as densely\n/// packed data, instead of as Value*'s.\n///\n/// This is the common base class of ConstantDataArray and ConstantDataVector.\n///\nclass ConstantDataSequential : public ConstantData {\n  friend class LLVMContextImpl;\n  friend class Constant;\n\n  /// A pointer to the bytes underlying this constant (which is owned by the\n  /// uniquing StringMap).\n  const char *DataElements;\n\n  /// This forms a link list of ConstantDataSequential nodes that have\n  /// the same value but different type.  For example, 0,0,0,1 could be a 4\n  /// element array of i8, or a 1-element array of i32.  They'll both end up in\n  /// the same StringMap bucket, linked up.\n  std::unique_ptr<ConstantDataSequential> Next;\n\n  void destroyConstantImpl();\n\nprotected:\n  explicit ConstantDataSequential(Type *ty, ValueTy VT, const char *Data)\n      : ConstantData(ty, VT), DataElements(Data) {}\n\n  static Constant *getImpl(StringRef Bytes, Type *Ty);\n\npublic:\n  ConstantDataSequential(const ConstantDataSequential &) = delete;\n\n  /// Return true if a ConstantDataSequential can be formed with a vector or\n  /// array of the specified element type.\n  /// ConstantDataArray only works with normal float and int types that are\n  /// stored densely in memory, not with things like i42 or x86_f80.\n  static bool isElementTypeCompatible(Type *Ty);\n\n  /// If this is a sequential container of integers (of any size), return the\n  /// specified element in the low bits of a uint64_t.\n  uint64_t getElementAsInteger(unsigned i) const;\n\n  /// If this is a sequential container of integers (of any size), return the\n  /// specified element as an APInt.\n  APInt getElementAsAPInt(unsigned i) const;\n\n  /// If this is a sequential container of floating point type, return the\n  /// specified element as an APFloat.\n  APFloat getElementAsAPFloat(unsigned i) const;\n\n  /// If this is an sequential container of floats, return the specified element\n  /// as a float.\n  float getElementAsFloat(unsigned i) const;\n\n  /// If this is an sequential container of doubles, return the specified\n  /// element as a double.\n  double getElementAsDouble(unsigned i) const;\n\n  /// Return a Constant for a specified index's element.\n  /// Note that this has to compute a new constant to return, so it isn't as\n  /// efficient as getElementAsInteger/Float/Double.\n  Constant *getElementAsConstant(unsigned i) const;\n\n  /// Return the element type of the array/vector.\n  Type *getElementType() const;\n\n  /// Return the number of elements in the array or vector.\n  unsigned getNumElements() const;\n\n  /// Return the size (in bytes) of each element in the array/vector.\n  /// The size of the elements is known to be a multiple of one byte.\n  uint64_t getElementByteSize() const;\n\n  /// This method returns true if this is an array of \\p CharSize integers.\n  bool isString(unsigned CharSize = 8) const;\n\n  /// This method returns true if the array \"isString\", ends with a null byte,\n  /// and does not contains any other null bytes.\n  bool isCString() const;\n\n  /// If this array is isString(), then this method returns the array as a\n  /// StringRef. Otherwise, it asserts out.\n  StringRef getAsString() const {\n    assert(isString() && \"Not a string\");\n    return getRawDataValues();\n  }\n\n  /// If this array is isCString(), then this method returns the array (without\n  /// the trailing null byte) as a StringRef. Otherwise, it asserts out.\n  StringRef getAsCString() const {\n    assert(isCString() && \"Isn't a C string\");\n    StringRef Str = getAsString();\n    return Str.substr(0, Str.size()-1);\n  }\n\n  /// Return the raw, underlying, bytes of this data. Note that this is an\n  /// extremely tricky thing to work with, as it exposes the host endianness of\n  /// the data elements.\n  StringRef getRawDataValues() const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantDataArrayVal ||\n           V->getValueID() == ConstantDataVectorVal;\n  }\n\nprivate:\n  const char *getElementPointer(unsigned Elt) const;\n};\n\n//===----------------------------------------------------------------------===//\n/// An array constant whose element type is a simple 1/2/4/8-byte integer or\n/// float/double, and whose elements are just simple data values\n/// (i.e. ConstantInt/ConstantFP). This Constant node has no operands because it\n/// stores all of the elements of the constant as densely packed data, instead\n/// of as Value*'s.\nclass ConstantDataArray final : public ConstantDataSequential {\n  friend class ConstantDataSequential;\n\n  explicit ConstantDataArray(Type *ty, const char *Data)\n      : ConstantDataSequential(ty, ConstantDataArrayVal, Data) {}\n\npublic:\n  ConstantDataArray(const ConstantDataArray &) = delete;\n\n  /// get() constructor - Return a constant with array type with an element\n  /// count and element type matching the ArrayRef passed in.  Note that this\n  /// can return a ConstantAggregateZero object.\n  template <typename ElementTy>\n  static Constant *get(LLVMContext &Context, ArrayRef<ElementTy> Elts) {\n    const char *Data = reinterpret_cast<const char *>(Elts.data());\n    return getRaw(StringRef(Data, Elts.size() * sizeof(ElementTy)), Elts.size(),\n                  Type::getScalarTy<ElementTy>(Context));\n  }\n\n  /// get() constructor - ArrayTy needs to be compatible with\n  /// ArrayRef<ElementTy>. Calls get(LLVMContext, ArrayRef<ElementTy>).\n  template <typename ArrayTy>\n  static Constant *get(LLVMContext &Context, ArrayTy &Elts) {\n    return ConstantDataArray::get(Context, makeArrayRef(Elts));\n  }\n\n  /// get() constructor - Return a constant with array type with an element\n  /// count and element type matching the NumElements and ElementTy parameters\n  /// passed in. Note that this can return a ConstantAggregateZero object.\n  /// ElementTy needs to be one of i8/i16/i32/i64/float/double. Data is the\n  /// buffer containing the elements. Be careful to make sure Data uses the\n  /// right endianness, the buffer will be used as-is.\n  static Constant *getRaw(StringRef Data, uint64_t NumElements, Type *ElementTy) {\n    Type *Ty = ArrayType::get(ElementTy, NumElements);\n    return getImpl(Data, Ty);\n  }\n\n  /// getFP() constructors - Return a constant of array type with a float\n  /// element type taken from argument `ElementType', and count taken from\n  /// argument `Elts'.  The amount of bits of the contained type must match the\n  /// number of bits of the type contained in the passed in ArrayRef.\n  /// (i.e. half or bfloat for 16bits, float for 32bits, double for 64bits) Note\n  /// that this can return a ConstantAggregateZero object.\n  static Constant *getFP(Type *ElementType, ArrayRef<uint16_t> Elts);\n  static Constant *getFP(Type *ElementType, ArrayRef<uint32_t> Elts);\n  static Constant *getFP(Type *ElementType, ArrayRef<uint64_t> Elts);\n\n  /// This method constructs a CDS and initializes it with a text string.\n  /// The default behavior (AddNull==true) causes a null terminator to\n  /// be placed at the end of the array (increasing the length of the string by\n  /// one more than the StringRef would normally indicate.  Pass AddNull=false\n  /// to disable this behavior.\n  static Constant *getString(LLVMContext &Context, StringRef Initializer,\n                             bool AddNull = true);\n\n  /// Specialize the getType() method to always return an ArrayType,\n  /// which reduces the amount of casting needed in parts of the compiler.\n  inline ArrayType *getType() const {\n    return cast<ArrayType>(Value::getType());\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantDataArrayVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// A vector constant whose element type is a simple 1/2/4/8-byte integer or\n/// float/double, and whose elements are just simple data values\n/// (i.e. ConstantInt/ConstantFP). This Constant node has no operands because it\n/// stores all of the elements of the constant as densely packed data, instead\n/// of as Value*'s.\nclass ConstantDataVector final : public ConstantDataSequential {\n  friend class ConstantDataSequential;\n\n  explicit ConstantDataVector(Type *ty, const char *Data)\n      : ConstantDataSequential(ty, ConstantDataVectorVal, Data),\n        IsSplatSet(false) {}\n  // Cache whether or not the constant is a splat.\n  mutable bool IsSplatSet : 1;\n  mutable bool IsSplat : 1;\n  bool isSplatData() const;\n\npublic:\n  ConstantDataVector(const ConstantDataVector &) = delete;\n\n  /// get() constructors - Return a constant with vector type with an element\n  /// count and element type matching the ArrayRef passed in.  Note that this\n  /// can return a ConstantAggregateZero object.\n  static Constant *get(LLVMContext &Context, ArrayRef<uint8_t> Elts);\n  static Constant *get(LLVMContext &Context, ArrayRef<uint16_t> Elts);\n  static Constant *get(LLVMContext &Context, ArrayRef<uint32_t> Elts);\n  static Constant *get(LLVMContext &Context, ArrayRef<uint64_t> Elts);\n  static Constant *get(LLVMContext &Context, ArrayRef<float> Elts);\n  static Constant *get(LLVMContext &Context, ArrayRef<double> Elts);\n\n  /// getFP() constructors - Return a constant of vector type with a float\n  /// element type taken from argument `ElementType', and count taken from\n  /// argument `Elts'.  The amount of bits of the contained type must match the\n  /// number of bits of the type contained in the passed in ArrayRef.\n  /// (i.e. half or bfloat for 16bits, float for 32bits, double for 64bits) Note\n  /// that this can return a ConstantAggregateZero object.\n  static Constant *getFP(Type *ElementType, ArrayRef<uint16_t> Elts);\n  static Constant *getFP(Type *ElementType, ArrayRef<uint32_t> Elts);\n  static Constant *getFP(Type *ElementType, ArrayRef<uint64_t> Elts);\n\n  /// Return a ConstantVector with the specified constant in each element.\n  /// The specified constant has to be a of a compatible type (i8/i16/\n  /// i32/i64/float/double) and must be a ConstantFP or ConstantInt.\n  static Constant *getSplat(unsigned NumElts, Constant *Elt);\n\n  /// Returns true if this is a splat constant, meaning that all elements have\n  /// the same value.\n  bool isSplat() const;\n\n  /// If this is a splat constant, meaning that all of the elements have the\n  /// same value, return that value. Otherwise return NULL.\n  Constant *getSplatValue() const;\n\n  /// Specialize the getType() method to always return a FixedVectorType,\n  /// which reduces the amount of casting needed in parts of the compiler.\n  inline FixedVectorType *getType() const {\n    return cast<FixedVectorType>(Value::getType());\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantDataVectorVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// A constant token which is empty\n///\nclass ConstantTokenNone final : public ConstantData {\n  friend class Constant;\n\n  explicit ConstantTokenNone(LLVMContext &Context)\n      : ConstantData(Type::getTokenTy(Context), ConstantTokenNoneVal) {}\n\n  void destroyConstantImpl();\n\npublic:\n  ConstantTokenNone(const ConstantTokenNone &) = delete;\n\n  /// Return the ConstantTokenNone.\n  static ConstantTokenNone *get(LLVMContext &Context);\n\n  /// Methods to support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantTokenNoneVal;\n  }\n};\n\n/// The address of a basic block.\n///\nclass BlockAddress final : public Constant {\n  friend class Constant;\n\n  BlockAddress(Function *F, BasicBlock *BB);\n\n  void *operator new(size_t s) { return User::operator new(s, 2); }\n\n  void destroyConstantImpl();\n  Value *handleOperandChangeImpl(Value *From, Value *To);\n\npublic:\n  /// Return a BlockAddress for the specified function and basic block.\n  static BlockAddress *get(Function *F, BasicBlock *BB);\n\n  /// Return a BlockAddress for the specified basic block.  The basic\n  /// block must be embedded into a function.\n  static BlockAddress *get(BasicBlock *BB);\n\n  /// Lookup an existing \\c BlockAddress constant for the given BasicBlock.\n  ///\n  /// \\returns 0 if \\c !BB->hasAddressTaken(), otherwise the \\c BlockAddress.\n  static BlockAddress *lookup(const BasicBlock *BB);\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  Function *getFunction() const { return (Function*)Op<0>().get(); }\n  BasicBlock *getBasicBlock() const { return (BasicBlock*)Op<1>().get(); }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == BlockAddressVal;\n  }\n};\n\ntemplate <>\nstruct OperandTraits<BlockAddress> :\n  public FixedNumOperandTraits<BlockAddress, 2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(BlockAddress, Value)\n\n/// Wrapper for a function that represents a value that\n/// functionally represents the original function. This can be a function,\n/// global alias to a function, or an ifunc.\nclass DSOLocalEquivalent final : public Constant {\n  friend class Constant;\n\n  DSOLocalEquivalent(GlobalValue *GV);\n\n  void *operator new(size_t s) { return User::operator new(s, 1); }\n\n  void destroyConstantImpl();\n  Value *handleOperandChangeImpl(Value *From, Value *To);\n\npublic:\n  /// Return a DSOLocalEquivalent for the specified global value.\n  static DSOLocalEquivalent *get(GlobalValue *GV);\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  GlobalValue *getGlobalValue() const {\n    return cast<GlobalValue>(Op<0>().get());\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == DSOLocalEquivalentVal;\n  }\n};\n\ntemplate <>\nstruct OperandTraits<DSOLocalEquivalent>\n    : public FixedNumOperandTraits<DSOLocalEquivalent, 1> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(DSOLocalEquivalent, Value)\n\n//===----------------------------------------------------------------------===//\n/// A constant value that is initialized with an expression using\n/// other constant values.\n///\n/// This class uses the standard Instruction opcodes to define the various\n/// constant expressions.  The Opcode field for the ConstantExpr class is\n/// maintained in the Value::SubclassData field.\nclass ConstantExpr : public Constant {\n  friend struct ConstantExprKeyType;\n  friend class Constant;\n\n  void destroyConstantImpl();\n  Value *handleOperandChangeImpl(Value *From, Value *To);\n\nprotected:\n  ConstantExpr(Type *ty, unsigned Opcode, Use *Ops, unsigned NumOps)\n      : Constant(ty, ConstantExprVal, Ops, NumOps) {\n    // Operation type (an Instruction opcode) is stored as the SubclassData.\n    setValueSubclassData(Opcode);\n  }\n\n  ~ConstantExpr() = default;\n\npublic:\n  // Static methods to construct a ConstantExpr of different kinds.  Note that\n  // these methods may return a object that is not an instance of the\n  // ConstantExpr class, because they will attempt to fold the constant\n  // expression into something simpler if possible.\n\n  /// getAlignOf constant expr - computes the alignment of a type in a target\n  /// independent way (Note: the return type is an i64).\n  static Constant *getAlignOf(Type *Ty);\n\n  /// getSizeOf constant expr - computes the (alloc) size of a type (in\n  /// address-units, not bits) in a target independent way (Note: the return\n  /// type is an i64).\n  ///\n  static Constant *getSizeOf(Type *Ty);\n\n  /// getOffsetOf constant expr - computes the offset of a struct field in a\n  /// target independent way (Note: the return type is an i64).\n  ///\n  static Constant *getOffsetOf(StructType *STy, unsigned FieldNo);\n\n  /// getOffsetOf constant expr - This is a generalized form of getOffsetOf,\n  /// which supports any aggregate type, and any Constant index.\n  ///\n  static Constant *getOffsetOf(Type *Ty, Constant *FieldNo);\n\n  static Constant *getNeg(Constant *C, bool HasNUW = false, bool HasNSW =false);\n  static Constant *getFNeg(Constant *C);\n  static Constant *getNot(Constant *C);\n  static Constant *getAdd(Constant *C1, Constant *C2,\n                          bool HasNUW = false, bool HasNSW = false);\n  static Constant *getFAdd(Constant *C1, Constant *C2);\n  static Constant *getSub(Constant *C1, Constant *C2,\n                          bool HasNUW = false, bool HasNSW = false);\n  static Constant *getFSub(Constant *C1, Constant *C2);\n  static Constant *getMul(Constant *C1, Constant *C2,\n                          bool HasNUW = false, bool HasNSW = false);\n  static Constant *getFMul(Constant *C1, Constant *C2);\n  static Constant *getUDiv(Constant *C1, Constant *C2, bool isExact = false);\n  static Constant *getSDiv(Constant *C1, Constant *C2, bool isExact = false);\n  static Constant *getFDiv(Constant *C1, Constant *C2);\n  static Constant *getURem(Constant *C1, Constant *C2);\n  static Constant *getSRem(Constant *C1, Constant *C2);\n  static Constant *getFRem(Constant *C1, Constant *C2);\n  static Constant *getAnd(Constant *C1, Constant *C2);\n  static Constant *getOr(Constant *C1, Constant *C2);\n  static Constant *getXor(Constant *C1, Constant *C2);\n  static Constant *getUMin(Constant *C1, Constant *C2);\n  static Constant *getShl(Constant *C1, Constant *C2,\n                          bool HasNUW = false, bool HasNSW = false);\n  static Constant *getLShr(Constant *C1, Constant *C2, bool isExact = false);\n  static Constant *getAShr(Constant *C1, Constant *C2, bool isExact = false);\n  static Constant *getTrunc(Constant *C, Type *Ty, bool OnlyIfReduced = false);\n  static Constant *getSExt(Constant *C, Type *Ty, bool OnlyIfReduced = false);\n  static Constant *getZExt(Constant *C, Type *Ty, bool OnlyIfReduced = false);\n  static Constant *getFPTrunc(Constant *C, Type *Ty,\n                              bool OnlyIfReduced = false);\n  static Constant *getFPExtend(Constant *C, Type *Ty,\n                               bool OnlyIfReduced = false);\n  static Constant *getUIToFP(Constant *C, Type *Ty, bool OnlyIfReduced = false);\n  static Constant *getSIToFP(Constant *C, Type *Ty, bool OnlyIfReduced = false);\n  static Constant *getFPToUI(Constant *C, Type *Ty, bool OnlyIfReduced = false);\n  static Constant *getFPToSI(Constant *C, Type *Ty, bool OnlyIfReduced = false);\n  static Constant *getPtrToInt(Constant *C, Type *Ty,\n                               bool OnlyIfReduced = false);\n  static Constant *getIntToPtr(Constant *C, Type *Ty,\n                               bool OnlyIfReduced = false);\n  static Constant *getBitCast(Constant *C, Type *Ty,\n                              bool OnlyIfReduced = false);\n  static Constant *getAddrSpaceCast(Constant *C, Type *Ty,\n                                    bool OnlyIfReduced = false);\n\n  static Constant *getNSWNeg(Constant *C) { return getNeg(C, false, true); }\n  static Constant *getNUWNeg(Constant *C) { return getNeg(C, true, false); }\n\n  static Constant *getNSWAdd(Constant *C1, Constant *C2) {\n    return getAdd(C1, C2, false, true);\n  }\n\n  static Constant *getNUWAdd(Constant *C1, Constant *C2) {\n    return getAdd(C1, C2, true, false);\n  }\n\n  static Constant *getNSWSub(Constant *C1, Constant *C2) {\n    return getSub(C1, C2, false, true);\n  }\n\n  static Constant *getNUWSub(Constant *C1, Constant *C2) {\n    return getSub(C1, C2, true, false);\n  }\n\n  static Constant *getNSWMul(Constant *C1, Constant *C2) {\n    return getMul(C1, C2, false, true);\n  }\n\n  static Constant *getNUWMul(Constant *C1, Constant *C2) {\n    return getMul(C1, C2, true, false);\n  }\n\n  static Constant *getNSWShl(Constant *C1, Constant *C2) {\n    return getShl(C1, C2, false, true);\n  }\n\n  static Constant *getNUWShl(Constant *C1, Constant *C2) {\n    return getShl(C1, C2, true, false);\n  }\n\n  static Constant *getExactSDiv(Constant *C1, Constant *C2) {\n    return getSDiv(C1, C2, true);\n  }\n\n  static Constant *getExactUDiv(Constant *C1, Constant *C2) {\n    return getUDiv(C1, C2, true);\n  }\n\n  static Constant *getExactAShr(Constant *C1, Constant *C2) {\n    return getAShr(C1, C2, true);\n  }\n\n  static Constant *getExactLShr(Constant *C1, Constant *C2) {\n    return getLShr(C1, C2, true);\n  }\n\n  /// If C is a scalar/fixed width vector of known powers of 2, then this\n  /// function returns a new scalar/fixed width vector obtained from logBase2\n  /// of C. Undef vector elements are set to zero.\n  /// Return a null pointer otherwise.\n  static Constant *getExactLogBase2(Constant *C);\n\n  /// Return the identity constant for a binary opcode.\n  /// The identity constant C is defined as X op C = X and C op X = X for every\n  /// X when the binary operation is commutative. If the binop is not\n  /// commutative, callers can acquire the operand 1 identity constant by\n  /// setting AllowRHSConstant to true. For example, any shift has a zero\n  /// identity constant for operand 1: X shift 0 = X.\n  /// Return nullptr if the operator does not have an identity constant.\n  static Constant *getBinOpIdentity(unsigned Opcode, Type *Ty,\n                                    bool AllowRHSConstant = false);\n\n  /// Return the absorbing element for the given binary\n  /// operation, i.e. a constant C such that X op C = C and C op X = C for\n  /// every X.  For example, this returns zero for integer multiplication.\n  /// It returns null if the operator doesn't have an absorbing element.\n  static Constant *getBinOpAbsorber(unsigned Opcode, Type *Ty);\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Constant);\n\n  /// Convenience function for getting a Cast operation.\n  ///\n  /// \\param ops The opcode for the conversion\n  /// \\param C  The constant to be converted\n  /// \\param Ty The type to which the constant is converted\n  /// \\param OnlyIfReduced see \\a getWithOperands() docs.\n  static Constant *getCast(unsigned ops, Constant *C, Type *Ty,\n                           bool OnlyIfReduced = false);\n\n  // Create a ZExt or BitCast cast constant expression\n  static Constant *getZExtOrBitCast(\n    Constant *C,   ///< The constant to zext or bitcast\n    Type *Ty ///< The type to zext or bitcast C to\n  );\n\n  // Create a SExt or BitCast cast constant expression\n  static Constant *getSExtOrBitCast(\n    Constant *C,   ///< The constant to sext or bitcast\n    Type *Ty ///< The type to sext or bitcast C to\n  );\n\n  // Create a Trunc or BitCast cast constant expression\n  static Constant *getTruncOrBitCast(\n    Constant *C,   ///< The constant to trunc or bitcast\n    Type *Ty ///< The type to trunc or bitcast C to\n  );\n\n  /// Create a BitCast, AddrSpaceCast, or a PtrToInt cast constant\n  /// expression.\n  static Constant *getPointerCast(\n    Constant *C,   ///< The pointer value to be casted (operand 0)\n    Type *Ty ///< The type to which cast should be made\n  );\n\n  /// Create a BitCast or AddrSpaceCast for a pointer type depending on\n  /// the address space.\n  static Constant *getPointerBitCastOrAddrSpaceCast(\n    Constant *C,   ///< The constant to addrspacecast or bitcast\n    Type *Ty ///< The type to bitcast or addrspacecast C to\n  );\n\n  /// Create a ZExt, Bitcast or Trunc for integer -> integer casts\n  static Constant *getIntegerCast(\n    Constant *C,    ///< The integer constant to be casted\n    Type *Ty, ///< The integer type to cast to\n    bool isSigned   ///< Whether C should be treated as signed or not\n  );\n\n  /// Create a FPExt, Bitcast or FPTrunc for fp -> fp casts\n  static Constant *getFPCast(\n    Constant *C,    ///< The integer constant to be casted\n    Type *Ty ///< The integer type to cast to\n  );\n\n  /// Return true if this is a convert constant expression\n  bool isCast() const;\n\n  /// Return true if this is a compare constant expression\n  bool isCompare() const;\n\n  /// Return true if this is an insertvalue or extractvalue expression,\n  /// and the getIndices() method may be used.\n  bool hasIndices() const;\n\n  /// Return true if this is a getelementptr expression and all\n  /// the index operands are compile-time known integers within the\n  /// corresponding notional static array extents. Note that this is\n  /// not equivalant to, a subset of, or a superset of the \"inbounds\"\n  /// property.\n  bool isGEPWithNoNotionalOverIndexing() const;\n\n  /// Select constant expr\n  ///\n  /// \\param OnlyIfReducedTy see \\a getWithOperands() docs.\n  static Constant *getSelect(Constant *C, Constant *V1, Constant *V2,\n                             Type *OnlyIfReducedTy = nullptr);\n\n  /// get - Return a unary operator constant expression,\n  /// folding if possible.\n  ///\n  /// \\param OnlyIfReducedTy see \\a getWithOperands() docs.\n  static Constant *get(unsigned Opcode, Constant *C1, unsigned Flags = 0, \n                       Type *OnlyIfReducedTy = nullptr);\n\n  /// get - Return a binary or shift operator constant expression,\n  /// folding if possible.\n  ///\n  /// \\param OnlyIfReducedTy see \\a getWithOperands() docs.\n  static Constant *get(unsigned Opcode, Constant *C1, Constant *C2,\n                       unsigned Flags = 0, Type *OnlyIfReducedTy = nullptr);\n\n  /// Return an ICmp or FCmp comparison operator constant expression.\n  ///\n  /// \\param OnlyIfReduced see \\a getWithOperands() docs.\n  static Constant *getCompare(unsigned short pred, Constant *C1, Constant *C2,\n                              bool OnlyIfReduced = false);\n\n  /// get* - Return some common constants without having to\n  /// specify the full Instruction::OPCODE identifier.\n  ///\n  static Constant *getICmp(unsigned short pred, Constant *LHS, Constant *RHS,\n                           bool OnlyIfReduced = false);\n  static Constant *getFCmp(unsigned short pred, Constant *LHS, Constant *RHS,\n                           bool OnlyIfReduced = false);\n\n  /// Getelementptr form.  Value* is only accepted for convenience;\n  /// all elements must be Constants.\n  ///\n  /// \\param InRangeIndex the inrange index if present or None.\n  /// \\param OnlyIfReducedTy see \\a getWithOperands() docs.\n  static Constant *getGetElementPtr(Type *Ty, Constant *C,\n                                    ArrayRef<Constant *> IdxList,\n                                    bool InBounds = false,\n                                    Optional<unsigned> InRangeIndex = None,\n                                    Type *OnlyIfReducedTy = nullptr) {\n    return getGetElementPtr(\n        Ty, C, makeArrayRef((Value * const *)IdxList.data(), IdxList.size()),\n        InBounds, InRangeIndex, OnlyIfReducedTy);\n  }\n  static Constant *getGetElementPtr(Type *Ty, Constant *C, Constant *Idx,\n                                    bool InBounds = false,\n                                    Optional<unsigned> InRangeIndex = None,\n                                    Type *OnlyIfReducedTy = nullptr) {\n    // This form of the function only exists to avoid ambiguous overload\n    // warnings about whether to convert Idx to ArrayRef<Constant *> or\n    // ArrayRef<Value *>.\n    return getGetElementPtr(Ty, C, cast<Value>(Idx), InBounds, InRangeIndex,\n                            OnlyIfReducedTy);\n  }\n  static Constant *getGetElementPtr(Type *Ty, Constant *C,\n                                    ArrayRef<Value *> IdxList,\n                                    bool InBounds = false,\n                                    Optional<unsigned> InRangeIndex = None,\n                                    Type *OnlyIfReducedTy = nullptr);\n\n  /// Create an \"inbounds\" getelementptr. See the documentation for the\n  /// \"inbounds\" flag in LangRef.html for details.\n  static Constant *getInBoundsGetElementPtr(Type *Ty, Constant *C,\n                                            ArrayRef<Constant *> IdxList) {\n    return getGetElementPtr(Ty, C, IdxList, true);\n  }\n  static Constant *getInBoundsGetElementPtr(Type *Ty, Constant *C,\n                                            Constant *Idx) {\n    // This form of the function only exists to avoid ambiguous overload\n    // warnings about whether to convert Idx to ArrayRef<Constant *> or\n    // ArrayRef<Value *>.\n    return getGetElementPtr(Ty, C, Idx, true);\n  }\n  static Constant *getInBoundsGetElementPtr(Type *Ty, Constant *C,\n                                            ArrayRef<Value *> IdxList) {\n    return getGetElementPtr(Ty, C, IdxList, true);\n  }\n\n  static Constant *getExtractElement(Constant *Vec, Constant *Idx,\n                                     Type *OnlyIfReducedTy = nullptr);\n  static Constant *getInsertElement(Constant *Vec, Constant *Elt, Constant *Idx,\n                                    Type *OnlyIfReducedTy = nullptr);\n  static Constant *getShuffleVector(Constant *V1, Constant *V2,\n                                    ArrayRef<int> Mask,\n                                    Type *OnlyIfReducedTy = nullptr);\n  static Constant *getExtractValue(Constant *Agg, ArrayRef<unsigned> Idxs,\n                                   Type *OnlyIfReducedTy = nullptr);\n  static Constant *getInsertValue(Constant *Agg, Constant *Val,\n                                  ArrayRef<unsigned> Idxs,\n                                  Type *OnlyIfReducedTy = nullptr);\n\n  /// Return the opcode at the root of this constant expression\n  unsigned getOpcode() const { return getSubclassDataFromValue(); }\n\n  /// Return the ICMP or FCMP predicate value. Assert if this is not an ICMP or\n  /// FCMP constant expression.\n  unsigned getPredicate() const;\n\n  /// Assert that this is an insertvalue or exactvalue\n  /// expression and return the list of indices.\n  ArrayRef<unsigned> getIndices() const;\n\n  /// Assert that this is a shufflevector and return the mask. See class\n  /// ShuffleVectorInst for a description of the mask representation.\n  ArrayRef<int> getShuffleMask() const;\n\n  /// Assert that this is a shufflevector and return the mask.\n  ///\n  /// TODO: This is a temporary hack until we update the bitcode format for\n  /// shufflevector.\n  Constant *getShuffleMaskForBitcode() const;\n\n  /// Return a string representation for an opcode.\n  const char *getOpcodeName() const;\n\n  /// Return a constant expression identical to this one, but with the specified\n  /// operand set to the specified value.\n  Constant *getWithOperandReplaced(unsigned OpNo, Constant *Op) const;\n\n  /// This returns the current constant expression with the operands replaced\n  /// with the specified values. The specified array must have the same number\n  /// of operands as our current one.\n  Constant *getWithOperands(ArrayRef<Constant*> Ops) const {\n    return getWithOperands(Ops, getType());\n  }\n\n  /// Get the current expression with the operands replaced.\n  ///\n  /// Return the current constant expression with the operands replaced with \\c\n  /// Ops and the type with \\c Ty.  The new operands must have the same number\n  /// as the current ones.\n  ///\n  /// If \\c OnlyIfReduced is \\c true, nullptr will be returned unless something\n  /// gets constant-folded, the type changes, or the expression is otherwise\n  /// canonicalized.  This parameter should almost always be \\c false.\n  Constant *getWithOperands(ArrayRef<Constant *> Ops, Type *Ty,\n                            bool OnlyIfReduced = false,\n                            Type *SrcTy = nullptr) const;\n\n  /// Returns an Instruction which implements the same operation as this\n  /// ConstantExpr. The instruction is not linked to any basic block.\n  ///\n  /// A better approach to this could be to have a constructor for Instruction\n  /// which would take a ConstantExpr parameter, but that would have spread\n  /// implementation details of ConstantExpr outside of Constants.cpp, which\n  /// would make it harder to remove ConstantExprs altogether.\n  Instruction *getAsInstruction() const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == ConstantExprVal;\n  }\n\nprivate:\n  // Shadow Value::setValueSubclassData with a private forwarding method so that\n  // subclasses cannot accidentally use it.\n  void setValueSubclassData(unsigned short D) {\n    Value::setValueSubclassData(D);\n  }\n};\n\ntemplate <>\nstruct OperandTraits<ConstantExpr> :\n  public VariadicOperandTraits<ConstantExpr, 1> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(ConstantExpr, Constant)\n\n//===----------------------------------------------------------------------===//\n/// 'undef' values are things that do not have specified contents.\n/// These are used for a variety of purposes, including global variable\n/// initializers and operands to instructions.  'undef' values can occur with\n/// any first-class type.\n///\n/// Undef values aren't exactly constants; if they have multiple uses, they\n/// can appear to have different bit patterns at each use. See\n/// LangRef.html#undefvalues for details.\n///\nclass UndefValue : public ConstantData {\n  friend class Constant;\n\n  explicit UndefValue(Type *T) : ConstantData(T, UndefValueVal) {}\n\n  void destroyConstantImpl();\n\nprotected:\n  explicit UndefValue(Type *T, ValueTy vty) : ConstantData(T, vty) {}\n\npublic:\n  UndefValue(const UndefValue &) = delete;\n\n  /// Static factory methods - Return an 'undef' object of the specified type.\n  static UndefValue *get(Type *T);\n\n  /// If this Undef has array or vector type, return a undef with the right\n  /// element type.\n  UndefValue *getSequentialElement() const;\n\n  /// If this undef has struct type, return a undef with the right element type\n  /// for the specified element.\n  UndefValue *getStructElement(unsigned Elt) const;\n\n  /// Return an undef of the right value for the specified GEP index if we can,\n  /// otherwise return null (e.g. if C is a ConstantExpr).\n  UndefValue *getElementValue(Constant *C) const;\n\n  /// Return an undef of the right value for the specified GEP index.\n  UndefValue *getElementValue(unsigned Idx) const;\n\n  /// Return the number of elements in the array, vector, or struct.\n  unsigned getNumElements() const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == UndefValueVal ||\n           V->getValueID() == PoisonValueVal;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// In order to facilitate speculative execution, many instructions do not\n/// invoke immediate undefined behavior when provided with illegal operands,\n/// and return a poison value instead.\n///\n/// see LangRef.html#poisonvalues for details.\n///\nclass PoisonValue final : public UndefValue {\n  friend class Constant;\n\n  explicit PoisonValue(Type *T) : UndefValue(T, PoisonValueVal) {}\n\n  void destroyConstantImpl();\n\npublic:\n  PoisonValue(const PoisonValue &) = delete;\n\n  /// Static factory methods - Return an 'poison' object of the specified type.\n  static PoisonValue *get(Type *T);\n\n  /// If this poison has array or vector type, return a poison with the right\n  /// element type.\n  PoisonValue *getSequentialElement() const;\n\n  /// If this poison has struct type, return a poison with the right element\n  /// type for the specified element.\n  PoisonValue *getStructElement(unsigned Elt) const;\n\n  /// Return an poison of the right value for the specified GEP index if we can,\n  /// otherwise return null (e.g. if C is a ConstantExpr).\n  PoisonValue *getElementValue(Constant *C) const;\n\n  /// Return an poison of the right value for the specified GEP index.\n  PoisonValue *getElementValue(unsigned Idx) const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Value *V) {\n    return V->getValueID() == PoisonValueVal;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_CONSTANTS_H\n"}, "47": {"id": 47, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DataLayout.h", "content": "//===- llvm/DataLayout.h - Data size & alignment info -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines layout properties related to datatype size/offset/alignment\n// information.  It uses lazy annotations to cache information about how\n// structure types are laid out and used.\n//\n// This structure should be created once, filled in if the defaults are not\n// correct and then passed around by const&.  None of the members functions\n// require modification to the object.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_DATALAYOUT_H\n#define LLVM_IR_DATALAYOUT_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include <cassert>\n#include <cstdint>\n#include <string>\n\n// This needs to be outside of the namespace, to avoid conflict with llvm-c\n// decl.\nusing LLVMTargetDataRef = struct LLVMOpaqueTargetData *;\n\nnamespace llvm {\n\nclass GlobalVariable;\nclass LLVMContext;\nclass Module;\nclass StructLayout;\nclass Triple;\nclass Value;\n\n/// Enum used to categorize the alignment types stored by LayoutAlignElem\nenum AlignTypeEnum {\n  INVALID_ALIGN = 0,\n  INTEGER_ALIGN = 'i',\n  VECTOR_ALIGN = 'v',\n  FLOAT_ALIGN = 'f',\n  AGGREGATE_ALIGN = 'a'\n};\n\n// FIXME: Currently the DataLayout string carries a \"preferred alignment\"\n// for types. As the DataLayout is module/global, this should likely be\n// sunk down to an FTTI element that is queried rather than a global\n// preference.\n\n/// Layout alignment element.\n///\n/// Stores the alignment data associated with a given alignment type (integer,\n/// vector, float) and type bit width.\n///\n/// \\note The unusual order of elements in the structure attempts to reduce\n/// padding and make the structure slightly more cache friendly.\nstruct LayoutAlignElem {\n  /// Alignment type from \\c AlignTypeEnum\n  unsigned AlignType : 8;\n  unsigned TypeBitWidth : 24;\n  Align ABIAlign;\n  Align PrefAlign;\n\n  static LayoutAlignElem get(AlignTypeEnum align_type, Align abi_align,\n                             Align pref_align, uint32_t bit_width);\n\n  bool operator==(const LayoutAlignElem &rhs) const;\n};\n\n/// Layout pointer alignment element.\n///\n/// Stores the alignment data associated with a given pointer and address space.\n///\n/// \\note The unusual order of elements in the structure attempts to reduce\n/// padding and make the structure slightly more cache friendly.\nstruct PointerAlignElem {\n  Align ABIAlign;\n  Align PrefAlign;\n  uint32_t TypeByteWidth;\n  uint32_t AddressSpace;\n  uint32_t IndexWidth;\n\n  /// Initializer\n  static PointerAlignElem get(uint32_t AddressSpace, Align ABIAlign,\n                              Align PrefAlign, uint32_t TypeByteWidth,\n                              uint32_t IndexWidth);\n\n  bool operator==(const PointerAlignElem &rhs) const;\n};\n\n/// A parsed version of the target data layout string in and methods for\n/// querying it.\n///\n/// The target data layout string is specified *by the target* - a frontend\n/// generating LLVM IR is required to generate the right target data for the\n/// target being codegen'd to.\nclass DataLayout {\npublic:\n  enum class FunctionPtrAlignType {\n    /// The function pointer alignment is independent of the function alignment.\n    Independent,\n    /// The function pointer alignment is a multiple of the function alignment.\n    MultipleOfFunctionAlign,\n  };\nprivate:\n  /// Defaults to false.\n  bool BigEndian;\n\n  unsigned AllocaAddrSpace;\n  MaybeAlign StackNaturalAlign;\n  unsigned ProgramAddrSpace;\n  unsigned DefaultGlobalsAddrSpace;\n\n  MaybeAlign FunctionPtrAlign;\n  FunctionPtrAlignType TheFunctionPtrAlignType;\n\n  enum ManglingModeT {\n    MM_None,\n    MM_ELF,\n    MM_MachO,\n    MM_WinCOFF,\n    MM_WinCOFFX86,\n    MM_Mips,\n    MM_XCOFF\n  };\n  ManglingModeT ManglingMode;\n\n  SmallVector<unsigned char, 8> LegalIntWidths;\n\n  /// Primitive type alignment data. This is sorted by type and bit\n  /// width during construction.\n  using AlignmentsTy = SmallVector<LayoutAlignElem, 16>;\n  AlignmentsTy Alignments;\n\n  AlignmentsTy::const_iterator\n  findAlignmentLowerBound(AlignTypeEnum AlignType, uint32_t BitWidth) const {\n    return const_cast<DataLayout *>(this)->findAlignmentLowerBound(AlignType,\n                                                                   BitWidth);\n  }\n\n  AlignmentsTy::iterator\n  findAlignmentLowerBound(AlignTypeEnum AlignType, uint32_t BitWidth);\n\n  /// The string representation used to create this DataLayout\n  std::string StringRepresentation;\n\n  using PointersTy = SmallVector<PointerAlignElem, 8>;\n  PointersTy Pointers;\n\n  const PointerAlignElem &getPointerAlignElem(uint32_t AddressSpace) const;\n\n  // The StructType -> StructLayout map.\n  mutable void *LayoutMap = nullptr;\n\n  /// Pointers in these address spaces are non-integral, and don't have a\n  /// well-defined bitwise representation.\n  SmallVector<unsigned, 8> NonIntegralAddressSpaces;\n\n  /// Attempts to set the alignment of the given type. Returns an error\n  /// description on failure.\n  Error setAlignment(AlignTypeEnum align_type, Align abi_align,\n                     Align pref_align, uint32_t bit_width);\n\n  /// Attempts to set the alignment of a pointer in the given address space.\n  /// Returns an error description on failure.\n  Error setPointerAlignment(uint32_t AddrSpace, Align ABIAlign, Align PrefAlign,\n                            uint32_t TypeByteWidth, uint32_t IndexWidth);\n\n  /// Internal helper to get alignment for integer of given bitwidth.\n  Align getIntegerAlignment(uint32_t BitWidth, bool abi_or_pref) const;\n\n  /// Internal helper method that returns requested alignment for type.\n  Align getAlignment(Type *Ty, bool abi_or_pref) const;\n\n  /// Attempts to parse a target data specification string and reports an error\n  /// if the string is malformed.\n  Error parseSpecifier(StringRef Desc);\n\n  // Free all internal data structures.\n  void clear();\n\npublic:\n  /// Constructs a DataLayout from a specification string. See reset().\n  explicit DataLayout(StringRef LayoutDescription) {\n    reset(LayoutDescription);\n  }\n\n  /// Initialize target data from properties stored in the module.\n  explicit DataLayout(const Module *M);\n\n  DataLayout(const DataLayout &DL) { *this = DL; }\n\n  ~DataLayout(); // Not virtual, do not subclass this class\n\n  DataLayout &operator=(const DataLayout &DL) {\n    clear();\n    StringRepresentation = DL.StringRepresentation;\n    BigEndian = DL.isBigEndian();\n    AllocaAddrSpace = DL.AllocaAddrSpace;\n    StackNaturalAlign = DL.StackNaturalAlign;\n    FunctionPtrAlign = DL.FunctionPtrAlign;\n    TheFunctionPtrAlignType = DL.TheFunctionPtrAlignType;\n    ProgramAddrSpace = DL.ProgramAddrSpace;\n    DefaultGlobalsAddrSpace = DL.DefaultGlobalsAddrSpace;\n    ManglingMode = DL.ManglingMode;\n    LegalIntWidths = DL.LegalIntWidths;\n    Alignments = DL.Alignments;\n    Pointers = DL.Pointers;\n    NonIntegralAddressSpaces = DL.NonIntegralAddressSpaces;\n    return *this;\n  }\n\n  bool operator==(const DataLayout &Other) const;\n  bool operator!=(const DataLayout &Other) const { return !(*this == Other); }\n\n  void init(const Module *M);\n\n  /// Parse a data layout string (with fallback to default values).\n  void reset(StringRef LayoutDescription);\n\n  /// Parse a data layout string and return the layout. Return an error\n  /// description on failure.\n  static Expected<DataLayout> parse(StringRef LayoutDescription);\n\n  /// Layout endianness...\n  bool isLittleEndian() const { return !BigEndian; }\n  bool isBigEndian() const { return BigEndian; }\n\n  /// Returns the string representation of the DataLayout.\n  ///\n  /// This representation is in the same format accepted by the string\n  /// constructor above. This should not be used to compare two DataLayout as\n  /// different string can represent the same layout.\n  const std::string &getStringRepresentation() const {\n    return StringRepresentation;\n  }\n\n  /// Test if the DataLayout was constructed from an empty string.\n  bool isDefault() const { return StringRepresentation.empty(); }\n\n  /// Returns true if the specified type is known to be a native integer\n  /// type supported by the CPU.\n  ///\n  /// For example, i64 is not native on most 32-bit CPUs and i37 is not native\n  /// on any known one. This returns false if the integer width is not legal.\n  ///\n  /// The width is specified in bits.\n  bool isLegalInteger(uint64_t Width) const {\n    return llvm::is_contained(LegalIntWidths, Width);\n  }\n\n  bool isIllegalInteger(uint64_t Width) const { return !isLegalInteger(Width); }\n\n  /// Returns true if the given alignment exceeds the natural stack alignment.\n  bool exceedsNaturalStackAlignment(Align Alignment) const {\n    return StackNaturalAlign && (Alignment > *StackNaturalAlign);\n  }\n\n  Align getStackAlignment() const {\n    assert(StackNaturalAlign && \"StackNaturalAlign must be defined\");\n    return *StackNaturalAlign;\n  }\n\n  unsigned getAllocaAddrSpace() const { return AllocaAddrSpace; }\n\n  /// Returns the alignment of function pointers, which may or may not be\n  /// related to the alignment of functions.\n  /// \\see getFunctionPtrAlignType\n  MaybeAlign getFunctionPtrAlign() const { return FunctionPtrAlign; }\n\n  /// Return the type of function pointer alignment.\n  /// \\see getFunctionPtrAlign\n  FunctionPtrAlignType getFunctionPtrAlignType() const {\n    return TheFunctionPtrAlignType;\n  }\n\n  unsigned getProgramAddressSpace() const { return ProgramAddrSpace; }\n  unsigned getDefaultGlobalsAddressSpace() const {\n    return DefaultGlobalsAddrSpace;\n  }\n\n  bool hasMicrosoftFastStdCallMangling() const {\n    return ManglingMode == MM_WinCOFFX86;\n  }\n\n  /// Returns true if symbols with leading question marks should not receive IR\n  /// mangling. True for Windows mangling modes.\n  bool doNotMangleLeadingQuestionMark() const {\n    return ManglingMode == MM_WinCOFF || ManglingMode == MM_WinCOFFX86;\n  }\n\n  bool hasLinkerPrivateGlobalPrefix() const { return ManglingMode == MM_MachO; }\n\n  StringRef getLinkerPrivateGlobalPrefix() const {\n    if (ManglingMode == MM_MachO)\n      return \"l\";\n    return \"\";\n  }\n\n  char getGlobalPrefix() const {\n    switch (ManglingMode) {\n    case MM_None:\n    case MM_ELF:\n    case MM_Mips:\n    case MM_WinCOFF:\n    case MM_XCOFF:\n      return '\\0';\n    case MM_MachO:\n    case MM_WinCOFFX86:\n      return '_';\n    }\n    llvm_unreachable(\"invalid mangling mode\");\n  }\n\n  StringRef getPrivateGlobalPrefix() const {\n    switch (ManglingMode) {\n    case MM_None:\n      return \"\";\n    case MM_ELF:\n    case MM_WinCOFF:\n      return \".L\";\n    case MM_Mips:\n      return \"$\";\n    case MM_MachO:\n    case MM_WinCOFFX86:\n      return \"L\";\n    case MM_XCOFF:\n      return \"L..\";\n    }\n    llvm_unreachable(\"invalid mangling mode\");\n  }\n\n  static const char *getManglingComponent(const Triple &T);\n\n  /// Returns true if the specified type fits in a native integer type\n  /// supported by the CPU.\n  ///\n  /// For example, if the CPU only supports i32 as a native integer type, then\n  /// i27 fits in a legal integer type but i45 does not.\n  bool fitsInLegalInteger(unsigned Width) const {\n    for (unsigned LegalIntWidth : LegalIntWidths)\n      if (Width <= LegalIntWidth)\n        return true;\n    return false;\n  }\n\n  /// Layout pointer alignment\n  Align getPointerABIAlignment(unsigned AS) const;\n\n  /// Return target's alignment for stack-based pointers\n  /// FIXME: The defaults need to be removed once all of\n  /// the backends/clients are updated.\n  Align getPointerPrefAlignment(unsigned AS = 0) const;\n\n  /// Layout pointer size\n  /// FIXME: The defaults need to be removed once all of\n  /// the backends/clients are updated.\n  unsigned getPointerSize(unsigned AS = 0) const;\n\n  /// Returns the maximum pointer size over all address spaces.\n  unsigned getMaxPointerSize() const;\n\n  // Index size used for address calculation.\n  unsigned getIndexSize(unsigned AS) const;\n\n  /// Return the address spaces containing non-integral pointers.  Pointers in\n  /// this address space don't have a well-defined bitwise representation.\n  ArrayRef<unsigned> getNonIntegralAddressSpaces() const {\n    return NonIntegralAddressSpaces;\n  }\n\n  bool isNonIntegralAddressSpace(unsigned AddrSpace) const {\n    ArrayRef<unsigned> NonIntegralSpaces = getNonIntegralAddressSpaces();\n    return is_contained(NonIntegralSpaces, AddrSpace);\n  }\n\n  bool isNonIntegralPointerType(PointerType *PT) const {\n    return isNonIntegralAddressSpace(PT->getAddressSpace());\n  }\n\n  bool isNonIntegralPointerType(Type *Ty) const {\n    auto *PTy = dyn_cast<PointerType>(Ty);\n    return PTy && isNonIntegralPointerType(PTy);\n  }\n\n  /// Layout pointer size, in bits\n  /// FIXME: The defaults need to be removed once all of\n  /// the backends/clients are updated.\n  unsigned getPointerSizeInBits(unsigned AS = 0) const {\n    return getPointerSize(AS) * 8;\n  }\n\n  /// Returns the maximum pointer size over all address spaces.\n  unsigned getMaxPointerSizeInBits() const {\n    return getMaxPointerSize() * 8;\n  }\n\n  /// Size in bits of index used for address calculation in getelementptr.\n  unsigned getIndexSizeInBits(unsigned AS) const {\n    return getIndexSize(AS) * 8;\n  }\n\n  /// Layout pointer size, in bits, based on the type.  If this function is\n  /// called with a pointer type, then the type size of the pointer is returned.\n  /// If this function is called with a vector of pointers, then the type size\n  /// of the pointer is returned.  This should only be called with a pointer or\n  /// vector of pointers.\n  unsigned getPointerTypeSizeInBits(Type *) const;\n\n  /// Layout size of the index used in GEP calculation.\n  /// The function should be called with pointer or vector of pointers type.\n  unsigned getIndexTypeSizeInBits(Type *Ty) const;\n\n  unsigned getPointerTypeSize(Type *Ty) const {\n    return getPointerTypeSizeInBits(Ty) / 8;\n  }\n\n  /// Size examples:\n  ///\n  /// Type        SizeInBits  StoreSizeInBits  AllocSizeInBits[*]\n  /// ----        ----------  ---------------  ---------------\n  ///  i1            1           8                8\n  ///  i8            8           8                8\n  ///  i19          19          24               32\n  ///  i32          32          32               32\n  ///  i100        100         104              128\n  ///  i128        128         128              128\n  ///  Float        32          32               32\n  ///  Double       64          64               64\n  ///  X86_FP80     80          80               96\n  ///\n  /// [*] The alloc size depends on the alignment, and thus on the target.\n  ///     These values are for x86-32 linux.\n\n  /// Returns the number of bits necessary to hold the specified type.\n  ///\n  /// If Ty is a scalable vector type, the scalable property will be set and\n  /// the runtime size will be a positive integer multiple of the base size.\n  ///\n  /// For example, returns 36 for i36 and 80 for x86_fp80. The type passed must\n  /// have a size (Type::isSized() must return true).\n  TypeSize getTypeSizeInBits(Type *Ty) const;\n\n  /// Returns the maximum number of bytes that may be overwritten by\n  /// storing the specified type.\n  ///\n  /// If Ty is a scalable vector type, the scalable property will be set and\n  /// the runtime size will be a positive integer multiple of the base size.\n  ///\n  /// For example, returns 5 for i36 and 10 for x86_fp80.\n  TypeSize getTypeStoreSize(Type *Ty) const {\n    TypeSize BaseSize = getTypeSizeInBits(Ty);\n    return { (BaseSize.getKnownMinSize() + 7) / 8, BaseSize.isScalable() };\n  }\n\n  /// Returns the maximum number of bits that may be overwritten by\n  /// storing the specified type; always a multiple of 8.\n  ///\n  /// If Ty is a scalable vector type, the scalable property will be set and\n  /// the runtime size will be a positive integer multiple of the base size.\n  ///\n  /// For example, returns 40 for i36 and 80 for x86_fp80.\n  TypeSize getTypeStoreSizeInBits(Type *Ty) const {\n    return 8 * getTypeStoreSize(Ty);\n  }\n\n  /// Returns true if no extra padding bits are needed when storing the\n  /// specified type.\n  ///\n  /// For example, returns false for i19 that has a 24-bit store size.\n  bool typeSizeEqualsStoreSize(Type *Ty) const {\n    return getTypeSizeInBits(Ty) == getTypeStoreSizeInBits(Ty);\n  }\n\n  /// Returns the offset in bytes between successive objects of the\n  /// specified type, including alignment padding.\n  ///\n  /// If Ty is a scalable vector type, the scalable property will be set and\n  /// the runtime size will be a positive integer multiple of the base size.\n  ///\n  /// This is the amount that alloca reserves for this type. For example,\n  /// returns 12 or 16 for x86_fp80, depending on alignment.\n  TypeSize getTypeAllocSize(Type *Ty) const {\n    // Round up to the next alignment boundary.\n    return alignTo(getTypeStoreSize(Ty), getABITypeAlignment(Ty));\n  }\n\n  /// Returns the offset in bits between successive objects of the\n  /// specified type, including alignment padding; always a multiple of 8.\n  ///\n  /// If Ty is a scalable vector type, the scalable property will be set and\n  /// the runtime size will be a positive integer multiple of the base size.\n  ///\n  /// This is the amount that alloca reserves for this type. For example,\n  /// returns 96 or 128 for x86_fp80, depending on alignment.\n  TypeSize getTypeAllocSizeInBits(Type *Ty) const {\n    return 8 * getTypeAllocSize(Ty);\n  }\n\n  /// Returns the minimum ABI-required alignment for the specified type.\n  /// FIXME: Deprecate this function once migration to Align is over.\n  unsigned getABITypeAlignment(Type *Ty) const;\n\n  /// Returns the minimum ABI-required alignment for the specified type.\n  Align getABITypeAlign(Type *Ty) const;\n\n  /// Helper function to return `Alignment` if it's set or the result of\n  /// `getABITypeAlignment(Ty)`, in any case the result is a valid alignment.\n  inline Align getValueOrABITypeAlignment(MaybeAlign Alignment,\n                                          Type *Ty) const {\n    return Alignment ? *Alignment : getABITypeAlign(Ty);\n  }\n\n  /// Returns the minimum ABI-required alignment for an integer type of\n  /// the specified bitwidth.\n  Align getABIIntegerTypeAlignment(unsigned BitWidth) const {\n    return getIntegerAlignment(BitWidth, /* abi_or_pref */ true);\n  }\n\n  /// Returns the preferred stack/global alignment for the specified\n  /// type.\n  ///\n  /// This is always at least as good as the ABI alignment.\n  /// FIXME: Deprecate this function once migration to Align is over.\n  unsigned getPrefTypeAlignment(Type *Ty) const;\n\n  /// Returns the preferred stack/global alignment for the specified\n  /// type.\n  ///\n  /// This is always at least as good as the ABI alignment.\n  Align getPrefTypeAlign(Type *Ty) const;\n\n  /// Returns an integer type with size at least as big as that of a\n  /// pointer in the given address space.\n  IntegerType *getIntPtrType(LLVMContext &C, unsigned AddressSpace = 0) const;\n\n  /// Returns an integer (vector of integer) type with size at least as\n  /// big as that of a pointer of the given pointer (vector of pointer) type.\n  Type *getIntPtrType(Type *) const;\n\n  /// Returns the smallest integer type with size at least as big as\n  /// Width bits.\n  Type *getSmallestLegalIntType(LLVMContext &C, unsigned Width = 0) const;\n\n  /// Returns the largest legal integer type, or null if none are set.\n  Type *getLargestLegalIntType(LLVMContext &C) const {\n    unsigned LargestSize = getLargestLegalIntTypeSizeInBits();\n    return (LargestSize == 0) ? nullptr : Type::getIntNTy(C, LargestSize);\n  }\n\n  /// Returns the size of largest legal integer type size, or 0 if none\n  /// are set.\n  unsigned getLargestLegalIntTypeSizeInBits() const;\n\n  /// Returns the type of a GEP index.\n  /// If it was not specified explicitly, it will be the integer type of the\n  /// pointer width - IntPtrType.\n  Type *getIndexType(Type *PtrTy) const;\n\n  /// Returns the offset from the beginning of the type for the specified\n  /// indices.\n  ///\n  /// Note that this takes the element type, not the pointer type.\n  /// This is used to implement getelementptr.\n  int64_t getIndexedOffsetInType(Type *ElemTy, ArrayRef<Value *> Indices) const;\n\n  /// Returns a StructLayout object, indicating the alignment of the\n  /// struct, its size, and the offsets of its fields.\n  ///\n  /// Note that this information is lazily cached.\n  const StructLayout *getStructLayout(StructType *Ty) const;\n\n  /// Returns the preferred alignment of the specified global.\n  ///\n  /// This includes an explicitly requested alignment (if the global has one).\n  Align getPreferredAlign(const GlobalVariable *GV) const;\n\n  /// Returns the preferred alignment of the specified global.\n  ///\n  /// This includes an explicitly requested alignment (if the global has one).\n  LLVM_ATTRIBUTE_DEPRECATED(\n      inline unsigned getPreferredAlignment(const GlobalVariable *GV) const,\n      \"Use getPreferredAlign instead\") {\n    return getPreferredAlign(GV).value();\n  }\n\n  /// Returns the preferred alignment of the specified global, returned\n  /// in log form.\n  ///\n  /// This includes an explicitly requested alignment (if the global has one).\n  LLVM_ATTRIBUTE_DEPRECATED(\n      inline unsigned getPreferredAlignmentLog(const GlobalVariable *GV) const,\n      \"Inline where needed\") {\n    return Log2(getPreferredAlign(GV));\n  }\n};\n\ninline DataLayout *unwrap(LLVMTargetDataRef P) {\n  return reinterpret_cast<DataLayout *>(P);\n}\n\ninline LLVMTargetDataRef wrap(const DataLayout *P) {\n  return reinterpret_cast<LLVMTargetDataRef>(const_cast<DataLayout *>(P));\n}\n\n/// Used to lazily calculate structure layout information for a target machine,\n/// based on the DataLayout structure.\nclass StructLayout {\n  uint64_t StructSize;\n  Align StructAlignment;\n  unsigned IsPadded : 1;\n  unsigned NumElements : 31;\n  uint64_t MemberOffsets[1]; // variable sized array!\n\npublic:\n  uint64_t getSizeInBytes() const { return StructSize; }\n\n  uint64_t getSizeInBits() const { return 8 * StructSize; }\n\n  Align getAlignment() const { return StructAlignment; }\n\n  /// Returns whether the struct has padding or not between its fields.\n  /// NB: Padding in nested element is not taken into account.\n  bool hasPadding() const { return IsPadded; }\n\n  /// Given a valid byte offset into the structure, returns the structure\n  /// index that contains it.\n  unsigned getElementContainingOffset(uint64_t Offset) const;\n\n  uint64_t getElementOffset(unsigned Idx) const {\n    assert(Idx < NumElements && \"Invalid element idx!\");\n    return MemberOffsets[Idx];\n  }\n\n  uint64_t getElementOffsetInBits(unsigned Idx) const {\n    return getElementOffset(Idx) * 8;\n  }\n\nprivate:\n  friend class DataLayout; // Only DataLayout can create this class\n\n  StructLayout(StructType *ST, const DataLayout &DL);\n};\n\n// The implementation of this method is provided inline as it is particularly\n// well suited to constant folding when called on a specific Type subclass.\ninline TypeSize DataLayout::getTypeSizeInBits(Type *Ty) const {\n  assert(Ty->isSized() && \"Cannot getTypeInfo() on a type that is unsized!\");\n  switch (Ty->getTypeID()) {\n  case Type::LabelTyID:\n    return TypeSize::Fixed(getPointerSizeInBits(0));\n  case Type::PointerTyID:\n    return TypeSize::Fixed(getPointerSizeInBits(Ty->getPointerAddressSpace()));\n  case Type::ArrayTyID: {\n    ArrayType *ATy = cast<ArrayType>(Ty);\n    return ATy->getNumElements() *\n           getTypeAllocSizeInBits(ATy->getElementType());\n  }\n  case Type::StructTyID:\n    // Get the layout annotation... which is lazily created on demand.\n    return TypeSize::Fixed(\n                        getStructLayout(cast<StructType>(Ty))->getSizeInBits());\n  case Type::IntegerTyID:\n    return TypeSize::Fixed(Ty->getIntegerBitWidth());\n  case Type::HalfTyID:\n  case Type::BFloatTyID:\n    return TypeSize::Fixed(16);\n  case Type::FloatTyID:\n    return TypeSize::Fixed(32);\n  case Type::DoubleTyID:\n  case Type::X86_MMXTyID:\n    return TypeSize::Fixed(64);\n  case Type::PPC_FP128TyID:\n  case Type::FP128TyID:\n    return TypeSize::Fixed(128);\n  case Type::X86_AMXTyID:\n    return TypeSize::Fixed(8192);\n  // In memory objects this is always aligned to a higher boundary, but\n  // only 80 bits contain information.\n  case Type::X86_FP80TyID:\n    return TypeSize::Fixed(80);\n  case Type::FixedVectorTyID:\n  case Type::ScalableVectorTyID: {\n    VectorType *VTy = cast<VectorType>(Ty);\n    auto EltCnt = VTy->getElementCount();\n    uint64_t MinBits = EltCnt.getKnownMinValue() *\n                       getTypeSizeInBits(VTy->getElementType()).getFixedSize();\n    return TypeSize(MinBits, EltCnt.isScalable());\n  }\n  default:\n    llvm_unreachable(\"DataLayout::getTypeSizeInBits(): Unsupported type\");\n  }\n}\n\n} // end namespace llvm\n\n#endif // LLVM_IR_DATALAYOUT_H\n"}, "48": {"id": 48, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "content": "//===- llvm/IR/DebugInfoMetadata.h - Debug info metadata --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Declarations for metadata specific to debug info.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_DEBUGINFOMETADATA_H\n#define LLVM_IR_DEBUGINFOMETADATA_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/BitmaskEnum.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <type_traits>\n#include <vector>\n\n// Helper macros for defining get() overrides.\n#define DEFINE_MDNODE_GET_UNPACK_IMPL(...) __VA_ARGS__\n#define DEFINE_MDNODE_GET_UNPACK(ARGS) DEFINE_MDNODE_GET_UNPACK_IMPL ARGS\n#define DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(CLASS, FORMAL, ARGS)              \\\n  static CLASS *getDistinct(LLVMContext &Context,                              \\\n                            DEFINE_MDNODE_GET_UNPACK(FORMAL)) {                \\\n    return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Distinct);         \\\n  }                                                                            \\\n  static Temp##CLASS getTemporary(LLVMContext &Context,                        \\\n                                  DEFINE_MDNODE_GET_UNPACK(FORMAL)) {          \\\n    return Temp##CLASS(                                                        \\\n        getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Temporary));          \\\n  }\n#define DEFINE_MDNODE_GET(CLASS, FORMAL, ARGS)                                 \\\n  static CLASS *get(LLVMContext &Context, DEFINE_MDNODE_GET_UNPACK(FORMAL)) {  \\\n    return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Uniqued);          \\\n  }                                                                            \\\n  static CLASS *getIfExists(LLVMContext &Context,                              \\\n                            DEFINE_MDNODE_GET_UNPACK(FORMAL)) {                \\\n    return getImpl(Context, DEFINE_MDNODE_GET_UNPACK(ARGS), Uniqued,           \\\n                   /* ShouldCreate */ false);                                  \\\n  }                                                                            \\\n  DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(CLASS, FORMAL, ARGS)\n\nnamespace llvm {\n\nclass DITypeRefArray {\n  const MDTuple *N = nullptr;\n\npublic:\n  DITypeRefArray() = default;\n  DITypeRefArray(const MDTuple *N) : N(N) {}\n\n  explicit operator bool() const { return get(); }\n  explicit operator MDTuple *() const { return get(); }\n\n  MDTuple *get() const { return const_cast<MDTuple *>(N); }\n  MDTuple *operator->() const { return get(); }\n  MDTuple &operator*() const { return *get(); }\n\n  // FIXME: Fix callers and remove condition on N.\n  unsigned size() const { return N ? N->getNumOperands() : 0u; }\n  DIType *operator[](unsigned I) const {\n    return cast_or_null<DIType>(N->getOperand(I));\n  }\n\n  class iterator : std::iterator<std::input_iterator_tag, DIType *,\n                                 std::ptrdiff_t, void, DIType *> {\n    MDNode::op_iterator I = nullptr;\n\n  public:\n    iterator() = default;\n    explicit iterator(MDNode::op_iterator I) : I(I) {}\n\n    DIType *operator*() const { return cast_or_null<DIType>(*I); }\n\n    iterator &operator++() {\n      ++I;\n      return *this;\n    }\n\n    iterator operator++(int) {\n      iterator Temp(*this);\n      ++I;\n      return Temp;\n    }\n\n    bool operator==(const iterator &X) const { return I == X.I; }\n    bool operator!=(const iterator &X) const { return I != X.I; }\n  };\n\n  // FIXME: Fix callers and remove condition on N.\n  iterator begin() const { return N ? iterator(N->op_begin()) : iterator(); }\n  iterator end() const { return N ? iterator(N->op_end()) : iterator(); }\n};\n\n/// Tagged DWARF-like metadata node.\n///\n/// A metadata node with a DWARF tag (i.e., a constant named \\c DW_TAG_*,\n/// defined in llvm/BinaryFormat/Dwarf.h).  Called \\a DINode because it's\n/// potentially used for non-DWARF output.\nclass DINode : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\nprotected:\n  DINode(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,\n         ArrayRef<Metadata *> Ops1, ArrayRef<Metadata *> Ops2 = None)\n      : MDNode(C, ID, Storage, Ops1, Ops2) {\n    assert(Tag < 1u << 16);\n    SubclassData16 = Tag;\n  }\n  ~DINode() = default;\n\n  template <class Ty> Ty *getOperandAs(unsigned I) const {\n    return cast_or_null<Ty>(getOperand(I));\n  }\n\n  StringRef getStringOperand(unsigned I) const {\n    if (auto *S = getOperandAs<MDString>(I))\n      return S->getString();\n    return StringRef();\n  }\n\n  static MDString *getCanonicalMDString(LLVMContext &Context, StringRef S) {\n    if (S.empty())\n      return nullptr;\n    return MDString::get(Context, S);\n  }\n\n  /// Allow subclasses to mutate the tag.\n  void setTag(unsigned Tag) { SubclassData16 = Tag; }\n\npublic:\n  unsigned getTag() const { return SubclassData16; }\n\n  /// Debug info flags.\n  ///\n  /// The three accessibility flags are mutually exclusive and rolled together\n  /// in the first two bits.\n  enum DIFlags : uint32_t {\n#define HANDLE_DI_FLAG(ID, NAME) Flag##NAME = ID,\n#define DI_FLAG_LARGEST_NEEDED\n#include \"llvm/IR/DebugInfoFlags.def\"\n    FlagAccessibility = FlagPrivate | FlagProtected | FlagPublic,\n    FlagPtrToMemberRep = FlagSingleInheritance | FlagMultipleInheritance |\n                         FlagVirtualInheritance,\n    LLVM_MARK_AS_BITMASK_ENUM(FlagLargest)\n  };\n\n  static DIFlags getFlag(StringRef Flag);\n  static StringRef getFlagString(DIFlags Flag);\n\n  /// Split up a flags bitfield.\n  ///\n  /// Split \\c Flags into \\c SplitFlags, a vector of its components.  Returns\n  /// any remaining (unrecognized) bits.\n  static DIFlags splitFlags(DIFlags Flags,\n                            SmallVectorImpl<DIFlags> &SplitFlags);\n\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n    case GenericDINodeKind:\n    case DISubrangeKind:\n    case DIEnumeratorKind:\n    case DIBasicTypeKind:\n    case DIStringTypeKind:\n    case DIDerivedTypeKind:\n    case DICompositeTypeKind:\n    case DISubroutineTypeKind:\n    case DIFileKind:\n    case DICompileUnitKind:\n    case DISubprogramKind:\n    case DILexicalBlockKind:\n    case DILexicalBlockFileKind:\n    case DINamespaceKind:\n    case DICommonBlockKind:\n    case DITemplateTypeParameterKind:\n    case DITemplateValueParameterKind:\n    case DIGlobalVariableKind:\n    case DILocalVariableKind:\n    case DILabelKind:\n    case DIObjCPropertyKind:\n    case DIImportedEntityKind:\n    case DIModuleKind:\n    case DIGenericSubrangeKind:\n      return true;\n    }\n  }\n};\n\n/// Generic tagged DWARF-like metadata node.\n///\n/// An un-specialized DWARF-like metadata node.  The first operand is a\n/// (possibly empty) null-separated \\a MDString header that contains arbitrary\n/// fields.  The remaining operands are \\a dwarf_operands(), and are pointers\n/// to other metadata.\nclass GenericDINode : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  GenericDINode(LLVMContext &C, StorageType Storage, unsigned Hash,\n                unsigned Tag, ArrayRef<Metadata *> Ops1,\n                ArrayRef<Metadata *> Ops2)\n      : DINode(C, GenericDINodeKind, Storage, Tag, Ops1, Ops2) {\n    setHash(Hash);\n  }\n  ~GenericDINode() { dropAllReferences(); }\n\n  void setHash(unsigned Hash) { SubclassData32 = Hash; }\n  void recalculateHash();\n\n  static GenericDINode *getImpl(LLVMContext &Context, unsigned Tag,\n                                StringRef Header, ArrayRef<Metadata *> DwarfOps,\n                                StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Header),\n                   DwarfOps, Storage, ShouldCreate);\n  }\n\n  static GenericDINode *getImpl(LLVMContext &Context, unsigned Tag,\n                                MDString *Header, ArrayRef<Metadata *> DwarfOps,\n                                StorageType Storage, bool ShouldCreate = true);\n\n  TempGenericDINode cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getHeader(),\n                        SmallVector<Metadata *, 4>(dwarf_operands()));\n  }\n\npublic:\n  unsigned getHash() const { return SubclassData32; }\n\n  DEFINE_MDNODE_GET(GenericDINode, (unsigned Tag, StringRef Header,\n                                    ArrayRef<Metadata *> DwarfOps),\n                    (Tag, Header, DwarfOps))\n  DEFINE_MDNODE_GET(GenericDINode, (unsigned Tag, MDString *Header,\n                                    ArrayRef<Metadata *> DwarfOps),\n                    (Tag, Header, DwarfOps))\n\n  /// Return a (temporary) clone of this.\n  TempGenericDINode clone() const { return cloneImpl(); }\n\n  unsigned getTag() const { return SubclassData16; }\n  StringRef getHeader() const { return getStringOperand(0); }\n  MDString *getRawHeader() const { return getOperandAs<MDString>(0); }\n\n  op_iterator dwarf_op_begin() const { return op_begin() + 1; }\n  op_iterator dwarf_op_end() const { return op_end(); }\n  op_range dwarf_operands() const {\n    return op_range(dwarf_op_begin(), dwarf_op_end());\n  }\n\n  unsigned getNumDwarfOperands() const { return getNumOperands() - 1; }\n  const MDOperand &getDwarfOperand(unsigned I) const {\n    return getOperand(I + 1);\n  }\n  void replaceDwarfOperandWith(unsigned I, Metadata *New) {\n    replaceOperandWith(I + 1, New);\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == GenericDINodeKind;\n  }\n};\n\n/// Array subrange.\n///\n/// TODO: Merge into node for DW_TAG_array_type, which should have a custom\n/// type.\nclass DISubrange : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DISubrange(LLVMContext &C, StorageType Storage, ArrayRef<Metadata *> Ops)\n      : DINode(C, DISubrangeKind, Storage, dwarf::DW_TAG_subrange_type, Ops) {}\n\n  ~DISubrange() = default;\n\n  static DISubrange *getImpl(LLVMContext &Context, int64_t Count,\n                             int64_t LowerBound, StorageType Storage,\n                             bool ShouldCreate = true);\n\n  static DISubrange *getImpl(LLVMContext &Context, Metadata *CountNode,\n                             int64_t LowerBound, StorageType Storage,\n                             bool ShouldCreate = true);\n\n  static DISubrange *getImpl(LLVMContext &Context, Metadata *CountNode,\n                             Metadata *LowerBound, Metadata *UpperBound,\n                             Metadata *Stride, StorageType Storage,\n                             bool ShouldCreate = true);\n\n  TempDISubrange cloneImpl() const {\n    return getTemporary(getContext(), getRawCountNode(), getRawLowerBound(),\n                        getRawUpperBound(), getRawStride());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DISubrange, (int64_t Count, int64_t LowerBound = 0),\n                    (Count, LowerBound))\n\n  DEFINE_MDNODE_GET(DISubrange, (Metadata *CountNode, int64_t LowerBound = 0),\n                    (CountNode, LowerBound))\n\n  DEFINE_MDNODE_GET(DISubrange,\n                    (Metadata * CountNode, Metadata *LowerBound,\n                     Metadata *UpperBound, Metadata *Stride),\n                    (CountNode, LowerBound, UpperBound, Stride))\n\n  TempDISubrange clone() const { return cloneImpl(); }\n\n  Metadata *getRawCountNode() const {\n    return getOperand(0).get();\n  }\n\n  Metadata *getRawLowerBound() const { return getOperand(1).get(); }\n\n  Metadata *getRawUpperBound() const { return getOperand(2).get(); }\n\n  Metadata *getRawStride() const { return getOperand(3).get(); }\n\n  typedef PointerUnion<ConstantInt*, DIVariable*> CountType;\n  typedef PointerUnion<ConstantInt *, DIVariable *, DIExpression *> BoundType;\n\n  CountType getCount() const;\n\n  BoundType getLowerBound() const;\n\n  BoundType getUpperBound() const;\n\n  BoundType getStride() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DISubrangeKind;\n  }\n};\n\nclass DIGenericSubrange : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DIGenericSubrange(LLVMContext &C, StorageType Storage,\n                    ArrayRef<Metadata *> Ops)\n      : DINode(C, DIGenericSubrangeKind, Storage,\n               dwarf::DW_TAG_generic_subrange, Ops) {}\n\n  ~DIGenericSubrange() = default;\n\n  static DIGenericSubrange *getImpl(LLVMContext &Context, Metadata *CountNode,\n                                    Metadata *LowerBound, Metadata *UpperBound,\n                                    Metadata *Stride, StorageType Storage,\n                                    bool ShouldCreate = true);\n\n  TempDIGenericSubrange cloneImpl() const {\n    return getTemporary(getContext(), getRawCountNode(), getRawLowerBound(),\n                        getRawUpperBound(), getRawStride());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIGenericSubrange,\n                    (Metadata * CountNode, Metadata *LowerBound,\n                     Metadata *UpperBound, Metadata *Stride),\n                    (CountNode, LowerBound, UpperBound, Stride))\n\n  TempDIGenericSubrange clone() const { return cloneImpl(); }\n\n  Metadata *getRawCountNode() const { return getOperand(0).get(); }\n  Metadata *getRawLowerBound() const { return getOperand(1).get(); }\n  Metadata *getRawUpperBound() const { return getOperand(2).get(); }\n  Metadata *getRawStride() const { return getOperand(3).get(); }\n\n  using BoundType = PointerUnion<DIVariable *, DIExpression *>;\n\n  BoundType getCount() const;\n  BoundType getLowerBound() const;\n  BoundType getUpperBound() const;\n  BoundType getStride() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIGenericSubrangeKind;\n  }\n};\n\n/// Enumeration value.\n///\n/// TODO: Add a pointer to the context (DW_TAG_enumeration_type) once that no\n/// longer creates a type cycle.\nclass DIEnumerator : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  APInt Value;\n  DIEnumerator(LLVMContext &C, StorageType Storage, const APInt &Value,\n               bool IsUnsigned, ArrayRef<Metadata *> Ops)\n      : DINode(C, DIEnumeratorKind, Storage, dwarf::DW_TAG_enumerator, Ops),\n        Value(Value) {\n    SubclassData32 = IsUnsigned;\n  }\n  DIEnumerator(LLVMContext &C, StorageType Storage, int64_t Value,\n               bool IsUnsigned, ArrayRef<Metadata *> Ops)\n      : DIEnumerator(C, Storage, APInt(64, Value, !IsUnsigned), IsUnsigned,\n                     Ops) {}\n  ~DIEnumerator() = default;\n\n  static DIEnumerator *getImpl(LLVMContext &Context, const APInt &Value,\n                               bool IsUnsigned, StringRef Name,\n                               StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Value, IsUnsigned,\n                   getCanonicalMDString(Context, Name), Storage, ShouldCreate);\n  }\n  static DIEnumerator *getImpl(LLVMContext &Context, const APInt &Value,\n                               bool IsUnsigned, MDString *Name,\n                               StorageType Storage, bool ShouldCreate = true);\n\n  TempDIEnumerator cloneImpl() const {\n    return getTemporary(getContext(), getValue(), isUnsigned(), getName());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIEnumerator,\n                    (int64_t Value, bool IsUnsigned, StringRef Name),\n                    (APInt(64, Value, !IsUnsigned), IsUnsigned, Name))\n  DEFINE_MDNODE_GET(DIEnumerator,\n                    (int64_t Value, bool IsUnsigned, MDString *Name),\n                    (APInt(64, Value, !IsUnsigned), IsUnsigned, Name))\n  DEFINE_MDNODE_GET(DIEnumerator,\n                    (APInt Value, bool IsUnsigned, StringRef Name),\n                    (Value, IsUnsigned, Name))\n  DEFINE_MDNODE_GET(DIEnumerator,\n                    (APInt Value, bool IsUnsigned, MDString *Name),\n                    (Value, IsUnsigned, Name))\n\n  TempDIEnumerator clone() const { return cloneImpl(); }\n\n  const APInt &getValue() const { return Value; }\n  bool isUnsigned() const { return SubclassData32; }\n  StringRef getName() const { return getStringOperand(0); }\n\n  MDString *getRawName() const { return getOperandAs<MDString>(0); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIEnumeratorKind;\n  }\n};\n\n/// Base class for scope-like contexts.\n///\n/// Base class for lexical scopes and types (which are also declaration\n/// contexts).\n///\n/// TODO: Separate the concepts of declaration contexts and lexical scopes.\nclass DIScope : public DINode {\nprotected:\n  DIScope(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,\n          ArrayRef<Metadata *> Ops)\n      : DINode(C, ID, Storage, Tag, Ops) {}\n  ~DIScope() = default;\n\npublic:\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n\n  inline StringRef getFilename() const;\n  inline StringRef getDirectory() const;\n  inline Optional<StringRef> getSource() const;\n\n  StringRef getName() const;\n  DIScope *getScope() const;\n\n  /// Return the raw underlying file.\n  ///\n  /// A \\a DIFile is a \\a DIScope, but it doesn't point at a separate file (it\n  /// \\em is the file).  If \\c this is an \\a DIFile, we need to return \\c this.\n  /// Otherwise, return the first operand, which is where all other subclasses\n  /// store their file pointer.\n  Metadata *getRawFile() const {\n    return isa<DIFile>(this) ? const_cast<DIScope *>(this)\n                             : static_cast<Metadata *>(getOperand(0));\n  }\n\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n    case DIBasicTypeKind:\n    case DIStringTypeKind:\n    case DIDerivedTypeKind:\n    case DICompositeTypeKind:\n    case DISubroutineTypeKind:\n    case DIFileKind:\n    case DICompileUnitKind:\n    case DISubprogramKind:\n    case DILexicalBlockKind:\n    case DILexicalBlockFileKind:\n    case DINamespaceKind:\n    case DICommonBlockKind:\n    case DIModuleKind:\n      return true;\n    }\n  }\n};\n\n/// File.\n///\n/// TODO: Merge with directory/file node (including users).\n/// TODO: Canonicalize paths on creation.\nclass DIFile : public DIScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\npublic:\n  /// Which algorithm (e.g. MD5) a checksum was generated with.\n  ///\n  /// The encoding is explicit because it is used directly in Bitcode. The\n  /// value 0 is reserved to indicate the absence of a checksum in Bitcode.\n  enum ChecksumKind {\n    // The first variant was originally CSK_None, encoded as 0. The new\n    // internal representation removes the need for this by wrapping the\n    // ChecksumInfo in an Optional, but to preserve Bitcode compatibility the 0\n    // encoding is reserved.\n    CSK_MD5 = 1,\n    CSK_SHA1 = 2,\n    CSK_SHA256 = 3,\n    CSK_Last = CSK_SHA256 // Should be last enumeration.\n  };\n\n  /// A single checksum, represented by a \\a Kind and a \\a Value (a string).\n  template <typename T>\n  struct ChecksumInfo {\n    /// The kind of checksum which \\a Value encodes.\n    ChecksumKind Kind;\n    /// The string value of the checksum.\n    T Value;\n\n    ChecksumInfo(ChecksumKind Kind, T Value) : Kind(Kind), Value(Value) { }\n    ~ChecksumInfo() = default;\n    bool operator==(const ChecksumInfo<T> &X) const {\n      return Kind == X.Kind && Value == X.Value;\n    }\n    bool operator!=(const ChecksumInfo<T> &X) const { return !(*this == X); }\n    StringRef getKindAsString() const { return getChecksumKindAsString(Kind); }\n  };\n\nprivate:\n  Optional<ChecksumInfo<MDString *>> Checksum;\n  Optional<MDString *> Source;\n\n  DIFile(LLVMContext &C, StorageType Storage,\n         Optional<ChecksumInfo<MDString *>> CS, Optional<MDString *> Src,\n         ArrayRef<Metadata *> Ops)\n      : DIScope(C, DIFileKind, Storage, dwarf::DW_TAG_file_type, Ops),\n        Checksum(CS), Source(Src) {}\n  ~DIFile() = default;\n\n  static DIFile *getImpl(LLVMContext &Context, StringRef Filename,\n                         StringRef Directory,\n                         Optional<ChecksumInfo<StringRef>> CS,\n                         Optional<StringRef> Source,\n                         StorageType Storage, bool ShouldCreate = true) {\n    Optional<ChecksumInfo<MDString *>> MDChecksum;\n    if (CS)\n      MDChecksum.emplace(CS->Kind, getCanonicalMDString(Context, CS->Value));\n    return getImpl(Context, getCanonicalMDString(Context, Filename),\n                   getCanonicalMDString(Context, Directory), MDChecksum,\n                   Source ? Optional<MDString *>(getCanonicalMDString(Context, *Source)) : None,\n                   Storage, ShouldCreate);\n  }\n  static DIFile *getImpl(LLVMContext &Context, MDString *Filename,\n                         MDString *Directory,\n                         Optional<ChecksumInfo<MDString *>> CS,\n                         Optional<MDString *> Source, StorageType Storage,\n                         bool ShouldCreate = true);\n\n  TempDIFile cloneImpl() const {\n    return getTemporary(getContext(), getFilename(), getDirectory(),\n                        getChecksum(), getSource());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIFile, (StringRef Filename, StringRef Directory,\n                             Optional<ChecksumInfo<StringRef>> CS = None,\n                             Optional<StringRef> Source = None),\n                    (Filename, Directory, CS, Source))\n  DEFINE_MDNODE_GET(DIFile, (MDString * Filename, MDString *Directory,\n                             Optional<ChecksumInfo<MDString *>> CS = None,\n                             Optional<MDString *> Source = None),\n                    (Filename, Directory, CS, Source))\n\n  TempDIFile clone() const { return cloneImpl(); }\n\n  StringRef getFilename() const { return getStringOperand(0); }\n  StringRef getDirectory() const { return getStringOperand(1); }\n  Optional<ChecksumInfo<StringRef>> getChecksum() const {\n    Optional<ChecksumInfo<StringRef>> StringRefChecksum;\n    if (Checksum)\n      StringRefChecksum.emplace(Checksum->Kind, Checksum->Value->getString());\n    return StringRefChecksum;\n  }\n  Optional<StringRef> getSource() const {\n    return Source ? Optional<StringRef>((*Source)->getString()) : None;\n  }\n\n  MDString *getRawFilename() const { return getOperandAs<MDString>(0); }\n  MDString *getRawDirectory() const { return getOperandAs<MDString>(1); }\n  Optional<ChecksumInfo<MDString *>> getRawChecksum() const { return Checksum; }\n  Optional<MDString *> getRawSource() const { return Source; }\n\n  static StringRef getChecksumKindAsString(ChecksumKind CSKind);\n  static Optional<ChecksumKind> getChecksumKind(StringRef CSKindStr);\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIFileKind;\n  }\n};\n\nStringRef DIScope::getFilename() const {\n  if (auto *F = getFile())\n    return F->getFilename();\n  return \"\";\n}\n\nStringRef DIScope::getDirectory() const {\n  if (auto *F = getFile())\n    return F->getDirectory();\n  return \"\";\n}\n\nOptional<StringRef> DIScope::getSource() const {\n  if (auto *F = getFile())\n    return F->getSource();\n  return None;\n}\n\n/// Base class for types.\n///\n/// TODO: Remove the hardcoded name and context, since many types don't use\n/// them.\n/// TODO: Split up flags.\nclass DIType : public DIScope {\n  unsigned Line;\n  DIFlags Flags;\n  uint64_t SizeInBits;\n  uint64_t OffsetInBits;\n  uint32_t AlignInBits;\n\nprotected:\n  DIType(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,\n         unsigned Line, uint64_t SizeInBits, uint32_t AlignInBits,\n         uint64_t OffsetInBits, DIFlags Flags, ArrayRef<Metadata *> Ops)\n      : DIScope(C, ID, Storage, Tag, Ops) {\n    init(Line, SizeInBits, AlignInBits, OffsetInBits, Flags);\n  }\n  ~DIType() = default;\n\n  void init(unsigned Line, uint64_t SizeInBits, uint32_t AlignInBits,\n            uint64_t OffsetInBits, DIFlags Flags) {\n    this->Line = Line;\n    this->Flags = Flags;\n    this->SizeInBits = SizeInBits;\n    this->AlignInBits = AlignInBits;\n    this->OffsetInBits = OffsetInBits;\n  }\n\n  /// Change fields in place.\n  void mutate(unsigned Tag, unsigned Line, uint64_t SizeInBits,\n              uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags) {\n    assert(isDistinct() && \"Only distinct nodes can mutate\");\n    setTag(Tag);\n    init(Line, SizeInBits, AlignInBits, OffsetInBits, Flags);\n  }\n\npublic:\n  TempDIType clone() const {\n    return TempDIType(cast<DIType>(MDNode::clone().release()));\n  }\n\n  unsigned getLine() const { return Line; }\n  uint64_t getSizeInBits() const { return SizeInBits; }\n  uint32_t getAlignInBits() const { return AlignInBits; }\n  uint32_t getAlignInBytes() const { return getAlignInBits() / CHAR_BIT; }\n  uint64_t getOffsetInBits() const { return OffsetInBits; }\n  DIFlags getFlags() const { return Flags; }\n\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  StringRef getName() const { return getStringOperand(2); }\n\n\n  Metadata *getRawScope() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n\n  /// Returns a new temporary DIType with updated Flags\n  TempDIType cloneWithFlags(DIFlags NewFlags) const {\n    auto NewTy = clone();\n    NewTy->Flags = NewFlags;\n    return NewTy;\n  }\n\n  bool isPrivate() const {\n    return (getFlags() & FlagAccessibility) == FlagPrivate;\n  }\n  bool isProtected() const {\n    return (getFlags() & FlagAccessibility) == FlagProtected;\n  }\n  bool isPublic() const {\n    return (getFlags() & FlagAccessibility) == FlagPublic;\n  }\n  bool isForwardDecl() const { return getFlags() & FlagFwdDecl; }\n  bool isAppleBlockExtension() const { return getFlags() & FlagAppleBlock; }\n  bool isVirtual() const { return getFlags() & FlagVirtual; }\n  bool isArtificial() const { return getFlags() & FlagArtificial; }\n  bool isObjectPointer() const { return getFlags() & FlagObjectPointer; }\n  bool isObjcClassComplete() const {\n    return getFlags() & FlagObjcClassComplete;\n  }\n  bool isVector() const { return getFlags() & FlagVector; }\n  bool isBitField() const { return getFlags() & FlagBitField; }\n  bool isStaticMember() const { return getFlags() & FlagStaticMember; }\n  bool isLValueReference() const { return getFlags() & FlagLValueReference; }\n  bool isRValueReference() const { return getFlags() & FlagRValueReference; }\n  bool isTypePassByValue() const { return getFlags() & FlagTypePassByValue; }\n  bool isTypePassByReference() const {\n    return getFlags() & FlagTypePassByReference;\n  }\n  bool isBigEndian() const { return getFlags() & FlagBigEndian; }\n  bool isLittleEndian() const { return getFlags() & FlagLittleEndian; }\n  bool getExportSymbols() const { return getFlags() & FlagExportSymbols; }\n\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n    case DIBasicTypeKind:\n    case DIStringTypeKind:\n    case DIDerivedTypeKind:\n    case DICompositeTypeKind:\n    case DISubroutineTypeKind:\n      return true;\n    }\n  }\n};\n\n/// Basic type, like 'int' or 'float'.\n///\n/// TODO: Split out DW_TAG_unspecified_type.\n/// TODO: Drop unused accessors.\nclass DIBasicType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Encoding;\n\n  DIBasicType(LLVMContext &C, StorageType Storage, unsigned Tag,\n              uint64_t SizeInBits, uint32_t AlignInBits, unsigned Encoding,\n              DIFlags Flags, ArrayRef<Metadata *> Ops)\n      : DIType(C, DIBasicTypeKind, Storage, Tag, 0, SizeInBits, AlignInBits, 0,\n               Flags, Ops),\n        Encoding(Encoding) {}\n  ~DIBasicType() = default;\n\n  static DIBasicType *getImpl(LLVMContext &Context, unsigned Tag,\n                              StringRef Name, uint64_t SizeInBits,\n                              uint32_t AlignInBits, unsigned Encoding,\n                              DIFlags Flags, StorageType Storage,\n                              bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Name),\n                   SizeInBits, AlignInBits, Encoding, Flags, Storage,\n                   ShouldCreate);\n  }\n  static DIBasicType *getImpl(LLVMContext &Context, unsigned Tag,\n                              MDString *Name, uint64_t SizeInBits,\n                              uint32_t AlignInBits, unsigned Encoding,\n                              DIFlags Flags, StorageType Storage,\n                              bool ShouldCreate = true);\n\n  TempDIBasicType cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getName(), getSizeInBits(),\n                        getAlignInBits(), getEncoding(), getFlags());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIBasicType, (unsigned Tag, StringRef Name),\n                    (Tag, Name, 0, 0, 0, FlagZero))\n  DEFINE_MDNODE_GET(DIBasicType,\n                    (unsigned Tag, StringRef Name, uint64_t SizeInBits),\n                    (Tag, Name, SizeInBits, 0, 0, FlagZero))\n  DEFINE_MDNODE_GET(DIBasicType,\n                    (unsigned Tag, MDString *Name, uint64_t SizeInBits),\n                    (Tag, Name, SizeInBits, 0, 0, FlagZero))\n  DEFINE_MDNODE_GET(DIBasicType,\n                    (unsigned Tag, StringRef Name, uint64_t SizeInBits,\n                     uint32_t AlignInBits, unsigned Encoding, DIFlags Flags),\n                    (Tag, Name, SizeInBits, AlignInBits, Encoding, Flags))\n  DEFINE_MDNODE_GET(DIBasicType,\n                    (unsigned Tag, MDString *Name, uint64_t SizeInBits,\n                     uint32_t AlignInBits, unsigned Encoding, DIFlags Flags),\n                    (Tag, Name, SizeInBits, AlignInBits, Encoding, Flags))\n\n  TempDIBasicType clone() const { return cloneImpl(); }\n\n  unsigned getEncoding() const { return Encoding; }\n\n  enum class Signedness { Signed, Unsigned };\n\n  /// Return the signedness of this type, or None if this type is neither\n  /// signed nor unsigned.\n  Optional<Signedness> getSignedness() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIBasicTypeKind;\n  }\n};\n\n/// String type, Fortran CHARACTER(n)\nclass DIStringType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Encoding;\n\n  DIStringType(LLVMContext &C, StorageType Storage, unsigned Tag,\n               uint64_t SizeInBits, uint32_t AlignInBits, unsigned Encoding,\n               ArrayRef<Metadata *> Ops)\n      : DIType(C, DIStringTypeKind, Storage, Tag, 0, SizeInBits, AlignInBits, 0,\n               FlagZero, Ops),\n        Encoding(Encoding) {}\n  ~DIStringType() = default;\n\n  static DIStringType *getImpl(LLVMContext &Context, unsigned Tag,\n                               StringRef Name, Metadata *StringLength,\n                               Metadata *StrLenExp, uint64_t SizeInBits,\n                               uint32_t AlignInBits, unsigned Encoding,\n                               StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Name),\n                   StringLength, StrLenExp, SizeInBits, AlignInBits, Encoding,\n                   Storage, ShouldCreate);\n  }\n  static DIStringType *getImpl(LLVMContext &Context, unsigned Tag,\n                               MDString *Name, Metadata *StringLength,\n                               Metadata *StrLenExp, uint64_t SizeInBits,\n                               uint32_t AlignInBits, unsigned Encoding,\n                               StorageType Storage, bool ShouldCreate = true);\n\n  TempDIStringType cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getRawName(),\n                        getRawStringLength(), getRawStringLengthExp(),\n                        getSizeInBits(), getAlignInBits(), getEncoding());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIStringType,\n                    (unsigned Tag, StringRef Name, uint64_t SizeInBits,\n                     uint32_t AlignInBits),\n                    (Tag, Name, nullptr, nullptr, SizeInBits, AlignInBits, 0))\n  DEFINE_MDNODE_GET(DIStringType,\n                    (unsigned Tag, MDString *Name, Metadata *StringLength,\n                     Metadata *StringLengthExp, uint64_t SizeInBits,\n                     uint32_t AlignInBits, unsigned Encoding),\n                    (Tag, Name, StringLength, StringLengthExp, SizeInBits,\n                     AlignInBits, Encoding))\n  DEFINE_MDNODE_GET(DIStringType,\n                    (unsigned Tag, StringRef Name, Metadata *StringLength,\n                     Metadata *StringLengthExp, uint64_t SizeInBits,\n                     uint32_t AlignInBits, unsigned Encoding),\n                    (Tag, Name, StringLength, StringLengthExp, SizeInBits,\n                     AlignInBits, Encoding))\n\n  TempDIStringType clone() const { return cloneImpl(); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIStringTypeKind;\n  }\n\n  DIVariable *getStringLength() const {\n    return cast_or_null<DIVariable>(getRawStringLength());\n  }\n\n  DIExpression *getStringLengthExp() const {\n    return cast_or_null<DIExpression>(getRawStringLengthExp());\n  }\n\n  unsigned getEncoding() const { return Encoding; }\n\n  Metadata *getRawStringLength() const { return getOperand(3); }\n\n  Metadata *getRawStringLengthExp() const { return getOperand(4); }\n};\n\n/// Derived types.\n///\n/// This includes qualified types, pointers, references, friends, typedefs, and\n/// class members.\n///\n/// TODO: Split out members (inheritance, fields, methods, etc.).\nclass DIDerivedType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  /// The DWARF address space of the memory pointed to or referenced by a\n  /// pointer or reference type respectively.\n  Optional<unsigned> DWARFAddressSpace;\n\n  DIDerivedType(LLVMContext &C, StorageType Storage, unsigned Tag,\n                unsigned Line, uint64_t SizeInBits, uint32_t AlignInBits,\n                uint64_t OffsetInBits, Optional<unsigned> DWARFAddressSpace,\n                DIFlags Flags, ArrayRef<Metadata *> Ops)\n      : DIType(C, DIDerivedTypeKind, Storage, Tag, Line, SizeInBits,\n               AlignInBits, OffsetInBits, Flags, Ops),\n        DWARFAddressSpace(DWARFAddressSpace) {}\n  ~DIDerivedType() = default;\n\n  static DIDerivedType *\n  getImpl(LLVMContext &Context, unsigned Tag, StringRef Name, DIFile *File,\n          unsigned Line, DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,\n          uint32_t AlignInBits, uint64_t OffsetInBits,\n          Optional<unsigned> DWARFAddressSpace, DIFlags Flags,\n          Metadata *ExtraData, StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Name), File,\n                   Line, Scope, BaseType, SizeInBits, AlignInBits, OffsetInBits,\n                   DWARFAddressSpace, Flags, ExtraData, Storage, ShouldCreate);\n  }\n  static DIDerivedType *getImpl(LLVMContext &Context, unsigned Tag,\n                                MDString *Name, Metadata *File, unsigned Line,\n                                Metadata *Scope, Metadata *BaseType,\n                                uint64_t SizeInBits, uint32_t AlignInBits,\n                                uint64_t OffsetInBits,\n                                Optional<unsigned> DWARFAddressSpace,\n                                DIFlags Flags, Metadata *ExtraData,\n                                StorageType Storage, bool ShouldCreate = true);\n\n  TempDIDerivedType cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getName(), getFile(), getLine(),\n                        getScope(), getBaseType(), getSizeInBits(),\n                        getAlignInBits(), getOffsetInBits(),\n                        getDWARFAddressSpace(), getFlags(), getExtraData());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIDerivedType,\n                    (unsigned Tag, MDString *Name, Metadata *File,\n                     unsigned Line, Metadata *Scope, Metadata *BaseType,\n                     uint64_t SizeInBits, uint32_t AlignInBits,\n                     uint64_t OffsetInBits,\n                     Optional<unsigned> DWARFAddressSpace, DIFlags Flags,\n                     Metadata *ExtraData = nullptr),\n                    (Tag, Name, File, Line, Scope, BaseType, SizeInBits,\n                     AlignInBits, OffsetInBits, DWARFAddressSpace, Flags,\n                     ExtraData))\n  DEFINE_MDNODE_GET(DIDerivedType,\n                    (unsigned Tag, StringRef Name, DIFile *File, unsigned Line,\n                     DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,\n                     uint32_t AlignInBits, uint64_t OffsetInBits,\n                     Optional<unsigned> DWARFAddressSpace, DIFlags Flags,\n                     Metadata *ExtraData = nullptr),\n                    (Tag, Name, File, Line, Scope, BaseType, SizeInBits,\n                     AlignInBits, OffsetInBits, DWARFAddressSpace, Flags,\n                     ExtraData))\n\n  TempDIDerivedType clone() const { return cloneImpl(); }\n\n  /// Get the base type this is derived from.\n  DIType *getBaseType() const { return cast_or_null<DIType>(getRawBaseType()); }\n  Metadata *getRawBaseType() const { return getOperand(3); }\n\n  /// \\returns The DWARF address space of the memory pointed to or referenced by\n  /// a pointer or reference type respectively.\n  Optional<unsigned> getDWARFAddressSpace() const { return DWARFAddressSpace; }\n\n  /// Get extra data associated with this derived type.\n  ///\n  /// Class type for pointer-to-members, objective-c property node for ivars,\n  /// global constant wrapper for static members, or virtual base pointer offset\n  /// for inheritance.\n  ///\n  /// TODO: Separate out types that need this extra operand: pointer-to-member\n  /// types and member fields (static members and ivars).\n  Metadata *getExtraData() const { return getRawExtraData(); }\n  Metadata *getRawExtraData() const { return getOperand(4); }\n\n  /// Get casted version of extra data.\n  /// @{\n  DIType *getClassType() const {\n    assert(getTag() == dwarf::DW_TAG_ptr_to_member_type);\n    return cast_or_null<DIType>(getExtraData());\n  }\n\n  DIObjCProperty *getObjCProperty() const {\n    return dyn_cast_or_null<DIObjCProperty>(getExtraData());\n  }\n\n  uint32_t getVBPtrOffset() const {\n    assert(getTag() == dwarf::DW_TAG_inheritance);\n    if (auto *CM = cast_or_null<ConstantAsMetadata>(getExtraData()))\n      if (auto *CI = dyn_cast_or_null<ConstantInt>(CM->getValue()))\n        return static_cast<uint32_t>(CI->getZExtValue());\n    return 0;\n  }\n\n  Constant *getStorageOffsetInBits() const {\n    assert(getTag() == dwarf::DW_TAG_member && isBitField());\n    if (auto *C = cast_or_null<ConstantAsMetadata>(getExtraData()))\n      return C->getValue();\n    return nullptr;\n  }\n\n  Constant *getConstant() const {\n    assert(getTag() == dwarf::DW_TAG_member && isStaticMember());\n    if (auto *C = cast_or_null<ConstantAsMetadata>(getExtraData()))\n      return C->getValue();\n    return nullptr;\n  }\n  Constant *getDiscriminantValue() const {\n    assert(getTag() == dwarf::DW_TAG_member && !isStaticMember());\n    if (auto *C = cast_or_null<ConstantAsMetadata>(getExtraData()))\n      return C->getValue();\n    return nullptr;\n  }\n  /// @}\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIDerivedTypeKind;\n  }\n};\n\n/// Composite types.\n///\n/// TODO: Detach from DerivedTypeBase (split out MDEnumType?).\n/// TODO: Create a custom, unrelated node for DW_TAG_array_type.\nclass DICompositeType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned RuntimeLang;\n\n  DICompositeType(LLVMContext &C, StorageType Storage, unsigned Tag,\n                  unsigned Line, unsigned RuntimeLang, uint64_t SizeInBits,\n                  uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,\n                  ArrayRef<Metadata *> Ops)\n      : DIType(C, DICompositeTypeKind, Storage, Tag, Line, SizeInBits,\n               AlignInBits, OffsetInBits, Flags, Ops),\n        RuntimeLang(RuntimeLang) {}\n  ~DICompositeType() = default;\n\n  /// Change fields in place.\n  void mutate(unsigned Tag, unsigned Line, unsigned RuntimeLang,\n              uint64_t SizeInBits, uint32_t AlignInBits,\n              uint64_t OffsetInBits, DIFlags Flags) {\n    assert(isDistinct() && \"Only distinct nodes can mutate\");\n    assert(getRawIdentifier() && \"Only ODR-uniqued nodes should mutate\");\n    this->RuntimeLang = RuntimeLang;\n    DIType::mutate(Tag, Line, SizeInBits, AlignInBits, OffsetInBits, Flags);\n  }\n\n  static DICompositeType *\n  getImpl(LLVMContext &Context, unsigned Tag, StringRef Name, Metadata *File,\n          unsigned Line, DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,\n          uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,\n          DINodeArray Elements, unsigned RuntimeLang, DIType *VTableHolder,\n          DITemplateParameterArray TemplateParams, StringRef Identifier,\n          DIDerivedType *Discriminator, Metadata *DataLocation,\n          Metadata *Associated, Metadata *Allocated, Metadata *Rank,\n          StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(\n        Context, Tag, getCanonicalMDString(Context, Name), File, Line, Scope,\n        BaseType, SizeInBits, AlignInBits, OffsetInBits, Flags, Elements.get(),\n        RuntimeLang, VTableHolder, TemplateParams.get(),\n        getCanonicalMDString(Context, Identifier), Discriminator, DataLocation,\n        Associated, Allocated, Rank, Storage, ShouldCreate);\n  }\n  static DICompositeType *\n  getImpl(LLVMContext &Context, unsigned Tag, MDString *Name, Metadata *File,\n          unsigned Line, Metadata *Scope, Metadata *BaseType,\n          uint64_t SizeInBits, uint32_t AlignInBits, uint64_t OffsetInBits,\n          DIFlags Flags, Metadata *Elements, unsigned RuntimeLang,\n          Metadata *VTableHolder, Metadata *TemplateParams,\n          MDString *Identifier, Metadata *Discriminator, Metadata *DataLocation,\n          Metadata *Associated, Metadata *Allocated, Metadata *Rank,\n          StorageType Storage, bool ShouldCreate = true);\n\n  TempDICompositeType cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getName(), getFile(), getLine(),\n                        getScope(), getBaseType(), getSizeInBits(),\n                        getAlignInBits(), getOffsetInBits(), getFlags(),\n                        getElements(), getRuntimeLang(), getVTableHolder(),\n                        getTemplateParams(), getIdentifier(),\n                        getDiscriminator(), getRawDataLocation(),\n                        getRawAssociated(), getRawAllocated(), getRawRank());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(\n      DICompositeType,\n      (unsigned Tag, StringRef Name, DIFile *File, unsigned Line,\n       DIScope *Scope, DIType *BaseType, uint64_t SizeInBits,\n       uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,\n       DINodeArray Elements, unsigned RuntimeLang, DIType *VTableHolder,\n       DITemplateParameterArray TemplateParams = nullptr,\n       StringRef Identifier = \"\", DIDerivedType *Discriminator = nullptr,\n       Metadata *DataLocation = nullptr, Metadata *Associated = nullptr,\n       Metadata *Allocated = nullptr, Metadata *Rank = nullptr),\n      (Tag, Name, File, Line, Scope, BaseType, SizeInBits, AlignInBits,\n       OffsetInBits, Flags, Elements, RuntimeLang, VTableHolder, TemplateParams,\n       Identifier, Discriminator, DataLocation, Associated, Allocated, Rank))\n  DEFINE_MDNODE_GET(\n      DICompositeType,\n      (unsigned Tag, MDString *Name, Metadata *File, unsigned Line,\n       Metadata *Scope, Metadata *BaseType, uint64_t SizeInBits,\n       uint32_t AlignInBits, uint64_t OffsetInBits, DIFlags Flags,\n       Metadata *Elements, unsigned RuntimeLang, Metadata *VTableHolder,\n       Metadata *TemplateParams = nullptr, MDString *Identifier = nullptr,\n       Metadata *Discriminator = nullptr, Metadata *DataLocation = nullptr,\n       Metadata *Associated = nullptr, Metadata *Allocated = nullptr,\n       Metadata *Rank = nullptr),\n      (Tag, Name, File, Line, Scope, BaseType, SizeInBits, AlignInBits,\n       OffsetInBits, Flags, Elements, RuntimeLang, VTableHolder, TemplateParams,\n       Identifier, Discriminator, DataLocation, Associated, Allocated, Rank))\n\n  TempDICompositeType clone() const { return cloneImpl(); }\n\n  /// Get a DICompositeType with the given ODR identifier.\n  ///\n  /// If \\a LLVMContext::isODRUniquingDebugTypes(), gets the mapped\n  /// DICompositeType for the given ODR \\c Identifier.  If none exists, creates\n  /// a new node.\n  ///\n  /// Else, returns \\c nullptr.\n  static DICompositeType *\n  getODRType(LLVMContext &Context, MDString &Identifier, unsigned Tag,\n             MDString *Name, Metadata *File, unsigned Line, Metadata *Scope,\n             Metadata *BaseType, uint64_t SizeInBits, uint32_t AlignInBits,\n             uint64_t OffsetInBits, DIFlags Flags, Metadata *Elements,\n             unsigned RuntimeLang, Metadata *VTableHolder,\n             Metadata *TemplateParams, Metadata *Discriminator,\n             Metadata *DataLocation, Metadata *Associated, Metadata *Allocated,\n             Metadata *Rank);\n  static DICompositeType *getODRTypeIfExists(LLVMContext &Context,\n                                             MDString &Identifier);\n\n  /// Build a DICompositeType with the given ODR identifier.\n  ///\n  /// Looks up the mapped DICompositeType for the given ODR \\c Identifier.  If\n  /// it doesn't exist, creates a new one.  If it does exist and \\a\n  /// isForwardDecl(), and the new arguments would be a definition, mutates the\n  /// the type in place.  In either case, returns the type.\n  ///\n  /// If not \\a LLVMContext::isODRUniquingDebugTypes(), this function returns\n  /// nullptr.\n  static DICompositeType *\n  buildODRType(LLVMContext &Context, MDString &Identifier, unsigned Tag,\n               MDString *Name, Metadata *File, unsigned Line, Metadata *Scope,\n               Metadata *BaseType, uint64_t SizeInBits, uint32_t AlignInBits,\n               uint64_t OffsetInBits, DIFlags Flags, Metadata *Elements,\n               unsigned RuntimeLang, Metadata *VTableHolder,\n               Metadata *TemplateParams, Metadata *Discriminator,\n               Metadata *DataLocation, Metadata *Associated,\n               Metadata *Allocated, Metadata *Rank);\n\n  DIType *getBaseType() const { return cast_or_null<DIType>(getRawBaseType()); }\n  DINodeArray getElements() const {\n    return cast_or_null<MDTuple>(getRawElements());\n  }\n  DIType *getVTableHolder() const {\n    return cast_or_null<DIType>(getRawVTableHolder());\n  }\n  DITemplateParameterArray getTemplateParams() const {\n    return cast_or_null<MDTuple>(getRawTemplateParams());\n  }\n  StringRef getIdentifier() const { return getStringOperand(7); }\n  unsigned getRuntimeLang() const { return RuntimeLang; }\n\n  Metadata *getRawBaseType() const { return getOperand(3); }\n  Metadata *getRawElements() const { return getOperand(4); }\n  Metadata *getRawVTableHolder() const { return getOperand(5); }\n  Metadata *getRawTemplateParams() const { return getOperand(6); }\n  MDString *getRawIdentifier() const { return getOperandAs<MDString>(7); }\n  Metadata *getRawDiscriminator() const { return getOperand(8); }\n  DIDerivedType *getDiscriminator() const { return getOperandAs<DIDerivedType>(8); }\n  Metadata *getRawDataLocation() const { return getOperand(9); }\n  DIVariable *getDataLocation() const {\n    return dyn_cast_or_null<DIVariable>(getRawDataLocation());\n  }\n  DIExpression *getDataLocationExp() const {\n    return dyn_cast_or_null<DIExpression>(getRawDataLocation());\n  }\n  Metadata *getRawAssociated() const { return getOperand(10); }\n  DIVariable *getAssociated() const {\n    return dyn_cast_or_null<DIVariable>(getRawAssociated());\n  }\n  DIExpression *getAssociatedExp() const {\n    return dyn_cast_or_null<DIExpression>(getRawAssociated());\n  }\n  Metadata *getRawAllocated() const { return getOperand(11); }\n  DIVariable *getAllocated() const {\n    return dyn_cast_or_null<DIVariable>(getRawAllocated());\n  }\n  DIExpression *getAllocatedExp() const {\n    return dyn_cast_or_null<DIExpression>(getRawAllocated());\n  }\n  Metadata *getRawRank() const { return getOperand(12); }\n  ConstantInt *getRankConst() const {\n    if (auto *MD = dyn_cast_or_null<ConstantAsMetadata>(getRawRank()))\n      return dyn_cast_or_null<ConstantInt>(MD->getValue());\n    return nullptr;\n  }\n  DIExpression *getRankExp() const {\n    return dyn_cast_or_null<DIExpression>(getRawRank());\n  }\n\n  /// Replace operands.\n  ///\n  /// If this \\a isUniqued() and not \\a isResolved(), on a uniquing collision\n  /// this will be RAUW'ed and deleted.  Use a \\a TrackingMDRef to keep track\n  /// of its movement if necessary.\n  /// @{\n  void replaceElements(DINodeArray Elements) {\n#ifndef NDEBUG\n    for (DINode *Op : getElements())\n      assert(is_contained(Elements->operands(), Op) &&\n             \"Lost a member during member list replacement\");\n#endif\n    replaceOperandWith(4, Elements.get());\n  }\n\n  void replaceVTableHolder(DIType *VTableHolder) {\n    replaceOperandWith(5, VTableHolder);\n  }\n\n  void replaceTemplateParams(DITemplateParameterArray TemplateParams) {\n    replaceOperandWith(6, TemplateParams.get());\n  }\n  /// @}\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DICompositeTypeKind;\n  }\n};\n\n/// Type array for a subprogram.\n///\n/// TODO: Fold the array of types in directly as operands.\nclass DISubroutineType : public DIType {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  /// The calling convention used with DW_AT_calling_convention. Actually of\n  /// type dwarf::CallingConvention.\n  uint8_t CC;\n\n  DISubroutineType(LLVMContext &C, StorageType Storage, DIFlags Flags,\n                   uint8_t CC, ArrayRef<Metadata *> Ops)\n      : DIType(C, DISubroutineTypeKind, Storage, dwarf::DW_TAG_subroutine_type,\n               0, 0, 0, 0, Flags, Ops),\n        CC(CC) {}\n  ~DISubroutineType() = default;\n\n  static DISubroutineType *getImpl(LLVMContext &Context, DIFlags Flags,\n                                   uint8_t CC, DITypeRefArray TypeArray,\n                                   StorageType Storage,\n                                   bool ShouldCreate = true) {\n    return getImpl(Context, Flags, CC, TypeArray.get(), Storage, ShouldCreate);\n  }\n  static DISubroutineType *getImpl(LLVMContext &Context, DIFlags Flags,\n                                   uint8_t CC, Metadata *TypeArray,\n                                   StorageType Storage,\n                                   bool ShouldCreate = true);\n\n  TempDISubroutineType cloneImpl() const {\n    return getTemporary(getContext(), getFlags(), getCC(), getTypeArray());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DISubroutineType,\n                    (DIFlags Flags, uint8_t CC, DITypeRefArray TypeArray),\n                    (Flags, CC, TypeArray))\n  DEFINE_MDNODE_GET(DISubroutineType,\n                    (DIFlags Flags, uint8_t CC, Metadata *TypeArray),\n                    (Flags, CC, TypeArray))\n\n  TempDISubroutineType clone() const { return cloneImpl(); }\n\n  uint8_t getCC() const { return CC; }\n\n  DITypeRefArray getTypeArray() const {\n    return cast_or_null<MDTuple>(getRawTypeArray());\n  }\n\n  Metadata *getRawTypeArray() const { return getOperand(3); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DISubroutineTypeKind;\n  }\n};\n\n/// Compile unit.\nclass DICompileUnit : public DIScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\npublic:\n  enum DebugEmissionKind : unsigned {\n    NoDebug = 0,\n    FullDebug,\n    LineTablesOnly,\n    DebugDirectivesOnly,\n    LastEmissionKind = DebugDirectivesOnly\n  };\n\n  enum class DebugNameTableKind : unsigned {\n    Default = 0,\n    GNU = 1,\n    None = 2,\n    LastDebugNameTableKind = None\n  };\n\n  static Optional<DebugEmissionKind> getEmissionKind(StringRef Str);\n  static const char *emissionKindString(DebugEmissionKind EK);\n  static Optional<DebugNameTableKind> getNameTableKind(StringRef Str);\n  static const char *nameTableKindString(DebugNameTableKind PK);\n\nprivate:\n  unsigned SourceLanguage;\n  bool IsOptimized;\n  unsigned RuntimeVersion;\n  unsigned EmissionKind;\n  uint64_t DWOId;\n  bool SplitDebugInlining;\n  bool DebugInfoForProfiling;\n  unsigned NameTableKind;\n  bool RangesBaseAddress;\n\n  DICompileUnit(LLVMContext &C, StorageType Storage, unsigned SourceLanguage,\n                bool IsOptimized, unsigned RuntimeVersion,\n                unsigned EmissionKind, uint64_t DWOId, bool SplitDebugInlining,\n                bool DebugInfoForProfiling, unsigned NameTableKind,\n                bool RangesBaseAddress, ArrayRef<Metadata *> Ops)\n      : DIScope(C, DICompileUnitKind, Storage, dwarf::DW_TAG_compile_unit, Ops),\n        SourceLanguage(SourceLanguage), IsOptimized(IsOptimized),\n        RuntimeVersion(RuntimeVersion), EmissionKind(EmissionKind),\n        DWOId(DWOId), SplitDebugInlining(SplitDebugInlining),\n        DebugInfoForProfiling(DebugInfoForProfiling),\n        NameTableKind(NameTableKind), RangesBaseAddress(RangesBaseAddress) {\n    assert(Storage != Uniqued);\n  }\n  ~DICompileUnit() = default;\n\n  static DICompileUnit *\n  getImpl(LLVMContext &Context, unsigned SourceLanguage, DIFile *File,\n          StringRef Producer, bool IsOptimized, StringRef Flags,\n          unsigned RuntimeVersion, StringRef SplitDebugFilename,\n          unsigned EmissionKind, DICompositeTypeArray EnumTypes,\n          DIScopeArray RetainedTypes,\n          DIGlobalVariableExpressionArray GlobalVariables,\n          DIImportedEntityArray ImportedEntities, DIMacroNodeArray Macros,\n          uint64_t DWOId, bool SplitDebugInlining, bool DebugInfoForProfiling,\n          unsigned NameTableKind, bool RangesBaseAddress, StringRef SysRoot,\n          StringRef SDK, StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(\n        Context, SourceLanguage, File, getCanonicalMDString(Context, Producer),\n        IsOptimized, getCanonicalMDString(Context, Flags), RuntimeVersion,\n        getCanonicalMDString(Context, SplitDebugFilename), EmissionKind,\n        EnumTypes.get(), RetainedTypes.get(), GlobalVariables.get(),\n        ImportedEntities.get(), Macros.get(), DWOId, SplitDebugInlining,\n        DebugInfoForProfiling, NameTableKind, RangesBaseAddress,\n        getCanonicalMDString(Context, SysRoot),\n        getCanonicalMDString(Context, SDK), Storage, ShouldCreate);\n  }\n  static DICompileUnit *\n  getImpl(LLVMContext &Context, unsigned SourceLanguage, Metadata *File,\n          MDString *Producer, bool IsOptimized, MDString *Flags,\n          unsigned RuntimeVersion, MDString *SplitDebugFilename,\n          unsigned EmissionKind, Metadata *EnumTypes, Metadata *RetainedTypes,\n          Metadata *GlobalVariables, Metadata *ImportedEntities,\n          Metadata *Macros, uint64_t DWOId, bool SplitDebugInlining,\n          bool DebugInfoForProfiling, unsigned NameTableKind,\n          bool RangesBaseAddress, MDString *SysRoot, MDString *SDK,\n          StorageType Storage, bool ShouldCreate = true);\n\n  TempDICompileUnit cloneImpl() const {\n    return getTemporary(\n        getContext(), getSourceLanguage(), getFile(), getProducer(),\n        isOptimized(), getFlags(), getRuntimeVersion(), getSplitDebugFilename(),\n        getEmissionKind(), getEnumTypes(), getRetainedTypes(),\n        getGlobalVariables(), getImportedEntities(), getMacros(), DWOId,\n        getSplitDebugInlining(), getDebugInfoForProfiling(), getNameTableKind(),\n        getRangesBaseAddress(), getSysRoot(), getSDK());\n  }\n\npublic:\n  static void get() = delete;\n  static void getIfExists() = delete;\n\n  DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(\n      DICompileUnit,\n      (unsigned SourceLanguage, DIFile *File, StringRef Producer,\n       bool IsOptimized, StringRef Flags, unsigned RuntimeVersion,\n       StringRef SplitDebugFilename, DebugEmissionKind EmissionKind,\n       DICompositeTypeArray EnumTypes, DIScopeArray RetainedTypes,\n       DIGlobalVariableExpressionArray GlobalVariables,\n       DIImportedEntityArray ImportedEntities, DIMacroNodeArray Macros,\n       uint64_t DWOId, bool SplitDebugInlining, bool DebugInfoForProfiling,\n       DebugNameTableKind NameTableKind, bool RangesBaseAddress,\n       StringRef SysRoot, StringRef SDK),\n      (SourceLanguage, File, Producer, IsOptimized, Flags, RuntimeVersion,\n       SplitDebugFilename, EmissionKind, EnumTypes, RetainedTypes,\n       GlobalVariables, ImportedEntities, Macros, DWOId, SplitDebugInlining,\n       DebugInfoForProfiling, (unsigned)NameTableKind, RangesBaseAddress,\n       SysRoot, SDK))\n  DEFINE_MDNODE_GET_DISTINCT_TEMPORARY(\n      DICompileUnit,\n      (unsigned SourceLanguage, Metadata *File, MDString *Producer,\n       bool IsOptimized, MDString *Flags, unsigned RuntimeVersion,\n       MDString *SplitDebugFilename, unsigned EmissionKind, Metadata *EnumTypes,\n       Metadata *RetainedTypes, Metadata *GlobalVariables,\n       Metadata *ImportedEntities, Metadata *Macros, uint64_t DWOId,\n       bool SplitDebugInlining, bool DebugInfoForProfiling,\n       unsigned NameTableKind, bool RangesBaseAddress, MDString *SysRoot,\n       MDString *SDK),\n      (SourceLanguage, File, Producer, IsOptimized, Flags, RuntimeVersion,\n       SplitDebugFilename, EmissionKind, EnumTypes, RetainedTypes,\n       GlobalVariables, ImportedEntities, Macros, DWOId, SplitDebugInlining,\n       DebugInfoForProfiling, NameTableKind, RangesBaseAddress, SysRoot, SDK))\n\n  TempDICompileUnit clone() const { return cloneImpl(); }\n\n  unsigned getSourceLanguage() const { return SourceLanguage; }\n  bool isOptimized() const { return IsOptimized; }\n  unsigned getRuntimeVersion() const { return RuntimeVersion; }\n  DebugEmissionKind getEmissionKind() const {\n    return (DebugEmissionKind)EmissionKind;\n  }\n  bool isDebugDirectivesOnly() const {\n    return EmissionKind == DebugDirectivesOnly;\n  }\n  bool getDebugInfoForProfiling() const { return DebugInfoForProfiling; }\n  DebugNameTableKind getNameTableKind() const {\n    return (DebugNameTableKind)NameTableKind;\n  }\n  bool getRangesBaseAddress() const { return RangesBaseAddress; }\n  StringRef getProducer() const { return getStringOperand(1); }\n  StringRef getFlags() const { return getStringOperand(2); }\n  StringRef getSplitDebugFilename() const { return getStringOperand(3); }\n  DICompositeTypeArray getEnumTypes() const {\n    return cast_or_null<MDTuple>(getRawEnumTypes());\n  }\n  DIScopeArray getRetainedTypes() const {\n    return cast_or_null<MDTuple>(getRawRetainedTypes());\n  }\n  DIGlobalVariableExpressionArray getGlobalVariables() const {\n    return cast_or_null<MDTuple>(getRawGlobalVariables());\n  }\n  DIImportedEntityArray getImportedEntities() const {\n    return cast_or_null<MDTuple>(getRawImportedEntities());\n  }\n  DIMacroNodeArray getMacros() const {\n    return cast_or_null<MDTuple>(getRawMacros());\n  }\n  uint64_t getDWOId() const { return DWOId; }\n  void setDWOId(uint64_t DwoId) { DWOId = DwoId; }\n  bool getSplitDebugInlining() const { return SplitDebugInlining; }\n  void setSplitDebugInlining(bool SplitDebugInlining) {\n    this->SplitDebugInlining = SplitDebugInlining;\n  }\n  StringRef getSysRoot() const { return getStringOperand(9); }\n  StringRef getSDK() const { return getStringOperand(10); }\n\n  MDString *getRawProducer() const { return getOperandAs<MDString>(1); }\n  MDString *getRawFlags() const { return getOperandAs<MDString>(2); }\n  MDString *getRawSplitDebugFilename() const {\n    return getOperandAs<MDString>(3);\n  }\n  Metadata *getRawEnumTypes() const { return getOperand(4); }\n  Metadata *getRawRetainedTypes() const { return getOperand(5); }\n  Metadata *getRawGlobalVariables() const { return getOperand(6); }\n  Metadata *getRawImportedEntities() const { return getOperand(7); }\n  Metadata *getRawMacros() const { return getOperand(8); }\n  MDString *getRawSysRoot() const { return getOperandAs<MDString>(9); }\n  MDString *getRawSDK() const { return getOperandAs<MDString>(10); }\n\n  /// Replace arrays.\n  ///\n  /// If this \\a isUniqued() and not \\a isResolved(), it will be RAUW'ed and\n  /// deleted on a uniquing collision.  In practice, uniquing collisions on \\a\n  /// DICompileUnit should be fairly rare.\n  /// @{\n  void replaceEnumTypes(DICompositeTypeArray N) {\n    replaceOperandWith(4, N.get());\n  }\n  void replaceRetainedTypes(DITypeArray N) {\n    replaceOperandWith(5, N.get());\n  }\n  void replaceGlobalVariables(DIGlobalVariableExpressionArray N) {\n    replaceOperandWith(6, N.get());\n  }\n  void replaceImportedEntities(DIImportedEntityArray N) {\n    replaceOperandWith(7, N.get());\n  }\n  void replaceMacros(DIMacroNodeArray N) { replaceOperandWith(8, N.get()); }\n  /// @}\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DICompileUnitKind;\n  }\n};\n\n/// A scope for locals.\n///\n/// A legal scope for lexical blocks, local variables, and debug info\n/// locations.  Subclasses are \\a DISubprogram, \\a DILexicalBlock, and \\a\n/// DILexicalBlockFile.\nclass DILocalScope : public DIScope {\nprotected:\n  DILocalScope(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Tag,\n               ArrayRef<Metadata *> Ops)\n      : DIScope(C, ID, Storage, Tag, Ops) {}\n  ~DILocalScope() = default;\n\npublic:\n  /// Get the subprogram for this scope.\n  ///\n  /// Return this if it's an \\a DISubprogram; otherwise, look up the scope\n  /// chain.\n  DISubprogram *getSubprogram() const;\n\n  /// Get the first non DILexicalBlockFile scope of this scope.\n  ///\n  /// Return this if it's not a \\a DILexicalBlockFIle; otherwise, look up the\n  /// scope chain.\n  DILocalScope *getNonLexicalBlockFileScope() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DISubprogramKind ||\n           MD->getMetadataID() == DILexicalBlockKind ||\n           MD->getMetadataID() == DILexicalBlockFileKind;\n  }\n};\n\n/// Debug location.\n///\n/// A debug location in source code, used for debug info and otherwise.\nclass DILocation : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DILocation(LLVMContext &C, StorageType Storage, unsigned Line,\n             unsigned Column, ArrayRef<Metadata *> MDs, bool ImplicitCode);\n  ~DILocation() { dropAllReferences(); }\n\n  static DILocation *getImpl(LLVMContext &Context, unsigned Line,\n                             unsigned Column, Metadata *Scope,\n                             Metadata *InlinedAt, bool ImplicitCode,\n                             StorageType Storage, bool ShouldCreate = true);\n  static DILocation *getImpl(LLVMContext &Context, unsigned Line,\n                             unsigned Column, DILocalScope *Scope,\n                             DILocation *InlinedAt, bool ImplicitCode,\n                             StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Line, Column, static_cast<Metadata *>(Scope),\n                   static_cast<Metadata *>(InlinedAt), ImplicitCode, Storage,\n                   ShouldCreate);\n  }\n\n  /// With a given unsigned int \\p U, use up to 13 bits to represent it.\n  /// old_bit 1~5  --> new_bit 1~5\n  /// old_bit 6~12 --> new_bit 7~13\n  /// new_bit_6 is 0 if higher bits (7~13) are all 0\n  static unsigned getPrefixEncodingFromUnsigned(unsigned U) {\n    U &= 0xfff;\n    return U > 0x1f ? (((U & 0xfe0) << 1) | (U & 0x1f) | 0x20) : U;\n  }\n\n  /// Reverse transformation as getPrefixEncodingFromUnsigned.\n  static unsigned getUnsignedFromPrefixEncoding(unsigned U) {\n    if (U & 1)\n      return 0;\n    U >>= 1;\n    return (U & 0x20) ? (((U >> 1) & 0xfe0) | (U & 0x1f)) : (U & 0x1f);\n  }\n\n  /// Returns the next component stored in discriminator.\n  static unsigned getNextComponentInDiscriminator(unsigned D) {\n    if ((D & 1) == 0)\n      return D >> ((D & 0x40) ? 14 : 7);\n    else\n      return D >> 1;\n  }\n\n  TempDILocation cloneImpl() const {\n    // Get the raw scope/inlinedAt since it is possible to invoke this on\n    // a DILocation containing temporary metadata.\n    return getTemporary(getContext(), getLine(), getColumn(), getRawScope(),\n                        getRawInlinedAt(), isImplicitCode());\n  }\n\n  static unsigned encodeComponent(unsigned C) {\n    return (C == 0) ? 1U : (getPrefixEncodingFromUnsigned(C) << 1);\n  }\n\n  static unsigned encodingBits(unsigned C) {\n    return (C == 0) ? 1 : (C > 0x1f ? 14 : 7);\n  }\n\npublic:\n  // Disallow replacing operands.\n  void replaceOperandWith(unsigned I, Metadata *New) = delete;\n\n  DEFINE_MDNODE_GET(DILocation,\n                    (unsigned Line, unsigned Column, Metadata *Scope,\n                     Metadata *InlinedAt = nullptr, bool ImplicitCode = false),\n                    (Line, Column, Scope, InlinedAt, ImplicitCode))\n  DEFINE_MDNODE_GET(DILocation,\n                    (unsigned Line, unsigned Column, DILocalScope *Scope,\n                     DILocation *InlinedAt = nullptr,\n                     bool ImplicitCode = false),\n                    (Line, Column, Scope, InlinedAt, ImplicitCode))\n\n  /// Return a (temporary) clone of this.\n  TempDILocation clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return SubclassData32; }\n  unsigned getColumn() const { return SubclassData16; }\n  DILocalScope *getScope() const { return cast<DILocalScope>(getRawScope()); }\n\n  DILocation *getInlinedAt() const {\n    return cast_or_null<DILocation>(getRawInlinedAt());\n  }\n\n  /// Check if the location corresponds to an implicit code.\n  /// When the ImplicitCode flag is true, it means that the Instruction\n  /// with this DILocation has been added by the front-end but it hasn't been\n  /// written explicitly by the user (e.g. cleanup stuff in C++ put on a closing\n  /// bracket). It's useful for code coverage to not show a counter on \"empty\"\n  /// lines.\n  bool isImplicitCode() const { return SubclassData1; }\n  void setImplicitCode(bool ImplicitCode) { SubclassData1 = ImplicitCode; }\n\n  DIFile *getFile() const { return getScope()->getFile(); }\n  StringRef getFilename() const { return getScope()->getFilename(); }\n  StringRef getDirectory() const { return getScope()->getDirectory(); }\n  Optional<StringRef> getSource() const { return getScope()->getSource(); }\n\n  /// Get the scope where this is inlined.\n  ///\n  /// Walk through \\a getInlinedAt() and return \\a getScope() from the deepest\n  /// location.\n  DILocalScope *getInlinedAtScope() const {\n    if (auto *IA = getInlinedAt())\n      return IA->getInlinedAtScope();\n    return getScope();\n  }\n\n  /// Get the DWARF discriminator.\n  ///\n  /// DWARF discriminators distinguish identical file locations between\n  /// instructions that are on different basic blocks.\n  ///\n  /// There are 3 components stored in discriminator, from lower bits:\n  ///\n  /// Base discriminator: assigned by AddDiscriminators pass to identify IRs\n  ///                     that are defined by the same source line, but\n  ///                     different basic blocks.\n  /// Duplication factor: assigned by optimizations that will scale down\n  ///                     the execution frequency of the original IR.\n  /// Copy Identifier: assigned by optimizations that clones the IR.\n  ///                  Each copy of the IR will be assigned an identifier.\n  ///\n  /// Encoding:\n  ///\n  /// The above 3 components are encoded into a 32bit unsigned integer in\n  /// order. If the lowest bit is 1, the current component is empty, and the\n  /// next component will start in the next bit. Otherwise, the current\n  /// component is non-empty, and its content starts in the next bit. The\n  /// value of each components is either 5 bit or 12 bit: if the 7th bit\n  /// is 0, the bit 2~6 (5 bits) are used to represent the component; if the\n  /// 7th bit is 1, the bit 2~6 (5 bits) and 8~14 (7 bits) are combined to\n  /// represent the component. Thus, the number of bits used for a component\n  /// is either 0 (if it and all the next components are empty); 1 - if it is\n  /// empty; 7 - if its value is up to and including 0x1f (lsb and msb are both\n  /// 0); or 14, if its value is up to and including 0x1ff. Note that the last\n  /// component is also capped at 0x1ff, even in the case when both first\n  /// components are 0, and we'd technically have 29 bits available.\n  ///\n  /// For precise control over the data being encoded in the discriminator,\n  /// use encodeDiscriminator/decodeDiscriminator.\n\n  inline unsigned getDiscriminator() const;\n\n  // For the regular discriminator, it stands for all empty components if all\n  // the lowest 3 bits are non-zero and all higher 29 bits are unused(zero by\n  // default). Here we fully leverage the higher 29 bits for pseudo probe use.\n  // This is the format:\n  // [2:0] - 0x7\n  // [31:3] - pseudo probe fields guaranteed to be non-zero as a whole\n  // So if the lower 3 bits is non-zero and the others has at least one\n  // non-zero bit, it guarantees to be a pseudo probe discriminator\n  inline static bool isPseudoProbeDiscriminator(unsigned Discriminator) {\n    return ((Discriminator & 0x7) == 0x7) && (Discriminator & 0xFFFFFFF8);\n  }\n\n  /// Returns a new DILocation with updated \\p Discriminator.\n  inline const DILocation *cloneWithDiscriminator(unsigned Discriminator) const;\n\n  /// Returns a new DILocation with updated base discriminator \\p BD. Only the\n  /// base discriminator is set in the new DILocation, the other encoded values\n  /// are elided.\n  /// If the discriminator cannot be encoded, the function returns None.\n  inline Optional<const DILocation *> cloneWithBaseDiscriminator(unsigned BD) const;\n\n  /// Returns the duplication factor stored in the discriminator, or 1 if no\n  /// duplication factor (or 0) is encoded.\n  inline unsigned getDuplicationFactor() const;\n\n  /// Returns the copy identifier stored in the discriminator.\n  inline unsigned getCopyIdentifier() const;\n\n  /// Returns the base discriminator stored in the discriminator.\n  inline unsigned getBaseDiscriminator() const;\n\n  /// Returns a new DILocation with duplication factor \\p DF * current\n  /// duplication factor encoded in the discriminator. The current duplication\n  /// factor is as defined by getDuplicationFactor().\n  /// Returns None if encoding failed.\n  inline Optional<const DILocation *> cloneByMultiplyingDuplicationFactor(unsigned DF) const;\n\n  /// When two instructions are combined into a single instruction we also\n  /// need to combine the original locations into a single location.\n  ///\n  /// When the locations are the same we can use either location. When they\n  /// differ, we need a third location which is distinct from either. If they\n  /// have the same file/line but have a different discriminator we could\n  /// create a location with a new discriminator. If they are from different\n  /// files/lines the location is ambiguous and can't be represented in a line\n  /// entry. In this case, if \\p GenerateLocation is true, we will set the\n  /// merged debug location as line 0 of the nearest common scope where the two\n  /// locations are inlined from.\n  ///\n  /// \\p GenerateLocation: Whether the merged location can be generated when\n  /// \\p LocA and \\p LocB differ.\n  static const DILocation *getMergedLocation(const DILocation *LocA,\n                                             const DILocation *LocB);\n\n  /// Try to combine the vector of locations passed as input in a single one.\n  /// This function applies getMergedLocation() repeatedly left-to-right.\n  ///\n  /// \\p Locs: The locations to be merged.\n  static\n  const DILocation *getMergedLocations(ArrayRef<const DILocation *> Locs);\n\n  /// Returns the base discriminator for a given encoded discriminator \\p D.\n  static unsigned getBaseDiscriminatorFromDiscriminator(unsigned D) {\n    return getUnsignedFromPrefixEncoding(D);\n  }\n\n  /// Raw encoding of the discriminator. APIs such as cloneWithDuplicationFactor\n  /// have certain special case behavior (e.g. treating empty duplication factor\n  /// as the value '1').\n  /// This API, in conjunction with cloneWithDiscriminator, may be used to encode\n  /// the raw values provided. \\p BD: base discriminator \\p DF: duplication factor\n  /// \\p CI: copy index\n  /// The return is None if the values cannot be encoded in 32 bits - for\n  /// example, values for BD or DF larger than 12 bits. Otherwise, the return\n  /// is the encoded value.\n  static Optional<unsigned> encodeDiscriminator(unsigned BD, unsigned DF, unsigned CI);\n\n  /// Raw decoder for values in an encoded discriminator D.\n  static void decodeDiscriminator(unsigned D, unsigned &BD, unsigned &DF,\n                                  unsigned &CI);\n\n  /// Returns the duplication factor for a given encoded discriminator \\p D, or\n  /// 1 if no value or 0 is encoded.\n  static unsigned getDuplicationFactorFromDiscriminator(unsigned D) {\n    D = getNextComponentInDiscriminator(D);\n    unsigned Ret = getUnsignedFromPrefixEncoding(D);\n    if (Ret == 0)\n      return 1;\n    return Ret;\n  }\n\n  /// Returns the copy identifier for a given encoded discriminator \\p D.\n  static unsigned getCopyIdentifierFromDiscriminator(unsigned D) {\n    return getUnsignedFromPrefixEncoding(getNextComponentInDiscriminator(\n        getNextComponentInDiscriminator(D)));\n  }\n\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  Metadata *getRawInlinedAt() const {\n    if (getNumOperands() == 2)\n      return getOperand(1);\n    return nullptr;\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILocationKind;\n  }\n};\n\n/// Subprogram description.\nclass DISubprogram : public DILocalScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n  unsigned ScopeLine;\n  unsigned VirtualIndex;\n\n  /// In the MS ABI, the implicit 'this' parameter is adjusted in the prologue\n  /// of method overrides from secondary bases by this amount. It may be\n  /// negative.\n  int ThisAdjustment;\n\npublic:\n  /// Debug info subprogram flags.\n  enum DISPFlags : uint32_t {\n#define HANDLE_DISP_FLAG(ID, NAME) SPFlag##NAME = ID,\n#define DISP_FLAG_LARGEST_NEEDED\n#include \"llvm/IR/DebugInfoFlags.def\"\n    SPFlagNonvirtual = SPFlagZero,\n    SPFlagVirtuality = SPFlagVirtual | SPFlagPureVirtual,\n    LLVM_MARK_AS_BITMASK_ENUM(SPFlagLargest)\n  };\n\n  static DISPFlags getFlag(StringRef Flag);\n  static StringRef getFlagString(DISPFlags Flag);\n\n  /// Split up a flags bitfield for easier printing.\n  ///\n  /// Split \\c Flags into \\c SplitFlags, a vector of its components.  Returns\n  /// any remaining (unrecognized) bits.\n  static DISPFlags splitFlags(DISPFlags Flags,\n                              SmallVectorImpl<DISPFlags> &SplitFlags);\n\n  // Helper for converting old bitfields to new flags word.\n  static DISPFlags toSPFlags(bool IsLocalToUnit, bool IsDefinition,\n                             bool IsOptimized,\n                             unsigned Virtuality = SPFlagNonvirtual,\n                             bool IsMainSubprogram = false) {\n    // We're assuming virtuality is the low-order field.\n    static_assert(\n        int(SPFlagVirtual) == int(dwarf::DW_VIRTUALITY_virtual) &&\n            int(SPFlagPureVirtual) == int(dwarf::DW_VIRTUALITY_pure_virtual),\n        \"Virtuality constant mismatch\");\n    return static_cast<DISPFlags>(\n        (Virtuality & SPFlagVirtuality) |\n        (IsLocalToUnit ? SPFlagLocalToUnit : SPFlagZero) |\n        (IsDefinition ? SPFlagDefinition : SPFlagZero) |\n        (IsOptimized ? SPFlagOptimized : SPFlagZero) |\n        (IsMainSubprogram ? SPFlagMainSubprogram : SPFlagZero));\n  }\n\nprivate:\n  DIFlags Flags;\n  DISPFlags SPFlags;\n\n  DISubprogram(LLVMContext &C, StorageType Storage, unsigned Line,\n               unsigned ScopeLine, unsigned VirtualIndex, int ThisAdjustment,\n               DIFlags Flags, DISPFlags SPFlags, ArrayRef<Metadata *> Ops)\n      : DILocalScope(C, DISubprogramKind, Storage, dwarf::DW_TAG_subprogram,\n                     Ops),\n        Line(Line), ScopeLine(ScopeLine), VirtualIndex(VirtualIndex),\n        ThisAdjustment(ThisAdjustment), Flags(Flags), SPFlags(SPFlags) {\n    static_assert(dwarf::DW_VIRTUALITY_max < 4, \"Virtuality out of range\");\n  }\n  ~DISubprogram() = default;\n\n  static DISubprogram *\n  getImpl(LLVMContext &Context, DIScope *Scope, StringRef Name,\n          StringRef LinkageName, DIFile *File, unsigned Line,\n          DISubroutineType *Type, unsigned ScopeLine, DIType *ContainingType,\n          unsigned VirtualIndex, int ThisAdjustment, DIFlags Flags,\n          DISPFlags SPFlags, DICompileUnit *Unit,\n          DITemplateParameterArray TemplateParams, DISubprogram *Declaration,\n          DINodeArray RetainedNodes, DITypeArray ThrownTypes,\n          StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name),\n                   getCanonicalMDString(Context, LinkageName), File, Line, Type,\n                   ScopeLine, ContainingType, VirtualIndex, ThisAdjustment,\n                   Flags, SPFlags, Unit, TemplateParams.get(), Declaration,\n                   RetainedNodes.get(), ThrownTypes.get(), Storage,\n                   ShouldCreate);\n  }\n  static DISubprogram *getImpl(LLVMContext &Context, Metadata *Scope,\n                               MDString *Name, MDString *LinkageName,\n                               Metadata *File, unsigned Line, Metadata *Type,\n                               unsigned ScopeLine, Metadata *ContainingType,\n                               unsigned VirtualIndex, int ThisAdjustment,\n                               DIFlags Flags, DISPFlags SPFlags, Metadata *Unit,\n                               Metadata *TemplateParams, Metadata *Declaration,\n                               Metadata *RetainedNodes, Metadata *ThrownTypes,\n                               StorageType Storage, bool ShouldCreate = true);\n\n  TempDISubprogram cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(), getLinkageName(),\n                        getFile(), getLine(), getType(), getScopeLine(),\n                        getContainingType(), getVirtualIndex(),\n                        getThisAdjustment(), getFlags(), getSPFlags(),\n                        getUnit(), getTemplateParams(), getDeclaration(),\n                        getRetainedNodes(), getThrownTypes());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(\n      DISubprogram,\n      (DIScope * Scope, StringRef Name, StringRef LinkageName, DIFile *File,\n       unsigned Line, DISubroutineType *Type, unsigned ScopeLine,\n       DIType *ContainingType, unsigned VirtualIndex, int ThisAdjustment,\n       DIFlags Flags, DISPFlags SPFlags, DICompileUnit *Unit,\n       DITemplateParameterArray TemplateParams = nullptr,\n       DISubprogram *Declaration = nullptr, DINodeArray RetainedNodes = nullptr,\n       DITypeArray ThrownTypes = nullptr),\n      (Scope, Name, LinkageName, File, Line, Type, ScopeLine, ContainingType,\n       VirtualIndex, ThisAdjustment, Flags, SPFlags, Unit, TemplateParams,\n       Declaration, RetainedNodes, ThrownTypes))\n\n  DEFINE_MDNODE_GET(\n      DISubprogram,\n      (Metadata * Scope, MDString *Name, MDString *LinkageName, Metadata *File,\n       unsigned Line, Metadata *Type, unsigned ScopeLine,\n       Metadata *ContainingType, unsigned VirtualIndex, int ThisAdjustment,\n       DIFlags Flags, DISPFlags SPFlags, Metadata *Unit,\n       Metadata *TemplateParams = nullptr, Metadata *Declaration = nullptr,\n       Metadata *RetainedNodes = nullptr, Metadata *ThrownTypes = nullptr),\n      (Scope, Name, LinkageName, File, Line, Type, ScopeLine, ContainingType,\n       VirtualIndex, ThisAdjustment, Flags, SPFlags, Unit, TemplateParams,\n       Declaration, RetainedNodes, ThrownTypes))\n\n  TempDISubprogram clone() const { return cloneImpl(); }\n\n  /// Returns a new temporary DISubprogram with updated Flags\n  TempDISubprogram cloneWithFlags(DIFlags NewFlags) const {\n    auto NewSP = clone();\n    NewSP->Flags = NewFlags;\n    return NewSP;\n  }\n\npublic:\n  unsigned getLine() const { return Line; }\n  unsigned getVirtuality() const { return getSPFlags() & SPFlagVirtuality; }\n  unsigned getVirtualIndex() const { return VirtualIndex; }\n  int getThisAdjustment() const { return ThisAdjustment; }\n  unsigned getScopeLine() const { return ScopeLine; }\n  void setScopeLine(unsigned L) { assert(isDistinct()); ScopeLine = L; }\n  DIFlags getFlags() const { return Flags; }\n  DISPFlags getSPFlags() const { return SPFlags; }\n  bool isLocalToUnit() const { return getSPFlags() & SPFlagLocalToUnit; }\n  bool isDefinition() const { return getSPFlags() & SPFlagDefinition; }\n  bool isOptimized() const { return getSPFlags() & SPFlagOptimized; }\n  bool isMainSubprogram() const { return getSPFlags() & SPFlagMainSubprogram; }\n\n  bool isArtificial() const { return getFlags() & FlagArtificial; }\n  bool isPrivate() const {\n    return (getFlags() & FlagAccessibility) == FlagPrivate;\n  }\n  bool isProtected() const {\n    return (getFlags() & FlagAccessibility) == FlagProtected;\n  }\n  bool isPublic() const {\n    return (getFlags() & FlagAccessibility) == FlagPublic;\n  }\n  bool isExplicit() const { return getFlags() & FlagExplicit; }\n  bool isPrototyped() const { return getFlags() & FlagPrototyped; }\n  bool areAllCallsDescribed() const {\n    return getFlags() & FlagAllCallsDescribed;\n  }\n  bool isPure() const { return getSPFlags() & SPFlagPure; }\n  bool isElemental() const { return getSPFlags() & SPFlagElemental; }\n  bool isRecursive() const { return getSPFlags() & SPFlagRecursive; }\n  bool isObjCDirect() const { return getSPFlags() & SPFlagObjCDirect; }\n\n  /// Check if this is deleted member function.\n  ///\n  /// Return true if this subprogram is a C++11 special\n  /// member function declared deleted.\n  bool isDeleted() const { return getSPFlags() & SPFlagDeleted; }\n\n  /// Check if this is reference-qualified.\n  ///\n  /// Return true if this subprogram is a C++11 reference-qualified non-static\n  /// member function (void foo() &).\n  bool isLValueReference() const { return getFlags() & FlagLValueReference; }\n\n  /// Check if this is rvalue-reference-qualified.\n  ///\n  /// Return true if this subprogram is a C++11 rvalue-reference-qualified\n  /// non-static member function (void foo() &&).\n  bool isRValueReference() const { return getFlags() & FlagRValueReference; }\n\n  /// Check if this is marked as noreturn.\n  ///\n  /// Return true if this subprogram is C++11 noreturn or C11 _Noreturn\n  bool isNoReturn() const { return getFlags() & FlagNoReturn; }\n\n  // Check if this routine is a compiler-generated thunk.\n  //\n  // Returns true if this subprogram is a thunk generated by the compiler.\n  bool isThunk() const { return getFlags() & FlagThunk; }\n\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n\n  StringRef getName() const { return getStringOperand(2); }\n  StringRef getLinkageName() const { return getStringOperand(3); }\n\n  DISubroutineType *getType() const {\n    return cast_or_null<DISubroutineType>(getRawType());\n  }\n  DIType *getContainingType() const {\n    return cast_or_null<DIType>(getRawContainingType());\n  }\n\n  DICompileUnit *getUnit() const {\n    return cast_or_null<DICompileUnit>(getRawUnit());\n  }\n  void replaceUnit(DICompileUnit *CU) { replaceOperandWith(5, CU); }\n  DITemplateParameterArray getTemplateParams() const {\n    return cast_or_null<MDTuple>(getRawTemplateParams());\n  }\n  DISubprogram *getDeclaration() const {\n    return cast_or_null<DISubprogram>(getRawDeclaration());\n  }\n  DINodeArray getRetainedNodes() const {\n    return cast_or_null<MDTuple>(getRawRetainedNodes());\n  }\n  DITypeArray getThrownTypes() const {\n    return cast_or_null<MDTuple>(getRawThrownTypes());\n  }\n\n  Metadata *getRawScope() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n  MDString *getRawLinkageName() const { return getOperandAs<MDString>(3); }\n  Metadata *getRawType() const { return getOperand(4); }\n  Metadata *getRawUnit() const { return getOperand(5); }\n  Metadata *getRawDeclaration() const { return getOperand(6); }\n  Metadata *getRawRetainedNodes() const { return getOperand(7); }\n  Metadata *getRawContainingType() const {\n    return getNumOperands() > 8 ? getOperandAs<Metadata>(8) : nullptr;\n  }\n  Metadata *getRawTemplateParams() const {\n    return getNumOperands() > 9 ? getOperandAs<Metadata>(9) : nullptr;\n  }\n  Metadata *getRawThrownTypes() const {\n    return getNumOperands() > 10 ? getOperandAs<Metadata>(10) : nullptr;\n  }\n\n  void replaceRawLinkageName(MDString *LinkageName) {\n    replaceOperandWith(3, LinkageName);\n  }\n\n  /// Check if this subprogram describes the given function.\n  ///\n  /// FIXME: Should this be looking through bitcasts?\n  bool describes(const Function *F) const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DISubprogramKind;\n  }\n};\n\nclass DILexicalBlockBase : public DILocalScope {\nprotected:\n  DILexicalBlockBase(LLVMContext &C, unsigned ID, StorageType Storage,\n                     ArrayRef<Metadata *> Ops)\n      : DILocalScope(C, ID, Storage, dwarf::DW_TAG_lexical_block, Ops) {}\n  ~DILexicalBlockBase() = default;\n\npublic:\n  DILocalScope *getScope() const { return cast<DILocalScope>(getRawScope()); }\n\n  Metadata *getRawScope() const { return getOperand(1); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILexicalBlockKind ||\n           MD->getMetadataID() == DILexicalBlockFileKind;\n  }\n};\n\nclass DILexicalBlock : public DILexicalBlockBase {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n  uint16_t Column;\n\n  DILexicalBlock(LLVMContext &C, StorageType Storage, unsigned Line,\n                 unsigned Column, ArrayRef<Metadata *> Ops)\n      : DILexicalBlockBase(C, DILexicalBlockKind, Storage, Ops), Line(Line),\n        Column(Column) {\n    assert(Column < (1u << 16) && \"Expected 16-bit column\");\n  }\n  ~DILexicalBlock() = default;\n\n  static DILexicalBlock *getImpl(LLVMContext &Context, DILocalScope *Scope,\n                                 DIFile *File, unsigned Line, unsigned Column,\n                                 StorageType Storage,\n                                 bool ShouldCreate = true) {\n    return getImpl(Context, static_cast<Metadata *>(Scope),\n                   static_cast<Metadata *>(File), Line, Column, Storage,\n                   ShouldCreate);\n  }\n\n  static DILexicalBlock *getImpl(LLVMContext &Context, Metadata *Scope,\n                                 Metadata *File, unsigned Line, unsigned Column,\n                                 StorageType Storage, bool ShouldCreate = true);\n\n  TempDILexicalBlock cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getFile(), getLine(),\n                        getColumn());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DILexicalBlock, (DILocalScope * Scope, DIFile *File,\n                                     unsigned Line, unsigned Column),\n                    (Scope, File, Line, Column))\n  DEFINE_MDNODE_GET(DILexicalBlock, (Metadata * Scope, Metadata *File,\n                                     unsigned Line, unsigned Column),\n                    (Scope, File, Line, Column))\n\n  TempDILexicalBlock clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return Line; }\n  unsigned getColumn() const { return Column; }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILexicalBlockKind;\n  }\n};\n\nclass DILexicalBlockFile : public DILexicalBlockBase {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Discriminator;\n\n  DILexicalBlockFile(LLVMContext &C, StorageType Storage,\n                     unsigned Discriminator, ArrayRef<Metadata *> Ops)\n      : DILexicalBlockBase(C, DILexicalBlockFileKind, Storage, Ops),\n        Discriminator(Discriminator) {}\n  ~DILexicalBlockFile() = default;\n\n  static DILexicalBlockFile *getImpl(LLVMContext &Context, DILocalScope *Scope,\n                                     DIFile *File, unsigned Discriminator,\n                                     StorageType Storage,\n                                     bool ShouldCreate = true) {\n    return getImpl(Context, static_cast<Metadata *>(Scope),\n                   static_cast<Metadata *>(File), Discriminator, Storage,\n                   ShouldCreate);\n  }\n\n  static DILexicalBlockFile *getImpl(LLVMContext &Context, Metadata *Scope,\n                                     Metadata *File, unsigned Discriminator,\n                                     StorageType Storage,\n                                     bool ShouldCreate = true);\n\n  TempDILexicalBlockFile cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getFile(),\n                        getDiscriminator());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DILexicalBlockFile, (DILocalScope * Scope, DIFile *File,\n                                         unsigned Discriminator),\n                    (Scope, File, Discriminator))\n  DEFINE_MDNODE_GET(DILexicalBlockFile,\n                    (Metadata * Scope, Metadata *File, unsigned Discriminator),\n                    (Scope, File, Discriminator))\n\n  TempDILexicalBlockFile clone() const { return cloneImpl(); }\n  unsigned getDiscriminator() const { return Discriminator; }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILexicalBlockFileKind;\n  }\n};\n\nunsigned DILocation::getDiscriminator() const {\n  if (auto *F = dyn_cast<DILexicalBlockFile>(getScope()))\n    return F->getDiscriminator();\n  return 0;\n}\n\nconst DILocation *\nDILocation::cloneWithDiscriminator(unsigned Discriminator) const {\n  DIScope *Scope = getScope();\n  // Skip all parent DILexicalBlockFile that already have a discriminator\n  // assigned. We do not want to have nested DILexicalBlockFiles that have\n  // mutliple discriminators because only the leaf DILexicalBlockFile's\n  // dominator will be used.\n  for (auto *LBF = dyn_cast<DILexicalBlockFile>(Scope);\n       LBF && LBF->getDiscriminator() != 0;\n       LBF = dyn_cast<DILexicalBlockFile>(Scope))\n    Scope = LBF->getScope();\n  DILexicalBlockFile *NewScope =\n      DILexicalBlockFile::get(getContext(), Scope, getFile(), Discriminator);\n  return DILocation::get(getContext(), getLine(), getColumn(), NewScope,\n                         getInlinedAt());\n}\n\nunsigned DILocation::getBaseDiscriminator() const {\n  return getBaseDiscriminatorFromDiscriminator(getDiscriminator());\n}\n\nunsigned DILocation::getDuplicationFactor() const {\n  return getDuplicationFactorFromDiscriminator(getDiscriminator());\n}\n\nunsigned DILocation::getCopyIdentifier() const {\n  return getCopyIdentifierFromDiscriminator(getDiscriminator());\n}\n\nOptional<const DILocation *> DILocation::cloneWithBaseDiscriminator(unsigned D) const {\n  unsigned BD, DF, CI;\n  decodeDiscriminator(getDiscriminator(), BD, DF, CI);\n  if (D == BD)\n    return this;\n  if (Optional<unsigned> Encoded = encodeDiscriminator(D, DF, CI))\n    return cloneWithDiscriminator(*Encoded);\n  return None;\n}\n\nOptional<const DILocation *> DILocation::cloneByMultiplyingDuplicationFactor(unsigned DF) const {\n  DF *= getDuplicationFactor();\n  if (DF <= 1)\n    return this;\n\n  unsigned BD = getBaseDiscriminator();\n  unsigned CI = getCopyIdentifier();\n  if (Optional<unsigned> D = encodeDiscriminator(BD, DF, CI))\n    return cloneWithDiscriminator(*D);\n  return None;\n}\n\nclass DINamespace : public DIScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned ExportSymbols : 1;\n\n  DINamespace(LLVMContext &Context, StorageType Storage, bool ExportSymbols,\n              ArrayRef<Metadata *> Ops)\n      : DIScope(Context, DINamespaceKind, Storage, dwarf::DW_TAG_namespace,\n                Ops),\n        ExportSymbols(ExportSymbols) {}\n  ~DINamespace() = default;\n\n  static DINamespace *getImpl(LLVMContext &Context, DIScope *Scope,\n                              StringRef Name, bool ExportSymbols,\n                              StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name),\n                   ExportSymbols, Storage, ShouldCreate);\n  }\n  static DINamespace *getImpl(LLVMContext &Context, Metadata *Scope,\n                              MDString *Name, bool ExportSymbols,\n                              StorageType Storage, bool ShouldCreate = true);\n\n  TempDINamespace cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(),\n                        getExportSymbols());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DINamespace,\n                    (DIScope *Scope, StringRef Name, bool ExportSymbols),\n                    (Scope, Name, ExportSymbols))\n  DEFINE_MDNODE_GET(DINamespace,\n                    (Metadata *Scope, MDString *Name, bool ExportSymbols),\n                    (Scope, Name, ExportSymbols))\n\n  TempDINamespace clone() const { return cloneImpl(); }\n\n  bool getExportSymbols() const { return ExportSymbols; }\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  StringRef getName() const { return getStringOperand(2); }\n\n  Metadata *getRawScope() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DINamespaceKind;\n  }\n};\n\n/// Represents a module in the programming language, for example, a Clang\n/// module, or a Fortran module.\nclass DIModule : public DIScope {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n  unsigned LineNo;\n  bool IsDecl;\n\n  DIModule(LLVMContext &Context, StorageType Storage, unsigned LineNo,\n           bool IsDecl, ArrayRef<Metadata *> Ops)\n      : DIScope(Context, DIModuleKind, Storage, dwarf::DW_TAG_module, Ops),\n        LineNo(LineNo), IsDecl(IsDecl) {}\n  ~DIModule() = default;\n\n  static DIModule *getImpl(LLVMContext &Context, DIFile *File, DIScope *Scope,\n                           StringRef Name, StringRef ConfigurationMacros,\n                           StringRef IncludePath, StringRef APINotesFile,\n                           unsigned LineNo, bool IsDecl, StorageType Storage,\n                           bool ShouldCreate = true) {\n    return getImpl(Context, File, Scope, getCanonicalMDString(Context, Name),\n                   getCanonicalMDString(Context, ConfigurationMacros),\n                   getCanonicalMDString(Context, IncludePath),\n                   getCanonicalMDString(Context, APINotesFile), LineNo, IsDecl,\n                   Storage, ShouldCreate);\n  }\n  static DIModule *getImpl(LLVMContext &Context, Metadata *File,\n                           Metadata *Scope, MDString *Name,\n                           MDString *ConfigurationMacros, MDString *IncludePath,\n                           MDString *APINotesFile, unsigned LineNo, bool IsDecl,\n                           StorageType Storage, bool ShouldCreate = true);\n\n  TempDIModule cloneImpl() const {\n    return getTemporary(getContext(), getFile(), getScope(), getName(),\n                        getConfigurationMacros(), getIncludePath(),\n                        getAPINotesFile(), getLineNo(), getIsDecl());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIModule,\n                    (DIFile * File, DIScope *Scope, StringRef Name,\n                     StringRef ConfigurationMacros, StringRef IncludePath,\n                     StringRef APINotesFile, unsigned LineNo,\n                     bool IsDecl = false),\n                    (File, Scope, Name, ConfigurationMacros, IncludePath,\n                     APINotesFile, LineNo, IsDecl))\n  DEFINE_MDNODE_GET(DIModule,\n                    (Metadata * File, Metadata *Scope, MDString *Name,\n                     MDString *ConfigurationMacros, MDString *IncludePath,\n                     MDString *APINotesFile, unsigned LineNo,\n                     bool IsDecl = false),\n                    (File, Scope, Name, ConfigurationMacros, IncludePath,\n                     APINotesFile, LineNo, IsDecl))\n\n  TempDIModule clone() const { return cloneImpl(); }\n\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  StringRef getName() const { return getStringOperand(2); }\n  StringRef getConfigurationMacros() const { return getStringOperand(3); }\n  StringRef getIncludePath() const { return getStringOperand(4); }\n  StringRef getAPINotesFile() const { return getStringOperand(5); }\n  unsigned getLineNo() const { return LineNo; }\n  bool getIsDecl() const { return IsDecl; }\n\n  Metadata *getRawScope() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n  MDString *getRawConfigurationMacros() const {\n    return getOperandAs<MDString>(3);\n  }\n  MDString *getRawIncludePath() const { return getOperandAs<MDString>(4); }\n  MDString *getRawAPINotesFile() const { return getOperandAs<MDString>(5); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIModuleKind;\n  }\n};\n\n/// Base class for template parameters.\nclass DITemplateParameter : public DINode {\nprotected:\n  bool IsDefault;\n\n  DITemplateParameter(LLVMContext &Context, unsigned ID, StorageType Storage,\n                      unsigned Tag, bool IsDefault, ArrayRef<Metadata *> Ops)\n      : DINode(Context, ID, Storage, Tag, Ops), IsDefault(IsDefault) {}\n  ~DITemplateParameter() = default;\n\npublic:\n  StringRef getName() const { return getStringOperand(0); }\n  DIType *getType() const { return cast_or_null<DIType>(getRawType()); }\n\n  MDString *getRawName() const { return getOperandAs<MDString>(0); }\n  Metadata *getRawType() const { return getOperand(1); }\n  bool isDefault() const { return IsDefault; }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DITemplateTypeParameterKind ||\n           MD->getMetadataID() == DITemplateValueParameterKind;\n  }\n};\n\nclass DITemplateTypeParameter : public DITemplateParameter {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DITemplateTypeParameter(LLVMContext &Context, StorageType Storage,\n                          bool IsDefault, ArrayRef<Metadata *> Ops)\n      : DITemplateParameter(Context, DITemplateTypeParameterKind, Storage,\n                            dwarf::DW_TAG_template_type_parameter, IsDefault,\n                            Ops) {}\n  ~DITemplateTypeParameter() = default;\n\n  static DITemplateTypeParameter *getImpl(LLVMContext &Context, StringRef Name,\n                                          DIType *Type, bool IsDefault,\n                                          StorageType Storage,\n                                          bool ShouldCreate = true) {\n    return getImpl(Context, getCanonicalMDString(Context, Name), Type,\n                   IsDefault, Storage, ShouldCreate);\n  }\n  static DITemplateTypeParameter *getImpl(LLVMContext &Context, MDString *Name,\n                                          Metadata *Type, bool IsDefault,\n                                          StorageType Storage,\n                                          bool ShouldCreate = true);\n\n  TempDITemplateTypeParameter cloneImpl() const {\n    return getTemporary(getContext(), getName(), getType(), isDefault());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DITemplateTypeParameter,\n                    (StringRef Name, DIType *Type, bool IsDefault),\n                    (Name, Type, IsDefault))\n  DEFINE_MDNODE_GET(DITemplateTypeParameter,\n                    (MDString *Name, Metadata *Type, bool IsDefault),\n                    (Name, Type, IsDefault))\n\n  TempDITemplateTypeParameter clone() const { return cloneImpl(); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DITemplateTypeParameterKind;\n  }\n};\n\nclass DITemplateValueParameter : public DITemplateParameter {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DITemplateValueParameter(LLVMContext &Context, StorageType Storage,\n                           unsigned Tag, bool IsDefault,\n                           ArrayRef<Metadata *> Ops)\n      : DITemplateParameter(Context, DITemplateValueParameterKind, Storage, Tag,\n                            IsDefault, Ops) {}\n  ~DITemplateValueParameter() = default;\n\n  static DITemplateValueParameter *getImpl(LLVMContext &Context, unsigned Tag,\n                                           StringRef Name, DIType *Type,\n                                           bool IsDefault, Metadata *Value,\n                                           StorageType Storage,\n                                           bool ShouldCreate = true) {\n    return getImpl(Context, Tag, getCanonicalMDString(Context, Name), Type,\n                   IsDefault, Value, Storage, ShouldCreate);\n  }\n  static DITemplateValueParameter *getImpl(LLVMContext &Context, unsigned Tag,\n                                           MDString *Name, Metadata *Type,\n                                           bool IsDefault, Metadata *Value,\n                                           StorageType Storage,\n                                           bool ShouldCreate = true);\n\n  TempDITemplateValueParameter cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getName(), getType(),\n                        isDefault(), getValue());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DITemplateValueParameter,\n                    (unsigned Tag, StringRef Name, DIType *Type, bool IsDefault,\n                     Metadata *Value),\n                    (Tag, Name, Type, IsDefault, Value))\n  DEFINE_MDNODE_GET(DITemplateValueParameter,\n                    (unsigned Tag, MDString *Name, Metadata *Type,\n                     bool IsDefault, Metadata *Value),\n                    (Tag, Name, Type, IsDefault, Value))\n\n  TempDITemplateValueParameter clone() const { return cloneImpl(); }\n\n  Metadata *getValue() const { return getOperand(2); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DITemplateValueParameterKind;\n  }\n};\n\n/// Base class for variables.\nclass DIVariable : public DINode {\n  unsigned Line;\n  uint32_t AlignInBits;\n\nprotected:\n  DIVariable(LLVMContext &C, unsigned ID, StorageType Storage, unsigned Line,\n             ArrayRef<Metadata *> Ops, uint32_t AlignInBits = 0)\n      : DINode(C, ID, Storage, dwarf::DW_TAG_variable, Ops), Line(Line),\n        AlignInBits(AlignInBits) {}\n  ~DIVariable() = default;\n\npublic:\n  unsigned getLine() const { return Line; }\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  StringRef getName() const { return getStringOperand(1); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n  DIType *getType() const { return cast_or_null<DIType>(getRawType()); }\n  uint32_t getAlignInBits() const { return AlignInBits; }\n  uint32_t getAlignInBytes() const { return getAlignInBits() / CHAR_BIT; }\n  /// Determines the size of the variable's type.\n  Optional<uint64_t> getSizeInBits() const;\n\n  /// Return the signedness of this variable's type, or None if this type is\n  /// neither signed nor unsigned.\n  Optional<DIBasicType::Signedness> getSignedness() const {\n    if (auto *BT = dyn_cast<DIBasicType>(getType()))\n      return BT->getSignedness();\n    return None;\n  }\n\n  StringRef getFilename() const {\n    if (auto *F = getFile())\n      return F->getFilename();\n    return \"\";\n  }\n\n  StringRef getDirectory() const {\n    if (auto *F = getFile())\n      return F->getDirectory();\n    return \"\";\n  }\n\n  Optional<StringRef> getSource() const {\n    if (auto *F = getFile())\n      return F->getSource();\n    return None;\n  }\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  MDString *getRawName() const { return getOperandAs<MDString>(1); }\n  Metadata *getRawFile() const { return getOperand(2); }\n  Metadata *getRawType() const { return getOperand(3); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILocalVariableKind ||\n           MD->getMetadataID() == DIGlobalVariableKind;\n  }\n};\n\n/// DWARF expression.\n///\n/// This is (almost) a DWARF expression that modifies the location of a\n/// variable, or the location of a single piece of a variable, or (when using\n/// DW_OP_stack_value) is the constant variable value.\n///\n/// TODO: Co-allocate the expression elements.\n/// TODO: Separate from MDNode, or otherwise drop Distinct and Temporary\n/// storage types.\nclass DIExpression : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  std::vector<uint64_t> Elements;\n\n  DIExpression(LLVMContext &C, StorageType Storage, ArrayRef<uint64_t> Elements)\n      : MDNode(C, DIExpressionKind, Storage, None),\n        Elements(Elements.begin(), Elements.end()) {}\n  ~DIExpression() = default;\n\n  static DIExpression *getImpl(LLVMContext &Context,\n                               ArrayRef<uint64_t> Elements, StorageType Storage,\n                               bool ShouldCreate = true);\n\n  TempDIExpression cloneImpl() const {\n    return getTemporary(getContext(), getElements());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIExpression, (ArrayRef<uint64_t> Elements), (Elements))\n\n  TempDIExpression clone() const { return cloneImpl(); }\n\n  ArrayRef<uint64_t> getElements() const { return Elements; }\n\n  unsigned getNumElements() const { return Elements.size(); }\n\n  uint64_t getElement(unsigned I) const {\n    assert(I < Elements.size() && \"Index out of range\");\n    return Elements[I];\n  }\n\n  /// Determine whether this represents a standalone constant value.\n  bool isConstant() const;\n\n  /// Determine whether this represents a standalone signed constant value.\n  bool isSignedConstant() const;\n\n  using element_iterator = ArrayRef<uint64_t>::iterator;\n\n  element_iterator elements_begin() const { return getElements().begin(); }\n  element_iterator elements_end() const { return getElements().end(); }\n\n  /// A lightweight wrapper around an expression operand.\n  ///\n  /// TODO: Store arguments directly and change \\a DIExpression to store a\n  /// range of these.\n  class ExprOperand {\n    const uint64_t *Op = nullptr;\n\n  public:\n    ExprOperand() = default;\n    explicit ExprOperand(const uint64_t *Op) : Op(Op) {}\n\n    const uint64_t *get() const { return Op; }\n\n    /// Get the operand code.\n    uint64_t getOp() const { return *Op; }\n\n    /// Get an argument to the operand.\n    ///\n    /// Never returns the operand itself.\n    uint64_t getArg(unsigned I) const { return Op[I + 1]; }\n\n    unsigned getNumArgs() const { return getSize() - 1; }\n\n    /// Return the size of the operand.\n    ///\n    /// Return the number of elements in the operand (1 + args).\n    unsigned getSize() const;\n\n    /// Append the elements of this operand to \\p V.\n    void appendToVector(SmallVectorImpl<uint64_t> &V) const {\n      V.append(get(), get() + getSize());\n    }\n  };\n\n  /// An iterator for expression operands.\n  class expr_op_iterator\n      : public std::iterator<std::input_iterator_tag, ExprOperand> {\n    ExprOperand Op;\n\n  public:\n    expr_op_iterator() = default;\n    explicit expr_op_iterator(element_iterator I) : Op(I) {}\n\n    element_iterator getBase() const { return Op.get(); }\n    const ExprOperand &operator*() const { return Op; }\n    const ExprOperand *operator->() const { return &Op; }\n\n    expr_op_iterator &operator++() {\n      increment();\n      return *this;\n    }\n    expr_op_iterator operator++(int) {\n      expr_op_iterator T(*this);\n      increment();\n      return T;\n    }\n\n    /// Get the next iterator.\n    ///\n    /// \\a std::next() doesn't work because this is technically an\n    /// input_iterator, but it's a perfectly valid operation.  This is an\n    /// accessor to provide the same functionality.\n    expr_op_iterator getNext() const { return ++expr_op_iterator(*this); }\n\n    bool operator==(const expr_op_iterator &X) const {\n      return getBase() == X.getBase();\n    }\n    bool operator!=(const expr_op_iterator &X) const {\n      return getBase() != X.getBase();\n    }\n\n  private:\n    void increment() { Op = ExprOperand(getBase() + Op.getSize()); }\n  };\n\n  /// Visit the elements via ExprOperand wrappers.\n  ///\n  /// These range iterators visit elements through \\a ExprOperand wrappers.\n  /// This is not guaranteed to be a valid range unless \\a isValid() gives \\c\n  /// true.\n  ///\n  /// \\pre \\a isValid() gives \\c true.\n  /// @{\n  expr_op_iterator expr_op_begin() const {\n    return expr_op_iterator(elements_begin());\n  }\n  expr_op_iterator expr_op_end() const {\n    return expr_op_iterator(elements_end());\n  }\n  iterator_range<expr_op_iterator> expr_ops() const {\n    return {expr_op_begin(), expr_op_end()};\n  }\n  /// @}\n\n  bool isValid() const;\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIExpressionKind;\n  }\n\n  /// Return whether the first element a DW_OP_deref.\n  bool startsWithDeref() const {\n    return getNumElements() > 0 && getElement(0) == dwarf::DW_OP_deref;\n  }\n\n  /// Holds the characteristics of one fragment of a larger variable.\n  struct FragmentInfo {\n    uint64_t SizeInBits;\n    uint64_t OffsetInBits;\n  };\n\n  /// Retrieve the details of this fragment expression.\n  static Optional<FragmentInfo> getFragmentInfo(expr_op_iterator Start,\n                                                expr_op_iterator End);\n\n  /// Retrieve the details of this fragment expression.\n  Optional<FragmentInfo> getFragmentInfo() const {\n    return getFragmentInfo(expr_op_begin(), expr_op_end());\n  }\n\n  /// Return whether this is a piece of an aggregate variable.\n  bool isFragment() const { return getFragmentInfo().hasValue(); }\n\n  /// Return whether this is an implicit location description.\n  bool isImplicit() const;\n\n  /// Return whether the location is computed on the expression stack, meaning\n  /// it cannot be a simple register location.\n  bool isComplex() const;\n\n  /// Append \\p Ops with operations to apply the \\p Offset.\n  static void appendOffset(SmallVectorImpl<uint64_t> &Ops, int64_t Offset);\n\n  /// If this is a constant offset, extract it. If there is no expression,\n  /// return true with an offset of zero.\n  bool extractIfOffset(int64_t &Offset) const;\n\n  /// Checks if the last 4 elements of the expression are DW_OP_constu <DWARF\n  /// Address Space> DW_OP_swap DW_OP_xderef and extracts the <DWARF Address\n  /// Space>.\n  static const DIExpression *extractAddressClass(const DIExpression *Expr,\n                                                 unsigned &AddrClass);\n\n  /// Used for DIExpression::prepend.\n  enum PrependOps : uint8_t {\n    ApplyOffset = 0,\n    DerefBefore = 1 << 0,\n    DerefAfter = 1 << 1,\n    StackValue = 1 << 2,\n    EntryValue = 1 << 3\n  };\n\n  /// Prepend \\p DIExpr with a deref and offset operation and optionally turn it\n  /// into a stack value or/and an entry value.\n  static DIExpression *prepend(const DIExpression *Expr, uint8_t Flags,\n                               int64_t Offset = 0);\n\n  /// Prepend \\p DIExpr with the given opcodes and optionally turn it into a\n  /// stack value.\n  static DIExpression *prependOpcodes(const DIExpression *Expr,\n                                      SmallVectorImpl<uint64_t> &Ops,\n                                      bool StackValue = false,\n                                      bool EntryValue = false);\n\n  /// Append the opcodes \\p Ops to \\p DIExpr. Unlike \\ref appendToStack, the\n  /// returned expression is a stack value only if \\p DIExpr is a stack value.\n  /// If \\p DIExpr describes a fragment, the returned expression will describe\n  /// the same fragment.\n  static DIExpression *append(const DIExpression *Expr, ArrayRef<uint64_t> Ops);\n\n  /// Convert \\p DIExpr into a stack value if it isn't one already by appending\n  /// DW_OP_deref if needed, and appending \\p Ops to the resulting expression.\n  /// If \\p DIExpr describes a fragment, the returned expression will describe\n  /// the same fragment.\n  static DIExpression *appendToStack(const DIExpression *Expr,\n                                     ArrayRef<uint64_t> Ops);\n\n  /// Create a copy of \\p Expr by appending the given list of \\p Ops to each\n  /// instance of the operand `DW_OP_LLVM_arg, \\p ArgNo`. This is used to\n  /// modify a specific location used by \\p Expr, such as when salvaging that\n  /// location.\n  static DIExpression *appendOpsToArg(const DIExpression *Expr,\n                                      ArrayRef<uint64_t> Ops, unsigned ArgNo,\n                                      bool StackValue = false);\n\n  /// Create a copy of \\p Expr with each instance of\n  /// `DW_OP_LLVM_arg, \\p OldArg` replaced with `DW_OP_LLVM_arg, \\p NewArg`,\n  /// and each instance of `DW_OP_LLVM_arg, Arg` with `DW_OP_LLVM_arg, Arg - 1`\n  /// for all Arg > \\p OldArg.\n  /// This is used when replacing one of the operands of a debug value list\n  /// with another operand in the same list and deleting the old operand.\n  static DIExpression *replaceArg(const DIExpression *Expr, uint64_t OldArg,\n                                  uint64_t NewArg);\n\n  /// Create a DIExpression to describe one part of an aggregate variable that\n  /// is fragmented across multiple Values. The DW_OP_LLVM_fragment operation\n  /// will be appended to the elements of \\c Expr. If \\c Expr already contains\n  /// a \\c DW_OP_LLVM_fragment \\c OffsetInBits is interpreted as an offset\n  /// into the existing fragment.\n  ///\n  /// \\param OffsetInBits Offset of the piece in bits.\n  /// \\param SizeInBits   Size of the piece in bits.\n  /// \\return             Creating a fragment expression may fail if \\c Expr\n  ///                     contains arithmetic operations that would be truncated.\n  static Optional<DIExpression *>\n  createFragmentExpression(const DIExpression *Expr, unsigned OffsetInBits,\n                           unsigned SizeInBits);\n\n  /// Determine the relative position of the fragments passed in.\n  /// Returns -1 if this is entirely before Other, 0 if this and Other overlap,\n  /// 1 if this is entirely after Other.\n  static int fragmentCmp(const FragmentInfo &A, const FragmentInfo &B) {\n    uint64_t l1 = A.OffsetInBits;\n    uint64_t l2 = B.OffsetInBits;\n    uint64_t r1 = l1 + A.SizeInBits;\n    uint64_t r2 = l2 + B.SizeInBits;\n    if (r1 <= l2)\n      return -1;\n    else if (r2 <= l1)\n      return 1;\n    else\n      return 0;\n  }\n\n  using ExtOps = std::array<uint64_t, 6>;\n\n  /// Returns the ops for a zero- or sign-extension in a DIExpression.\n  static ExtOps getExtOps(unsigned FromSize, unsigned ToSize, bool Signed);\n\n  /// Append a zero- or sign-extension to \\p Expr. Converts the expression to a\n  /// stack value if it isn't one already.\n  static DIExpression *appendExt(const DIExpression *Expr, unsigned FromSize,\n                                 unsigned ToSize, bool Signed);\n\n  /// Check if fragments overlap between a pair of FragmentInfos.\n  static bool fragmentsOverlap(const FragmentInfo &A, const FragmentInfo &B) {\n    return fragmentCmp(A, B) == 0;\n  }\n\n  /// Determine the relative position of the fragments described by this\n  /// DIExpression and \\p Other. Calls static fragmentCmp implementation.\n  int fragmentCmp(const DIExpression *Other) const {\n    auto Fragment1 = *getFragmentInfo();\n    auto Fragment2 = *Other->getFragmentInfo();\n    return fragmentCmp(Fragment1, Fragment2);\n  }\n\n  /// Check if fragments overlap between this DIExpression and \\p Other.\n  bool fragmentsOverlap(const DIExpression *Other) const {\n    if (!isFragment() || !Other->isFragment())\n      return true;\n    return fragmentCmp(Other) == 0;\n  }\n\n  /// Check if the expression consists of exactly one entry value operand.\n  /// (This is the only configuration of entry values that is supported.)\n  bool isEntryValue() const {\n    return getNumElements() > 0 &&\n           getElement(0) == dwarf::DW_OP_LLVM_entry_value;\n  }\n};\n\ninline bool operator==(const DIExpression::FragmentInfo &A,\n                       const DIExpression::FragmentInfo &B) {\n  return std::tie(A.SizeInBits, A.OffsetInBits) ==\n         std::tie(B.SizeInBits, B.OffsetInBits);\n}\n\ninline bool operator<(const DIExpression::FragmentInfo &A,\n                      const DIExpression::FragmentInfo &B) {\n  return std::tie(A.SizeInBits, A.OffsetInBits) <\n         std::tie(B.SizeInBits, B.OffsetInBits);\n}\n\ntemplate <> struct DenseMapInfo<DIExpression::FragmentInfo> {\n  using FragInfo = DIExpression::FragmentInfo;\n  static const uint64_t MaxVal = std::numeric_limits<uint64_t>::max();\n\n  static inline FragInfo getEmptyKey() { return {MaxVal, MaxVal}; }\n\n  static inline FragInfo getTombstoneKey() { return {MaxVal - 1, MaxVal - 1}; }\n\n  static unsigned getHashValue(const FragInfo &Frag) {\n    return (Frag.SizeInBits & 0xffff) << 16 | (Frag.OffsetInBits & 0xffff);\n  }\n\n  static bool isEqual(const FragInfo &A, const FragInfo &B) { return A == B; }\n};\n\n/// Global variables.\n///\n/// TODO: Remove DisplayName.  It's always equal to Name.\nclass DIGlobalVariable : public DIVariable {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  bool IsLocalToUnit;\n  bool IsDefinition;\n\n  DIGlobalVariable(LLVMContext &C, StorageType Storage, unsigned Line,\n                   bool IsLocalToUnit, bool IsDefinition, uint32_t AlignInBits,\n                   ArrayRef<Metadata *> Ops)\n      : DIVariable(C, DIGlobalVariableKind, Storage, Line, Ops, AlignInBits),\n        IsLocalToUnit(IsLocalToUnit), IsDefinition(IsDefinition) {}\n  ~DIGlobalVariable() = default;\n\n  static DIGlobalVariable *\n  getImpl(LLVMContext &Context, DIScope *Scope, StringRef Name,\n          StringRef LinkageName, DIFile *File, unsigned Line, DIType *Type,\n          bool IsLocalToUnit, bool IsDefinition,\n          DIDerivedType *StaticDataMemberDeclaration, MDTuple *TemplateParams,\n          uint32_t AlignInBits, StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name),\n                   getCanonicalMDString(Context, LinkageName), File, Line, Type,\n                   IsLocalToUnit, IsDefinition, StaticDataMemberDeclaration,\n                   cast_or_null<Metadata>(TemplateParams), AlignInBits, Storage,\n                   ShouldCreate);\n  }\n  static DIGlobalVariable *\n  getImpl(LLVMContext &Context, Metadata *Scope, MDString *Name,\n          MDString *LinkageName, Metadata *File, unsigned Line, Metadata *Type,\n          bool IsLocalToUnit, bool IsDefinition,\n          Metadata *StaticDataMemberDeclaration, Metadata *TemplateParams,\n          uint32_t AlignInBits, StorageType Storage, bool ShouldCreate = true);\n\n  TempDIGlobalVariable cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(), getLinkageName(),\n                        getFile(), getLine(), getType(), isLocalToUnit(),\n                        isDefinition(), getStaticDataMemberDeclaration(),\n                        getTemplateParams(), getAlignInBits());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIGlobalVariable,\n                    (DIScope * Scope, StringRef Name, StringRef LinkageName,\n                     DIFile *File, unsigned Line, DIType *Type,\n                     bool IsLocalToUnit, bool IsDefinition,\n                     DIDerivedType *StaticDataMemberDeclaration,\n                     MDTuple *TemplateParams, uint32_t AlignInBits),\n                    (Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit,\n                     IsDefinition, StaticDataMemberDeclaration, TemplateParams,\n                     AlignInBits))\n  DEFINE_MDNODE_GET(DIGlobalVariable,\n                    (Metadata * Scope, MDString *Name, MDString *LinkageName,\n                     Metadata *File, unsigned Line, Metadata *Type,\n                     bool IsLocalToUnit, bool IsDefinition,\n                     Metadata *StaticDataMemberDeclaration,\n                     Metadata *TemplateParams, uint32_t AlignInBits),\n                    (Scope, Name, LinkageName, File, Line, Type, IsLocalToUnit,\n                     IsDefinition, StaticDataMemberDeclaration, TemplateParams,\n                     AlignInBits))\n\n  TempDIGlobalVariable clone() const { return cloneImpl(); }\n\n  bool isLocalToUnit() const { return IsLocalToUnit; }\n  bool isDefinition() const { return IsDefinition; }\n  StringRef getDisplayName() const { return getStringOperand(4); }\n  StringRef getLinkageName() const { return getStringOperand(5); }\n  DIDerivedType *getStaticDataMemberDeclaration() const {\n    return cast_or_null<DIDerivedType>(getRawStaticDataMemberDeclaration());\n  }\n\n  MDString *getRawLinkageName() const { return getOperandAs<MDString>(5); }\n  Metadata *getRawStaticDataMemberDeclaration() const { return getOperand(6); }\n  Metadata *getRawTemplateParams() const { return getOperand(7); }\n  MDTuple *getTemplateParams() const { return getOperandAs<MDTuple>(7); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIGlobalVariableKind;\n  }\n};\n\nclass DICommonBlock : public DIScope {\n  unsigned LineNo;\n\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DICommonBlock(LLVMContext &Context, StorageType Storage, unsigned LineNo,\n                ArrayRef<Metadata *> Ops)\n      : DIScope(Context, DICommonBlockKind, Storage, dwarf::DW_TAG_common_block,\n                Ops), LineNo(LineNo) {}\n\n  static DICommonBlock *getImpl(LLVMContext &Context, DIScope *Scope,\n                                DIGlobalVariable *Decl, StringRef Name,\n                                DIFile *File, unsigned LineNo,\n                                StorageType Storage,\n                                bool ShouldCreate = true) {\n    return getImpl(Context, Scope, Decl, getCanonicalMDString(Context, Name),\n                   File, LineNo, Storage, ShouldCreate);\n  }\n  static DICommonBlock *getImpl(LLVMContext &Context, Metadata *Scope,\n                                Metadata *Decl, MDString *Name, Metadata *File,\n                                unsigned LineNo, \n                                StorageType Storage, bool ShouldCreate = true);\n\n  TempDICommonBlock cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getDecl(), getName(),\n                        getFile(), getLineNo());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DICommonBlock,\n                    (DIScope *Scope, DIGlobalVariable *Decl, StringRef Name,\n                     DIFile *File, unsigned LineNo),\n                    (Scope, Decl, Name, File, LineNo))\n  DEFINE_MDNODE_GET(DICommonBlock,\n                    (Metadata *Scope, Metadata *Decl, MDString *Name,\n                     Metadata *File, unsigned LineNo),\n                    (Scope, Decl, Name, File, LineNo))\n\n  TempDICommonBlock clone() const { return cloneImpl(); }\n\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  DIGlobalVariable *getDecl() const {\n    return cast_or_null<DIGlobalVariable>(getRawDecl());\n  }\n  StringRef getName() const { return getStringOperand(2); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n  unsigned getLineNo() const { return LineNo; }\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  Metadata *getRawDecl() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n  Metadata *getRawFile() const { return getOperand(3); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DICommonBlockKind;\n  }\n};\n\n/// Local variable.\n///\n/// TODO: Split up flags.\nclass DILocalVariable : public DIVariable {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Arg : 16;\n  DIFlags Flags;\n\n  DILocalVariable(LLVMContext &C, StorageType Storage, unsigned Line,\n                  unsigned Arg, DIFlags Flags, uint32_t AlignInBits,\n                  ArrayRef<Metadata *> Ops)\n      : DIVariable(C, DILocalVariableKind, Storage, Line, Ops, AlignInBits),\n        Arg(Arg), Flags(Flags) {\n    assert(Arg < (1 << 16) && \"DILocalVariable: Arg out of range\");\n  }\n  ~DILocalVariable() = default;\n\n  static DILocalVariable *getImpl(LLVMContext &Context, DIScope *Scope,\n                                  StringRef Name, DIFile *File, unsigned Line,\n                                  DIType *Type, unsigned Arg, DIFlags Flags,\n                                  uint32_t AlignInBits, StorageType Storage,\n                                  bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name), File,\n                   Line, Type, Arg, Flags, AlignInBits, Storage, ShouldCreate);\n  }\n  static DILocalVariable *getImpl(LLVMContext &Context, Metadata *Scope,\n                                  MDString *Name, Metadata *File, unsigned Line,\n                                  Metadata *Type, unsigned Arg, DIFlags Flags,\n                                  uint32_t AlignInBits, StorageType Storage,\n                                  bool ShouldCreate = true);\n\n  TempDILocalVariable cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(), getFile(),\n                        getLine(), getType(), getArg(), getFlags(),\n                        getAlignInBits());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DILocalVariable,\n                    (DILocalScope * Scope, StringRef Name, DIFile *File,\n                     unsigned Line, DIType *Type, unsigned Arg, DIFlags Flags,\n                     uint32_t AlignInBits),\n                    (Scope, Name, File, Line, Type, Arg, Flags, AlignInBits))\n  DEFINE_MDNODE_GET(DILocalVariable,\n                    (Metadata * Scope, MDString *Name, Metadata *File,\n                     unsigned Line, Metadata *Type, unsigned Arg,\n                     DIFlags Flags, uint32_t AlignInBits),\n                    (Scope, Name, File, Line, Type, Arg, Flags, AlignInBits))\n\n  TempDILocalVariable clone() const { return cloneImpl(); }\n\n  /// Get the local scope for this variable.\n  ///\n  /// Variables must be defined in a local scope.\n  DILocalScope *getScope() const {\n    return cast<DILocalScope>(DIVariable::getScope());\n  }\n\n  bool isParameter() const { return Arg; }\n  unsigned getArg() const { return Arg; }\n  DIFlags getFlags() const { return Flags; }\n\n  bool isArtificial() const { return getFlags() & FlagArtificial; }\n  bool isObjectPointer() const { return getFlags() & FlagObjectPointer; }\n\n  /// Check that a location is valid for this variable.\n  ///\n  /// Check that \\c DL exists, is in the same subprogram, and has the same\n  /// inlined-at location as \\c this.  (Otherwise, it's not a valid attachment\n  /// to a \\a DbgInfoIntrinsic.)\n  bool isValidLocationForIntrinsic(const DILocation *DL) const {\n    return DL && getScope()->getSubprogram() == DL->getScope()->getSubprogram();\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILocalVariableKind;\n  }\n};\n\n/// Label.\n///\nclass DILabel : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n\n  DILabel(LLVMContext &C, StorageType Storage, unsigned Line,\n          ArrayRef<Metadata *> Ops)\n      : DINode(C, DILabelKind, Storage, dwarf::DW_TAG_label, Ops), Line(Line) {}\n  ~DILabel() = default;\n\n  static DILabel *getImpl(LLVMContext &Context, DIScope *Scope,\n                          StringRef Name, DIFile *File, unsigned Line,\n                          StorageType Storage,\n                          bool ShouldCreate = true) {\n    return getImpl(Context, Scope, getCanonicalMDString(Context, Name), File,\n                   Line, Storage, ShouldCreate);\n  }\n  static DILabel *getImpl(LLVMContext &Context, Metadata *Scope,\n                          MDString *Name, Metadata *File, unsigned Line,\n                          StorageType Storage,\n                          bool ShouldCreate = true);\n\n  TempDILabel cloneImpl() const {\n    return getTemporary(getContext(), getScope(), getName(), getFile(),\n                        getLine());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DILabel,\n                    (DILocalScope * Scope, StringRef Name, DIFile *File,\n                     unsigned Line),\n                    (Scope, Name, File, Line))\n  DEFINE_MDNODE_GET(DILabel,\n                    (Metadata * Scope, MDString *Name, Metadata *File,\n                     unsigned Line),\n                    (Scope, Name, File, Line))\n\n  TempDILabel clone() const { return cloneImpl(); }\n\n  /// Get the local scope for this label.\n  ///\n  /// Labels must be defined in a local scope.\n  DILocalScope *getScope() const {\n    return cast_or_null<DILocalScope>(getRawScope());\n  }\n  unsigned getLine() const { return Line; }\n  StringRef getName() const { return getStringOperand(1); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  MDString *getRawName() const { return getOperandAs<MDString>(1); }\n  Metadata *getRawFile() const { return getOperand(2); }\n\n  /// Check that a location is valid for this label.\n  ///\n  /// Check that \\c DL exists, is in the same subprogram, and has the same\n  /// inlined-at location as \\c this.  (Otherwise, it's not a valid attachment\n  /// to a \\a DbgInfoIntrinsic.)\n  bool isValidLocationForIntrinsic(const DILocation *DL) const {\n    return DL && getScope()->getSubprogram() == DL->getScope()->getSubprogram();\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DILabelKind;\n  }\n};\n\nclass DIObjCProperty : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n  unsigned Attributes;\n\n  DIObjCProperty(LLVMContext &C, StorageType Storage, unsigned Line,\n                 unsigned Attributes, ArrayRef<Metadata *> Ops)\n      : DINode(C, DIObjCPropertyKind, Storage, dwarf::DW_TAG_APPLE_property,\n               Ops),\n        Line(Line), Attributes(Attributes) {}\n  ~DIObjCProperty() = default;\n\n  static DIObjCProperty *\n  getImpl(LLVMContext &Context, StringRef Name, DIFile *File, unsigned Line,\n          StringRef GetterName, StringRef SetterName, unsigned Attributes,\n          DIType *Type, StorageType Storage, bool ShouldCreate = true) {\n    return getImpl(Context, getCanonicalMDString(Context, Name), File, Line,\n                   getCanonicalMDString(Context, GetterName),\n                   getCanonicalMDString(Context, SetterName), Attributes, Type,\n                   Storage, ShouldCreate);\n  }\n  static DIObjCProperty *getImpl(LLVMContext &Context, MDString *Name,\n                                 Metadata *File, unsigned Line,\n                                 MDString *GetterName, MDString *SetterName,\n                                 unsigned Attributes, Metadata *Type,\n                                 StorageType Storage, bool ShouldCreate = true);\n\n  TempDIObjCProperty cloneImpl() const {\n    return getTemporary(getContext(), getName(), getFile(), getLine(),\n                        getGetterName(), getSetterName(), getAttributes(),\n                        getType());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIObjCProperty,\n                    (StringRef Name, DIFile *File, unsigned Line,\n                     StringRef GetterName, StringRef SetterName,\n                     unsigned Attributes, DIType *Type),\n                    (Name, File, Line, GetterName, SetterName, Attributes,\n                     Type))\n  DEFINE_MDNODE_GET(DIObjCProperty,\n                    (MDString * Name, Metadata *File, unsigned Line,\n                     MDString *GetterName, MDString *SetterName,\n                     unsigned Attributes, Metadata *Type),\n                    (Name, File, Line, GetterName, SetterName, Attributes,\n                     Type))\n\n  TempDIObjCProperty clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return Line; }\n  unsigned getAttributes() const { return Attributes; }\n  StringRef getName() const { return getStringOperand(0); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n  StringRef getGetterName() const { return getStringOperand(2); }\n  StringRef getSetterName() const { return getStringOperand(3); }\n  DIType *getType() const { return cast_or_null<DIType>(getRawType()); }\n\n  StringRef getFilename() const {\n    if (auto *F = getFile())\n      return F->getFilename();\n    return \"\";\n  }\n\n  StringRef getDirectory() const {\n    if (auto *F = getFile())\n      return F->getDirectory();\n    return \"\";\n  }\n\n  MDString *getRawName() const { return getOperandAs<MDString>(0); }\n  Metadata *getRawFile() const { return getOperand(1); }\n  MDString *getRawGetterName() const { return getOperandAs<MDString>(2); }\n  MDString *getRawSetterName() const { return getOperandAs<MDString>(3); }\n  Metadata *getRawType() const { return getOperand(4); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIObjCPropertyKind;\n  }\n};\n\n/// An imported module (C++ using directive or similar).\nclass DIImportedEntity : public DINode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n\n  DIImportedEntity(LLVMContext &C, StorageType Storage, unsigned Tag,\n                   unsigned Line, ArrayRef<Metadata *> Ops)\n      : DINode(C, DIImportedEntityKind, Storage, Tag, Ops), Line(Line) {}\n  ~DIImportedEntity() = default;\n\n  static DIImportedEntity *getImpl(LLVMContext &Context, unsigned Tag,\n                                   DIScope *Scope, DINode *Entity, DIFile *File,\n                                   unsigned Line, StringRef Name,\n                                   StorageType Storage,\n                                   bool ShouldCreate = true) {\n    return getImpl(Context, Tag, Scope, Entity, File, Line,\n                   getCanonicalMDString(Context, Name), Storage, ShouldCreate);\n  }\n  static DIImportedEntity *getImpl(LLVMContext &Context, unsigned Tag,\n                                   Metadata *Scope, Metadata *Entity,\n                                   Metadata *File, unsigned Line,\n                                   MDString *Name, StorageType Storage,\n                                   bool ShouldCreate = true);\n\n  TempDIImportedEntity cloneImpl() const {\n    return getTemporary(getContext(), getTag(), getScope(), getEntity(),\n                        getFile(), getLine(), getName());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIImportedEntity,\n                    (unsigned Tag, DIScope *Scope, DINode *Entity, DIFile *File,\n                     unsigned Line, StringRef Name = \"\"),\n                    (Tag, Scope, Entity, File, Line, Name))\n  DEFINE_MDNODE_GET(DIImportedEntity,\n                    (unsigned Tag, Metadata *Scope, Metadata *Entity,\n                     Metadata *File, unsigned Line, MDString *Name),\n                    (Tag, Scope, Entity, File, Line, Name))\n\n  TempDIImportedEntity clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return Line; }\n  DIScope *getScope() const { return cast_or_null<DIScope>(getRawScope()); }\n  DINode *getEntity() const { return cast_or_null<DINode>(getRawEntity()); }\n  StringRef getName() const { return getStringOperand(2); }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n\n  Metadata *getRawScope() const { return getOperand(0); }\n  Metadata *getRawEntity() const { return getOperand(1); }\n  MDString *getRawName() const { return getOperandAs<MDString>(2); }\n  Metadata *getRawFile() const { return getOperand(3); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIImportedEntityKind;\n  }\n};\n\n/// A pair of DIGlobalVariable and DIExpression.\nclass DIGlobalVariableExpression : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  DIGlobalVariableExpression(LLVMContext &C, StorageType Storage,\n                             ArrayRef<Metadata *> Ops)\n      : MDNode(C, DIGlobalVariableExpressionKind, Storage, Ops) {}\n  ~DIGlobalVariableExpression() = default;\n\n  static DIGlobalVariableExpression *\n  getImpl(LLVMContext &Context, Metadata *Variable, Metadata *Expression,\n          StorageType Storage, bool ShouldCreate = true);\n\n  TempDIGlobalVariableExpression cloneImpl() const {\n    return getTemporary(getContext(), getVariable(), getExpression());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIGlobalVariableExpression,\n                    (Metadata * Variable, Metadata *Expression),\n                    (Variable, Expression))\n\n  TempDIGlobalVariableExpression clone() const { return cloneImpl(); }\n\n  Metadata *getRawVariable() const { return getOperand(0); }\n\n  DIGlobalVariable *getVariable() const {\n    return cast_or_null<DIGlobalVariable>(getRawVariable());\n  }\n\n  Metadata *getRawExpression() const { return getOperand(1); }\n\n  DIExpression *getExpression() const {\n    return cast<DIExpression>(getRawExpression());\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIGlobalVariableExpressionKind;\n  }\n};\n\n/// Macro Info DWARF-like metadata node.\n///\n/// A metadata node with a DWARF macro info (i.e., a constant named\n/// \\c DW_MACINFO_*, defined in llvm/BinaryFormat/Dwarf.h).  Called \\a\n/// DIMacroNode\n/// because it's potentially used for non-DWARF output.\nclass DIMacroNode : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\nprotected:\n  DIMacroNode(LLVMContext &C, unsigned ID, StorageType Storage, unsigned MIType,\n              ArrayRef<Metadata *> Ops1, ArrayRef<Metadata *> Ops2 = None)\n      : MDNode(C, ID, Storage, Ops1, Ops2) {\n    assert(MIType < 1u << 16);\n    SubclassData16 = MIType;\n  }\n  ~DIMacroNode() = default;\n\n  template <class Ty> Ty *getOperandAs(unsigned I) const {\n    return cast_or_null<Ty>(getOperand(I));\n  }\n\n  StringRef getStringOperand(unsigned I) const {\n    if (auto *S = getOperandAs<MDString>(I))\n      return S->getString();\n    return StringRef();\n  }\n\n  static MDString *getCanonicalMDString(LLVMContext &Context, StringRef S) {\n    if (S.empty())\n      return nullptr;\n    return MDString::get(Context, S);\n  }\n\npublic:\n  unsigned getMacinfoType() const { return SubclassData16; }\n\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n    case DIMacroKind:\n    case DIMacroFileKind:\n      return true;\n    }\n  }\n};\n\nclass DIMacro : public DIMacroNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n\n  DIMacro(LLVMContext &C, StorageType Storage, unsigned MIType, unsigned Line,\n          ArrayRef<Metadata *> Ops)\n      : DIMacroNode(C, DIMacroKind, Storage, MIType, Ops), Line(Line) {}\n  ~DIMacro() = default;\n\n  static DIMacro *getImpl(LLVMContext &Context, unsigned MIType, unsigned Line,\n                          StringRef Name, StringRef Value, StorageType Storage,\n                          bool ShouldCreate = true) {\n    return getImpl(Context, MIType, Line, getCanonicalMDString(Context, Name),\n                   getCanonicalMDString(Context, Value), Storage, ShouldCreate);\n  }\n  static DIMacro *getImpl(LLVMContext &Context, unsigned MIType, unsigned Line,\n                          MDString *Name, MDString *Value, StorageType Storage,\n                          bool ShouldCreate = true);\n\n  TempDIMacro cloneImpl() const {\n    return getTemporary(getContext(), getMacinfoType(), getLine(), getName(),\n                        getValue());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIMacro, (unsigned MIType, unsigned Line, StringRef Name,\n                              StringRef Value = \"\"),\n                    (MIType, Line, Name, Value))\n  DEFINE_MDNODE_GET(DIMacro, (unsigned MIType, unsigned Line, MDString *Name,\n                              MDString *Value),\n                    (MIType, Line, Name, Value))\n\n  TempDIMacro clone() const { return cloneImpl(); }\n\n  unsigned getLine() const { return Line; }\n\n  StringRef getName() const { return getStringOperand(0); }\n  StringRef getValue() const { return getStringOperand(1); }\n\n  MDString *getRawName() const { return getOperandAs<MDString>(0); }\n  MDString *getRawValue() const { return getOperandAs<MDString>(1); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIMacroKind;\n  }\n};\n\nclass DIMacroFile : public DIMacroNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  unsigned Line;\n\n  DIMacroFile(LLVMContext &C, StorageType Storage, unsigned MIType,\n              unsigned Line, ArrayRef<Metadata *> Ops)\n      : DIMacroNode(C, DIMacroFileKind, Storage, MIType, Ops), Line(Line) {}\n  ~DIMacroFile() = default;\n\n  static DIMacroFile *getImpl(LLVMContext &Context, unsigned MIType,\n                              unsigned Line, DIFile *File,\n                              DIMacroNodeArray Elements, StorageType Storage,\n                              bool ShouldCreate = true) {\n    return getImpl(Context, MIType, Line, static_cast<Metadata *>(File),\n                   Elements.get(), Storage, ShouldCreate);\n  }\n\n  static DIMacroFile *getImpl(LLVMContext &Context, unsigned MIType,\n                              unsigned Line, Metadata *File, Metadata *Elements,\n                              StorageType Storage, bool ShouldCreate = true);\n\n  TempDIMacroFile cloneImpl() const {\n    return getTemporary(getContext(), getMacinfoType(), getLine(), getFile(),\n                        getElements());\n  }\n\npublic:\n  DEFINE_MDNODE_GET(DIMacroFile, (unsigned MIType, unsigned Line, DIFile *File,\n                                  DIMacroNodeArray Elements),\n                    (MIType, Line, File, Elements))\n  DEFINE_MDNODE_GET(DIMacroFile, (unsigned MIType, unsigned Line,\n                                  Metadata *File, Metadata *Elements),\n                    (MIType, Line, File, Elements))\n\n  TempDIMacroFile clone() const { return cloneImpl(); }\n\n  void replaceElements(DIMacroNodeArray Elements) {\n#ifndef NDEBUG\n    for (DIMacroNode *Op : getElements())\n      assert(is_contained(Elements->operands(), Op) &&\n             \"Lost a macro node during macro node list replacement\");\n#endif\n    replaceOperandWith(1, Elements.get());\n  }\n\n  unsigned getLine() const { return Line; }\n  DIFile *getFile() const { return cast_or_null<DIFile>(getRawFile()); }\n\n  DIMacroNodeArray getElements() const {\n    return cast_or_null<MDTuple>(getRawElements());\n  }\n\n  Metadata *getRawFile() const { return getOperand(0); }\n  Metadata *getRawElements() const { return getOperand(1); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIMacroFileKind;\n  }\n};\n\n/// List of ValueAsMetadata, to be used as an argument to a dbg.value\n/// intrinsic.\nclass DIArgList : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n  using iterator = SmallVectorImpl<ValueAsMetadata *>::iterator;\n\n  SmallVector<ValueAsMetadata *, 4> Args;\n\n  DIArgList(LLVMContext &C, StorageType Storage,\n            ArrayRef<ValueAsMetadata *> Args)\n      : MDNode(C, DIArgListKind, Storage, None),\n        Args(Args.begin(), Args.end()) {\n    track();\n  }\n  ~DIArgList() { untrack(); }\n\n  static DIArgList *getImpl(LLVMContext &Context,\n                            ArrayRef<ValueAsMetadata *> Args,\n                            StorageType Storage, bool ShouldCreate = true);\n\n  TempDIArgList cloneImpl() const {\n    return getTemporary(getContext(), getArgs());\n  }\n\n  void track();\n  void untrack();\n  void dropAllReferences();\n\npublic:\n  DEFINE_MDNODE_GET(DIArgList, (ArrayRef<ValueAsMetadata *> Args), (Args))\n\n  TempDIArgList clone() const { return cloneImpl(); }\n\n  ArrayRef<ValueAsMetadata *> getArgs() const { return Args; }\n\n  iterator args_begin() { return Args.begin(); }\n  iterator args_end() { return Args.end(); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == DIArgListKind;\n  }\n\n  void handleChangedOperand(void *Ref, Metadata *New);\n};\n\n/// Identifies a unique instance of a variable.\n///\n/// Storage for identifying a potentially inlined instance of a variable,\n/// or a fragment thereof. This guarantees that exactly one variable instance\n/// may be identified by this class, even when that variable is a fragment of\n/// an aggregate variable and/or there is another inlined instance of the same\n/// source code variable nearby.\n/// This class does not necessarily uniquely identify that variable: it is\n/// possible that a DebugVariable with different parameters may point to the\n/// same variable instance, but not that one DebugVariable points to multiple\n/// variable instances.\nclass DebugVariable {\n  using FragmentInfo = DIExpression::FragmentInfo;\n\n  const DILocalVariable *Variable;\n  Optional<FragmentInfo> Fragment;\n  const DILocation *InlinedAt;\n\n  /// Fragment that will overlap all other fragments. Used as default when\n  /// caller demands a fragment.\n  static const FragmentInfo DefaultFragment;\n\npublic:\n  DebugVariable(const DILocalVariable *Var, Optional<FragmentInfo> FragmentInfo,\n                const DILocation *InlinedAt)\n      : Variable(Var), Fragment(FragmentInfo), InlinedAt(InlinedAt) {}\n\n  DebugVariable(const DILocalVariable *Var, const DIExpression *DIExpr,\n                const DILocation *InlinedAt)\n      : Variable(Var),\n        Fragment(DIExpr ? DIExpr->getFragmentInfo() : NoneType()),\n        InlinedAt(InlinedAt) {}\n\n  const DILocalVariable *getVariable() const { return Variable; }\n  Optional<FragmentInfo> getFragment() const { return Fragment; }\n  const DILocation *getInlinedAt() const { return InlinedAt; }\n\n  FragmentInfo getFragmentOrDefault() const {\n    return Fragment.getValueOr(DefaultFragment);\n  }\n\n  static bool isDefaultFragment(const FragmentInfo F) {\n    return F == DefaultFragment;\n  }\n\n  bool operator==(const DebugVariable &Other) const {\n    return std::tie(Variable, Fragment, InlinedAt) ==\n           std::tie(Other.Variable, Other.Fragment, Other.InlinedAt);\n  }\n\n  bool operator<(const DebugVariable &Other) const {\n    return std::tie(Variable, Fragment, InlinedAt) <\n           std::tie(Other.Variable, Other.Fragment, Other.InlinedAt);\n  }\n};\n\ntemplate <> struct DenseMapInfo<DebugVariable> {\n  using FragmentInfo = DIExpression::FragmentInfo;\n\n  /// Empty key: no key should be generated that has no DILocalVariable.\n  static inline DebugVariable getEmptyKey() {\n    return DebugVariable(nullptr, NoneType(), nullptr);\n  }\n\n  /// Difference in tombstone is that the Optional is meaningful.\n  static inline DebugVariable getTombstoneKey() {\n    return DebugVariable(nullptr, {{0, 0}}, nullptr);\n  }\n\n  static unsigned getHashValue(const DebugVariable &D) {\n    unsigned HV = 0;\n    const Optional<FragmentInfo> Fragment = D.getFragment();\n    if (Fragment)\n      HV = DenseMapInfo<FragmentInfo>::getHashValue(*Fragment);\n\n    return hash_combine(D.getVariable(), HV, D.getInlinedAt());\n  }\n\n  static bool isEqual(const DebugVariable &A, const DebugVariable &B) {\n    return A == B;\n  }\n};\n\n} // end namespace llvm\n\n#undef DEFINE_MDNODE_GET_UNPACK_IMPL\n#undef DEFINE_MDNODE_GET_UNPACK\n#undef DEFINE_MDNODE_GET\n\n#endif // LLVM_IR_DEBUGINFOMETADATA_H\n"}, "49": {"id": 49, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DerivedTypes.h", "content": "//===- llvm/DerivedTypes.h - Classes for handling data types ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declarations of classes that represent \"derived\n// types\".  These are things like \"arrays of x\" or \"structure of x, y, z\" or\n// \"function returning x taking (y,z) as parameters\", etc...\n//\n// The implementations of these classes live in the Type.cpp file.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_DERIVEDTYPES_H\n#define LLVM_IR_DERIVEDTYPES_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include <cassert>\n#include <cstdint>\n\nnamespace llvm {\n\nclass Value;\nclass APInt;\nclass LLVMContext;\n\n/// Class to represent integer types. Note that this class is also used to\n/// represent the built-in integer types: Int1Ty, Int8Ty, Int16Ty, Int32Ty and\n/// Int64Ty.\n/// Integer representation type\nclass IntegerType : public Type {\n  friend class LLVMContextImpl;\n\nprotected:\n  explicit IntegerType(LLVMContext &C, unsigned NumBits) : Type(C, IntegerTyID){\n    setSubclassData(NumBits);\n  }\n\npublic:\n  /// This enum is just used to hold constants we need for IntegerType.\n  enum {\n    MIN_INT_BITS = 1,        ///< Minimum number of bits that can be specified\n    MAX_INT_BITS = (1<<24)-1 ///< Maximum number of bits that can be specified\n      ///< Note that bit width is stored in the Type classes SubclassData field\n      ///< which has 24 bits. This yields a maximum bit width of 16,777,215\n      ///< bits.\n  };\n\n  /// This static method is the primary way of constructing an IntegerType.\n  /// If an IntegerType with the same NumBits value was previously instantiated,\n  /// that instance will be returned. Otherwise a new one will be created. Only\n  /// one instance with a given NumBits value is ever created.\n  /// Get or create an IntegerType instance.\n  static IntegerType *get(LLVMContext &C, unsigned NumBits);\n\n  /// Returns type twice as wide the input type.\n  IntegerType *getExtendedType() const {\n    return Type::getIntNTy(getContext(), 2 * getScalarSizeInBits());\n  }\n\n  /// Get the number of bits in this IntegerType\n  unsigned getBitWidth() const { return getSubclassData(); }\n\n  /// Return a bitmask with ones set for all of the bits that can be set by an\n  /// unsigned version of this type. This is 0xFF for i8, 0xFFFF for i16, etc.\n  uint64_t getBitMask() const {\n    return ~uint64_t(0UL) >> (64-getBitWidth());\n  }\n\n  /// Return a uint64_t with just the most significant bit set (the sign bit, if\n  /// the value is treated as a signed number).\n  uint64_t getSignBit() const {\n    return 1ULL << (getBitWidth()-1);\n  }\n\n  /// For example, this is 0xFF for an 8 bit integer, 0xFFFF for i16, etc.\n  /// @returns a bit mask with ones set for all the bits of this type.\n  /// Get a bit mask for this type.\n  APInt getMask() const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Type *T) {\n    return T->getTypeID() == IntegerTyID;\n  }\n};\n\nunsigned Type::getIntegerBitWidth() const {\n  return cast<IntegerType>(this)->getBitWidth();\n}\n\n/// Class to represent function types\n///\nclass FunctionType : public Type {\n  FunctionType(Type *Result, ArrayRef<Type*> Params, bool IsVarArgs);\n\npublic:\n  FunctionType(const FunctionType &) = delete;\n  FunctionType &operator=(const FunctionType &) = delete;\n\n  /// This static method is the primary way of constructing a FunctionType.\n  static FunctionType *get(Type *Result,\n                           ArrayRef<Type*> Params, bool isVarArg);\n\n  /// Create a FunctionType taking no parameters.\n  static FunctionType *get(Type *Result, bool isVarArg);\n\n  /// Return true if the specified type is valid as a return type.\n  static bool isValidReturnType(Type *RetTy);\n\n  /// Return true if the specified type is valid as an argument type.\n  static bool isValidArgumentType(Type *ArgTy);\n\n  bool isVarArg() const { return getSubclassData()!=0; }\n  Type *getReturnType() const { return ContainedTys[0]; }\n\n  using param_iterator = Type::subtype_iterator;\n\n  param_iterator param_begin() const { return ContainedTys + 1; }\n  param_iterator param_end() const { return &ContainedTys[NumContainedTys]; }\n  ArrayRef<Type *> params() const {\n    return makeArrayRef(param_begin(), param_end());\n  }\n\n  /// Parameter type accessors.\n  Type *getParamType(unsigned i) const { return ContainedTys[i+1]; }\n\n  /// Return the number of fixed parameters this function type requires.\n  /// This does not consider varargs.\n  unsigned getNumParams() const { return NumContainedTys - 1; }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Type *T) {\n    return T->getTypeID() == FunctionTyID;\n  }\n};\nstatic_assert(alignof(FunctionType) >= alignof(Type *),\n              \"Alignment sufficient for objects appended to FunctionType\");\n\nbool Type::isFunctionVarArg() const {\n  return cast<FunctionType>(this)->isVarArg();\n}\n\nType *Type::getFunctionParamType(unsigned i) const {\n  return cast<FunctionType>(this)->getParamType(i);\n}\n\nunsigned Type::getFunctionNumParams() const {\n  return cast<FunctionType>(this)->getNumParams();\n}\n\n/// A handy container for a FunctionType+Callee-pointer pair, which can be\n/// passed around as a single entity. This assists in replacing the use of\n/// PointerType::getElementType() to access the function's type, since that's\n/// slated for removal as part of the [opaque pointer types] project.\nclass FunctionCallee {\npublic:\n  // Allow implicit conversion from types which have a getFunctionType member\n  // (e.g. Function and InlineAsm).\n  template <typename T, typename U = decltype(&T::getFunctionType)>\n  FunctionCallee(T *Fn)\n      : FnTy(Fn ? Fn->getFunctionType() : nullptr), Callee(Fn) {}\n\n  FunctionCallee(FunctionType *FnTy, Value *Callee)\n      : FnTy(FnTy), Callee(Callee) {\n    assert((FnTy == nullptr) == (Callee == nullptr));\n  }\n\n  FunctionCallee(std::nullptr_t) {}\n\n  FunctionCallee() = default;\n\n  FunctionType *getFunctionType() { return FnTy; }\n\n  Value *getCallee() { return Callee; }\n\n  explicit operator bool() { return Callee; }\n\nprivate:\n  FunctionType *FnTy = nullptr;\n  Value *Callee = nullptr;\n};\n\n/// Class to represent struct types. There are two different kinds of struct\n/// types: Literal structs and Identified structs.\n///\n/// Literal struct types (e.g. { i32, i32 }) are uniqued structurally, and must\n/// always have a body when created.  You can get one of these by using one of\n/// the StructType::get() forms.\n///\n/// Identified structs (e.g. %foo or %42) may optionally have a name and are not\n/// uniqued.  The names for identified structs are managed at the LLVMContext\n/// level, so there can only be a single identified struct with a given name in\n/// a particular LLVMContext.  Identified structs may also optionally be opaque\n/// (have no body specified).  You get one of these by using one of the\n/// StructType::create() forms.\n///\n/// Independent of what kind of struct you have, the body of a struct type are\n/// laid out in memory consecutively with the elements directly one after the\n/// other (if the struct is packed) or (if not packed) with padding between the\n/// elements as defined by DataLayout (which is required to match what the code\n/// generator for a target expects).\n///\nclass StructType : public Type {\n  StructType(LLVMContext &C) : Type(C, StructTyID) {}\n\n  enum {\n    /// This is the contents of the SubClassData field.\n    SCDB_HasBody = 1,\n    SCDB_Packed = 2,\n    SCDB_IsLiteral = 4,\n    SCDB_IsSized = 8\n  };\n\n  /// For a named struct that actually has a name, this is a pointer to the\n  /// symbol table entry (maintained by LLVMContext) for the struct.\n  /// This is null if the type is an literal struct or if it is a identified\n  /// type that has an empty name.\n  void *SymbolTableEntry = nullptr;\n\npublic:\n  StructType(const StructType &) = delete;\n  StructType &operator=(const StructType &) = delete;\n\n  /// This creates an identified struct.\n  static StructType *create(LLVMContext &Context, StringRef Name);\n  static StructType *create(LLVMContext &Context);\n\n  static StructType *create(ArrayRef<Type *> Elements, StringRef Name,\n                            bool isPacked = false);\n  static StructType *create(ArrayRef<Type *> Elements);\n  static StructType *create(LLVMContext &Context, ArrayRef<Type *> Elements,\n                            StringRef Name, bool isPacked = false);\n  static StructType *create(LLVMContext &Context, ArrayRef<Type *> Elements);\n  template <class... Tys>\n  static std::enable_if_t<are_base_of<Type, Tys...>::value, StructType *>\n  create(StringRef Name, Type *elt1, Tys *... elts) {\n    assert(elt1 && \"Cannot create a struct type with no elements with this\");\n    SmallVector<llvm::Type *, 8> StructFields({elt1, elts...});\n    return create(StructFields, Name);\n  }\n\n  /// This static method is the primary way to create a literal StructType.\n  static StructType *get(LLVMContext &Context, ArrayRef<Type*> Elements,\n                         bool isPacked = false);\n\n  /// Create an empty structure type.\n  static StructType *get(LLVMContext &Context, bool isPacked = false);\n\n  /// This static method is a convenience method for creating structure types by\n  /// specifying the elements as arguments. Note that this method always returns\n  /// a non-packed struct, and requires at least one element type.\n  template <class... Tys>\n  static std::enable_if_t<are_base_of<Type, Tys...>::value, StructType *>\n  get(Type *elt1, Tys *... elts) {\n    assert(elt1 && \"Cannot create a struct type with no elements with this\");\n    LLVMContext &Ctx = elt1->getContext();\n    SmallVector<llvm::Type *, 8> StructFields({elt1, elts...});\n    return llvm::StructType::get(Ctx, StructFields);\n  }\n\n  /// Return the type with the specified name, or null if there is none by that\n  /// name.\n  static StructType *getTypeByName(LLVMContext &C, StringRef Name);\n\n  bool isPacked() const { return (getSubclassData() & SCDB_Packed) != 0; }\n\n  /// Return true if this type is uniqued by structural equivalence, false if it\n  /// is a struct definition.\n  bool isLiteral() const { return (getSubclassData() & SCDB_IsLiteral) != 0; }\n\n  /// Return true if this is a type with an identity that has no body specified\n  /// yet. These prints as 'opaque' in .ll files.\n  bool isOpaque() const { return (getSubclassData() & SCDB_HasBody) == 0; }\n\n  /// isSized - Return true if this is a sized type.\n  bool isSized(SmallPtrSetImpl<Type *> *Visited = nullptr) const;\n\n  /// Returns true if this struct contains a scalable vector.\n  bool containsScalableVectorType() const;\n\n  /// Return true if this is a named struct that has a non-empty name.\n  bool hasName() const { return SymbolTableEntry != nullptr; }\n\n  /// Return the name for this struct type if it has an identity.\n  /// This may return an empty string for an unnamed struct type.  Do not call\n  /// this on an literal type.\n  StringRef getName() const;\n\n  /// Change the name of this type to the specified name, or to a name with a\n  /// suffix if there is a collision. Do not call this on an literal type.\n  void setName(StringRef Name);\n\n  /// Specify a body for an opaque identified type.\n  void setBody(ArrayRef<Type*> Elements, bool isPacked = false);\n\n  template <typename... Tys>\n  std::enable_if_t<are_base_of<Type, Tys...>::value, void>\n  setBody(Type *elt1, Tys *... elts) {\n    assert(elt1 && \"Cannot create a struct type with no elements with this\");\n    SmallVector<llvm::Type *, 8> StructFields({elt1, elts...});\n    setBody(StructFields);\n  }\n\n  /// Return true if the specified type is valid as a element type.\n  static bool isValidElementType(Type *ElemTy);\n\n  // Iterator access to the elements.\n  using element_iterator = Type::subtype_iterator;\n\n  element_iterator element_begin() const { return ContainedTys; }\n  element_iterator element_end() const { return &ContainedTys[NumContainedTys];}\n  ArrayRef<Type *> elements() const {\n    return makeArrayRef(element_begin(), element_end());\n  }\n\n  /// Return true if this is layout identical to the specified struct.\n  bool isLayoutIdentical(StructType *Other) const;\n\n  /// Random access to the elements\n  unsigned getNumElements() const { return NumContainedTys; }\n  Type *getElementType(unsigned N) const {\n    assert(N < NumContainedTys && \"Element number out of range!\");\n    return ContainedTys[N];\n  }\n  /// Given an index value into the type, return the type of the element.\n  Type *getTypeAtIndex(const Value *V) const;\n  Type *getTypeAtIndex(unsigned N) const { return getElementType(N); }\n  bool indexValid(const Value *V) const;\n  bool indexValid(unsigned Idx) const { return Idx < getNumElements(); }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Type *T) {\n    return T->getTypeID() == StructTyID;\n  }\n};\n\nStringRef Type::getStructName() const {\n  return cast<StructType>(this)->getName();\n}\n\nunsigned Type::getStructNumElements() const {\n  return cast<StructType>(this)->getNumElements();\n}\n\nType *Type::getStructElementType(unsigned N) const {\n  return cast<StructType>(this)->getElementType(N);\n}\n\n/// Class to represent array types.\nclass ArrayType : public Type {\n  /// The element type of the array.\n  Type *ContainedType;\n  /// Number of elements in the array.\n  uint64_t NumElements;\n\n  ArrayType(Type *ElType, uint64_t NumEl);\n\npublic:\n  ArrayType(const ArrayType &) = delete;\n  ArrayType &operator=(const ArrayType &) = delete;\n\n  uint64_t getNumElements() const { return NumElements; }\n  Type *getElementType() const { return ContainedType; }\n\n  /// This static method is the primary way to construct an ArrayType\n  static ArrayType *get(Type *ElementType, uint64_t NumElements);\n\n  /// Return true if the specified type is valid as a element type.\n  static bool isValidElementType(Type *ElemTy);\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Type *T) {\n    return T->getTypeID() == ArrayTyID;\n  }\n};\n\nuint64_t Type::getArrayNumElements() const {\n  return cast<ArrayType>(this)->getNumElements();\n}\n\n/// Base class of all SIMD vector types\nclass VectorType : public Type {\n  /// A fully specified VectorType is of the form <vscale x n x Ty>. 'n' is the\n  /// minimum number of elements of type Ty contained within the vector, and\n  /// 'vscale x' indicates that the total element count is an integer multiple\n  /// of 'n', where the multiple is either guaranteed to be one, or is\n  /// statically unknown at compile time.\n  ///\n  /// If the multiple is known to be 1, then the extra term is discarded in\n  /// textual IR:\n  ///\n  /// <4 x i32>          - a vector containing 4 i32s\n  /// <vscale x 4 x i32> - a vector containing an unknown integer multiple\n  ///                      of 4 i32s\n\n  /// The element type of the vector.\n  Type *ContainedType;\n\nprotected:\n  /// The element quantity of this vector. The meaning of this value depends\n  /// on the type of vector:\n  /// - For FixedVectorType = <ElementQuantity x ty>, there are\n  ///   exactly ElementQuantity elements in this vector.\n  /// - For ScalableVectorType = <vscale x ElementQuantity x ty>,\n  ///   there are vscale * ElementQuantity elements in this vector, where\n  ///   vscale is a runtime-constant integer greater than 0.\n  const unsigned ElementQuantity;\n\n  VectorType(Type *ElType, unsigned EQ, Type::TypeID TID);\n\npublic:\n  VectorType(const VectorType &) = delete;\n  VectorType &operator=(const VectorType &) = delete;\n\n  Type *getElementType() const { return ContainedType; }\n\n  /// This static method is the primary way to construct an VectorType.\n  static VectorType *get(Type *ElementType, ElementCount EC);\n\n  static VectorType *get(Type *ElementType, unsigned NumElements,\n                         bool Scalable) {\n    return VectorType::get(ElementType,\n                           ElementCount::get(NumElements, Scalable));\n  }\n\n  static VectorType *get(Type *ElementType, const VectorType *Other) {\n    return VectorType::get(ElementType, Other->getElementCount());\n  }\n\n  /// This static method gets a VectorType with the same number of elements as\n  /// the input type, and the element type is an integer type of the same width\n  /// as the input element type.\n  static VectorType *getInteger(VectorType *VTy) {\n    unsigned EltBits = VTy->getElementType()->getPrimitiveSizeInBits();\n    assert(EltBits && \"Element size must be of a non-zero size\");\n    Type *EltTy = IntegerType::get(VTy->getContext(), EltBits);\n    return VectorType::get(EltTy, VTy->getElementCount());\n  }\n\n  /// This static method is like getInteger except that the element types are\n  /// twice as wide as the elements in the input type.\n  static VectorType *getExtendedElementVectorType(VectorType *VTy) {\n    assert(VTy->isIntOrIntVectorTy() && \"VTy expected to be a vector of ints.\");\n    auto *EltTy = cast<IntegerType>(VTy->getElementType());\n    return VectorType::get(EltTy->getExtendedType(), VTy->getElementCount());\n  }\n\n  // This static method gets a VectorType with the same number of elements as\n  // the input type, and the element type is an integer or float type which\n  // is half as wide as the elements in the input type.\n  static VectorType *getTruncatedElementVectorType(VectorType *VTy) {\n    Type *EltTy;\n    if (VTy->getElementType()->isFloatingPointTy()) {\n      switch(VTy->getElementType()->getTypeID()) {\n      case DoubleTyID:\n        EltTy = Type::getFloatTy(VTy->getContext());\n        break;\n      case FloatTyID:\n        EltTy = Type::getHalfTy(VTy->getContext());\n        break;\n      default:\n        llvm_unreachable(\"Cannot create narrower fp vector element type\");\n      }\n    } else {\n      unsigned EltBits = VTy->getElementType()->getPrimitiveSizeInBits();\n      assert((EltBits & 1) == 0 &&\n             \"Cannot truncate vector element with odd bit-width\");\n      EltTy = IntegerType::get(VTy->getContext(), EltBits / 2);\n    }\n    return VectorType::get(EltTy, VTy->getElementCount());\n  }\n\n  // This static method returns a VectorType with a smaller number of elements\n  // of a larger type than the input element type. For example, a <16 x i8>\n  // subdivided twice would return <4 x i32>\n  static VectorType *getSubdividedVectorType(VectorType *VTy, int NumSubdivs) {\n    for (int i = 0; i < NumSubdivs; ++i) {\n      VTy = VectorType::getDoubleElementsVectorType(VTy);\n      VTy = VectorType::getTruncatedElementVectorType(VTy);\n    }\n    return VTy;\n  }\n\n  /// This static method returns a VectorType with half as many elements as the\n  /// input type and the same element type.\n  static VectorType *getHalfElementsVectorType(VectorType *VTy) {\n    auto EltCnt = VTy->getElementCount();\n    assert(EltCnt.isKnownEven() &&\n           \"Cannot halve vector with odd number of elements.\");\n    return VectorType::get(VTy->getElementType(),\n                           EltCnt.divideCoefficientBy(2));\n  }\n\n  /// This static method returns a VectorType with twice as many elements as the\n  /// input type and the same element type.\n  static VectorType *getDoubleElementsVectorType(VectorType *VTy) {\n    auto EltCnt = VTy->getElementCount();\n    assert((EltCnt.getKnownMinValue() * 2ull) <= UINT_MAX &&\n           \"Too many elements in vector\");\n    return VectorType::get(VTy->getElementType(), EltCnt * 2);\n  }\n\n  /// Return true if the specified type is valid as a element type.\n  static bool isValidElementType(Type *ElemTy);\n\n  /// Return an ElementCount instance to represent the (possibly scalable)\n  /// number of elements in the vector.\n  inline ElementCount getElementCount() const;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Type *T) {\n    return T->getTypeID() == FixedVectorTyID ||\n           T->getTypeID() == ScalableVectorTyID;\n  }\n};\n\n/// Class to represent fixed width SIMD vectors\nclass FixedVectorType : public VectorType {\nprotected:\n  FixedVectorType(Type *ElTy, unsigned NumElts)\n      : VectorType(ElTy, NumElts, FixedVectorTyID) {}\n\npublic:\n  static FixedVectorType *get(Type *ElementType, unsigned NumElts);\n\n  static FixedVectorType *get(Type *ElementType, const FixedVectorType *FVTy) {\n    return get(ElementType, FVTy->getNumElements());\n  }\n\n  static FixedVectorType *getInteger(FixedVectorType *VTy) {\n    return cast<FixedVectorType>(VectorType::getInteger(VTy));\n  }\n\n  static FixedVectorType *getExtendedElementVectorType(FixedVectorType *VTy) {\n    return cast<FixedVectorType>(VectorType::getExtendedElementVectorType(VTy));\n  }\n\n  static FixedVectorType *getTruncatedElementVectorType(FixedVectorType *VTy) {\n    return cast<FixedVectorType>(\n        VectorType::getTruncatedElementVectorType(VTy));\n  }\n\n  static FixedVectorType *getSubdividedVectorType(FixedVectorType *VTy,\n                                                  int NumSubdivs) {\n    return cast<FixedVectorType>(\n        VectorType::getSubdividedVectorType(VTy, NumSubdivs));\n  }\n\n  static FixedVectorType *getHalfElementsVectorType(FixedVectorType *VTy) {\n    return cast<FixedVectorType>(VectorType::getHalfElementsVectorType(VTy));\n  }\n\n  static FixedVectorType *getDoubleElementsVectorType(FixedVectorType *VTy) {\n    return cast<FixedVectorType>(VectorType::getDoubleElementsVectorType(VTy));\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeID() == FixedVectorTyID;\n  }\n\n  unsigned getNumElements() const { return ElementQuantity; }\n};\n\n/// Class to represent scalable SIMD vectors\nclass ScalableVectorType : public VectorType {\nprotected:\n  ScalableVectorType(Type *ElTy, unsigned MinNumElts)\n      : VectorType(ElTy, MinNumElts, ScalableVectorTyID) {}\n\npublic:\n  static ScalableVectorType *get(Type *ElementType, unsigned MinNumElts);\n\n  static ScalableVectorType *get(Type *ElementType,\n                                 const ScalableVectorType *SVTy) {\n    return get(ElementType, SVTy->getMinNumElements());\n  }\n\n  static ScalableVectorType *getInteger(ScalableVectorType *VTy) {\n    return cast<ScalableVectorType>(VectorType::getInteger(VTy));\n  }\n\n  static ScalableVectorType *\n  getExtendedElementVectorType(ScalableVectorType *VTy) {\n    return cast<ScalableVectorType>(\n        VectorType::getExtendedElementVectorType(VTy));\n  }\n\n  static ScalableVectorType *\n  getTruncatedElementVectorType(ScalableVectorType *VTy) {\n    return cast<ScalableVectorType>(\n        VectorType::getTruncatedElementVectorType(VTy));\n  }\n\n  static ScalableVectorType *getSubdividedVectorType(ScalableVectorType *VTy,\n                                                     int NumSubdivs) {\n    return cast<ScalableVectorType>(\n        VectorType::getSubdividedVectorType(VTy, NumSubdivs));\n  }\n\n  static ScalableVectorType *\n  getHalfElementsVectorType(ScalableVectorType *VTy) {\n    return cast<ScalableVectorType>(VectorType::getHalfElementsVectorType(VTy));\n  }\n\n  static ScalableVectorType *\n  getDoubleElementsVectorType(ScalableVectorType *VTy) {\n    return cast<ScalableVectorType>(\n        VectorType::getDoubleElementsVectorType(VTy));\n  }\n\n  /// Get the minimum number of elements in this vector. The actual number of\n  /// elements in the vector is an integer multiple of this value.\n  uint64_t getMinNumElements() const { return ElementQuantity; }\n\n  static bool classof(const Type *T) {\n    return T->getTypeID() == ScalableVectorTyID;\n  }\n};\n\ninline ElementCount VectorType::getElementCount() const {\n  return ElementCount::get(ElementQuantity, isa<ScalableVectorType>(this));\n}\n\n/// Class to represent pointers.\nclass PointerType : public Type {\n  explicit PointerType(Type *ElType, unsigned AddrSpace);\n\n  Type *PointeeTy;\n\npublic:\n  PointerType(const PointerType &) = delete;\n  PointerType &operator=(const PointerType &) = delete;\n\n  /// This constructs a pointer to an object of the specified type in a numbered\n  /// address space.\n  static PointerType *get(Type *ElementType, unsigned AddressSpace);\n\n  /// This constructs a pointer to an object of the specified type in the\n  /// generic address space (address space zero).\n  static PointerType *getUnqual(Type *ElementType) {\n    return PointerType::get(ElementType, 0);\n  }\n\n  Type *getElementType() const { return PointeeTy; }\n\n  /// Return true if the specified type is valid as a element type.\n  static bool isValidElementType(Type *ElemTy);\n\n  /// Return true if we can load or store from a pointer to this type.\n  static bool isLoadableOrStorableType(Type *ElemTy);\n\n  /// Return the address space of the Pointer type.\n  inline unsigned getAddressSpace() const { return getSubclassData(); }\n\n  /// Implement support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Type *T) {\n    return T->getTypeID() == PointerTyID;\n  }\n};\n\nType *Type::getExtendedType() const {\n  assert(\n      isIntOrIntVectorTy() &&\n      \"Original type expected to be a vector of integers or a scalar integer.\");\n  if (auto *VTy = dyn_cast<VectorType>(this))\n    return VectorType::getExtendedElementVectorType(\n        const_cast<VectorType *>(VTy));\n  return cast<IntegerType>(this)->getExtendedType();\n}\n\nType *Type::getWithNewBitWidth(unsigned NewBitWidth) const {\n  assert(\n      isIntOrIntVectorTy() &&\n      \"Original type expected to be a vector of integers or a scalar integer.\");\n  Type *NewType = getIntNTy(getContext(), NewBitWidth);\n  if (auto *VTy = dyn_cast<VectorType>(this))\n    NewType = VectorType::get(NewType, VTy->getElementCount());\n  return NewType;\n}\n\nunsigned Type::getPointerAddressSpace() const {\n  return cast<PointerType>(getScalarType())->getAddressSpace();\n}\n\n} // end namespace llvm\n\n#endif // LLVM_IR_DERIVEDTYPES_H\n"}, "50": {"id": 50, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Intrinsics.h", "content": "//===- Intrinsics.h - LLVM Intrinsic Function Handling ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a set of enums which allow processing of intrinsic\n// functions.  Values of these enum types are returned by\n// Function::getIntrinsicID.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_INTRINSICS_H\n#define LLVM_IR_INTRINSICS_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include <string>\n\nnamespace llvm {\n\nclass Type;\nclass FunctionType;\nclass Function;\nclass LLVMContext;\nclass Module;\nclass AttributeList;\n\n/// This namespace contains an enum with a value for every intrinsic/builtin\n/// function known by LLVM. The enum values are returned by\n/// Function::getIntrinsicID().\nnamespace Intrinsic {\n  // Abstraction for the arguments of the noalias intrinsics\n  static const int NoAliasScopeDeclScopeArg = 0;\n\n  // Intrinsic ID type. This is an opaque typedef to facilitate splitting up\n  // the enum into target-specific enums.\n  typedef unsigned ID;\n\n  enum IndependentIntrinsics : unsigned {\n    not_intrinsic = 0, // Must be zero\n\n  // Get the intrinsic enums generated from Intrinsics.td\n#define GET_INTRINSIC_ENUM_VALUES\n#include \"llvm/IR/IntrinsicEnums.inc\"\n#undef GET_INTRINSIC_ENUM_VALUES\n  };\n\n  /// Return the LLVM name for an intrinsic, such as \"llvm.ppc.altivec.lvx\".\n  /// Note, this version is for intrinsics with no overloads.  Use the other\n  /// version of getName if overloads are required.\n  StringRef getName(ID id);\n\n  /// Return the LLVM name for an intrinsic, such as \"llvm.ppc.altivec.lvx\".\n  /// Note, this version of getName supports overloads, but is less efficient\n  /// than the StringRef version of this function.  If no overloads are\n  /// requried, it is safe to use this version, but better to use the StringRef\n  /// version.\n  std::string getName(ID id, ArrayRef<Type*> Tys);\n\n  /// Return the function type for an intrinsic.\n  FunctionType *getType(LLVMContext &Context, ID id,\n                        ArrayRef<Type*> Tys = None);\n\n  /// Returns true if the intrinsic can be overloaded.\n  bool isOverloaded(ID id);\n\n  /// Returns true if the intrinsic is a leaf, i.e. it does not make any calls\n  /// itself.  Most intrinsics are leafs, the exceptions being the patchpoint\n  /// and statepoint intrinsics. These call (or invoke) their \"target\" argument.\n  bool isLeaf(ID id);\n\n  /// Return the attributes for an intrinsic.\n  AttributeList getAttributes(LLVMContext &C, ID id);\n\n  /// Create or insert an LLVM Function declaration for an intrinsic, and return\n  /// it.\n  ///\n  /// The Tys parameter is for intrinsics with overloaded types (e.g., those\n  /// using iAny, fAny, vAny, or iPTRAny).  For a declaration of an overloaded\n  /// intrinsic, Tys must provide exactly one type for each overloaded type in\n  /// the intrinsic.\n  Function *getDeclaration(Module *M, ID id, ArrayRef<Type*> Tys = None);\n\n  /// Looks up Name in NameTable via binary search. NameTable must be sorted\n  /// and all entries must start with \"llvm.\".  If NameTable contains an exact\n  /// match for Name or a prefix of Name followed by a dot, its index in\n  /// NameTable is returned. Otherwise, -1 is returned.\n  int lookupLLVMIntrinsicByName(ArrayRef<const char *> NameTable,\n                                StringRef Name);\n\n  /// Map a GCC builtin name to an intrinsic ID.\n  ID getIntrinsicForGCCBuiltin(const char *Prefix, StringRef BuiltinName);\n\n  /// Map a MS builtin name to an intrinsic ID.\n  ID getIntrinsicForMSBuiltin(const char *Prefix, StringRef BuiltinName);\n\n  /// This is a type descriptor which explains the type requirements of an\n  /// intrinsic. This is returned by getIntrinsicInfoTableEntries.\n  struct IITDescriptor {\n    enum IITDescriptorKind {\n      Void,\n      VarArg,\n      MMX,\n      Token,\n      Metadata,\n      Half,\n      BFloat,\n      Float,\n      Double,\n      Quad,\n      Integer,\n      Vector,\n      Pointer,\n      Struct,\n      Argument,\n      ExtendArgument,\n      TruncArgument,\n      HalfVecArgument,\n      SameVecWidthArgument,\n      PtrToArgument,\n      PtrToElt,\n      VecOfAnyPtrsToElt,\n      VecElementArgument,\n      Subdivide2Argument,\n      Subdivide4Argument,\n      VecOfBitcastsToInt,\n      AMX\n    } Kind;\n\n    union {\n      unsigned Integer_Width;\n      unsigned Float_Width;\n      unsigned Pointer_AddressSpace;\n      unsigned Struct_NumElements;\n      unsigned Argument_Info;\n      ElementCount Vector_Width;\n    };\n\n    enum ArgKind {\n      AK_Any,\n      AK_AnyInteger,\n      AK_AnyFloat,\n      AK_AnyVector,\n      AK_AnyPointer,\n      AK_MatchType = 7\n    };\n\n    unsigned getArgumentNumber() const {\n      assert(Kind == Argument || Kind == ExtendArgument ||\n             Kind == TruncArgument || Kind == HalfVecArgument ||\n             Kind == SameVecWidthArgument || Kind == PtrToArgument ||\n             Kind == PtrToElt || Kind == VecElementArgument ||\n             Kind == Subdivide2Argument || Kind == Subdivide4Argument ||\n             Kind == VecOfBitcastsToInt);\n      return Argument_Info >> 3;\n    }\n    ArgKind getArgumentKind() const {\n      assert(Kind == Argument || Kind == ExtendArgument ||\n             Kind == TruncArgument || Kind == HalfVecArgument ||\n             Kind == SameVecWidthArgument || Kind == PtrToArgument ||\n             Kind == VecElementArgument || Kind == Subdivide2Argument ||\n             Kind == Subdivide4Argument || Kind == VecOfBitcastsToInt);\n      return (ArgKind)(Argument_Info & 7);\n    }\n\n    // VecOfAnyPtrsToElt uses both an overloaded argument (for address space)\n    // and a reference argument (for matching vector width and element types)\n    unsigned getOverloadArgNumber() const {\n      assert(Kind == VecOfAnyPtrsToElt);\n      return Argument_Info >> 16;\n    }\n    unsigned getRefArgNumber() const {\n      assert(Kind == VecOfAnyPtrsToElt);\n      return Argument_Info & 0xFFFF;\n    }\n\n    static IITDescriptor get(IITDescriptorKind K, unsigned Field) {\n      IITDescriptor Result = { K, { Field } };\n      return Result;\n    }\n\n    static IITDescriptor get(IITDescriptorKind K, unsigned short Hi,\n                             unsigned short Lo) {\n      unsigned Field = Hi << 16 | Lo;\n      IITDescriptor Result = {K, {Field}};\n      return Result;\n    }\n\n    static IITDescriptor getVector(unsigned Width, bool IsScalable) {\n      IITDescriptor Result = {Vector, {0}};\n      Result.Vector_Width = ElementCount::get(Width, IsScalable);\n      return Result;\n    }\n  };\n\n  /// Return the IIT table descriptor for the specified intrinsic into an array\n  /// of IITDescriptors.\n  void getIntrinsicInfoTableEntries(ID id, SmallVectorImpl<IITDescriptor> &T);\n\n  enum MatchIntrinsicTypesResult {\n    MatchIntrinsicTypes_Match = 0,\n    MatchIntrinsicTypes_NoMatchRet = 1,\n    MatchIntrinsicTypes_NoMatchArg = 2,\n  };\n\n  /// Match the specified function type with the type constraints specified by\n  /// the .td file. If the given type is an overloaded type it is pushed to the\n  /// ArgTys vector.\n  ///\n  /// Returns false if the given type matches with the constraints, true\n  /// otherwise.\n  MatchIntrinsicTypesResult\n  matchIntrinsicSignature(FunctionType *FTy, ArrayRef<IITDescriptor> &Infos,\n                          SmallVectorImpl<Type *> &ArgTys);\n\n  /// Verify if the intrinsic has variable arguments. This method is intended to\n  /// be called after all the fixed arguments have been matched first.\n  ///\n  /// This method returns true on error.\n  bool matchIntrinsicVarArg(bool isVarArg, ArrayRef<IITDescriptor> &Infos);\n\n  /// Gets the type arguments of an intrinsic call by matching type contraints\n  /// specified by the .td file. The overloaded types are pushed into the\n  /// AgTys vector.\n  ///\n  /// Returns false if the given function is not a valid intrinsic call.\n  bool getIntrinsicSignature(Function *F, SmallVectorImpl<Type *> &ArgTys);\n\n  // Checks if the intrinsic name matches with its signature and if not\n  // returns the declaration with the same signature and remangled name.\n  llvm::Optional<Function*> remangleIntrinsicFunction(Function *F);\n\n} // End Intrinsic namespace\n\n} // End llvm namespace\n\n#endif\n"}, "51": {"id": 51, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "content": "//===- llvm/IR/Metadata.h - Metadata definitions ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// @file\n/// This file contains the declarations for metadata subclasses.\n/// They represent the different flavors of metadata that live in LLVM.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_METADATA_H\n#define LLVM_IR_METADATA_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <memory>\n#include <string>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\nclass Module;\nclass ModuleSlotTracker;\nclass raw_ostream;\nclass Type;\n\nenum LLVMConstants : uint32_t {\n  DEBUG_METADATA_VERSION = 3 // Current debug info version number.\n};\n\n/// Root of the metadata hierarchy.\n///\n/// This is a root class for typeless data in the IR.\nclass Metadata {\n  friend class ReplaceableMetadataImpl;\n\n  /// RTTI.\n  const unsigned char SubclassID;\n\nprotected:\n  /// Active type of storage.\n  enum StorageType { Uniqued, Distinct, Temporary };\n\n  /// Storage flag for non-uniqued, otherwise unowned, metadata.\n  unsigned char Storage : 7;\n\n  unsigned char SubclassData1 : 1;\n  unsigned short SubclassData16 = 0;\n  unsigned SubclassData32 = 0;\n\npublic:\n  enum MetadataKind {\n#define HANDLE_METADATA_LEAF(CLASS) CLASS##Kind,\n#include \"llvm/IR/Metadata.def\"\n  };\n\nprotected:\n  Metadata(unsigned ID, StorageType Storage)\n      : SubclassID(ID), Storage(Storage), SubclassData1(false) {\n    static_assert(sizeof(*this) == 8, \"Metadata fields poorly packed\");\n  }\n\n  ~Metadata() = default;\n\n  /// Default handling of a changed operand, which asserts.\n  ///\n  /// If subclasses pass themselves in as owners to a tracking node reference,\n  /// they must provide an implementation of this method.\n  void handleChangedOperand(void *, Metadata *) {\n    llvm_unreachable(\"Unimplemented in Metadata subclass\");\n  }\n\npublic:\n  unsigned getMetadataID() const { return SubclassID; }\n\n  /// User-friendly dump.\n  ///\n  /// If \\c M is provided, metadata nodes will be numbered canonically;\n  /// otherwise, pointer addresses are substituted.\n  ///\n  /// Note: this uses an explicit overload instead of default arguments so that\n  /// the nullptr version is easy to call from a debugger.\n  ///\n  /// @{\n  void dump() const;\n  void dump(const Module *M) const;\n  /// @}\n\n  /// Print.\n  ///\n  /// Prints definition of \\c this.\n  ///\n  /// If \\c M is provided, metadata nodes will be numbered canonically;\n  /// otherwise, pointer addresses are substituted.\n  /// @{\n  void print(raw_ostream &OS, const Module *M = nullptr,\n             bool IsForDebug = false) const;\n  void print(raw_ostream &OS, ModuleSlotTracker &MST, const Module *M = nullptr,\n             bool IsForDebug = false) const;\n  /// @}\n\n  /// Print as operand.\n  ///\n  /// Prints reference of \\c this.\n  ///\n  /// If \\c M is provided, metadata nodes will be numbered canonically;\n  /// otherwise, pointer addresses are substituted.\n  /// @{\n  void printAsOperand(raw_ostream &OS, const Module *M = nullptr) const;\n  void printAsOperand(raw_ostream &OS, ModuleSlotTracker &MST,\n                      const Module *M = nullptr) const;\n  /// @}\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_ISA_CONVERSION_FUNCTIONS(Metadata, LLVMMetadataRef)\n\n// Specialized opaque metadata conversions.\ninline Metadata **unwrap(LLVMMetadataRef *MDs) {\n  return reinterpret_cast<Metadata**>(MDs);\n}\n\n#define HANDLE_METADATA(CLASS) class CLASS;\n#include \"llvm/IR/Metadata.def\"\n\n// Provide specializations of isa so that we don't need definitions of\n// subclasses to see if the metadata is a subclass.\n#define HANDLE_METADATA_LEAF(CLASS)                                            \\\n  template <> struct isa_impl<CLASS, Metadata> {                               \\\n    static inline bool doit(const Metadata &MD) {                              \\\n      return MD.getMetadataID() == Metadata::CLASS##Kind;                      \\\n    }                                                                          \\\n  };\n#include \"llvm/IR/Metadata.def\"\n\ninline raw_ostream &operator<<(raw_ostream &OS, const Metadata &MD) {\n  MD.print(OS);\n  return OS;\n}\n\n/// Metadata wrapper in the Value hierarchy.\n///\n/// A member of the \\a Value hierarchy to represent a reference to metadata.\n/// This allows, e.g., instrinsics to have metadata as operands.\n///\n/// Notably, this is the only thing in either hierarchy that is allowed to\n/// reference \\a LocalAsMetadata.\nclass MetadataAsValue : public Value {\n  friend class ReplaceableMetadataImpl;\n  friend class LLVMContextImpl;\n\n  Metadata *MD;\n\n  MetadataAsValue(Type *Ty, Metadata *MD);\n\n  /// Drop use of metadata (during teardown).\n  void dropUse() { MD = nullptr; }\n\npublic:\n  ~MetadataAsValue();\n\n  static MetadataAsValue *get(LLVMContext &Context, Metadata *MD);\n  static MetadataAsValue *getIfExists(LLVMContext &Context, Metadata *MD);\n\n  Metadata *getMetadata() const { return MD; }\n\n  static bool classof(const Value *V) {\n    return V->getValueID() == MetadataAsValueVal;\n  }\n\nprivate:\n  void handleChangedMetadata(Metadata *MD);\n  void track();\n  void untrack();\n};\n\n/// API for tracking metadata references through RAUW and deletion.\n///\n/// Shared API for updating \\a Metadata pointers in subclasses that support\n/// RAUW.\n///\n/// This API is not meant to be used directly.  See \\a TrackingMDRef for a\n/// user-friendly tracking reference.\nclass MetadataTracking {\npublic:\n  /// Track the reference to metadata.\n  ///\n  /// Register \\c MD with \\c *MD, if the subclass supports tracking.  If \\c *MD\n  /// gets RAUW'ed, \\c MD will be updated to the new address.  If \\c *MD gets\n  /// deleted, \\c MD will be set to \\c nullptr.\n  ///\n  /// If tracking isn't supported, \\c *MD will not change.\n  ///\n  /// \\return true iff tracking is supported by \\c MD.\n  static bool track(Metadata *&MD) {\n    return track(&MD, *MD, static_cast<Metadata *>(nullptr));\n  }\n\n  /// Track the reference to metadata for \\a Metadata.\n  ///\n  /// As \\a track(Metadata*&), but with support for calling back to \\c Owner to\n  /// tell it that its operand changed.  This could trigger \\c Owner being\n  /// re-uniqued.\n  static bool track(void *Ref, Metadata &MD, Metadata &Owner) {\n    return track(Ref, MD, &Owner);\n  }\n\n  /// Track the reference to metadata for \\a MetadataAsValue.\n  ///\n  /// As \\a track(Metadata*&), but with support for calling back to \\c Owner to\n  /// tell it that its operand changed.  This could trigger \\c Owner being\n  /// re-uniqued.\n  static bool track(void *Ref, Metadata &MD, MetadataAsValue &Owner) {\n    return track(Ref, MD, &Owner);\n  }\n\n  /// Stop tracking a reference to metadata.\n  ///\n  /// Stops \\c *MD from tracking \\c MD.\n  static void untrack(Metadata *&MD) { untrack(&MD, *MD); }\n  static void untrack(void *Ref, Metadata &MD);\n\n  /// Move tracking from one reference to another.\n  ///\n  /// Semantically equivalent to \\c untrack(MD) followed by \\c track(New),\n  /// except that ownership callbacks are maintained.\n  ///\n  /// Note: it is an error if \\c *MD does not equal \\c New.\n  ///\n  /// \\return true iff tracking is supported by \\c MD.\n  static bool retrack(Metadata *&MD, Metadata *&New) {\n    return retrack(&MD, *MD, &New);\n  }\n  static bool retrack(void *Ref, Metadata &MD, void *New);\n\n  /// Check whether metadata is replaceable.\n  static bool isReplaceable(const Metadata &MD);\n\n  using OwnerTy = PointerUnion<MetadataAsValue *, Metadata *>;\n\nprivate:\n  /// Track a reference to metadata for an owner.\n  ///\n  /// Generalized version of tracking.\n  static bool track(void *Ref, Metadata &MD, OwnerTy Owner);\n};\n\n/// Shared implementation of use-lists for replaceable metadata.\n///\n/// Most metadata cannot be RAUW'ed.  This is a shared implementation of\n/// use-lists and associated API for the two that support it (\\a ValueAsMetadata\n/// and \\a TempMDNode).\nclass ReplaceableMetadataImpl {\n  friend class MetadataTracking;\n\npublic:\n  using OwnerTy = MetadataTracking::OwnerTy;\n\nprivate:\n  LLVMContext &Context;\n  uint64_t NextIndex = 0;\n  SmallDenseMap<void *, std::pair<OwnerTy, uint64_t>, 4> UseMap;\n\npublic:\n  ReplaceableMetadataImpl(LLVMContext &Context) : Context(Context) {}\n\n  ~ReplaceableMetadataImpl() {\n    assert(UseMap.empty() && \"Cannot destroy in-use replaceable metadata\");\n  }\n\n  LLVMContext &getContext() const { return Context; }\n\n  /// Replace all uses of this with MD.\n  ///\n  /// Replace all uses of this with \\c MD, which is allowed to be null.\n  void replaceAllUsesWith(Metadata *MD);\n\n  /// Returns the list of all DIArgList users of this.\n  SmallVector<Metadata *, 4> getAllArgListUsers();\n\n  /// Resolve all uses of this.\n  ///\n  /// Resolve all uses of this, turning off RAUW permanently.  If \\c\n  /// ResolveUsers, call \\a MDNode::resolve() on any users whose last operand\n  /// is resolved.\n  void resolveAllUses(bool ResolveUsers = true);\n\nprivate:\n  void addRef(void *Ref, OwnerTy Owner);\n  void dropRef(void *Ref);\n  void moveRef(void *Ref, void *New, const Metadata &MD);\n\n  /// Lazily construct RAUW support on MD.\n  ///\n  /// If this is an unresolved MDNode, RAUW support will be created on-demand.\n  /// ValueAsMetadata always has RAUW support.\n  static ReplaceableMetadataImpl *getOrCreate(Metadata &MD);\n\n  /// Get RAUW support on MD, if it exists.\n  static ReplaceableMetadataImpl *getIfExists(Metadata &MD);\n\n  /// Check whether this node will support RAUW.\n  ///\n  /// Returns \\c true unless getOrCreate() would return null.\n  static bool isReplaceable(const Metadata &MD);\n};\n\n/// Value wrapper in the Metadata hierarchy.\n///\n/// This is a custom value handle that allows other metadata to refer to\n/// classes in the Value hierarchy.\n///\n/// Because of full uniquing support, each value is only wrapped by a single \\a\n/// ValueAsMetadata object, so the lookup maps are far more efficient than\n/// those using ValueHandleBase.\nclass ValueAsMetadata : public Metadata, ReplaceableMetadataImpl {\n  friend class ReplaceableMetadataImpl;\n  friend class LLVMContextImpl;\n\n  Value *V;\n\n  /// Drop users without RAUW (during teardown).\n  void dropUsers() {\n    ReplaceableMetadataImpl::resolveAllUses(/* ResolveUsers */ false);\n  }\n\nprotected:\n  ValueAsMetadata(unsigned ID, Value *V)\n      : Metadata(ID, Uniqued), ReplaceableMetadataImpl(V->getContext()), V(V) {\n    assert(V && \"Expected valid value\");\n  }\n\n  ~ValueAsMetadata() = default;\n\npublic:\n  static ValueAsMetadata *get(Value *V);\n\n  static ConstantAsMetadata *getConstant(Value *C) {\n    return cast<ConstantAsMetadata>(get(C));\n  }\n\n  static LocalAsMetadata *getLocal(Value *Local) {\n    return cast<LocalAsMetadata>(get(Local));\n  }\n\n  static ValueAsMetadata *getIfExists(Value *V);\n\n  static ConstantAsMetadata *getConstantIfExists(Value *C) {\n    return cast_or_null<ConstantAsMetadata>(getIfExists(C));\n  }\n\n  static LocalAsMetadata *getLocalIfExists(Value *Local) {\n    return cast_or_null<LocalAsMetadata>(getIfExists(Local));\n  }\n\n  Value *getValue() const { return V; }\n  Type *getType() const { return V->getType(); }\n  LLVMContext &getContext() const { return V->getContext(); }\n\n  SmallVector<Metadata *, 4> getAllArgListUsers() {\n    return ReplaceableMetadataImpl::getAllArgListUsers();\n  }\n\n  static void handleDeletion(Value *V);\n  static void handleRAUW(Value *From, Value *To);\n\nprotected:\n  /// Handle collisions after \\a Value::replaceAllUsesWith().\n  ///\n  /// RAUW isn't supported directly for \\a ValueAsMetadata, but if the wrapped\n  /// \\a Value gets RAUW'ed and the target already exists, this is used to\n  /// merge the two metadata nodes.\n  void replaceAllUsesWith(Metadata *MD) {\n    ReplaceableMetadataImpl::replaceAllUsesWith(MD);\n  }\n\npublic:\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == LocalAsMetadataKind ||\n           MD->getMetadataID() == ConstantAsMetadataKind;\n  }\n};\n\nclass ConstantAsMetadata : public ValueAsMetadata {\n  friend class ValueAsMetadata;\n\n  ConstantAsMetadata(Constant *C)\n      : ValueAsMetadata(ConstantAsMetadataKind, C) {}\n\npublic:\n  static ConstantAsMetadata *get(Constant *C) {\n    return ValueAsMetadata::getConstant(C);\n  }\n\n  static ConstantAsMetadata *getIfExists(Constant *C) {\n    return ValueAsMetadata::getConstantIfExists(C);\n  }\n\n  Constant *getValue() const {\n    return cast<Constant>(ValueAsMetadata::getValue());\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == ConstantAsMetadataKind;\n  }\n};\n\nclass LocalAsMetadata : public ValueAsMetadata {\n  friend class ValueAsMetadata;\n\n  LocalAsMetadata(Value *Local)\n      : ValueAsMetadata(LocalAsMetadataKind, Local) {\n    assert(!isa<Constant>(Local) && \"Expected local value\");\n  }\n\npublic:\n  static LocalAsMetadata *get(Value *Local) {\n    return ValueAsMetadata::getLocal(Local);\n  }\n\n  static LocalAsMetadata *getIfExists(Value *Local) {\n    return ValueAsMetadata::getLocalIfExists(Local);\n  }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == LocalAsMetadataKind;\n  }\n};\n\n/// Transitional API for extracting constants from Metadata.\n///\n/// This namespace contains transitional functions for metadata that points to\n/// \\a Constants.\n///\n/// In prehistory -- when metadata was a subclass of \\a Value -- \\a MDNode\n/// operands could refer to any \\a Value.  There's was a lot of code like this:\n///\n/// \\code\n///     MDNode *N = ...;\n///     auto *CI = dyn_cast<ConstantInt>(N->getOperand(2));\n/// \\endcode\n///\n/// Now that \\a Value and \\a Metadata are in separate hierarchies, maintaining\n/// the semantics for \\a isa(), \\a cast(), \\a dyn_cast() (etc.) requires three\n/// steps: cast in the \\a Metadata hierarchy, extraction of the \\a Value, and\n/// cast in the \\a Value hierarchy.  Besides creating boiler-plate, this\n/// requires subtle control flow changes.\n///\n/// The end-goal is to create a new type of metadata, called (e.g.) \\a MDInt,\n/// so that metadata can refer to numbers without traversing a bridge to the \\a\n/// Value hierarchy.  In this final state, the code above would look like this:\n///\n/// \\code\n///     MDNode *N = ...;\n///     auto *MI = dyn_cast<MDInt>(N->getOperand(2));\n/// \\endcode\n///\n/// The API in this namespace supports the transition.  \\a MDInt doesn't exist\n/// yet, and even once it does, changing each metadata schema to use it is its\n/// own mini-project.  In the meantime this API prevents us from introducing\n/// complex and bug-prone control flow that will disappear in the end.  In\n/// particular, the above code looks like this:\n///\n/// \\code\n///     MDNode *N = ...;\n///     auto *CI = mdconst::dyn_extract<ConstantInt>(N->getOperand(2));\n/// \\endcode\n///\n/// The full set of provided functions includes:\n///\n///   mdconst::hasa                <=> isa\n///   mdconst::extract             <=> cast\n///   mdconst::extract_or_null     <=> cast_or_null\n///   mdconst::dyn_extract         <=> dyn_cast\n///   mdconst::dyn_extract_or_null <=> dyn_cast_or_null\n///\n/// The target of the cast must be a subclass of \\a Constant.\nnamespace mdconst {\n\nnamespace detail {\n\ntemplate <class T> T &make();\ntemplate <class T, class Result> struct HasDereference {\n  using Yes = char[1];\n  using No = char[2];\n  template <size_t N> struct SFINAE {};\n\n  template <class U, class V>\n  static Yes &hasDereference(SFINAE<sizeof(static_cast<V>(*make<U>()))> * = 0);\n  template <class U, class V> static No &hasDereference(...);\n\n  static const bool value =\n      sizeof(hasDereference<T, Result>(nullptr)) == sizeof(Yes);\n};\ntemplate <class V, class M> struct IsValidPointer {\n  static const bool value = std::is_base_of<Constant, V>::value &&\n                            HasDereference<M, const Metadata &>::value;\n};\ntemplate <class V, class M> struct IsValidReference {\n  static const bool value = std::is_base_of<Constant, V>::value &&\n                            std::is_convertible<M, const Metadata &>::value;\n};\n\n} // end namespace detail\n\n/// Check whether Metadata has a Value.\n///\n/// As an analogue to \\a isa(), check whether \\c MD has an \\a Value inside of\n/// type \\c X.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, bool>\nhasa(Y &&MD) {\n  assert(MD && \"Null pointer sent into hasa\");\n  if (auto *V = dyn_cast<ConstantAsMetadata>(MD))\n    return isa<X>(V->getValue());\n  return false;\n}\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidReference<X, Y &>::value, bool>\nhasa(Y &MD) {\n  return hasa(&MD);\n}\n\n/// Extract a Value from Metadata.\n///\n/// As an analogue to \\a cast(), extract the \\a Value subclass \\c X from \\c MD.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\nextract(Y &&MD) {\n  return cast<X>(cast<ConstantAsMetadata>(MD)->getValue());\n}\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidReference<X, Y &>::value, X *>\nextract(Y &MD) {\n  return extract(&MD);\n}\n\n/// Extract a Value from Metadata, allowing null.\n///\n/// As an analogue to \\a cast_or_null(), extract the \\a Value subclass \\c X\n/// from \\c MD, allowing \\c MD to be null.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\nextract_or_null(Y &&MD) {\n  if (auto *V = cast_or_null<ConstantAsMetadata>(MD))\n    return cast<X>(V->getValue());\n  return nullptr;\n}\n\n/// Extract a Value from Metadata, if any.\n///\n/// As an analogue to \\a dyn_cast_or_null(), extract the \\a Value subclass \\c X\n/// from \\c MD, return null if \\c MD doesn't contain a \\a Value or if the \\a\n/// Value it does contain is of the wrong subclass.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\ndyn_extract(Y &&MD) {\n  if (auto *V = dyn_cast<ConstantAsMetadata>(MD))\n    return dyn_cast<X>(V->getValue());\n  return nullptr;\n}\n\n/// Extract a Value from Metadata, if any, allowing null.\n///\n/// As an analogue to \\a dyn_cast_or_null(), extract the \\a Value subclass \\c X\n/// from \\c MD, return null if \\c MD doesn't contain a \\a Value or if the \\a\n/// Value it does contain is of the wrong subclass, allowing \\c MD to be null.\ntemplate <class X, class Y>\ninline std::enable_if_t<detail::IsValidPointer<X, Y>::value, X *>\ndyn_extract_or_null(Y &&MD) {\n  if (auto *V = dyn_cast_or_null<ConstantAsMetadata>(MD))\n    return dyn_cast<X>(V->getValue());\n  return nullptr;\n}\n\n} // end namespace mdconst\n\n//===----------------------------------------------------------------------===//\n/// A single uniqued string.\n///\n/// These are used to efficiently contain a byte sequence for metadata.\n/// MDString is always unnamed.\nclass MDString : public Metadata {\n  friend class StringMapEntryStorage<MDString>;\n\n  StringMapEntry<MDString> *Entry = nullptr;\n\n  MDString() : Metadata(MDStringKind, Uniqued) {}\n\npublic:\n  MDString(const MDString &) = delete;\n  MDString &operator=(MDString &&) = delete;\n  MDString &operator=(const MDString &) = delete;\n\n  static MDString *get(LLVMContext &Context, StringRef Str);\n  static MDString *get(LLVMContext &Context, const char *Str) {\n    return get(Context, Str ? StringRef(Str) : StringRef());\n  }\n\n  StringRef getString() const;\n\n  unsigned getLength() const { return (unsigned)getString().size(); }\n\n  using iterator = StringRef::iterator;\n\n  /// Pointer to the first byte of the string.\n  iterator begin() const { return getString().begin(); }\n\n  /// Pointer to one byte past the end of the string.\n  iterator end() const { return getString().end(); }\n\n  const unsigned char *bytes_begin() const { return getString().bytes_begin(); }\n  const unsigned char *bytes_end() const { return getString().bytes_end(); }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast.\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == MDStringKind;\n  }\n};\n\n/// A collection of metadata nodes that might be associated with a\n/// memory access used by the alias-analysis infrastructure.\nstruct AAMDNodes {\n  explicit AAMDNodes() = default;\n  explicit AAMDNodes(MDNode *T, MDNode *TS, MDNode *S, MDNode *N)\n      : TBAA(T), TBAAStruct(TS), Scope(S), NoAlias(N) {}\n\n  bool operator==(const AAMDNodes &A) const {\n    return TBAA == A.TBAA && TBAAStruct == A.TBAAStruct && Scope == A.Scope &&\n           NoAlias == A.NoAlias;\n  }\n\n  bool operator!=(const AAMDNodes &A) const { return !(*this == A); }\n\n  explicit operator bool() const {\n    return TBAA || TBAAStruct || Scope || NoAlias;\n  }\n\n  /// The tag for type-based alias analysis.\n  MDNode *TBAA = nullptr;\n\n  /// The tag for type-based alias analysis (tbaa struct).\n  MDNode *TBAAStruct = nullptr;\n\n  /// The tag for alias scope specification (used with noalias).\n  MDNode *Scope = nullptr;\n\n  /// The tag specifying the noalias scope.\n  MDNode *NoAlias = nullptr;\n\n  // Shift tbaa Metadata node to start off bytes later\n  static MDNode *ShiftTBAA(MDNode *M, size_t off);\n\n  // Shift tbaa.struct Metadata node to start off bytes later\n  static MDNode *ShiftTBAAStruct(MDNode *M, size_t off);\n\n  /// Given two sets of AAMDNodes that apply to the same pointer,\n  /// give the best AAMDNodes that are compatible with both (i.e. a set of\n  /// nodes whose allowable aliasing conclusions are a subset of those\n  /// allowable by both of the inputs). However, for efficiency\n  /// reasons, do not create any new MDNodes.\n  AAMDNodes intersect(const AAMDNodes &Other) {\n    AAMDNodes Result;\n    Result.TBAA = Other.TBAA == TBAA ? TBAA : nullptr;\n    Result.TBAAStruct = Other.TBAAStruct == TBAAStruct ? TBAAStruct : nullptr;\n    Result.Scope = Other.Scope == Scope ? Scope : nullptr;\n    Result.NoAlias = Other.NoAlias == NoAlias ? NoAlias : nullptr;\n    return Result;\n  }\n\n  /// Create a new AAMDNode that describes this AAMDNode after applying a\n  /// constant offset to the start of the pointer\n  AAMDNodes shift(size_t Offset) {\n    AAMDNodes Result;\n    Result.TBAA = TBAA ? ShiftTBAA(TBAA, Offset) : nullptr;\n    Result.TBAAStruct =\n        TBAAStruct ? ShiftTBAAStruct(TBAAStruct, Offset) : nullptr;\n    Result.Scope = Scope;\n    Result.NoAlias = NoAlias;\n    return Result;\n  }\n};\n\n// Specialize DenseMapInfo for AAMDNodes.\ntemplate<>\nstruct DenseMapInfo<AAMDNodes> {\n  static inline AAMDNodes getEmptyKey() {\n    return AAMDNodes(DenseMapInfo<MDNode *>::getEmptyKey(),\n                     nullptr, nullptr, nullptr);\n  }\n\n  static inline AAMDNodes getTombstoneKey() {\n    return AAMDNodes(DenseMapInfo<MDNode *>::getTombstoneKey(),\n                     nullptr, nullptr, nullptr);\n  }\n\n  static unsigned getHashValue(const AAMDNodes &Val) {\n    return DenseMapInfo<MDNode *>::getHashValue(Val.TBAA) ^\n           DenseMapInfo<MDNode *>::getHashValue(Val.TBAAStruct) ^\n           DenseMapInfo<MDNode *>::getHashValue(Val.Scope) ^\n           DenseMapInfo<MDNode *>::getHashValue(Val.NoAlias);\n  }\n\n  static bool isEqual(const AAMDNodes &LHS, const AAMDNodes &RHS) {\n    return LHS == RHS;\n  }\n};\n\n/// Tracking metadata reference owned by Metadata.\n///\n/// Similar to \\a TrackingMDRef, but it's expected to be owned by an instance\n/// of \\a Metadata, which has the option of registering itself for callbacks to\n/// re-unique itself.\n///\n/// In particular, this is used by \\a MDNode.\nclass MDOperand {\n  Metadata *MD = nullptr;\n\npublic:\n  MDOperand() = default;\n  MDOperand(MDOperand &&) = delete;\n  MDOperand(const MDOperand &) = delete;\n  MDOperand &operator=(MDOperand &&) = delete;\n  MDOperand &operator=(const MDOperand &) = delete;\n  ~MDOperand() { untrack(); }\n\n  Metadata *get() const { return MD; }\n  operator Metadata *() const { return get(); }\n  Metadata *operator->() const { return get(); }\n  Metadata &operator*() const { return *get(); }\n\n  void reset() {\n    untrack();\n    MD = nullptr;\n  }\n  void reset(Metadata *MD, Metadata *Owner) {\n    untrack();\n    this->MD = MD;\n    track(Owner);\n  }\n\nprivate:\n  void track(Metadata *Owner) {\n    if (MD) {\n      if (Owner)\n        MetadataTracking::track(this, *MD, *Owner);\n      else\n        MetadataTracking::track(MD);\n    }\n  }\n\n  void untrack() {\n    assert(static_cast<void *>(this) == &MD && \"Expected same address\");\n    if (MD)\n      MetadataTracking::untrack(MD);\n  }\n};\n\ntemplate <> struct simplify_type<MDOperand> {\n  using SimpleType = Metadata *;\n\n  static SimpleType getSimplifiedValue(MDOperand &MD) { return MD.get(); }\n};\n\ntemplate <> struct simplify_type<const MDOperand> {\n  using SimpleType = Metadata *;\n\n  static SimpleType getSimplifiedValue(const MDOperand &MD) { return MD.get(); }\n};\n\n/// Pointer to the context, with optional RAUW support.\n///\n/// Either a raw (non-null) pointer to the \\a LLVMContext, or an owned pointer\n/// to \\a ReplaceableMetadataImpl (which has a reference to \\a LLVMContext).\nclass ContextAndReplaceableUses {\n  PointerUnion<LLVMContext *, ReplaceableMetadataImpl *> Ptr;\n\npublic:\n  ContextAndReplaceableUses(LLVMContext &Context) : Ptr(&Context) {}\n  ContextAndReplaceableUses(\n      std::unique_ptr<ReplaceableMetadataImpl> ReplaceableUses)\n      : Ptr(ReplaceableUses.release()) {\n    assert(getReplaceableUses() && \"Expected non-null replaceable uses\");\n  }\n  ContextAndReplaceableUses() = delete;\n  ContextAndReplaceableUses(ContextAndReplaceableUses &&) = delete;\n  ContextAndReplaceableUses(const ContextAndReplaceableUses &) = delete;\n  ContextAndReplaceableUses &operator=(ContextAndReplaceableUses &&) = delete;\n  ContextAndReplaceableUses &\n  operator=(const ContextAndReplaceableUses &) = delete;\n  ~ContextAndReplaceableUses() { delete getReplaceableUses(); }\n\n  operator LLVMContext &() { return getContext(); }\n\n  /// Whether this contains RAUW support.\n  bool hasReplaceableUses() const {\n    return Ptr.is<ReplaceableMetadataImpl *>();\n  }\n\n  LLVMContext &getContext() const {\n    if (hasReplaceableUses())\n      return getReplaceableUses()->getContext();\n    return *Ptr.get<LLVMContext *>();\n  }\n\n  ReplaceableMetadataImpl *getReplaceableUses() const {\n    if (hasReplaceableUses())\n      return Ptr.get<ReplaceableMetadataImpl *>();\n    return nullptr;\n  }\n\n  /// Ensure that this has RAUW support, and then return it.\n  ReplaceableMetadataImpl *getOrCreateReplaceableUses() {\n    if (!hasReplaceableUses())\n      makeReplaceable(std::make_unique<ReplaceableMetadataImpl>(getContext()));\n    return getReplaceableUses();\n  }\n\n  /// Assign RAUW support to this.\n  ///\n  /// Make this replaceable, taking ownership of \\c ReplaceableUses (which must\n  /// not be null).\n  void\n  makeReplaceable(std::unique_ptr<ReplaceableMetadataImpl> ReplaceableUses) {\n    assert(ReplaceableUses && \"Expected non-null replaceable uses\");\n    assert(&ReplaceableUses->getContext() == &getContext() &&\n           \"Expected same context\");\n    delete getReplaceableUses();\n    Ptr = ReplaceableUses.release();\n  }\n\n  /// Drop RAUW support.\n  ///\n  /// Cede ownership of RAUW support, returning it.\n  std::unique_ptr<ReplaceableMetadataImpl> takeReplaceableUses() {\n    assert(hasReplaceableUses() && \"Expected to own replaceable uses\");\n    std::unique_ptr<ReplaceableMetadataImpl> ReplaceableUses(\n        getReplaceableUses());\n    Ptr = &ReplaceableUses->getContext();\n    return ReplaceableUses;\n  }\n};\n\nstruct TempMDNodeDeleter {\n  inline void operator()(MDNode *Node) const;\n};\n\n#define HANDLE_MDNODE_LEAF(CLASS)                                              \\\n  using Temp##CLASS = std::unique_ptr<CLASS, TempMDNodeDeleter>;\n#define HANDLE_MDNODE_BRANCH(CLASS) HANDLE_MDNODE_LEAF(CLASS)\n#include \"llvm/IR/Metadata.def\"\n\n/// Metadata node.\n///\n/// Metadata nodes can be uniqued, like constants, or distinct.  Temporary\n/// metadata nodes (with full support for RAUW) can be used to delay uniquing\n/// until forward references are known.  The basic metadata node is an \\a\n/// MDTuple.\n///\n/// There is limited support for RAUW at construction time.  At construction\n/// time, if any operand is a temporary node (or an unresolved uniqued node,\n/// which indicates a transitive temporary operand), the node itself will be\n/// unresolved.  As soon as all operands become resolved, it will drop RAUW\n/// support permanently.\n///\n/// If an unresolved node is part of a cycle, \\a resolveCycles() needs\n/// to be called on some member of the cycle once all temporary nodes have been\n/// replaced.\nclass MDNode : public Metadata {\n  friend class ReplaceableMetadataImpl;\n  friend class LLVMContextImpl;\n\n  unsigned NumOperands;\n  unsigned NumUnresolved;\n\n  ContextAndReplaceableUses Context;\n\nprotected:\n  MDNode(LLVMContext &Context, unsigned ID, StorageType Storage,\n         ArrayRef<Metadata *> Ops1, ArrayRef<Metadata *> Ops2 = None);\n  ~MDNode() = default;\n\n  void *operator new(size_t Size, unsigned NumOps);\n  void operator delete(void *Mem);\n\n  /// Required by std, but never called.\n  void operator delete(void *, unsigned) {\n    llvm_unreachable(\"Constructor throws?\");\n  }\n\n  /// Required by std, but never called.\n  void operator delete(void *, unsigned, bool) {\n    llvm_unreachable(\"Constructor throws?\");\n  }\n\n  void dropAllReferences();\n\n  MDOperand *mutable_begin() { return mutable_end() - NumOperands; }\n  MDOperand *mutable_end() { return reinterpret_cast<MDOperand *>(this); }\n\n  using mutable_op_range = iterator_range<MDOperand *>;\n\n  mutable_op_range mutable_operands() {\n    return mutable_op_range(mutable_begin(), mutable_end());\n  }\n\npublic:\n  MDNode(const MDNode &) = delete;\n  void operator=(const MDNode &) = delete;\n  void *operator new(size_t) = delete;\n\n  static inline MDTuple *get(LLVMContext &Context, ArrayRef<Metadata *> MDs);\n  static inline MDTuple *getIfExists(LLVMContext &Context,\n                                     ArrayRef<Metadata *> MDs);\n  static inline MDTuple *getDistinct(LLVMContext &Context,\n                                     ArrayRef<Metadata *> MDs);\n  static inline TempMDTuple getTemporary(LLVMContext &Context,\n                                         ArrayRef<Metadata *> MDs);\n\n  /// Create a (temporary) clone of this.\n  TempMDNode clone() const;\n\n  /// Deallocate a node created by getTemporary.\n  ///\n  /// Calls \\c replaceAllUsesWith(nullptr) before deleting, so any remaining\n  /// references will be reset.\n  static void deleteTemporary(MDNode *N);\n\n  LLVMContext &getContext() const { return Context.getContext(); }\n\n  /// Replace a specific operand.\n  void replaceOperandWith(unsigned I, Metadata *New);\n\n  /// Check if node is fully resolved.\n  ///\n  /// If \\a isTemporary(), this always returns \\c false; if \\a isDistinct(),\n  /// this always returns \\c true.\n  ///\n  /// If \\a isUniqued(), returns \\c true if this has already dropped RAUW\n  /// support (because all operands are resolved).\n  ///\n  /// As forward declarations are resolved, their containers should get\n  /// resolved automatically.  However, if this (or one of its operands) is\n  /// involved in a cycle, \\a resolveCycles() needs to be called explicitly.\n  bool isResolved() const { return !isTemporary() && !NumUnresolved; }\n\n  bool isUniqued() const { return Storage == Uniqued; }\n  bool isDistinct() const { return Storage == Distinct; }\n  bool isTemporary() const { return Storage == Temporary; }\n\n  /// RAUW a temporary.\n  ///\n  /// \\pre \\a isTemporary() must be \\c true.\n  void replaceAllUsesWith(Metadata *MD) {\n    assert(isTemporary() && \"Expected temporary node\");\n    if (Context.hasReplaceableUses())\n      Context.getReplaceableUses()->replaceAllUsesWith(MD);\n  }\n\n  /// Resolve cycles.\n  ///\n  /// Once all forward declarations have been resolved, force cycles to be\n  /// resolved.\n  ///\n  /// \\pre No operands (or operands' operands, etc.) have \\a isTemporary().\n  void resolveCycles();\n\n  /// Resolve a unique, unresolved node.\n  void resolve();\n\n  /// Replace a temporary node with a permanent one.\n  ///\n  /// Try to create a uniqued version of \\c N -- in place, if possible -- and\n  /// return it.  If \\c N cannot be uniqued, return a distinct node instead.\n  template <class T>\n  static std::enable_if_t<std::is_base_of<MDNode, T>::value, T *>\n  replaceWithPermanent(std::unique_ptr<T, TempMDNodeDeleter> N) {\n    return cast<T>(N.release()->replaceWithPermanentImpl());\n  }\n\n  /// Replace a temporary node with a uniqued one.\n  ///\n  /// Create a uniqued version of \\c N -- in place, if possible -- and return\n  /// it.  Takes ownership of the temporary node.\n  ///\n  /// \\pre N does not self-reference.\n  template <class T>\n  static std::enable_if_t<std::is_base_of<MDNode, T>::value, T *>\n  replaceWithUniqued(std::unique_ptr<T, TempMDNodeDeleter> N) {\n    return cast<T>(N.release()->replaceWithUniquedImpl());\n  }\n\n  /// Replace a temporary node with a distinct one.\n  ///\n  /// Create a distinct version of \\c N -- in place, if possible -- and return\n  /// it.  Takes ownership of the temporary node.\n  template <class T>\n  static std::enable_if_t<std::is_base_of<MDNode, T>::value, T *>\n  replaceWithDistinct(std::unique_ptr<T, TempMDNodeDeleter> N) {\n    return cast<T>(N.release()->replaceWithDistinctImpl());\n  }\n\nprivate:\n  MDNode *replaceWithPermanentImpl();\n  MDNode *replaceWithUniquedImpl();\n  MDNode *replaceWithDistinctImpl();\n\nprotected:\n  /// Set an operand.\n  ///\n  /// Sets the operand directly, without worrying about uniquing.\n  void setOperand(unsigned I, Metadata *New);\n\n  void storeDistinctInContext();\n  template <class T, class StoreT>\n  static T *storeImpl(T *N, StorageType Storage, StoreT &Store);\n  template <class T> static T *storeImpl(T *N, StorageType Storage);\n\nprivate:\n  void handleChangedOperand(void *Ref, Metadata *New);\n\n  /// Drop RAUW support, if any.\n  void dropReplaceableUses();\n\n  void resolveAfterOperandChange(Metadata *Old, Metadata *New);\n  void decrementUnresolvedOperandCount();\n  void countUnresolvedOperands();\n\n  /// Mutate this to be \"uniqued\".\n  ///\n  /// Mutate this so that \\a isUniqued().\n  /// \\pre \\a isTemporary().\n  /// \\pre already added to uniquing set.\n  void makeUniqued();\n\n  /// Mutate this to be \"distinct\".\n  ///\n  /// Mutate this so that \\a isDistinct().\n  /// \\pre \\a isTemporary().\n  void makeDistinct();\n\n  void deleteAsSubclass();\n  MDNode *uniquify();\n  void eraseFromStore();\n\n  template <class NodeTy> struct HasCachedHash;\n  template <class NodeTy>\n  static void dispatchRecalculateHash(NodeTy *N, std::true_type) {\n    N->recalculateHash();\n  }\n  template <class NodeTy>\n  static void dispatchRecalculateHash(NodeTy *, std::false_type) {}\n  template <class NodeTy>\n  static void dispatchResetHash(NodeTy *N, std::true_type) {\n    N->setHash(0);\n  }\n  template <class NodeTy>\n  static void dispatchResetHash(NodeTy *, std::false_type) {}\n\npublic:\n  using op_iterator = const MDOperand *;\n  using op_range = iterator_range<op_iterator>;\n\n  op_iterator op_begin() const {\n    return const_cast<MDNode *>(this)->mutable_begin();\n  }\n\n  op_iterator op_end() const {\n    return const_cast<MDNode *>(this)->mutable_end();\n  }\n\n  op_range operands() const { return op_range(op_begin(), op_end()); }\n\n  const MDOperand &getOperand(unsigned I) const {\n    assert(I < NumOperands && \"Out of range\");\n    return op_begin()[I];\n  }\n\n  /// Return number of MDNode operands.\n  unsigned getNumOperands() const { return NumOperands; }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Metadata *MD) {\n    switch (MD->getMetadataID()) {\n    default:\n      return false;\n#define HANDLE_MDNODE_LEAF(CLASS)                                              \\\n  case CLASS##Kind:                                                            \\\n    return true;\n#include \"llvm/IR/Metadata.def\"\n    }\n  }\n\n  /// Check whether MDNode is a vtable access.\n  bool isTBAAVtableAccess() const;\n\n  /// Methods for metadata merging.\n  static MDNode *concatenate(MDNode *A, MDNode *B);\n  static MDNode *intersect(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericTBAA(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericFPMath(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericRange(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericAliasScope(MDNode *A, MDNode *B);\n  static MDNode *getMostGenericAlignmentOrDereferenceable(MDNode *A, MDNode *B);\n};\n\n/// Tuple of metadata.\n///\n/// This is the simple \\a MDNode arbitrary tuple.  Nodes are uniqued by\n/// default based on their operands.\nclass MDTuple : public MDNode {\n  friend class LLVMContextImpl;\n  friend class MDNode;\n\n  MDTuple(LLVMContext &C, StorageType Storage, unsigned Hash,\n          ArrayRef<Metadata *> Vals)\n      : MDNode(C, MDTupleKind, Storage, Vals) {\n    setHash(Hash);\n  }\n\n  ~MDTuple() { dropAllReferences(); }\n\n  void setHash(unsigned Hash) { SubclassData32 = Hash; }\n  void recalculateHash();\n\n  static MDTuple *getImpl(LLVMContext &Context, ArrayRef<Metadata *> MDs,\n                          StorageType Storage, bool ShouldCreate = true);\n\n  TempMDTuple cloneImpl() const {\n    return getTemporary(getContext(), SmallVector<Metadata *, 4>(operands()));\n  }\n\npublic:\n  /// Get the hash, if any.\n  unsigned getHash() const { return SubclassData32; }\n\n  static MDTuple *get(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n    return getImpl(Context, MDs, Uniqued);\n  }\n\n  static MDTuple *getIfExists(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n    return getImpl(Context, MDs, Uniqued, /* ShouldCreate */ false);\n  }\n\n  /// Return a distinct node.\n  ///\n  /// Return a distinct node -- i.e., a node that is not uniqued.\n  static MDTuple *getDistinct(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n    return getImpl(Context, MDs, Distinct);\n  }\n\n  /// Return a temporary node.\n  ///\n  /// For use in constructing cyclic MDNode structures. A temporary MDNode is\n  /// not uniqued, may be RAUW'd, and must be manually deleted with\n  /// deleteTemporary.\n  static TempMDTuple getTemporary(LLVMContext &Context,\n                                  ArrayRef<Metadata *> MDs) {\n    return TempMDTuple(getImpl(Context, MDs, Temporary));\n  }\n\n  /// Return a (temporary) clone of this.\n  TempMDTuple clone() const { return cloneImpl(); }\n\n  static bool classof(const Metadata *MD) {\n    return MD->getMetadataID() == MDTupleKind;\n  }\n};\n\nMDTuple *MDNode::get(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n  return MDTuple::get(Context, MDs);\n}\n\nMDTuple *MDNode::getIfExists(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n  return MDTuple::getIfExists(Context, MDs);\n}\n\nMDTuple *MDNode::getDistinct(LLVMContext &Context, ArrayRef<Metadata *> MDs) {\n  return MDTuple::getDistinct(Context, MDs);\n}\n\nTempMDTuple MDNode::getTemporary(LLVMContext &Context,\n                                 ArrayRef<Metadata *> MDs) {\n  return MDTuple::getTemporary(Context, MDs);\n}\n\nvoid TempMDNodeDeleter::operator()(MDNode *Node) const {\n  MDNode::deleteTemporary(Node);\n}\n\n/// This is a simple wrapper around an MDNode which provides a higher-level\n/// interface by hiding the details of how alias analysis information is encoded\n/// in its operands.\nclass AliasScopeNode {\n  const MDNode *Node = nullptr;\n\npublic:\n  AliasScopeNode() = default;\n  explicit AliasScopeNode(const MDNode *N) : Node(N) {}\n\n  /// Get the MDNode for this AliasScopeNode.\n  const MDNode *getNode() const { return Node; }\n\n  /// Get the MDNode for this AliasScopeNode's domain.\n  const MDNode *getDomain() const {\n    if (Node->getNumOperands() < 2)\n      return nullptr;\n    return dyn_cast_or_null<MDNode>(Node->getOperand(1));\n  }\n  StringRef getName() const {\n    if (Node->getNumOperands() > 2)\n      if (MDString *N = dyn_cast_or_null<MDString>(Node->getOperand(2)))\n        return N->getString();\n    return StringRef();\n  }\n};\n\n/// Typed iterator through MDNode operands.\n///\n/// An iterator that transforms an \\a MDNode::iterator into an iterator over a\n/// particular Metadata subclass.\ntemplate <class T>\nclass TypedMDOperandIterator\n    : public std::iterator<std::input_iterator_tag, T *, std::ptrdiff_t, void,\n                           T *> {\n  MDNode::op_iterator I = nullptr;\n\npublic:\n  TypedMDOperandIterator() = default;\n  explicit TypedMDOperandIterator(MDNode::op_iterator I) : I(I) {}\n\n  T *operator*() const { return cast_or_null<T>(*I); }\n\n  TypedMDOperandIterator &operator++() {\n    ++I;\n    return *this;\n  }\n\n  TypedMDOperandIterator operator++(int) {\n    TypedMDOperandIterator Temp(*this);\n    ++I;\n    return Temp;\n  }\n\n  bool operator==(const TypedMDOperandIterator &X) const { return I == X.I; }\n  bool operator!=(const TypedMDOperandIterator &X) const { return I != X.I; }\n};\n\n/// Typed, array-like tuple of metadata.\n///\n/// This is a wrapper for \\a MDTuple that makes it act like an array holding a\n/// particular type of metadata.\ntemplate <class T> class MDTupleTypedArrayWrapper {\n  const MDTuple *N = nullptr;\n\npublic:\n  MDTupleTypedArrayWrapper() = default;\n  MDTupleTypedArrayWrapper(const MDTuple *N) : N(N) {}\n\n  template <class U>\n  MDTupleTypedArrayWrapper(\n      const MDTupleTypedArrayWrapper<U> &Other,\n      std::enable_if_t<std::is_convertible<U *, T *>::value> * = nullptr)\n      : N(Other.get()) {}\n\n  template <class U>\n  explicit MDTupleTypedArrayWrapper(\n      const MDTupleTypedArrayWrapper<U> &Other,\n      std::enable_if_t<!std::is_convertible<U *, T *>::value> * = nullptr)\n      : N(Other.get()) {}\n\n  explicit operator bool() const { return get(); }\n  explicit operator MDTuple *() const { return get(); }\n\n  MDTuple *get() const { return const_cast<MDTuple *>(N); }\n  MDTuple *operator->() const { return get(); }\n  MDTuple &operator*() const { return *get(); }\n\n  // FIXME: Fix callers and remove condition on N.\n  unsigned size() const { return N ? N->getNumOperands() : 0u; }\n  bool empty() const { return N ? N->getNumOperands() == 0 : true; }\n  T *operator[](unsigned I) const { return cast_or_null<T>(N->getOperand(I)); }\n\n  // FIXME: Fix callers and remove condition on N.\n  using iterator = TypedMDOperandIterator<T>;\n\n  iterator begin() const { return N ? iterator(N->op_begin()) : iterator(); }\n  iterator end() const { return N ? iterator(N->op_end()) : iterator(); }\n};\n\n#define HANDLE_METADATA(CLASS)                                                 \\\n  using CLASS##Array = MDTupleTypedArrayWrapper<CLASS>;\n#include \"llvm/IR/Metadata.def\"\n\n/// Placeholder metadata for operands of distinct MDNodes.\n///\n/// This is a lightweight placeholder for an operand of a distinct node.  It's\n/// purpose is to help track forward references when creating a distinct node.\n/// This allows distinct nodes involved in a cycle to be constructed before\n/// their operands without requiring a heavyweight temporary node with\n/// full-blown RAUW support.\n///\n/// Each placeholder supports only a single MDNode user.  Clients should pass\n/// an ID, retrieved via \\a getID(), to indicate the \"real\" operand that this\n/// should be replaced with.\n///\n/// While it would be possible to implement move operators, they would be\n/// fairly expensive.  Leave them unimplemented to discourage their use\n/// (clients can use std::deque, std::list, BumpPtrAllocator, etc.).\nclass DistinctMDOperandPlaceholder : public Metadata {\n  friend class MetadataTracking;\n\n  Metadata **Use = nullptr;\n\npublic:\n  explicit DistinctMDOperandPlaceholder(unsigned ID)\n      : Metadata(DistinctMDOperandPlaceholderKind, Distinct) {\n    SubclassData32 = ID;\n  }\n\n  DistinctMDOperandPlaceholder() = delete;\n  DistinctMDOperandPlaceholder(DistinctMDOperandPlaceholder &&) = delete;\n  DistinctMDOperandPlaceholder(const DistinctMDOperandPlaceholder &) = delete;\n\n  ~DistinctMDOperandPlaceholder() {\n    if (Use)\n      *Use = nullptr;\n  }\n\n  unsigned getID() const { return SubclassData32; }\n\n  /// Replace the use of this with MD.\n  void replaceUseWith(Metadata *MD) {\n    if (!Use)\n      return;\n    *Use = MD;\n\n    if (*Use)\n      MetadataTracking::track(*Use);\n\n    Metadata *T = cast<Metadata>(this);\n    MetadataTracking::untrack(T);\n    assert(!Use && \"Use is still being tracked despite being untracked!\");\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// A tuple of MDNodes.\n///\n/// Despite its name, a NamedMDNode isn't itself an MDNode.\n///\n/// NamedMDNodes are named module-level entities that contain lists of MDNodes.\n///\n/// It is illegal for a NamedMDNode to appear as an operand of an MDNode.\nclass NamedMDNode : public ilist_node<NamedMDNode> {\n  friend class LLVMContextImpl;\n  friend class Module;\n\n  std::string Name;\n  Module *Parent = nullptr;\n  void *Operands; // SmallVector<TrackingMDRef, 4>\n\n  void setParent(Module *M) { Parent = M; }\n\n  explicit NamedMDNode(const Twine &N);\n\n  template<class T1, class T2>\n  class op_iterator_impl :\n      public std::iterator<std::bidirectional_iterator_tag, T2> {\n    friend class NamedMDNode;\n\n    const NamedMDNode *Node = nullptr;\n    unsigned Idx = 0;\n\n    op_iterator_impl(const NamedMDNode *N, unsigned i) : Node(N), Idx(i) {}\n\n  public:\n    op_iterator_impl() = default;\n\n    bool operator==(const op_iterator_impl &o) const { return Idx == o.Idx; }\n    bool operator!=(const op_iterator_impl &o) const { return Idx != o.Idx; }\n\n    op_iterator_impl &operator++() {\n      ++Idx;\n      return *this;\n    }\n\n    op_iterator_impl operator++(int) {\n      op_iterator_impl tmp(*this);\n      operator++();\n      return tmp;\n    }\n\n    op_iterator_impl &operator--() {\n      --Idx;\n      return *this;\n    }\n\n    op_iterator_impl operator--(int) {\n      op_iterator_impl tmp(*this);\n      operator--();\n      return tmp;\n    }\n\n    T1 operator*() const { return Node->getOperand(Idx); }\n  };\n\npublic:\n  NamedMDNode(const NamedMDNode &) = delete;\n  ~NamedMDNode();\n\n  /// Drop all references and remove the node from parent module.\n  void eraseFromParent();\n\n  /// Remove all uses and clear node vector.\n  void dropAllReferences() { clearOperands(); }\n  /// Drop all references to this node's operands.\n  void clearOperands();\n\n  /// Get the module that holds this named metadata collection.\n  inline Module *getParent() { return Parent; }\n  inline const Module *getParent() const { return Parent; }\n\n  MDNode *getOperand(unsigned i) const;\n  unsigned getNumOperands() const;\n  void addOperand(MDNode *M);\n  void setOperand(unsigned I, MDNode *New);\n  StringRef getName() const;\n  void print(raw_ostream &ROS, bool IsForDebug = false) const;\n  void print(raw_ostream &ROS, ModuleSlotTracker &MST,\n             bool IsForDebug = false) const;\n  void dump() const;\n\n  // ---------------------------------------------------------------------------\n  // Operand Iterator interface...\n  //\n  using op_iterator = op_iterator_impl<MDNode *, MDNode>;\n\n  op_iterator op_begin() { return op_iterator(this, 0); }\n  op_iterator op_end()   { return op_iterator(this, getNumOperands()); }\n\n  using const_op_iterator = op_iterator_impl<const MDNode *, MDNode>;\n\n  const_op_iterator op_begin() const { return const_op_iterator(this, 0); }\n  const_op_iterator op_end()   const { return const_op_iterator(this, getNumOperands()); }\n\n  inline iterator_range<op_iterator>  operands() {\n    return make_range(op_begin(), op_end());\n  }\n  inline iterator_range<const_op_iterator> operands() const {\n    return make_range(op_begin(), op_end());\n  }\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_ISA_CONVERSION_FUNCTIONS(NamedMDNode, LLVMNamedMDNodeRef)\n\n} // end namespace llvm\n\n#endif // LLVM_IR_METADATA_H\n"}, "52": {"id": 52, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "content": "//===- PassManager.h - Pass management infrastructure -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n///\n/// This header defines various interfaces for pass management in LLVM. There\n/// is no \"pass\" interface in LLVM per se. Instead, an instance of any class\n/// which supports a method to 'run' it over a unit of IR can be used as\n/// a pass. A pass manager is generally a tool to collect a sequence of passes\n/// which run over a particular IR construct, and run each of them in sequence\n/// over each such construct in the containing IR construct. As there is no\n/// containing IR construct for a Module, a manager for passes over modules\n/// forms the base case which runs its managed passes in sequence over the\n/// single module provided.\n///\n/// The core IR library provides managers for running passes over\n/// modules and functions.\n///\n/// * FunctionPassManager can run over a Module, runs each pass over\n///   a Function.\n/// * ModulePassManager must be directly run, runs each pass over the Module.\n///\n/// Note that the implementations of the pass managers use concept-based\n/// polymorphism as outlined in the \"Value Semantics and Concept-based\n/// Polymorphism\" talk (or its abbreviated sibling \"Inheritance Is The Base\n/// Class of Evil\") by Sean Parent:\n/// * http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations\n/// * http://www.youtube.com/watch?v=_BpMYeUFXv8\n/// * http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_PASSMANAGER_H\n#define LLVM_IR_PASSMANAGER_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/PassInstrumentation.h\"\n#include \"llvm/IR/PassManagerInternal.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/TimeProfiler.h\"\n#include \"llvm/Support/TypeName.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iterator>\n#include <list>\n#include <memory>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\n/// A special type used by analysis passes to provide an address that\n/// identifies that particular analysis pass type.\n///\n/// Analysis passes should have a static data member of this type and derive\n/// from the \\c AnalysisInfoMixin to get a static ID method used to identify\n/// the analysis in the pass management infrastructure.\nstruct alignas(8) AnalysisKey {};\n\n/// A special type used to provide an address that identifies a set of related\n/// analyses.  These sets are primarily used below to mark sets of analyses as\n/// preserved.\n///\n/// For example, a transformation can indicate that it preserves the CFG of a\n/// function by preserving the appropriate AnalysisSetKey.  An analysis that\n/// depends only on the CFG can then check if that AnalysisSetKey is preserved;\n/// if it is, the analysis knows that it itself is preserved.\nstruct alignas(8) AnalysisSetKey {};\n\n/// This templated class represents \"all analyses that operate over \\<a\n/// particular IR unit\\>\" (e.g. a Function or a Module) in instances of\n/// PreservedAnalysis.\n///\n/// This lets a transformation say e.g. \"I preserved all function analyses\".\n///\n/// Note that you must provide an explicit instantiation declaration and\n/// definition for this template in order to get the correct behavior on\n/// Windows. Otherwise, the address of SetKey will not be stable.\ntemplate <typename IRUnitT> class AllAnalysesOn {\npublic:\n  static AnalysisSetKey *ID() { return &SetKey; }\n\nprivate:\n  static AnalysisSetKey SetKey;\n};\n\ntemplate <typename IRUnitT> AnalysisSetKey AllAnalysesOn<IRUnitT>::SetKey;\n\nextern template class AllAnalysesOn<Module>;\nextern template class AllAnalysesOn<Function>;\n\n/// Represents analyses that only rely on functions' control flow.\n///\n/// This can be used with \\c PreservedAnalyses to mark the CFG as preserved and\n/// to query whether it has been preserved.\n///\n/// The CFG of a function is defined as the set of basic blocks and the edges\n/// between them. Changing the set of basic blocks in a function is enough to\n/// mutate the CFG. Mutating the condition of a branch or argument of an\n/// invoked function does not mutate the CFG, but changing the successor labels\n/// of those instructions does.\nclass CFGAnalyses {\npublic:\n  static AnalysisSetKey *ID() { return &SetKey; }\n\nprivate:\n  static AnalysisSetKey SetKey;\n};\n\n/// A set of analyses that are preserved following a run of a transformation\n/// pass.\n///\n/// Transformation passes build and return these objects to communicate which\n/// analyses are still valid after the transformation. For most passes this is\n/// fairly simple: if they don't change anything all analyses are preserved,\n/// otherwise only a short list of analyses that have been explicitly updated\n/// are preserved.\n///\n/// This class also lets transformation passes mark abstract *sets* of analyses\n/// as preserved. A transformation that (say) does not alter the CFG can\n/// indicate such by marking a particular AnalysisSetKey as preserved, and\n/// then analyses can query whether that AnalysisSetKey is preserved.\n///\n/// Finally, this class can represent an \"abandoned\" analysis, which is\n/// not preserved even if it would be covered by some abstract set of analyses.\n///\n/// Given a `PreservedAnalyses` object, an analysis will typically want to\n/// figure out whether it is preserved. In the example below, MyAnalysisType is\n/// preserved if it's not abandoned, and (a) it's explicitly marked as\n/// preserved, (b), the set AllAnalysesOn<MyIRUnit> is preserved, or (c) both\n/// AnalysisSetA and AnalysisSetB are preserved.\n///\n/// ```\n///   auto PAC = PA.getChecker<MyAnalysisType>();\n///   if (PAC.preserved() || PAC.preservedSet<AllAnalysesOn<MyIRUnit>>() ||\n///       (PAC.preservedSet<AnalysisSetA>() &&\n///        PAC.preservedSet<AnalysisSetB>())) {\n///     // The analysis has been successfully preserved ...\n///   }\n/// ```\nclass PreservedAnalyses {\npublic:\n  /// Convenience factory function for the empty preserved set.\n  static PreservedAnalyses none() { return PreservedAnalyses(); }\n\n  /// Construct a special preserved set that preserves all passes.\n  static PreservedAnalyses all() {\n    PreservedAnalyses PA;\n    PA.PreservedIDs.insert(&AllAnalysesKey);\n    return PA;\n  }\n\n  /// Construct a preserved analyses object with a single preserved set.\n  template <typename AnalysisSetT>\n  static PreservedAnalyses allInSet() {\n    PreservedAnalyses PA;\n    PA.preserveSet<AnalysisSetT>();\n    return PA;\n  }\n\n  /// Mark an analysis as preserved.\n  template <typename AnalysisT> void preserve() { preserve(AnalysisT::ID()); }\n\n  /// Given an analysis's ID, mark the analysis as preserved, adding it\n  /// to the set.\n  void preserve(AnalysisKey *ID) {\n    // Clear this ID from the explicit not-preserved set if present.\n    NotPreservedAnalysisIDs.erase(ID);\n\n    // If we're not already preserving all analyses (other than those in\n    // NotPreservedAnalysisIDs).\n    if (!areAllPreserved())\n      PreservedIDs.insert(ID);\n  }\n\n  /// Mark an analysis set as preserved.\n  template <typename AnalysisSetT> void preserveSet() {\n    preserveSet(AnalysisSetT::ID());\n  }\n\n  /// Mark an analysis set as preserved using its ID.\n  void preserveSet(AnalysisSetKey *ID) {\n    // If we're not already in the saturated 'all' state, add this set.\n    if (!areAllPreserved())\n      PreservedIDs.insert(ID);\n  }\n\n  /// Mark an analysis as abandoned.\n  ///\n  /// An abandoned analysis is not preserved, even if it is nominally covered\n  /// by some other set or was previously explicitly marked as preserved.\n  ///\n  /// Note that you can only abandon a specific analysis, not a *set* of\n  /// analyses.\n  template <typename AnalysisT> void abandon() { abandon(AnalysisT::ID()); }\n\n  /// Mark an analysis as abandoned using its ID.\n  ///\n  /// An abandoned analysis is not preserved, even if it is nominally covered\n  /// by some other set or was previously explicitly marked as preserved.\n  ///\n  /// Note that you can only abandon a specific analysis, not a *set* of\n  /// analyses.\n  void abandon(AnalysisKey *ID) {\n    PreservedIDs.erase(ID);\n    NotPreservedAnalysisIDs.insert(ID);\n  }\n\n  /// Intersect this set with another in place.\n  ///\n  /// This is a mutating operation on this preserved set, removing all\n  /// preserved passes which are not also preserved in the argument.\n  void intersect(const PreservedAnalyses &Arg) {\n    if (Arg.areAllPreserved())\n      return;\n    if (areAllPreserved()) {\n      *this = Arg;\n      return;\n    }\n    // The intersection requires the *union* of the explicitly not-preserved\n    // IDs and the *intersection* of the preserved IDs.\n    for (auto ID : Arg.NotPreservedAnalysisIDs) {\n      PreservedIDs.erase(ID);\n      NotPreservedAnalysisIDs.insert(ID);\n    }\n    for (auto ID : PreservedIDs)\n      if (!Arg.PreservedIDs.count(ID))\n        PreservedIDs.erase(ID);\n  }\n\n  /// Intersect this set with a temporary other set in place.\n  ///\n  /// This is a mutating operation on this preserved set, removing all\n  /// preserved passes which are not also preserved in the argument.\n  void intersect(PreservedAnalyses &&Arg) {\n    if (Arg.areAllPreserved())\n      return;\n    if (areAllPreserved()) {\n      *this = std::move(Arg);\n      return;\n    }\n    // The intersection requires the *union* of the explicitly not-preserved\n    // IDs and the *intersection* of the preserved IDs.\n    for (auto ID : Arg.NotPreservedAnalysisIDs) {\n      PreservedIDs.erase(ID);\n      NotPreservedAnalysisIDs.insert(ID);\n    }\n    for (auto ID : PreservedIDs)\n      if (!Arg.PreservedIDs.count(ID))\n        PreservedIDs.erase(ID);\n  }\n\n  /// A checker object that makes it easy to query for whether an analysis or\n  /// some set covering it is preserved.\n  class PreservedAnalysisChecker {\n    friend class PreservedAnalyses;\n\n    const PreservedAnalyses &PA;\n    AnalysisKey *const ID;\n    const bool IsAbandoned;\n\n    /// A PreservedAnalysisChecker is tied to a particular Analysis because\n    /// `preserved()` and `preservedSet()` both return false if the Analysis\n    /// was abandoned.\n    PreservedAnalysisChecker(const PreservedAnalyses &PA, AnalysisKey *ID)\n        : PA(PA), ID(ID), IsAbandoned(PA.NotPreservedAnalysisIDs.count(ID)) {}\n\n  public:\n    /// Returns true if the checker's analysis was not abandoned and either\n    ///  - the analysis is explicitly preserved or\n    ///  - all analyses are preserved.\n    bool preserved() {\n      return !IsAbandoned && (PA.PreservedIDs.count(&AllAnalysesKey) ||\n                              PA.PreservedIDs.count(ID));\n    }\n\n    /// Return true if the checker's analysis was not abandoned, i.e. it was not\n    /// explicitly invalidated. Even if the analysis is not explicitly\n    /// preserved, if the analysis is known stateless, then it is preserved.\n    bool preservedWhenStateless() {\n      return !IsAbandoned;\n    }\n\n    /// Returns true if the checker's analysis was not abandoned and either\n    ///  - \\p AnalysisSetT is explicitly preserved or\n    ///  - all analyses are preserved.\n    template <typename AnalysisSetT> bool preservedSet() {\n      AnalysisSetKey *SetID = AnalysisSetT::ID();\n      return !IsAbandoned && (PA.PreservedIDs.count(&AllAnalysesKey) ||\n                              PA.PreservedIDs.count(SetID));\n    }\n  };\n\n  /// Build a checker for this `PreservedAnalyses` and the specified analysis\n  /// type.\n  ///\n  /// You can use the returned object to query whether an analysis was\n  /// preserved. See the example in the comment on `PreservedAnalysis`.\n  template <typename AnalysisT> PreservedAnalysisChecker getChecker() const {\n    return PreservedAnalysisChecker(*this, AnalysisT::ID());\n  }\n\n  /// Build a checker for this `PreservedAnalyses` and the specified analysis\n  /// ID.\n  ///\n  /// You can use the returned object to query whether an analysis was\n  /// preserved. See the example in the comment on `PreservedAnalysis`.\n  PreservedAnalysisChecker getChecker(AnalysisKey *ID) const {\n    return PreservedAnalysisChecker(*this, ID);\n  }\n\n  /// Test whether all analyses are preserved (and none are abandoned).\n  ///\n  /// This is used primarily to optimize for the common case of a transformation\n  /// which makes no changes to the IR.\n  bool areAllPreserved() const {\n    return NotPreservedAnalysisIDs.empty() &&\n           PreservedIDs.count(&AllAnalysesKey);\n  }\n\n  /// Directly test whether a set of analyses is preserved.\n  ///\n  /// This is only true when no analyses have been explicitly abandoned.\n  template <typename AnalysisSetT> bool allAnalysesInSetPreserved() const {\n    return allAnalysesInSetPreserved(AnalysisSetT::ID());\n  }\n\n  /// Directly test whether a set of analyses is preserved.\n  ///\n  /// This is only true when no analyses have been explicitly abandoned.\n  bool allAnalysesInSetPreserved(AnalysisSetKey *SetID) const {\n    return NotPreservedAnalysisIDs.empty() &&\n           (PreservedIDs.count(&AllAnalysesKey) || PreservedIDs.count(SetID));\n  }\n\nprivate:\n  /// A special key used to indicate all analyses.\n  static AnalysisSetKey AllAnalysesKey;\n\n  /// The IDs of analyses and analysis sets that are preserved.\n  SmallPtrSet<void *, 2> PreservedIDs;\n\n  /// The IDs of explicitly not-preserved analyses.\n  ///\n  /// If an analysis in this set is covered by a set in `PreservedIDs`, we\n  /// consider it not-preserved. That is, `NotPreservedAnalysisIDs` always\n  /// \"wins\" over analysis sets in `PreservedIDs`.\n  ///\n  /// Also, a given ID should never occur both here and in `PreservedIDs`.\n  SmallPtrSet<AnalysisKey *, 2> NotPreservedAnalysisIDs;\n};\n\n// Forward declare the analysis manager template.\ntemplate <typename IRUnitT, typename... ExtraArgTs> class AnalysisManager;\n\n/// A CRTP mix-in to automatically provide informational APIs needed for\n/// passes.\n///\n/// This provides some boilerplate for types that are passes.\ntemplate <typename DerivedT> struct PassInfoMixin {\n  /// Gets the name of the pass we are mixed into.\n  static StringRef name() {\n    static_assert(std::is_base_of<PassInfoMixin, DerivedT>::value,\n                  \"Must pass the derived type as the template argument!\");\n    StringRef Name = getTypeName<DerivedT>();\n    if (Name.startswith(\"llvm::\"))\n      Name = Name.drop_front(strlen(\"llvm::\"));\n    return Name;\n  }\n};\n\n/// A CRTP mix-in that provides informational APIs needed for analysis passes.\n///\n/// This provides some boilerplate for types that are analysis passes. It\n/// automatically mixes in \\c PassInfoMixin.\ntemplate <typename DerivedT>\nstruct AnalysisInfoMixin : PassInfoMixin<DerivedT> {\n  /// Returns an opaque, unique ID for this analysis type.\n  ///\n  /// This ID is a pointer type that is guaranteed to be 8-byte aligned and thus\n  /// suitable for use in sets, maps, and other data structures that use the low\n  /// bits of pointers.\n  ///\n  /// Note that this requires the derived type provide a static \\c AnalysisKey\n  /// member called \\c Key.\n  ///\n  /// FIXME: The only reason the mixin type itself can't declare the Key value\n  /// is that some compilers cannot correctly unique a templated static variable\n  /// so it has the same addresses in each instantiation. The only currently\n  /// known platform with this limitation is Windows DLL builds, specifically\n  /// building each part of LLVM as a DLL. If we ever remove that build\n  /// configuration, this mixin can provide the static key as well.\n  static AnalysisKey *ID() {\n    static_assert(std::is_base_of<AnalysisInfoMixin, DerivedT>::value,\n                  \"Must pass the derived type as the template argument!\");\n    return &DerivedT::Key;\n  }\n};\n\nnamespace detail {\n\n/// Actual unpacker of extra arguments in getAnalysisResult,\n/// passes only those tuple arguments that are mentioned in index_sequence.\ntemplate <typename PassT, typename IRUnitT, typename AnalysisManagerT,\n          typename... ArgTs, size_t... Ns>\ntypename PassT::Result\ngetAnalysisResultUnpackTuple(AnalysisManagerT &AM, IRUnitT &IR,\n                             std::tuple<ArgTs...> Args,\n                             std::index_sequence<Ns...>) {\n  (void)Args;\n  return AM.template getResult<PassT>(IR, std::get<Ns>(Args)...);\n}\n\n/// Helper for *partial* unpacking of extra arguments in getAnalysisResult.\n///\n/// Arguments passed in tuple come from PassManager, so they might have extra\n/// arguments after those AnalysisManager's ExtraArgTs ones that we need to\n/// pass to getResult.\ntemplate <typename PassT, typename IRUnitT, typename... AnalysisArgTs,\n          typename... MainArgTs>\ntypename PassT::Result\ngetAnalysisResult(AnalysisManager<IRUnitT, AnalysisArgTs...> &AM, IRUnitT &IR,\n                  std::tuple<MainArgTs...> Args) {\n  return (getAnalysisResultUnpackTuple<\n          PassT, IRUnitT>)(AM, IR, Args,\n                           std::index_sequence_for<AnalysisArgTs...>{});\n}\n\n} // namespace detail\n\n// Forward declare the pass instrumentation analysis explicitly queried in\n// generic PassManager code.\n// FIXME: figure out a way to move PassInstrumentationAnalysis into its own\n// header.\nclass PassInstrumentationAnalysis;\n\n/// Manages a sequence of passes over a particular unit of IR.\n///\n/// A pass manager contains a sequence of passes to run over a particular unit\n/// of IR (e.g. Functions, Modules). It is itself a valid pass over that unit of\n/// IR, and when run over some given IR will run each of its contained passes in\n/// sequence. Pass managers are the primary and most basic building block of a\n/// pass pipeline.\n///\n/// When you run a pass manager, you provide an \\c AnalysisManager<IRUnitT>\n/// argument. The pass manager will propagate that analysis manager to each\n/// pass it runs, and will call the analysis manager's invalidation routine with\n/// the PreservedAnalyses of each pass it runs.\ntemplate <typename IRUnitT,\n          typename AnalysisManagerT = AnalysisManager<IRUnitT>,\n          typename... ExtraArgTs>\nclass PassManager : public PassInfoMixin<\n                        PassManager<IRUnitT, AnalysisManagerT, ExtraArgTs...>> {\npublic:\n  /// Construct a pass manager.\n  ///\n  /// If \\p DebugLogging is true, we'll log our progress to llvm::dbgs().\n  explicit PassManager(bool DebugLogging = false) : DebugLogging(DebugLogging) {}\n\n  // FIXME: These are equivalent to the default move constructor/move\n  // assignment. However, using = default triggers linker errors due to the\n  // explicit instantiations below. Find away to use the default and remove the\n  // duplicated code here.\n  PassManager(PassManager &&Arg)\n      : Passes(std::move(Arg.Passes)),\n        DebugLogging(std::move(Arg.DebugLogging)) {}\n\n  PassManager &operator=(PassManager &&RHS) {\n    Passes = std::move(RHS.Passes);\n    DebugLogging = std::move(RHS.DebugLogging);\n    return *this;\n  }\n\n  /// Run all of the passes in this manager over the given unit of IR.\n  /// ExtraArgs are passed to each pass.\n  PreservedAnalyses run(IRUnitT &IR, AnalysisManagerT &AM,\n                        ExtraArgTs... ExtraArgs) {\n    PreservedAnalyses PA = PreservedAnalyses::all();\n\n    // Request PassInstrumentation from analysis manager, will use it to run\n    // instrumenting callbacks for the passes later.\n    // Here we use std::tuple wrapper over getResult which helps to extract\n    // AnalysisManager's arguments out of the whole ExtraArgs set.\n    PassInstrumentation PI =\n        detail::getAnalysisResult<PassInstrumentationAnalysis>(\n            AM, IR, std::tuple<ExtraArgTs...>(ExtraArgs...));\n\n    if (DebugLogging)\n      dbgs() << \"Starting \" << getTypeName<IRUnitT>() << \" pass manager run.\\n\";\n\n    for (unsigned Idx = 0, Size = Passes.size(); Idx != Size; ++Idx) {\n      auto *P = Passes[Idx].get();\n\n      // Check the PassInstrumentation's BeforePass callbacks before running the\n      // pass, skip its execution completely if asked to (callback returns\n      // false).\n      if (!PI.runBeforePass<IRUnitT>(*P, IR))\n        continue;\n\n      PreservedAnalyses PassPA;\n      {\n        TimeTraceScope TimeScope(P->name(), IR.getName());\n        PassPA = P->run(IR, AM, ExtraArgs...);\n      }\n\n      // Call onto PassInstrumentation's AfterPass callbacks immediately after\n      // running the pass.\n      PI.runAfterPass<IRUnitT>(*P, IR, PassPA);\n\n      // Update the analysis manager as each pass runs and potentially\n      // invalidates analyses.\n      AM.invalidate(IR, PassPA);\n\n      // Finally, intersect the preserved analyses to compute the aggregate\n      // preserved set for this pass manager.\n      PA.intersect(std::move(PassPA));\n\n      // FIXME: Historically, the pass managers all called the LLVM context's\n      // yield function here. We don't have a generic way to acquire the\n      // context and it isn't yet clear what the right pattern is for yielding\n      // in the new pass manager so it is currently omitted.\n      //IR.getContext().yield();\n    }\n\n    // Invalidation was handled after each pass in the above loop for the\n    // current unit of IR. Therefore, the remaining analysis results in the\n    // AnalysisManager are preserved. We mark this with a set so that we don't\n    // need to inspect each one individually.\n    PA.preserveSet<AllAnalysesOn<IRUnitT>>();\n\n    if (DebugLogging)\n      dbgs() << \"Finished \" << getTypeName<IRUnitT>() << \" pass manager run.\\n\";\n\n    return PA;\n  }\n\n  template <typename PassT>\n  std::enable_if_t<!std::is_same<PassT, PassManager>::value>\n  addPass(PassT Pass) {\n    using PassModelT =\n        detail::PassModel<IRUnitT, PassT, PreservedAnalyses, AnalysisManagerT,\n                          ExtraArgTs...>;\n\n    Passes.emplace_back(new PassModelT(std::move(Pass)));\n  }\n\n  /// When adding a pass manager pass that has the same type as this pass\n  /// manager, simply move the passes over. This is because we don't have use\n  /// cases rely on executing nested pass managers. Doing this could reduce\n  /// implementation complexity and avoid potential invalidation issues that may\n  /// happen with nested pass managers of the same type.\n  template <typename PassT>\n  std::enable_if_t<std::is_same<PassT, PassManager>::value>\n  addPass(PassT &&Pass) {\n    for (auto &P : Pass.Passes)\n      Passes.emplace_back(std::move(P));\n  }\n\n  /// Returns if the pass manager contains any passes.\n  bool isEmpty() const { return Passes.empty(); }\n\n  static bool isRequired() { return true; }\n\nprotected:\n  using PassConceptT =\n      detail::PassConcept<IRUnitT, AnalysisManagerT, ExtraArgTs...>;\n\n  std::vector<std::unique_ptr<PassConceptT>> Passes;\n\n  /// Flag indicating whether we should do debug logging.\n  bool DebugLogging;\n};\n\nextern template class PassManager<Module>;\n\n/// Convenience typedef for a pass manager over modules.\nusing ModulePassManager = PassManager<Module>;\n\nextern template class PassManager<Function>;\n\n/// Convenience typedef for a pass manager over functions.\nusing FunctionPassManager = PassManager<Function>;\n\n/// Pseudo-analysis pass that exposes the \\c PassInstrumentation to pass\n/// managers. Goes before AnalysisManager definition to provide its\n/// internals (e.g PassInstrumentationAnalysis::ID) for use there if needed.\n/// FIXME: figure out a way to move PassInstrumentationAnalysis into its own\n/// header.\nclass PassInstrumentationAnalysis\n    : public AnalysisInfoMixin<PassInstrumentationAnalysis> {\n  friend AnalysisInfoMixin<PassInstrumentationAnalysis>;\n  static AnalysisKey Key;\n\n  PassInstrumentationCallbacks *Callbacks;\n\npublic:\n  /// PassInstrumentationCallbacks object is shared, owned by something else,\n  /// not this analysis.\n  PassInstrumentationAnalysis(PassInstrumentationCallbacks *Callbacks = nullptr)\n      : Callbacks(Callbacks) {}\n\n  using Result = PassInstrumentation;\n\n  template <typename IRUnitT, typename AnalysisManagerT, typename... ExtraArgTs>\n  Result run(IRUnitT &, AnalysisManagerT &, ExtraArgTs &&...) {\n    return PassInstrumentation(Callbacks);\n  }\n};\n\n/// A container for analyses that lazily runs them and caches their\n/// results.\n///\n/// This class can manage analyses for any IR unit where the address of the IR\n/// unit sufficies as its identity.\ntemplate <typename IRUnitT, typename... ExtraArgTs> class AnalysisManager {\npublic:\n  class Invalidator;\n\nprivate:\n  // Now that we've defined our invalidator, we can define the concept types.\n  using ResultConceptT =\n      detail::AnalysisResultConcept<IRUnitT, PreservedAnalyses, Invalidator>;\n  using PassConceptT =\n      detail::AnalysisPassConcept<IRUnitT, PreservedAnalyses, Invalidator,\n                                  ExtraArgTs...>;\n\n  /// List of analysis pass IDs and associated concept pointers.\n  ///\n  /// Requires iterators to be valid across appending new entries and arbitrary\n  /// erases. Provides the analysis ID to enable finding iterators to a given\n  /// entry in maps below, and provides the storage for the actual result\n  /// concept.\n  using AnalysisResultListT =\n      std::list<std::pair<AnalysisKey *, std::unique_ptr<ResultConceptT>>>;\n\n  /// Map type from IRUnitT pointer to our custom list type.\n  using AnalysisResultListMapT = DenseMap<IRUnitT *, AnalysisResultListT>;\n\n  /// Map type from a pair of analysis ID and IRUnitT pointer to an\n  /// iterator into a particular result list (which is where the actual analysis\n  /// result is stored).\n  using AnalysisResultMapT =\n      DenseMap<std::pair<AnalysisKey *, IRUnitT *>,\n               typename AnalysisResultListT::iterator>;\n\npublic:\n  /// API to communicate dependencies between analyses during invalidation.\n  ///\n  /// When an analysis result embeds handles to other analysis results, it\n  /// needs to be invalidated both when its own information isn't preserved and\n  /// when any of its embedded analysis results end up invalidated. We pass an\n  /// \\c Invalidator object as an argument to \\c invalidate() in order to let\n  /// the analysis results themselves define the dependency graph on the fly.\n  /// This lets us avoid building an explicit representation of the\n  /// dependencies between analysis results.\n  class Invalidator {\n  public:\n    /// Trigger the invalidation of some other analysis pass if not already\n    /// handled and return whether it was in fact invalidated.\n    ///\n    /// This is expected to be called from within a given analysis result's \\c\n    /// invalidate method to trigger a depth-first walk of all inter-analysis\n    /// dependencies. The same \\p IR unit and \\p PA passed to that result's \\c\n    /// invalidate method should in turn be provided to this routine.\n    ///\n    /// The first time this is called for a given analysis pass, it will call\n    /// the corresponding result's \\c invalidate method.  Subsequent calls will\n    /// use a cache of the results of that initial call.  It is an error to form\n    /// cyclic dependencies between analysis results.\n    ///\n    /// This returns true if the given analysis's result is invalid. Any\n    /// dependecies on it will become invalid as a result.\n    template <typename PassT>\n    bool invalidate(IRUnitT &IR, const PreservedAnalyses &PA) {\n      using ResultModelT =\n          detail::AnalysisResultModel<IRUnitT, PassT, typename PassT::Result,\n                                      PreservedAnalyses, Invalidator>;\n\n      return invalidateImpl<ResultModelT>(PassT::ID(), IR, PA);\n    }\n\n    /// A type-erased variant of the above invalidate method with the same core\n    /// API other than passing an analysis ID rather than an analysis type\n    /// parameter.\n    ///\n    /// This is sadly less efficient than the above routine, which leverages\n    /// the type parameter to avoid the type erasure overhead.\n    bool invalidate(AnalysisKey *ID, IRUnitT &IR, const PreservedAnalyses &PA) {\n      return invalidateImpl<>(ID, IR, PA);\n    }\n\n  private:\n    friend class AnalysisManager;\n\n    template <typename ResultT = ResultConceptT>\n    bool invalidateImpl(AnalysisKey *ID, IRUnitT &IR,\n                        const PreservedAnalyses &PA) {\n      // If we've already visited this pass, return true if it was invalidated\n      // and false otherwise.\n      auto IMapI = IsResultInvalidated.find(ID);\n      if (IMapI != IsResultInvalidated.end())\n        return IMapI->second;\n\n      // Otherwise look up the result object.\n      auto RI = Results.find({ID, &IR});\n      assert(RI != Results.end() &&\n             \"Trying to invalidate a dependent result that isn't in the \"\n             \"manager's cache is always an error, likely due to a stale result \"\n             \"handle!\");\n\n      auto &Result = static_cast<ResultT &>(*RI->second->second);\n\n      // Insert into the map whether the result should be invalidated and return\n      // that. Note that we cannot reuse IMapI and must do a fresh insert here,\n      // as calling invalidate could (recursively) insert things into the map,\n      // making any iterator or reference invalid.\n      bool Inserted;\n      std::tie(IMapI, Inserted) =\n          IsResultInvalidated.insert({ID, Result.invalidate(IR, PA, *this)});\n      (void)Inserted;\n      assert(Inserted && \"Should not have already inserted this ID, likely \"\n                         \"indicates a dependency cycle!\");\n      return IMapI->second;\n    }\n\n    Invalidator(SmallDenseMap<AnalysisKey *, bool, 8> &IsResultInvalidated,\n                const AnalysisResultMapT &Results)\n        : IsResultInvalidated(IsResultInvalidated), Results(Results) {}\n\n    SmallDenseMap<AnalysisKey *, bool, 8> &IsResultInvalidated;\n    const AnalysisResultMapT &Results;\n  };\n\n  /// Construct an empty analysis manager.\n  ///\n  /// If \\p DebugLogging is true, we'll log our progress to llvm::dbgs().\n  AnalysisManager(bool DebugLogging = false);\n  AnalysisManager(AnalysisManager &&);\n  AnalysisManager &operator=(AnalysisManager &&);\n\n  /// Returns true if the analysis manager has an empty results cache.\n  bool empty() const {\n    assert(AnalysisResults.empty() == AnalysisResultLists.empty() &&\n           \"The storage and index of analysis results disagree on how many \"\n           \"there are!\");\n    return AnalysisResults.empty();\n  }\n\n  /// Clear any cached analysis results for a single unit of IR.\n  ///\n  /// This doesn't invalidate, but instead simply deletes, the relevant results.\n  /// It is useful when the IR is being removed and we want to clear out all the\n  /// memory pinned for it.\n  void clear(IRUnitT &IR, llvm::StringRef Name);\n\n  /// Clear all analysis results cached by this AnalysisManager.\n  ///\n  /// Like \\c clear(IRUnitT&), this doesn't invalidate the results; it simply\n  /// deletes them.  This lets you clean up the AnalysisManager when the set of\n  /// IR units itself has potentially changed, and thus we can't even look up a\n  /// a result and invalidate/clear it directly.\n  void clear() {\n    AnalysisResults.clear();\n    AnalysisResultLists.clear();\n  }\n\n  /// Get the result of an analysis pass for a given IR unit.\n  ///\n  /// Runs the analysis if a cached result is not available.\n  template <typename PassT>\n  typename PassT::Result &getResult(IRUnitT &IR, ExtraArgTs... ExtraArgs) {\n    assert(AnalysisPasses.count(PassT::ID()) &&\n           \"This analysis pass was not registered prior to being queried\");\n    ResultConceptT &ResultConcept =\n        getResultImpl(PassT::ID(), IR, ExtraArgs...);\n\n    using ResultModelT =\n        detail::AnalysisResultModel<IRUnitT, PassT, typename PassT::Result,\n                                    PreservedAnalyses, Invalidator>;\n\n    return static_cast<ResultModelT &>(ResultConcept).Result;\n  }\n\n  /// Get the cached result of an analysis pass for a given IR unit.\n  ///\n  /// This method never runs the analysis.\n  ///\n  /// \\returns null if there is no cached result.\n  template <typename PassT>\n  typename PassT::Result *getCachedResult(IRUnitT &IR) const {\n    assert(AnalysisPasses.count(PassT::ID()) &&\n           \"This analysis pass was not registered prior to being queried\");\n\n    ResultConceptT *ResultConcept = getCachedResultImpl(PassT::ID(), IR);\n    if (!ResultConcept)\n      return nullptr;\n\n    using ResultModelT =\n        detail::AnalysisResultModel<IRUnitT, PassT, typename PassT::Result,\n                                    PreservedAnalyses, Invalidator>;\n\n    return &static_cast<ResultModelT *>(ResultConcept)->Result;\n  }\n\n  /// Verify that the given Result cannot be invalidated, assert otherwise.\n  template <typename PassT>\n  void verifyNotInvalidated(IRUnitT &IR, typename PassT::Result *Result) const {\n    PreservedAnalyses PA = PreservedAnalyses::none();\n    SmallDenseMap<AnalysisKey *, bool, 8> IsResultInvalidated;\n    Invalidator Inv(IsResultInvalidated, AnalysisResults);\n    assert(!Result->invalidate(IR, PA, Inv) &&\n           \"Cached result cannot be invalidated\");\n  }\n\n  /// Register an analysis pass with the manager.\n  ///\n  /// The parameter is a callable whose result is an analysis pass. This allows\n  /// passing in a lambda to construct the analysis.\n  ///\n  /// The analysis type to register is the type returned by calling the \\c\n  /// PassBuilder argument. If that type has already been registered, then the\n  /// argument will not be called and this function will return false.\n  /// Otherwise, we register the analysis returned by calling \\c PassBuilder(),\n  /// and this function returns true.\n  ///\n  /// (Note: Although the return value of this function indicates whether or not\n  /// an analysis was previously registered, there intentionally isn't a way to\n  /// query this directly.  Instead, you should just register all the analyses\n  /// you might want and let this class run them lazily.  This idiom lets us\n  /// minimize the number of times we have to look up analyses in our\n  /// hashtable.)\n  template <typename PassBuilderT>\n  bool registerPass(PassBuilderT &&PassBuilder) {\n    using PassT = decltype(PassBuilder());\n    using PassModelT =\n        detail::AnalysisPassModel<IRUnitT, PassT, PreservedAnalyses,\n                                  Invalidator, ExtraArgTs...>;\n\n    auto &PassPtr = AnalysisPasses[PassT::ID()];\n    if (PassPtr)\n      // Already registered this pass type!\n      return false;\n\n    // Construct a new model around the instance returned by the builder.\n    PassPtr.reset(new PassModelT(PassBuilder()));\n    return true;\n  }\n\n  /// Invalidate a specific analysis pass for an IR unit.\n  ///\n  /// Note that the analysis result can disregard invalidation, if it determines\n  /// it is in fact still valid.\n  template <typename PassT> void invalidate(IRUnitT &IR) {\n    assert(AnalysisPasses.count(PassT::ID()) &&\n           \"This analysis pass was not registered prior to being invalidated\");\n    invalidateImpl(PassT::ID(), IR);\n  }\n\n  /// Invalidate cached analyses for an IR unit.\n  ///\n  /// Walk through all of the analyses pertaining to this unit of IR and\n  /// invalidate them, unless they are preserved by the PreservedAnalyses set.\n  void invalidate(IRUnitT &IR, const PreservedAnalyses &PA);\n\nprivate:\n  /// Look up a registered analysis pass.\n  PassConceptT &lookUpPass(AnalysisKey *ID) {\n    typename AnalysisPassMapT::iterator PI = AnalysisPasses.find(ID);\n    assert(PI != AnalysisPasses.end() &&\n           \"Analysis passes must be registered prior to being queried!\");\n    return *PI->second;\n  }\n\n  /// Look up a registered analysis pass.\n  const PassConceptT &lookUpPass(AnalysisKey *ID) const {\n    typename AnalysisPassMapT::const_iterator PI = AnalysisPasses.find(ID);\n    assert(PI != AnalysisPasses.end() &&\n           \"Analysis passes must be registered prior to being queried!\");\n    return *PI->second;\n  }\n\n  /// Get an analysis result, running the pass if necessary.\n  ResultConceptT &getResultImpl(AnalysisKey *ID, IRUnitT &IR,\n                                ExtraArgTs... ExtraArgs);\n\n  /// Get a cached analysis result or return null.\n  ResultConceptT *getCachedResultImpl(AnalysisKey *ID, IRUnitT &IR) const {\n    typename AnalysisResultMapT::const_iterator RI =\n        AnalysisResults.find({ID, &IR});\n    return RI == AnalysisResults.end() ? nullptr : &*RI->second->second;\n  }\n\n  /// Invalidate a pass result for a IR unit.\n  void invalidateImpl(AnalysisKey *ID, IRUnitT &IR) {\n    typename AnalysisResultMapT::iterator RI =\n        AnalysisResults.find({ID, &IR});\n    if (RI == AnalysisResults.end())\n      return;\n\n    if (DebugLogging)\n      dbgs() << \"Invalidating analysis: \" << this->lookUpPass(ID).name()\n             << \" on \" << IR.getName() << \"\\n\";\n    AnalysisResultLists[&IR].erase(RI->second);\n    AnalysisResults.erase(RI);\n  }\n\n  /// Map type from analysis pass ID to pass concept pointer.\n  using AnalysisPassMapT =\n      DenseMap<AnalysisKey *, std::unique_ptr<PassConceptT>>;\n\n  /// Collection of analysis passes, indexed by ID.\n  AnalysisPassMapT AnalysisPasses;\n\n  /// Map from IR unit to a list of analysis results.\n  ///\n  /// Provides linear time removal of all analysis results for a IR unit and\n  /// the ultimate storage for a particular cached analysis result.\n  AnalysisResultListMapT AnalysisResultLists;\n\n  /// Map from an analysis ID and IR unit to a particular cached\n  /// analysis result.\n  AnalysisResultMapT AnalysisResults;\n\n  /// Indicates whether we log to \\c llvm::dbgs().\n  bool DebugLogging;\n};\n\nextern template class AnalysisManager<Module>;\n\n/// Convenience typedef for the Module analysis manager.\nusing ModuleAnalysisManager = AnalysisManager<Module>;\n\nextern template class AnalysisManager<Function>;\n\n/// Convenience typedef for the Function analysis manager.\nusing FunctionAnalysisManager = AnalysisManager<Function>;\n\n/// An analysis over an \"outer\" IR unit that provides access to an\n/// analysis manager over an \"inner\" IR unit.  The inner unit must be contained\n/// in the outer unit.\n///\n/// For example, InnerAnalysisManagerProxy<FunctionAnalysisManager, Module> is\n/// an analysis over Modules (the \"outer\" unit) that provides access to a\n/// Function analysis manager.  The FunctionAnalysisManager is the \"inner\"\n/// manager being proxied, and Functions are the \"inner\" unit.  The inner/outer\n/// relationship is valid because each Function is contained in one Module.\n///\n/// If you're (transitively) within a pass manager for an IR unit U that\n/// contains IR unit V, you should never use an analysis manager over V, except\n/// via one of these proxies.\n///\n/// Note that the proxy's result is a move-only RAII object.  The validity of\n/// the analyses in the inner analysis manager is tied to its lifetime.\ntemplate <typename AnalysisManagerT, typename IRUnitT, typename... ExtraArgTs>\nclass InnerAnalysisManagerProxy\n    : public AnalysisInfoMixin<\n          InnerAnalysisManagerProxy<AnalysisManagerT, IRUnitT>> {\npublic:\n  class Result {\n  public:\n    explicit Result(AnalysisManagerT &InnerAM) : InnerAM(&InnerAM) {}\n\n    Result(Result &&Arg) : InnerAM(std::move(Arg.InnerAM)) {\n      // We have to null out the analysis manager in the moved-from state\n      // because we are taking ownership of the responsibilty to clear the\n      // analysis state.\n      Arg.InnerAM = nullptr;\n    }\n\n    ~Result() {\n      // InnerAM is cleared in a moved from state where there is nothing to do.\n      if (!InnerAM)\n        return;\n\n      // Clear out the analysis manager if we're being destroyed -- it means we\n      // didn't even see an invalidate call when we got invalidated.\n      InnerAM->clear();\n    }\n\n    Result &operator=(Result &&RHS) {\n      InnerAM = RHS.InnerAM;\n      // We have to null out the analysis manager in the moved-from state\n      // because we are taking ownership of the responsibilty to clear the\n      // analysis state.\n      RHS.InnerAM = nullptr;\n      return *this;\n    }\n\n    /// Accessor for the analysis manager.\n    AnalysisManagerT &getManager() { return *InnerAM; }\n\n    /// Handler for invalidation of the outer IR unit, \\c IRUnitT.\n    ///\n    /// If the proxy analysis itself is not preserved, we assume that the set of\n    /// inner IR objects contained in IRUnit may have changed.  In this case,\n    /// we have to call \\c clear() on the inner analysis manager, as it may now\n    /// have stale pointers to its inner IR objects.\n    ///\n    /// Regardless of whether the proxy analysis is marked as preserved, all of\n    /// the analyses in the inner analysis manager are potentially invalidated\n    /// based on the set of preserved analyses.\n    bool invalidate(\n        IRUnitT &IR, const PreservedAnalyses &PA,\n        typename AnalysisManager<IRUnitT, ExtraArgTs...>::Invalidator &Inv);\n\n  private:\n    AnalysisManagerT *InnerAM;\n  };\n\n  explicit InnerAnalysisManagerProxy(AnalysisManagerT &InnerAM)\n      : InnerAM(&InnerAM) {}\n\n  /// Run the analysis pass and create our proxy result object.\n  ///\n  /// This doesn't do any interesting work; it is primarily used to insert our\n  /// proxy result object into the outer analysis cache so that we can proxy\n  /// invalidation to the inner analysis manager.\n  Result run(IRUnitT &IR, AnalysisManager<IRUnitT, ExtraArgTs...> &AM,\n             ExtraArgTs...) {\n    return Result(*InnerAM);\n  }\n\nprivate:\n  friend AnalysisInfoMixin<\n      InnerAnalysisManagerProxy<AnalysisManagerT, IRUnitT>>;\n\n  static AnalysisKey Key;\n\n  AnalysisManagerT *InnerAM;\n};\n\ntemplate <typename AnalysisManagerT, typename IRUnitT, typename... ExtraArgTs>\nAnalysisKey\n    InnerAnalysisManagerProxy<AnalysisManagerT, IRUnitT, ExtraArgTs...>::Key;\n\n/// Provide the \\c FunctionAnalysisManager to \\c Module proxy.\nusing FunctionAnalysisManagerModuleProxy =\n    InnerAnalysisManagerProxy<FunctionAnalysisManager, Module>;\n\n/// Specialization of the invalidate method for the \\c\n/// FunctionAnalysisManagerModuleProxy's result.\ntemplate <>\nbool FunctionAnalysisManagerModuleProxy::Result::invalidate(\n    Module &M, const PreservedAnalyses &PA,\n    ModuleAnalysisManager::Invalidator &Inv);\n\n// Ensure the \\c FunctionAnalysisManagerModuleProxy is provided as an extern\n// template.\nextern template class InnerAnalysisManagerProxy<FunctionAnalysisManager,\n                                                Module>;\n\n/// An analysis over an \"inner\" IR unit that provides access to an\n/// analysis manager over a \"outer\" IR unit.  The inner unit must be contained\n/// in the outer unit.\n///\n/// For example OuterAnalysisManagerProxy<ModuleAnalysisManager, Function> is an\n/// analysis over Functions (the \"inner\" unit) which provides access to a Module\n/// analysis manager.  The ModuleAnalysisManager is the \"outer\" manager being\n/// proxied, and Modules are the \"outer\" IR unit.  The inner/outer relationship\n/// is valid because each Function is contained in one Module.\n///\n/// This proxy only exposes the const interface of the outer analysis manager,\n/// to indicate that you cannot cause an outer analysis to run from within an\n/// inner pass.  Instead, you must rely on the \\c getCachedResult API.  This is\n/// due to keeping potential future concurrency in mind. To give an example,\n/// running a module analysis before any function passes may give a different\n/// result than running it in a function pass. Both may be valid, but it would\n/// produce non-deterministic results. GlobalsAA is a good analysis example,\n/// because the cached information has the mod/ref info for all memory for each\n/// function at the time the analysis was computed. The information is still\n/// valid after a function transformation, but it may be *different* if\n/// recomputed after that transform. GlobalsAA is never invalidated.\n\n///\n/// This proxy doesn't manage invalidation in any way -- that is handled by the\n/// recursive return path of each layer of the pass manager.  A consequence of\n/// this is the outer analyses may be stale.  We invalidate the outer analyses\n/// only when we're done running passes over the inner IR units.\ntemplate <typename AnalysisManagerT, typename IRUnitT, typename... ExtraArgTs>\nclass OuterAnalysisManagerProxy\n    : public AnalysisInfoMixin<\n          OuterAnalysisManagerProxy<AnalysisManagerT, IRUnitT, ExtraArgTs...>> {\npublic:\n  /// Result proxy object for \\c OuterAnalysisManagerProxy.\n  class Result {\n  public:\n    explicit Result(const AnalysisManagerT &OuterAM) : OuterAM(&OuterAM) {}\n\n    /// Get a cached analysis. If the analysis can be invalidated, this will\n    /// assert.\n    template <typename PassT, typename IRUnitTParam>\n    typename PassT::Result *getCachedResult(IRUnitTParam &IR) const {\n      typename PassT::Result *Res =\n          OuterAM->template getCachedResult<PassT>(IR);\n      if (Res)\n        OuterAM->template verifyNotInvalidated<PassT>(IR, Res);\n      return Res;\n    }\n\n    /// Method provided for unit testing, not intended for general use.\n    template <typename PassT, typename IRUnitTParam>\n    bool cachedResultExists(IRUnitTParam &IR) const {\n      typename PassT::Result *Res =\n          OuterAM->template getCachedResult<PassT>(IR);\n      return Res != nullptr;\n    }\n\n    /// When invalidation occurs, remove any registered invalidation events.\n    bool invalidate(\n        IRUnitT &IRUnit, const PreservedAnalyses &PA,\n        typename AnalysisManager<IRUnitT, ExtraArgTs...>::Invalidator &Inv) {\n      // Loop over the set of registered outer invalidation mappings and if any\n      // of them map to an analysis that is now invalid, clear it out.\n      SmallVector<AnalysisKey *, 4> DeadKeys;\n      for (auto &KeyValuePair : OuterAnalysisInvalidationMap) {\n        AnalysisKey *OuterID = KeyValuePair.first;\n        auto &InnerIDs = KeyValuePair.second;\n        llvm::erase_if(InnerIDs, [&](AnalysisKey *InnerID) {\n          return Inv.invalidate(InnerID, IRUnit, PA);\n        });\n        if (InnerIDs.empty())\n          DeadKeys.push_back(OuterID);\n      }\n\n      for (auto OuterID : DeadKeys)\n        OuterAnalysisInvalidationMap.erase(OuterID);\n\n      // The proxy itself remains valid regardless of anything else.\n      return false;\n    }\n\n    /// Register a deferred invalidation event for when the outer analysis\n    /// manager processes its invalidations.\n    template <typename OuterAnalysisT, typename InvalidatedAnalysisT>\n    void registerOuterAnalysisInvalidation() {\n      AnalysisKey *OuterID = OuterAnalysisT::ID();\n      AnalysisKey *InvalidatedID = InvalidatedAnalysisT::ID();\n\n      auto &InvalidatedIDList = OuterAnalysisInvalidationMap[OuterID];\n      // Note, this is a linear scan. If we end up with large numbers of\n      // analyses that all trigger invalidation on the same outer analysis,\n      // this entire system should be changed to some other deterministic\n      // data structure such as a `SetVector` of a pair of pointers.\n      if (!llvm::is_contained(InvalidatedIDList, InvalidatedID))\n        InvalidatedIDList.push_back(InvalidatedID);\n    }\n\n    /// Access the map from outer analyses to deferred invalidation requiring\n    /// analyses.\n    const SmallDenseMap<AnalysisKey *, TinyPtrVector<AnalysisKey *>, 2> &\n    getOuterInvalidations() const {\n      return OuterAnalysisInvalidationMap;\n    }\n\n  private:\n    const AnalysisManagerT *OuterAM;\n\n    /// A map from an outer analysis ID to the set of this IR-unit's analyses\n    /// which need to be invalidated.\n    SmallDenseMap<AnalysisKey *, TinyPtrVector<AnalysisKey *>, 2>\n        OuterAnalysisInvalidationMap;\n  };\n\n  OuterAnalysisManagerProxy(const AnalysisManagerT &OuterAM)\n      : OuterAM(&OuterAM) {}\n\n  /// Run the analysis pass and create our proxy result object.\n  /// Nothing to see here, it just forwards the \\c OuterAM reference into the\n  /// result.\n  Result run(IRUnitT &, AnalysisManager<IRUnitT, ExtraArgTs...> &,\n             ExtraArgTs...) {\n    return Result(*OuterAM);\n  }\n\nprivate:\n  friend AnalysisInfoMixin<\n      OuterAnalysisManagerProxy<AnalysisManagerT, IRUnitT, ExtraArgTs...>>;\n\n  static AnalysisKey Key;\n\n  const AnalysisManagerT *OuterAM;\n};\n\ntemplate <typename AnalysisManagerT, typename IRUnitT, typename... ExtraArgTs>\nAnalysisKey\n    OuterAnalysisManagerProxy<AnalysisManagerT, IRUnitT, ExtraArgTs...>::Key;\n\nextern template class OuterAnalysisManagerProxy<ModuleAnalysisManager,\n                                                Function>;\n/// Provide the \\c ModuleAnalysisManager to \\c Function proxy.\nusing ModuleAnalysisManagerFunctionProxy =\n    OuterAnalysisManagerProxy<ModuleAnalysisManager, Function>;\n\n/// Trivial adaptor that maps from a module to its functions.\n///\n/// Designed to allow composition of a FunctionPass(Manager) and\n/// a ModulePassManager, by running the FunctionPass(Manager) over every\n/// function in the module.\n///\n/// Function passes run within this adaptor can rely on having exclusive access\n/// to the function they are run over. They should not read or modify any other\n/// functions! Other threads or systems may be manipulating other functions in\n/// the module, and so their state should never be relied on.\n/// FIXME: Make the above true for all of LLVM's actual passes, some still\n/// violate this principle.\n///\n/// Function passes can also read the module containing the function, but they\n/// should not modify that module outside of the use lists of various globals.\n/// For example, a function pass is not permitted to add functions to the\n/// module.\n/// FIXME: Make the above true for all of LLVM's actual passes, some still\n/// violate this principle.\n///\n/// Note that although function passes can access module analyses, module\n/// analyses are not invalidated while the function passes are running, so they\n/// may be stale.  Function analyses will not be stale.\nclass ModuleToFunctionPassAdaptor\n    : public PassInfoMixin<ModuleToFunctionPassAdaptor> {\npublic:\n  using PassConceptT = detail::PassConcept<Function, FunctionAnalysisManager>;\n\n  explicit ModuleToFunctionPassAdaptor(std::unique_ptr<PassConceptT> Pass)\n      : Pass(std::move(Pass)) {}\n\n  /// Runs the function pass across every function in the module.\n  PreservedAnalyses run(Module &M, ModuleAnalysisManager &AM);\n\n  static bool isRequired() { return true; }\n\nprivate:\n  std::unique_ptr<PassConceptT> Pass;\n};\n\n/// A function to deduce a function pass type and wrap it in the\n/// templated adaptor.\ntemplate <typename FunctionPassT>\nModuleToFunctionPassAdaptor\ncreateModuleToFunctionPassAdaptor(FunctionPassT Pass) {\n  using PassModelT =\n      detail::PassModel<Function, FunctionPassT, PreservedAnalyses,\n                        FunctionAnalysisManager>;\n\n  return ModuleToFunctionPassAdaptor(\n      std::make_unique<PassModelT>(std::move(Pass)));\n}\n\n/// A utility pass template to force an analysis result to be available.\n///\n/// If there are extra arguments at the pass's run level there may also be\n/// extra arguments to the analysis manager's \\c getResult routine. We can't\n/// guess how to effectively map the arguments from one to the other, and so\n/// this specialization just ignores them.\n///\n/// Specific patterns of run-method extra arguments and analysis manager extra\n/// arguments will have to be defined as appropriate specializations.\ntemplate <typename AnalysisT, typename IRUnitT,\n          typename AnalysisManagerT = AnalysisManager<IRUnitT>,\n          typename... ExtraArgTs>\nstruct RequireAnalysisPass\n    : PassInfoMixin<RequireAnalysisPass<AnalysisT, IRUnitT, AnalysisManagerT,\n                                        ExtraArgTs...>> {\n  /// Run this pass over some unit of IR.\n  ///\n  /// This pass can be run over any unit of IR and use any analysis manager\n  /// provided they satisfy the basic API requirements. When this pass is\n  /// created, these methods can be instantiated to satisfy whatever the\n  /// context requires.\n  PreservedAnalyses run(IRUnitT &Arg, AnalysisManagerT &AM,\n                        ExtraArgTs &&... Args) {\n    (void)AM.template getResult<AnalysisT>(Arg,\n                                           std::forward<ExtraArgTs>(Args)...);\n\n    return PreservedAnalyses::all();\n  }\n  static bool isRequired() { return true; }\n};\n\n/// A no-op pass template which simply forces a specific analysis result\n/// to be invalidated.\ntemplate <typename AnalysisT>\nstruct InvalidateAnalysisPass\n    : PassInfoMixin<InvalidateAnalysisPass<AnalysisT>> {\n  /// Run this pass over some unit of IR.\n  ///\n  /// This pass can be run over any unit of IR and use any analysis manager,\n  /// provided they satisfy the basic API requirements. When this pass is\n  /// created, these methods can be instantiated to satisfy whatever the\n  /// context requires.\n  template <typename IRUnitT, typename AnalysisManagerT, typename... ExtraArgTs>\n  PreservedAnalyses run(IRUnitT &Arg, AnalysisManagerT &AM, ExtraArgTs &&...) {\n    auto PA = PreservedAnalyses::all();\n    PA.abandon<AnalysisT>();\n    return PA;\n  }\n};\n\n/// A utility pass that does nothing, but preserves no analyses.\n///\n/// Because this preserves no analyses, any analysis passes queried after this\n/// pass runs will recompute fresh results.\nstruct InvalidateAllAnalysesPass : PassInfoMixin<InvalidateAllAnalysesPass> {\n  /// Run this pass over some unit of IR.\n  template <typename IRUnitT, typename AnalysisManagerT, typename... ExtraArgTs>\n  PreservedAnalyses run(IRUnitT &, AnalysisManagerT &, ExtraArgTs &&...) {\n    return PreservedAnalyses::none();\n  }\n};\n\n/// A utility pass template that simply runs another pass multiple times.\n///\n/// This can be useful when debugging or testing passes. It also serves as an\n/// example of how to extend the pass manager in ways beyond composition.\ntemplate <typename PassT>\nclass RepeatedPass : public PassInfoMixin<RepeatedPass<PassT>> {\npublic:\n  RepeatedPass(int Count, PassT P) : Count(Count), P(std::move(P)) {}\n\n  template <typename IRUnitT, typename AnalysisManagerT, typename... Ts>\n  PreservedAnalyses run(IRUnitT &IR, AnalysisManagerT &AM, Ts &&... Args) {\n\n    // Request PassInstrumentation from analysis manager, will use it to run\n    // instrumenting callbacks for the passes later.\n    // Here we use std::tuple wrapper over getResult which helps to extract\n    // AnalysisManager's arguments out of the whole Args set.\n    PassInstrumentation PI =\n        detail::getAnalysisResult<PassInstrumentationAnalysis>(\n            AM, IR, std::tuple<Ts...>(Args...));\n\n    auto PA = PreservedAnalyses::all();\n    for (int i = 0; i < Count; ++i) {\n      // Check the PassInstrumentation's BeforePass callbacks before running the\n      // pass, skip its execution completely if asked to (callback returns\n      // false).\n      if (!PI.runBeforePass<IRUnitT>(P, IR))\n        continue;\n      PreservedAnalyses IterPA = P.run(IR, AM, std::forward<Ts>(Args)...);\n      PA.intersect(IterPA);\n      PI.runAfterPass(P, IR, IterPA);\n    }\n    return PA;\n  }\n\nprivate:\n  int Count;\n  PassT P;\n};\n\ntemplate <typename PassT>\nRepeatedPass<PassT> createRepeatedPass(int Count, PassT P) {\n  return RepeatedPass<PassT>(Count, std::move(P));\n}\n\n} // end namespace llvm\n\n#endif // LLVM_IR_PASSMANAGER_H\n"}, "53": {"id": 53, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h", "content": "//===- PassManager internal APIs and implementation details -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n///\n/// This header provides internal APIs and implementation details used by the\n/// pass management interfaces exposed in PassManager.h. To understand more\n/// context of why these particular interfaces are needed, see that header\n/// file. None of these APIs should be used elsewhere.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_PASSMANAGERINTERNAL_H\n#define LLVM_IR_PASSMANAGERINTERNAL_H\n\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <memory>\n#include <utility>\n\nnamespace llvm {\n\ntemplate <typename IRUnitT> class AllAnalysesOn;\ntemplate <typename IRUnitT, typename... ExtraArgTs> class AnalysisManager;\nclass PreservedAnalyses;\n\n/// Implementation details of the pass manager interfaces.\nnamespace detail {\n\n/// Template for the abstract base class used to dispatch\n/// polymorphically over pass objects.\ntemplate <typename IRUnitT, typename AnalysisManagerT, typename... ExtraArgTs>\nstruct PassConcept {\n  // Boiler plate necessary for the container of derived classes.\n  virtual ~PassConcept() = default;\n\n  /// The polymorphic API which runs the pass over a given IR entity.\n  ///\n  /// Note that actual pass object can omit the analysis manager argument if\n  /// desired. Also that the analysis manager may be null if there is no\n  /// analysis manager in the pass pipeline.\n  virtual PreservedAnalyses run(IRUnitT &IR, AnalysisManagerT &AM,\n                                ExtraArgTs... ExtraArgs) = 0;\n\n  /// Polymorphic method to access the name of a pass.\n  virtual StringRef name() const = 0;\n\n  /// Polymorphic method to to let a pass optionally exempted from skipping by\n  /// PassInstrumentation.\n  /// To opt-in, pass should implement `static bool isRequired()`. It's no-op\n  /// to have `isRequired` always return false since that is the default.\n  virtual bool isRequired() const = 0;\n};\n\n/// A template wrapper used to implement the polymorphic API.\n///\n/// Can be instantiated for any object which provides a \\c run method accepting\n/// an \\c IRUnitT& and an \\c AnalysisManager<IRUnit>&. It requires the pass to\n/// be a copyable object.\ntemplate <typename IRUnitT, typename PassT, typename PreservedAnalysesT,\n          typename AnalysisManagerT, typename... ExtraArgTs>\nstruct PassModel : PassConcept<IRUnitT, AnalysisManagerT, ExtraArgTs...> {\n  explicit PassModel(PassT Pass) : Pass(std::move(Pass)) {}\n  // We have to explicitly define all the special member functions because MSVC\n  // refuses to generate them.\n  PassModel(const PassModel &Arg) : Pass(Arg.Pass) {}\n  PassModel(PassModel &&Arg) : Pass(std::move(Arg.Pass)) {}\n\n  friend void swap(PassModel &LHS, PassModel &RHS) {\n    using std::swap;\n    swap(LHS.Pass, RHS.Pass);\n  }\n\n  PassModel &operator=(PassModel RHS) {\n    swap(*this, RHS);\n    return *this;\n  }\n\n  PreservedAnalysesT run(IRUnitT &IR, AnalysisManagerT &AM,\n                         ExtraArgTs... ExtraArgs) override {\n    return Pass.run(IR, AM, ExtraArgs...);\n  }\n\n  StringRef name() const override { return PassT::name(); }\n\n  template <typename T>\n  using has_required_t = decltype(std::declval<T &>().isRequired());\n\n  template <typename T>\n  static std::enable_if_t<is_detected<has_required_t, T>::value, bool>\n  passIsRequiredImpl() {\n    return T::isRequired();\n  }\n  template <typename T>\n  static std::enable_if_t<!is_detected<has_required_t, T>::value, bool>\n  passIsRequiredImpl() {\n    return false;\n  }\n\n  bool isRequired() const override { return passIsRequiredImpl<PassT>(); }\n\n  PassT Pass;\n};\n\n/// Abstract concept of an analysis result.\n///\n/// This concept is parameterized over the IR unit that this result pertains\n/// to.\ntemplate <typename IRUnitT, typename PreservedAnalysesT, typename InvalidatorT>\nstruct AnalysisResultConcept {\n  virtual ~AnalysisResultConcept() = default;\n\n  /// Method to try and mark a result as invalid.\n  ///\n  /// When the outer analysis manager detects a change in some underlying\n  /// unit of the IR, it will call this method on all of the results cached.\n  ///\n  /// \\p PA is a set of preserved analyses which can be used to avoid\n  /// invalidation because the pass which changed the underlying IR took care\n  /// to update or preserve the analysis result in some way.\n  ///\n  /// \\p Inv is typically a \\c AnalysisManager::Invalidator object that can be\n  /// used by a particular analysis result to discover if other analyses\n  /// results are also invalidated in the event that this result depends on\n  /// them. See the documentation in the \\c AnalysisManager for more details.\n  ///\n  /// \\returns true if the result is indeed invalid (the default).\n  virtual bool invalidate(IRUnitT &IR, const PreservedAnalysesT &PA,\n                          InvalidatorT &Inv) = 0;\n};\n\n/// SFINAE metafunction for computing whether \\c ResultT provides an\n/// \\c invalidate member function.\ntemplate <typename IRUnitT, typename ResultT> class ResultHasInvalidateMethod {\n  using EnabledType = char;\n  struct DisabledType {\n    char a, b;\n  };\n\n  // Purely to help out MSVC which fails to disable the below specialization,\n  // explicitly enable using the result type's invalidate routine if we can\n  // successfully call that routine.\n  template <typename T> struct Nonce { using Type = EnabledType; };\n  template <typename T>\n  static typename Nonce<decltype(std::declval<T>().invalidate(\n      std::declval<IRUnitT &>(), std::declval<PreservedAnalyses>()))>::Type\n      check(rank<2>);\n\n  // First we define an overload that can only be taken if there is no\n  // invalidate member. We do this by taking the address of an invalidate\n  // member in an adjacent base class of a derived class. This would be\n  // ambiguous if there were an invalidate member in the result type.\n  template <typename T, typename U> static DisabledType NonceFunction(T U::*);\n  struct CheckerBase { int invalidate; };\n  template <typename T> struct Checker : CheckerBase, T {};\n  template <typename T>\n  static decltype(NonceFunction(&Checker<T>::invalidate)) check(rank<1>);\n\n  // Now we have the fallback that will only be reached when there is an\n  // invalidate member, and enables the trait.\n  template <typename T>\n  static EnabledType check(rank<0>);\n\npublic:\n  enum { Value = sizeof(check<ResultT>(rank<2>())) == sizeof(EnabledType) };\n};\n\n/// Wrapper to model the analysis result concept.\n///\n/// By default, this will implement the invalidate method with a trivial\n/// implementation so that the actual analysis result doesn't need to provide\n/// an invalidation handler. It is only selected when the invalidation handler\n/// is not part of the ResultT's interface.\ntemplate <typename IRUnitT, typename PassT, typename ResultT,\n          typename PreservedAnalysesT, typename InvalidatorT,\n          bool HasInvalidateHandler =\n              ResultHasInvalidateMethod<IRUnitT, ResultT>::Value>\nstruct AnalysisResultModel;\n\n/// Specialization of \\c AnalysisResultModel which provides the default\n/// invalidate functionality.\ntemplate <typename IRUnitT, typename PassT, typename ResultT,\n          typename PreservedAnalysesT, typename InvalidatorT>\nstruct AnalysisResultModel<IRUnitT, PassT, ResultT, PreservedAnalysesT,\n                           InvalidatorT, false>\n    : AnalysisResultConcept<IRUnitT, PreservedAnalysesT, InvalidatorT> {\n  explicit AnalysisResultModel(ResultT Result) : Result(std::move(Result)) {}\n  // We have to explicitly define all the special member functions because MSVC\n  // refuses to generate them.\n  AnalysisResultModel(const AnalysisResultModel &Arg) : Result(Arg.Result) {}\n  AnalysisResultModel(AnalysisResultModel &&Arg)\n      : Result(std::move(Arg.Result)) {}\n\n  friend void swap(AnalysisResultModel &LHS, AnalysisResultModel &RHS) {\n    using std::swap;\n    swap(LHS.Result, RHS.Result);\n  }\n\n  AnalysisResultModel &operator=(AnalysisResultModel RHS) {\n    swap(*this, RHS);\n    return *this;\n  }\n\n  /// The model bases invalidation solely on being in the preserved set.\n  //\n  // FIXME: We should actually use two different concepts for analysis results\n  // rather than two different models, and avoid the indirect function call for\n  // ones that use the trivial behavior.\n  bool invalidate(IRUnitT &, const PreservedAnalysesT &PA,\n                  InvalidatorT &) override {\n    auto PAC = PA.template getChecker<PassT>();\n    return !PAC.preserved() &&\n           !PAC.template preservedSet<AllAnalysesOn<IRUnitT>>();\n  }\n\n  ResultT Result;\n};\n\n/// Specialization of \\c AnalysisResultModel which delegates invalidate\n/// handling to \\c ResultT.\ntemplate <typename IRUnitT, typename PassT, typename ResultT,\n          typename PreservedAnalysesT, typename InvalidatorT>\nstruct AnalysisResultModel<IRUnitT, PassT, ResultT, PreservedAnalysesT,\n                           InvalidatorT, true>\n    : AnalysisResultConcept<IRUnitT, PreservedAnalysesT, InvalidatorT> {\n  explicit AnalysisResultModel(ResultT Result) : Result(std::move(Result)) {}\n  // We have to explicitly define all the special member functions because MSVC\n  // refuses to generate them.\n  AnalysisResultModel(const AnalysisResultModel &Arg) : Result(Arg.Result) {}\n  AnalysisResultModel(AnalysisResultModel &&Arg)\n      : Result(std::move(Arg.Result)) {}\n\n  friend void swap(AnalysisResultModel &LHS, AnalysisResultModel &RHS) {\n    using std::swap;\n    swap(LHS.Result, RHS.Result);\n  }\n\n  AnalysisResultModel &operator=(AnalysisResultModel RHS) {\n    swap(*this, RHS);\n    return *this;\n  }\n\n  /// The model delegates to the \\c ResultT method.\n  bool invalidate(IRUnitT &IR, const PreservedAnalysesT &PA,\n                  InvalidatorT &Inv) override {\n    return Result.invalidate(IR, PA, Inv);\n  }\n\n  ResultT Result;\n};\n\n/// Abstract concept of an analysis pass.\n///\n/// This concept is parameterized over the IR unit that it can run over and\n/// produce an analysis result.\ntemplate <typename IRUnitT, typename PreservedAnalysesT, typename InvalidatorT,\n          typename... ExtraArgTs>\nstruct AnalysisPassConcept {\n  virtual ~AnalysisPassConcept() = default;\n\n  /// Method to run this analysis over a unit of IR.\n  /// \\returns A unique_ptr to the analysis result object to be queried by\n  /// users.\n  virtual std::unique_ptr<\n      AnalysisResultConcept<IRUnitT, PreservedAnalysesT, InvalidatorT>>\n  run(IRUnitT &IR, AnalysisManager<IRUnitT, ExtraArgTs...> &AM,\n      ExtraArgTs... ExtraArgs) = 0;\n\n  /// Polymorphic method to access the name of a pass.\n  virtual StringRef name() const = 0;\n};\n\n/// Wrapper to model the analysis pass concept.\n///\n/// Can wrap any type which implements a suitable \\c run method. The method\n/// must accept an \\c IRUnitT& and an \\c AnalysisManager<IRUnitT>& as arguments\n/// and produce an object which can be wrapped in a \\c AnalysisResultModel.\ntemplate <typename IRUnitT, typename PassT, typename PreservedAnalysesT,\n          typename InvalidatorT, typename... ExtraArgTs>\nstruct AnalysisPassModel : AnalysisPassConcept<IRUnitT, PreservedAnalysesT,\n                                               InvalidatorT, ExtraArgTs...> {\n  explicit AnalysisPassModel(PassT Pass) : Pass(std::move(Pass)) {}\n  // We have to explicitly define all the special member functions because MSVC\n  // refuses to generate them.\n  AnalysisPassModel(const AnalysisPassModel &Arg) : Pass(Arg.Pass) {}\n  AnalysisPassModel(AnalysisPassModel &&Arg) : Pass(std::move(Arg.Pass)) {}\n\n  friend void swap(AnalysisPassModel &LHS, AnalysisPassModel &RHS) {\n    using std::swap;\n    swap(LHS.Pass, RHS.Pass);\n  }\n\n  AnalysisPassModel &operator=(AnalysisPassModel RHS) {\n    swap(*this, RHS);\n    return *this;\n  }\n\n  // FIXME: Replace PassT::Result with type traits when we use C++11.\n  using ResultModelT =\n      AnalysisResultModel<IRUnitT, PassT, typename PassT::Result,\n                          PreservedAnalysesT, InvalidatorT>;\n\n  /// The model delegates to the \\c PassT::run method.\n  ///\n  /// The return is wrapped in an \\c AnalysisResultModel.\n  std::unique_ptr<\n      AnalysisResultConcept<IRUnitT, PreservedAnalysesT, InvalidatorT>>\n  run(IRUnitT &IR, AnalysisManager<IRUnitT, ExtraArgTs...> &AM,\n      ExtraArgTs... ExtraArgs) override {\n    return std::make_unique<ResultModelT>(\n        Pass.run(IR, AM, std::forward<ExtraArgTs>(ExtraArgs)...));\n  }\n\n  /// The model delegates to a static \\c PassT::name method.\n  ///\n  /// The returned string ref must point to constant immutable data!\n  StringRef name() const override { return PassT::name(); }\n\n  PassT Pass;\n};\n\n} // end namespace detail\n\n} // end namespace llvm\n\n#endif // LLVM_IR_PASSMANAGERINTERNAL_H\n"}, "54": {"id": 54, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/TrackingMDRef.h", "content": "//===- llvm/IR/TrackingMDRef.h - Tracking Metadata references ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// References to metadata that track RAUW.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_TRACKINGMDREF_H\n#define LLVM_IR_TRACKINGMDREF_H\n\n#include \"llvm/IR/Metadata.h\"\n#include <algorithm>\n#include <cassert>\n\nnamespace llvm {\n\n/// Tracking metadata reference.\n///\n/// This class behaves like \\a TrackingVH, but for metadata.\nclass TrackingMDRef {\n  Metadata *MD = nullptr;\n\npublic:\n  TrackingMDRef() = default;\n  explicit TrackingMDRef(Metadata *MD) : MD(MD) { track(); }\n\n  TrackingMDRef(TrackingMDRef &&X) : MD(X.MD) { retrack(X); }\n  TrackingMDRef(const TrackingMDRef &X) : MD(X.MD) { track(); }\n\n  TrackingMDRef &operator=(TrackingMDRef &&X) {\n    if (&X == this)\n      return *this;\n\n    untrack();\n    MD = X.MD;\n    retrack(X);\n    return *this;\n  }\n\n  TrackingMDRef &operator=(const TrackingMDRef &X) {\n    if (&X == this)\n      return *this;\n\n    untrack();\n    MD = X.MD;\n    track();\n    return *this;\n  }\n\n  ~TrackingMDRef() { untrack(); }\n\n  Metadata *get() const { return MD; }\n  operator Metadata *() const { return get(); }\n  Metadata *operator->() const { return get(); }\n  Metadata &operator*() const { return *get(); }\n\n  void reset() {\n    untrack();\n    MD = nullptr;\n  }\n  void reset(Metadata *MD) {\n    untrack();\n    this->MD = MD;\n    track();\n  }\n\n  /// Check whether this has a trivial destructor.\n  ///\n  /// If \\c MD isn't replaceable, the destructor will be a no-op.\n  bool hasTrivialDestructor() const {\n    return !MD || !MetadataTracking::isReplaceable(*MD);\n  }\n\n  bool operator==(const TrackingMDRef &X) const { return MD == X.MD; }\n  bool operator!=(const TrackingMDRef &X) const { return MD != X.MD; }\n\nprivate:\n  void track() {\n    if (MD)\n      MetadataTracking::track(MD);\n  }\n\n  void untrack() {\n    if (MD)\n      MetadataTracking::untrack(MD);\n  }\n\n  void retrack(TrackingMDRef &X) {\n    assert(MD == X.MD && \"Expected values to match\");\n    if (X.MD) {\n      MetadataTracking::retrack(X.MD, MD);\n      X.MD = nullptr;\n    }\n  }\n};\n\n/// Typed tracking ref.\n///\n/// Track refererences of a particular type.  It's useful to use this for \\a\n/// MDNode and \\a ValueAsMetadata.\ntemplate <class T> class TypedTrackingMDRef {\n  TrackingMDRef Ref;\n\npublic:\n  TypedTrackingMDRef() = default;\n  explicit TypedTrackingMDRef(T *MD) : Ref(static_cast<Metadata *>(MD)) {}\n\n  TypedTrackingMDRef(TypedTrackingMDRef &&X) : Ref(std::move(X.Ref)) {}\n  TypedTrackingMDRef(const TypedTrackingMDRef &X) : Ref(X.Ref) {}\n\n  TypedTrackingMDRef &operator=(TypedTrackingMDRef &&X) {\n    Ref = std::move(X.Ref);\n    return *this;\n  }\n\n  TypedTrackingMDRef &operator=(const TypedTrackingMDRef &X) {\n    Ref = X.Ref;\n    return *this;\n  }\n\n  T *get() const { return (T *)Ref.get(); }\n  operator T *() const { return get(); }\n  T *operator->() const { return get(); }\n  T &operator*() const { return *get(); }\n\n  bool operator==(const TypedTrackingMDRef &X) const { return Ref == X.Ref; }\n  bool operator!=(const TypedTrackingMDRef &X) const { return Ref != X.Ref; }\n\n  void reset() { Ref.reset(); }\n  void reset(T *MD) { Ref.reset(static_cast<Metadata *>(MD)); }\n\n  /// Check whether this has a trivial destructor.\n  bool hasTrivialDestructor() const { return Ref.hasTrivialDestructor(); }\n};\n\nusing TrackingMDNodeRef = TypedTrackingMDRef<MDNode>;\nusing TrackingValueAsMetadataRef = TypedTrackingMDRef<ValueAsMetadata>;\n\n// Expose the underlying metadata to casting.\ntemplate <> struct simplify_type<TrackingMDRef> {\n  using SimpleType = Metadata *;\n\n  static SimpleType getSimplifiedValue(TrackingMDRef &MD) { return MD.get(); }\n};\n\ntemplate <> struct simplify_type<const TrackingMDRef> {\n  using SimpleType = Metadata *;\n\n  static SimpleType getSimplifiedValue(const TrackingMDRef &MD) {\n    return MD.get();\n  }\n};\n\ntemplate <class T> struct simplify_type<TypedTrackingMDRef<T>> {\n  using SimpleType = T *;\n\n  static SimpleType getSimplifiedValue(TypedTrackingMDRef<T> &MD) {\n    return MD.get();\n  }\n};\n\ntemplate <class T> struct simplify_type<const TypedTrackingMDRef<T>> {\n  using SimpleType = T *;\n\n  static SimpleType getSimplifiedValue(const TypedTrackingMDRef<T> &MD) {\n    return MD.get();\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_TRACKINGMDREF_H\n"}, "55": {"id": 55, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueMap.h", "content": "//===- ValueMap.h - Safe map from Values to data ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ValueMap class.  ValueMap maps Value* or any subclass\n// to an arbitrary other type.  It provides the DenseMap interface but updates\n// itself to remain safe when keys are RAUWed or deleted.  By default, when a\n// key is RAUWed from V1 to V2, the old mapping V1->target is removed, and a new\n// mapping V2->target is added.  If V2 already existed, its old target is\n// overwritten.  When a key is deleted, its mapping is removed.\n//\n// You can override a ValueMap's Config parameter to control exactly what\n// happens on RAUW and destruction and to get called back on each event.  It's\n// legal to call back into the ValueMap from a Config's callbacks.  Config\n// parameters should inherit from ValueMapConfig<KeyT> to get default\n// implementations of all the methods ValueMap uses.  See ValueMapConfig for\n// documentation of the functions you can override.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_VALUEMAP_H\n#define LLVM_IR_VALUEMAP_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/IR/TrackingMDRef.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Mutex.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <mutex>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\ntemplate<typename KeyT, typename ValueT, typename Config>\nclass ValueMapCallbackVH;\ntemplate<typename DenseMapT, typename KeyT>\nclass ValueMapIterator;\ntemplate<typename DenseMapT, typename KeyT>\nclass ValueMapConstIterator;\n\n/// This class defines the default behavior for configurable aspects of\n/// ValueMap<>.  User Configs should inherit from this class to be as compatible\n/// as possible with future versions of ValueMap.\ntemplate<typename KeyT, typename MutexT = sys::Mutex>\nstruct ValueMapConfig {\n  using mutex_type = MutexT;\n\n  /// If FollowRAUW is true, the ValueMap will update mappings on RAUW. If it's\n  /// false, the ValueMap will leave the original mapping in place.\n  enum { FollowRAUW = true };\n\n  // All methods will be called with a first argument of type ExtraData.  The\n  // default implementations in this class take a templated first argument so\n  // that users' subclasses can use any type they want without having to\n  // override all the defaults.\n  struct ExtraData {};\n\n  template<typename ExtraDataT>\n  static void onRAUW(const ExtraDataT & /*Data*/, KeyT /*Old*/, KeyT /*New*/) {}\n  template<typename ExtraDataT>\n  static void onDelete(const ExtraDataT &/*Data*/, KeyT /*Old*/) {}\n\n  /// Returns a mutex that should be acquired around any changes to the map.\n  /// This is only acquired from the CallbackVH (and held around calls to onRAUW\n  /// and onDelete) and not inside other ValueMap methods.  NULL means that no\n  /// mutex is necessary.\n  template<typename ExtraDataT>\n  static mutex_type *getMutex(const ExtraDataT &/*Data*/) { return nullptr; }\n};\n\n/// See the file comment.\ntemplate<typename KeyT, typename ValueT, typename Config =ValueMapConfig<KeyT>>\nclass ValueMap {\n  friend class ValueMapCallbackVH<KeyT, ValueT, Config>;\n\n  using ValueMapCVH = ValueMapCallbackVH<KeyT, ValueT, Config>;\n  using MapT = DenseMap<ValueMapCVH, ValueT, DenseMapInfo<ValueMapCVH>>;\n  using MDMapT = DenseMap<const Metadata *, TrackingMDRef>;\n  using ExtraData = typename Config::ExtraData;\n\n  MapT Map;\n  Optional<MDMapT> MDMap;\n  ExtraData Data;\n\npublic:\n  using key_type = KeyT;\n  using mapped_type = ValueT;\n  using value_type = std::pair<KeyT, ValueT>;\n  using size_type = unsigned;\n\n  explicit ValueMap(unsigned NumInitBuckets = 64)\n      : Map(NumInitBuckets), Data() {}\n  explicit ValueMap(const ExtraData &Data, unsigned NumInitBuckets = 64)\n      : Map(NumInitBuckets), Data(Data) {}\n  // ValueMap can't be copied nor moved, beucase the callbacks store pointer\n  // to it.\n  ValueMap(const ValueMap &) = delete;\n  ValueMap(ValueMap &&) = delete;\n  ValueMap &operator=(const ValueMap &) = delete;\n  ValueMap &operator=(ValueMap &&) = delete;\n\n  bool hasMD() const { return bool(MDMap); }\n  MDMapT &MD() {\n    if (!MDMap)\n      MDMap.emplace();\n    return *MDMap;\n  }\n  Optional<MDMapT> &getMDMap() { return MDMap; }\n\n  /// Get the mapped metadata, if it's in the map.\n  Optional<Metadata *> getMappedMD(const Metadata *MD) const {\n    if (!MDMap)\n      return None;\n    auto Where = MDMap->find(MD);\n    if (Where == MDMap->end())\n      return None;\n    return Where->second.get();\n  }\n\n  using iterator = ValueMapIterator<MapT, KeyT>;\n  using const_iterator = ValueMapConstIterator<MapT, KeyT>;\n\n  inline iterator begin() { return iterator(Map.begin()); }\n  inline iterator end() { return iterator(Map.end()); }\n  inline const_iterator begin() const { return const_iterator(Map.begin()); }\n  inline const_iterator end() const { return const_iterator(Map.end()); }\n\n  bool empty() const { return Map.empty(); }\n  size_type size() const { return Map.size(); }\n\n  /// Grow the map so that it has at least Size buckets. Does not shrink\n  void resize(size_t Size) { Map.resize(Size); }\n\n  void clear() {\n    Map.clear();\n    MDMap.reset();\n  }\n\n  /// Return 1 if the specified key is in the map, 0 otherwise.\n  size_type count(const KeyT &Val) const {\n    return Map.find_as(Val) == Map.end() ? 0 : 1;\n  }\n\n  iterator find(const KeyT &Val) {\n    return iterator(Map.find_as(Val));\n  }\n  const_iterator find(const KeyT &Val) const {\n    return const_iterator(Map.find_as(Val));\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueT lookup(const KeyT &Val) const {\n    typename MapT::const_iterator I = Map.find_as(Val);\n    return I != Map.end() ? I->second : ValueT();\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &KV) {\n    auto MapResult = Map.insert(std::make_pair(Wrap(KV.first), KV.second));\n    return std::make_pair(iterator(MapResult.first), MapResult.second);\n  }\n\n  std::pair<iterator, bool> insert(std::pair<KeyT, ValueT> &&KV) {\n    auto MapResult =\n        Map.insert(std::make_pair(Wrap(KV.first), std::move(KV.second)));\n    return std::make_pair(iterator(MapResult.first), MapResult.second);\n  }\n\n  /// insert - Range insertion of pairs.\n  template<typename InputIt>\n  void insert(InputIt I, InputIt E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  bool erase(const KeyT &Val) {\n    typename MapT::iterator I = Map.find_as(Val);\n    if (I == Map.end())\n      return false;\n\n    Map.erase(I);\n    return true;\n  }\n  void erase(iterator I) {\n    return Map.erase(I.base());\n  }\n\n  value_type& FindAndConstruct(const KeyT &Key) {\n    return Map.FindAndConstruct(Wrap(Key));\n  }\n\n  ValueT &operator[](const KeyT &Key) {\n    return Map[Wrap(Key)];\n  }\n\n  /// isPointerIntoBucketsArray - Return true if the specified pointer points\n  /// somewhere into the ValueMap's array of buckets (i.e. either to a key or\n  /// value in the ValueMap).\n  bool isPointerIntoBucketsArray(const void *Ptr) const {\n    return Map.isPointerIntoBucketsArray(Ptr);\n  }\n\n  /// getPointerIntoBucketsArray() - Return an opaque pointer into the buckets\n  /// array.  In conjunction with the previous method, this can be used to\n  /// determine whether an insertion caused the ValueMap to reallocate.\n  const void *getPointerIntoBucketsArray() const {\n    return Map.getPointerIntoBucketsArray();\n  }\n\nprivate:\n  // Takes a key being looked up in the map and wraps it into a\n  // ValueMapCallbackVH, the actual key type of the map.  We use a helper\n  // function because ValueMapCVH is constructed with a second parameter.\n  ValueMapCVH Wrap(KeyT key) const {\n    // The only way the resulting CallbackVH could try to modify *this (making\n    // the const_cast incorrect) is if it gets inserted into the map.  But then\n    // this function must have been called from a non-const method, making the\n    // const_cast ok.\n    return ValueMapCVH(key, const_cast<ValueMap*>(this));\n  }\n};\n\n// This CallbackVH updates its ValueMap when the contained Value changes,\n// according to the user's preferences expressed through the Config object.\ntemplate <typename KeyT, typename ValueT, typename Config>\nclass ValueMapCallbackVH final : public CallbackVH {\n  friend class ValueMap<KeyT, ValueT, Config>;\n  friend struct DenseMapInfo<ValueMapCallbackVH>;\n\n  using ValueMapT = ValueMap<KeyT, ValueT, Config>;\n  using KeySansPointerT = std::remove_pointer_t<KeyT>;\n\n  ValueMapT *Map;\n\n  ValueMapCallbackVH(KeyT Key, ValueMapT *Map)\n      : CallbackVH(const_cast<Value*>(static_cast<const Value*>(Key))),\n        Map(Map) {}\n\n  // Private constructor used to create empty/tombstone DenseMap keys.\n  ValueMapCallbackVH(Value *V) : CallbackVH(V), Map(nullptr) {}\n\npublic:\n  KeyT Unwrap() const { return cast_or_null<KeySansPointerT>(getValPtr()); }\n\n  void deleted() override {\n    // Make a copy that won't get changed even when *this is destroyed.\n    ValueMapCallbackVH Copy(*this);\n    typename Config::mutex_type *M = Config::getMutex(Copy.Map->Data);\n    std::unique_lock<typename Config::mutex_type> Guard;\n    if (M)\n      Guard = std::unique_lock<typename Config::mutex_type>(*M);\n    Config::onDelete(Copy.Map->Data, Copy.Unwrap());  // May destroy *this.\n    Copy.Map->Map.erase(Copy);  // Definitely destroys *this.\n  }\n\n  void allUsesReplacedWith(Value *new_key) override {\n    assert(isa<KeySansPointerT>(new_key) &&\n           \"Invalid RAUW on key of ValueMap<>\");\n    // Make a copy that won't get changed even when *this is destroyed.\n    ValueMapCallbackVH Copy(*this);\n    typename Config::mutex_type *M = Config::getMutex(Copy.Map->Data);\n    std::unique_lock<typename Config::mutex_type> Guard;\n    if (M)\n      Guard = std::unique_lock<typename Config::mutex_type>(*M);\n\n    KeyT typed_new_key = cast<KeySansPointerT>(new_key);\n    // Can destroy *this:\n    Config::onRAUW(Copy.Map->Data, Copy.Unwrap(), typed_new_key);\n    if (Config::FollowRAUW) {\n      typename ValueMapT::MapT::iterator I = Copy.Map->Map.find(Copy);\n      // I could == Copy.Map->Map.end() if the onRAUW callback already\n      // removed the old mapping.\n      if (I != Copy.Map->Map.end()) {\n        ValueT Target(std::move(I->second));\n        Copy.Map->Map.erase(I);  // Definitely destroys *this.\n        Copy.Map->insert(std::make_pair(typed_new_key, std::move(Target)));\n      }\n    }\n  }\n};\n\ntemplate<typename KeyT, typename ValueT, typename Config>\nstruct DenseMapInfo<ValueMapCallbackVH<KeyT, ValueT, Config>> {\n  using VH = ValueMapCallbackVH<KeyT, ValueT, Config>;\n\n  static inline VH getEmptyKey() {\n    return VH(DenseMapInfo<Value *>::getEmptyKey());\n  }\n\n  static inline VH getTombstoneKey() {\n    return VH(DenseMapInfo<Value *>::getTombstoneKey());\n  }\n\n  static unsigned getHashValue(const VH &Val) {\n    return DenseMapInfo<KeyT>::getHashValue(Val.Unwrap());\n  }\n\n  static unsigned getHashValue(const KeyT &Val) {\n    return DenseMapInfo<KeyT>::getHashValue(Val);\n  }\n\n  static bool isEqual(const VH &LHS, const VH &RHS) {\n    return LHS == RHS;\n  }\n\n  static bool isEqual(const KeyT &LHS, const VH &RHS) {\n    return LHS == RHS.getValPtr();\n  }\n};\n\ntemplate<typename DenseMapT, typename KeyT>\nclass ValueMapIterator :\n    public std::iterator<std::forward_iterator_tag,\n                         std::pair<KeyT, typename DenseMapT::mapped_type>,\n                         ptrdiff_t> {\n  using BaseT = typename DenseMapT::iterator;\n  using ValueT = typename DenseMapT::mapped_type;\n\n  BaseT I;\n\npublic:\n  ValueMapIterator() : I() {}\n  ValueMapIterator(BaseT I) : I(I) {}\n\n  BaseT base() const { return I; }\n\n  struct ValueTypeProxy {\n    const KeyT first;\n    ValueT& second;\n\n    ValueTypeProxy *operator->() { return this; }\n\n    operator std::pair<KeyT, ValueT>() const {\n      return std::make_pair(first, second);\n    }\n  };\n\n  ValueTypeProxy operator*() const {\n    ValueTypeProxy Result = {I->first.Unwrap(), I->second};\n    return Result;\n  }\n\n  ValueTypeProxy operator->() const {\n    return operator*();\n  }\n\n  bool operator==(const ValueMapIterator &RHS) const {\n    return I == RHS.I;\n  }\n  bool operator!=(const ValueMapIterator &RHS) const {\n    return I != RHS.I;\n  }\n\n  inline ValueMapIterator& operator++() {  // Preincrement\n    ++I;\n    return *this;\n  }\n  ValueMapIterator operator++(int) {  // Postincrement\n    ValueMapIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\ntemplate<typename DenseMapT, typename KeyT>\nclass ValueMapConstIterator :\n    public std::iterator<std::forward_iterator_tag,\n                         std::pair<KeyT, typename DenseMapT::mapped_type>,\n                         ptrdiff_t> {\n  using BaseT = typename DenseMapT::const_iterator;\n  using ValueT = typename DenseMapT::mapped_type;\n\n  BaseT I;\n\npublic:\n  ValueMapConstIterator() : I() {}\n  ValueMapConstIterator(BaseT I) : I(I) {}\n  ValueMapConstIterator(ValueMapIterator<DenseMapT, KeyT> Other)\n    : I(Other.base()) {}\n\n  BaseT base() const { return I; }\n\n  struct ValueTypeProxy {\n    const KeyT first;\n    const ValueT& second;\n    ValueTypeProxy *operator->() { return this; }\n    operator std::pair<KeyT, ValueT>() const {\n      return std::make_pair(first, second);\n    }\n  };\n\n  ValueTypeProxy operator*() const {\n    ValueTypeProxy Result = {I->first.Unwrap(), I->second};\n    return Result;\n  }\n\n  ValueTypeProxy operator->() const {\n    return operator*();\n  }\n\n  bool operator==(const ValueMapConstIterator &RHS) const {\n    return I == RHS.I;\n  }\n  bool operator!=(const ValueMapConstIterator &RHS) const {\n    return I != RHS.I;\n  }\n\n  inline ValueMapConstIterator& operator++() {  // Preincrement\n    ++I;\n    return *this;\n  }\n  ValueMapConstIterator operator++(int) {  // Postincrement\n    ValueMapConstIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_VALUEMAP_H\n"}, "56": {"id": 56, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCDwarf.h", "content": "//===- MCDwarf.h - Machine Code Dwarf support -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the declaration of the MCDwarfFile to support the dwarf\n// .file directive and the .loc directive.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCDWARF_H\n#define LLVM_MC_MCDWARF_H\n\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/MC/MCSection.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/MD5.h\"\n#include <cassert>\n#include <cstdint>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\ntemplate <typename T> class ArrayRef;\nclass MCAsmBackend;\nclass MCContext;\nclass MCDwarfLineStr;\nclass MCObjectStreamer;\nclass MCStreamer;\nclass MCSymbol;\nclass raw_ostream;\nclass SMLoc;\nclass SourceMgr;\n\nnamespace mcdwarf {\n// Emit the common part of the DWARF 5 range/locations list tables header.\nMCSymbol *emitListsTableHeaderStart(MCStreamer &S);\n} // namespace mcdwarf\n\n/// Instances of this class represent the name of the dwarf .file directive and\n/// its associated dwarf file number in the MC file. MCDwarfFile's are created\n/// and uniqued by the MCContext class. In Dwarf 4 file numbers start from 1;\n/// i.e. the entry with file number 1 is the first element in the vector of\n/// DwarfFiles and there is no MCDwarfFile with file number 0. In Dwarf 5 file\n/// numbers start from 0, with the MCDwarfFile with file number 0 being the\n/// primary source file, and file numbers correspond to their index in the\n/// vector.\nstruct MCDwarfFile {\n  // The base name of the file without its directory path.\n  std::string Name;\n\n  // The index into the list of directory names for this file name.\n  unsigned DirIndex = 0;\n\n  /// The MD5 checksum, if there is one. Non-owning pointer to data allocated\n  /// in MCContext.\n  Optional<MD5::MD5Result> Checksum;\n\n  /// The source code of the file. Non-owning reference to data allocated in\n  /// MCContext.\n  Optional<StringRef> Source;\n};\n\n/// Instances of this class represent the information from a\n/// dwarf .loc directive.\nclass MCDwarfLoc {\n  uint32_t FileNum;\n  uint32_t Line;\n  uint16_t Column;\n  // Flags (see #define's below)\n  uint8_t Flags;\n  uint8_t Isa;\n  uint32_t Discriminator;\n\n// Flag that indicates the initial value of the is_stmt_start flag.\n#define DWARF2_LINE_DEFAULT_IS_STMT 1\n\n#define DWARF2_FLAG_IS_STMT (1 << 0)\n#define DWARF2_FLAG_BASIC_BLOCK (1 << 1)\n#define DWARF2_FLAG_PROLOGUE_END (1 << 2)\n#define DWARF2_FLAG_EPILOGUE_BEGIN (1 << 3)\n\nprivate: // MCContext manages these\n  friend class MCContext;\n  friend class MCDwarfLineEntry;\n\n  MCDwarfLoc(unsigned fileNum, unsigned line, unsigned column, unsigned flags,\n             unsigned isa, unsigned discriminator)\n      : FileNum(fileNum), Line(line), Column(column), Flags(flags), Isa(isa),\n        Discriminator(discriminator) {}\n\n  // Allow the default copy constructor and assignment operator to be used\n  // for an MCDwarfLoc object.\n\npublic:\n  /// Get the FileNum of this MCDwarfLoc.\n  unsigned getFileNum() const { return FileNum; }\n\n  /// Get the Line of this MCDwarfLoc.\n  unsigned getLine() const { return Line; }\n\n  /// Get the Column of this MCDwarfLoc.\n  unsigned getColumn() const { return Column; }\n\n  /// Get the Flags of this MCDwarfLoc.\n  unsigned getFlags() const { return Flags; }\n\n  /// Get the Isa of this MCDwarfLoc.\n  unsigned getIsa() const { return Isa; }\n\n  /// Get the Discriminator of this MCDwarfLoc.\n  unsigned getDiscriminator() const { return Discriminator; }\n\n  /// Set the FileNum of this MCDwarfLoc.\n  void setFileNum(unsigned fileNum) { FileNum = fileNum; }\n\n  /// Set the Line of this MCDwarfLoc.\n  void setLine(unsigned line) { Line = line; }\n\n  /// Set the Column of this MCDwarfLoc.\n  void setColumn(unsigned column) {\n    assert(column <= UINT16_MAX);\n    Column = column;\n  }\n\n  /// Set the Flags of this MCDwarfLoc.\n  void setFlags(unsigned flags) {\n    assert(flags <= UINT8_MAX);\n    Flags = flags;\n  }\n\n  /// Set the Isa of this MCDwarfLoc.\n  void setIsa(unsigned isa) {\n    assert(isa <= UINT8_MAX);\n    Isa = isa;\n  }\n\n  /// Set the Discriminator of this MCDwarfLoc.\n  void setDiscriminator(unsigned discriminator) {\n    Discriminator = discriminator;\n  }\n};\n\n/// Instances of this class represent the line information for\n/// the dwarf line table entries.  Which is created after a machine\n/// instruction is assembled and uses an address from a temporary label\n/// created at the current address in the current section and the info from\n/// the last .loc directive seen as stored in the context.\nclass MCDwarfLineEntry : public MCDwarfLoc {\n  MCSymbol *Label;\n\nprivate:\n  // Allow the default copy constructor and assignment operator to be used\n  // for an MCDwarfLineEntry object.\n\npublic:\n  // Constructor to create an MCDwarfLineEntry given a symbol and the dwarf loc.\n  MCDwarfLineEntry(MCSymbol *label, const MCDwarfLoc loc)\n      : MCDwarfLoc(loc), Label(label) {}\n\n  MCSymbol *getLabel() const { return Label; }\n\n  // This is called when an instruction is assembled into the specified\n  // section and if there is information from the last .loc directive that\n  // has yet to have a line entry made for it is made.\n  static void make(MCStreamer *MCOS, MCSection *Section);\n};\n\n/// Instances of this class represent the line information for a compile\n/// unit where machine instructions have been assembled after seeing .loc\n/// directives.  This is the information used to build the dwarf line\n/// table for a section.\nclass MCLineSection {\npublic:\n  // Add an entry to this MCLineSection's line entries.\n  void addLineEntry(const MCDwarfLineEntry &LineEntry, MCSection *Sec) {\n    MCLineDivisions[Sec].push_back(LineEntry);\n  }\n\n  using MCDwarfLineEntryCollection = std::vector<MCDwarfLineEntry>;\n  using iterator = MCDwarfLineEntryCollection::iterator;\n  using const_iterator = MCDwarfLineEntryCollection::const_iterator;\n  using MCLineDivisionMap = MapVector<MCSection *, MCDwarfLineEntryCollection>;\n\nprivate:\n  // A collection of MCDwarfLineEntry for each section.\n  MCLineDivisionMap MCLineDivisions;\n\npublic:\n  // Returns the collection of MCDwarfLineEntry for a given Compile Unit ID.\n  const MCLineDivisionMap &getMCLineEntries() const {\n    return MCLineDivisions;\n  }\n};\n\nstruct MCDwarfLineTableParams {\n  /// First special line opcode - leave room for the standard opcodes.\n  /// Note: If you want to change this, you'll have to update the\n  /// \"StandardOpcodeLengths\" table that is emitted in\n  /// \\c Emit().\n  uint8_t DWARF2LineOpcodeBase = 13;\n  /// Minimum line offset in a special line info. opcode.  The value\n  /// -5 was chosen to give a reasonable range of values.\n  int8_t DWARF2LineBase = -5;\n  /// Range of line offsets in a special line info. opcode.\n  uint8_t DWARF2LineRange = 14;\n};\n\nstruct MCDwarfLineTableHeader {\n  MCSymbol *Label = nullptr;\n  SmallVector<std::string, 3> MCDwarfDirs;\n  SmallVector<MCDwarfFile, 3> MCDwarfFiles;\n  StringMap<unsigned> SourceIdMap;\n  std::string CompilationDir;\n  MCDwarfFile RootFile;\n  bool HasSource = false;\nprivate:\n  bool HasAllMD5 = true;\n  bool HasAnyMD5 = false;\n\npublic:\n  MCDwarfLineTableHeader() = default;\n\n  Expected<unsigned> tryGetFile(StringRef &Directory, StringRef &FileName,\n                                Optional<MD5::MD5Result> Checksum,\n                                Optional<StringRef> Source,\n                                uint16_t DwarfVersion,\n                                unsigned FileNumber = 0);\n  std::pair<MCSymbol *, MCSymbol *>\n  Emit(MCStreamer *MCOS, MCDwarfLineTableParams Params,\n       Optional<MCDwarfLineStr> &LineStr) const;\n  std::pair<MCSymbol *, MCSymbol *>\n  Emit(MCStreamer *MCOS, MCDwarfLineTableParams Params,\n       ArrayRef<char> SpecialOpcodeLengths,\n       Optional<MCDwarfLineStr> &LineStr) const;\n  void resetMD5Usage() {\n    HasAllMD5 = true;\n    HasAnyMD5 = false;\n  }\n  void trackMD5Usage(bool MD5Used) {\n    HasAllMD5 &= MD5Used;\n    HasAnyMD5 |= MD5Used;\n  }\n  bool isMD5UsageConsistent() const {\n    return MCDwarfFiles.empty() || (HasAllMD5 == HasAnyMD5);\n  }\n\n  void setRootFile(StringRef Directory, StringRef FileName,\n                   Optional<MD5::MD5Result> Checksum,\n                   Optional<StringRef> Source) {\n    CompilationDir = std::string(Directory);\n    RootFile.Name = std::string(FileName);\n    RootFile.DirIndex = 0;\n    RootFile.Checksum = Checksum;\n    RootFile.Source = Source;\n    trackMD5Usage(Checksum.hasValue());\n    HasSource = Source.hasValue();\n  }\n\n  void resetFileTable() {\n    MCDwarfDirs.clear();\n    MCDwarfFiles.clear();\n    RootFile.Name.clear();\n    resetMD5Usage();\n    HasSource = false;\n  }\n\nprivate:\n  void emitV2FileDirTables(MCStreamer *MCOS) const;\n  void emitV5FileDirTables(MCStreamer *MCOS, Optional<MCDwarfLineStr> &LineStr) const;\n};\n\nclass MCDwarfDwoLineTable {\n  MCDwarfLineTableHeader Header;\n  bool HasSplitLineTable = false;\n\npublic:\n  void maybeSetRootFile(StringRef Directory, StringRef FileName,\n                        Optional<MD5::MD5Result> Checksum,\n                        Optional<StringRef> Source) {\n    if (!Header.RootFile.Name.empty())\n      return;\n    Header.setRootFile(Directory, FileName, Checksum, Source);\n  }\n\n  unsigned getFile(StringRef Directory, StringRef FileName,\n                   Optional<MD5::MD5Result> Checksum, uint16_t DwarfVersion,\n                   Optional<StringRef> Source) {\n    HasSplitLineTable = true;\n    return cantFail(Header.tryGetFile(Directory, FileName, Checksum, Source,\n                                      DwarfVersion));\n  }\n\n  void Emit(MCStreamer &MCOS, MCDwarfLineTableParams Params,\n            MCSection *Section) const;\n};\n\nclass MCDwarfLineTable {\n  MCDwarfLineTableHeader Header;\n  MCLineSection MCLineSections;\n\npublic:\n  // This emits the Dwarf file and the line tables for all Compile Units.\n  static void emit(MCStreamer *MCOS, MCDwarfLineTableParams Params);\n\n  // This emits the Dwarf file and the line tables for a given Compile Unit.\n  void emitCU(MCStreamer *MCOS, MCDwarfLineTableParams Params,\n              Optional<MCDwarfLineStr> &LineStr) const;\n\n  Expected<unsigned> tryGetFile(StringRef &Directory, StringRef &FileName,\n                                Optional<MD5::MD5Result> Checksum,\n                                Optional<StringRef> Source,\n                                uint16_t DwarfVersion,\n                                unsigned FileNumber = 0);\n  unsigned getFile(StringRef &Directory, StringRef &FileName,\n                   Optional<MD5::MD5Result> Checksum, Optional<StringRef> Source,\n                   uint16_t DwarfVersion, unsigned FileNumber = 0) {\n    return cantFail(tryGetFile(Directory, FileName, Checksum, Source,\n                               DwarfVersion, FileNumber));\n  }\n\n  void setRootFile(StringRef Directory, StringRef FileName,\n                   Optional<MD5::MD5Result> Checksum, Optional<StringRef> Source) {\n    Header.CompilationDir = std::string(Directory);\n    Header.RootFile.Name = std::string(FileName);\n    Header.RootFile.DirIndex = 0;\n    Header.RootFile.Checksum = Checksum;\n    Header.RootFile.Source = Source;\n    Header.trackMD5Usage(Checksum.hasValue());\n    Header.HasSource = Source.hasValue();\n  }\n\n  void resetFileTable() { Header.resetFileTable(); }\n\n  bool hasRootFile() const { return !Header.RootFile.Name.empty(); }\n\n  const MCDwarfFile &getRootFile() const { return Header.RootFile; }\n\n  // Report whether MD5 usage has been consistent (all-or-none).\n  bool isMD5UsageConsistent() const { return Header.isMD5UsageConsistent(); }\n\n  MCSymbol *getLabel() const {\n    return Header.Label;\n  }\n\n  void setLabel(MCSymbol *Label) {\n    Header.Label = Label;\n  }\n\n  const SmallVectorImpl<std::string> &getMCDwarfDirs() const {\n    return Header.MCDwarfDirs;\n  }\n\n  SmallVectorImpl<std::string> &getMCDwarfDirs() {\n    return Header.MCDwarfDirs;\n  }\n\n  const SmallVectorImpl<MCDwarfFile> &getMCDwarfFiles() const {\n    return Header.MCDwarfFiles;\n  }\n\n  SmallVectorImpl<MCDwarfFile> &getMCDwarfFiles() {\n    return Header.MCDwarfFiles;\n  }\n\n  const MCLineSection &getMCLineSections() const {\n    return MCLineSections;\n  }\n  MCLineSection &getMCLineSections() {\n    return MCLineSections;\n  }\n};\n\nclass MCDwarfLineAddr {\npublic:\n  /// Utility function to encode a Dwarf pair of LineDelta and AddrDeltas.\n  static void Encode(MCContext &Context, MCDwarfLineTableParams Params,\n                     int64_t LineDelta, uint64_t AddrDelta, raw_ostream &OS);\n\n  /// Utility function to encode a Dwarf pair of LineDelta and AddrDeltas using\n  /// fixed length operands. Returns (Offset, Size, SetDelta).\n  static std::tuple<uint32_t, uint32_t, bool> fixedEncode(MCContext &Context,\n                                                          int64_t LineDelta,\n                                                          uint64_t AddrDelta,\n                                                          raw_ostream &OS);\n\n  /// Utility function to emit the encoding to a streamer.\n  static void Emit(MCStreamer *MCOS, MCDwarfLineTableParams Params,\n                   int64_t LineDelta, uint64_t AddrDelta);\n};\n\nclass MCGenDwarfInfo {\npublic:\n  //\n  // When generating dwarf for assembly source files this emits the Dwarf\n  // sections.\n  //\n  static void Emit(MCStreamer *MCOS);\n};\n\n// When generating dwarf for assembly source files this is the info that is\n// needed to be gathered for each symbol that will have a dwarf label.\nclass MCGenDwarfLabelEntry {\nprivate:\n  // Name of the symbol without a leading underbar, if any.\n  StringRef Name;\n  // The dwarf file number this symbol is in.\n  unsigned FileNumber;\n  // The line number this symbol is at.\n  unsigned LineNumber;\n  // The low_pc for the dwarf label is taken from this symbol.\n  MCSymbol *Label;\n\npublic:\n  MCGenDwarfLabelEntry(StringRef name, unsigned fileNumber, unsigned lineNumber,\n                       MCSymbol *label)\n      : Name(name), FileNumber(fileNumber), LineNumber(lineNumber),\n        Label(label) {}\n\n  StringRef getName() const { return Name; }\n  unsigned getFileNumber() const { return FileNumber; }\n  unsigned getLineNumber() const { return LineNumber; }\n  MCSymbol *getLabel() const { return Label; }\n\n  // This is called when label is created when we are generating dwarf for\n  // assembly source files.\n  static void Make(MCSymbol *Symbol, MCStreamer *MCOS, SourceMgr &SrcMgr,\n                   SMLoc &Loc);\n};\n\nclass MCCFIInstruction {\npublic:\n  enum OpType {\n    OpSameValue,\n    OpRememberState,\n    OpRestoreState,\n    OpOffset,\n    OpDefCfaRegister,\n    OpDefCfaOffset,\n    OpDefCfa,\n    OpRelOffset,\n    OpAdjustCfaOffset,\n    OpEscape,\n    OpRestore,\n    OpUndefined,\n    OpRegister,\n    OpWindowSave,\n    OpNegateRAState,\n    OpGnuArgsSize\n  };\n\nprivate:\n  OpType Operation;\n  MCSymbol *Label;\n  unsigned Register;\n  union {\n    int Offset;\n    unsigned Register2;\n  };\n  std::vector<char> Values;\n  std::string Comment;\n\n  MCCFIInstruction(OpType Op, MCSymbol *L, unsigned R, int O, StringRef V,\n                   StringRef Comment = \"\")\n      : Operation(Op), Label(L), Register(R), Offset(O),\n        Values(V.begin(), V.end()), Comment(Comment) {\n    assert(Op != OpRegister);\n  }\n\n  MCCFIInstruction(OpType Op, MCSymbol *L, unsigned R1, unsigned R2)\n      : Operation(Op), Label(L), Register(R1), Register2(R2) {\n    assert(Op == OpRegister);\n  }\n\npublic:\n  /// .cfi_def_cfa defines a rule for computing CFA as: take address from\n  /// Register and add Offset to it.\n  static MCCFIInstruction cfiDefCfa(MCSymbol *L, unsigned Register,\n                                    int Offset) {\n    return MCCFIInstruction(OpDefCfa, L, Register, Offset, \"\");\n  }\n\n  /// .cfi_def_cfa_register modifies a rule for computing CFA. From now\n  /// on Register will be used instead of the old one. Offset remains the same.\n  static MCCFIInstruction createDefCfaRegister(MCSymbol *L, unsigned Register) {\n    return MCCFIInstruction(OpDefCfaRegister, L, Register, 0, \"\");\n  }\n\n  /// .cfi_def_cfa_offset modifies a rule for computing CFA. Register\n  /// remains the same, but offset is new. Note that it is the absolute offset\n  /// that will be added to a defined register to the compute CFA address.\n  static MCCFIInstruction cfiDefCfaOffset(MCSymbol *L, int Offset) {\n    return MCCFIInstruction(OpDefCfaOffset, L, 0, Offset, \"\");\n  }\n\n  /// .cfi_adjust_cfa_offset Same as .cfi_def_cfa_offset, but\n  /// Offset is a relative value that is added/subtracted from the previous\n  /// offset.\n  static MCCFIInstruction createAdjustCfaOffset(MCSymbol *L, int Adjustment) {\n    return MCCFIInstruction(OpAdjustCfaOffset, L, 0, Adjustment, \"\");\n  }\n\n  /// .cfi_offset Previous value of Register is saved at offset Offset\n  /// from CFA.\n  static MCCFIInstruction createOffset(MCSymbol *L, unsigned Register,\n                                       int Offset) {\n    return MCCFIInstruction(OpOffset, L, Register, Offset, \"\");\n  }\n\n  /// .cfi_rel_offset Previous value of Register is saved at offset\n  /// Offset from the current CFA register. This is transformed to .cfi_offset\n  /// using the known displacement of the CFA register from the CFA.\n  static MCCFIInstruction createRelOffset(MCSymbol *L, unsigned Register,\n                                          int Offset) {\n    return MCCFIInstruction(OpRelOffset, L, Register, Offset, \"\");\n  }\n\n  /// .cfi_register Previous value of Register1 is saved in\n  /// register Register2.\n  static MCCFIInstruction createRegister(MCSymbol *L, unsigned Register1,\n                                         unsigned Register2) {\n    return MCCFIInstruction(OpRegister, L, Register1, Register2);\n  }\n\n  /// .cfi_window_save SPARC register window is saved.\n  static MCCFIInstruction createWindowSave(MCSymbol *L) {\n    return MCCFIInstruction(OpWindowSave, L, 0, 0, \"\");\n  }\n\n  /// .cfi_negate_ra_state AArch64 negate RA state.\n  static MCCFIInstruction createNegateRAState(MCSymbol *L) {\n    return MCCFIInstruction(OpNegateRAState, L, 0, 0, \"\");\n  }\n\n  /// .cfi_restore says that the rule for Register is now the same as it\n  /// was at the beginning of the function, after all initial instructions added\n  /// by .cfi_startproc were executed.\n  static MCCFIInstruction createRestore(MCSymbol *L, unsigned Register) {\n    return MCCFIInstruction(OpRestore, L, Register, 0, \"\");\n  }\n\n  /// .cfi_undefined From now on the previous value of Register can't be\n  /// restored anymore.\n  static MCCFIInstruction createUndefined(MCSymbol *L, unsigned Register) {\n    return MCCFIInstruction(OpUndefined, L, Register, 0, \"\");\n  }\n\n  /// .cfi_same_value Current value of Register is the same as in the\n  /// previous frame. I.e., no restoration is needed.\n  static MCCFIInstruction createSameValue(MCSymbol *L, unsigned Register) {\n    return MCCFIInstruction(OpSameValue, L, Register, 0, \"\");\n  }\n\n  /// .cfi_remember_state Save all current rules for all registers.\n  static MCCFIInstruction createRememberState(MCSymbol *L) {\n    return MCCFIInstruction(OpRememberState, L, 0, 0, \"\");\n  }\n\n  /// .cfi_restore_state Restore the previously saved state.\n  static MCCFIInstruction createRestoreState(MCSymbol *L) {\n    return MCCFIInstruction(OpRestoreState, L, 0, 0, \"\");\n  }\n\n  /// .cfi_escape Allows the user to add arbitrary bytes to the unwind\n  /// info.\n  static MCCFIInstruction createEscape(MCSymbol *L, StringRef Vals,\n                                       StringRef Comment = \"\") {\n    return MCCFIInstruction(OpEscape, L, 0, 0, Vals, Comment);\n  }\n\n  /// A special wrapper for .cfi_escape that indicates GNU_ARGS_SIZE\n  static MCCFIInstruction createGnuArgsSize(MCSymbol *L, int Size) {\n    return MCCFIInstruction(OpGnuArgsSize, L, 0, Size, \"\");\n  }\n\n  OpType getOperation() const { return Operation; }\n  MCSymbol *getLabel() const { return Label; }\n\n  unsigned getRegister() const {\n    assert(Operation == OpDefCfa || Operation == OpOffset ||\n           Operation == OpRestore || Operation == OpUndefined ||\n           Operation == OpSameValue || Operation == OpDefCfaRegister ||\n           Operation == OpRelOffset || Operation == OpRegister);\n    return Register;\n  }\n\n  unsigned getRegister2() const {\n    assert(Operation == OpRegister);\n    return Register2;\n  }\n\n  int getOffset() const {\n    assert(Operation == OpDefCfa || Operation == OpOffset ||\n           Operation == OpRelOffset || Operation == OpDefCfaOffset ||\n           Operation == OpAdjustCfaOffset || Operation == OpGnuArgsSize);\n    return Offset;\n  }\n\n  StringRef getValues() const {\n    assert(Operation == OpEscape);\n    return StringRef(&Values[0], Values.size());\n  }\n\n  StringRef getComment() const {\n    return Comment;\n  }\n};\n\nstruct MCDwarfFrameInfo {\n  MCDwarfFrameInfo() = default;\n\n  MCSymbol *Begin = nullptr;\n  MCSymbol *End = nullptr;\n  const MCSymbol *Personality = nullptr;\n  const MCSymbol *Lsda = nullptr;\n  std::vector<MCCFIInstruction> Instructions;\n  unsigned CurrentCfaRegister = 0;\n  unsigned PersonalityEncoding = 0;\n  unsigned LsdaEncoding = 0;\n  uint32_t CompactUnwindEncoding = 0;\n  bool IsSignalFrame = false;\n  bool IsSimple = false;\n  unsigned RAReg = static_cast<unsigned>(INT_MAX);\n  bool IsBKeyFrame = false;\n};\n\nclass MCDwarfFrameEmitter {\npublic:\n  //\n  // This emits the frame info section.\n  //\n  static void Emit(MCObjectStreamer &streamer, MCAsmBackend *MAB, bool isEH);\n  static void EmitAdvanceLoc(MCObjectStreamer &Streamer, uint64_t AddrDelta);\n  static void EncodeAdvanceLoc(MCContext &Context, uint64_t AddrDelta,\n                               raw_ostream &OS, uint32_t *Offset = nullptr,\n                               uint32_t *Size = nullptr);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCDWARF_H\n"}, "60": {"id": 60, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h", "content": "//===- MCLinkerOptimizationHint.h - LOH interface ---------------*- C++ -*-===//\n//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares some helpers classes to handle Linker Optimization Hint\n// (LOH).\n//\n// FIXME: LOH interface supports only MachO format at the moment.\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCLINKEROPTIMIZATIONHINT_H\n#define LLVM_MC_MCLINKEROPTIMIZATIONHINT_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <cstdint>\n\nnamespace llvm {\n\nclass MachObjectWriter;\nclass MCAsmLayout;\nclass MCSymbol;\n\n/// Linker Optimization Hint Type.\nenum MCLOHType {\n  MCLOH_AdrpAdrp = 0x1u,      ///< Adrp xY, _v1@PAGE -> Adrp xY, _v2@PAGE.\n  MCLOH_AdrpLdr = 0x2u,       ///< Adrp _v@PAGE -> Ldr _v@PAGEOFF.\n  MCLOH_AdrpAddLdr = 0x3u,    ///< Adrp _v@PAGE -> Add _v@PAGEOFF -> Ldr.\n  MCLOH_AdrpLdrGotLdr = 0x4u, ///< Adrp _v@GOTPAGE -> Ldr _v@GOTPAGEOFF -> Ldr.\n  MCLOH_AdrpAddStr = 0x5u,    ///< Adrp _v@PAGE -> Add _v@PAGEOFF -> Str.\n  MCLOH_AdrpLdrGotStr = 0x6u, ///< Adrp _v@GOTPAGE -> Ldr _v@GOTPAGEOFF -> Str.\n  MCLOH_AdrpAdd = 0x7u,       ///< Adrp _v@PAGE -> Add _v@PAGEOFF.\n  MCLOH_AdrpLdrGot = 0x8u     ///< Adrp _v@GOTPAGE -> Ldr _v@GOTPAGEOFF.\n};\n\nstatic inline StringRef MCLOHDirectiveName() {\n  return StringRef(\".loh\");\n}\n\nstatic inline bool isValidMCLOHType(unsigned Kind) {\n  return Kind >= MCLOH_AdrpAdrp && Kind <= MCLOH_AdrpLdrGot;\n}\n\nstatic inline int MCLOHNameToId(StringRef Name) {\n#define MCLOHCaseNameToId(Name)     .Case(#Name, MCLOH_ ## Name)\n  return StringSwitch<int>(Name)\n    MCLOHCaseNameToId(AdrpAdrp)\n    MCLOHCaseNameToId(AdrpLdr)\n    MCLOHCaseNameToId(AdrpAddLdr)\n    MCLOHCaseNameToId(AdrpLdrGotLdr)\n    MCLOHCaseNameToId(AdrpAddStr)\n    MCLOHCaseNameToId(AdrpLdrGotStr)\n    MCLOHCaseNameToId(AdrpAdd)\n    MCLOHCaseNameToId(AdrpLdrGot)\n    .Default(-1);\n#undef MCLOHCaseNameToId\n}\n\nstatic inline StringRef MCLOHIdToName(MCLOHType Kind) {\n#define MCLOHCaseIdToName(Name)      case MCLOH_ ## Name: return StringRef(#Name);\n  switch (Kind) {\n    MCLOHCaseIdToName(AdrpAdrp);\n    MCLOHCaseIdToName(AdrpLdr);\n    MCLOHCaseIdToName(AdrpAddLdr);\n    MCLOHCaseIdToName(AdrpLdrGotLdr);\n    MCLOHCaseIdToName(AdrpAddStr);\n    MCLOHCaseIdToName(AdrpLdrGotStr);\n    MCLOHCaseIdToName(AdrpAdd);\n    MCLOHCaseIdToName(AdrpLdrGot);\n  }\n  return StringRef();\n#undef MCLOHCaseIdToName\n}\n\nstatic inline int MCLOHIdToNbArgs(MCLOHType Kind) {\n  switch (Kind) {\n    // LOH with two arguments\n  case MCLOH_AdrpAdrp:\n  case MCLOH_AdrpLdr:\n  case MCLOH_AdrpAdd:\n  case MCLOH_AdrpLdrGot:\n    return 2;\n    // LOH with three arguments\n  case MCLOH_AdrpAddLdr:\n  case MCLOH_AdrpLdrGotLdr:\n  case MCLOH_AdrpAddStr:\n  case MCLOH_AdrpLdrGotStr:\n    return 3;\n  }\n  return -1;\n}\n\n/// Store Linker Optimization Hint information (LOH).\nclass MCLOHDirective {\n  MCLOHType Kind;\n\n  /// Arguments of this directive. Order matters.\n  SmallVector<MCSymbol *, 3> Args;\n\n  /// Emit this directive in \\p OutStream using the information available\n  /// in the given \\p ObjWriter and \\p Layout to get the address of the\n  /// arguments within the object file.\n  void emit_impl(raw_ostream &OutStream, const MachObjectWriter &ObjWriter,\n                 const MCAsmLayout &Layout) const;\n\npublic:\n  using LOHArgs = SmallVectorImpl<MCSymbol *>;\n\n  MCLOHDirective(MCLOHType Kind, const LOHArgs &Args)\n      : Kind(Kind), Args(Args.begin(), Args.end()) {\n    assert(isValidMCLOHType(Kind) && \"Invalid LOH directive type!\");\n  }\n\n  MCLOHType getKind() const { return Kind; }\n\n  const LOHArgs &getArgs() const { return Args; }\n\n  /// Emit this directive as:\n  /// <kind, numArgs, addr1, ..., addrN>\n  void emit(MachObjectWriter &ObjWriter, const MCAsmLayout &Layout) const;\n\n  /// Get the size in bytes of this directive if emitted in \\p ObjWriter with\n  /// the given \\p Layout.\n  uint64_t getEmitSize(const MachObjectWriter &ObjWriter,\n                       const MCAsmLayout &Layout) const;\n};\n\nclass MCLOHContainer {\n  /// Keep track of the emit size of all the LOHs.\n  mutable uint64_t EmitSize = 0;\n\n  /// Keep track of all LOH directives.\n  SmallVector<MCLOHDirective, 32> Directives;\n\npublic:\n  using LOHDirectives = SmallVectorImpl<MCLOHDirective>;\n\n  MCLOHContainer() = default;\n\n  /// Const accessor to the directives.\n  const LOHDirectives &getDirectives() const {\n    return Directives;\n  }\n\n  /// Add the directive of the given kind \\p Kind with the given arguments\n  /// \\p Args to the container.\n  void addDirective(MCLOHType Kind, const MCLOHDirective::LOHArgs &Args) {\n    Directives.push_back(MCLOHDirective(Kind, Args));\n  }\n\n  /// Get the size of the directives if emitted.\n  uint64_t getEmitSize(const MachObjectWriter &ObjWriter,\n                       const MCAsmLayout &Layout) const {\n    if (!EmitSize) {\n      for (const MCLOHDirective &D : Directives)\n        EmitSize += D.getEmitSize(ObjWriter, Layout);\n    }\n    return EmitSize;\n  }\n\n  /// Emit all Linker Optimization Hint in one big table.\n  /// Each line of the table is emitted by LOHDirective::emit.\n  void emit(MachObjectWriter &ObjWriter, const MCAsmLayout &Layout) const {\n    for (const MCLOHDirective &D : Directives)\n      D.emit(ObjWriter, Layout);\n  }\n\n  void reset() {\n    Directives.clear();\n    EmitSize = 0;\n  }\n};\n\n// Add types for specialized template using MCSymbol.\nusing MCLOHArgs = MCLOHDirective::LOHArgs;\nusing MCLOHDirectives = MCLOHContainer::LOHDirectives;\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCLINKEROPTIMIZATIONHINT_H\n"}, "61": {"id": 61, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "content": "//===- MC/MCRegisterInfo.h - Target Register Description --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file describes an abstract interface used to get information about a\n// target machines register file.  This information is used for a variety of\n// purposed, especially register allocation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCREGISTERINFO_H\n#define LLVM_MC_MCREGISTERINFO_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/MC/LaneBitmask.h\"\n#include \"llvm/MC/MCRegister.h\"\n#include <cassert>\n#include <cstdint>\n#include <iterator>\n#include <utility>\n\nnamespace llvm {\n\n/// MCRegisterClass - Base class of TargetRegisterClass.\nclass MCRegisterClass {\npublic:\n  using iterator = const MCPhysReg*;\n  using const_iterator = const MCPhysReg*;\n\n  const iterator RegsBegin;\n  const uint8_t *const RegSet;\n  const uint32_t NameIdx;\n  const uint16_t RegsSize;\n  const uint16_t RegSetSize;\n  const uint16_t ID;\n  const int8_t CopyCost;\n  const bool Allocatable;\n\n  /// getID() - Return the register class ID number.\n  ///\n  unsigned getID() const { return ID; }\n\n  /// begin/end - Return all of the registers in this class.\n  ///\n  iterator       begin() const { return RegsBegin; }\n  iterator         end() const { return RegsBegin + RegsSize; }\n\n  /// getNumRegs - Return the number of registers in this class.\n  ///\n  unsigned getNumRegs() const { return RegsSize; }\n\n  /// getRegister - Return the specified register in the class.\n  ///\n  unsigned getRegister(unsigned i) const {\n    assert(i < getNumRegs() && \"Register number out of range!\");\n    return RegsBegin[i];\n  }\n\n  /// contains - Return true if the specified register is included in this\n  /// register class.  This does not include virtual registers.\n  bool contains(MCRegister Reg) const {\n    unsigned RegNo = unsigned(Reg);\n    unsigned InByte = RegNo % 8;\n    unsigned Byte = RegNo / 8;\n    if (Byte >= RegSetSize)\n      return false;\n    return (RegSet[Byte] & (1 << InByte)) != 0;\n  }\n\n  /// contains - Return true if both registers are in this class.\n  bool contains(MCRegister Reg1, MCRegister Reg2) const {\n    return contains(Reg1) && contains(Reg2);\n  }\n\n  /// getCopyCost - Return the cost of copying a value between two registers in\n  /// this class. A negative number means the register class is very expensive\n  /// to copy e.g. status flag register classes.\n  int getCopyCost() const { return CopyCost; }\n\n  /// isAllocatable - Return true if this register class may be used to create\n  /// virtual registers.\n  bool isAllocatable() const { return Allocatable; }\n};\n\n/// MCRegisterDesc - This record contains information about a particular\n/// register.  The SubRegs field is a zero terminated array of registers that\n/// are sub-registers of the specific register, e.g. AL, AH are sub-registers\n/// of AX. The SuperRegs field is a zero terminated array of registers that are\n/// super-registers of the specific register, e.g. RAX, EAX, are\n/// super-registers of AX.\n///\nstruct MCRegisterDesc {\n  uint32_t Name;      // Printable name for the reg (for debugging)\n  uint32_t SubRegs;   // Sub-register set, described above\n  uint32_t SuperRegs; // Super-register set, described above\n\n  // Offset into MCRI::SubRegIndices of a list of sub-register indices for each\n  // sub-register in SubRegs.\n  uint32_t SubRegIndices;\n\n  // RegUnits - Points to the list of register units. The low 4 bits holds the\n  // Scale, the high bits hold an offset into DiffLists. See MCRegUnitIterator.\n  uint32_t RegUnits;\n\n  /// Index into list with lane mask sequences. The sequence contains a lanemask\n  /// for every register unit.\n  uint16_t RegUnitLaneMasks;\n};\n\n/// MCRegisterInfo base class - We assume that the target defines a static\n/// array of MCRegisterDesc objects that represent all of the machine\n/// registers that the target has.  As such, we simply have to track a pointer\n/// to this array so that we can turn register number into a register\n/// descriptor.\n///\n/// Note this class is designed to be a base class of TargetRegisterInfo, which\n/// is the interface used by codegen. However, specific targets *should never*\n/// specialize this class. MCRegisterInfo should only contain getters to access\n/// TableGen generated physical register data. It must not be extended with\n/// virtual methods.\n///\nclass MCRegisterInfo {\npublic:\n  using regclass_iterator = const MCRegisterClass *;\n\n  /// DwarfLLVMRegPair - Emitted by tablegen so Dwarf<->LLVM reg mappings can be\n  /// performed with a binary search.\n  struct DwarfLLVMRegPair {\n    unsigned FromReg;\n    unsigned ToReg;\n\n    bool operator<(DwarfLLVMRegPair RHS) const { return FromReg < RHS.FromReg; }\n  };\n\n  /// SubRegCoveredBits - Emitted by tablegen: bit range covered by a subreg\n  /// index, -1 in any being invalid.\n  struct SubRegCoveredBits {\n    uint16_t Offset;\n    uint16_t Size;\n  };\n\nprivate:\n  const MCRegisterDesc *Desc;                 // Pointer to the descriptor array\n  unsigned NumRegs;                           // Number of entries in the array\n  MCRegister RAReg;                           // Return address register\n  MCRegister PCReg;                           // Program counter register\n  const MCRegisterClass *Classes;             // Pointer to the regclass array\n  unsigned NumClasses;                        // Number of entries in the array\n  unsigned NumRegUnits;                       // Number of regunits.\n  const MCPhysReg (*RegUnitRoots)[2];         // Pointer to regunit root table.\n  const MCPhysReg *DiffLists;                 // Pointer to the difflists array\n  const LaneBitmask *RegUnitMaskSequences;    // Pointer to lane mask sequences\n                                              // for register units.\n  const char *RegStrings;                     // Pointer to the string table.\n  const char *RegClassStrings;                // Pointer to the class strings.\n  const uint16_t *SubRegIndices;              // Pointer to the subreg lookup\n                                              // array.\n  const SubRegCoveredBits *SubRegIdxRanges;   // Pointer to the subreg covered\n                                              // bit ranges array.\n  unsigned NumSubRegIndices;                  // Number of subreg indices.\n  const uint16_t *RegEncodingTable;           // Pointer to array of register\n                                              // encodings.\n\n  unsigned L2DwarfRegsSize;\n  unsigned EHL2DwarfRegsSize;\n  unsigned Dwarf2LRegsSize;\n  unsigned EHDwarf2LRegsSize;\n  const DwarfLLVMRegPair *L2DwarfRegs;        // LLVM to Dwarf regs mapping\n  const DwarfLLVMRegPair *EHL2DwarfRegs;      // LLVM to Dwarf regs mapping EH\n  const DwarfLLVMRegPair *Dwarf2LRegs;        // Dwarf to LLVM regs mapping\n  const DwarfLLVMRegPair *EHDwarf2LRegs;      // Dwarf to LLVM regs mapping EH\n  DenseMap<MCRegister, int> L2SEHRegs;        // LLVM to SEH regs mapping\n  DenseMap<MCRegister, int> L2CVRegs;         // LLVM to CV regs mapping\n\npublic:\n  // Forward declaration to become a friend class of DiffListIterator.\n  template <class SubT> class mc_difflist_iterator;\n\n  /// DiffListIterator - Base iterator class that can traverse the\n  /// differentially encoded register and regunit lists in DiffLists.\n  /// Don't use this class directly, use one of the specialized sub-classes\n  /// defined below.\n  class DiffListIterator {\n    uint16_t Val = 0;\n    const MCPhysReg *List = nullptr;\n\n  protected:\n    /// Create an invalid iterator. Call init() to point to something useful.\n    DiffListIterator() = default;\n\n    /// init - Point the iterator to InitVal, decoding subsequent values from\n    /// DiffList. The iterator will initially point to InitVal, sub-classes are\n    /// responsible for skipping the seed value if it is not part of the list.\n    void init(MCPhysReg InitVal, const MCPhysReg *DiffList) {\n      Val = InitVal;\n      List = DiffList;\n    }\n\n    /// advance - Move to the next list position, return the applied\n    /// differential. This function does not detect the end of the list, that\n    /// is the caller's responsibility (by checking for a 0 return value).\n    MCRegister advance() {\n      assert(isValid() && \"Cannot move off the end of the list.\");\n      MCPhysReg D = *List++;\n      Val += D;\n      return D;\n    }\n\n  public:\n    /// isValid - returns true if this iterator is not yet at the end.\n    bool isValid() const { return List; }\n\n    /// Dereference the iterator to get the value at the current position.\n    MCRegister operator*() const { return Val; }\n\n    /// Pre-increment to move to the next position.\n    void operator++() {\n      // The end of the list is encoded as a 0 differential.\n      if (!advance())\n        List = nullptr;\n    }\n\n    template <class SubT> friend class MCRegisterInfo::mc_difflist_iterator;\n  };\n\n  /// Forward iterator using DiffListIterator.\n  template <class SubT>\n  class mc_difflist_iterator\n      : public iterator_facade_base<mc_difflist_iterator<SubT>,\n                                    std::forward_iterator_tag, MCPhysReg> {\n    MCRegisterInfo::DiffListIterator Iter;\n    /// Current value as MCPhysReg, so we can return a reference to it.\n    MCPhysReg Val;\n\n  protected:\n    mc_difflist_iterator(MCRegisterInfo::DiffListIterator Iter) : Iter(Iter) {}\n\n    // Allow conversion between instantiations where valid.\n    mc_difflist_iterator(MCRegister Reg, const MCPhysReg *DiffList) {\n      Iter.init(Reg, DiffList);\n      Val = *Iter;\n    }\n\n  public:\n    // Allow default construction to build variables, but this doesn't build\n    // a useful iterator.\n    mc_difflist_iterator() = default;\n\n    /// Return an iterator past the last element.\n    static SubT end() {\n      SubT End;\n      End.Iter.List = nullptr;\n      return End;\n    }\n\n    bool operator==(const mc_difflist_iterator &Arg) const {\n      return Iter.List == Arg.Iter.List;\n    }\n\n    const MCPhysReg &operator*() const { return Val; }\n\n    using mc_difflist_iterator::iterator_facade_base::operator++;\n    void operator++() {\n      assert(Iter.List && \"Cannot increment the end iterator!\");\n      ++Iter;\n      Val = *Iter;\n    }\n  };\n\n  /// Forward iterator over all sub-registers.\n  /// TODO: Replace remaining uses of MCSubRegIterator.\n  class mc_subreg_iterator : public mc_difflist_iterator<mc_subreg_iterator> {\n  public:\n    mc_subreg_iterator(MCRegisterInfo::DiffListIterator Iter)\n        : mc_difflist_iterator(Iter) {}\n    mc_subreg_iterator() = default;\n    mc_subreg_iterator(MCRegister Reg, const MCRegisterInfo *MCRI)\n        : mc_difflist_iterator(Reg, MCRI->DiffLists + MCRI->get(Reg).SubRegs) {}\n  };\n\n  /// Forward iterator over all super-registers.\n  /// TODO: Replace remaining uses of MCSuperRegIterator.\n  class mc_superreg_iterator\n      : public mc_difflist_iterator<mc_superreg_iterator> {\n  public:\n    mc_superreg_iterator(MCRegisterInfo::DiffListIterator Iter)\n        : mc_difflist_iterator(Iter) {}\n    mc_superreg_iterator() = default;\n    mc_superreg_iterator(MCRegister Reg, const MCRegisterInfo *MCRI)\n        : mc_difflist_iterator(Reg,\n                               MCRI->DiffLists + MCRI->get(Reg).SuperRegs) {}\n  };\n\n  /// Return an iterator range over all sub-registers of \\p Reg, excluding \\p\n  /// Reg.\n  iterator_range<mc_subreg_iterator> subregs(MCRegister Reg) const {\n    return make_range(std::next(mc_subreg_iterator(Reg, this)),\n                      mc_subreg_iterator::end());\n  }\n\n  /// Return an iterator range over all sub-registers of \\p Reg, including \\p\n  /// Reg.\n  iterator_range<mc_subreg_iterator> subregs_inclusive(MCRegister Reg) const {\n    return make_range({Reg, this}, mc_subreg_iterator::end());\n  }\n\n  /// Return an iterator range over all super-registers of \\p Reg, excluding \\p\n  /// Reg.\n  iterator_range<mc_superreg_iterator> superregs(MCRegister Reg) const {\n    return make_range(std::next(mc_superreg_iterator(Reg, this)),\n                      mc_superreg_iterator::end());\n  }\n\n  /// Return an iterator range over all super-registers of \\p Reg, including \\p\n  /// Reg.\n  iterator_range<mc_superreg_iterator>\n  superregs_inclusive(MCRegister Reg) const {\n    return make_range({Reg, this}, mc_superreg_iterator::end());\n  }\n\n  /// Return an iterator range over all sub- and super-registers of \\p Reg,\n  /// including \\p Reg.\n  detail::concat_range<const MCPhysReg, iterator_range<mc_subreg_iterator>,\n                       iterator_range<mc_superreg_iterator>>\n  sub_and_superregs_inclusive(MCRegister Reg) const {\n    return concat<const MCPhysReg>(subregs_inclusive(Reg), superregs(Reg));\n  }\n\n  // These iterators are allowed to sub-class DiffListIterator and access\n  // internal list pointers.\n  friend class MCSubRegIterator;\n  friend class MCSubRegIndexIterator;\n  friend class MCSuperRegIterator;\n  friend class MCRegUnitIterator;\n  friend class MCRegUnitMaskIterator;\n  friend class MCRegUnitRootIterator;\n\n  /// Initialize MCRegisterInfo, called by TableGen\n  /// auto-generated routines. *DO NOT USE*.\n  void InitMCRegisterInfo(const MCRegisterDesc *D, unsigned NR, unsigned RA,\n                          unsigned PC,\n                          const MCRegisterClass *C, unsigned NC,\n                          const MCPhysReg (*RURoots)[2],\n                          unsigned NRU,\n                          const MCPhysReg *DL,\n                          const LaneBitmask *RUMS,\n                          const char *Strings,\n                          const char *ClassStrings,\n                          const uint16_t *SubIndices,\n                          unsigned NumIndices,\n                          const SubRegCoveredBits *SubIdxRanges,\n                          const uint16_t *RET) {\n    Desc = D;\n    NumRegs = NR;\n    RAReg = RA;\n    PCReg = PC;\n    Classes = C;\n    DiffLists = DL;\n    RegUnitMaskSequences = RUMS;\n    RegStrings = Strings;\n    RegClassStrings = ClassStrings;\n    NumClasses = NC;\n    RegUnitRoots = RURoots;\n    NumRegUnits = NRU;\n    SubRegIndices = SubIndices;\n    NumSubRegIndices = NumIndices;\n    SubRegIdxRanges = SubIdxRanges;\n    RegEncodingTable = RET;\n\n    // Initialize DWARF register mapping variables\n    EHL2DwarfRegs = nullptr;\n    EHL2DwarfRegsSize = 0;\n    L2DwarfRegs = nullptr;\n    L2DwarfRegsSize = 0;\n    EHDwarf2LRegs = nullptr;\n    EHDwarf2LRegsSize = 0;\n    Dwarf2LRegs = nullptr;\n    Dwarf2LRegsSize = 0;\n  }\n\n  /// Used to initialize LLVM register to Dwarf\n  /// register number mapping. Called by TableGen auto-generated routines.\n  /// *DO NOT USE*.\n  void mapLLVMRegsToDwarfRegs(const DwarfLLVMRegPair *Map, unsigned Size,\n                              bool isEH) {\n    if (isEH) {\n      EHL2DwarfRegs = Map;\n      EHL2DwarfRegsSize = Size;\n    } else {\n      L2DwarfRegs = Map;\n      L2DwarfRegsSize = Size;\n    }\n  }\n\n  /// Used to initialize Dwarf register to LLVM\n  /// register number mapping. Called by TableGen auto-generated routines.\n  /// *DO NOT USE*.\n  void mapDwarfRegsToLLVMRegs(const DwarfLLVMRegPair *Map, unsigned Size,\n                              bool isEH) {\n    if (isEH) {\n      EHDwarf2LRegs = Map;\n      EHDwarf2LRegsSize = Size;\n    } else {\n      Dwarf2LRegs = Map;\n      Dwarf2LRegsSize = Size;\n    }\n  }\n\n  /// mapLLVMRegToSEHReg - Used to initialize LLVM register to SEH register\n  /// number mapping. By default the SEH register number is just the same\n  /// as the LLVM register number.\n  /// FIXME: TableGen these numbers. Currently this requires target specific\n  /// initialization code.\n  void mapLLVMRegToSEHReg(MCRegister LLVMReg, int SEHReg) {\n    L2SEHRegs[LLVMReg] = SEHReg;\n  }\n\n  void mapLLVMRegToCVReg(MCRegister LLVMReg, int CVReg) {\n    L2CVRegs[LLVMReg] = CVReg;\n  }\n\n  /// This method should return the register where the return\n  /// address can be found.\n  MCRegister getRARegister() const {\n    return RAReg;\n  }\n\n  /// Return the register which is the program counter.\n  MCRegister getProgramCounter() const {\n    return PCReg;\n  }\n\n  const MCRegisterDesc &operator[](MCRegister RegNo) const {\n    assert(RegNo < NumRegs &&\n           \"Attempting to access record for invalid register number!\");\n    return Desc[RegNo];\n  }\n\n  /// Provide a get method, equivalent to [], but more useful with a\n  /// pointer to this object.\n  const MCRegisterDesc &get(MCRegister RegNo) const {\n    return operator[](RegNo);\n  }\n\n  /// Returns the physical register number of sub-register \"Index\"\n  /// for physical register RegNo. Return zero if the sub-register does not\n  /// exist.\n  MCRegister getSubReg(MCRegister Reg, unsigned Idx) const;\n\n  /// Return a super-register of the specified register\n  /// Reg so its sub-register of index SubIdx is Reg.\n  MCRegister getMatchingSuperReg(MCRegister Reg, unsigned SubIdx,\n                                 const MCRegisterClass *RC) const;\n\n  /// For a given register pair, return the sub-register index\n  /// if the second register is a sub-register of the first. Return zero\n  /// otherwise.\n  unsigned getSubRegIndex(MCRegister RegNo, MCRegister SubRegNo) const;\n\n  /// Get the size of the bit range covered by a sub-register index.\n  /// If the index isn't continuous, return the sum of the sizes of its parts.\n  /// If the index is used to access subregisters of different sizes, return -1.\n  unsigned getSubRegIdxSize(unsigned Idx) const;\n\n  /// Get the offset of the bit range covered by a sub-register index.\n  /// If an Offset doesn't make sense (the index isn't continuous, or is used to\n  /// access sub-registers at different offsets), return -1.\n  unsigned getSubRegIdxOffset(unsigned Idx) const;\n\n  /// Return the human-readable symbolic target-specific name for the\n  /// specified physical register.\n  const char *getName(MCRegister RegNo) const {\n    return RegStrings + get(RegNo).Name;\n  }\n\n  /// Return the number of registers this target has (useful for\n  /// sizing arrays holding per register information)\n  unsigned getNumRegs() const {\n    return NumRegs;\n  }\n\n  /// Return the number of sub-register indices\n  /// understood by the target. Index 0 is reserved for the no-op sub-register,\n  /// while 1 to getNumSubRegIndices() - 1 represent real sub-registers.\n  unsigned getNumSubRegIndices() const {\n    return NumSubRegIndices;\n  }\n\n  /// Return the number of (native) register units in the\n  /// target. Register units are numbered from 0 to getNumRegUnits() - 1. They\n  /// can be accessed through MCRegUnitIterator defined below.\n  unsigned getNumRegUnits() const {\n    return NumRegUnits;\n  }\n\n  /// Map a target register to an equivalent dwarf register\n  /// number.  Returns -1 if there is no equivalent value.  The second\n  /// parameter allows targets to use different numberings for EH info and\n  /// debugging info.\n  int getDwarfRegNum(MCRegister RegNum, bool isEH) const;\n\n  /// Map a dwarf register back to a target register. Returns None is there is\n  /// no mapping.\n  Optional<unsigned> getLLVMRegNum(unsigned RegNum, bool isEH) const;\n\n  /// Map a target EH register number to an equivalent DWARF register\n  /// number.\n  int getDwarfRegNumFromDwarfEHRegNum(unsigned RegNum) const;\n\n  /// Map a target register to an equivalent SEH register\n  /// number.  Returns LLVM register number if there is no equivalent value.\n  int getSEHRegNum(MCRegister RegNum) const;\n\n  /// Map a target register to an equivalent CodeView register\n  /// number.\n  int getCodeViewRegNum(MCRegister RegNum) const;\n\n  regclass_iterator regclass_begin() const { return Classes; }\n  regclass_iterator regclass_end() const { return Classes+NumClasses; }\n  iterator_range<regclass_iterator> regclasses() const {\n    return make_range(regclass_begin(), regclass_end());\n  }\n\n  unsigned getNumRegClasses() const {\n    return (unsigned)(regclass_end()-regclass_begin());\n  }\n\n  /// Returns the register class associated with the enumeration\n  /// value.  See class MCOperandInfo.\n  const MCRegisterClass& getRegClass(unsigned i) const {\n    assert(i < getNumRegClasses() && \"Register Class ID out of range\");\n    return Classes[i];\n  }\n\n  const char *getRegClassName(const MCRegisterClass *Class) const {\n    return RegClassStrings + Class->NameIdx;\n  }\n\n   /// Returns the encoding for RegNo\n  uint16_t getEncodingValue(MCRegister RegNo) const {\n    assert(RegNo < NumRegs &&\n           \"Attempting to get encoding for invalid register number!\");\n    return RegEncodingTable[RegNo];\n  }\n\n  /// Returns true if RegB is a sub-register of RegA.\n  bool isSubRegister(MCRegister RegA, MCRegister RegB) const {\n    return isSuperRegister(RegB, RegA);\n  }\n\n  /// Returns true if RegB is a super-register of RegA.\n  bool isSuperRegister(MCRegister RegA, MCRegister RegB) const;\n\n  /// Returns true if RegB is a sub-register of RegA or if RegB == RegA.\n  bool isSubRegisterEq(MCRegister RegA, MCRegister RegB) const {\n    return isSuperRegisterEq(RegB, RegA);\n  }\n\n  /// Returns true if RegB is a super-register of RegA or if\n  /// RegB == RegA.\n  bool isSuperRegisterEq(MCRegister RegA, MCRegister RegB) const {\n    return RegA == RegB || isSuperRegister(RegA, RegB);\n  }\n\n  /// Returns true if RegB is a super-register or sub-register of RegA\n  /// or if RegB == RegA.\n  bool isSuperOrSubRegisterEq(MCRegister RegA, MCRegister RegB) const {\n    return isSubRegisterEq(RegA, RegB) || isSuperRegister(RegA, RegB);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                          Register List Iterators\n//===----------------------------------------------------------------------===//\n\n// MCRegisterInfo provides lists of super-registers, sub-registers, and\n// aliasing registers. Use these iterator classes to traverse the lists.\n\n/// MCSubRegIterator enumerates all sub-registers of Reg.\n/// If IncludeSelf is set, Reg itself is included in the list.\nclass MCSubRegIterator : public MCRegisterInfo::DiffListIterator {\npublic:\n  MCSubRegIterator(MCRegister Reg, const MCRegisterInfo *MCRI,\n                   bool IncludeSelf = false) {\n    init(Reg, MCRI->DiffLists + MCRI->get(Reg).SubRegs);\n    // Initially, the iterator points to Reg itself.\n    if (!IncludeSelf)\n      ++*this;\n  }\n};\n\n/// Iterator that enumerates the sub-registers of a Reg and the associated\n/// sub-register indices.\nclass MCSubRegIndexIterator {\n  MCSubRegIterator SRIter;\n  const uint16_t *SRIndex;\n\npublic:\n  /// Constructs an iterator that traverses subregisters and their\n  /// associated subregister indices.\n  MCSubRegIndexIterator(MCRegister Reg, const MCRegisterInfo *MCRI)\n    : SRIter(Reg, MCRI) {\n    SRIndex = MCRI->SubRegIndices + MCRI->get(Reg).SubRegIndices;\n  }\n\n  /// Returns current sub-register.\n  MCRegister getSubReg() const {\n    return *SRIter;\n  }\n\n  /// Returns sub-register index of the current sub-register.\n  unsigned getSubRegIndex() const {\n    return *SRIndex;\n  }\n\n  /// Returns true if this iterator is not yet at the end.\n  bool isValid() const { return SRIter.isValid(); }\n\n  /// Moves to the next position.\n  void operator++() {\n    ++SRIter;\n    ++SRIndex;\n  }\n};\n\n/// MCSuperRegIterator enumerates all super-registers of Reg.\n/// If IncludeSelf is set, Reg itself is included in the list.\nclass MCSuperRegIterator : public MCRegisterInfo::DiffListIterator {\npublic:\n  MCSuperRegIterator() = default;\n\n  MCSuperRegIterator(MCRegister Reg, const MCRegisterInfo *MCRI,\n                     bool IncludeSelf = false) {\n    init(Reg, MCRI->DiffLists + MCRI->get(Reg).SuperRegs);\n    // Initially, the iterator points to Reg itself.\n    if (!IncludeSelf)\n      ++*this;\n  }\n};\n\n// Definition for isSuperRegister. Put it down here since it needs the\n// iterator defined above in addition to the MCRegisterInfo class itself.\ninline bool MCRegisterInfo::isSuperRegister(MCRegister RegA, MCRegister RegB) const{\n  for (MCSuperRegIterator I(RegA, this); I.isValid(); ++I)\n    if (*I == RegB)\n      return true;\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n//                               Register Units\n//===----------------------------------------------------------------------===//\n\n// Register units are used to compute register aliasing. Every register has at\n// least one register unit, but it can have more. Two registers overlap if and\n// only if they have a common register unit.\n//\n// A target with a complicated sub-register structure will typically have many\n// fewer register units than actual registers. MCRI::getNumRegUnits() returns\n// the number of register units in the target.\n\n// MCRegUnitIterator enumerates a list of register units for Reg. The list is\n// in ascending numerical order.\nclass MCRegUnitIterator : public MCRegisterInfo::DiffListIterator {\npublic:\n  /// MCRegUnitIterator - Create an iterator that traverses the register units\n  /// in Reg.\n  MCRegUnitIterator() = default;\n\n  MCRegUnitIterator(MCRegister Reg, const MCRegisterInfo *MCRI) {\n    assert(Reg && \"Null register has no regunits\");\n    assert(MCRegister::isPhysicalRegister(Reg.id()));\n    // Decode the RegUnits MCRegisterDesc field.\n    unsigned RU = MCRI->get(Reg).RegUnits;\n    unsigned Scale = RU & 15;\n    unsigned Offset = RU >> 4;\n\n    // Initialize the iterator to Reg * Scale, and the List pointer to\n    // DiffLists + Offset.\n    init(Reg * Scale, MCRI->DiffLists + Offset);\n\n    // That may not be a valid unit, we need to advance by one to get the real\n    // unit number. The first differential can be 0 which would normally\n    // terminate the list, but since we know every register has at least one\n    // unit, we can allow a 0 differential here.\n    advance();\n  }\n};\n\n/// MCRegUnitMaskIterator enumerates a list of register units and their\n/// associated lane masks for Reg. The register units are in ascending\n/// numerical order.\nclass MCRegUnitMaskIterator {\n  MCRegUnitIterator RUIter;\n  const LaneBitmask *MaskListIter;\n\npublic:\n  MCRegUnitMaskIterator() = default;\n\n  /// Constructs an iterator that traverses the register units and their\n  /// associated LaneMasks in Reg.\n  MCRegUnitMaskIterator(MCRegister Reg, const MCRegisterInfo *MCRI)\n    : RUIter(Reg, MCRI) {\n      uint16_t Idx = MCRI->get(Reg).RegUnitLaneMasks;\n      MaskListIter = &MCRI->RegUnitMaskSequences[Idx];\n  }\n\n  /// Returns a (RegUnit, LaneMask) pair.\n  std::pair<unsigned,LaneBitmask> operator*() const {\n    return std::make_pair(*RUIter, *MaskListIter);\n  }\n\n  /// Returns true if this iterator is not yet at the end.\n  bool isValid() const { return RUIter.isValid(); }\n\n  /// Moves to the next position.\n  void operator++() {\n    ++MaskListIter;\n    ++RUIter;\n  }\n};\n\n// Each register unit has one or two root registers. The complete set of\n// registers containing a register unit is the union of the roots and their\n// super-registers. All registers aliasing Unit can be visited like this:\n//\n//   for (MCRegUnitRootIterator RI(Unit, MCRI); RI.isValid(); ++RI) {\n//     for (MCSuperRegIterator SI(*RI, MCRI, true); SI.isValid(); ++SI)\n//       visit(*SI);\n//    }\n\n/// MCRegUnitRootIterator enumerates the root registers of a register unit.\nclass MCRegUnitRootIterator {\n  uint16_t Reg0 = 0;\n  uint16_t Reg1 = 0;\n\npublic:\n  MCRegUnitRootIterator() = default;\n\n  MCRegUnitRootIterator(unsigned RegUnit, const MCRegisterInfo *MCRI) {\n    assert(RegUnit < MCRI->getNumRegUnits() && \"Invalid register unit\");\n    Reg0 = MCRI->RegUnitRoots[RegUnit][0];\n    Reg1 = MCRI->RegUnitRoots[RegUnit][1];\n  }\n\n  /// Dereference to get the current root register.\n  unsigned operator*() const {\n    return Reg0;\n  }\n\n  /// Check if the iterator is at the end of the list.\n  bool isValid() const {\n    return Reg0;\n  }\n\n  /// Preincrement to move to the next root register.\n  void operator++() {\n    assert(isValid() && \"Cannot move off the end of the list.\");\n    Reg0 = Reg1;\n    Reg1 = 0;\n  }\n};\n\n/// MCRegAliasIterator enumerates all registers aliasing Reg.  If IncludeSelf is\n/// set, Reg itself is included in the list.  This iterator does not guarantee\n/// any ordering or that entries are unique.\nclass MCRegAliasIterator {\nprivate:\n  MCRegister Reg;\n  const MCRegisterInfo *MCRI;\n  bool IncludeSelf;\n\n  MCRegUnitIterator RI;\n  MCRegUnitRootIterator RRI;\n  MCSuperRegIterator SI;\n\npublic:\n  MCRegAliasIterator(MCRegister Reg, const MCRegisterInfo *MCRI,\n                     bool IncludeSelf)\n    : Reg(Reg), MCRI(MCRI), IncludeSelf(IncludeSelf) {\n    // Initialize the iterators.\n    for (RI = MCRegUnitIterator(Reg, MCRI); RI.isValid(); ++RI) {\n      for (RRI = MCRegUnitRootIterator(*RI, MCRI); RRI.isValid(); ++RRI) {\n        for (SI = MCSuperRegIterator(*RRI, MCRI, true); SI.isValid(); ++SI) {\n          if (!(!IncludeSelf && Reg == *SI))\n            return;\n        }\n      }\n    }\n  }\n\n  bool isValid() const { return RI.isValid(); }\n\n  MCRegister operator*() const {\n    assert(SI.isValid() && \"Cannot dereference an invalid iterator.\");\n    return *SI;\n  }\n\n  void advance() {\n    // Assuming SI is valid.\n    ++SI;\n    if (SI.isValid()) return;\n\n    ++RRI;\n    if (RRI.isValid()) {\n      SI = MCSuperRegIterator(*RRI, MCRI, true);\n      return;\n    }\n\n    ++RI;\n    if (RI.isValid()) {\n      RRI = MCRegUnitRootIterator(*RI, MCRI);\n      SI = MCSuperRegIterator(*RRI, MCRI, true);\n    }\n  }\n\n  void operator++() {\n    assert(isValid() && \"Cannot move off the end of the list.\");\n    do advance();\n    while (!IncludeSelf && isValid() && *SI == Reg);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_MC_MCREGISTERINFO_H\n"}, "62": {"id": 62, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCSchedule.h", "content": "//===-- llvm/MC/MCSchedule.h - Scheduling -----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the classes used to describe a subtarget's machine model\n// for scheduling and other instruction cost heuristics.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_MC_MCSCHEDULE_H\n#define LLVM_MC_MCSCHEDULE_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include <cassert>\n\nnamespace llvm {\n\ntemplate <typename T> class ArrayRef;\nstruct InstrItinerary;\nclass MCSubtargetInfo;\nclass MCInstrInfo;\nclass MCInst;\nclass InstrItineraryData;\n\n/// Define a kind of processor resource that will be modeled by the scheduler.\nstruct MCProcResourceDesc {\n  const char *Name;\n  unsigned NumUnits; // Number of resource of this kind\n  unsigned SuperIdx; // Index of the resources kind that contains this kind.\n\n  // Number of resources that may be buffered.\n  //\n  // Buffered resources (BufferSize != 0) may be consumed at some indeterminate\n  // cycle after dispatch. This should be used for out-of-order cpus when\n  // instructions that use this resource can be buffered in a reservaton\n  // station.\n  //\n  // Unbuffered resources (BufferSize == 0) always consume their resource some\n  // fixed number of cycles after dispatch. If a resource is unbuffered, then\n  // the scheduler will avoid scheduling instructions with conflicting resources\n  // in the same cycle. This is for in-order cpus, or the in-order portion of\n  // an out-of-order cpus.\n  int BufferSize;\n\n  // If the resource has sub-units, a pointer to the first element of an array\n  // of `NumUnits` elements containing the ProcResourceIdx of the sub units.\n  // nullptr if the resource does not have sub-units.\n  const unsigned *SubUnitsIdxBegin;\n\n  bool operator==(const MCProcResourceDesc &Other) const {\n    return NumUnits == Other.NumUnits && SuperIdx == Other.SuperIdx\n      && BufferSize == Other.BufferSize;\n  }\n};\n\n/// Identify one of the processor resource kinds consumed by a particular\n/// scheduling class for the specified number of cycles.\nstruct MCWriteProcResEntry {\n  uint16_t ProcResourceIdx;\n  uint16_t Cycles;\n\n  bool operator==(const MCWriteProcResEntry &Other) const {\n    return ProcResourceIdx == Other.ProcResourceIdx && Cycles == Other.Cycles;\n  }\n};\n\n/// Specify the latency in cpu cycles for a particular scheduling class and def\n/// index. -1 indicates an invalid latency. Heuristics would typically consider\n/// an instruction with invalid latency to have infinite latency.  Also identify\n/// the WriteResources of this def. When the operand expands to a sequence of\n/// writes, this ID is the last write in the sequence.\nstruct MCWriteLatencyEntry {\n  int16_t Cycles;\n  uint16_t WriteResourceID;\n\n  bool operator==(const MCWriteLatencyEntry &Other) const {\n    return Cycles == Other.Cycles && WriteResourceID == Other.WriteResourceID;\n  }\n};\n\n/// Specify the number of cycles allowed after instruction issue before a\n/// particular use operand reads its registers. This effectively reduces the\n/// write's latency. Here we allow negative cycles for corner cases where\n/// latency increases. This rule only applies when the entry's WriteResource\n/// matches the write's WriteResource.\n///\n/// MCReadAdvanceEntries are sorted first by operand index (UseIdx), then by\n/// WriteResourceIdx.\nstruct MCReadAdvanceEntry {\n  unsigned UseIdx;\n  unsigned WriteResourceID;\n  int Cycles;\n\n  bool operator==(const MCReadAdvanceEntry &Other) const {\n    return UseIdx == Other.UseIdx && WriteResourceID == Other.WriteResourceID\n      && Cycles == Other.Cycles;\n  }\n};\n\n/// Summarize the scheduling resources required for an instruction of a\n/// particular scheduling class.\n///\n/// Defined as an aggregate struct for creating tables with initializer lists.\nstruct MCSchedClassDesc {\n  static const unsigned short InvalidNumMicroOps = (1U << 13) - 1;\n  static const unsigned short VariantNumMicroOps = InvalidNumMicroOps - 1;\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  const char* Name;\n#endif\n  uint16_t NumMicroOps : 13;\n  uint16_t BeginGroup : 1;\n  uint16_t EndGroup : 1;\n  uint16_t RetireOOO : 1;\n  uint16_t WriteProcResIdx; // First index into WriteProcResTable.\n  uint16_t NumWriteProcResEntries;\n  uint16_t WriteLatencyIdx; // First index into WriteLatencyTable.\n  uint16_t NumWriteLatencyEntries;\n  uint16_t ReadAdvanceIdx; // First index into ReadAdvanceTable.\n  uint16_t NumReadAdvanceEntries;\n\n  bool isValid() const {\n    return NumMicroOps != InvalidNumMicroOps;\n  }\n  bool isVariant() const {\n    return NumMicroOps == VariantNumMicroOps;\n  }\n};\n\n/// Specify the cost of a register definition in terms of number of physical\n/// register allocated at register renaming stage. For example, AMD Jaguar.\n/// natively supports 128-bit data types, and operations on 256-bit registers\n/// (i.e. YMM registers) are internally split into two COPs (complex operations)\n/// and each COP updates a physical register. Basically, on Jaguar, a YMM\n/// register write effectively consumes two physical registers. That means,\n/// the cost of a YMM write in the BtVer2 model is 2.\nstruct MCRegisterCostEntry {\n  unsigned RegisterClassID;\n  unsigned Cost;\n  bool AllowMoveElimination;\n};\n\n/// A register file descriptor.\n///\n/// This struct allows to describe processor register files. In particular, it\n/// helps describing the size of the register file, as well as the cost of\n/// allocating a register file at register renaming stage.\n/// FIXME: this struct can be extended to provide information about the number\n/// of read/write ports to the register file.  A value of zero for field\n/// 'NumPhysRegs' means: this register file has an unbounded number of physical\n/// registers.\nstruct MCRegisterFileDesc {\n  const char *Name;\n  uint16_t NumPhysRegs;\n  uint16_t NumRegisterCostEntries;\n  // Index of the first cost entry in MCExtraProcessorInfo::RegisterCostTable.\n  uint16_t RegisterCostEntryIdx;\n  // A value of zero means: there is no limit in the number of moves that can be\n  // eliminated every cycle.\n  uint16_t MaxMovesEliminatedPerCycle;\n  // Ture if this register file only knows how to optimize register moves from\n  // known zero registers.\n  bool AllowZeroMoveEliminationOnly;\n};\n\n/// Provide extra details about the machine processor.\n///\n/// This is a collection of \"optional\" processor information that is not\n/// normally used by the LLVM machine schedulers, but that can be consumed by\n/// external tools like llvm-mca to improve the quality of the peformance\n/// analysis.\nstruct MCExtraProcessorInfo {\n  // Actual size of the reorder buffer in hardware.\n  unsigned ReorderBufferSize;\n  // Number of instructions retired per cycle.\n  unsigned MaxRetirePerCycle;\n  const MCRegisterFileDesc *RegisterFiles;\n  unsigned NumRegisterFiles;\n  const MCRegisterCostEntry *RegisterCostTable;\n  unsigned NumRegisterCostEntries;\n  unsigned LoadQueueID;\n  unsigned StoreQueueID;\n};\n\n/// Machine model for scheduling, bundling, and heuristics.\n///\n/// The machine model directly provides basic information about the\n/// microarchitecture to the scheduler in the form of properties. It also\n/// optionally refers to scheduler resource tables and itinerary\n/// tables. Scheduler resource tables model the latency and cost for each\n/// instruction type. Itinerary tables are an independent mechanism that\n/// provides a detailed reservation table describing each cycle of instruction\n/// execution. Subtargets may define any or all of the above categories of data\n/// depending on the type of CPU and selected scheduler.\n///\n/// The machine independent properties defined here are used by the scheduler as\n/// an abstract machine model. A real micro-architecture has a number of\n/// buffers, queues, and stages. Declaring that a given machine-independent\n/// abstract property corresponds to a specific physical property across all\n/// subtargets can't be done. Nonetheless, the abstract model is\n/// useful. Futhermore, subtargets typically extend this model with processor\n/// specific resources to model any hardware features that can be exploited by\n/// scheduling heuristics and aren't sufficiently represented in the abstract.\n///\n/// The abstract pipeline is built around the notion of an \"issue point\". This\n/// is merely a reference point for counting machine cycles. The physical\n/// machine will have pipeline stages that delay execution. The scheduler does\n/// not model those delays because they are irrelevant as long as they are\n/// consistent. Inaccuracies arise when instructions have different execution\n/// delays relative to each other, in addition to their intrinsic latency. Those\n/// special cases can be handled by TableGen constructs such as, ReadAdvance,\n/// which reduces latency when reading data, and ResourceCycles, which consumes\n/// a processor resource when writing data for a number of abstract\n/// cycles.\n///\n/// TODO: One tool currently missing is the ability to add a delay to\n/// ResourceCycles. That would be easy to add and would likely cover all cases\n/// currently handled by the legacy itinerary tables.\n///\n/// A note on out-of-order execution and, more generally, instruction\n/// buffers. Part of the CPU pipeline is always in-order. The issue point, which\n/// is the point of reference for counting cycles, only makes sense as an\n/// in-order part of the pipeline. Other parts of the pipeline are sometimes\n/// falling behind and sometimes catching up. It's only interesting to model\n/// those other, decoupled parts of the pipeline if they may be predictably\n/// resource constrained in a way that the scheduler can exploit.\n///\n/// The LLVM machine model distinguishes between in-order constraints and\n/// out-of-order constraints so that the target's scheduling strategy can apply\n/// appropriate heuristics. For a well-balanced CPU pipeline, out-of-order\n/// resources would not typically be treated as a hard scheduling\n/// constraint. For example, in the GenericScheduler, a delay caused by limited\n/// out-of-order resources is not directly reflected in the number of cycles\n/// that the scheduler sees between issuing an instruction and its dependent\n/// instructions. In other words, out-of-order resources don't directly increase\n/// the latency between pairs of instructions. However, they can still be used\n/// to detect potential bottlenecks across a sequence of instructions and bias\n/// the scheduling heuristics appropriately.\nstruct MCSchedModel {\n  // IssueWidth is the maximum number of instructions that may be scheduled in\n  // the same per-cycle group. This is meant to be a hard in-order constraint\n  // (a.k.a. \"hazard\"). In the GenericScheduler strategy, no more than\n  // IssueWidth micro-ops can ever be scheduled in a particular cycle.\n  //\n  // In practice, IssueWidth is useful to model any bottleneck between the\n  // decoder (after micro-op expansion) and the out-of-order reservation\n  // stations or the decoder bandwidth itself. If the total number of\n  // reservation stations is also a bottleneck, or if any other pipeline stage\n  // has a bandwidth limitation, then that can be naturally modeled by adding an\n  // out-of-order processor resource.\n  unsigned IssueWidth;\n  static const unsigned DefaultIssueWidth = 1;\n\n  // MicroOpBufferSize is the number of micro-ops that the processor may buffer\n  // for out-of-order execution.\n  //\n  // \"0\" means operations that are not ready in this cycle are not considered\n  // for scheduling (they go in the pending queue). Latency is paramount. This\n  // may be more efficient if many instructions are pending in a schedule.\n  //\n  // \"1\" means all instructions are considered for scheduling regardless of\n  // whether they are ready in this cycle. Latency still causes issue stalls,\n  // but we balance those stalls against other heuristics.\n  //\n  // \"> 1\" means the processor is out-of-order. This is a machine independent\n  // estimate of highly machine specific characteristics such as the register\n  // renaming pool and reorder buffer.\n  unsigned MicroOpBufferSize;\n  static const unsigned DefaultMicroOpBufferSize = 0;\n\n  // LoopMicroOpBufferSize is the number of micro-ops that the processor may\n  // buffer for optimized loop execution. More generally, this represents the\n  // optimal number of micro-ops in a loop body. A loop may be partially\n  // unrolled to bring the count of micro-ops in the loop body closer to this\n  // number.\n  unsigned LoopMicroOpBufferSize;\n  static const unsigned DefaultLoopMicroOpBufferSize = 0;\n\n  // LoadLatency is the expected latency of load instructions.\n  unsigned LoadLatency;\n  static const unsigned DefaultLoadLatency = 4;\n\n  // HighLatency is the expected latency of \"very high latency\" operations.\n  // See TargetInstrInfo::isHighLatencyDef().\n  // By default, this is set to an arbitrarily high number of cycles\n  // likely to have some impact on scheduling heuristics.\n  unsigned HighLatency;\n  static const unsigned DefaultHighLatency = 10;\n\n  // MispredictPenalty is the typical number of extra cycles the processor\n  // takes to recover from a branch misprediction.\n  unsigned MispredictPenalty;\n  static const unsigned DefaultMispredictPenalty = 10;\n\n  bool PostRAScheduler; // default value is false\n\n  bool CompleteModel;\n\n  unsigned ProcID;\n  const MCProcResourceDesc *ProcResourceTable;\n  const MCSchedClassDesc *SchedClassTable;\n  unsigned NumProcResourceKinds;\n  unsigned NumSchedClasses;\n  // Instruction itinerary tables used by InstrItineraryData.\n  friend class InstrItineraryData;\n  const InstrItinerary *InstrItineraries;\n\n  const MCExtraProcessorInfo *ExtraProcessorInfo;\n\n  bool hasExtraProcessorInfo() const { return ExtraProcessorInfo; }\n\n  unsigned getProcessorID() const { return ProcID; }\n\n  /// Does this machine model include instruction-level scheduling.\n  bool hasInstrSchedModel() const { return SchedClassTable; }\n\n  const MCExtraProcessorInfo &getExtraProcessorInfo() const {\n    assert(hasExtraProcessorInfo() &&\n           \"No extra information available for this model\");\n    return *ExtraProcessorInfo;\n  }\n\n  /// Return true if this machine model data for all instructions with a\n  /// scheduling class (itinerary class or SchedRW list).\n  bool isComplete() const { return CompleteModel; }\n\n  /// Return true if machine supports out of order execution.\n  bool isOutOfOrder() const { return MicroOpBufferSize > 1; }\n\n  unsigned getNumProcResourceKinds() const {\n    return NumProcResourceKinds;\n  }\n\n  const MCProcResourceDesc *getProcResource(unsigned ProcResourceIdx) const {\n    assert(hasInstrSchedModel() && \"No scheduling machine model\");\n\n    assert(ProcResourceIdx < NumProcResourceKinds && \"bad proc resource idx\");\n    return &ProcResourceTable[ProcResourceIdx];\n  }\n\n  const MCSchedClassDesc *getSchedClassDesc(unsigned SchedClassIdx) const {\n    assert(hasInstrSchedModel() && \"No scheduling machine model\");\n\n    assert(SchedClassIdx < NumSchedClasses && \"bad scheduling class idx\");\n    return &SchedClassTable[SchedClassIdx];\n  }\n\n  /// Returns the latency value for the scheduling class.\n  static int computeInstrLatency(const MCSubtargetInfo &STI,\n                                 const MCSchedClassDesc &SCDesc);\n\n  int computeInstrLatency(const MCSubtargetInfo &STI, unsigned SClass) const;\n  int computeInstrLatency(const MCSubtargetInfo &STI, const MCInstrInfo &MCII,\n                          const MCInst &Inst) const;\n\n  // Returns the reciprocal throughput information from a MCSchedClassDesc.\n  static double\n  getReciprocalThroughput(const MCSubtargetInfo &STI,\n                          const MCSchedClassDesc &SCDesc);\n\n  static double\n  getReciprocalThroughput(unsigned SchedClass, const InstrItineraryData &IID);\n\n  double\n  getReciprocalThroughput(const MCSubtargetInfo &STI, const MCInstrInfo &MCII,\n                          const MCInst &Inst) const;\n\n  /// Returns the maximum forwarding delay for register reads dependent on\n  /// writes of scheduling class WriteResourceIdx.\n  static unsigned getForwardingDelayCycles(ArrayRef<MCReadAdvanceEntry> Entries,\n                                           unsigned WriteResourceIdx = 0);\n\n  /// Returns the default initialized model.\n  static const MCSchedModel &GetDefaultSchedModel() { return Default; }\n  static const MCSchedModel Default;\n};\n\n} // namespace llvm\n\n#endif\n"}, "65": {"id": 65, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Pass.h", "content": "//===- llvm/Pass.h - Base class for Passes ----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a base class that indicates that a specified class is a\n// transformation pass implementation.\n//\n// Passes are designed this way so that it is possible to run passes in a cache\n// and organizationally optimal order without having to specify it at the front\n// end.  This allows arbitrary passes to be strung together and have them\n// executed as efficiently as possible.\n//\n// Passes should extend one of the classes below, depending on the guarantees\n// that it can make about what will be modified as it is run.  For example, most\n// global optimizations should derive from FunctionPass, because they do not add\n// or delete functions, they operate on the internals of the function.\n//\n// Note that this file #includes PassSupport.h and PassAnalysisSupport.h (at the\n// bottom), so the APIs exposed by these files are also automatically available\n// to all users of this file.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_PASS_H\n#define LLVM_PASS_H\n\n#include <string>\n\nnamespace llvm {\n\nclass AnalysisResolver;\nclass AnalysisUsage;\nclass Function;\nclass ImmutablePass;\nclass Module;\nclass PassInfo;\nclass PMDataManager;\nclass PMStack;\nclass raw_ostream;\nclass StringRef;\n\n// AnalysisID - Use the PassInfo to identify a pass...\nusing AnalysisID = const void *;\n\n/// Different types of internal pass managers. External pass managers\n/// (PassManager and FunctionPassManager) are not represented here.\n/// Ordering of pass manager types is important here.\nenum PassManagerType {\n  PMT_Unknown = 0,\n  PMT_ModulePassManager = 1, ///< MPPassManager\n  PMT_CallGraphPassManager,  ///< CGPassManager\n  PMT_FunctionPassManager,   ///< FPPassManager\n  PMT_LoopPassManager,       ///< LPPassManager\n  PMT_RegionPassManager,     ///< RGPassManager\n  PMT_Last\n};\n\n// Different types of passes.\nenum PassKind {\n  PT_Region,\n  PT_Loop,\n  PT_Function,\n  PT_CallGraphSCC,\n  PT_Module,\n  PT_PassManager\n};\n\n/// This enumerates the LLVM full LTO or ThinLTO optimization phases.\nenum class ThinOrFullLTOPhase {\n  /// No LTO/ThinLTO behavior needed.\n  None,\n  /// ThinLTO prelink (summary) phase.\n  ThinLTOPreLink,\n  /// ThinLTO postlink (backend compile) phase.\n  ThinLTOPostLink,\n  /// Full LTO prelink phase.\n  FullLTOPreLink,\n  /// Full LTO postlink (backend compile) phase.\n  FullLTOPostLink\n};\n\n//===----------------------------------------------------------------------===//\n/// Pass interface - Implemented by all 'passes'.  Subclass this if you are an\n/// interprocedural optimization or you do not fit into any of the more\n/// constrained passes described below.\n///\nclass Pass {\n  AnalysisResolver *Resolver = nullptr;  // Used to resolve analysis\n  const void *PassID;\n  PassKind Kind;\n\npublic:\n  explicit Pass(PassKind K, char &pid) : PassID(&pid), Kind(K) {}\n  Pass(const Pass &) = delete;\n  Pass &operator=(const Pass &) = delete;\n  virtual ~Pass();\n\n  PassKind getPassKind() const { return Kind; }\n\n  /// getPassName - Return a nice clean name for a pass.  This usually\n  /// implemented in terms of the name that is registered by one of the\n  /// Registration templates, but can be overloaded directly.\n  virtual StringRef getPassName() const;\n\n  /// getPassID - Return the PassID number that corresponds to this pass.\n  AnalysisID getPassID() const {\n    return PassID;\n  }\n\n  /// doInitialization - Virtual method overridden by subclasses to do\n  /// any necessary initialization before any pass is run.\n  virtual bool doInitialization(Module &)  { return false; }\n\n  /// doFinalization - Virtual method overriden by subclasses to do any\n  /// necessary clean up after all passes have run.\n  virtual bool doFinalization(Module &) { return false; }\n\n  /// print - Print out the internal state of the pass.  This is called by\n  /// Analyze to print out the contents of an analysis.  Otherwise it is not\n  /// necessary to implement this method.  Beware that the module pointer MAY be\n  /// null.  This automatically forwards to a virtual function that does not\n  /// provide the Module* in case the analysis doesn't need it it can just be\n  /// ignored.\n  virtual void print(raw_ostream &OS, const Module *M) const;\n\n  void dump() const; // dump - Print to stderr.\n\n  /// createPrinterPass - Get a Pass appropriate to print the IR this\n  /// pass operates on (Module, Function or MachineFunction).\n  virtual Pass *createPrinterPass(raw_ostream &OS,\n                                  const std::string &Banner) const = 0;\n\n  /// Each pass is responsible for assigning a pass manager to itself.\n  /// PMS is the stack of available pass manager.\n  virtual void assignPassManager(PMStack &,\n                                 PassManagerType) {}\n\n  /// Check if available pass managers are suitable for this pass or not.\n  virtual void preparePassManager(PMStack &);\n\n  ///  Return what kind of Pass Manager can manage this pass.\n  virtual PassManagerType getPotentialPassManagerType() const;\n\n  // Access AnalysisResolver\n  void setResolver(AnalysisResolver *AR);\n  AnalysisResolver *getResolver() const { return Resolver; }\n\n  /// getAnalysisUsage - This function should be overriden by passes that need\n  /// analysis information to do their job.  If a pass specifies that it uses a\n  /// particular analysis result to this function, it can then use the\n  /// getAnalysis<AnalysisType>() function, below.\n  virtual void getAnalysisUsage(AnalysisUsage &) const;\n\n  /// releaseMemory() - This member can be implemented by a pass if it wants to\n  /// be able to release its memory when it is no longer needed.  The default\n  /// behavior of passes is to hold onto memory for the entire duration of their\n  /// lifetime (which is the entire compile time).  For pipelined passes, this\n  /// is not a big deal because that memory gets recycled every time the pass is\n  /// invoked on another program unit.  For IP passes, it is more important to\n  /// free memory when it is unused.\n  ///\n  /// Optionally implement this function to release pass memory when it is no\n  /// longer used.\n  virtual void releaseMemory();\n\n  /// getAdjustedAnalysisPointer - This method is used when a pass implements\n  /// an analysis interface through multiple inheritance.  If needed, it should\n  /// override this to adjust the this pointer as needed for the specified pass\n  /// info.\n  virtual void *getAdjustedAnalysisPointer(AnalysisID ID);\n  virtual ImmutablePass *getAsImmutablePass();\n  virtual PMDataManager *getAsPMDataManager();\n\n  /// verifyAnalysis() - This member can be implemented by a analysis pass to\n  /// check state of analysis information.\n  virtual void verifyAnalysis() const;\n\n  // dumpPassStructure - Implement the -debug-passes=PassStructure option\n  virtual void dumpPassStructure(unsigned Offset = 0);\n\n  // lookupPassInfo - Return the pass info object for the specified pass class,\n  // or null if it is not known.\n  static const PassInfo *lookupPassInfo(const void *TI);\n\n  // lookupPassInfo - Return the pass info object for the pass with the given\n  // argument string, or null if it is not known.\n  static const PassInfo *lookupPassInfo(StringRef Arg);\n\n  // createPass - Create a object for the specified pass class,\n  // or null if it is not known.\n  static Pass *createPass(AnalysisID ID);\n\n  /// getAnalysisIfAvailable<AnalysisType>() - Subclasses use this function to\n  /// get analysis information that might be around, for example to update it.\n  /// This is different than getAnalysis in that it can fail (if the analysis\n  /// results haven't been computed), so should only be used if you can handle\n  /// the case when the analysis is not available.  This method is often used by\n  /// transformation APIs to update analysis results for a pass automatically as\n  /// the transform is performed.\n  template<typename AnalysisType> AnalysisType *\n    getAnalysisIfAvailable() const; // Defined in PassAnalysisSupport.h\n\n  /// mustPreserveAnalysisID - This method serves the same function as\n  /// getAnalysisIfAvailable, but works if you just have an AnalysisID.  This\n  /// obviously cannot give you a properly typed instance of the class if you\n  /// don't have the class name available (use getAnalysisIfAvailable if you\n  /// do), but it can tell you if you need to preserve the pass at least.\n  bool mustPreserveAnalysisID(char &AID) const;\n\n  /// getAnalysis<AnalysisType>() - This function is used by subclasses to get\n  /// to the analysis information that they claim to use by overriding the\n  /// getAnalysisUsage function.\n  template<typename AnalysisType>\n  AnalysisType &getAnalysis() const; // Defined in PassAnalysisSupport.h\n\n  template <typename AnalysisType>\n  AnalysisType &\n  getAnalysis(Function &F,\n              bool *Changed = nullptr); // Defined in PassAnalysisSupport.h\n\n  template<typename AnalysisType>\n  AnalysisType &getAnalysisID(AnalysisID PI) const;\n\n  template <typename AnalysisType>\n  AnalysisType &getAnalysisID(AnalysisID PI, Function &F,\n                              bool *Changed = nullptr);\n};\n\n//===----------------------------------------------------------------------===//\n/// ModulePass class - This class is used to implement unstructured\n/// interprocedural optimizations and analyses.  ModulePasses may do anything\n/// they want to the program.\n///\nclass ModulePass : public Pass {\npublic:\n  explicit ModulePass(char &pid) : Pass(PT_Module, pid) {}\n\n  // Force out-of-line virtual method.\n  ~ModulePass() override;\n\n  /// createPrinterPass - Get a module printer pass.\n  Pass *createPrinterPass(raw_ostream &OS,\n                          const std::string &Banner) const override;\n\n  /// runOnModule - Virtual method overriden by subclasses to process the module\n  /// being operated on.\n  virtual bool runOnModule(Module &M) = 0;\n\n  void assignPassManager(PMStack &PMS, PassManagerType T) override;\n\n  ///  Return what kind of Pass Manager can manage this pass.\n  PassManagerType getPotentialPassManagerType() const override;\n\nprotected:\n  /// Optional passes call this function to check whether the pass should be\n  /// skipped. This is the case when optimization bisect is over the limit.\n  bool skipModule(Module &M) const;\n};\n\n//===----------------------------------------------------------------------===//\n/// ImmutablePass class - This class is used to provide information that does\n/// not need to be run.  This is useful for things like target information and\n/// \"basic\" versions of AnalysisGroups.\n///\nclass ImmutablePass : public ModulePass {\npublic:\n  explicit ImmutablePass(char &pid) : ModulePass(pid) {}\n\n  // Force out-of-line virtual method.\n  ~ImmutablePass() override;\n\n  /// initializePass - This method may be overriden by immutable passes to allow\n  /// them to perform various initialization actions they require.  This is\n  /// primarily because an ImmutablePass can \"require\" another ImmutablePass,\n  /// and if it does, the overloaded version of initializePass may get access to\n  /// these passes with getAnalysis<>.\n  virtual void initializePass();\n\n  ImmutablePass *getAsImmutablePass() override { return this; }\n\n  /// ImmutablePasses are never run.\n  bool runOnModule(Module &) override { return false; }\n};\n\n//===----------------------------------------------------------------------===//\n/// FunctionPass class - This class is used to implement most global\n/// optimizations.  Optimizations should subclass this class if they meet the\n/// following constraints:\n///\n///  1. Optimizations are organized globally, i.e., a function at a time\n///  2. Optimizing a function does not cause the addition or removal of any\n///     functions in the module\n///\nclass FunctionPass : public Pass {\npublic:\n  explicit FunctionPass(char &pid) : Pass(PT_Function, pid) {}\n\n  /// createPrinterPass - Get a function printer pass.\n  Pass *createPrinterPass(raw_ostream &OS,\n                          const std::string &Banner) const override;\n\n  /// runOnFunction - Virtual method overriden by subclasses to do the\n  /// per-function processing of the pass.\n  virtual bool runOnFunction(Function &F) = 0;\n\n  void assignPassManager(PMStack &PMS, PassManagerType T) override;\n\n  ///  Return what kind of Pass Manager can manage this pass.\n  PassManagerType getPotentialPassManagerType() const override;\n\nprotected:\n  /// Optional passes call this function to check whether the pass should be\n  /// skipped. This is the case when Attribute::OptimizeNone is set or when\n  /// optimization bisect is over the limit.\n  bool skipFunction(const Function &F) const;\n};\n\n/// If the user specifies the -time-passes argument on an LLVM tool command line\n/// then the value of this boolean will be true, otherwise false.\n/// This is the storage for the -time-passes option.\nextern bool TimePassesIsEnabled;\n/// If TimePassesPerRun is true, there would be one line of report for\n/// each pass invocation.\n/// If TimePassesPerRun is false, there would be only one line of\n/// report for each pass (even there are more than one pass objects).\n/// (For new pass manager only)\nextern bool TimePassesPerRun;\n\n} // end namespace llvm\n\n// Include support files that contain important APIs commonly used by Passes,\n// but that we want to separate out to make it easier to read the header files.\n#include \"llvm/PassAnalysisSupport.h\"\n#include \"llvm/PassSupport.h\"\n\n#endif // LLVM_PASS_H\n"}, "66": {"id": 66, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/PassSupport.h", "content": "//===- llvm/PassSupport.h - Pass Support code -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines stuff that is used to define and \"use\" Passes.  This file\n// is automatically #included by Pass.h, so:\n//\n//           NO .CPP FILES SHOULD INCLUDE THIS FILE DIRECTLY\n//\n// Instead, #include Pass.h.\n//\n// This file defines Pass registration code and classes used for it.\n//\n//===----------------------------------------------------------------------===//\n\n#if !defined(LLVM_PASS_H) || defined(LLVM_PASSSUPPORT_H)\n#error \"Do not include <PassSupport.h>; include <Pass.h> instead\"\n#endif\n\n#ifndef LLVM_PASSSUPPORT_H\n#define LLVM_PASSSUPPORT_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/PassInfo.h\"\n#include \"llvm/PassRegistry.h\"\n#include \"llvm/Support/Threading.h\"\n#include <functional>\n\nnamespace llvm {\n\nclass Pass;\n\n#define INITIALIZE_PASS(passName, arg, name, cfg, analysis)                    \\\n  static void *initialize##passName##PassOnce(PassRegistry &Registry) {        \\\n    PassInfo *PI = new PassInfo(                                               \\\n        name, arg, &passName::ID,                                              \\\n        PassInfo::NormalCtor_t(callDefaultCtor<passName>), cfg, analysis);     \\\n    Registry.registerPass(*PI, true);                                          \\\n    return PI;                                                                 \\\n  }                                                                            \\\n  static llvm::once_flag Initialize##passName##PassFlag;                       \\\n  void llvm::initialize##passName##Pass(PassRegistry &Registry) {              \\\n    llvm::call_once(Initialize##passName##PassFlag,                            \\\n                    initialize##passName##PassOnce, std::ref(Registry));       \\\n  }\n\n#define INITIALIZE_PASS_BEGIN(passName, arg, name, cfg, analysis)              \\\n  static void *initialize##passName##PassOnce(PassRegistry &Registry) {\n\n#define INITIALIZE_PASS_DEPENDENCY(depName) initialize##depName##Pass(Registry);\n#define INITIALIZE_AG_DEPENDENCY(depName)                                      \\\n  initialize##depName##AnalysisGroup(Registry);\n\n#define INITIALIZE_PASS_END(passName, arg, name, cfg, analysis)                \\\n  PassInfo *PI = new PassInfo(                                                 \\\n      name, arg, &passName::ID,                                                \\\n      PassInfo::NormalCtor_t(callDefaultCtor<passName>), cfg, analysis);       \\\n  Registry.registerPass(*PI, true);                                            \\\n  return PI;                                                                   \\\n  }                                                                            \\\n  static llvm::once_flag Initialize##passName##PassFlag;                       \\\n  void llvm::initialize##passName##Pass(PassRegistry &Registry) {              \\\n    llvm::call_once(Initialize##passName##PassFlag,                            \\\n                    initialize##passName##PassOnce, std::ref(Registry));       \\\n  }\n\n#define INITIALIZE_PASS_WITH_OPTIONS(PassName, Arg, Name, Cfg, Analysis)       \\\n  INITIALIZE_PASS_BEGIN(PassName, Arg, Name, Cfg, Analysis)                    \\\n  PassName::registerOptions();                                                 \\\n  INITIALIZE_PASS_END(PassName, Arg, Name, Cfg, Analysis)\n\n#define INITIALIZE_PASS_WITH_OPTIONS_BEGIN(PassName, Arg, Name, Cfg, Analysis) \\\n  INITIALIZE_PASS_BEGIN(PassName, Arg, Name, Cfg, Analysis)                    \\\n  PassName::registerOptions();\n\ntemplate <typename PassName> Pass *callDefaultCtor() { return new PassName(); }\n\n//===---------------------------------------------------------------------------\n/// RegisterPass<t> template - This template class is used to notify the system\n/// that a Pass is available for use, and registers it into the internal\n/// database maintained by the PassManager.  Unless this template is used, opt,\n/// for example will not be able to see the pass and attempts to create the pass\n/// will fail. This template is used in the follow manner (at global scope, in\n/// your .cpp file):\n///\n/// static RegisterPass<YourPassClassName> tmp(\"passopt\", \"My Pass Name\");\n///\n/// This statement will cause your pass to be created by calling the default\n/// constructor exposed by the pass.\ntemplate <typename passName> struct RegisterPass : public PassInfo {\n  // Register Pass using default constructor...\n  RegisterPass(StringRef PassArg, StringRef Name, bool CFGOnly = false,\n               bool is_analysis = false)\n      : PassInfo(Name, PassArg, &passName::ID,\n                 PassInfo::NormalCtor_t(callDefaultCtor<passName>), CFGOnly,\n                 is_analysis) {\n    PassRegistry::getPassRegistry()->registerPass(*this);\n  }\n};\n\n/// RegisterAnalysisGroup - Register a Pass as a member of an analysis _group_.\n/// Analysis groups are used to define an interface (which need not derive from\n/// Pass) that is required by passes to do their job.  Analysis Groups differ\n/// from normal analyses because any available implementation of the group will\n/// be used if it is available.\n///\n/// If no analysis implementing the interface is available, a default\n/// implementation is created and added.  A pass registers itself as the default\n/// implementation by specifying 'true' as the second template argument of this\n/// class.\n///\n/// In addition to registering itself as an analysis group member, a pass must\n/// register itself normally as well.  Passes may be members of multiple groups\n/// and may still be \"required\" specifically by name.\n///\n/// The actual interface may also be registered as well (by not specifying the\n/// second template argument).  The interface should be registered to associate\n/// a nice name with the interface.\nclass RegisterAGBase : public PassInfo {\npublic:\n  RegisterAGBase(StringRef Name, const void *InterfaceID,\n                 const void *PassID = nullptr, bool isDefault = false);\n};\n\ntemplate <typename Interface, bool Default = false>\nstruct RegisterAnalysisGroup : public RegisterAGBase {\n  explicit RegisterAnalysisGroup(PassInfo &RPB)\n      : RegisterAGBase(RPB.getPassName(), &Interface::ID, RPB.getTypeInfo(),\n                       Default) {}\n\n  explicit RegisterAnalysisGroup(const char *Name)\n      : RegisterAGBase(Name, &Interface::ID) {}\n};\n\n#define INITIALIZE_ANALYSIS_GROUP(agName, name, defaultPass)                   \\\n  static void *initialize##agName##AnalysisGroupOnce(PassRegistry &Registry) { \\\n    initialize##defaultPass##Pass(Registry);                                   \\\n    PassInfo *AI = new PassInfo(name, &agName::ID);                            \\\n    Registry.registerAnalysisGroup(&agName::ID, 0, *AI, false, true);          \\\n    return AI;                                                                 \\\n  }                                                                            \\\n  static llvm::once_flag Initialize##agName##AnalysisGroupFlag;                \\\n  void llvm::initialize##agName##AnalysisGroup(PassRegistry &Registry) {       \\\n    llvm::call_once(Initialize##agName##AnalysisGroupFlag,                     \\\n                    initialize##agName##AnalysisGroupOnce,                     \\\n                    std::ref(Registry));                                       \\\n  }\n\n#define INITIALIZE_AG_PASS(passName, agName, arg, name, cfg, analysis, def)    \\\n  static void *initialize##passName##PassOnce(PassRegistry &Registry) {        \\\n    if (!def)                                                                  \\\n      initialize##agName##AnalysisGroup(Registry);                             \\\n    PassInfo *PI = new PassInfo(                                               \\\n        name, arg, &passName::ID,                                              \\\n        PassInfo::NormalCtor_t(callDefaultCtor<passName>), cfg, analysis);     \\\n    Registry.registerPass(*PI, true);                                          \\\n                                                                               \\\n    PassInfo *AI = new PassInfo(name, &agName::ID);                            \\\n    Registry.registerAnalysisGroup(&agName::ID, &passName::ID, *AI, def,       \\\n                                   true);                                      \\\n    return AI;                                                                 \\\n  }                                                                            \\\n  static llvm::once_flag Initialize##passName##PassFlag;                       \\\n  void llvm::initialize##passName##Pass(PassRegistry &Registry) {              \\\n    llvm::call_once(Initialize##passName##PassFlag,                            \\\n                    initialize##passName##PassOnce, std::ref(Registry));       \\\n  }\n\n#define INITIALIZE_AG_PASS_BEGIN(passName, agName, arg, n, cfg, analysis, def) \\\n  static void *initialize##passName##PassOnce(PassRegistry &Registry) {        \\\n    if (!def)                                                                  \\\n      initialize##agName##AnalysisGroup(Registry);\n\n#define INITIALIZE_AG_PASS_END(passName, agName, arg, n, cfg, analysis, def)   \\\n  PassInfo *PI = new PassInfo(                                                 \\\n      n, arg, &passName::ID,                                                   \\\n      PassInfo::NormalCtor_t(callDefaultCtor<passName>), cfg, analysis);       \\\n  Registry.registerPass(*PI, true);                                            \\\n                                                                               \\\n  PassInfo *AI = new PassInfo(n, &agName::ID);                                 \\\n  Registry.registerAnalysisGroup(&agName::ID, &passName::ID, *AI, def, true);  \\\n  return AI;                                                                   \\\n  }                                                                            \\\n  static llvm::once_flag Initialize##passName##PassFlag;                       \\\n  void llvm::initialize##passName##Pass(PassRegistry &Registry) {              \\\n    llvm::call_once(Initialize##passName##PassFlag,                            \\\n                    initialize##passName##PassOnce, std::ref(Registry));       \\\n  }\n\n//===---------------------------------------------------------------------------\n/// PassRegistrationListener class - This class is meant to be derived from by\n/// clients that are interested in which passes get registered and unregistered\n/// at runtime (which can be because of the RegisterPass constructors being run\n/// as the program starts up, or may be because a shared object just got\n/// loaded).\nstruct PassRegistrationListener {\n  PassRegistrationListener() = default;\n  virtual ~PassRegistrationListener() = default;\n\n  /// Callback functions - These functions are invoked whenever a pass is loaded\n  /// or removed from the current executable.\n  virtual void passRegistered(const PassInfo *) {}\n\n  /// enumeratePasses - Iterate over the registered passes, calling the\n  /// passEnumerate callback on each PassInfo object.\n  void enumeratePasses();\n\n  /// passEnumerate - Callback function invoked when someone calls\n  /// enumeratePasses on this PassRegistrationListener object.\n  virtual void passEnumerate(const PassInfo *) {}\n};\n\n} // end namespace llvm\n\n#endif // LLVM_PASSSUPPORT_H\n"}, "71": {"id": 71, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "content": "//===- llvm/Support/CommandLine.h - Command line handler --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This class implements a command line argument processor that is useful when\n// creating a tool.  It provides a simple, minimalistic interface that is easily\n// extensible and supports nonlocal (library) command line options.\n//\n// Note that rather than trying to figure out what this code does, you should\n// read the library documentation located in docs/CommandLine.html or looks at\n// the many example usages in tools/*/*.cpp\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_COMMANDLINE_H\n#define LLVM_SUPPORT_COMMANDLINE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/ManagedStatic.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <functional>\n#include <initializer_list>\n#include <string>\n#include <type_traits>\n#include <vector>\n\nnamespace llvm {\n\nclass StringSaver;\n\n/// cl Namespace - This namespace contains all of the command line option\n/// processing machinery.  It is intentionally a short name to make qualified\n/// usage concise.\nnamespace cl {\n\n//===----------------------------------------------------------------------===//\n// ParseCommandLineOptions - Command line option processing entry point.\n//\n// Returns true on success. Otherwise, this will print the error message to\n// stderr and exit if \\p Errs is not set (nullptr by default), or print the\n// error message to \\p Errs and return false if \\p Errs is provided.\n//\n// If EnvVar is not nullptr, command-line options are also parsed from the\n// environment variable named by EnvVar.  Precedence is given to occurrences\n// from argv.  This precedence is currently implemented by parsing argv after\n// the environment variable, so it is only implemented correctly for options\n// that give precedence to later occurrences.  If your program supports options\n// that give precedence to earlier occurrences, you will need to extend this\n// function to support it correctly.\nbool ParseCommandLineOptions(int argc, const char *const *argv,\n                             StringRef Overview = \"\",\n                             raw_ostream *Errs = nullptr,\n                             const char *EnvVar = nullptr,\n                             bool LongOptionsUseDoubleDash = false);\n\n// Function pointer type for printing version information.\nusing VersionPrinterTy = std::function<void(raw_ostream &)>;\n\n///===---------------------------------------------------------------------===//\n/// SetVersionPrinter - Override the default (LLVM specific) version printer\n///                     used to print out the version when --version is given\n///                     on the command line. This allows other systems using the\n///                     CommandLine utilities to print their own version string.\nvoid SetVersionPrinter(VersionPrinterTy func);\n\n///===---------------------------------------------------------------------===//\n/// AddExtraVersionPrinter - Add an extra printer to use in addition to the\n///                          default one. This can be called multiple times,\n///                          and each time it adds a new function to the list\n///                          which will be called after the basic LLVM version\n///                          printing is complete. Each can then add additional\n///                          information specific to the tool.\nvoid AddExtraVersionPrinter(VersionPrinterTy func);\n\n// PrintOptionValues - Print option values.\n// With -print-options print the difference between option values and defaults.\n// With -print-all-options print all option values.\n// (Currently not perfect, but best-effort.)\nvoid PrintOptionValues();\n\n// Forward declaration - AddLiteralOption needs to be up here to make gcc happy.\nclass Option;\n\n/// Adds a new option for parsing and provides the option it refers to.\n///\n/// \\param O pointer to the option\n/// \\param Name the string name for the option to handle during parsing\n///\n/// Literal options are used by some parsers to register special option values.\n/// This is how the PassNameParser registers pass names for opt.\nvoid AddLiteralOption(Option &O, StringRef Name);\n\n//===----------------------------------------------------------------------===//\n// Flags permitted to be passed to command line arguments\n//\n\nenum NumOccurrencesFlag { // Flags for the number of occurrences allowed\n  Optional = 0x00,        // Zero or One occurrence\n  ZeroOrMore = 0x01,      // Zero or more occurrences allowed\n  Required = 0x02,        // One occurrence required\n  OneOrMore = 0x03,       // One or more occurrences required\n\n  // ConsumeAfter - Indicates that this option is fed anything that follows the\n  // last positional argument required by the application (it is an error if\n  // there are zero positional arguments, and a ConsumeAfter option is used).\n  // Thus, for example, all arguments to LLI are processed until a filename is\n  // found.  Once a filename is found, all of the succeeding arguments are\n  // passed, unprocessed, to the ConsumeAfter option.\n  //\n  ConsumeAfter = 0x04\n};\n\nenum ValueExpected { // Is a value required for the option?\n  // zero reserved for the unspecified value\n  ValueOptional = 0x01,  // The value can appear... or not\n  ValueRequired = 0x02,  // The value is required to appear!\n  ValueDisallowed = 0x03 // A value may not be specified (for flags)\n};\n\nenum OptionHidden {   // Control whether -help shows this option\n  NotHidden = 0x00,   // Option included in -help & -help-hidden\n  Hidden = 0x01,      // -help doesn't, but -help-hidden does\n  ReallyHidden = 0x02 // Neither -help nor -help-hidden show this arg\n};\n\n// Formatting flags - This controls special features that the option might have\n// that cause it to be parsed differently...\n//\n// Prefix - This option allows arguments that are otherwise unrecognized to be\n// matched by options that are a prefix of the actual value.  This is useful for\n// cases like a linker, where options are typically of the form '-lfoo' or\n// '-L../../include' where -l or -L are the actual flags.  When prefix is\n// enabled, and used, the value for the flag comes from the suffix of the\n// argument.\n//\n// AlwaysPrefix - Only allow the behavior enabled by the Prefix flag and reject\n// the Option=Value form.\n//\n\nenum FormattingFlags {\n  NormalFormatting = 0x00, // Nothing special\n  Positional = 0x01,       // Is a positional argument, no '-' required\n  Prefix = 0x02,           // Can this option directly prefix its value?\n  AlwaysPrefix = 0x03      // Can this option only directly prefix its value?\n};\n\nenum MiscFlags {             // Miscellaneous flags to adjust argument\n  CommaSeparated = 0x01,     // Should this cl::list split between commas?\n  PositionalEatsArgs = 0x02, // Should this positional cl::list eat -args?\n  Sink = 0x04,               // Should this cl::list eat all unknown options?\n\n  // Grouping - Can this option group with other options?\n  // If this is enabled, multiple letter options are allowed to bunch together\n  // with only a single hyphen for the whole group.  This allows emulation\n  // of the behavior that ls uses for example: ls -la === ls -l -a\n  Grouping = 0x08,\n\n  // Default option\n  DefaultOption = 0x10\n};\n\n//===----------------------------------------------------------------------===//\n// Option Category class\n//\nclass OptionCategory {\nprivate:\n  StringRef const Name;\n  StringRef const Description;\n\n  void registerCategory();\n\npublic:\n  OptionCategory(StringRef const Name,\n                 StringRef const Description = \"\")\n      : Name(Name), Description(Description) {\n    registerCategory();\n  }\n\n  StringRef getName() const { return Name; }\n  StringRef getDescription() const { return Description; }\n};\n\n// The general Option Category (used as default category).\nextern OptionCategory GeneralCategory;\n\n//===----------------------------------------------------------------------===//\n// SubCommand class\n//\nclass SubCommand {\nprivate:\n  StringRef Name;\n  StringRef Description;\n\nprotected:\n  void registerSubCommand();\n  void unregisterSubCommand();\n\npublic:\n  SubCommand(StringRef Name, StringRef Description = \"\")\n      : Name(Name), Description(Description) {\n        registerSubCommand();\n  }\n  SubCommand() = default;\n\n  void reset();\n\n  explicit operator bool() const;\n\n  StringRef getName() const { return Name; }\n  StringRef getDescription() const { return Description; }\n\n  SmallVector<Option *, 4> PositionalOpts;\n  SmallVector<Option *, 4> SinkOpts;\n  StringMap<Option *> OptionsMap;\n\n  Option *ConsumeAfterOpt = nullptr; // The ConsumeAfter option if it exists.\n};\n\n// A special subcommand representing no subcommand\nextern ManagedStatic<SubCommand> TopLevelSubCommand;\n\n// A special subcommand that can be used to put an option into all subcommands.\nextern ManagedStatic<SubCommand> AllSubCommands;\n\n//===----------------------------------------------------------------------===//\n// Option Base class\n//\nclass Option {\n  friend class alias;\n\n  // handleOccurrences - Overriden by subclasses to handle the value passed into\n  // an argument.  Should return true if there was an error processing the\n  // argument and the program should exit.\n  //\n  virtual bool handleOccurrence(unsigned pos, StringRef ArgName,\n                                StringRef Arg) = 0;\n\n  virtual enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // Out of line virtual function to provide home for the class.\n  virtual void anchor();\n\n  uint16_t NumOccurrences; // The number of times specified\n  // Occurrences, HiddenFlag, and Formatting are all enum types but to avoid\n  // problems with signed enums in bitfields.\n  uint16_t Occurrences : 3; // enum NumOccurrencesFlag\n  // not using the enum type for 'Value' because zero is an implementation\n  // detail representing the non-value\n  uint16_t Value : 2;\n  uint16_t HiddenFlag : 2; // enum OptionHidden\n  uint16_t Formatting : 2; // enum FormattingFlags\n  uint16_t Misc : 5;\n  uint16_t FullyInitialized : 1; // Has addArgument been called?\n  uint16_t Position;             // Position of last occurrence of the option\n  uint16_t AdditionalVals;       // Greater than 0 for multi-valued option.\n\npublic:\n  StringRef ArgStr;   // The argument string itself (ex: \"help\", \"o\")\n  StringRef HelpStr;  // The descriptive text message for -help\n  StringRef ValueStr; // String describing what the value of this option is\n  SmallVector<OptionCategory *, 1>\n      Categories;                    // The Categories this option belongs to\n  SmallPtrSet<SubCommand *, 1> Subs; // The subcommands this option belongs to.\n\n  inline enum NumOccurrencesFlag getNumOccurrencesFlag() const {\n    return (enum NumOccurrencesFlag)Occurrences;\n  }\n\n  inline enum ValueExpected getValueExpectedFlag() const {\n    return Value ? ((enum ValueExpected)Value) : getValueExpectedFlagDefault();\n  }\n\n  inline enum OptionHidden getOptionHiddenFlag() const {\n    return (enum OptionHidden)HiddenFlag;\n  }\n\n  inline enum FormattingFlags getFormattingFlag() const {\n    return (enum FormattingFlags)Formatting;\n  }\n\n  inline unsigned getMiscFlags() const { return Misc; }\n  inline unsigned getPosition() const { return Position; }\n  inline unsigned getNumAdditionalVals() const { return AdditionalVals; }\n\n  // hasArgStr - Return true if the argstr != \"\"\n  bool hasArgStr() const { return !ArgStr.empty(); }\n  bool isPositional() const { return getFormattingFlag() == cl::Positional; }\n  bool isSink() const { return getMiscFlags() & cl::Sink; }\n  bool isDefaultOption() const { return getMiscFlags() & cl::DefaultOption; }\n\n  bool isConsumeAfter() const {\n    return getNumOccurrencesFlag() == cl::ConsumeAfter;\n  }\n\n  bool isInAllSubCommands() const {\n    return any_of(Subs, [](const SubCommand *SC) {\n      return SC == &*AllSubCommands;\n    });\n  }\n\n  //-------------------------------------------------------------------------===\n  // Accessor functions set by OptionModifiers\n  //\n  void setArgStr(StringRef S);\n  void setDescription(StringRef S) { HelpStr = S; }\n  void setValueStr(StringRef S) { ValueStr = S; }\n  void setNumOccurrencesFlag(enum NumOccurrencesFlag Val) { Occurrences = Val; }\n  void setValueExpectedFlag(enum ValueExpected Val) { Value = Val; }\n  void setHiddenFlag(enum OptionHidden Val) { HiddenFlag = Val; }\n  void setFormattingFlag(enum FormattingFlags V) { Formatting = V; }\n  void setMiscFlag(enum MiscFlags M) { Misc |= M; }\n  void setPosition(unsigned pos) { Position = pos; }\n  void addCategory(OptionCategory &C);\n  void addSubCommand(SubCommand &S) { Subs.insert(&S); }\n\nprotected:\n  explicit Option(enum NumOccurrencesFlag OccurrencesFlag,\n                  enum OptionHidden Hidden)\n      : NumOccurrences(0), Occurrences(OccurrencesFlag), Value(0),\n        HiddenFlag(Hidden), Formatting(NormalFormatting), Misc(0),\n        FullyInitialized(false), Position(0), AdditionalVals(0) {\n    Categories.push_back(&GeneralCategory);\n  }\n\n  inline void setNumAdditionalVals(unsigned n) { AdditionalVals = n; }\n\npublic:\n  virtual ~Option() = default;\n\n  // addArgument - Register this argument with the commandline system.\n  //\n  void addArgument();\n\n  /// Unregisters this option from the CommandLine system.\n  ///\n  /// This option must have been the last option registered.\n  /// For testing purposes only.\n  void removeArgument();\n\n  // Return the width of the option tag for printing...\n  virtual size_t getOptionWidth() const = 0;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  virtual void printOptionInfo(size_t GlobalWidth) const = 0;\n\n  virtual void printOptionValue(size_t GlobalWidth, bool Force) const = 0;\n\n  virtual void setDefault() = 0;\n\n  // Prints the help string for an option.\n  //\n  // This maintains the Indent for multi-line descriptions.\n  // FirstLineIndentedBy is the count of chars of the first line\n  //      i.e. the one containing the --<option name>.\n  static void printHelpStr(StringRef HelpStr, size_t Indent,\n                           size_t FirstLineIndentedBy);\n\n  // Prints the help string for an enum value.\n  //\n  // This maintains the Indent for multi-line descriptions.\n  // FirstLineIndentedBy is the count of chars of the first line\n  //      i.e. the one containing the =<value>.\n  static void printEnumValHelpStr(StringRef HelpStr, size_t Indent,\n                                  size_t FirstLineIndentedBy);\n\n  virtual void getExtraOptionNames(SmallVectorImpl<StringRef> &) {}\n\n  // addOccurrence - Wrapper around handleOccurrence that enforces Flags.\n  //\n  virtual bool addOccurrence(unsigned pos, StringRef ArgName, StringRef Value,\n                             bool MultiArg = false);\n\n  // Prints option name followed by message.  Always returns true.\n  bool error(const Twine &Message, StringRef ArgName = StringRef(), raw_ostream &Errs = llvm::errs());\n  bool error(const Twine &Message, raw_ostream &Errs) {\n    return error(Message, StringRef(), Errs);\n  }\n\n  inline int getNumOccurrences() const { return NumOccurrences; }\n  void reset();\n};\n\n//===----------------------------------------------------------------------===//\n// Command line option modifiers that can be used to modify the behavior of\n// command line option parsers...\n//\n\n// desc - Modifier to set the description shown in the -help output...\nstruct desc {\n  StringRef Desc;\n\n  desc(StringRef Str) : Desc(Str) {}\n\n  void apply(Option &O) const { O.setDescription(Desc); }\n};\n\n// value_desc - Modifier to set the value description shown in the -help\n// output...\nstruct value_desc {\n  StringRef Desc;\n\n  value_desc(StringRef Str) : Desc(Str) {}\n\n  void apply(Option &O) const { O.setValueStr(Desc); }\n};\n\n// init - Specify a default (initial) value for the command line argument, if\n// the default constructor for the argument type does not give you what you\n// want.  This is only valid on \"opt\" arguments, not on \"list\" arguments.\n//\ntemplate <class Ty> struct initializer {\n  const Ty &Init;\n  initializer(const Ty &Val) : Init(Val) {}\n\n  template <class Opt> void apply(Opt &O) const { O.setInitialValue(Init); }\n};\n\ntemplate <class Ty> initializer<Ty> init(const Ty &Val) {\n  return initializer<Ty>(Val);\n}\n\n// location - Allow the user to specify which external variable they want to\n// store the results of the command line argument processing into, if they don't\n// want to store it in the option itself.\n//\ntemplate <class Ty> struct LocationClass {\n  Ty &Loc;\n\n  LocationClass(Ty &L) : Loc(L) {}\n\n  template <class Opt> void apply(Opt &O) const { O.setLocation(O, Loc); }\n};\n\ntemplate <class Ty> LocationClass<Ty> location(Ty &L) {\n  return LocationClass<Ty>(L);\n}\n\n// cat - Specifiy the Option category for the command line argument to belong\n// to.\nstruct cat {\n  OptionCategory &Category;\n\n  cat(OptionCategory &c) : Category(c) {}\n\n  template <class Opt> void apply(Opt &O) const { O.addCategory(Category); }\n};\n\n// sub - Specify the subcommand that this option belongs to.\nstruct sub {\n  SubCommand &Sub;\n\n  sub(SubCommand &S) : Sub(S) {}\n\n  template <class Opt> void apply(Opt &O) const { O.addSubCommand(Sub); }\n};\n\n// Specify a callback function to be called when an option is seen.\n// Can be used to set other options automatically.\ntemplate <typename R, typename Ty> struct cb {\n  std::function<R(Ty)> CB;\n\n  cb(std::function<R(Ty)> CB) : CB(CB) {}\n\n  template <typename Opt> void apply(Opt &O) const { O.setCallback(CB); }\n};\n\nnamespace detail {\ntemplate <typename F>\nstruct callback_traits : public callback_traits<decltype(&F::operator())> {};\n\ntemplate <typename R, typename C, typename... Args>\nstruct callback_traits<R (C::*)(Args...) const> {\n  using result_type = R;\n  using arg_type = std::tuple_element_t<0, std::tuple<Args...>>;\n  static_assert(sizeof...(Args) == 1, \"callback function must have one and only one parameter\");\n  static_assert(std::is_same<result_type, void>::value,\n                \"callback return type must be void\");\n  static_assert(std::is_lvalue_reference<arg_type>::value &&\n                    std::is_const<std::remove_reference_t<arg_type>>::value,\n                \"callback arg_type must be a const lvalue reference\");\n};\n} // namespace detail\n\ntemplate <typename F>\ncb<typename detail::callback_traits<F>::result_type,\n   typename detail::callback_traits<F>::arg_type>\ncallback(F CB) {\n  using result_type = typename detail::callback_traits<F>::result_type;\n  using arg_type = typename detail::callback_traits<F>::arg_type;\n  return cb<result_type, arg_type>(CB);\n}\n\n//===----------------------------------------------------------------------===//\n// OptionValue class\n\n// Support value comparison outside the template.\nstruct GenericOptionValue {\n  virtual bool compare(const GenericOptionValue &V) const = 0;\n\nprotected:\n  GenericOptionValue() = default;\n  GenericOptionValue(const GenericOptionValue&) = default;\n  GenericOptionValue &operator=(const GenericOptionValue &) = default;\n  ~GenericOptionValue() = default;\n\nprivate:\n  virtual void anchor();\n};\n\ntemplate <class DataType> struct OptionValue;\n\n// The default value safely does nothing. Option value printing is only\n// best-effort.\ntemplate <class DataType, bool isClass>\nstruct OptionValueBase : public GenericOptionValue {\n  // Temporary storage for argument passing.\n  using WrapperType = OptionValue<DataType>;\n\n  bool hasValue() const { return false; }\n\n  const DataType &getValue() const { llvm_unreachable(\"no default value\"); }\n\n  // Some options may take their value from a different data type.\n  template <class DT> void setValue(const DT & /*V*/) {}\n\n  bool compare(const DataType & /*V*/) const { return false; }\n\n  bool compare(const GenericOptionValue & /*V*/) const override {\n    return false;\n  }\n\nprotected:\n  ~OptionValueBase() = default;\n};\n\n// Simple copy of the option value.\ntemplate <class DataType> class OptionValueCopy : public GenericOptionValue {\n  DataType Value;\n  bool Valid = false;\n\nprotected:\n  OptionValueCopy(const OptionValueCopy&) = default;\n  OptionValueCopy &operator=(const OptionValueCopy &) = default;\n  ~OptionValueCopy() = default;\n\npublic:\n  OptionValueCopy() = default;\n\n  bool hasValue() const { return Valid; }\n\n  const DataType &getValue() const {\n    assert(Valid && \"invalid option value\");\n    return Value;\n  }\n\n  void setValue(const DataType &V) {\n    Valid = true;\n    Value = V;\n  }\n\n  bool compare(const DataType &V) const { return Valid && (Value != V); }\n\n  bool compare(const GenericOptionValue &V) const override {\n    const OptionValueCopy<DataType> &VC =\n        static_cast<const OptionValueCopy<DataType> &>(V);\n    if (!VC.hasValue())\n      return false;\n    return compare(VC.getValue());\n  }\n};\n\n// Non-class option values.\ntemplate <class DataType>\nstruct OptionValueBase<DataType, false> : OptionValueCopy<DataType> {\n  using WrapperType = DataType;\n\nprotected:\n  OptionValueBase() = default;\n  OptionValueBase(const OptionValueBase&) = default;\n  OptionValueBase &operator=(const OptionValueBase &) = default;\n  ~OptionValueBase() = default;\n};\n\n// Top-level option class.\ntemplate <class DataType>\nstruct OptionValue final\n    : OptionValueBase<DataType, std::is_class<DataType>::value> {\n  OptionValue() = default;\n\n  OptionValue(const DataType &V) { this->setValue(V); }\n\n  // Some options may take their value from a different data type.\n  template <class DT> OptionValue<DataType> &operator=(const DT &V) {\n    this->setValue(V);\n    return *this;\n  }\n};\n\n// Other safe-to-copy-by-value common option types.\nenum boolOrDefault { BOU_UNSET, BOU_TRUE, BOU_FALSE };\ntemplate <>\nstruct OptionValue<cl::boolOrDefault> final\n    : OptionValueCopy<cl::boolOrDefault> {\n  using WrapperType = cl::boolOrDefault;\n\n  OptionValue() = default;\n\n  OptionValue(const cl::boolOrDefault &V) { this->setValue(V); }\n\n  OptionValue<cl::boolOrDefault> &operator=(const cl::boolOrDefault &V) {\n    setValue(V);\n    return *this;\n  }\n\nprivate:\n  void anchor() override;\n};\n\ntemplate <>\nstruct OptionValue<std::string> final : OptionValueCopy<std::string> {\n  using WrapperType = StringRef;\n\n  OptionValue() = default;\n\n  OptionValue(const std::string &V) { this->setValue(V); }\n\n  OptionValue<std::string> &operator=(const std::string &V) {\n    setValue(V);\n    return *this;\n  }\n\nprivate:\n  void anchor() override;\n};\n\n//===----------------------------------------------------------------------===//\n// Enum valued command line option\n//\n\n// This represents a single enum value, using \"int\" as the underlying type.\nstruct OptionEnumValue {\n  StringRef Name;\n  int Value;\n  StringRef Description;\n};\n\n#define clEnumVal(ENUMVAL, DESC)                                               \\\n  llvm::cl::OptionEnumValue { #ENUMVAL, int(ENUMVAL), DESC }\n#define clEnumValN(ENUMVAL, FLAGNAME, DESC)                                    \\\n  llvm::cl::OptionEnumValue { FLAGNAME, int(ENUMVAL), DESC }\n\n// values - For custom data types, allow specifying a group of values together\n// as the values that go into the mapping that the option handler uses.\n//\nclass ValuesClass {\n  // Use a vector instead of a map, because the lists should be short,\n  // the overhead is less, and most importantly, it keeps them in the order\n  // inserted so we can print our option out nicely.\n  SmallVector<OptionEnumValue, 4> Values;\n\npublic:\n  ValuesClass(std::initializer_list<OptionEnumValue> Options)\n      : Values(Options) {}\n\n  template <class Opt> void apply(Opt &O) const {\n    for (const auto &Value : Values)\n      O.getParser().addLiteralOption(Value.Name, Value.Value,\n                                     Value.Description);\n  }\n};\n\n/// Helper to build a ValuesClass by forwarding a variable number of arguments\n/// as an initializer list to the ValuesClass constructor.\ntemplate <typename... OptsTy> ValuesClass values(OptsTy... Options) {\n  return ValuesClass({Options...});\n}\n\n//===----------------------------------------------------------------------===//\n// parser class - Parameterizable parser for different data types.  By default,\n// known data types (string, int, bool) have specialized parsers, that do what\n// you would expect.  The default parser, used for data types that are not\n// built-in, uses a mapping table to map specific options to values, which is\n// used, among other things, to handle enum types.\n\n//--------------------------------------------------\n// generic_parser_base - This class holds all the non-generic code that we do\n// not need replicated for every instance of the generic parser.  This also\n// allows us to put stuff into CommandLine.cpp\n//\nclass generic_parser_base {\nprotected:\n  class GenericOptionInfo {\n  public:\n    GenericOptionInfo(StringRef name, StringRef helpStr)\n        : Name(name), HelpStr(helpStr) {}\n    StringRef Name;\n    StringRef HelpStr;\n  };\n\npublic:\n  generic_parser_base(Option &O) : Owner(O) {}\n\n  virtual ~generic_parser_base() = default;\n  // Base class should have virtual-destructor\n\n  // getNumOptions - Virtual function implemented by generic subclass to\n  // indicate how many entries are in Values.\n  //\n  virtual unsigned getNumOptions() const = 0;\n\n  // getOption - Return option name N.\n  virtual StringRef getOption(unsigned N) const = 0;\n\n  // getDescription - Return description N\n  virtual StringRef getDescription(unsigned N) const = 0;\n\n  // Return the width of the option tag for printing...\n  virtual size_t getOptionWidth(const Option &O) const;\n\n  virtual const GenericOptionValue &getOptionValue(unsigned N) const = 0;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  virtual void printOptionInfo(const Option &O, size_t GlobalWidth) const;\n\n  void printGenericOptionDiff(const Option &O, const GenericOptionValue &V,\n                              const GenericOptionValue &Default,\n                              size_t GlobalWidth) const;\n\n  // printOptionDiff - print the value of an option and it's default.\n  //\n  // Template definition ensures that the option and default have the same\n  // DataType (via the same AnyOptionValue).\n  template <class AnyOptionValue>\n  void printOptionDiff(const Option &O, const AnyOptionValue &V,\n                       const AnyOptionValue &Default,\n                       size_t GlobalWidth) const {\n    printGenericOptionDiff(O, V, Default, GlobalWidth);\n  }\n\n  void initialize() {}\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) {\n    // If there has been no argstr specified, that means that we need to add an\n    // argument for every possible option.  This ensures that our options are\n    // vectored to us.\n    if (!Owner.hasArgStr())\n      for (unsigned i = 0, e = getNumOptions(); i != e; ++i)\n        OptionNames.push_back(getOption(i));\n  }\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    // If there is an ArgStr specified, then we are of the form:\n    //\n    //    -opt=O2   or   -opt O2  or  -optO2\n    //\n    // In which case, the value is required.  Otherwise if an arg str has not\n    // been specified, we are of the form:\n    //\n    //    -O2 or O2 or -la (where -l and -a are separate options)\n    //\n    // If this is the case, we cannot allow a value.\n    //\n    if (Owner.hasArgStr())\n      return ValueRequired;\n    else\n      return ValueDisallowed;\n  }\n\n  // findOption - Return the option number corresponding to the specified\n  // argument string.  If the option is not found, getNumOptions() is returned.\n  //\n  unsigned findOption(StringRef Name);\n\nprotected:\n  Option &Owner;\n};\n\n// Default parser implementation - This implementation depends on having a\n// mapping of recognized options to values of some sort.  In addition to this,\n// each entry in the mapping also tracks a help message that is printed with the\n// command line option for -help.  Because this is a simple mapping parser, the\n// data type can be any unsupported type.\n//\ntemplate <class DataType> class parser : public generic_parser_base {\nprotected:\n  class OptionInfo : public GenericOptionInfo {\n  public:\n    OptionInfo(StringRef name, DataType v, StringRef helpStr)\n        : GenericOptionInfo(name, helpStr), V(v) {}\n\n    OptionValue<DataType> V;\n  };\n  SmallVector<OptionInfo, 8> Values;\n\npublic:\n  parser(Option &O) : generic_parser_base(O) {}\n\n  using parser_data_type = DataType;\n\n  // Implement virtual functions needed by generic_parser_base\n  unsigned getNumOptions() const override { return unsigned(Values.size()); }\n  StringRef getOption(unsigned N) const override { return Values[N].Name; }\n  StringRef getDescription(unsigned N) const override {\n    return Values[N].HelpStr;\n  }\n\n  // getOptionValue - Return the value of option name N.\n  const GenericOptionValue &getOptionValue(unsigned N) const override {\n    return Values[N].V;\n  }\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, DataType &V) {\n    StringRef ArgVal;\n    if (Owner.hasArgStr())\n      ArgVal = Arg;\n    else\n      ArgVal = ArgName;\n\n    for (size_t i = 0, e = Values.size(); i != e; ++i)\n      if (Values[i].Name == ArgVal) {\n        V = Values[i].V.getValue();\n        return false;\n      }\n\n    return O.error(\"Cannot find option named '\" + ArgVal + \"'!\");\n  }\n\n  /// addLiteralOption - Add an entry to the mapping table.\n  ///\n  template <class DT>\n  void addLiteralOption(StringRef Name, const DT &V, StringRef HelpStr) {\n    assert(findOption(Name) == Values.size() && \"Option already exists!\");\n    OptionInfo X(Name, static_cast<DataType>(V), HelpStr);\n    Values.push_back(X);\n    AddLiteralOption(Owner, Name);\n  }\n\n  /// removeLiteralOption - Remove the specified option.\n  ///\n  void removeLiteralOption(StringRef Name) {\n    unsigned N = findOption(Name);\n    assert(N != Values.size() && \"Option not found!\");\n    Values.erase(Values.begin() + N);\n  }\n};\n\n//--------------------------------------------------\n// basic_parser - Super class of parsers to provide boilerplate code\n//\nclass basic_parser_impl { // non-template implementation of basic_parser<t>\npublic:\n  basic_parser_impl(Option &) {}\n\n  virtual ~basic_parser_impl() {}\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueRequired;\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &) {}\n\n  void initialize() {}\n\n  // Return the width of the option tag for printing...\n  size_t getOptionWidth(const Option &O) const;\n\n  // printOptionInfo - Print out information about this option.  The\n  // to-be-maintained width is specified.\n  //\n  void printOptionInfo(const Option &O, size_t GlobalWidth) const;\n\n  // printOptionNoValue - Print a placeholder for options that don't yet support\n  // printOptionDiff().\n  void printOptionNoValue(const Option &O, size_t GlobalWidth) const;\n\n  // getValueName - Overload in subclass to provide a better default value.\n  virtual StringRef getValueName() const { return \"value\"; }\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  virtual void anchor();\n\nprotected:\n  // A helper for basic_parser::printOptionDiff.\n  void printOptionName(const Option &O, size_t GlobalWidth) const;\n};\n\n// basic_parser - The real basic parser is just a template wrapper that provides\n// a typedef for the provided data type.\n//\ntemplate <class DataType> class basic_parser : public basic_parser_impl {\npublic:\n  using parser_data_type = DataType;\n  using OptVal = OptionValue<DataType>;\n\n  basic_parser(Option &O) : basic_parser_impl(O) {}\n};\n\n//--------------------------------------------------\n// parser<bool>\n//\ntemplate <> class parser<bool> : public basic_parser<bool> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, bool &Val);\n\n  void initialize() {}\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // getValueName - Do not print =<value> at all.\n  StringRef getValueName() const override { return StringRef(); }\n\n  void printOptionDiff(const Option &O, bool V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<bool>;\n\n//--------------------------------------------------\n// parser<boolOrDefault>\ntemplate <> class parser<boolOrDefault> : public basic_parser<boolOrDefault> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, boolOrDefault &Val);\n\n  enum ValueExpected getValueExpectedFlagDefault() const {\n    return ValueOptional;\n  }\n\n  // getValueName - Do not print =<value> at all.\n  StringRef getValueName() const override { return StringRef(); }\n\n  void printOptionDiff(const Option &O, boolOrDefault V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<boolOrDefault>;\n\n//--------------------------------------------------\n// parser<int>\n//\ntemplate <> class parser<int> : public basic_parser<int> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, int &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"int\"; }\n\n  void printOptionDiff(const Option &O, int V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<int>;\n\n//--------------------------------------------------\n// parser<long>\n//\ntemplate <> class parser<long> final : public basic_parser<long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"long\"; }\n\n  void printOptionDiff(const Option &O, long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<long>;\n\n//--------------------------------------------------\n// parser<long long>\n//\ntemplate <> class parser<long long> : public basic_parser<long long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, long long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"long\"; }\n\n  void printOptionDiff(const Option &O, long long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<long long>;\n\n//--------------------------------------------------\n// parser<unsigned>\n//\ntemplate <> class parser<unsigned> : public basic_parser<unsigned> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, unsigned &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"uint\"; }\n\n  void printOptionDiff(const Option &O, unsigned V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned>;\n\n//--------------------------------------------------\n// parser<unsigned long>\n//\ntemplate <>\nclass parser<unsigned long> final : public basic_parser<unsigned long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, unsigned long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"ulong\"; }\n\n  void printOptionDiff(const Option &O, unsigned long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned long>;\n\n//--------------------------------------------------\n// parser<unsigned long long>\n//\ntemplate <>\nclass parser<unsigned long long> : public basic_parser<unsigned long long> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg,\n             unsigned long long &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"ulong\"; }\n\n  void printOptionDiff(const Option &O, unsigned long long V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<unsigned long long>;\n\n//--------------------------------------------------\n// parser<double>\n//\ntemplate <> class parser<double> : public basic_parser<double> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, double &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"number\"; }\n\n  void printOptionDiff(const Option &O, double V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<double>;\n\n//--------------------------------------------------\n// parser<float>\n//\ntemplate <> class parser<float> : public basic_parser<float> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &O, StringRef ArgName, StringRef Arg, float &Val);\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"number\"; }\n\n  void printOptionDiff(const Option &O, float V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<float>;\n\n//--------------------------------------------------\n// parser<std::string>\n//\ntemplate <> class parser<std::string> : public basic_parser<std::string> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &, StringRef, StringRef Arg, std::string &Value) {\n    Value = Arg.str();\n    return false;\n  }\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"string\"; }\n\n  void printOptionDiff(const Option &O, StringRef V, const OptVal &Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<std::string>;\n\n//--------------------------------------------------\n// parser<char>\n//\ntemplate <> class parser<char> : public basic_parser<char> {\npublic:\n  parser(Option &O) : basic_parser(O) {}\n\n  // parse - Return true on error.\n  bool parse(Option &, StringRef, StringRef Arg, char &Value) {\n    Value = Arg[0];\n    return false;\n  }\n\n  // getValueName - Overload in subclass to provide a better default value.\n  StringRef getValueName() const override { return \"char\"; }\n\n  void printOptionDiff(const Option &O, char V, OptVal Default,\n                       size_t GlobalWidth) const;\n\n  // An out-of-line virtual method to provide a 'home' for this class.\n  void anchor() override;\n};\n\nextern template class basic_parser<char>;\n\n//--------------------------------------------------\n// PrintOptionDiff\n//\n// This collection of wrappers is the intermediary between class opt and class\n// parser to handle all the template nastiness.\n\n// This overloaded function is selected by the generic parser.\ntemplate <class ParserClass, class DT>\nvoid printOptionDiff(const Option &O, const generic_parser_base &P, const DT &V,\n                     const OptionValue<DT> &Default, size_t GlobalWidth) {\n  OptionValue<DT> OV = V;\n  P.printOptionDiff(O, OV, Default, GlobalWidth);\n}\n\n// This is instantiated for basic parsers when the parsed value has a different\n// type than the option value. e.g. HelpPrinter.\ntemplate <class ParserDT, class ValDT> struct OptionDiffPrinter {\n  void print(const Option &O, const parser<ParserDT> &P, const ValDT & /*V*/,\n             const OptionValue<ValDT> & /*Default*/, size_t GlobalWidth) {\n    P.printOptionNoValue(O, GlobalWidth);\n  }\n};\n\n// This is instantiated for basic parsers when the parsed value has the same\n// type as the option value.\ntemplate <class DT> struct OptionDiffPrinter<DT, DT> {\n  void print(const Option &O, const parser<DT> &P, const DT &V,\n             const OptionValue<DT> &Default, size_t GlobalWidth) {\n    P.printOptionDiff(O, V, Default, GlobalWidth);\n  }\n};\n\n// This overloaded function is selected by the basic parser, which may parse a\n// different type than the option type.\ntemplate <class ParserClass, class ValDT>\nvoid printOptionDiff(\n    const Option &O,\n    const basic_parser<typename ParserClass::parser_data_type> &P,\n    const ValDT &V, const OptionValue<ValDT> &Default, size_t GlobalWidth) {\n\n  OptionDiffPrinter<typename ParserClass::parser_data_type, ValDT> printer;\n  printer.print(O, static_cast<const ParserClass &>(P), V, Default,\n                GlobalWidth);\n}\n\n//===----------------------------------------------------------------------===//\n// applicator class - This class is used because we must use partial\n// specialization to handle literal string arguments specially (const char* does\n// not correctly respond to the apply method).  Because the syntax to use this\n// is a pain, we have the 'apply' method below to handle the nastiness...\n//\ntemplate <class Mod> struct applicator {\n  template <class Opt> static void opt(const Mod &M, Opt &O) { M.apply(O); }\n};\n\n// Handle const char* as a special case...\ntemplate <unsigned n> struct applicator<char[n]> {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\ntemplate <unsigned n> struct applicator<const char[n]> {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\ntemplate <> struct applicator<StringRef > {\n  template <class Opt> static void opt(StringRef Str, Opt &O) {\n    O.setArgStr(Str);\n  }\n};\n\ntemplate <> struct applicator<NumOccurrencesFlag> {\n  static void opt(NumOccurrencesFlag N, Option &O) {\n    O.setNumOccurrencesFlag(N);\n  }\n};\n\ntemplate <> struct applicator<ValueExpected> {\n  static void opt(ValueExpected VE, Option &O) { O.setValueExpectedFlag(VE); }\n};\n\ntemplate <> struct applicator<OptionHidden> {\n  static void opt(OptionHidden OH, Option &O) { O.setHiddenFlag(OH); }\n};\n\ntemplate <> struct applicator<FormattingFlags> {\n  static void opt(FormattingFlags FF, Option &O) { O.setFormattingFlag(FF); }\n};\n\ntemplate <> struct applicator<MiscFlags> {\n  static void opt(MiscFlags MF, Option &O) {\n    assert((MF != Grouping || O.ArgStr.size() == 1) &&\n           \"cl::Grouping can only apply to single charater Options.\");\n    O.setMiscFlag(MF);\n  }\n};\n\n// apply method - Apply modifiers to an option in a type safe way.\ntemplate <class Opt, class Mod, class... Mods>\nvoid apply(Opt *O, const Mod &M, const Mods &... Ms) {\n  applicator<Mod>::opt(M, *O);\n  apply(O, Ms...);\n}\n\ntemplate <class Opt, class Mod> void apply(Opt *O, const Mod &M) {\n  applicator<Mod>::opt(M, *O);\n}\n\n//===----------------------------------------------------------------------===//\n// opt_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, bool ExternalStorage, bool isClass>\nclass opt_storage {\n  DataType *Location = nullptr; // Where to store the object...\n  OptionValue<DataType> Default;\n\n  void check_location() const {\n    assert(Location && \"cl::location(...) not specified for a command \"\n                       \"line option with external storage, \"\n                       \"or cl::init specified before cl::location()!!\");\n  }\n\npublic:\n  opt_storage() = default;\n\n  bool setLocation(Option &O, DataType &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    Default = L;\n    return false;\n  }\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    check_location();\n    *Location = V;\n    if (initial)\n      Default = V;\n  }\n\n  DataType &getValue() {\n    check_location();\n    return *Location;\n  }\n  const DataType &getValue() const {\n    check_location();\n    return *Location;\n  }\n\n  operator DataType() const { return this->getValue(); }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n};\n\n// Define how to hold a class type object, such as a string.  Since we can\n// inherit from a class, we do so.  This makes us exactly compatible with the\n// object in all cases that it is used.\n//\ntemplate <class DataType>\nclass opt_storage<DataType, false, true> : public DataType {\npublic:\n  OptionValue<DataType> Default;\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    DataType::operator=(V);\n    if (initial)\n      Default = V;\n  }\n\n  DataType &getValue() { return *this; }\n  const DataType &getValue() const { return *this; }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n};\n\n// Define a partial specialization to handle things we cannot inherit from.  In\n// this case, we store an instance through containment, and overload operators\n// to get at the value.\n//\ntemplate <class DataType> class opt_storage<DataType, false, false> {\npublic:\n  DataType Value;\n  OptionValue<DataType> Default;\n\n  // Make sure we initialize the value with the default constructor for the\n  // type.\n  opt_storage() : Value(DataType()), Default(DataType()) {}\n\n  template <class T> void setValue(const T &V, bool initial = false) {\n    Value = V;\n    if (initial)\n      Default = V;\n  }\n  DataType &getValue() { return Value; }\n  DataType getValue() const { return Value; }\n\n  const OptionValue<DataType> &getDefault() const { return Default; }\n\n  operator DataType() const { return getValue(); }\n\n  // If the datatype is a pointer, support -> on it.\n  DataType operator->() const { return Value; }\n};\n\n//===----------------------------------------------------------------------===//\n// opt - A scalar command line option.\n//\ntemplate <class DataType, bool ExternalStorage = false,\n          class ParserClass = parser<DataType>>\nclass opt : public Option,\n            public opt_storage<DataType, ExternalStorage,\n                               std::is_class<DataType>::value> {\n  ParserClass Parser;\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse error!\n    this->setValue(Val);\n    this->setPosition(pos);\n    Callback(Val);\n    return false;\n  }\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  void printOptionValue(size_t GlobalWidth, bool Force) const override {\n    if (Force || this->getDefault().compare(this->getValue())) {\n      cl::printOptionDiff<ParserClass>(*this, Parser, this->getValue(),\n                                       this->getDefault(), GlobalWidth);\n    }\n  }\n\n  template <class T,\n            class = std::enable_if_t<std::is_assignable<T &, T>::value>>\n  void setDefaultImpl() {\n    const OptionValue<DataType> &V = this->getDefault();\n    if (V.hasValue())\n      this->setValue(V.getValue());\n  }\n\n  template <class T,\n            class = std::enable_if_t<!std::is_assignable<T &, T>::value>>\n  void setDefaultImpl(...) {}\n\n  void setDefault() override { setDefaultImpl<DataType>(); }\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  opt(const opt &) = delete;\n  opt &operator=(const opt &) = delete;\n\n  // setInitialValue - Used by the cl::init modifier...\n  void setInitialValue(const DataType &V) { this->setValue(V, true); }\n\n  ParserClass &getParser() { return Parser; }\n\n  template <class T> DataType &operator=(const T &Val) {\n    this->setValue(Val);\n    Callback(Val);\n    return this->getValue();\n  }\n\n  template <class... Mods>\n  explicit opt(const Mods &... Ms)\n      : Option(llvm::cl::Optional, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\nextern template class opt<unsigned>;\nextern template class opt<int>;\nextern template class opt<std::string>;\nextern template class opt<char>;\nextern template class opt<bool>;\n\n//===----------------------------------------------------------------------===//\n// list_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, class StorageClass> class list_storage {\n  StorageClass *Location = nullptr; // Where to store the object...\n\npublic:\n  list_storage() = default;\n\n  void clear() {}\n\n  bool setLocation(Option &O, StorageClass &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    return false;\n  }\n\n  template <class T> void addValue(const T &V) {\n    assert(Location != 0 && \"cl::location(...) not specified for a command \"\n                            \"line option with external storage!\");\n    Location->push_back(V);\n  }\n};\n\n// Define how to hold a class type object, such as a string.\n// Originally this code inherited from std::vector. In transitioning to a new\n// API for command line options we should change this. The new implementation\n// of this list_storage specialization implements the minimum subset of the\n// std::vector API required for all the current clients.\n//\n// FIXME: Reduce this API to a more narrow subset of std::vector\n//\ntemplate <class DataType> class list_storage<DataType, bool> {\n  std::vector<DataType> Storage;\n\npublic:\n  using iterator = typename std::vector<DataType>::iterator;\n\n  iterator begin() { return Storage.begin(); }\n  iterator end() { return Storage.end(); }\n\n  using const_iterator = typename std::vector<DataType>::const_iterator;\n\n  const_iterator begin() const { return Storage.begin(); }\n  const_iterator end() const { return Storage.end(); }\n\n  using size_type = typename std::vector<DataType>::size_type;\n\n  size_type size() const { return Storage.size(); }\n\n  bool empty() const { return Storage.empty(); }\n\n  void push_back(const DataType &value) { Storage.push_back(value); }\n  void push_back(DataType &&value) { Storage.push_back(value); }\n\n  using reference = typename std::vector<DataType>::reference;\n  using const_reference = typename std::vector<DataType>::const_reference;\n\n  reference operator[](size_type pos) { return Storage[pos]; }\n  const_reference operator[](size_type pos) const { return Storage[pos]; }\n\n  void clear() {\n    Storage.clear();\n  }\n\n  iterator erase(const_iterator pos) { return Storage.erase(pos); }\n  iterator erase(const_iterator first, const_iterator last) {\n    return Storage.erase(first, last);\n  }\n\n  iterator erase(iterator pos) { return Storage.erase(pos); }\n  iterator erase(iterator first, iterator last) {\n    return Storage.erase(first, last);\n  }\n\n  iterator insert(const_iterator pos, const DataType &value) {\n    return Storage.insert(pos, value);\n  }\n  iterator insert(const_iterator pos, DataType &&value) {\n    return Storage.insert(pos, value);\n  }\n\n  iterator insert(iterator pos, const DataType &value) {\n    return Storage.insert(pos, value);\n  }\n  iterator insert(iterator pos, DataType &&value) {\n    return Storage.insert(pos, value);\n  }\n\n  reference front() { return Storage.front(); }\n  const_reference front() const { return Storage.front(); }\n\n  operator std::vector<DataType> &() { return Storage; }\n  operator ArrayRef<DataType>() const { return Storage; }\n  std::vector<DataType> *operator&() { return &Storage; }\n  const std::vector<DataType> *operator&() const { return &Storage; }\n\n  template <class T> void addValue(const T &V) { Storage.push_back(V); }\n};\n\n//===----------------------------------------------------------------------===//\n// list - A list of command line options.\n//\ntemplate <class DataType, class StorageClass = bool,\n          class ParserClass = parser<DataType>>\nclass list : public Option, public list_storage<DataType, StorageClass> {\n  std::vector<unsigned> Positions;\n  ParserClass Parser;\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse Error!\n    list_storage<DataType, StorageClass>::addValue(Val);\n    setPosition(pos);\n    Positions.push_back(pos);\n    Callback(Val);\n    return false;\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  // Unimplemented: list options don't currently store their default value.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override {\n    Positions.clear();\n    list_storage<DataType, StorageClass>::clear();\n  }\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  list(const list &) = delete;\n  list &operator=(const list &) = delete;\n\n  ParserClass &getParser() { return Parser; }\n\n  unsigned getPosition(unsigned optnum) const {\n    assert(optnum < this->size() && \"Invalid option index\");\n    return Positions[optnum];\n  }\n\n  void setNumAdditionalVals(unsigned n) { Option::setNumAdditionalVals(n); }\n\n  template <class... Mods>\n  explicit list(const Mods &... Ms)\n      : Option(ZeroOrMore, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\n// multi_val - Modifier to set the number of additional values.\nstruct multi_val {\n  unsigned AdditionalVals;\n  explicit multi_val(unsigned N) : AdditionalVals(N) {}\n\n  template <typename D, typename S, typename P>\n  void apply(list<D, S, P> &L) const {\n    L.setNumAdditionalVals(AdditionalVals);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// bits_storage class\n\n// Default storage class definition: external storage.  This implementation\n// assumes the user will specify a variable to store the data into with the\n// cl::location(x) modifier.\n//\ntemplate <class DataType, class StorageClass> class bits_storage {\n  unsigned *Location = nullptr; // Where to store the bits...\n\n  template <class T> static unsigned Bit(const T &V) {\n    unsigned BitPos = reinterpret_cast<unsigned>(V);\n    assert(BitPos < sizeof(unsigned) * CHAR_BIT &&\n           \"enum exceeds width of bit vector!\");\n    return 1 << BitPos;\n  }\n\npublic:\n  bits_storage() = default;\n\n  bool setLocation(Option &O, unsigned &L) {\n    if (Location)\n      return O.error(\"cl::location(x) specified more than once!\");\n    Location = &L;\n    return false;\n  }\n\n  template <class T> void addValue(const T &V) {\n    assert(Location != 0 && \"cl::location(...) not specified for a command \"\n                            \"line option with external storage!\");\n    *Location |= Bit(V);\n  }\n\n  unsigned getBits() { return *Location; }\n\n  template <class T> bool isSet(const T &V) {\n    return (*Location & Bit(V)) != 0;\n  }\n};\n\n// Define how to hold bits.  Since we can inherit from a class, we do so.\n// This makes us exactly compatible with the bits in all cases that it is used.\n//\ntemplate <class DataType> class bits_storage<DataType, bool> {\n  unsigned Bits; // Where to store the bits...\n\n  template <class T> static unsigned Bit(const T &V) {\n    unsigned BitPos = (unsigned)V;\n    assert(BitPos < sizeof(unsigned) * CHAR_BIT &&\n           \"enum exceeds width of bit vector!\");\n    return 1 << BitPos;\n  }\n\npublic:\n  template <class T> void addValue(const T &V) { Bits |= Bit(V); }\n\n  unsigned getBits() { return Bits; }\n\n  template <class T> bool isSet(const T &V) { return (Bits & Bit(V)) != 0; }\n};\n\n//===----------------------------------------------------------------------===//\n// bits - A bit vector of command options.\n//\ntemplate <class DataType, class Storage = bool,\n          class ParserClass = parser<DataType>>\nclass bits : public Option, public bits_storage<DataType, Storage> {\n  std::vector<unsigned> Positions;\n  ParserClass Parser;\n\n  enum ValueExpected getValueExpectedFlagDefault() const override {\n    return Parser.getValueExpectedFlagDefault();\n  }\n\n  void getExtraOptionNames(SmallVectorImpl<StringRef> &OptionNames) override {\n    return Parser.getExtraOptionNames(OptionNames);\n  }\n\n  bool handleOccurrence(unsigned pos, StringRef ArgName,\n                        StringRef Arg) override {\n    typename ParserClass::parser_data_type Val =\n        typename ParserClass::parser_data_type();\n    if (Parser.parse(*this, ArgName, Arg, Val))\n      return true; // Parse Error!\n    this->addValue(Val);\n    setPosition(pos);\n    Positions.push_back(pos);\n    Callback(Val);\n    return false;\n  }\n\n  // Forward printing stuff to the parser...\n  size_t getOptionWidth() const override {\n    return Parser.getOptionWidth(*this);\n  }\n\n  void printOptionInfo(size_t GlobalWidth) const override {\n    Parser.printOptionInfo(*this, GlobalWidth);\n  }\n\n  // Unimplemented: bits options don't currently store their default values.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override {}\n\n  void done() {\n    addArgument();\n    Parser.initialize();\n  }\n\npublic:\n  // Command line options should not be copyable\n  bits(const bits &) = delete;\n  bits &operator=(const bits &) = delete;\n\n  ParserClass &getParser() { return Parser; }\n\n  unsigned getPosition(unsigned optnum) const {\n    assert(optnum < this->size() && \"Invalid option index\");\n    return Positions[optnum];\n  }\n\n  template <class... Mods>\n  explicit bits(const Mods &... Ms)\n      : Option(ZeroOrMore, NotHidden), Parser(*this) {\n    apply(this, Ms...);\n    done();\n  }\n\n  void setCallback(\n      std::function<void(const typename ParserClass::parser_data_type &)> CB) {\n    Callback = CB;\n  }\n\n  std::function<void(const typename ParserClass::parser_data_type &)> Callback =\n      [](const typename ParserClass::parser_data_type &) {};\n};\n\n//===----------------------------------------------------------------------===//\n// Aliased command line option (alias this name to a preexisting name)\n//\n\nclass alias : public Option {\n  Option *AliasFor;\n\n  bool handleOccurrence(unsigned pos, StringRef /*ArgName*/,\n                        StringRef Arg) override {\n    return AliasFor->handleOccurrence(pos, AliasFor->ArgStr, Arg);\n  }\n\n  bool addOccurrence(unsigned pos, StringRef /*ArgName*/, StringRef Value,\n                     bool MultiArg = false) override {\n    return AliasFor->addOccurrence(pos, AliasFor->ArgStr, Value, MultiArg);\n  }\n\n  // Handle printing stuff...\n  size_t getOptionWidth() const override;\n  void printOptionInfo(size_t GlobalWidth) const override;\n\n  // Aliases do not need to print their values.\n  void printOptionValue(size_t /*GlobalWidth*/, bool /*Force*/) const override {\n  }\n\n  void setDefault() override { AliasFor->setDefault(); }\n\n  ValueExpected getValueExpectedFlagDefault() const override {\n    return AliasFor->getValueExpectedFlag();\n  }\n\n  void done() {\n    if (!hasArgStr())\n      error(\"cl::alias must have argument name specified!\");\n    if (!AliasFor)\n      error(\"cl::alias must have an cl::aliasopt(option) specified!\");\n    if (!Subs.empty())\n      error(\"cl::alias must not have cl::sub(), aliased option's cl::sub() will be used!\");\n    Subs = AliasFor->Subs;\n    Categories = AliasFor->Categories;\n    addArgument();\n  }\n\npublic:\n  // Command line options should not be copyable\n  alias(const alias &) = delete;\n  alias &operator=(const alias &) = delete;\n\n  void setAliasFor(Option &O) {\n    if (AliasFor)\n      error(\"cl::alias must only have one cl::aliasopt(...) specified!\");\n    AliasFor = &O;\n  }\n\n  template <class... Mods>\n  explicit alias(const Mods &... Ms)\n      : Option(Optional, Hidden), AliasFor(nullptr) {\n    apply(this, Ms...);\n    done();\n  }\n};\n\n// aliasfor - Modifier to set the option an alias aliases.\nstruct aliasopt {\n  Option &Opt;\n\n  explicit aliasopt(Option &O) : Opt(O) {}\n\n  void apply(alias &A) const { A.setAliasFor(Opt); }\n};\n\n// extrahelp - provide additional help at the end of the normal help\n// output. All occurrences of cl::extrahelp will be accumulated and\n// printed to stderr at the end of the regular help, just before\n// exit is called.\nstruct extrahelp {\n  StringRef morehelp;\n\n  explicit extrahelp(StringRef help);\n};\n\nvoid PrintVersionMessage();\n\n/// This function just prints the help message, exactly the same way as if the\n/// -help or -help-hidden option had been given on the command line.\n///\n/// \\param Hidden if true will print hidden options\n/// \\param Categorized if true print options in categories\nvoid PrintHelpMessage(bool Hidden = false, bool Categorized = false);\n\n//===----------------------------------------------------------------------===//\n// Public interface for accessing registered options.\n//\n\n/// Use this to get a StringMap to all registered named options\n/// (e.g. -help).\n///\n/// \\return A reference to the StringMap used by the cl APIs to parse options.\n///\n/// Access to unnamed arguments (i.e. positional) are not provided because\n/// it is expected that the client already has access to these.\n///\n/// Typical usage:\n/// \\code\n/// main(int argc,char* argv[]) {\n/// StringMap<llvm::cl::Option*> &opts = llvm::cl::getRegisteredOptions();\n/// assert(opts.count(\"help\") == 1)\n/// opts[\"help\"]->setDescription(\"Show alphabetical help information\")\n/// // More code\n/// llvm::cl::ParseCommandLineOptions(argc,argv);\n/// //More code\n/// }\n/// \\endcode\n///\n/// This interface is useful for modifying options in libraries that are out of\n/// the control of the client. The options should be modified before calling\n/// llvm::cl::ParseCommandLineOptions().\n///\n/// Hopefully this API can be deprecated soon. Any situation where options need\n/// to be modified by tools or libraries should be handled by sane APIs rather\n/// than just handing around a global list.\nStringMap<Option *> &getRegisteredOptions(SubCommand &Sub = *TopLevelSubCommand);\n\n/// Use this to get all registered SubCommands from the provided parser.\n///\n/// \\return A range of all SubCommand pointers registered with the parser.\n///\n/// Typical usage:\n/// \\code\n/// main(int argc, char* argv[]) {\n///   llvm::cl::ParseCommandLineOptions(argc, argv);\n///   for (auto* S : llvm::cl::getRegisteredSubcommands()) {\n///     if (*S) {\n///       std::cout << \"Executing subcommand: \" << S->getName() << std::endl;\n///       // Execute some function based on the name...\n///     }\n///   }\n/// }\n/// \\endcode\n///\n/// This interface is useful for defining subcommands in libraries and\n/// the dispatch from a single point (like in the main function).\niterator_range<typename SmallPtrSet<SubCommand *, 4>::iterator>\ngetRegisteredSubcommands();\n\n//===----------------------------------------------------------------------===//\n// Standalone command line processing utilities.\n//\n\n/// Tokenizes a command line that can contain escapes and quotes.\n//\n/// The quoting rules match those used by GCC and other tools that use\n/// libiberty's buildargv() or expandargv() utilities, and do not match bash.\n/// They differ from buildargv() on treatment of backslashes that do not escape\n/// a special character to make it possible to accept most Windows file paths.\n///\n/// \\param [in] Source The string to be split on whitespace with quotes.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] MarkEOLs true if tokenizing a response file and you want end of\n/// lines and end of the response file to be marked with a nullptr string.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\nvoid TokenizeGNUCommandLine(StringRef Source, StringSaver &Saver,\n                            SmallVectorImpl<const char *> &NewArgv,\n                            bool MarkEOLs = false);\n\n/// Tokenizes a Windows command line which may contain quotes and escaped\n/// quotes.\n///\n/// See MSDN docs for CommandLineToArgvW for information on the quoting rules.\n/// http://msdn.microsoft.com/en-us/library/windows/desktop/17w5ykft(v=vs.85).aspx\n///\n/// \\param [in] Source The string to be split on whitespace with quotes.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] MarkEOLs true if tokenizing a response file and you want end of\n/// lines and end of the response file to be marked with a nullptr string.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\nvoid TokenizeWindowsCommandLine(StringRef Source, StringSaver &Saver,\n                                SmallVectorImpl<const char *> &NewArgv,\n                                bool MarkEOLs = false);\n\n/// Tokenizes a Windows command line while attempting to avoid copies. If no\n/// quoting or escaping was used, this produces substrings of the original\n/// string. If a token requires unquoting, it will be allocated with the\n/// StringSaver.\nvoid TokenizeWindowsCommandLineNoCopy(StringRef Source, StringSaver &Saver,\n                                      SmallVectorImpl<StringRef> &NewArgv);\n\n/// String tokenization function type.  Should be compatible with either\n/// Windows or Unix command line tokenizers.\nusing TokenizerCallback = void (*)(StringRef Source, StringSaver &Saver,\n                                   SmallVectorImpl<const char *> &NewArgv,\n                                   bool MarkEOLs);\n\n/// Tokenizes content of configuration file.\n///\n/// \\param [in] Source The string representing content of config file.\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [out] NewArgv All parsed strings are appended to NewArgv.\n/// \\param [in] MarkEOLs Added for compatibility with TokenizerCallback.\n///\n/// It works like TokenizeGNUCommandLine with ability to skip comment lines.\n///\nvoid tokenizeConfigFile(StringRef Source, StringSaver &Saver,\n                        SmallVectorImpl<const char *> &NewArgv,\n                        bool MarkEOLs = false);\n\n/// Reads command line options from the given configuration file.\n///\n/// \\param [in] CfgFileName Path to configuration file.\n/// \\param [in] Saver  Objects that saves allocated strings.\n/// \\param [out] Argv Array to which the read options are added.\n/// \\return true if the file was successfully read.\n///\n/// It reads content of the specified file, tokenizes it and expands \"@file\"\n/// commands resolving file names in them relative to the directory where\n/// CfgFilename resides.\n///\nbool readConfigFile(StringRef CfgFileName, StringSaver &Saver,\n                    SmallVectorImpl<const char *> &Argv);\n\n/// Expand response files on a command line recursively using the given\n/// StringSaver and tokenization strategy.  Argv should contain the command line\n/// before expansion and will be modified in place. If requested, Argv will\n/// also be populated with nullptrs indicating where each response file line\n/// ends, which is useful for the \"/link\" argument that needs to consume all\n/// remaining arguments only until the next end of line, when in a response\n/// file.\n///\n/// \\param [in] Saver Delegates back to the caller for saving parsed strings.\n/// \\param [in] Tokenizer Tokenization strategy. Typically Unix or Windows.\n/// \\param [in,out] Argv Command line into which to expand response files.\n/// \\param [in] MarkEOLs Mark end of lines and the end of the response file\n/// with nullptrs in the Argv vector.\n/// \\param [in] RelativeNames true if names of nested response files must be\n/// resolved relative to including file.\n/// \\param [in] FS File system used for all file access when running the tool.\n/// \\param [in] CurrentDir Path used to resolve relative rsp files. If set to\n/// None, process' cwd is used instead.\n/// \\return true if all @files were expanded successfully or there were none.\nbool ExpandResponseFiles(\n    StringSaver &Saver, TokenizerCallback Tokenizer,\n    SmallVectorImpl<const char *> &Argv, bool MarkEOLs = false,\n    bool RelativeNames = false,\n    llvm::vfs::FileSystem &FS = *llvm::vfs::getRealFileSystem(),\n    llvm::Optional<llvm::StringRef> CurrentDir = llvm::None);\n\n/// A convenience helper which concatenates the options specified by the\n/// environment variable EnvVar and command line options, then expands response\n/// files recursively. The tokenizer is a predefined GNU or Windows one.\n/// \\return true if all @files were expanded successfully or there were none.\nbool expandResponseFiles(int Argc, const char *const *Argv, const char *EnvVar,\n                         StringSaver &Saver,\n                         SmallVectorImpl<const char *> &NewArgv);\n\n/// Mark all options not part of this category as cl::ReallyHidden.\n///\n/// \\param Category the category of options to keep displaying\n///\n/// Some tools (like clang-format) like to be able to hide all options that are\n/// not specific to the tool. This function allows a tool to specify a single\n/// option category to display in the -help output.\nvoid HideUnrelatedOptions(cl::OptionCategory &Category,\n                          SubCommand &Sub = *TopLevelSubCommand);\n\n/// Mark all options not part of the categories as cl::ReallyHidden.\n///\n/// \\param Categories the categories of options to keep displaying.\n///\n/// Some tools (like clang-format) like to be able to hide all options that are\n/// not specific to the tool. This function allows a tool to specify a single\n/// option category to display in the -help output.\nvoid HideUnrelatedOptions(ArrayRef<const cl::OptionCategory *> Categories,\n                          SubCommand &Sub = *TopLevelSubCommand);\n\n/// Reset all command line options to a state that looks as if they have\n/// never appeared on the command line.  This is useful for being able to parse\n/// a command line multiple times (especially useful for writing tests).\nvoid ResetAllOptionOccurrences();\n\n/// Reset the command line parser back to its initial state.  This\n/// removes\n/// all options, categories, and subcommands and returns the parser to a state\n/// where no options are supported.\nvoid ResetCommandLineParser();\n\n/// Parses `Arg` into the option handler `Handler`.\nbool ProvidePositionalOption(Option *Handler, StringRef Arg, int i);\n\n} // end namespace cl\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_COMMANDLINE_H\n"}, "74": {"id": 74, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "content": "//===- llvm/Support/FileSystem.h - File System OS Concept -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the llvm::sys::fs namespace. It is designed after\n// TR2/boost filesystem (v3), but modified to remove exception handling and the\n// path class.\n//\n// All functions return an error_code and their actual work via the last out\n// argument. The out argument is defined if and only if errc::success is\n// returned. A function may return any error code in the generic or system\n// category. However, they shall be equivalent to any error conditions listed\n// in each functions respective documentation if the condition applies. [ note:\n// this does not guarantee that error_code will be in the set of explicitly\n// listed codes, but it does guarantee that if any of the explicitly listed\n// errors occur, the correct error_code will be used ]. All functions may\n// return errc::not_enough_memory if there is not enough memory to complete the\n// operation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_FILESYSTEM_H\n#define LLVM_SUPPORT_FILESYSTEM_H\n\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/Support/Chrono.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/FileSystem/UniqueID.h\"\n#include \"llvm/Support/MD5.h\"\n#include <cassert>\n#include <cstdint>\n#include <ctime>\n#include <memory>\n#include <stack>\n#include <string>\n#include <system_error>\n#include <vector>\n\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n\nnamespace llvm {\nnamespace sys {\nnamespace fs {\n\n#if defined(_WIN32)\n// A Win32 HANDLE is a typedef of void*\nusing file_t = void *;\n#else\nusing file_t = int;\n#endif\n\nextern const file_t kInvalidFile;\n\n/// An enumeration for the file system's view of the type.\nenum class file_type {\n  status_error,\n  file_not_found,\n  regular_file,\n  directory_file,\n  symlink_file,\n  block_file,\n  character_file,\n  fifo_file,\n  socket_file,\n  type_unknown\n};\n\n/// space_info - Self explanatory.\nstruct space_info {\n  uint64_t capacity;\n  uint64_t free;\n  uint64_t available;\n};\n\nenum perms {\n  no_perms = 0,\n  owner_read = 0400,\n  owner_write = 0200,\n  owner_exe = 0100,\n  owner_all = owner_read | owner_write | owner_exe,\n  group_read = 040,\n  group_write = 020,\n  group_exe = 010,\n  group_all = group_read | group_write | group_exe,\n  others_read = 04,\n  others_write = 02,\n  others_exe = 01,\n  others_all = others_read | others_write | others_exe,\n  all_read = owner_read | group_read | others_read,\n  all_write = owner_write | group_write | others_write,\n  all_exe = owner_exe | group_exe | others_exe,\n  all_all = owner_all | group_all | others_all,\n  set_uid_on_exe = 04000,\n  set_gid_on_exe = 02000,\n  sticky_bit = 01000,\n  all_perms = all_all | set_uid_on_exe | set_gid_on_exe | sticky_bit,\n  perms_not_known = 0xFFFF\n};\n\n// Helper functions so that you can use & and | to manipulate perms bits:\ninline perms operator|(perms l, perms r) {\n  return static_cast<perms>(static_cast<unsigned short>(l) |\n                            static_cast<unsigned short>(r));\n}\ninline perms operator&(perms l, perms r) {\n  return static_cast<perms>(static_cast<unsigned short>(l) &\n                            static_cast<unsigned short>(r));\n}\ninline perms &operator|=(perms &l, perms r) {\n  l = l | r;\n  return l;\n}\ninline perms &operator&=(perms &l, perms r) {\n  l = l & r;\n  return l;\n}\ninline perms operator~(perms x) {\n  // Avoid UB by explicitly truncating the (unsigned) ~ result.\n  return static_cast<perms>(\n      static_cast<unsigned short>(~static_cast<unsigned short>(x)));\n}\n\n/// Represents the result of a call to directory_iterator::status(). This is a\n/// subset of the information returned by a regular sys::fs::status() call, and\n/// represents the information provided by Windows FileFirstFile/FindNextFile.\nclass basic_file_status {\nprotected:\n  #if defined(LLVM_ON_UNIX)\n  time_t fs_st_atime = 0;\n  time_t fs_st_mtime = 0;\n  uint32_t fs_st_atime_nsec = 0;\n  uint32_t fs_st_mtime_nsec = 0;\n  uid_t fs_st_uid = 0;\n  gid_t fs_st_gid = 0;\n  off_t fs_st_size = 0;\n  #elif defined (_WIN32)\n  uint32_t LastAccessedTimeHigh = 0;\n  uint32_t LastAccessedTimeLow = 0;\n  uint32_t LastWriteTimeHigh = 0;\n  uint32_t LastWriteTimeLow = 0;\n  uint32_t FileSizeHigh = 0;\n  uint32_t FileSizeLow = 0;\n  #endif\n  file_type Type = file_type::status_error;\n  perms Perms = perms_not_known;\n\npublic:\n  basic_file_status() = default;\n\n  explicit basic_file_status(file_type Type) : Type(Type) {}\n\n  #if defined(LLVM_ON_UNIX)\n  basic_file_status(file_type Type, perms Perms, time_t ATime,\n                    uint32_t ATimeNSec, time_t MTime, uint32_t MTimeNSec,\n                    uid_t UID, gid_t GID, off_t Size)\n      : fs_st_atime(ATime), fs_st_mtime(MTime),\n        fs_st_atime_nsec(ATimeNSec), fs_st_mtime_nsec(MTimeNSec),\n        fs_st_uid(UID), fs_st_gid(GID),\n        fs_st_size(Size), Type(Type), Perms(Perms) {}\n#elif defined(_WIN32)\n  basic_file_status(file_type Type, perms Perms, uint32_t LastAccessTimeHigh,\n                    uint32_t LastAccessTimeLow, uint32_t LastWriteTimeHigh,\n                    uint32_t LastWriteTimeLow, uint32_t FileSizeHigh,\n                    uint32_t FileSizeLow)\n      : LastAccessedTimeHigh(LastAccessTimeHigh),\n        LastAccessedTimeLow(LastAccessTimeLow),\n        LastWriteTimeHigh(LastWriteTimeHigh),\n        LastWriteTimeLow(LastWriteTimeLow), FileSizeHigh(FileSizeHigh),\n        FileSizeLow(FileSizeLow), Type(Type), Perms(Perms) {}\n  #endif\n\n  // getters\n  file_type type() const { return Type; }\n  perms permissions() const { return Perms; }\n\n  /// The file access time as reported from the underlying file system.\n  ///\n  /// Also see comments on \\c getLastModificationTime() related to the precision\n  /// of the returned value.\n  TimePoint<> getLastAccessedTime() const;\n\n  /// The file modification time as reported from the underlying file system.\n  ///\n  /// The returned value allows for nanosecond precision but the actual\n  /// resolution is an implementation detail of the underlying file system.\n  /// There is no guarantee for what kind of resolution you can expect, the\n  /// resolution can differ across platforms and even across mountpoints on the\n  /// same machine.\n  TimePoint<> getLastModificationTime() const;\n\n  #if defined(LLVM_ON_UNIX)\n  uint32_t getUser() const { return fs_st_uid; }\n  uint32_t getGroup() const { return fs_st_gid; }\n  uint64_t getSize() const { return fs_st_size; }\n  #elif defined (_WIN32)\n  uint32_t getUser() const {\n    return 9999; // Not applicable to Windows, so...\n  }\n\n  uint32_t getGroup() const {\n    return 9999; // Not applicable to Windows, so...\n  }\n\n  uint64_t getSize() const {\n    return (uint64_t(FileSizeHigh) << 32) + FileSizeLow;\n  }\n  #endif\n\n  // setters\n  void type(file_type v) { Type = v; }\n  void permissions(perms p) { Perms = p; }\n};\n\n/// Represents the result of a call to sys::fs::status().\nclass file_status : public basic_file_status {\n  friend bool equivalent(file_status A, file_status B);\n\n  #if defined(LLVM_ON_UNIX)\n  dev_t fs_st_dev = 0;\n  nlink_t fs_st_nlinks = 0;\n  ino_t fs_st_ino = 0;\n  #elif defined (_WIN32)\n  uint32_t NumLinks = 0;\n  uint32_t VolumeSerialNumber = 0;\n  uint32_t FileIndexHigh = 0;\n  uint32_t FileIndexLow = 0;\n  #endif\n\npublic:\n  file_status() = default;\n\n  explicit file_status(file_type Type) : basic_file_status(Type) {}\n\n  #if defined(LLVM_ON_UNIX)\n  file_status(file_type Type, perms Perms, dev_t Dev, nlink_t Links, ino_t Ino,\n              time_t ATime, uint32_t ATimeNSec,\n              time_t MTime, uint32_t MTimeNSec,\n              uid_t UID, gid_t GID, off_t Size)\n      : basic_file_status(Type, Perms, ATime, ATimeNSec, MTime, MTimeNSec,\n                          UID, GID, Size),\n        fs_st_dev(Dev), fs_st_nlinks(Links), fs_st_ino(Ino) {}\n  #elif defined(_WIN32)\n  file_status(file_type Type, perms Perms, uint32_t LinkCount,\n              uint32_t LastAccessTimeHigh, uint32_t LastAccessTimeLow,\n              uint32_t LastWriteTimeHigh, uint32_t LastWriteTimeLow,\n              uint32_t VolumeSerialNumber, uint32_t FileSizeHigh,\n              uint32_t FileSizeLow, uint32_t FileIndexHigh,\n              uint32_t FileIndexLow)\n      : basic_file_status(Type, Perms, LastAccessTimeHigh, LastAccessTimeLow,\n                          LastWriteTimeHigh, LastWriteTimeLow, FileSizeHigh,\n                          FileSizeLow),\n        NumLinks(LinkCount), VolumeSerialNumber(VolumeSerialNumber),\n        FileIndexHigh(FileIndexHigh), FileIndexLow(FileIndexLow) {}\n  #endif\n\n  UniqueID getUniqueID() const;\n  uint32_t getLinkCount() const;\n};\n\n/// @}\n/// @name Physical Operators\n/// @{\n\n/// Make \\a path an absolute path.\n///\n/// Makes \\a path absolute using the \\a current_directory if it is not already.\n/// An empty \\a path will result in the \\a current_directory.\n///\n/// /absolute/path   => /absolute/path\n/// relative/../path => <current-directory>/relative/../path\n///\n/// @param path A path that is modified to be an absolute path.\nvoid make_absolute(const Twine &current_directory, SmallVectorImpl<char> &path);\n\n/// Make \\a path an absolute path.\n///\n/// Makes \\a path absolute using the current directory if it is not already. An\n/// empty \\a path will result in the current directory.\n///\n/// /absolute/path   => /absolute/path\n/// relative/../path => <current-directory>/relative/../path\n///\n/// @param path A path that is modified to be an absolute path.\n/// @returns errc::success if \\a path has been made absolute, otherwise a\n///          platform-specific error_code.\nstd::error_code make_absolute(SmallVectorImpl<char> &path);\n\n/// Create all the non-existent directories in path.\n///\n/// @param path Directories to create.\n/// @returns errc::success if is_directory(path), otherwise a platform\n///          specific error_code. If IgnoreExisting is false, also returns\n///          error if the directory already existed.\nstd::error_code create_directories(const Twine &path,\n                                   bool IgnoreExisting = true,\n                                   perms Perms = owner_all | group_all);\n\n/// Create the directory in path.\n///\n/// @param path Directory to create.\n/// @returns errc::success if is_directory(path), otherwise a platform\n///          specific error_code. If IgnoreExisting is false, also returns\n///          error if the directory already existed.\nstd::error_code create_directory(const Twine &path, bool IgnoreExisting = true,\n                                 perms Perms = owner_all | group_all);\n\n/// Create a link from \\a from to \\a to.\n///\n/// The link may be a soft or a hard link, depending on the platform. The caller\n/// may not assume which one. Currently on windows it creates a hard link since\n/// soft links require extra privileges. On unix, it creates a soft link since\n/// hard links don't work on SMB file systems.\n///\n/// @param to The path to hard link to.\n/// @param from The path to hard link from. This is created.\n/// @returns errc::success if the link was created, otherwise a platform\n/// specific error_code.\nstd::error_code create_link(const Twine &to, const Twine &from);\n\n/// Create a hard link from \\a from to \\a to, or return an error.\n///\n/// @param to The path to hard link to.\n/// @param from The path to hard link from. This is created.\n/// @returns errc::success if the link was created, otherwise a platform\n/// specific error_code.\nstd::error_code create_hard_link(const Twine &to, const Twine &from);\n\n/// Collapse all . and .. patterns, resolve all symlinks, and optionally\n///        expand ~ expressions to the user's home directory.\n///\n/// @param path The path to resolve.\n/// @param output The location to store the resolved path.\n/// @param expand_tilde If true, resolves ~ expressions to the user's home\n///                     directory.\nstd::error_code real_path(const Twine &path, SmallVectorImpl<char> &output,\n                          bool expand_tilde = false);\n\n/// Expands ~ expressions to the user's home directory. On Unix ~user\n/// directories are resolved as well.\n///\n/// @param path The path to resolve.\nvoid expand_tilde(const Twine &path, SmallVectorImpl<char> &output);\n\n/// Get the current path.\n///\n/// @param result Holds the current path on return.\n/// @returns errc::success if the current path has been stored in result,\n///          otherwise a platform-specific error_code.\nstd::error_code current_path(SmallVectorImpl<char> &result);\n\n/// Set the current path.\n///\n/// @param path The path to set.\n/// @returns errc::success if the current path was successfully set,\n///          otherwise a platform-specific error_code.\nstd::error_code set_current_path(const Twine &path);\n\n/// Remove path. Equivalent to POSIX remove().\n///\n/// @param path Input path.\n/// @returns errc::success if path has been removed or didn't exist, otherwise a\n///          platform-specific error code. If IgnoreNonExisting is false, also\n///          returns error if the file didn't exist.\nstd::error_code remove(const Twine &path, bool IgnoreNonExisting = true);\n\n/// Recursively delete a directory.\n///\n/// @param path Input path.\n/// @returns errc::success if path has been removed or didn't exist, otherwise a\n///          platform-specific error code.\nstd::error_code remove_directories(const Twine &path, bool IgnoreErrors = true);\n\n/// Rename \\a from to \\a to.\n///\n/// Files are renamed as if by POSIX rename(), except that on Windows there may\n/// be a short interval of time during which the destination file does not\n/// exist.\n///\n/// @param from The path to rename from.\n/// @param to The path to rename to. This is created.\nstd::error_code rename(const Twine &from, const Twine &to);\n\n/// Copy the contents of \\a From to \\a To.\n///\n/// @param From The path to copy from.\n/// @param To The path to copy to. This is created.\nstd::error_code copy_file(const Twine &From, const Twine &To);\n\n/// Copy the contents of \\a From to \\a To.\n///\n/// @param From The path to copy from.\n/// @param ToFD The open file descriptor of the destination file.\nstd::error_code copy_file(const Twine &From, int ToFD);\n\n/// Resize path to size. File is resized as if by POSIX truncate().\n///\n/// @param FD Input file descriptor.\n/// @param Size Size to resize to.\n/// @returns errc::success if \\a path has been resized to \\a size, otherwise a\n///          platform-specific error_code.\nstd::error_code resize_file(int FD, uint64_t Size);\n\n/// Compute an MD5 hash of a file's contents.\n///\n/// @param FD Input file descriptor.\n/// @returns An MD5Result with the hash computed, if successful, otherwise a\n///          std::error_code.\nErrorOr<MD5::MD5Result> md5_contents(int FD);\n\n/// Version of compute_md5 that doesn't require an open file descriptor.\nErrorOr<MD5::MD5Result> md5_contents(const Twine &Path);\n\n/// @}\n/// @name Physical Observers\n/// @{\n\n/// Does file exist?\n///\n/// @param status A basic_file_status previously returned from stat.\n/// @returns True if the file represented by status exists, false if it does\n///          not.\nbool exists(const basic_file_status &status);\n\nenum class AccessMode { Exist, Write, Execute };\n\n/// Can the file be accessed?\n///\n/// @param Path Input path.\n/// @returns errc::success if the path can be accessed, otherwise a\n///          platform-specific error_code.\nstd::error_code access(const Twine &Path, AccessMode Mode);\n\n/// Does file exist?\n///\n/// @param Path Input path.\n/// @returns True if it exists, false otherwise.\ninline bool exists(const Twine &Path) {\n  return !access(Path, AccessMode::Exist);\n}\n\n/// Can we execute this file?\n///\n/// @param Path Input path.\n/// @returns True if we can execute it, false otherwise.\nbool can_execute(const Twine &Path);\n\n/// Can we write this file?\n///\n/// @param Path Input path.\n/// @returns True if we can write to it, false otherwise.\ninline bool can_write(const Twine &Path) {\n  return !access(Path, AccessMode::Write);\n}\n\n/// Do file_status's represent the same thing?\n///\n/// @param A Input file_status.\n/// @param B Input file_status.\n///\n/// assert(status_known(A) || status_known(B));\n///\n/// @returns True if A and B both represent the same file system entity, false\n///          otherwise.\nbool equivalent(file_status A, file_status B);\n\n/// Do paths represent the same thing?\n///\n/// assert(status_known(A) || status_known(B));\n///\n/// @param A Input path A.\n/// @param B Input path B.\n/// @param result Set to true if stat(A) and stat(B) have the same device and\n///               inode (or equivalent).\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code equivalent(const Twine &A, const Twine &B, bool &result);\n\n/// Simpler version of equivalent for clients that don't need to\n///        differentiate between an error and false.\ninline bool equivalent(const Twine &A, const Twine &B) {\n  bool result;\n  return !equivalent(A, B, result) && result;\n}\n\n/// Is the file mounted on a local filesystem?\n///\n/// @param path Input path.\n/// @param result Set to true if \\a path is on fixed media such as a hard disk,\n///               false if it is not.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform specific error_code.\nstd::error_code is_local(const Twine &path, bool &result);\n\n/// Version of is_local accepting an open file descriptor.\nstd::error_code is_local(int FD, bool &result);\n\n/// Simpler version of is_local for clients that don't need to\n///        differentiate between an error and false.\ninline bool is_local(const Twine &Path) {\n  bool Result;\n  return !is_local(Path, Result) && Result;\n}\n\n/// Simpler version of is_local accepting an open file descriptor for\n///        clients that don't need to differentiate between an error and false.\ninline bool is_local(int FD) {\n  bool Result;\n  return !is_local(FD, Result) && Result;\n}\n\n/// Does status represent a directory?\n///\n/// @param Path The path to get the type of.\n/// @param Follow For symbolic links, indicates whether to return the file type\n///               of the link itself, or of the target.\n/// @returns A value from the file_type enumeration indicating the type of file.\nfile_type get_file_type(const Twine &Path, bool Follow = true);\n\n/// Does status represent a directory?\n///\n/// @param status A basic_file_status previously returned from status.\n/// @returns status.type() == file_type::directory_file.\nbool is_directory(const basic_file_status &status);\n\n/// Is path a directory?\n///\n/// @param path Input path.\n/// @param result Set to true if \\a path is a directory (after following\n///               symlinks, false if it is not. Undefined otherwise.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code is_directory(const Twine &path, bool &result);\n\n/// Simpler version of is_directory for clients that don't need to\n///        differentiate between an error and false.\ninline bool is_directory(const Twine &Path) {\n  bool Result;\n  return !is_directory(Path, Result) && Result;\n}\n\n/// Does status represent a regular file?\n///\n/// @param status A basic_file_status previously returned from status.\n/// @returns status_known(status) && status.type() == file_type::regular_file.\nbool is_regular_file(const basic_file_status &status);\n\n/// Is path a regular file?\n///\n/// @param path Input path.\n/// @param result Set to true if \\a path is a regular file (after following\n///               symlinks), false if it is not. Undefined otherwise.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code is_regular_file(const Twine &path, bool &result);\n\n/// Simpler version of is_regular_file for clients that don't need to\n///        differentiate between an error and false.\ninline bool is_regular_file(const Twine &Path) {\n  bool Result;\n  if (is_regular_file(Path, Result))\n    return false;\n  return Result;\n}\n\n/// Does status represent a symlink file?\n///\n/// @param status A basic_file_status previously returned from status.\n/// @returns status_known(status) && status.type() == file_type::symlink_file.\nbool is_symlink_file(const basic_file_status &status);\n\n/// Is path a symlink file?\n///\n/// @param path Input path.\n/// @param result Set to true if \\a path is a symlink file, false if it is not.\n///               Undefined otherwise.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code is_symlink_file(const Twine &path, bool &result);\n\n/// Simpler version of is_symlink_file for clients that don't need to\n///        differentiate between an error and false.\ninline bool is_symlink_file(const Twine &Path) {\n  bool Result;\n  if (is_symlink_file(Path, Result))\n    return false;\n  return Result;\n}\n\n/// Does this status represent something that exists but is not a\n///        directory or regular file?\n///\n/// @param status A basic_file_status previously returned from status.\n/// @returns exists(s) && !is_regular_file(s) && !is_directory(s)\nbool is_other(const basic_file_status &status);\n\n/// Is path something that exists but is not a directory,\n///        regular file, or symlink?\n///\n/// @param path Input path.\n/// @param result Set to true if \\a path exists, but is not a directory, regular\n///               file, or a symlink, false if it does not. Undefined otherwise.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code is_other(const Twine &path, bool &result);\n\n/// Get file status as if by POSIX stat().\n///\n/// @param path Input path.\n/// @param result Set to the file status.\n/// @param follow When true, follows symlinks.  Otherwise, the symlink itself is\n///               statted.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code status(const Twine &path, file_status &result,\n                       bool follow = true);\n\n/// A version for when a file descriptor is already available.\nstd::error_code status(int FD, file_status &Result);\n\n#ifdef _WIN32\n/// A version for when a file descriptor is already available.\nstd::error_code status(file_t FD, file_status &Result);\n#endif\n\n/// Get file creation mode mask of the process.\n///\n/// @returns Mask reported by umask(2)\n/// @note There is no umask on Windows. This function returns 0 always\n///       on Windows. This function does not return an error_code because\n///       umask(2) never fails. It is not thread safe.\nunsigned getUmask();\n\n/// Set file permissions.\n///\n/// @param Path File to set permissions on.\n/// @param Permissions New file permissions.\n/// @returns errc::success if the permissions were successfully set, otherwise\n///          a platform-specific error_code.\n/// @note On Windows, all permissions except *_write are ignored. Using any of\n///       owner_write, group_write, or all_write will make the file writable.\n///       Otherwise, the file will be marked as read-only.\nstd::error_code setPermissions(const Twine &Path, perms Permissions);\n\n/// Vesion of setPermissions accepting a file descriptor.\n/// TODO Delete the path based overload once we implement the FD based overload\n/// on Windows.\nstd::error_code setPermissions(int FD, perms Permissions);\n\n/// Get file permissions.\n///\n/// @param Path File to get permissions from.\n/// @returns the permissions if they were successfully retrieved, otherwise a\n///          platform-specific error_code.\n/// @note On Windows, if the file does not have the FILE_ATTRIBUTE_READONLY\n///       attribute, all_all will be returned. Otherwise, all_read | all_exe\n///       will be returned.\nErrorOr<perms> getPermissions(const Twine &Path);\n\n/// Get file size.\n///\n/// @param Path Input path.\n/// @param Result Set to the size of the file in \\a Path.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\ninline std::error_code file_size(const Twine &Path, uint64_t &Result) {\n  file_status Status;\n  std::error_code EC = status(Path, Status);\n  if (EC)\n    return EC;\n  Result = Status.getSize();\n  return std::error_code();\n}\n\n/// Set the file modification and access time.\n///\n/// @returns errc::success if the file times were successfully set, otherwise a\n///          platform-specific error_code or errc::function_not_supported on\n///          platforms where the functionality isn't available.\nstd::error_code setLastAccessAndModificationTime(int FD, TimePoint<> AccessTime,\n                                                 TimePoint<> ModificationTime);\n\n/// Simpler version that sets both file modification and access time to the same\n/// time.\ninline std::error_code setLastAccessAndModificationTime(int FD,\n                                                        TimePoint<> Time) {\n  return setLastAccessAndModificationTime(FD, Time, Time);\n}\n\n/// Is status available?\n///\n/// @param s Input file status.\n/// @returns True if status() != status_error.\nbool status_known(const basic_file_status &s);\n\n/// Is status available?\n///\n/// @param path Input path.\n/// @param result Set to true if status() != status_error.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code status_known(const Twine &path, bool &result);\n\nenum CreationDisposition : unsigned {\n  /// CD_CreateAlways - When opening a file:\n  ///   * If it already exists, truncate it.\n  ///   * If it does not already exist, create a new file.\n  CD_CreateAlways = 0,\n\n  /// CD_CreateNew - When opening a file:\n  ///   * If it already exists, fail.\n  ///   * If it does not already exist, create a new file.\n  CD_CreateNew = 1,\n\n  /// CD_OpenExisting - When opening a file:\n  ///   * If it already exists, open the file with the offset set to 0.\n  ///   * If it does not already exist, fail.\n  CD_OpenExisting = 2,\n\n  /// CD_OpenAlways - When opening a file:\n  ///   * If it already exists, open the file with the offset set to 0.\n  ///   * If it does not already exist, create a new file.\n  CD_OpenAlways = 3,\n};\n\nenum FileAccess : unsigned {\n  FA_Read = 1,\n  FA_Write = 2,\n};\n\nenum OpenFlags : unsigned {\n  OF_None = 0,\n  F_None = 0, // For compatibility\n\n  /// The file should be opened in text mode on platforms that make this\n  /// distinction.\n  OF_Text = 1,\n  F_Text = 1, // For compatibility\n\n  /// The file should be opened in append mode.\n  OF_Append = 2,\n  F_Append = 2, // For compatibility\n\n  /// Delete the file on close. Only makes a difference on windows.\n  OF_Delete = 4,\n\n  /// When a child process is launched, this file should remain open in the\n  /// child process.\n  OF_ChildInherit = 8,\n\n  /// Force files Atime to be updated on access. Only makes a difference on windows.\n  OF_UpdateAtime = 16,\n};\n\n/// Create a potentially unique file name but does not create it.\n///\n/// Generates a unique path suitable for a temporary file but does not\n/// open or create the file. The name is based on \\a Model with '%'\n/// replaced by a random char in [0-9a-f]. If \\a MakeAbsolute is true\n/// then the system's temp directory is prepended first. If \\a MakeAbsolute\n/// is false the current directory will be used instead.\n///\n/// This function does not check if the file exists. If you want to be sure\n/// that the file does not yet exist, you should use use enough '%' characters\n/// in your model to ensure this. Each '%' gives 4-bits of entropy so you can\n/// use 32 of them to get 128 bits of entropy.\n///\n/// Example: clang-%%-%%-%%-%%-%%.s => clang-a0-b1-c2-d3-e4.s\n///\n/// @param Model Name to base unique path off of.\n/// @param ResultPath Set to the file's path.\n/// @param MakeAbsolute Whether to use the system temp directory.\nvoid createUniquePath(const Twine &Model, SmallVectorImpl<char> &ResultPath,\n                      bool MakeAbsolute);\n\n/// Create a uniquely named file.\n///\n/// Generates a unique path suitable for a temporary file and then opens it as a\n/// file. The name is based on \\a Model with '%' replaced by a random char in\n/// [0-9a-f]. If \\a Model is not an absolute path, the temporary file will be\n/// created in the current directory.\n///\n/// Example: clang-%%-%%-%%-%%-%%.s => clang-a0-b1-c2-d3-e4.s\n///\n/// This is an atomic operation. Either the file is created and opened, or the\n/// file system is left untouched.\n///\n/// The intended use is for files that are to be kept, possibly after\n/// renaming them. For example, when running 'clang -c foo.o', the file can\n/// be first created as foo-abc123.o and then renamed.\n///\n/// @param Model Name to base unique path off of.\n/// @param ResultFD Set to the opened file's file descriptor.\n/// @param ResultPath Set to the opened file's absolute path.\n/// @returns errc::success if Result{FD,Path} have been successfully set,\n///          otherwise a platform-specific error_code.\nstd::error_code createUniqueFile(const Twine &Model, int &ResultFD,\n                                 SmallVectorImpl<char> &ResultPath,\n                                 unsigned Mode = all_read | all_write);\n\n/// Simpler version for clients that don't want an open file. An empty\n/// file will still be created.\nstd::error_code createUniqueFile(const Twine &Model,\n                                 SmallVectorImpl<char> &ResultPath,\n                                 unsigned Mode = all_read | all_write);\n\n/// Represents a temporary file.\n///\n/// The temporary file must be eventually discarded or given a final name and\n/// kept.\n///\n/// The destructor doesn't implicitly discard because there is no way to\n/// properly handle errors in a destructor.\nclass TempFile {\n  bool Done = false;\n  TempFile(StringRef Name, int FD);\n\npublic:\n  /// This creates a temporary file with createUniqueFile and schedules it for\n  /// deletion with sys::RemoveFileOnSignal.\n  static Expected<TempFile> create(const Twine &Model,\n                                   unsigned Mode = all_read | all_write);\n  TempFile(TempFile &&Other);\n  TempFile &operator=(TempFile &&Other);\n\n  // Name of the temporary file.\n  std::string TmpName;\n\n  // The open file descriptor.\n  int FD = -1;\n\n  // Keep this with the given name.\n  Error keep(const Twine &Name);\n\n  // Keep this with the temporary name.\n  Error keep();\n\n  // Delete the file.\n  Error discard();\n\n  // This checks that keep or delete was called.\n  ~TempFile();\n};\n\n/// Create a file in the system temporary directory.\n///\n/// The filename is of the form prefix-random_chars.suffix. Since the directory\n/// is not know to the caller, Prefix and Suffix cannot have path separators.\n/// The files are created with mode 0600.\n///\n/// This should be used for things like a temporary .s that is removed after\n/// running the assembler.\nstd::error_code createTemporaryFile(const Twine &Prefix, StringRef Suffix,\n                                    int &ResultFD,\n                                    SmallVectorImpl<char> &ResultPath);\n\n/// Simpler version for clients that don't want an open file. An empty\n/// file will still be created.\nstd::error_code createTemporaryFile(const Twine &Prefix, StringRef Suffix,\n                                    SmallVectorImpl<char> &ResultPath);\n\nstd::error_code createUniqueDirectory(const Twine &Prefix,\n                                      SmallVectorImpl<char> &ResultPath);\n\n/// Get a unique name, not currently exisiting in the filesystem. Subject\n/// to race conditions, prefer to use createUniqueFile instead.\n///\n/// Similar to createUniqueFile, but instead of creating a file only\n/// checks if it exists. This function is subject to race conditions, if you\n/// want to use the returned name to actually create a file, use\n/// createUniqueFile instead.\nstd::error_code getPotentiallyUniqueFileName(const Twine &Model,\n                                             SmallVectorImpl<char> &ResultPath);\n\n/// Get a unique temporary file name, not currently exisiting in the\n/// filesystem. Subject to race conditions, prefer to use createTemporaryFile\n/// instead.\n///\n/// Similar to createTemporaryFile, but instead of creating a file only\n/// checks if it exists. This function is subject to race conditions, if you\n/// want to use the returned name to actually create a file, use\n/// createTemporaryFile instead.\nstd::error_code\ngetPotentiallyUniqueTempFileName(const Twine &Prefix, StringRef Suffix,\n                                 SmallVectorImpl<char> &ResultPath);\n\ninline OpenFlags operator|(OpenFlags A, OpenFlags B) {\n  return OpenFlags(unsigned(A) | unsigned(B));\n}\n\ninline OpenFlags &operator|=(OpenFlags &A, OpenFlags B) {\n  A = A | B;\n  return A;\n}\n\ninline FileAccess operator|(FileAccess A, FileAccess B) {\n  return FileAccess(unsigned(A) | unsigned(B));\n}\n\ninline FileAccess &operator|=(FileAccess &A, FileAccess B) {\n  A = A | B;\n  return A;\n}\n\n/// @brief Opens a file with the specified creation disposition, access mode,\n/// and flags and returns a file descriptor.\n///\n/// The caller is responsible for closing the file descriptor once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param ResultFD If the file could be opened successfully, its descriptor\n///                 is stored in this location. Otherwise, this is set to -1.\n/// @param Disp Value specifying the existing-file behavior.\n/// @param Access Value specifying whether to open the file in read, write, or\n///               read-write mode.\n/// @param Flags Additional flags.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns errc::success if \\a Name has been opened, otherwise a\n///          platform-specific error_code.\nstd::error_code openFile(const Twine &Name, int &ResultFD,\n                         CreationDisposition Disp, FileAccess Access,\n                         OpenFlags Flags, unsigned Mode = 0666);\n\n/// @brief Opens a file with the specified creation disposition, access mode,\n/// and flags and returns a platform-specific file object.\n///\n/// The caller is responsible for closing the file object once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param Disp Value specifying the existing-file behavior.\n/// @param Access Value specifying whether to open the file in read, write, or\n///               read-write mode.\n/// @param Flags Additional flags.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns errc::success if \\a Name has been opened, otherwise a\n///          platform-specific error_code.\nExpected<file_t> openNativeFile(const Twine &Name, CreationDisposition Disp,\n                                FileAccess Access, OpenFlags Flags,\n                                unsigned Mode = 0666);\n\n/// Converts from a Posix file descriptor number to a native file handle.\n/// On Windows, this retreives the underlying handle. On non-Windows, this is a\n/// no-op.\nfile_t convertFDToNativeFile(int FD);\n\n#ifndef _WIN32\ninline file_t convertFDToNativeFile(int FD) { return FD; }\n#endif\n\n/// Return an open handle to standard in. On Unix, this is typically FD 0.\n/// Returns kInvalidFile when the stream is closed.\nfile_t getStdinHandle();\n\n/// Return an open handle to standard out. On Unix, this is typically FD 1.\n/// Returns kInvalidFile when the stream is closed.\nfile_t getStdoutHandle();\n\n/// Return an open handle to standard error. On Unix, this is typically FD 2.\n/// Returns kInvalidFile when the stream is closed.\nfile_t getStderrHandle();\n\n/// Reads \\p Buf.size() bytes from \\p FileHandle into \\p Buf. Returns the number\n/// of bytes actually read. On Unix, this is equivalent to `return ::read(FD,\n/// Buf.data(), Buf.size())`, with error reporting. Returns 0 when reaching EOF.\n///\n/// @param FileHandle File to read from.\n/// @param Buf Buffer to read into.\n/// @returns The number of bytes read, or error.\nExpected<size_t> readNativeFile(file_t FileHandle, MutableArrayRef<char> Buf);\n\n/// Reads \\p Buf.size() bytes from \\p FileHandle at offset \\p Offset into \\p\n/// Buf. If 'pread' is available, this will use that, otherwise it will use\n/// 'lseek'. Returns the number of bytes actually read. Returns 0 when reaching\n/// EOF.\n///\n/// @param FileHandle File to read from.\n/// @param Buf Buffer to read into.\n/// @param Offset Offset into the file at which the read should occur.\n/// @returns The number of bytes read, or error.\nExpected<size_t> readNativeFileSlice(file_t FileHandle,\n                                     MutableArrayRef<char> Buf,\n                                     uint64_t Offset);\n\n/// @brief Opens the file with the given name in a write-only or read-write\n/// mode, returning its open file descriptor. If the file does not exist, it\n/// is created.\n///\n/// The caller is responsible for closing the file descriptor once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param ResultFD If the file could be opened successfully, its descriptor\n///                 is stored in this location. Otherwise, this is set to -1.\n/// @param Flags Additional flags used to determine whether the file should be\n///              opened in, for example, read-write or in write-only mode.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns errc::success if \\a Name has been opened, otherwise a\n///          platform-specific error_code.\ninline std::error_code\nopenFileForWrite(const Twine &Name, int &ResultFD,\n                 CreationDisposition Disp = CD_CreateAlways,\n                 OpenFlags Flags = OF_None, unsigned Mode = 0666) {\n  return openFile(Name, ResultFD, Disp, FA_Write, Flags, Mode);\n}\n\n/// @brief Opens the file with the given name in a write-only or read-write\n/// mode, returning its open file descriptor. If the file does not exist, it\n/// is created.\n///\n/// The caller is responsible for closing the freeing the file once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param Flags Additional flags used to determine whether the file should be\n///              opened in, for example, read-write or in write-only mode.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns a platform-specific file descriptor if \\a Name has been opened,\n///          otherwise an error object.\ninline Expected<file_t> openNativeFileForWrite(const Twine &Name,\n                                               CreationDisposition Disp,\n                                               OpenFlags Flags,\n                                               unsigned Mode = 0666) {\n  return openNativeFile(Name, Disp, FA_Write, Flags, Mode);\n}\n\n/// @brief Opens the file with the given name in a write-only or read-write\n/// mode, returning its open file descriptor. If the file does not exist, it\n/// is created.\n///\n/// The caller is responsible for closing the file descriptor once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param ResultFD If the file could be opened successfully, its descriptor\n///                 is stored in this location. Otherwise, this is set to -1.\n/// @param Flags Additional flags used to determine whether the file should be\n///              opened in, for example, read-write or in write-only mode.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns errc::success if \\a Name has been opened, otherwise a\n///          platform-specific error_code.\ninline std::error_code openFileForReadWrite(const Twine &Name, int &ResultFD,\n                                            CreationDisposition Disp,\n                                            OpenFlags Flags,\n                                            unsigned Mode = 0666) {\n  return openFile(Name, ResultFD, Disp, FA_Write | FA_Read, Flags, Mode);\n}\n\n/// @brief Opens the file with the given name in a write-only or read-write\n/// mode, returning its open file descriptor. If the file does not exist, it\n/// is created.\n///\n/// The caller is responsible for closing the freeing the file once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param Flags Additional flags used to determine whether the file should be\n///              opened in, for example, read-write or in write-only mode.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns a platform-specific file descriptor if \\a Name has been opened,\n///          otherwise an error object.\ninline Expected<file_t> openNativeFileForReadWrite(const Twine &Name,\n                                                   CreationDisposition Disp,\n                                                   OpenFlags Flags,\n                                                   unsigned Mode = 0666) {\n  return openNativeFile(Name, Disp, FA_Write | FA_Read, Flags, Mode);\n}\n\n/// @brief Opens the file with the given name in a read-only mode, returning\n/// its open file descriptor.\n///\n/// The caller is responsible for closing the file descriptor once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param ResultFD If the file could be opened successfully, its descriptor\n///                 is stored in this location. Otherwise, this is set to -1.\n/// @param RealPath If nonnull, extra work is done to determine the real path\n///                 of the opened file, and that path is stored in this\n///                 location.\n/// @returns errc::success if \\a Name has been opened, otherwise a\n///          platform-specific error_code.\nstd::error_code openFileForRead(const Twine &Name, int &ResultFD,\n                                OpenFlags Flags = OF_None,\n                                SmallVectorImpl<char> *RealPath = nullptr);\n\n/// @brief Opens the file with the given name in a read-only mode, returning\n/// its open file descriptor.\n///\n/// The caller is responsible for closing the freeing the file once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param RealPath If nonnull, extra work is done to determine the real path\n///                 of the opened file, and that path is stored in this\n///                 location.\n/// @returns a platform-specific file descriptor if \\a Name has been opened,\n///          otherwise an error object.\nExpected<file_t>\nopenNativeFileForRead(const Twine &Name, OpenFlags Flags = OF_None,\n                      SmallVectorImpl<char> *RealPath = nullptr);\n\n/// Try to locks the file during the specified time.\n///\n/// This function implements advisory locking on entire file. If it returns\n/// <em>errc::success</em>, the file is locked by the calling process. Until the\n/// process unlocks the file by calling \\a unlockFile, all attempts to lock the\n/// same file will fail/block. The process that locked the file may assume that\n/// none of other processes read or write this file, provided that all processes\n/// lock the file prior to accessing its content.\n///\n/// @param FD      The descriptor representing the file to lock.\n/// @param Timeout Time in milliseconds that the process should wait before\n///                reporting lock failure. Zero value means try to get lock only\n///                once.\n/// @returns errc::success if lock is successfully obtained,\n/// errc::no_lock_available if the file cannot be locked, or platform-specific\n/// error_code otherwise.\n///\n/// @note Care should be taken when using this function in a multithreaded\n/// context, as it may not prevent other threads in the same process from\n/// obtaining a lock on the same file, even if they are using a different file\n/// descriptor.\nstd::error_code\ntryLockFile(int FD,\n            std::chrono::milliseconds Timeout = std::chrono::milliseconds(0));\n\n/// Lock the file.\n///\n/// This function acts as @ref tryLockFile but it waits infinitely.\nstd::error_code lockFile(int FD);\n\n/// Unlock the file.\n///\n/// @param FD The descriptor representing the file to unlock.\n/// @returns errc::success if lock is successfully released or platform-specific\n/// error_code otherwise.\nstd::error_code unlockFile(int FD);\n\n/// @brief Close the file object.  This should be used instead of ::close for\n/// portability. On error, the caller should assume the file is closed, as is\n/// the case for Process::SafelyCloseFileDescriptor\n///\n/// @param F On input, this is the file to close.  On output, the file is\n/// set to kInvalidFile.\n///\n/// @returns An error code if closing the file failed. Typically, an error here\n/// means that the filesystem may have failed to perform some buffered writes.\nstd::error_code closeFile(file_t &F);\n\n#ifdef LLVM_ON_UNIX\n/// @brief Change ownership of a file.\n///\n/// @param Owner The owner of the file to change to.\n/// @param Group The group of the file to change to.\n/// @returns errc::success if successfully updated file ownership, otherwise an\n///          error code is returned.\nstd::error_code changeFileOwnership(int FD, uint32_t Owner, uint32_t Group);\n#endif\n\n/// RAII class that facilitates file locking.\nclass FileLocker {\n  int FD; ///< Locked file handle.\n  FileLocker(int FD) : FD(FD) {}\n  friend class llvm::raw_fd_ostream;\n\npublic:\n  FileLocker(const FileLocker &L) = delete;\n  FileLocker(FileLocker &&L) : FD(L.FD) { L.FD = -1; }\n  ~FileLocker() {\n    if (FD != -1)\n      unlockFile(FD);\n  }\n  FileLocker &operator=(FileLocker &&L) {\n    FD = L.FD;\n    L.FD = -1;\n    return *this;\n  }\n  FileLocker &operator=(const FileLocker &L) = delete;\n  std::error_code unlock() {\n    if (FD != -1) {\n      std::error_code Result = unlockFile(FD);\n      FD = -1;\n      return Result;\n    }\n    return std::error_code();\n  }\n};\n\nstd::error_code getUniqueID(const Twine Path, UniqueID &Result);\n\n/// Get disk space usage information.\n///\n/// Note: Users must be careful about \"Time Of Check, Time Of Use\" kind of bug.\n/// Note: Windows reports results according to the quota allocated to the user.\n///\n/// @param Path Input path.\n/// @returns a space_info structure filled with the capacity, free, and\n/// available space on the device \\a Path is on. A platform specific error_code\n/// is returned on error.\nErrorOr<space_info> disk_space(const Twine &Path);\n\n/// This class represents a memory mapped file. It is based on\n/// boost::iostreams::mapped_file.\nclass mapped_file_region {\npublic:\n  enum mapmode {\n    readonly, ///< May only access map via const_data as read only.\n    readwrite, ///< May access map via data and modify it. Written to path.\n    priv ///< May modify via data, but changes are lost on destruction.\n  };\n\nprivate:\n  /// Platform-specific mapping state.\n  size_t Size;\n  void *Mapping;\n#ifdef _WIN32\n  sys::fs::file_t FileHandle;\n#endif\n  mapmode Mode;\n\n  std::error_code init(sys::fs::file_t FD, uint64_t Offset, mapmode Mode);\n\npublic:\n  mapped_file_region() = delete;\n  mapped_file_region(mapped_file_region&) = delete;\n  mapped_file_region &operator =(mapped_file_region&) = delete;\n\n  /// \\param fd An open file descriptor to map. Does not take ownership of fd.\n  mapped_file_region(sys::fs::file_t fd, mapmode mode, size_t length, uint64_t offset,\n                     std::error_code &ec);\n\n  ~mapped_file_region();\n\n  size_t size() const;\n  char *data() const;\n\n  /// Get a const view of the data. Modifying this memory has undefined\n  /// behavior.\n  const char *const_data() const;\n\n  /// \\returns The minimum alignment offset must be.\n  static int alignment();\n};\n\n/// Return the path to the main executable, given the value of argv[0] from\n/// program startup and the address of main itself. In extremis, this function\n/// may fail and return an empty path.\nstd::string getMainExecutable(const char *argv0, void *MainExecAddr);\n\n/// @}\n/// @name Iterators\n/// @{\n\n/// directory_entry - A single entry in a directory.\nclass directory_entry {\n  // FIXME: different platforms make different information available \"for free\"\n  // when traversing a directory. The design of this class wraps most of the\n  // information in basic_file_status, so on platforms where we can't populate\n  // that whole structure, callers end up paying for a stat().\n  // std::filesystem::directory_entry may be a better model.\n  std::string Path;\n  file_type Type = file_type::type_unknown; // Most platforms can provide this.\n  bool FollowSymlinks = true;               // Affects the behavior of status().\n  basic_file_status Status;                 // If available.\n\npublic:\n  explicit directory_entry(const Twine &Path, bool FollowSymlinks = true,\n                           file_type Type = file_type::type_unknown,\n                           basic_file_status Status = basic_file_status())\n      : Path(Path.str()), Type(Type), FollowSymlinks(FollowSymlinks),\n        Status(Status) {}\n\n  directory_entry() = default;\n\n  void replace_filename(const Twine &Filename, file_type Type,\n                        basic_file_status Status = basic_file_status());\n\n  const std::string &path() const { return Path; }\n  // Get basic information about entry file (a subset of fs::status()).\n  // On most platforms this is a stat() call.\n  // On windows the information was already retrieved from the directory.\n  ErrorOr<basic_file_status> status() const;\n  // Get the type of this file.\n  // On most platforms (Linux/Mac/Windows/BSD), this was already retrieved.\n  // On some platforms (e.g. Solaris) this is a stat() call.\n  file_type type() const {\n    if (Type != file_type::type_unknown)\n      return Type;\n    auto S = status();\n    return S ? S->type() : file_type::type_unknown;\n  }\n\n  bool operator==(const directory_entry& RHS) const { return Path == RHS.Path; }\n  bool operator!=(const directory_entry& RHS) const { return !(*this == RHS); }\n  bool operator< (const directory_entry& RHS) const;\n  bool operator<=(const directory_entry& RHS) const;\n  bool operator> (const directory_entry& RHS) const;\n  bool operator>=(const directory_entry& RHS) const;\n};\n\nnamespace detail {\n\n  struct DirIterState;\n\n  std::error_code directory_iterator_construct(DirIterState &, StringRef, bool);\n  std::error_code directory_iterator_increment(DirIterState &);\n  std::error_code directory_iterator_destruct(DirIterState &);\n\n  /// Keeps state for the directory_iterator.\n  struct DirIterState {\n    ~DirIterState() {\n      directory_iterator_destruct(*this);\n    }\n\n    intptr_t IterationHandle = 0;\n    directory_entry CurrentEntry;\n  };\n\n} // end namespace detail\n\n/// directory_iterator - Iterates through the entries in path. There is no\n/// operator++ because we need an error_code. If it's really needed we can make\n/// it call report_fatal_error on error.\nclass directory_iterator {\n  std::shared_ptr<detail::DirIterState> State;\n  bool FollowSymlinks = true;\n\npublic:\n  explicit directory_iterator(const Twine &path, std::error_code &ec,\n                              bool follow_symlinks = true)\n      : FollowSymlinks(follow_symlinks) {\n    State = std::make_shared<detail::DirIterState>();\n    SmallString<128> path_storage;\n    ec = detail::directory_iterator_construct(\n        *State, path.toStringRef(path_storage), FollowSymlinks);\n  }\n\n  explicit directory_iterator(const directory_entry &de, std::error_code &ec,\n                              bool follow_symlinks = true)\n      : FollowSymlinks(follow_symlinks) {\n    State = std::make_shared<detail::DirIterState>();\n    ec = detail::directory_iterator_construct(\n        *State, de.path(), FollowSymlinks);\n  }\n\n  /// Construct end iterator.\n  directory_iterator() = default;\n\n  // No operator++ because we need error_code.\n  directory_iterator &increment(std::error_code &ec) {\n    ec = directory_iterator_increment(*State);\n    return *this;\n  }\n\n  const directory_entry &operator*() const { return State->CurrentEntry; }\n  const directory_entry *operator->() const { return &State->CurrentEntry; }\n\n  bool operator==(const directory_iterator &RHS) const {\n    if (State == RHS.State)\n      return true;\n    if (!RHS.State)\n      return State->CurrentEntry == directory_entry();\n    if (!State)\n      return RHS.State->CurrentEntry == directory_entry();\n    return State->CurrentEntry == RHS.State->CurrentEntry;\n  }\n\n  bool operator!=(const directory_iterator &RHS) const {\n    return !(*this == RHS);\n  }\n};\n\nnamespace detail {\n\n  /// Keeps state for the recursive_directory_iterator.\n  struct RecDirIterState {\n    std::stack<directory_iterator, std::vector<directory_iterator>> Stack;\n    uint16_t Level = 0;\n    bool HasNoPushRequest = false;\n  };\n\n} // end namespace detail\n\n/// recursive_directory_iterator - Same as directory_iterator except for it\n/// recurses down into child directories.\nclass recursive_directory_iterator {\n  std::shared_ptr<detail::RecDirIterState> State;\n  bool Follow;\n\npublic:\n  recursive_directory_iterator() = default;\n  explicit recursive_directory_iterator(const Twine &path, std::error_code &ec,\n                                        bool follow_symlinks = true)\n      : State(std::make_shared<detail::RecDirIterState>()),\n        Follow(follow_symlinks) {\n    State->Stack.push(directory_iterator(path, ec, Follow));\n    if (State->Stack.top() == directory_iterator())\n      State.reset();\n  }\n\n  // No operator++ because we need error_code.\n  recursive_directory_iterator &increment(std::error_code &ec) {\n    const directory_iterator end_itr = {};\n\n    if (State->HasNoPushRequest)\n      State->HasNoPushRequest = false;\n    else {\n      file_type type = State->Stack.top()->type();\n      if (type == file_type::symlink_file && Follow) {\n        // Resolve the symlink: is it a directory to recurse into?\n        ErrorOr<basic_file_status> status = State->Stack.top()->status();\n        if (status)\n          type = status->type();\n        // Otherwise broken symlink, and we'll continue.\n      }\n      if (type == file_type::directory_file) {\n        State->Stack.push(directory_iterator(*State->Stack.top(), ec, Follow));\n        if (State->Stack.top() != end_itr) {\n          ++State->Level;\n          return *this;\n        }\n        State->Stack.pop();\n      }\n    }\n\n    while (!State->Stack.empty()\n           && State->Stack.top().increment(ec) == end_itr) {\n      State->Stack.pop();\n      --State->Level;\n    }\n\n    // Check if we are done. If so, create an end iterator.\n    if (State->Stack.empty())\n      State.reset();\n\n    return *this;\n  }\n\n  const directory_entry &operator*() const { return *State->Stack.top(); }\n  const directory_entry *operator->() const { return &*State->Stack.top(); }\n\n  // observers\n  /// Gets the current level. Starting path is at level 0.\n  int level() const { return State->Level; }\n\n  /// Returns true if no_push has been called for this directory_entry.\n  bool no_push_request() const { return State->HasNoPushRequest; }\n\n  // modifiers\n  /// Goes up one level if Level > 0.\n  void pop() {\n    assert(State && \"Cannot pop an end iterator!\");\n    assert(State->Level > 0 && \"Cannot pop an iterator with level < 1\");\n\n    const directory_iterator end_itr = {};\n    std::error_code ec;\n    do {\n      if (ec)\n        report_fatal_error(\"Error incrementing directory iterator.\");\n      State->Stack.pop();\n      --State->Level;\n    } while (!State->Stack.empty()\n             && State->Stack.top().increment(ec) == end_itr);\n\n    // Check if we are done. If so, create an end iterator.\n    if (State->Stack.empty())\n      State.reset();\n  }\n\n  /// Does not go down into the current directory_entry.\n  void no_push() { State->HasNoPushRequest = true; }\n\n  bool operator==(const recursive_directory_iterator &RHS) const {\n    return State == RHS.State;\n  }\n\n  bool operator!=(const recursive_directory_iterator &RHS) const {\n    return !(*this == RHS);\n  }\n};\n\n/// @}\n\n} // end namespace fs\n} // end namespace sys\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_FILESYSTEM_H\n"}, "75": {"id": 75, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem/UniqueID.h", "content": "//===- llvm/Support/FileSystem/UniqueID.h - UniqueID for files --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is cut out of llvm/Support/FileSystem.h to allow UniqueID to be\n// reused without bloating the includes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_FILESYSTEM_UNIQUEID_H\n#define LLVM_SUPPORT_FILESYSTEM_UNIQUEID_H\n\n#include <cstdint>\n\nnamespace llvm {\nnamespace sys {\nnamespace fs {\n\nclass UniqueID {\n  uint64_t Device;\n  uint64_t File;\n\npublic:\n  UniqueID() = default;\n  UniqueID(uint64_t Device, uint64_t File) : Device(Device), File(File) {}\n\n  bool operator==(const UniqueID &Other) const {\n    return Device == Other.Device && File == Other.File;\n  }\n  bool operator!=(const UniqueID &Other) const { return !(*this == Other); }\n  bool operator<(const UniqueID &Other) const {\n    /// Don't use std::tie since it bloats the compile time of this header.\n    if (Device < Other.Device)\n      return true;\n    if (Other.Device < Device)\n      return false;\n    return File < Other.File;\n  }\n\n  uint64_t getDevice() const { return Device; }\n  uint64_t getFile() const { return File; }\n};\n\n} // end namespace fs\n} // end namespace sys\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_FILESYSTEM_UNIQUEID_H\n"}, "78": {"id": 78, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SourceMgr.h", "content": "//===- SourceMgr.h - Manager for Source Buffers & Diagnostics ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the SMDiagnostic and SourceMgr classes.  This\n// provides a simple substrate for diagnostics, #include handling, and other low\n// level things for simple parsers.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_SOURCEMGR_H\n#define LLVM_SUPPORT_SOURCEMGR_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include <vector>\n\nnamespace llvm {\n\nclass raw_ostream;\nclass SMDiagnostic;\nclass SMFixIt;\n\n/// This owns the files read by a parser, handles include stacks,\n/// and handles diagnostic wrangling.\nclass SourceMgr {\npublic:\n  enum DiagKind {\n    DK_Error,\n    DK_Warning,\n    DK_Remark,\n    DK_Note,\n  };\n\n  /// Clients that want to handle their own diagnostics in a custom way can\n  /// register a function pointer+context as a diagnostic handler.\n  /// It gets called each time PrintMessage is invoked.\n  using DiagHandlerTy = void (*)(const SMDiagnostic &, void *Context);\n\nprivate:\n  struct SrcBuffer {\n    /// The memory buffer for the file.\n    std::unique_ptr<MemoryBuffer> Buffer;\n\n    /// Vector of offsets into Buffer at which there are line-endings\n    /// (lazily populated). Once populated, the '\\n' that marks the end of\n    /// line number N from [1..] is at Buffer[OffsetCache[N-1]]. Since\n    /// these offsets are in sorted (ascending) order, they can be\n    /// binary-searched for the first one after any given offset (eg. an\n    /// offset corresponding to a particular SMLoc).\n    ///\n    /// Since we're storing offsets into relatively small files (often smaller\n    /// than 2^8 or 2^16 bytes), we select the offset vector element type\n    /// dynamically based on the size of Buffer.\n    mutable void *OffsetCache = nullptr;\n\n    /// Look up a given \\p Ptr in in the buffer, determining which line it came\n    /// from.\n    unsigned getLineNumber(const char *Ptr) const;\n    template <typename T>\n    unsigned getLineNumberSpecialized(const char *Ptr) const;\n\n    /// Return a pointer to the first character of the specified line number or\n    /// null if the line number is invalid.\n    const char *getPointerForLineNumber(unsigned LineNo) const;\n    template <typename T>\n    const char *getPointerForLineNumberSpecialized(unsigned LineNo) const;\n\n    /// This is the location of the parent include, or null if at the top level.\n    SMLoc IncludeLoc;\n\n    SrcBuffer() = default;\n    SrcBuffer(SrcBuffer &&);\n    SrcBuffer(const SrcBuffer &) = delete;\n    SrcBuffer &operator=(const SrcBuffer &) = delete;\n    ~SrcBuffer();\n  };\n\n  /// This is all of the buffers that we are reading from.\n  std::vector<SrcBuffer> Buffers;\n\n  // This is the list of directories we should search for include files in.\n  std::vector<std::string> IncludeDirectories;\n\n  DiagHandlerTy DiagHandler = nullptr;\n  void *DiagContext = nullptr;\n\n  bool isValidBufferID(unsigned i) const { return i && i <= Buffers.size(); }\n\npublic:\n  SourceMgr() = default;\n  SourceMgr(const SourceMgr &) = delete;\n  SourceMgr &operator=(const SourceMgr &) = delete;\n  SourceMgr(SourceMgr &&) = default;\n  SourceMgr &operator=(SourceMgr &&) = default;\n  ~SourceMgr() = default;\n\n  void setIncludeDirs(const std::vector<std::string> &Dirs) {\n    IncludeDirectories = Dirs;\n  }\n\n  /// Specify a diagnostic handler to be invoked every time PrintMessage is\n  /// called. \\p Ctx is passed into the handler when it is invoked.\n  void setDiagHandler(DiagHandlerTy DH, void *Ctx = nullptr) {\n    DiagHandler = DH;\n    DiagContext = Ctx;\n  }\n\n  DiagHandlerTy getDiagHandler() const { return DiagHandler; }\n  void *getDiagContext() const { return DiagContext; }\n\n  const SrcBuffer &getBufferInfo(unsigned i) const {\n    assert(isValidBufferID(i));\n    return Buffers[i - 1];\n  }\n\n  const MemoryBuffer *getMemoryBuffer(unsigned i) const {\n    assert(isValidBufferID(i));\n    return Buffers[i - 1].Buffer.get();\n  }\n\n  unsigned getNumBuffers() const { return Buffers.size(); }\n\n  unsigned getMainFileID() const {\n    assert(getNumBuffers());\n    return 1;\n  }\n\n  SMLoc getParentIncludeLoc(unsigned i) const {\n    assert(isValidBufferID(i));\n    return Buffers[i - 1].IncludeLoc;\n  }\n\n  /// Add a new source buffer to this source manager. This takes ownership of\n  /// the memory buffer.\n  unsigned AddNewSourceBuffer(std::unique_ptr<MemoryBuffer> F,\n                              SMLoc IncludeLoc) {\n    SrcBuffer NB;\n    NB.Buffer = std::move(F);\n    NB.IncludeLoc = IncludeLoc;\n    Buffers.push_back(std::move(NB));\n    return Buffers.size();\n  }\n\n  /// Search for a file with the specified name in the current directory or in\n  /// one of the IncludeDirs.\n  ///\n  /// If no file is found, this returns 0, otherwise it returns the buffer ID\n  /// of the stacked file. The full path to the included file can be found in\n  /// \\p IncludedFile.\n  unsigned AddIncludeFile(const std::string &Filename, SMLoc IncludeLoc,\n                          std::string &IncludedFile);\n\n  /// Return the ID of the buffer containing the specified location.\n  ///\n  /// 0 is returned if the buffer is not found.\n  unsigned FindBufferContainingLoc(SMLoc Loc) const;\n\n  /// Find the line number for the specified location in the specified file.\n  /// This is not a fast method.\n  unsigned FindLineNumber(SMLoc Loc, unsigned BufferID = 0) const {\n    return getLineAndColumn(Loc, BufferID).first;\n  }\n\n  /// Find the line and column number for the specified location in the\n  /// specified file. This is not a fast method.\n  std::pair<unsigned, unsigned> getLineAndColumn(SMLoc Loc,\n                                                 unsigned BufferID = 0) const;\n\n  /// Get a string with the \\p SMLoc filename and line number\n  /// formatted in the standard style.\n  std::string getFormattedLocationNoOffset(SMLoc Loc,\n                                           bool IncludePath = false) const;\n\n  /// Given a line and column number in a mapped buffer, turn it into an SMLoc.\n  /// This will return a null SMLoc if the line/column location is invalid.\n  SMLoc FindLocForLineAndColumn(unsigned BufferID, unsigned LineNo,\n                                unsigned ColNo);\n\n  /// Emit a message about the specified location with the specified string.\n  ///\n  /// \\param ShowColors Display colored messages if output is a terminal and\n  /// the default error handler is used.\n  void PrintMessage(raw_ostream &OS, SMLoc Loc, DiagKind Kind, const Twine &Msg,\n                    ArrayRef<SMRange> Ranges = {},\n                    ArrayRef<SMFixIt> FixIts = {},\n                    bool ShowColors = true) const;\n\n  /// Emits a diagnostic to llvm::errs().\n  void PrintMessage(SMLoc Loc, DiagKind Kind, const Twine &Msg,\n                    ArrayRef<SMRange> Ranges = {},\n                    ArrayRef<SMFixIt> FixIts = {},\n                    bool ShowColors = true) const;\n\n  /// Emits a manually-constructed diagnostic to the given output stream.\n  ///\n  /// \\param ShowColors Display colored messages if output is a terminal and\n  /// the default error handler is used.\n  void PrintMessage(raw_ostream &OS, const SMDiagnostic &Diagnostic,\n                    bool ShowColors = true) const;\n\n  /// Return an SMDiagnostic at the specified location with the specified\n  /// string.\n  ///\n  /// \\param Msg If non-null, the kind of message (e.g., \"error\") which is\n  /// prefixed to the message.\n  SMDiagnostic GetMessage(SMLoc Loc, DiagKind Kind, const Twine &Msg,\n                          ArrayRef<SMRange> Ranges = {},\n                          ArrayRef<SMFixIt> FixIts = {}) const;\n\n  /// Prints the names of included files and the line of the file they were\n  /// included from. A diagnostic handler can use this before printing its\n  /// custom formatted message.\n  ///\n  /// \\param IncludeLoc The location of the include.\n  /// \\param OS the raw_ostream to print on.\n  void PrintIncludeStack(SMLoc IncludeLoc, raw_ostream &OS) const;\n};\n\n/// Represents a single fixit, a replacement of one range of text with another.\nclass SMFixIt {\n  SMRange Range;\n\n  std::string Text;\n\npublic:\n  SMFixIt(SMRange R, const Twine &Replacement);\n\n  SMFixIt(SMLoc Loc, const Twine &Replacement)\n      : SMFixIt(SMRange(Loc, Loc), Replacement) {}\n\n  StringRef getText() const { return Text; }\n  SMRange getRange() const { return Range; }\n\n  bool operator<(const SMFixIt &Other) const {\n    if (Range.Start.getPointer() != Other.Range.Start.getPointer())\n      return Range.Start.getPointer() < Other.Range.Start.getPointer();\n    if (Range.End.getPointer() != Other.Range.End.getPointer())\n      return Range.End.getPointer() < Other.Range.End.getPointer();\n    return Text < Other.Text;\n  }\n};\n\n/// Instances of this class encapsulate one diagnostic report, allowing\n/// printing to a raw_ostream as a caret diagnostic.\nclass SMDiagnostic {\n  const SourceMgr *SM = nullptr;\n  SMLoc Loc;\n  std::string Filename;\n  int LineNo = 0;\n  int ColumnNo = 0;\n  SourceMgr::DiagKind Kind = SourceMgr::DK_Error;\n  std::string Message, LineContents;\n  std::vector<std::pair<unsigned, unsigned>> Ranges;\n  SmallVector<SMFixIt, 4> FixIts;\n\npublic:\n  // Null diagnostic.\n  SMDiagnostic() = default;\n  // Diagnostic with no location (e.g. file not found, command line arg error).\n  SMDiagnostic(StringRef filename, SourceMgr::DiagKind Knd, StringRef Msg)\n      : Filename(filename), LineNo(-1), ColumnNo(-1), Kind(Knd), Message(Msg) {}\n\n  // Diagnostic with a location.\n  SMDiagnostic(const SourceMgr &sm, SMLoc L, StringRef FN, int Line, int Col,\n               SourceMgr::DiagKind Kind, StringRef Msg, StringRef LineStr,\n               ArrayRef<std::pair<unsigned, unsigned>> Ranges,\n               ArrayRef<SMFixIt> FixIts = {});\n\n  const SourceMgr *getSourceMgr() const { return SM; }\n  SMLoc getLoc() const { return Loc; }\n  StringRef getFilename() const { return Filename; }\n  int getLineNo() const { return LineNo; }\n  int getColumnNo() const { return ColumnNo; }\n  SourceMgr::DiagKind getKind() const { return Kind; }\n  StringRef getMessage() const { return Message; }\n  StringRef getLineContents() const { return LineContents; }\n  ArrayRef<std::pair<unsigned, unsigned>> getRanges() const { return Ranges; }\n\n  void addFixIt(const SMFixIt &Hint) { FixIts.push_back(Hint); }\n\n  ArrayRef<SMFixIt> getFixIts() const { return FixIts; }\n\n  void print(const char *ProgName, raw_ostream &S, bool ShowColors = true,\n             bool ShowKindLabel = true) const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_SOURCEMGR_H\n"}, "80": {"id": 80, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TimeProfiler.h", "content": "//===- llvm/Support/TimeProfiler.h - Hierarchical Time Profiler -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_TIMEPROFILER_H\n#define LLVM_SUPPORT_TIMEPROFILER_H\n\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace llvm {\n\nstruct TimeTraceProfiler;\nTimeTraceProfiler *getTimeTraceProfilerInstance();\n\n/// Initialize the time trace profiler.\n/// This sets up the global \\p TimeTraceProfilerInstance\n/// variable to be the profiler instance.\nvoid timeTraceProfilerInitialize(unsigned TimeTraceGranularity,\n                                 StringRef ProcName);\n\n/// Cleanup the time trace profiler, if it was initialized.\nvoid timeTraceProfilerCleanup();\n\n/// Finish a time trace profiler running on a worker thread.\nvoid timeTraceProfilerFinishThread();\n\n/// Is the time trace profiler enabled, i.e. initialized?\ninline bool timeTraceProfilerEnabled() {\n  return getTimeTraceProfilerInstance() != nullptr;\n}\n\n/// Write profiling data to output stream.\n/// Data produced is JSON, in Chrome \"Trace Event\" format, see\n/// https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview\nvoid timeTraceProfilerWrite(raw_pwrite_stream &OS);\n\n/// Write profiling data to a file.\n/// The function will write to \\p PreferredFileName if provided, if not\n/// then will write to \\p FallbackFileName appending .time-trace.\n/// Returns a StringError indicating a failure if the function is\n/// unable to open the file for writing.\nError timeTraceProfilerWrite(StringRef PreferredFileName,\n                             StringRef FallbackFileName);\n\n/// Manually begin a time section, with the given \\p Name and \\p Detail.\n/// Profiler copies the string data, so the pointers can be given into\n/// temporaries. Time sections can be hierarchical; every Begin must have a\n/// matching End pair but they can nest.\nvoid timeTraceProfilerBegin(StringRef Name, StringRef Detail);\nvoid timeTraceProfilerBegin(StringRef Name,\n                            llvm::function_ref<std::string()> Detail);\n\n/// Manually end the last time section.\nvoid timeTraceProfilerEnd();\n\n/// The TimeTraceScope is a helper class to call the begin and end functions\n/// of the time trace profiler.  When the object is constructed, it begins\n/// the section; and when it is destroyed, it stops it. If the time profiler\n/// is not initialized, the overhead is a single branch.\nstruct TimeTraceScope {\n\n  TimeTraceScope() = delete;\n  TimeTraceScope(const TimeTraceScope &) = delete;\n  TimeTraceScope &operator=(const TimeTraceScope &) = delete;\n  TimeTraceScope(TimeTraceScope &&) = delete;\n  TimeTraceScope &operator=(TimeTraceScope &&) = delete;\n\n  TimeTraceScope(StringRef Name) {\n    if (getTimeTraceProfilerInstance() != nullptr)\n      timeTraceProfilerBegin(Name, StringRef(\"\"));\n  }\n  TimeTraceScope(StringRef Name, StringRef Detail) {\n    if (getTimeTraceProfilerInstance() != nullptr)\n      timeTraceProfilerBegin(Name, Detail);\n  }\n  TimeTraceScope(StringRef Name, llvm::function_ref<std::string()> Detail) {\n    if (getTimeTraceProfilerInstance() != nullptr)\n      timeTraceProfilerBegin(Name, Detail);\n  }\n  ~TimeTraceScope() {\n    if (getTimeTraceProfilerInstance() != nullptr)\n      timeTraceProfilerEnd();\n  }\n};\n\n} // end namespace llvm\n\n#endif\n"}, "82": {"id": 82, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "content": "//===- VirtualFileSystem.h - Virtual File System Layer ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the virtual file system interface vfs::FileSystem.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_VIRTUALFILESYSTEM_H\n#define LLVM_SUPPORT_VIRTUALFILESYSTEM_H\n\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Chrono.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include <cassert>\n#include <cstdint>\n#include <ctime>\n#include <memory>\n#include <stack>\n#include <string>\n#include <system_error>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass MemoryBuffer;\nclass MemoryBufferRef;\nclass Twine;\n\nnamespace vfs {\n\n/// The result of a \\p status operation.\nclass Status {\n  std::string Name;\n  llvm::sys::fs::UniqueID UID;\n  llvm::sys::TimePoint<> MTime;\n  uint32_t User;\n  uint32_t Group;\n  uint64_t Size;\n  llvm::sys::fs::file_type Type = llvm::sys::fs::file_type::status_error;\n  llvm::sys::fs::perms Perms;\n\npublic:\n  // FIXME: remove when files support multiple names\n  bool IsVFSMapped = false;\n\n  Status() = default;\n  Status(const llvm::sys::fs::file_status &Status);\n  Status(const Twine &Name, llvm::sys::fs::UniqueID UID,\n         llvm::sys::TimePoint<> MTime, uint32_t User, uint32_t Group,\n         uint64_t Size, llvm::sys::fs::file_type Type,\n         llvm::sys::fs::perms Perms);\n\n  /// Get a copy of a Status with a different name.\n  static Status copyWithNewName(const Status &In, const Twine &NewName);\n  static Status copyWithNewName(const llvm::sys::fs::file_status &In,\n                                const Twine &NewName);\n\n  /// Returns the name that should be used for this file or directory.\n  StringRef getName() const { return Name; }\n\n  /// @name Status interface from llvm::sys::fs\n  /// @{\n  llvm::sys::fs::file_type getType() const { return Type; }\n  llvm::sys::fs::perms getPermissions() const { return Perms; }\n  llvm::sys::TimePoint<> getLastModificationTime() const { return MTime; }\n  llvm::sys::fs::UniqueID getUniqueID() const { return UID; }\n  uint32_t getUser() const { return User; }\n  uint32_t getGroup() const { return Group; }\n  uint64_t getSize() const { return Size; }\n  /// @}\n  /// @name Status queries\n  /// These are static queries in llvm::sys::fs.\n  /// @{\n  bool equivalent(const Status &Other) const;\n  bool isDirectory() const;\n  bool isRegularFile() const;\n  bool isOther() const;\n  bool isSymlink() const;\n  bool isStatusKnown() const;\n  bool exists() const;\n  /// @}\n};\n\n/// Represents an open file.\nclass File {\npublic:\n  /// Destroy the file after closing it (if open).\n  /// Sub-classes should generally call close() inside their destructors.  We\n  /// cannot do that from the base class, since close is virtual.\n  virtual ~File();\n\n  /// Get the status of the file.\n  virtual llvm::ErrorOr<Status> status() = 0;\n\n  /// Get the name of the file\n  virtual llvm::ErrorOr<std::string> getName() {\n    if (auto Status = status())\n      return Status->getName().str();\n    else\n      return Status.getError();\n  }\n\n  /// Get the contents of the file as a \\p MemoryBuffer.\n  virtual llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>>\n  getBuffer(const Twine &Name, int64_t FileSize = -1,\n            bool RequiresNullTerminator = true, bool IsVolatile = false) = 0;\n\n  /// Closes the file.\n  virtual std::error_code close() = 0;\n};\n\n/// A member of a directory, yielded by a directory_iterator.\n/// Only information available on most platforms is included.\nclass directory_entry {\n  std::string Path;\n  llvm::sys::fs::file_type Type = llvm::sys::fs::file_type::type_unknown;\n\npublic:\n  directory_entry() = default;\n  directory_entry(std::string Path, llvm::sys::fs::file_type Type)\n      : Path(std::move(Path)), Type(Type) {}\n\n  llvm::StringRef path() const { return Path; }\n  llvm::sys::fs::file_type type() const { return Type; }\n};\n\nnamespace detail {\n\n/// An interface for virtual file systems to provide an iterator over the\n/// (non-recursive) contents of a directory.\nstruct DirIterImpl {\n  virtual ~DirIterImpl();\n\n  /// Sets \\c CurrentEntry to the next entry in the directory on success,\n  /// to directory_entry() at end,  or returns a system-defined \\c error_code.\n  virtual std::error_code increment() = 0;\n\n  directory_entry CurrentEntry;\n};\n\n} // namespace detail\n\n/// An input iterator over the entries in a virtual path, similar to\n/// llvm::sys::fs::directory_iterator.\nclass directory_iterator {\n  std::shared_ptr<detail::DirIterImpl> Impl; // Input iterator semantics on copy\n\npublic:\n  directory_iterator(std::shared_ptr<detail::DirIterImpl> I)\n      : Impl(std::move(I)) {\n    assert(Impl.get() != nullptr && \"requires non-null implementation\");\n    if (Impl->CurrentEntry.path().empty())\n      Impl.reset(); // Normalize the end iterator to Impl == nullptr.\n  }\n\n  /// Construct an 'end' iterator.\n  directory_iterator() = default;\n\n  /// Equivalent to operator++, with an error code.\n  directory_iterator &increment(std::error_code &EC) {\n    assert(Impl && \"attempting to increment past end\");\n    EC = Impl->increment();\n    if (Impl->CurrentEntry.path().empty())\n      Impl.reset(); // Normalize the end iterator to Impl == nullptr.\n    return *this;\n  }\n\n  const directory_entry &operator*() const { return Impl->CurrentEntry; }\n  const directory_entry *operator->() const { return &Impl->CurrentEntry; }\n\n  bool operator==(const directory_iterator &RHS) const {\n    if (Impl && RHS.Impl)\n      return Impl->CurrentEntry.path() == RHS.Impl->CurrentEntry.path();\n    return !Impl && !RHS.Impl;\n  }\n  bool operator!=(const directory_iterator &RHS) const {\n    return !(*this == RHS);\n  }\n};\n\nclass FileSystem;\n\nnamespace detail {\n\n/// Keeps state for the recursive_directory_iterator.\nstruct RecDirIterState {\n  std::stack<directory_iterator, std::vector<directory_iterator>> Stack;\n  bool HasNoPushRequest = false;\n};\n\n} // end namespace detail\n\n/// An input iterator over the recursive contents of a virtual path,\n/// similar to llvm::sys::fs::recursive_directory_iterator.\nclass recursive_directory_iterator {\n  FileSystem *FS;\n  std::shared_ptr<detail::RecDirIterState>\n      State; // Input iterator semantics on copy.\n\npublic:\n  recursive_directory_iterator(FileSystem &FS, const Twine &Path,\n                               std::error_code &EC);\n\n  /// Construct an 'end' iterator.\n  recursive_directory_iterator() = default;\n\n  /// Equivalent to operator++, with an error code.\n  recursive_directory_iterator &increment(std::error_code &EC);\n\n  const directory_entry &operator*() const { return *State->Stack.top(); }\n  const directory_entry *operator->() const { return &*State->Stack.top(); }\n\n  bool operator==(const recursive_directory_iterator &Other) const {\n    return State == Other.State; // identity\n  }\n  bool operator!=(const recursive_directory_iterator &RHS) const {\n    return !(*this == RHS);\n  }\n\n  /// Gets the current level. Starting path is at level 0.\n  int level() const {\n    assert(!State->Stack.empty() &&\n           \"Cannot get level without any iteration state\");\n    return State->Stack.size() - 1;\n  }\n\n  void no_push() { State->HasNoPushRequest = true; }\n};\n\n/// The virtual file system interface.\nclass FileSystem : public llvm::ThreadSafeRefCountedBase<FileSystem> {\npublic:\n  virtual ~FileSystem();\n\n  /// Get the status of the entry at \\p Path, if one exists.\n  virtual llvm::ErrorOr<Status> status(const Twine &Path) = 0;\n\n  /// Get a \\p File object for the file at \\p Path, if one exists.\n  virtual llvm::ErrorOr<std::unique_ptr<File>>\n  openFileForRead(const Twine &Path) = 0;\n\n  /// This is a convenience method that opens a file, gets its content and then\n  /// closes the file.\n  llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>>\n  getBufferForFile(const Twine &Name, int64_t FileSize = -1,\n                   bool RequiresNullTerminator = true, bool IsVolatile = false);\n\n  /// Get a directory_iterator for \\p Dir.\n  /// \\note The 'end' iterator is directory_iterator().\n  virtual directory_iterator dir_begin(const Twine &Dir,\n                                       std::error_code &EC) = 0;\n\n  /// Set the working directory. This will affect all following operations on\n  /// this file system and may propagate down for nested file systems.\n  virtual std::error_code setCurrentWorkingDirectory(const Twine &Path) = 0;\n\n  /// Get the working directory of this file system.\n  virtual llvm::ErrorOr<std::string> getCurrentWorkingDirectory() const = 0;\n\n  /// Gets real path of \\p Path e.g. collapse all . and .. patterns, resolve\n  /// symlinks. For real file system, this uses `llvm::sys::fs::real_path`.\n  /// This returns errc::operation_not_permitted if not implemented by subclass.\n  virtual std::error_code getRealPath(const Twine &Path,\n                                      SmallVectorImpl<char> &Output) const;\n\n  /// Check whether a file exists. Provided for convenience.\n  bool exists(const Twine &Path);\n\n  /// Is the file mounted on a local filesystem?\n  virtual std::error_code isLocal(const Twine &Path, bool &Result);\n\n  /// Make \\a Path an absolute path.\n  ///\n  /// Makes \\a Path absolute using the current directory if it is not already.\n  /// An empty \\a Path will result in the current directory.\n  ///\n  /// /absolute/path   => /absolute/path\n  /// relative/../path => <current-directory>/relative/../path\n  ///\n  /// \\param Path A path that is modified to be an absolute path.\n  /// \\returns success if \\a path has been made absolute, otherwise a\n  ///          platform-specific error_code.\n  virtual std::error_code makeAbsolute(SmallVectorImpl<char> &Path) const;\n};\n\n/// Gets an \\p vfs::FileSystem for the 'real' file system, as seen by\n/// the operating system.\n/// The working directory is linked to the process's working directory.\n/// (This is usually thread-hostile).\nIntrusiveRefCntPtr<FileSystem> getRealFileSystem();\n\n/// Create an \\p vfs::FileSystem for the 'real' file system, as seen by\n/// the operating system.\n/// It has its own working directory, independent of (but initially equal to)\n/// that of the process.\nstd::unique_ptr<FileSystem> createPhysicalFileSystem();\n\n/// A file system that allows overlaying one \\p AbstractFileSystem on top\n/// of another.\n///\n/// Consists of a stack of >=1 \\p FileSystem objects, which are treated as being\n/// one merged file system. When there is a directory that exists in more than\n/// one file system, the \\p OverlayFileSystem contains a directory containing\n/// the union of their contents.  The attributes (permissions, etc.) of the\n/// top-most (most recently added) directory are used.  When there is a file\n/// that exists in more than one file system, the file in the top-most file\n/// system overrides the other(s).\nclass OverlayFileSystem : public FileSystem {\n  using FileSystemList = SmallVector<IntrusiveRefCntPtr<FileSystem>, 1>;\n\n  /// The stack of file systems, implemented as a list in order of\n  /// their addition.\n  FileSystemList FSList;\n\npublic:\n  OverlayFileSystem(IntrusiveRefCntPtr<FileSystem> Base);\n\n  /// Pushes a file system on top of the stack.\n  void pushOverlay(IntrusiveRefCntPtr<FileSystem> FS);\n\n  llvm::ErrorOr<Status> status(const Twine &Path) override;\n  llvm::ErrorOr<std::unique_ptr<File>>\n  openFileForRead(const Twine &Path) override;\n  directory_iterator dir_begin(const Twine &Dir, std::error_code &EC) override;\n  llvm::ErrorOr<std::string> getCurrentWorkingDirectory() const override;\n  std::error_code setCurrentWorkingDirectory(const Twine &Path) override;\n  std::error_code isLocal(const Twine &Path, bool &Result) override;\n  std::error_code getRealPath(const Twine &Path,\n                              SmallVectorImpl<char> &Output) const override;\n\n  using iterator = FileSystemList::reverse_iterator;\n  using const_iterator = FileSystemList::const_reverse_iterator;\n  using reverse_iterator = FileSystemList::iterator;\n  using const_reverse_iterator = FileSystemList::const_iterator;\n\n  /// Get an iterator pointing to the most recently added file system.\n  iterator overlays_begin() { return FSList.rbegin(); }\n  const_iterator overlays_begin() const { return FSList.rbegin(); }\n\n  /// Get an iterator pointing one-past the least recently added file system.\n  iterator overlays_end() { return FSList.rend(); }\n  const_iterator overlays_end() const { return FSList.rend(); }\n\n  /// Get an iterator pointing to the least recently added file system.\n  reverse_iterator overlays_rbegin() { return FSList.begin(); }\n  const_reverse_iterator overlays_rbegin() const { return FSList.begin(); }\n\n  /// Get an iterator pointing one-past the most recently added file system.\n  reverse_iterator overlays_rend() { return FSList.end(); }\n  const_reverse_iterator overlays_rend() const { return FSList.end(); }\n};\n\n/// By default, this delegates all calls to the underlying file system. This\n/// is useful when derived file systems want to override some calls and still\n/// proxy other calls.\nclass ProxyFileSystem : public FileSystem {\npublic:\n  explicit ProxyFileSystem(IntrusiveRefCntPtr<FileSystem> FS)\n      : FS(std::move(FS)) {}\n\n  llvm::ErrorOr<Status> status(const Twine &Path) override {\n    return FS->status(Path);\n  }\n  llvm::ErrorOr<std::unique_ptr<File>>\n  openFileForRead(const Twine &Path) override {\n    return FS->openFileForRead(Path);\n  }\n  directory_iterator dir_begin(const Twine &Dir, std::error_code &EC) override {\n    return FS->dir_begin(Dir, EC);\n  }\n  llvm::ErrorOr<std::string> getCurrentWorkingDirectory() const override {\n    return FS->getCurrentWorkingDirectory();\n  }\n  std::error_code setCurrentWorkingDirectory(const Twine &Path) override {\n    return FS->setCurrentWorkingDirectory(Path);\n  }\n  std::error_code getRealPath(const Twine &Path,\n                              SmallVectorImpl<char> &Output) const override {\n    return FS->getRealPath(Path, Output);\n  }\n  std::error_code isLocal(const Twine &Path, bool &Result) override {\n    return FS->isLocal(Path, Result);\n  }\n\nprotected:\n  FileSystem &getUnderlyingFS() { return *FS; }\n\nprivate:\n  IntrusiveRefCntPtr<FileSystem> FS;\n\n  virtual void anchor();\n};\n\nnamespace detail {\n\nclass InMemoryDirectory;\nclass InMemoryFile;\n\n} // namespace detail\n\n/// An in-memory file system.\nclass InMemoryFileSystem : public FileSystem {\n  std::unique_ptr<detail::InMemoryDirectory> Root;\n  std::string WorkingDirectory;\n  bool UseNormalizedPaths = true;\n\n  /// If HardLinkTarget is non-null, a hardlink is created to the To path which\n  /// must be a file. If it is null then it adds the file as the public addFile.\n  bool addFile(const Twine &Path, time_t ModificationTime,\n               std::unique_ptr<llvm::MemoryBuffer> Buffer,\n               Optional<uint32_t> User, Optional<uint32_t> Group,\n               Optional<llvm::sys::fs::file_type> Type,\n               Optional<llvm::sys::fs::perms> Perms,\n               const detail::InMemoryFile *HardLinkTarget);\n\npublic:\n  explicit InMemoryFileSystem(bool UseNormalizedPaths = true);\n  ~InMemoryFileSystem() override;\n\n  /// Add a file containing a buffer or a directory to the VFS with a\n  /// path. The VFS owns the buffer.  If present, User, Group, Type\n  /// and Perms apply to the newly-created file or directory.\n  /// \\return true if the file or directory was successfully added,\n  /// false if the file or directory already exists in the file system with\n  /// different contents.\n  bool addFile(const Twine &Path, time_t ModificationTime,\n               std::unique_ptr<llvm::MemoryBuffer> Buffer,\n               Optional<uint32_t> User = None, Optional<uint32_t> Group = None,\n               Optional<llvm::sys::fs::file_type> Type = None,\n               Optional<llvm::sys::fs::perms> Perms = None);\n\n  /// Add a hard link to a file.\n  /// Here hard links are not intended to be fully equivalent to the classical\n  /// filesystem. Both the hard link and the file share the same buffer and\n  /// status (and thus have the same UniqueID). Because of this there is no way\n  /// to distinguish between the link and the file after the link has been\n  /// added.\n  ///\n  /// The To path must be an existing file or a hardlink. The From file must not\n  /// have been added before. The To Path must not be a directory. The From Node\n  /// is added as a hard link which points to the resolved file of To Node.\n  /// \\return true if the above condition is satisfied and hardlink was\n  /// successfully created, false otherwise.\n  bool addHardLink(const Twine &From, const Twine &To);\n\n  /// Add a buffer to the VFS with a path. The VFS does not own the buffer.\n  /// If present, User, Group, Type and Perms apply to the newly-created file\n  /// or directory.\n  /// \\return true if the file or directory was successfully added,\n  /// false if the file or directory already exists in the file system with\n  /// different contents.\n  bool addFileNoOwn(const Twine &Path, time_t ModificationTime,\n                    const llvm::MemoryBufferRef &Buffer,\n                    Optional<uint32_t> User = None,\n                    Optional<uint32_t> Group = None,\n                    Optional<llvm::sys::fs::file_type> Type = None,\n                    Optional<llvm::sys::fs::perms> Perms = None);\n\n  std::string toString() const;\n\n  /// Return true if this file system normalizes . and .. in paths.\n  bool useNormalizedPaths() const { return UseNormalizedPaths; }\n\n  llvm::ErrorOr<Status> status(const Twine &Path) override;\n  llvm::ErrorOr<std::unique_ptr<File>>\n  openFileForRead(const Twine &Path) override;\n  directory_iterator dir_begin(const Twine &Dir, std::error_code &EC) override;\n\n  llvm::ErrorOr<std::string> getCurrentWorkingDirectory() const override {\n    return WorkingDirectory;\n  }\n  /// Canonicalizes \\p Path by combining with the current working\n  /// directory and normalizing the path (e.g. remove dots). If the current\n  /// working directory is not set, this returns errc::operation_not_permitted.\n  ///\n  /// This doesn't resolve symlinks as they are not supported in in-memory file\n  /// system.\n  std::error_code getRealPath(const Twine &Path,\n                              SmallVectorImpl<char> &Output) const override;\n  std::error_code isLocal(const Twine &Path, bool &Result) override;\n  std::error_code setCurrentWorkingDirectory(const Twine &Path) override;\n};\n\n/// Get a globally unique ID for a virtual file or directory.\nllvm::sys::fs::UniqueID getNextVirtualUniqueID();\n\n/// Gets a \\p FileSystem for a virtual file system described in YAML\n/// format.\nstd::unique_ptr<FileSystem>\ngetVFSFromYAML(std::unique_ptr<llvm::MemoryBuffer> Buffer,\n               llvm::SourceMgr::DiagHandlerTy DiagHandler,\n               StringRef YAMLFilePath, void *DiagContext = nullptr,\n               IntrusiveRefCntPtr<FileSystem> ExternalFS = getRealFileSystem());\n\nstruct YAMLVFSEntry {\n  template <typename T1, typename T2>\n  YAMLVFSEntry(T1 &&VPath, T2 &&RPath, bool IsDirectory = false)\n      : VPath(std::forward<T1>(VPath)), RPath(std::forward<T2>(RPath)),\n        IsDirectory(IsDirectory) {}\n  std::string VPath;\n  std::string RPath;\n  bool IsDirectory = false;\n};\n\nclass RedirectingFSDirIterImpl;\nclass RedirectingFileSystemParser;\n\n/// A virtual file system parsed from a YAML file.\n///\n/// Currently, this class allows creating virtual files and directories. Virtual\n/// files map to existing external files in \\c ExternalFS, and virtual\n/// directories may either map to existing directories in \\c ExternalFS or list\n/// their contents in the form of other virtual directories and/or files.\n///\n/// The basic structure of the parsed file is:\n/// \\verbatim\n/// {\n///   'version': <version number>,\n///   <optional configuration>\n///   'roots': [\n///              <directory entries>\n///            ]\n/// }\n/// \\endverbatim\n///\n/// All configuration options are optional.\n///   'case-sensitive': <boolean, default=(true for Posix, false for Windows)>\n///   'use-external-names': <boolean, default=true>\n///   'overlay-relative': <boolean, default=false>\n///   'fallthrough': <boolean, default=true>\n///\n/// Virtual directories that list their contents are represented as\n/// \\verbatim\n/// {\n///   'type': 'directory',\n///   'name': <string>,\n///   'contents': [ <file or directory entries> ]\n/// }\n/// \\endverbatim\n///\n/// The default attributes for such virtual directories are:\n/// \\verbatim\n/// MTime = now() when created\n/// Perms = 0777\n/// User = Group = 0\n/// Size = 0\n/// UniqueID = unspecified unique value\n/// \\endverbatim\n///\n/// When a path prefix matches such a directory, the next component in the path\n/// is matched against the entries in the 'contents' array.\n///\n/// Re-mapped directories, on the other hand, are represented as\n/// /// \\verbatim\n/// {\n///   'type': 'directory-remap',\n///   'name': <string>,\n///   'use-external-name': <boolean>, # Optional\n///   'external-contents': <path to external directory>\n/// }\n/// \\endverbatim\n///\n/// and inherit their attributes from the external directory. When a path\n/// prefix matches such an entry, the unmatched components are appended to the\n/// 'external-contents' path, and the resulting path is looked up in the\n/// external file system instead.\n///\n/// Re-mapped files are represented as\n/// \\verbatim\n/// {\n///   'type': 'file',\n///   'name': <string>,\n///   'use-external-name': <boolean>, # Optional\n///   'external-contents': <path to external file>\n/// }\n/// \\endverbatim\n///\n/// Their attributes and file contents are determined by looking up the file at\n/// their 'external-contents' path in the external file system.\n///\n/// For 'file', 'directory' and 'directory-remap' entries the 'name' field may\n/// contain multiple path components (e.g. /path/to/file). However, any\n/// directory in such a path that contains more than one child must be uniquely\n/// represented by a 'directory' entry.\nclass RedirectingFileSystem : public vfs::FileSystem {\npublic:\n  enum EntryKind { EK_Directory, EK_DirectoryRemap, EK_File };\n  enum NameKind { NK_NotSet, NK_External, NK_Virtual };\n\n  /// A single file or directory in the VFS.\n  class Entry {\n    EntryKind Kind;\n    std::string Name;\n\n  public:\n    Entry(EntryKind K, StringRef Name) : Kind(K), Name(Name) {}\n    virtual ~Entry() = default;\n\n    StringRef getName() const { return Name; }\n    EntryKind getKind() const { return Kind; }\n  };\n\n  /// A directory in the vfs with explicitly specified contents.\n  class DirectoryEntry : public Entry {\n    std::vector<std::unique_ptr<Entry>> Contents;\n    Status S;\n\n  public:\n    /// Constructs a directory entry with explicitly specified contents.\n    DirectoryEntry(StringRef Name, std::vector<std::unique_ptr<Entry>> Contents,\n                   Status S)\n        : Entry(EK_Directory, Name), Contents(std::move(Contents)),\n          S(std::move(S)) {}\n\n    /// Constructs an empty directory entry.\n    DirectoryEntry(StringRef Name, Status S)\n        : Entry(EK_Directory, Name), S(std::move(S)) {}\n\n    Status getStatus() { return S; }\n\n    void addContent(std::unique_ptr<Entry> Content) {\n      Contents.push_back(std::move(Content));\n    }\n\n    Entry *getLastContent() const { return Contents.back().get(); }\n\n    using iterator = decltype(Contents)::iterator;\n\n    iterator contents_begin() { return Contents.begin(); }\n    iterator contents_end() { return Contents.end(); }\n\n    static bool classof(const Entry *E) { return E->getKind() == EK_Directory; }\n  };\n\n  /// A file or directory in the vfs that is mapped to a file or directory in\n  /// the external filesystem.\n  class RemapEntry : public Entry {\n    std::string ExternalContentsPath;\n    NameKind UseName;\n\n  protected:\n    RemapEntry(EntryKind K, StringRef Name, StringRef ExternalContentsPath,\n               NameKind UseName)\n        : Entry(K, Name), ExternalContentsPath(ExternalContentsPath),\n          UseName(UseName) {}\n\n  public:\n    StringRef getExternalContentsPath() const { return ExternalContentsPath; }\n\n    /// Whether to use the external path as the name for this file or directory.\n    bool useExternalName(bool GlobalUseExternalName) const {\n      return UseName == NK_NotSet ? GlobalUseExternalName\n                                  : (UseName == NK_External);\n    }\n\n    NameKind getUseName() const { return UseName; }\n\n    static bool classof(const Entry *E) {\n      switch (E->getKind()) {\n      case EK_DirectoryRemap:\n        LLVM_FALLTHROUGH;\n      case EK_File:\n        return true;\n      case EK_Directory:\n        return false;\n      }\n      llvm_unreachable(\"invalid entry kind\");\n    }\n  };\n\n  /// A directory in the vfs that maps to a directory in the external file\n  /// system.\n  class DirectoryRemapEntry : public RemapEntry {\n  public:\n    DirectoryRemapEntry(StringRef Name, StringRef ExternalContentsPath,\n                        NameKind UseName)\n        : RemapEntry(EK_DirectoryRemap, Name, ExternalContentsPath, UseName) {}\n\n    static bool classof(const Entry *E) {\n      return E->getKind() == EK_DirectoryRemap;\n    }\n  };\n\n  /// A file in the vfs that maps to a file in the external file system.\n  class FileEntry : public RemapEntry {\n  public:\n    FileEntry(StringRef Name, StringRef ExternalContentsPath, NameKind UseName)\n        : RemapEntry(EK_File, Name, ExternalContentsPath, UseName) {}\n\n    static bool classof(const Entry *E) { return E->getKind() == EK_File; }\n  };\n\n  /// Represents the result of a path lookup into the RedirectingFileSystem.\n  struct LookupResult {\n    /// The entry the looked-up path corresponds to.\n    Entry *E;\n\n  private:\n    /// When the found Entry is a DirectoryRemapEntry, stores the path in the\n    /// external file system that the looked-up path in the virtual file system\n    //  corresponds to.\n    Optional<std::string> ExternalRedirect;\n\n  public:\n    LookupResult(Entry *E, sys::path::const_iterator Start,\n                 sys::path::const_iterator End);\n\n    /// If the found Entry maps the the input path to a path in the external\n    /// file system (i.e. it is a FileEntry or DirectoryRemapEntry), returns\n    /// that path.\n    Optional<StringRef> getExternalRedirect() const {\n      if (isa<DirectoryRemapEntry>(E))\n        return StringRef(*ExternalRedirect);\n      if (auto *FE = dyn_cast<FileEntry>(E))\n        return FE->getExternalContentsPath();\n      return None;\n    }\n  };\n\nprivate:\n  friend class RedirectingFSDirIterImpl;\n  friend class RedirectingFileSystemParser;\n\n  bool shouldUseExternalFS() const { return IsFallthrough; }\n\n  /// Canonicalize path by removing \".\", \"..\", \"./\", components. This is\n  /// a VFS request, do not bother about symlinks in the path components\n  /// but canonicalize in order to perform the correct entry search.\n  std::error_code makeCanonical(SmallVectorImpl<char> &Path) const;\n\n  /// Whether to fall back to the external file system when an operation fails\n  /// with the given error code on a path associated with the provided Entry.\n  bool shouldFallBackToExternalFS(std::error_code EC, Entry *E = nullptr) const;\n\n  // In a RedirectingFileSystem, keys can be specified in Posix or Windows\n  // style (or even a mixture of both), so this comparison helper allows\n  // slashes (representing a root) to match backslashes (and vice versa).  Note\n  // that, other than the root, path components should not contain slashes or\n  // backslashes.\n  bool pathComponentMatches(llvm::StringRef lhs, llvm::StringRef rhs) const {\n    if ((CaseSensitive ? lhs.equals(rhs) : lhs.equals_lower(rhs)))\n      return true;\n    return (lhs == \"/\" && rhs == \"\\\\\") || (lhs == \"\\\\\" && rhs == \"/\");\n  }\n\n  /// The root(s) of the virtual file system.\n  std::vector<std::unique_ptr<Entry>> Roots;\n\n  /// The current working directory of the file system.\n  std::string WorkingDirectory;\n\n  /// The file system to use for external references.\n  IntrusiveRefCntPtr<FileSystem> ExternalFS;\n\n  /// If IsRelativeOverlay is set, this represents the directory\n  /// path that should be prefixed to each 'external-contents' entry\n  /// when reading from YAML files.\n  std::string ExternalContentsPrefixDir;\n\n  /// @name Configuration\n  /// @{\n\n  /// Whether to perform case-sensitive comparisons.\n  ///\n  /// Currently, case-insensitive matching only works correctly with ASCII.\n  bool CaseSensitive =\n#ifdef _WIN32\n      false;\n#else\n      true;\n#endif\n\n  /// IsRelativeOverlay marks whether a ExternalContentsPrefixDir path must\n  /// be prefixed in every 'external-contents' when reading from YAML files.\n  bool IsRelativeOverlay = false;\n\n  /// Whether to use to use the value of 'external-contents' for the\n  /// names of files.  This global value is overridable on a per-file basis.\n  bool UseExternalNames = true;\n\n  /// Whether to attempt a file lookup in external file system after it wasn't\n  /// found in VFS.\n  bool IsFallthrough = true;\n  /// @}\n\n  RedirectingFileSystem(IntrusiveRefCntPtr<FileSystem> ExternalFS);\n\n  /// Looks up the path <tt>[Start, End)</tt> in \\p From, possibly recursing\n  /// into the contents of \\p From if it is a directory. Returns a LookupResult\n  /// giving the matched entry and, if that entry is a FileEntry or\n  /// DirectoryRemapEntry, the path it redirects to in the external file system.\n  ErrorOr<LookupResult> lookupPathImpl(llvm::sys::path::const_iterator Start,\n                                       llvm::sys::path::const_iterator End,\n                                       Entry *From) const;\n\n  /// Get the status for a path with the provided \\c LookupResult.\n  ErrorOr<Status> status(const Twine &Path, const LookupResult &Result);\n\npublic:\n  /// Looks up \\p Path in \\c Roots and returns a LookupResult giving the\n  /// matched entry and, if the entry was a FileEntry or DirectoryRemapEntry,\n  /// the path it redirects to in the external file system.\n  ErrorOr<LookupResult> lookupPath(StringRef Path) const;\n\n  /// Parses \\p Buffer, which is expected to be in YAML format and\n  /// returns a virtual file system representing its contents.\n  static std::unique_ptr<RedirectingFileSystem>\n  create(std::unique_ptr<MemoryBuffer> Buffer,\n         SourceMgr::DiagHandlerTy DiagHandler, StringRef YAMLFilePath,\n         void *DiagContext, IntrusiveRefCntPtr<FileSystem> ExternalFS);\n\n  /// Redirect each of the remapped files from first to second.\n  static std::unique_ptr<RedirectingFileSystem>\n  create(ArrayRef<std::pair<std::string, std::string>> RemappedFiles,\n         bool UseExternalNames, FileSystem &ExternalFS);\n\n  ErrorOr<Status> status(const Twine &Path) override;\n  ErrorOr<std::unique_ptr<File>> openFileForRead(const Twine &Path) override;\n\n  std::error_code getRealPath(const Twine &Path,\n                              SmallVectorImpl<char> &Output) const override;\n\n  llvm::ErrorOr<std::string> getCurrentWorkingDirectory() const override;\n\n  std::error_code setCurrentWorkingDirectory(const Twine &Path) override;\n\n  std::error_code isLocal(const Twine &Path, bool &Result) override;\n\n  std::error_code makeAbsolute(SmallVectorImpl<char> &Path) const override;\n\n  directory_iterator dir_begin(const Twine &Dir, std::error_code &EC) override;\n\n  void setExternalContentsPrefixDir(StringRef PrefixDir);\n\n  StringRef getExternalContentsPrefixDir() const;\n\n  void setFallthrough(bool Fallthrough);\n\n  std::vector<llvm::StringRef> getRoots() const;\n\n  void dump(raw_ostream &OS) const;\n  void dumpEntry(raw_ostream &OS, Entry *E, int NumSpaces = 0) const;\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  LLVM_DUMP_METHOD void dump() const;\n#endif\n};\n\n/// Collect all pairs of <virtual path, real path> entries from the\n/// \\p YAMLFilePath. This is used by the module dependency collector to forward\n/// the entries into the reproducer output VFS YAML file.\nvoid collectVFSFromYAML(\n    std::unique_ptr<llvm::MemoryBuffer> Buffer,\n    llvm::SourceMgr::DiagHandlerTy DiagHandler, StringRef YAMLFilePath,\n    SmallVectorImpl<YAMLVFSEntry> &CollectedEntries,\n    void *DiagContext = nullptr,\n    IntrusiveRefCntPtr<FileSystem> ExternalFS = getRealFileSystem());\n\nclass YAMLVFSWriter {\n  std::vector<YAMLVFSEntry> Mappings;\n  Optional<bool> IsCaseSensitive;\n  Optional<bool> IsOverlayRelative;\n  Optional<bool> UseExternalNames;\n  std::string OverlayDir;\n\n  void addEntry(StringRef VirtualPath, StringRef RealPath, bool IsDirectory);\n\npublic:\n  YAMLVFSWriter() = default;\n\n  void addFileMapping(StringRef VirtualPath, StringRef RealPath);\n  void addDirectoryMapping(StringRef VirtualPath, StringRef RealPath);\n\n  void setCaseSensitivity(bool CaseSensitive) {\n    IsCaseSensitive = CaseSensitive;\n  }\n\n  void setUseExternalNames(bool UseExtNames) { UseExternalNames = UseExtNames; }\n\n  void setOverlayDir(StringRef OverlayDirectory) {\n    IsOverlayRelative = true;\n    OverlayDir.assign(OverlayDirectory.str());\n  }\n\n  const std::vector<YAMLVFSEntry> &getMappings() const { return Mappings; }\n\n  void write(llvm::raw_ostream &OS);\n};\n\n} // namespace vfs\n} // namespace llvm\n\n#endif // LLVM_SUPPORT_VIRTUALFILESYSTEM_H\n"}, "85": {"id": 85, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Target/CGPassBuilderOption.h", "content": "//===- CGPassBuilderOption.h - Options for pass builder ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the CCState and CCValAssign classes, used for lowering\n// and implementing calling conventions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TARGET_CGPASSBUILDEROPTION_H\n#define LLVM_TARGET_CGPASSBUILDEROPTION_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Target/TargetOptions.h\"\n#include <vector>\n\nnamespace llvm {\nclass TargetMachine;\n\nenum class RunOutliner { TargetDefault, AlwaysOutline, NeverOutline };\nenum class RegAllocType { Default, Basic, Fast, Greedy, PBQP };\nenum class CFLAAType { None, Steensgaard, Andersen, Both };\n\n// Not one-on-one but mostly corresponding to commandline options in\n// TargetPassConfig.cpp.\nstruct CGPassBuilderOption {\n  Optional<bool> OptimizeRegAlloc;\n  Optional<bool> EnableIPRA;\n  bool DebugPM = false;\n  bool DisableVerify = false;\n  bool EnableImplicitNullChecks = false;\n  bool EnableBlockPlacementStats = false;\n  bool MISchedPostRA = false;\n  bool EarlyLiveIntervals = false;\n\n  bool DisableLSR = false;\n  bool DisableCGP = false;\n  bool PrintLSR = false;\n  bool DisableMergeICmps = false;\n  bool DisablePartialLibcallInlining = false;\n  bool DisableConstantHoisting = false;\n  bool PrintISelInput = false;\n  bool PrintGCInfo = false;\n  bool RequiresCodeGenSCCOrder = false;\n\n  RunOutliner EnableMachineOutliner = RunOutliner::TargetDefault;\n  RegAllocType RegAlloc = RegAllocType::Default;\n  CFLAAType UseCFLAA = CFLAAType::None;\n  Optional<GlobalISelAbortMode> EnableGlobalISelAbort;\n\n  Optional<bool> VerifyMachineCode;\n  Optional<bool> EnableFastISelOption;\n  Optional<bool> EnableGlobalISelOption;\n};\n\nCGPassBuilderOption getCGPassBuilderOption();\n\n} // namespace llvm\n\n#endif // LLVM_TARGET_CGPASSBUILDEROPTION_H\n"}, "86": {"id": 86, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Target/TargetMachine.h", "content": "//===-- llvm/Target/TargetMachine.h - Target Information --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the TargetMachine and LLVMTargetMachine classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TARGET_TARGETMACHINE_H\n#define LLVM_TARGET_TARGETMACHINE_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/CodeGen.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Target/CGPassBuilderOption.h\"\n#include \"llvm/Target/TargetOptions.h\"\n#include <string>\n\nnamespace llvm {\n\nclass AAManager;\ntemplate <typename IRUnitT, typename AnalysisManagerT, typename... ExtraArgTs>\nclass PassManager;\nusing ModulePassManager = PassManager<Module>;\n\nclass Function;\nclass GlobalValue;\nclass MachineFunctionPassManager;\nclass MachineFunctionAnalysisManager;\nclass MachineModuleInfoWrapperPass;\nclass Mangler;\nclass MCAsmInfo;\nclass MCContext;\nclass MCInstrInfo;\nclass MCRegisterInfo;\nclass MCStreamer;\nclass MCSubtargetInfo;\nclass MCSymbol;\nclass raw_pwrite_stream;\nclass PassBuilder;\nclass PassManagerBuilder;\nstruct PerFunctionMIParsingState;\nclass SMDiagnostic;\nclass SMRange;\nclass Target;\nclass TargetIntrinsicInfo;\nclass TargetIRAnalysis;\nclass TargetTransformInfo;\nclass TargetLoweringObjectFile;\nclass TargetPassConfig;\nclass TargetSubtargetInfo;\n\n// The old pass manager infrastructure is hidden in a legacy namespace now.\nnamespace legacy {\nclass PassManagerBase;\n}\nusing legacy::PassManagerBase;\n\nnamespace yaml {\nstruct MachineFunctionInfo;\n}\n\n//===----------------------------------------------------------------------===//\n///\n/// Primary interface to the complete machine description for the target\n/// machine.  All target-specific information should be accessible through this\n/// interface.\n///\nclass TargetMachine {\nprotected: // Can only create subclasses.\n  TargetMachine(const Target &T, StringRef DataLayoutString,\n                const Triple &TargetTriple, StringRef CPU, StringRef FS,\n                const TargetOptions &Options);\n\n  /// The Target that this machine was created for.\n  const Target &TheTarget;\n\n  /// DataLayout for the target: keep ABI type size and alignment.\n  ///\n  /// The DataLayout is created based on the string representation provided\n  /// during construction. It is kept here only to avoid reparsing the string\n  /// but should not really be used during compilation, because it has an\n  /// internal cache that is context specific.\n  const DataLayout DL;\n\n  /// Triple string, CPU name, and target feature strings the TargetMachine\n  /// instance is created with.\n  Triple TargetTriple;\n  std::string TargetCPU;\n  std::string TargetFS;\n\n  Reloc::Model RM = Reloc::Static;\n  CodeModel::Model CMModel = CodeModel::Small;\n  CodeGenOpt::Level OptLevel = CodeGenOpt::Default;\n\n  /// Contains target specific asm information.\n  std::unique_ptr<const MCAsmInfo> AsmInfo;\n  std::unique_ptr<const MCRegisterInfo> MRI;\n  std::unique_ptr<const MCInstrInfo> MII;\n  std::unique_ptr<const MCSubtargetInfo> STI;\n\n  unsigned RequireStructuredCFG : 1;\n  unsigned O0WantsFastISel : 1;\n\npublic:\n  const TargetOptions DefaultOptions;\n  mutable TargetOptions Options;\n\n  TargetMachine(const TargetMachine &) = delete;\n  void operator=(const TargetMachine &) = delete;\n  virtual ~TargetMachine();\n\n  const Target &getTarget() const { return TheTarget; }\n\n  const Triple &getTargetTriple() const { return TargetTriple; }\n  StringRef getTargetCPU() const { return TargetCPU; }\n  StringRef getTargetFeatureString() const { return TargetFS; }\n  void setTargetFeatureString(StringRef FS) { TargetFS = std::string(FS); }\n\n  /// Virtual method implemented by subclasses that returns a reference to that\n  /// target's TargetSubtargetInfo-derived member variable.\n  virtual const TargetSubtargetInfo *getSubtargetImpl(const Function &) const {\n    return nullptr;\n  }\n  virtual TargetLoweringObjectFile *getObjFileLowering() const {\n    return nullptr;\n  }\n\n  /// Allocate and return a default initialized instance of the YAML\n  /// representation for the MachineFunctionInfo.\n  virtual yaml::MachineFunctionInfo *createDefaultFuncInfoYAML() const {\n    return nullptr;\n  }\n\n  /// Allocate and initialize an instance of the YAML representation of the\n  /// MachineFunctionInfo.\n  virtual yaml::MachineFunctionInfo *\n  convertFuncInfoToYAML(const MachineFunction &MF) const {\n    return nullptr;\n  }\n\n  /// Parse out the target's MachineFunctionInfo from the YAML reprsentation.\n  virtual bool parseMachineFunctionInfo(const yaml::MachineFunctionInfo &,\n                                        PerFunctionMIParsingState &PFS,\n                                        SMDiagnostic &Error,\n                                        SMRange &SourceRange) const {\n    return false;\n  }\n\n  /// This method returns a pointer to the specified type of\n  /// TargetSubtargetInfo.  In debug builds, it verifies that the object being\n  /// returned is of the correct type.\n  template <typename STC> const STC &getSubtarget(const Function &F) const {\n    return *static_cast<const STC*>(getSubtargetImpl(F));\n  }\n\n  /// Create a DataLayout.\n  const DataLayout createDataLayout() const { return DL; }\n\n  /// Test if a DataLayout if compatible with the CodeGen for this target.\n  ///\n  /// The LLVM Module owns a DataLayout that is used for the target independent\n  /// optimizations and code generation. This hook provides a target specific\n  /// check on the validity of this DataLayout.\n  bool isCompatibleDataLayout(const DataLayout &Candidate) const {\n    return DL == Candidate;\n  }\n\n  /// Get the pointer size for this target.\n  ///\n  /// This is the only time the DataLayout in the TargetMachine is used.\n  unsigned getPointerSize(unsigned AS) const {\n    return DL.getPointerSize(AS);\n  }\n\n  unsigned getPointerSizeInBits(unsigned AS) const {\n    return DL.getPointerSizeInBits(AS);\n  }\n\n  unsigned getProgramPointerSize() const {\n    return DL.getPointerSize(DL.getProgramAddressSpace());\n  }\n\n  unsigned getAllocaPointerSize() const {\n    return DL.getPointerSize(DL.getAllocaAddrSpace());\n  }\n\n  /// Reset the target options based on the function's attributes.\n  // FIXME: Remove TargetOptions that affect per-function code generation\n  // from TargetMachine.\n  void resetTargetOptions(const Function &F) const;\n\n  /// Return target specific asm information.\n  const MCAsmInfo *getMCAsmInfo() const { return AsmInfo.get(); }\n\n  const MCRegisterInfo *getMCRegisterInfo() const { return MRI.get(); }\n  const MCInstrInfo *getMCInstrInfo() const { return MII.get(); }\n  const MCSubtargetInfo *getMCSubtargetInfo() const { return STI.get(); }\n\n  /// If intrinsic information is available, return it.  If not, return null.\n  virtual const TargetIntrinsicInfo *getIntrinsicInfo() const {\n    return nullptr;\n  }\n\n  bool requiresStructuredCFG() const { return RequireStructuredCFG; }\n  void setRequiresStructuredCFG(bool Value) { RequireStructuredCFG = Value; }\n\n  /// Returns the code generation relocation model. The choices are static, PIC,\n  /// and dynamic-no-pic, and target default.\n  Reloc::Model getRelocationModel() const;\n\n  /// Returns the code model. The choices are small, kernel, medium, large, and\n  /// target default.\n  CodeModel::Model getCodeModel() const;\n\n  bool isPositionIndependent() const;\n\n  bool shouldAssumeDSOLocal(const Module &M, const GlobalValue *GV) const;\n\n  /// Returns true if this target uses emulated TLS.\n  bool useEmulatedTLS() const;\n\n  /// Returns the TLS model which should be used for the given global variable.\n  TLSModel::Model getTLSModel(const GlobalValue *GV) const;\n\n  /// Returns the optimization level: None, Less, Default, or Aggressive.\n  CodeGenOpt::Level getOptLevel() const;\n\n  /// Overrides the optimization level.\n  void setOptLevel(CodeGenOpt::Level Level);\n\n  void setFastISel(bool Enable) { Options.EnableFastISel = Enable; }\n  bool getO0WantsFastISel() { return O0WantsFastISel; }\n  void setO0WantsFastISel(bool Enable) { O0WantsFastISel = Enable; }\n  void setGlobalISel(bool Enable) { Options.EnableGlobalISel = Enable; }\n  void setGlobalISelAbort(GlobalISelAbortMode Mode) {\n    Options.GlobalISelAbort = Mode;\n  }\n  void setMachineOutliner(bool Enable) {\n    Options.EnableMachineOutliner = Enable;\n  }\n  void setSupportsDefaultOutlining(bool Enable) {\n    Options.SupportsDefaultOutlining = Enable;\n  }\n  void setSupportsDebugEntryValues(bool Enable) {\n    Options.SupportsDebugEntryValues = Enable;\n  }\n\n  bool getAIXExtendedAltivecABI() const {\n    return Options.EnableAIXExtendedAltivecABI;\n  }\n\n  bool getUniqueSectionNames() const { return Options.UniqueSectionNames; }\n\n  /// Return true if unique basic block section names must be generated.\n  bool getUniqueBasicBlockSectionNames() const {\n    return Options.UniqueBasicBlockSectionNames;\n  }\n\n  /// Return true if data objects should be emitted into their own section,\n  /// corresponds to -fdata-sections.\n  bool getDataSections() const {\n    return Options.DataSections;\n  }\n\n  /// Return true if functions should be emitted into their own section,\n  /// corresponding to -ffunction-sections.\n  bool getFunctionSections() const {\n    return Options.FunctionSections;\n  }\n\n  /// Return true if visibility attribute should not be emitted in XCOFF,\n  /// corresponding to -mignore-xcoff-visibility.\n  bool getIgnoreXCOFFVisibility() const {\n    return Options.IgnoreXCOFFVisibility;\n  }\n\n  /// Return true if XCOFF traceback table should be emitted,\n  /// corresponding to -xcoff-traceback-table.\n  bool getXCOFFTracebackTable() const { return Options.XCOFFTracebackTable; }\n\n  /// If basic blocks should be emitted into their own section,\n  /// corresponding to -fbasic-block-sections.\n  llvm::BasicBlockSection getBBSectionsType() const {\n    return Options.BBSections;\n  }\n\n  /// Get the list of functions and basic block ids that need unique sections.\n  const MemoryBuffer *getBBSectionsFuncListBuf() const {\n    return Options.BBSectionsFuncListBuf.get();\n  }\n\n  /// Returns true if a cast between SrcAS and DestAS is a noop.\n  virtual bool isNoopAddrSpaceCast(unsigned SrcAS, unsigned DestAS) const {\n    return false;\n  }\n\n  /// If the specified generic pointer could be assumed as a pointer to a\n  /// specific address space, return that address space.\n  ///\n  /// Under offloading programming, the offloading target may be passed with\n  /// values only prepared on the host side and could assume certain\n  /// properties.\n  virtual unsigned getAssumedAddrSpace(const Value *V) const { return -1; }\n\n  /// Get a \\c TargetIRAnalysis appropriate for the target.\n  ///\n  /// This is used to construct the new pass manager's target IR analysis pass,\n  /// set up appropriately for this target machine. Even the old pass manager\n  /// uses this to answer queries about the IR.\n  TargetIRAnalysis getTargetIRAnalysis();\n\n  /// Return a TargetTransformInfo for a given function.\n  ///\n  /// The returned TargetTransformInfo is specialized to the subtarget\n  /// corresponding to \\p F.\n  virtual TargetTransformInfo getTargetTransformInfo(const Function &F);\n\n  /// Allow the target to modify the pass manager, e.g. by calling\n  /// PassManagerBuilder::addExtension.\n  virtual void adjustPassManager(PassManagerBuilder &) {}\n\n  /// Allow the target to modify the pass pipeline with New Pass Manager\n  /// (similar to adjustPassManager for Legacy Pass manager).\n  virtual void registerPassBuilderCallbacks(PassBuilder &,\n                                            bool DebugPassManager) {}\n\n  /// Allow the target to register alias analyses with the AAManager for use\n  /// with the new pass manager. Only affects the \"default\" AAManager.\n  virtual void registerDefaultAliasAnalyses(AAManager &) {}\n\n  /// Add passes to the specified pass manager to get the specified file\n  /// emitted.  Typically this will involve several steps of code generation.\n  /// This method should return true if emission of this file type is not\n  /// supported, or false on success.\n  /// \\p MMIWP is an optional parameter that, if set to non-nullptr,\n  /// will be used to set the MachineModuloInfo for this PM.\n  virtual bool\n  addPassesToEmitFile(PassManagerBase &, raw_pwrite_stream &,\n                      raw_pwrite_stream *, CodeGenFileType,\n                      bool /*DisableVerify*/ = true,\n                      MachineModuleInfoWrapperPass *MMIWP = nullptr) {\n    return true;\n  }\n\n  /// Add passes to the specified pass manager to get machine code emitted with\n  /// the MCJIT. This method returns true if machine code is not supported. It\n  /// fills the MCContext Ctx pointer which can be used to build custom\n  /// MCStreamer.\n  ///\n  virtual bool addPassesToEmitMC(PassManagerBase &, MCContext *&,\n                                 raw_pwrite_stream &,\n                                 bool /*DisableVerify*/ = true) {\n    return true;\n  }\n\n  /// True if subtarget inserts the final scheduling pass on its own.\n  ///\n  /// Branch relaxation, which must happen after block placement, can\n  /// on some targets (e.g. SystemZ) expose additional post-RA\n  /// scheduling opportunities.\n  virtual bool targetSchedulesPostRAScheduling() const { return false; };\n\n  void getNameWithPrefix(SmallVectorImpl<char> &Name, const GlobalValue *GV,\n                         Mangler &Mang, bool MayAlwaysUsePrivate = false) const;\n  MCSymbol *getSymbol(const GlobalValue *GV) const;\n\n  /// The integer bit size to use for SjLj based exception handling.\n  static constexpr unsigned DefaultSjLjDataSize = 32;\n  virtual unsigned getSjLjDataSize() const { return DefaultSjLjDataSize; }\n\n  static std::pair<int, int> parseBinutilsVersion(StringRef Version);\n};\n\n/// This class describes a target machine that is implemented with the LLVM\n/// target-independent code generator.\n///\nclass LLVMTargetMachine : public TargetMachine {\nprotected: // Can only create subclasses.\n  LLVMTargetMachine(const Target &T, StringRef DataLayoutString,\n                    const Triple &TT, StringRef CPU, StringRef FS,\n                    const TargetOptions &Options, Reloc::Model RM,\n                    CodeModel::Model CM, CodeGenOpt::Level OL);\n\n  void initAsmInfo();\n\npublic:\n  /// Get a TargetTransformInfo implementation for the target.\n  ///\n  /// The TTI returned uses the common code generator to answer queries about\n  /// the IR.\n  TargetTransformInfo getTargetTransformInfo(const Function &F) override;\n\n  /// Create a pass configuration object to be used by addPassToEmitX methods\n  /// for generating a pipeline of CodeGen passes.\n  virtual TargetPassConfig *createPassConfig(PassManagerBase &PM);\n\n  /// Add passes to the specified pass manager to get the specified file\n  /// emitted.  Typically this will involve several steps of code generation.\n  /// \\p MMIWP is an optional parameter that, if set to non-nullptr,\n  /// will be used to set the MachineModuloInfo for this PM.\n  bool\n  addPassesToEmitFile(PassManagerBase &PM, raw_pwrite_stream &Out,\n                      raw_pwrite_stream *DwoOut, CodeGenFileType FileType,\n                      bool DisableVerify = true,\n                      MachineModuleInfoWrapperPass *MMIWP = nullptr) override;\n\n  virtual Error buildCodeGenPipeline(ModulePassManager &,\n                                     MachineFunctionPassManager &,\n                                     MachineFunctionAnalysisManager &,\n                                     raw_pwrite_stream &, raw_pwrite_stream *,\n                                     CodeGenFileType, CGPassBuilderOption,\n                                     PassInstrumentationCallbacks *) {\n    return make_error<StringError>(\"buildCodeGenPipeline is not overriden\",\n                                   inconvertibleErrorCode());\n  }\n\n  virtual std::pair<StringRef, bool> getPassNameFromLegacyName(StringRef) {\n    llvm_unreachable(\n        \"getPassNameFromLegacyName parseMIRPipeline is not overriden\");\n  }\n\n  /// Add passes to the specified pass manager to get machine code emitted with\n  /// the MCJIT. This method returns true if machine code is not supported. It\n  /// fills the MCContext Ctx pointer which can be used to build custom\n  /// MCStreamer.\n  bool addPassesToEmitMC(PassManagerBase &PM, MCContext *&Ctx,\n                         raw_pwrite_stream &Out,\n                         bool DisableVerify = true) override;\n\n  /// Returns true if the target is expected to pass all machine verifier\n  /// checks. This is a stopgap measure to fix targets one by one. We will\n  /// remove this at some point and always enable the verifier when\n  /// EXPENSIVE_CHECKS is enabled.\n  virtual bool isMachineVerifierClean() const { return true; }\n\n  /// Adds an AsmPrinter pass to the pipeline that prints assembly or\n  /// machine code from the MI representation.\n  bool addAsmPrinter(PassManagerBase &PM, raw_pwrite_stream &Out,\n                     raw_pwrite_stream *DwoOut, CodeGenFileType FileType,\n                     MCContext &Context);\n\n  Expected<std::unique_ptr<MCStreamer>>\n  createMCStreamer(raw_pwrite_stream &Out, raw_pwrite_stream *DwoOut,\n                   CodeGenFileType FileType, MCContext &Ctx);\n\n  /// True if the target uses physical regs (as nearly all targets do). False\n  /// for stack machines such as WebAssembly and other virtual-register\n  /// machines. If true, all vregs must be allocated before PEI. If false, then\n  /// callee-save register spilling and scavenging are not needed or used. If\n  /// false, implicitly defined registers will still be assumed to be physical\n  /// registers, except that variadic defs will be allocated vregs.\n  virtual bool usesPhysRegsForValues() const { return true; }\n\n  /// True if the target wants to use interprocedural register allocation by\n  /// default. The -enable-ipra flag can be used to override this.\n  virtual bool useIPRA() const {\n    return false;\n  }\n};\n\n/// Helper method for getting the code model, returning Default if\n/// CM does not have a value. The tiny and kernel models will produce\n/// an error, so targets that support them or require more complex codemodel\n/// selection logic should implement and call their own getEffectiveCodeModel.\ninline CodeModel::Model getEffectiveCodeModel(Optional<CodeModel::Model> CM,\n                                              CodeModel::Model Default) {\n  if (CM) {\n    // By default, targets do not support the tiny and kernel models.\n    if (*CM == CodeModel::Tiny)\n      report_fatal_error(\"Target does not support the tiny CodeModel\", false);\n    if (*CM == CodeModel::Kernel)\n      report_fatal_error(\"Target does not support the kernel CodeModel\", false);\n    return *CM;\n  }\n  return Default;\n}\n\n} // end namespace llvm\n\n#endif // LLVM_TARGET_TARGETMACHINE_H\n"}, "88": {"id": 88, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/AddressPool.h", "content": "//===- llvm/CodeGen/AddressPool.h - Dwarf Debug Framework -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_CODEGEN_ASMPRINTER_ADDRESSPOOL_H\n#define LLVM_LIB_CODEGEN_ASMPRINTER_ADDRESSPOOL_H\n\n#include \"llvm/ADT/DenseMap.h\"\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass MCSection;\nclass MCSymbol;\n\n// Collection of addresses for this unit and assorted labels.\n// A Symbol->unsigned mapping of addresses used by indirect\n// references.\nclass AddressPool {\n  struct AddressPoolEntry {\n    unsigned Number;\n    bool TLS;\n\n    AddressPoolEntry(unsigned Number, bool TLS) : Number(Number), TLS(TLS) {}\n  };\n  DenseMap<const MCSymbol *, AddressPoolEntry> Pool;\n\n  /// Record whether the AddressPool has been queried for an address index since\n  /// the last \"resetUsedFlag\" call. Used to implement type unit fallback - a\n  /// type that references addresses cannot be placed in a type unit when using\n  /// fission.\n  bool HasBeenUsed = false;\n\npublic:\n  AddressPool() = default;\n\n  /// Returns the index into the address pool with the given\n  /// label/symbol.\n  unsigned getIndex(const MCSymbol *Sym, bool TLS = false);\n\n  void emit(AsmPrinter &Asm, MCSection *AddrSection);\n\n  bool isEmpty() { return Pool.empty(); }\n\n  bool hasBeenUsed() const { return HasBeenUsed; }\n\n  void resetUsedFlag(bool HasBeenUsed = false) { this->HasBeenUsed = HasBeenUsed; }\n\n  MCSymbol *getLabel() { return AddressTableBaseSym; }\n  void setLabel(MCSymbol *Sym) { AddressTableBaseSym = Sym; }\n\nprivate:\n  MCSymbol *emitHeader(AsmPrinter &Asm, MCSection *Section);\n\n  /// Symbol designates the start of the contribution to the address table.\n  MCSymbol *AddressTableBaseSym = nullptr;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_LIB_CODEGEN_ASMPRINTER_ADDRESSPOOL_H\n"}, "89": {"id": 89, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/ByteStreamer.h", "content": "//===-- llvm/CodeGen/ByteStreamer.h - ByteStreamer class --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains a class that can take bytes that would normally be\n// streamed via the AsmPrinter.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_CODEGEN_ASMPRINTER_BYTESTREAMER_H\n#define LLVM_LIB_CODEGEN_ASMPRINTER_BYTESTREAMER_H\n\n#include \"DIEHash.h\"\n#include \"llvm/CodeGen/AsmPrinter.h\"\n#include \"llvm/MC/MCStreamer.h\"\n#include \"llvm/Support/LEB128.h\"\n#include <string>\n\nnamespace llvm {\nclass ByteStreamer {\n protected:\n  ~ByteStreamer() = default;\n  ByteStreamer(const ByteStreamer&) = default;\n  ByteStreamer() = default;\n\n public:\n  // For now we're just handling the calls we need for dwarf emission/hashing.\n  virtual void emitInt8(uint8_t Byte, const Twine &Comment = \"\") = 0;\n  virtual void emitSLEB128(uint64_t DWord, const Twine &Comment = \"\") = 0;\n  virtual void emitULEB128(uint64_t DWord, const Twine &Comment = \"\",\n                           unsigned PadTo = 0) = 0;\n};\n\nclass APByteStreamer final : public ByteStreamer {\nprivate:\n  AsmPrinter &AP;\n\npublic:\n  APByteStreamer(AsmPrinter &Asm) : AP(Asm) {}\n  void emitInt8(uint8_t Byte, const Twine &Comment) override {\n    AP.OutStreamer->AddComment(Comment);\n    AP.emitInt8(Byte);\n  }\n  void emitSLEB128(uint64_t DWord, const Twine &Comment) override {\n    AP.OutStreamer->AddComment(Comment);\n    AP.emitSLEB128(DWord);\n  }\n  void emitULEB128(uint64_t DWord, const Twine &Comment,\n                   unsigned PadTo) override {\n    AP.OutStreamer->AddComment(Comment);\n    AP.emitULEB128(DWord, nullptr, PadTo);\n  }\n};\n\nclass HashingByteStreamer final : public ByteStreamer {\n private:\n  DIEHash &Hash;\n public:\n HashingByteStreamer(DIEHash &H) : Hash(H) {}\n  void emitInt8(uint8_t Byte, const Twine &Comment) override {\n    Hash.update(Byte);\n  }\n  void emitSLEB128(uint64_t DWord, const Twine &Comment) override {\n    Hash.addSLEB128(DWord);\n  }\n  void emitULEB128(uint64_t DWord, const Twine &Comment,\n                   unsigned PadTo) override {\n    Hash.addULEB128(DWord);\n  }\n};\n\nclass BufferByteStreamer final : public ByteStreamer {\nprivate:\n  SmallVectorImpl<char> &Buffer;\n  std::vector<std::string> &Comments;\n\npublic:\n  /// Only verbose textual output needs comments.  This will be set to\n  /// true for that case, and false otherwise.  If false, comments passed in to\n  /// the emit methods will be ignored.\n  const bool GenerateComments;\n\n  BufferByteStreamer(SmallVectorImpl<char> &Buffer,\n                     std::vector<std::string> &Comments, bool GenerateComments)\n      : Buffer(Buffer), Comments(Comments), GenerateComments(GenerateComments) {\n  }\n  void emitInt8(uint8_t Byte, const Twine &Comment) override {\n    Buffer.push_back(Byte);\n    if (GenerateComments)\n      Comments.push_back(Comment.str());\n  }\n  void emitSLEB128(uint64_t DWord, const Twine &Comment) override {\n    raw_svector_ostream OSE(Buffer);\n    unsigned Length = encodeSLEB128(DWord, OSE);\n    if (GenerateComments) {\n      Comments.push_back(Comment.str());\n      // Add some empty comments to keep the Buffer and Comments vectors aligned\n      // with each other.\n      for (size_t i = 1; i < Length; ++i)\n        Comments.push_back(\"\");\n\n    }\n  }\n  void emitULEB128(uint64_t DWord, const Twine &Comment,\n                   unsigned PadTo) override {\n    raw_svector_ostream OSE(Buffer);\n    unsigned Length = encodeULEB128(DWord, OSE, PadTo);\n    if (GenerateComments) {\n      Comments.push_back(Comment.str());\n      // Add some empty comments to keep the Buffer and Comments vectors aligned\n      // with each other.\n      for (size_t i = 1; i < Length; ++i)\n        Comments.push_back(\"\");\n\n    }\n  }\n};\n\n}\n\n#endif\n"}, "90": {"id": 90, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h", "content": "//===-- llvm/CodeGen/DIEHash.h - Dwarf Hashing Framework -------*- C++ -*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains support for DWARF4 hashing of DIEs.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_CODEGEN_ASMPRINTER_DIEHASH_H\n#define LLVM_LIB_CODEGEN_ASMPRINTER_DIEHASH_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/CodeGen/DIE.h\"\n#include \"llvm/Support/MD5.h\"\n\nnamespace llvm {\n\nclass AsmPrinter;\n\n/// An object containing the capability of hashing and adding hash\n/// attributes onto a DIE.\nclass DIEHash {\n  // Collection of all attributes used in hashing a particular DIE.\n  struct DIEAttrs {\n#define HANDLE_DIE_HASH_ATTR(NAME) DIEValue NAME;\n#include \"DIEHashAttributes.def\"\n  };\n\npublic:\n  DIEHash(AsmPrinter *A = nullptr, DwarfCompileUnit *CU = nullptr)\n      : AP(A), CU(CU) {}\n\n  /// Computes the CU signature.\n  uint64_t computeCUSignature(StringRef DWOName, const DIE &Die);\n\n  /// Computes the type signature.\n  uint64_t computeTypeSignature(const DIE &Die);\n\n  // Helper routines to process parts of a DIE.\nprivate:\n  /// Adds the parent context of \\param Parent to the hash.\n  void addParentContext(const DIE &Parent);\n\n  /// Adds the attributes of \\param Die to the hash.\n  void addAttributes(const DIE &Die);\n\n  /// Computes the full DWARF4 7.27 hash of the DIE.\n  void computeHash(const DIE &Die);\n\n  // Routines that add DIEValues to the hash.\npublic:\n  /// Adds \\param Value to the hash.\n  void update(uint8_t Value) { Hash.update(Value); }\n\n  /// Encodes and adds \\param Value to the hash as a ULEB128.\n  void addULEB128(uint64_t Value);\n\n  /// Encodes and adds \\param Value to the hash as a SLEB128.\n  void addSLEB128(int64_t Value);\n\nprivate:\n  /// Adds \\param Str to the hash and includes a NULL byte.\n  void addString(StringRef Str);\n\n  /// Collects the attributes of DIE \\param Die into the \\param Attrs\n  /// structure.\n  void collectAttributes(const DIE &Die, DIEAttrs &Attrs);\n\n  /// Hashes the attributes in \\param Attrs in order.\n  void hashAttributes(const DIEAttrs &Attrs, dwarf::Tag Tag);\n\n  /// Hashes the data in a block like DIEValue, e.g. DW_FORM_block or\n  /// DW_FORM_exprloc.\n  void hashBlockData(const DIE::const_value_range &Values);\n\n  /// Hashes the contents pointed to in the .debug_loc section.\n  void hashLocList(const DIELocList &LocList);\n\n  /// Hashes an individual attribute.\n  void hashAttribute(const DIEValue &Value, dwarf::Tag Tag);\n\n  /// Hashes an attribute that refers to another DIE.\n  void hashDIEEntry(dwarf::Attribute Attribute, dwarf::Tag Tag,\n                    const DIE &Entry);\n\n  /// Hashes a reference to a named type in such a way that is\n  /// independent of whether that type is described by a declaration or a\n  /// definition.\n  void hashShallowTypeReference(dwarf::Attribute Attribute, const DIE &Entry,\n                                StringRef Name);\n\n  /// Hashes a reference to a previously referenced type DIE.\n  void hashRepeatedTypeReference(dwarf::Attribute Attribute,\n                                 unsigned DieNumber);\n\n  void hashNestedType(const DIE &Die, StringRef Name);\n\nprivate:\n  MD5 Hash;\n  AsmPrinter *AP;\n  DwarfCompileUnit *CU;\n  DenseMap<const DIE *, unsigned> Numbering;\n};\n}\n\n#endif\n"}, "91": {"id": 91, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "content": "//===-- llvm/CodeGen/DebugLocEntry.h - Entry in debug_loc list -*- C++ -*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_CODEGEN_ASMPRINTER_DEBUGLOCENTRY_H\n#define LLVM_LIB_CODEGEN_ASMPRINTER_DEBUGLOCENTRY_H\n\n#include \"DebugLocStream.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DebugInfo.h\"\n#include \"llvm/MC/MCSymbol.h\"\n#include \"llvm/MC/MachineLocation.h\"\n#include \"llvm/Support/Debug.h\"\n\nnamespace llvm {\nclass AsmPrinter;\n\n/// This struct describes target specific location.\nstruct TargetIndexLocation {\n  int Index;\n  int Offset;\n\n  TargetIndexLocation() = default;\n  TargetIndexLocation(unsigned Idx, int64_t Offset)\n      : Index(Idx), Offset(Offset) {}\n\n  bool operator==(const TargetIndexLocation &Other) const {\n    return Index == Other.Index && Offset == Other.Offset;\n  }\n};\n\n/// A single location or constant within a variable location description, with\n/// either a single entry (with an optional DIExpression) used for a DBG_VALUE,\n/// or a list of entries used for a DBG_VALUE_LIST.\nclass DbgValueLocEntry {\n\n  /// Type of entry that this represents.\n  enum EntryType {\n    E_Location,\n    E_Integer,\n    E_ConstantFP,\n    E_ConstantInt,\n    E_TargetIndexLocation\n  };\n  enum EntryType EntryKind;\n\n  /// Either a constant,\n  union {\n    int64_t Int;\n    const ConstantFP *CFP;\n    const ConstantInt *CIP;\n  } Constant;\n\n  union {\n    /// Or a location in the machine frame.\n    MachineLocation Loc;\n    /// Or a location from target specific location.\n    TargetIndexLocation TIL;\n  };\n\npublic:\n  DbgValueLocEntry(int64_t i) : EntryKind(E_Integer) { Constant.Int = i; }\n  DbgValueLocEntry(const ConstantFP *CFP) : EntryKind(E_ConstantFP) {\n    Constant.CFP = CFP;\n  }\n  DbgValueLocEntry(const ConstantInt *CIP) : EntryKind(E_ConstantInt) {\n    Constant.CIP = CIP;\n  }\n  DbgValueLocEntry(MachineLocation Loc) : EntryKind(E_Location), Loc(Loc) {}\n  DbgValueLocEntry(TargetIndexLocation Loc)\n      : EntryKind(E_TargetIndexLocation), TIL(Loc) {}\n\n  bool isLocation() const { return EntryKind == E_Location; }\n  bool isTargetIndexLocation() const {\n    return EntryKind == E_TargetIndexLocation;\n  }\n  bool isInt() const { return EntryKind == E_Integer; }\n  bool isConstantFP() const { return EntryKind == E_ConstantFP; }\n  bool isConstantInt() const { return EntryKind == E_ConstantInt; }\n  int64_t getInt() const { return Constant.Int; }\n  const ConstantFP *getConstantFP() const { return Constant.CFP; }\n  const ConstantInt *getConstantInt() const { return Constant.CIP; }\n  MachineLocation getLoc() const { return Loc; }\n  TargetIndexLocation getTargetIndexLocation() const { return TIL; }\n  friend bool operator==(const DbgValueLocEntry &, const DbgValueLocEntry &);\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  LLVM_DUMP_METHOD void dump() const {\n    if (isLocation()) {\n      llvm::dbgs() << \"Loc = { reg=\" << Loc.getReg() << \" \";\n      if (Loc.isIndirect())\n        llvm::dbgs() << \"+0\";\n      llvm::dbgs() << \"} \";\n    } else if (isConstantInt())\n      Constant.CIP->dump();\n    else if (isConstantFP())\n      Constant.CFP->dump();\n  }\n#endif\n};\n\n/// The location of a single variable, composed of an expression and 0 or more\n/// DbgValueLocEntries.\nclass DbgValueLoc {\n  /// Any complex address location expression for this DbgValueLoc.\n  const DIExpression *Expression;\n\n  SmallVector<DbgValueLocEntry, 2> ValueLocEntries;\n\n  bool IsVariadic;\n\npublic:\n  DbgValueLoc(const DIExpression *Expr, ArrayRef<DbgValueLocEntry> Locs)\n      : Expression(Expr), ValueLocEntries(Locs.begin(), Locs.end()),\n        IsVariadic(true) {\n#ifndef NDEBUG\n    // Currently, DBG_VALUE_VAR expressions must use stack_value.\n    assert(Expr && Expr->isValid() &&\n           is_contained(Locs, dwarf::DW_OP_stack_value));\n    for (DbgValueLocEntry &Entry : ValueLocEntries) {\n      assert(!Entry.isConstantFP() && !Entry.isConstantInt() &&\n             \"Constant values should only be present in non-variadic \"\n             \"DBG_VALUEs.\");\n    }\n#endif\n  }\n\n  DbgValueLoc(const DIExpression *Expr, ArrayRef<DbgValueLocEntry> Locs,\n              bool IsVariadic)\n      : Expression(Expr), ValueLocEntries(Locs.begin(), Locs.end()),\n        IsVariadic(IsVariadic) {\n#ifndef NDEBUG\n    assert(cast<DIExpression>(Expr)->isValid() ||\n           !any_of(Locs, [](auto LE) { return LE.isLocation(); }));\n    if (!IsVariadic) {\n      assert(ValueLocEntries.size() == 1);\n    } else {\n      // Currently, DBG_VALUE_VAR expressions must use stack_value.\n      assert(Expr && Expr->isValid() &&\n             is_contained(Expr->getElements(), dwarf::DW_OP_stack_value));\n      for (DbgValueLocEntry &Entry : ValueLocEntries) {\n        assert(!Entry.isConstantFP() && !Entry.isConstantInt() &&\n               \"Constant values should only be present in non-variadic \"\n               \"DBG_VALUEs.\");\n      }\n    }\n#endif\n  }\n\n  DbgValueLoc(const DIExpression *Expr, DbgValueLocEntry Loc)\n      : Expression(Expr), ValueLocEntries(1, Loc), IsVariadic(false) {\n    assert(((Expr && Expr->isValid()) || !Loc.isLocation()) &&\n           \"DBG_VALUE with a machine location must have a valid expression.\");\n  }\n\n  bool isFragment() const { return getExpression()->isFragment(); }\n  bool isEntryVal() const { return getExpression()->isEntryValue(); }\n  bool isVariadic() const { return IsVariadic; }\n  const DIExpression *getExpression() const { return Expression; }\n  const ArrayRef<DbgValueLocEntry> getLocEntries() const {\n    return ValueLocEntries;\n  }\n  friend bool operator==(const DbgValueLoc &, const DbgValueLoc &);\n  friend bool operator<(const DbgValueLoc &, const DbgValueLoc &);\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  LLVM_DUMP_METHOD void dump() const {\n    for (DbgValueLocEntry DV : ValueLocEntries)\n      DV.dump();\n    if (Expression)\n      Expression->dump();\n  }\n#endif\n};\n\n/// This struct describes location entries emitted in the .debug_loc\n/// section.\nclass DebugLocEntry {\n  /// Begin and end symbols for the address range that this location is valid.\n  const MCSymbol *Begin;\n  const MCSymbol *End;\n\n  /// A nonempty list of locations/constants belonging to this entry,\n  /// sorted by offset.\n  SmallVector<DbgValueLoc, 1> Values;\n\npublic:\n  /// Create a location list entry for the range [\\p Begin, \\p End).\n  ///\n  /// \\param Vals One or more values describing (parts of) the variable.\n  DebugLocEntry(const MCSymbol *Begin, const MCSymbol *End,\n                ArrayRef<DbgValueLoc> Vals)\n      : Begin(Begin), End(End) {\n    addValues(Vals);\n  }\n\n  /// Attempt to merge this DebugLocEntry with Next and return\n  /// true if the merge was successful. Entries can be merged if they\n  /// share the same Loc/Constant and if Next immediately follows this\n  /// Entry.\n  bool MergeRanges(const DebugLocEntry &Next) {\n    // If this and Next are describing the same variable, merge them.\n    if ((End == Next.Begin && Values == Next.Values)) {\n      End = Next.End;\n      return true;\n    }\n    return false;\n  }\n\n  const MCSymbol *getBeginSym() const { return Begin; }\n  const MCSymbol *getEndSym() const { return End; }\n  ArrayRef<DbgValueLoc> getValues() const { return Values; }\n  void addValues(ArrayRef<DbgValueLoc> Vals) {\n    Values.append(Vals.begin(), Vals.end());\n    sortUniqueValues();\n    assert((Values.size() == 1 || all_of(Values, [](DbgValueLoc V) {\n              return V.isFragment();\n            })) && \"must either have a single value or multiple pieces\");\n  }\n\n  // Sort the pieces by offset.\n  // Remove any duplicate entries by dropping all but the first.\n  void sortUniqueValues() {\n    llvm::sort(Values);\n    Values.erase(std::unique(Values.begin(), Values.end(),\n                             [](const DbgValueLoc &A, const DbgValueLoc &B) {\n                               return A.getExpression() == B.getExpression();\n                             }),\n                 Values.end());\n  }\n\n  /// Lower this entry into a DWARF expression.\n  void finalize(const AsmPrinter &AP,\n                DebugLocStream::ListBuilder &List,\n                const DIBasicType *BT,\n                DwarfCompileUnit &TheCU);\n};\n\n/// Compare two DbgValueLocEntries for equality.\ninline bool operator==(const DbgValueLocEntry &A, const DbgValueLocEntry &B) {\n  if (A.EntryKind != B.EntryKind)\n    return false;\n\n  switch (A.EntryKind) {\n  case DbgValueLocEntry::E_Location:\n    return A.Loc == B.Loc;\n  case DbgValueLocEntry::E_TargetIndexLocation:\n    return A.TIL == B.TIL;\n  case DbgValueLocEntry::E_Integer:\n    return A.Constant.Int == B.Constant.Int;\n  case DbgValueLocEntry::E_ConstantFP:\n    return A.Constant.CFP == B.Constant.CFP;\n  case DbgValueLocEntry::E_ConstantInt:\n    return A.Constant.CIP == B.Constant.CIP;\n  }\n  llvm_unreachable(\"unhandled EntryKind\");\n}\n\n/// Compare two DbgValueLocs for equality.\ninline bool operator==(const DbgValueLoc &A, const DbgValueLoc &B) {\n  return A.ValueLocEntries == B.ValueLocEntries &&\n         A.Expression == B.Expression && A.IsVariadic == B.IsVariadic;\n}\n\n/// Compare two fragments based on their offset.\ninline bool operator<(const DbgValueLoc &A,\n                      const DbgValueLoc &B) {\n  return A.getExpression()->getFragmentInfo()->OffsetInBits <\n         B.getExpression()->getFragmentInfo()->OffsetInBits;\n}\n\n}\n\n#endif\n"}, "92": {"id": 92, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocStream.h", "content": "//===--- lib/CodeGen/DebugLocStream.h - DWARF debug_loc stream --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_CODEGEN_ASMPRINTER_DEBUGLOCSTREAM_H\n#define LLVM_LIB_CODEGEN_ASMPRINTER_DEBUGLOCSTREAM_H\n\n#include \"ByteStreamer.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass DbgVariable;\nclass DwarfCompileUnit;\nclass MachineInstr;\nclass MCSymbol;\n\n/// Byte stream of .debug_loc entries.\n///\n/// Stores a unified stream of .debug_loc entries.  There's \\a List for each\n/// variable/inlined-at pair, and an \\a Entry for each \\a DebugLocEntry.\n///\n/// FIXME: Do we need all these temp symbols?\n/// FIXME: Why not output directly to the output stream?\nclass DebugLocStream {\npublic:\n  struct List {\n    DwarfCompileUnit *CU;\n    MCSymbol *Label = nullptr;\n    size_t EntryOffset;\n    List(DwarfCompileUnit *CU, size_t EntryOffset)\n        : CU(CU), EntryOffset(EntryOffset) {}\n  };\n  struct Entry {\n    const MCSymbol *Begin;\n    const MCSymbol *End;\n    size_t ByteOffset;\n    size_t CommentOffset;\n  };\n\nprivate:\n  SmallVector<List, 4> Lists;\n  SmallVector<Entry, 32> Entries;\n  SmallString<256> DWARFBytes;\n  std::vector<std::string> Comments;\n  MCSymbol *Sym;\n\n  /// Only verbose textual output needs comments.  This will be set to\n  /// true for that case, and false otherwise.\n  bool GenerateComments;\n\npublic:\n  DebugLocStream(bool GenerateComments) : GenerateComments(GenerateComments) { }\n  size_t getNumLists() const { return Lists.size(); }\n  const List &getList(size_t LI) const { return Lists[LI]; }\n  ArrayRef<List> getLists() const { return Lists; }\n  MCSymbol *getSym() const {\n    return Sym;\n  }\n  void setSym(MCSymbol *Sym) {\n    this->Sym = Sym;\n  }\n\n  class ListBuilder;\n  class EntryBuilder;\n\nprivate:\n  /// Start a new .debug_loc entry list.\n  ///\n  /// Start a new .debug_loc entry list.  Return the new list's index so it can\n  /// be retrieved later via \\a getList().\n  ///\n  /// Until the next call, \\a startEntry() will add entries to this list.\n  size_t startList(DwarfCompileUnit *CU) {\n    size_t LI = Lists.size();\n    Lists.emplace_back(CU, Entries.size());\n    return LI;\n  }\n\n  /// Finalize a .debug_loc entry list.\n  ///\n  /// If there are no entries in this list, delete it outright.  Otherwise,\n  /// create a label with \\a Asm.\n  ///\n  /// \\return false iff the list is deleted.\n  bool finalizeList(AsmPrinter &Asm);\n\n  /// Start a new .debug_loc entry.\n  ///\n  /// Until the next call, bytes added to the stream will be added to this\n  /// entry.\n  void startEntry(const MCSymbol *BeginSym, const MCSymbol *EndSym) {\n    Entries.push_back({BeginSym, EndSym, DWARFBytes.size(), Comments.size()});\n  }\n\n  /// Finalize a .debug_loc entry, deleting if it's empty.\n  void finalizeEntry();\n\npublic:\n  BufferByteStreamer getStreamer() {\n    return BufferByteStreamer(DWARFBytes, Comments, GenerateComments);\n  }\n\n  ArrayRef<Entry> getEntries(const List &L) const {\n    size_t LI = getIndex(L);\n    return makeArrayRef(Entries)\n        .slice(Lists[LI].EntryOffset, getNumEntries(LI));\n  }\n\n  ArrayRef<char> getBytes(const Entry &E) const {\n    size_t EI = getIndex(E);\n    return makeArrayRef(DWARFBytes.begin(), DWARFBytes.end())\n        .slice(Entries[EI].ByteOffset, getNumBytes(EI));\n  }\n  ArrayRef<std::string> getComments(const Entry &E) const {\n    size_t EI = getIndex(E);\n    return makeArrayRef(Comments)\n        .slice(Entries[EI].CommentOffset, getNumComments(EI));\n  }\n\nprivate:\n  size_t getIndex(const List &L) const {\n    assert(&Lists.front() <= &L && &L <= &Lists.back() &&\n           \"Expected valid list\");\n    return &L - &Lists.front();\n  }\n  size_t getIndex(const Entry &E) const {\n    assert(&Entries.front() <= &E && &E <= &Entries.back() &&\n           \"Expected valid entry\");\n    return &E - &Entries.front();\n  }\n  size_t getNumEntries(size_t LI) const {\n    if (LI + 1 == Lists.size())\n      return Entries.size() - Lists[LI].EntryOffset;\n    return Lists[LI + 1].EntryOffset - Lists[LI].EntryOffset;\n  }\n  size_t getNumBytes(size_t EI) const {\n    if (EI + 1 == Entries.size())\n      return DWARFBytes.size() - Entries[EI].ByteOffset;\n    return Entries[EI + 1].ByteOffset - Entries[EI].ByteOffset;\n  }\n  size_t getNumComments(size_t EI) const {\n    if (EI + 1 == Entries.size())\n      return Comments.size() - Entries[EI].CommentOffset;\n    return Entries[EI + 1].CommentOffset - Entries[EI].CommentOffset;\n  }\n};\n\n/// Builder for DebugLocStream lists.\nclass DebugLocStream::ListBuilder {\n  DebugLocStream &Locs;\n  AsmPrinter &Asm;\n  DbgVariable &V;\n  const MachineInstr &MI;\n  size_t ListIndex;\n  Optional<uint8_t> TagOffset;\n\npublic:\n  ListBuilder(DebugLocStream &Locs, DwarfCompileUnit &CU, AsmPrinter &Asm,\n              DbgVariable &V, const MachineInstr &MI)\n      : Locs(Locs), Asm(Asm), V(V), MI(MI), ListIndex(Locs.startList(&CU)),\n        TagOffset(None) {}\n\n  void setTagOffset(uint8_t TO) {\n    TagOffset = TO;\n  }\n\n  /// Finalize the list.\n  ///\n  /// If the list is empty, delete it.  Otherwise, finalize it by creating a\n  /// temp symbol in \\a Asm and setting up the \\a DbgVariable.\n  ~ListBuilder();\n\n  DebugLocStream &getLocs() { return Locs; }\n};\n\n/// Builder for DebugLocStream entries.\nclass DebugLocStream::EntryBuilder {\n  DebugLocStream &Locs;\n\npublic:\n  EntryBuilder(ListBuilder &List, const MCSymbol *Begin, const MCSymbol *End)\n      : Locs(List.getLocs()) {\n    Locs.startEntry(Begin, End);\n  }\n\n  /// Finalize the entry, deleting it if it's empty.\n  ~EntryBuilder() { Locs.finalizeEntry(); }\n\n  BufferByteStreamer getStreamer() { return Locs.getStreamer(); }\n};\n\n} // namespace llvm\n\n#endif\n"}, "93": {"id": 93, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h", "content": "//===- llvm/CodeGen/DwarfCompileUnit.h - Dwarf Compile Unit -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains support for writing dwarf compile unit.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_CODEGEN_ASMPRINTER_DWARFCOMPILEUNIT_H\n#define LLVM_LIB_CODEGEN_ASMPRINTER_DWARFCOMPILEUNIT_H\n\n#include \"DwarfDebug.h\"\n#include \"DwarfUnit.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/CodeGen/DbgEntityHistoryCalculator.h\"\n#include \"llvm/CodeGen/LexicalScopes.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/Support/Casting.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <memory>\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass DIE;\nclass DIELoc;\nclass DIEValueList;\nclass DwarfFile;\nclass GlobalVariable;\nclass MCExpr;\nclass MCSymbol;\nclass MDNode;\n\nenum class UnitKind { Skeleton, Full };\n\nclass DwarfCompileUnit final : public DwarfUnit {\n  /// A numeric ID unique among all CUs in the module\n  unsigned UniqueID;\n  bool HasRangeLists = false;\n\n  /// The start of the unit line section, this is also\n  /// reused in appyStmtList.\n  MCSymbol *LineTableStartSym;\n\n  /// Skeleton unit associated with this unit.\n  DwarfCompileUnit *Skeleton = nullptr;\n\n  /// The start of the unit within its section.\n  MCSymbol *LabelBegin = nullptr;\n\n  /// The start of the unit macro info within macro section.\n  MCSymbol *MacroLabelBegin;\n\n  using ImportedEntityList = SmallVector<const MDNode *, 8>;\n  using ImportedEntityMap = DenseMap<const MDNode *, ImportedEntityList>;\n\n  ImportedEntityMap ImportedEntities;\n\n  /// GlobalNames - A map of globally visible named entities for this unit.\n  StringMap<const DIE *> GlobalNames;\n\n  /// GlobalTypes - A map of globally visible types for this unit.\n  StringMap<const DIE *> GlobalTypes;\n\n  // List of ranges for a given compile unit.\n  SmallVector<RangeSpan, 2> CURanges;\n\n  // The base address of this unit, if any. Used for relative references in\n  // ranges/locs.\n  const MCSymbol *BaseAddress = nullptr;\n\n  DenseMap<const MDNode *, DIE *> AbstractSPDies;\n  DenseMap<const DINode *, std::unique_ptr<DbgEntity>> AbstractEntities;\n\n  /// DWO ID for correlating skeleton and split units.\n  uint64_t DWOId = 0;\n\n  /// Construct a DIE for the given DbgVariable without initializing the\n  /// DbgVariable's DIE reference.\n  DIE *constructVariableDIEImpl(const DbgVariable &DV, bool Abstract);\n\n  bool isDwoUnit() const override;\n\n  DenseMap<const MDNode *, DIE *> &getAbstractSPDies() {\n    if (isDwoUnit() && !DD->shareAcrossDWOCUs())\n      return AbstractSPDies;\n    return DU->getAbstractSPDies();\n  }\n\n  DenseMap<const DINode *, std::unique_ptr<DbgEntity>> &getAbstractEntities() {\n    if (isDwoUnit() && !DD->shareAcrossDWOCUs())\n      return AbstractEntities;\n    return DU->getAbstractEntities();\n  }\n\n  void finishNonUnitTypeDIE(DIE& D, const DICompositeType *CTy) override;\n\npublic:\n  DwarfCompileUnit(unsigned UID, const DICompileUnit *Node, AsmPrinter *A,\n                   DwarfDebug *DW, DwarfFile *DWU,\n                   UnitKind Kind = UnitKind::Full);\n\n  bool hasRangeLists() const { return HasRangeLists; }\n  unsigned getUniqueID() const { return UniqueID; }\n\n  DwarfCompileUnit *getSkeleton() const {\n    return Skeleton;\n  }\n\n  bool includeMinimalInlineScopes() const;\n\n  void initStmtList();\n\n  /// Apply the DW_AT_stmt_list from this compile unit to the specified DIE.\n  void applyStmtList(DIE &D);\n\n  /// Get line table start symbol for this unit.\n  MCSymbol *getLineTableStartSym() const { return LineTableStartSym; }\n\n  /// A pair of GlobalVariable and DIExpression.\n  struct GlobalExpr {\n    const GlobalVariable *Var;\n    const DIExpression *Expr;\n  };\n\n  struct BaseTypeRef {\n    BaseTypeRef(unsigned BitSize, dwarf::TypeKind Encoding) :\n      BitSize(BitSize), Encoding(Encoding) {}\n    unsigned BitSize;\n    dwarf::TypeKind Encoding;\n    DIE *Die = nullptr;\n  };\n\n  std::vector<BaseTypeRef> ExprRefedBaseTypes;\n\n  /// Get or create global variable DIE.\n  DIE *\n  getOrCreateGlobalVariableDIE(const DIGlobalVariable *GV,\n                               ArrayRef<GlobalExpr> GlobalExprs);\n\n  DIE *getOrCreateCommonBlock(const DICommonBlock *CB,\n                              ArrayRef<GlobalExpr> GlobalExprs);\n\n  void addLocationAttribute(DIE *ToDIE, const DIGlobalVariable *GV,\n                            ArrayRef<GlobalExpr> GlobalExprs);\n\n  /// addLabelAddress - Add a dwarf label attribute data and value using\n  /// either DW_FORM_addr or DW_FORM_GNU_addr_index.\n  void addLabelAddress(DIE &Die, dwarf::Attribute Attribute,\n                       const MCSymbol *Label);\n\n  /// addLocalLabelAddress - Add a dwarf label attribute data and value using\n  /// DW_FORM_addr only.\n  void addLocalLabelAddress(DIE &Die, dwarf::Attribute Attribute,\n                            const MCSymbol *Label);\n\n  DwarfCompileUnit &getCU() override { return *this; }\n\n  unsigned getOrCreateSourceID(const DIFile *File) override;\n\n  void addImportedEntity(const DIImportedEntity* IE) {\n    DIScope *Scope = IE->getScope();\n    assert(Scope && \"Invalid Scope encoding!\");\n    if (!isa<DILocalScope>(Scope))\n      // No need to add imported enities that are not local declaration.\n      return;\n\n    auto *LocalScope = cast<DILocalScope>(Scope)->getNonLexicalBlockFileScope();\n    ImportedEntities[LocalScope].push_back(IE);\n  }\n\n  /// addRange - Add an address range to the list of ranges for this unit.\n  void addRange(RangeSpan Range);\n\n  void attachLowHighPC(DIE &D, const MCSymbol *Begin, const MCSymbol *End);\n\n  /// Find DIE for the given subprogram and attach appropriate\n  /// DW_AT_low_pc and DW_AT_high_pc attributes. If there are global\n  /// variables in this scope then create and insert DIEs for these\n  /// variables.\n  DIE &updateSubprogramScopeDIE(const DISubprogram *SP);\n\n  void constructScopeDIE(LexicalScope *Scope,\n                         SmallVectorImpl<DIE *> &FinalChildren);\n\n  /// A helper function to construct a RangeSpanList for a given\n  /// lexical scope.\n  void addScopeRangeList(DIE &ScopeDIE, SmallVector<RangeSpan, 2> Range);\n\n  void attachRangesOrLowHighPC(DIE &D, SmallVector<RangeSpan, 2> Ranges);\n\n  void attachRangesOrLowHighPC(DIE &D,\n                               const SmallVectorImpl<InsnRange> &Ranges);\n\n  /// This scope represents inlined body of a function. Construct\n  /// DIE to represent this concrete inlined copy of the function.\n  DIE *constructInlinedScopeDIE(LexicalScope *Scope);\n\n  /// Construct new DW_TAG_lexical_block for this scope and\n  /// attach DW_AT_low_pc/DW_AT_high_pc labels.\n  DIE *constructLexicalScopeDIE(LexicalScope *Scope);\n\n  /// constructVariableDIE - Construct a DIE for the given DbgVariable.\n  DIE *constructVariableDIE(DbgVariable &DV, bool Abstract = false);\n\n  DIE *constructVariableDIE(DbgVariable &DV, const LexicalScope &Scope,\n                            DIE *&ObjectPointer);\n\n  /// Construct a DIE for the given DbgLabel.\n  DIE *constructLabelDIE(DbgLabel &DL, const LexicalScope &Scope);\n\n  /// A helper function to create children of a Scope DIE.\n  DIE *createScopeChildrenDIE(LexicalScope *Scope,\n                              SmallVectorImpl<DIE *> &Children,\n                              bool *HasNonScopeChildren = nullptr);\n\n  void createBaseTypeDIEs();\n\n  /// Construct a DIE for this subprogram scope.\n  DIE &constructSubprogramScopeDIE(const DISubprogram *Sub,\n                                   LexicalScope *Scope);\n\n  DIE *createAndAddScopeChildren(LexicalScope *Scope, DIE &ScopeDIE);\n\n  void constructAbstractSubprogramScopeDIE(LexicalScope *Scope);\n\n  /// Whether to use the GNU analog for a DWARF5 tag, attribute, or location\n  /// atom. Only applicable when emitting otherwise DWARF4-compliant debug info.\n  bool useGNUAnalogForDwarf5Feature() const;\n\n  /// This takes a DWARF 5 tag and returns it or a GNU analog.\n  dwarf::Tag getDwarf5OrGNUTag(dwarf::Tag Tag) const;\n\n  /// This takes a DWARF 5 attribute and returns it or a GNU analog.\n  dwarf::Attribute getDwarf5OrGNUAttr(dwarf::Attribute Attr) const;\n\n  /// This takes a DWARF 5 location atom and either returns it or a GNU analog.\n  dwarf::LocationAtom getDwarf5OrGNULocationAtom(dwarf::LocationAtom Loc) const;\n\n  /// Construct a call site entry DIE describing a call within \\p Scope to a\n  /// callee described by \\p CalleeDIE.\n  /// \\p CalleeDIE is a declaration or definition subprogram DIE for the callee.\n  /// For indirect calls \\p CalleeDIE is set to nullptr.\n  /// \\p IsTail specifies whether the call is a tail call.\n  /// \\p PCAddr points to the PC value after the call instruction.\n  /// \\p CallAddr points to the PC value at the call instruction (or is null).\n  /// \\p CallReg is a register location for an indirect call. For direct calls\n  /// the \\p CallReg is set to 0.\n  DIE &constructCallSiteEntryDIE(DIE &ScopeDIE, DIE *CalleeDIE, bool IsTail,\n                                 const MCSymbol *PCAddr,\n                                 const MCSymbol *CallAddr, unsigned CallReg);\n  /// Construct call site parameter DIEs for the \\p CallSiteDIE. The \\p Params\n  /// were collected by the \\ref collectCallSiteParameters.\n  /// Note: The order of parameters does not matter, since debuggers recognize\n  ///       call site parameters by the DW_AT_location attribute.\n  void constructCallSiteParmEntryDIEs(DIE &CallSiteDIE,\n                                      SmallVector<DbgCallSiteParam, 4> &Params);\n\n  /// Construct import_module DIE.\n  DIE *constructImportedEntityDIE(const DIImportedEntity *Module);\n\n  void finishSubprogramDefinition(const DISubprogram *SP);\n  void finishEntityDefinition(const DbgEntity *Entity);\n\n  /// Find abstract variable associated with Var.\n  using InlinedEntity = DbgValueHistoryMap::InlinedEntity;\n  DbgEntity *getExistingAbstractEntity(const DINode *Node);\n  void createAbstractEntity(const DINode *Node, LexicalScope *Scope);\n\n  /// Set the skeleton unit associated with this unit.\n  void setSkeleton(DwarfCompileUnit &Skel) { Skeleton = &Skel; }\n\n  unsigned getHeaderSize() const override {\n    // DWARF v5 added the DWO ID to the header for split/skeleton units.\n    unsigned DWOIdSize =\n        DD->getDwarfVersion() >= 5 && DD->useSplitDwarf() ? sizeof(uint64_t)\n                                                          : 0;\n    return DwarfUnit::getHeaderSize() + DWOIdSize;\n  }\n  unsigned getLength() {\n    return Asm->getUnitLengthFieldByteSize() + // Length field\n           getHeaderSize() + getUnitDie().getSize();\n  }\n\n  void emitHeader(bool UseOffsets) override;\n\n  /// Add the DW_AT_addr_base attribute to the unit DIE.\n  void addAddrTableBase();\n\n  MCSymbol *getLabelBegin() const {\n    assert(LabelBegin && \"LabelBegin is not initialized\");\n    return LabelBegin;\n  }\n\n  MCSymbol *getMacroLabelBegin() const {\n    return MacroLabelBegin;\n  }\n\n  /// Add a new global name to the compile unit.\n  void addGlobalName(StringRef Name, const DIE &Die,\n                     const DIScope *Context) override;\n\n  /// Add a new global name present in a type unit to this compile unit.\n  void addGlobalNameForTypeUnit(StringRef Name, const DIScope *Context);\n\n  /// Add a new global type to the compile unit.\n  void addGlobalType(const DIType *Ty, const DIE &Die,\n                     const DIScope *Context) override;\n\n  /// Add a new global type present in a type unit to this compile unit.\n  void addGlobalTypeUnitType(const DIType *Ty, const DIScope *Context);\n\n  const StringMap<const DIE *> &getGlobalNames() const { return GlobalNames; }\n  const StringMap<const DIE *> &getGlobalTypes() const { return GlobalTypes; }\n\n  /// Add DW_AT_location attribute for a DbgVariable based on provided\n  /// MachineLocation.\n  void addVariableAddress(const DbgVariable &DV, DIE &Die,\n                          MachineLocation Location);\n  /// Add an address attribute to a die based on the location provided.\n  void addAddress(DIE &Die, dwarf::Attribute Attribute,\n                  const MachineLocation &Location);\n\n  /// Start with the address based on the location provided, and generate the\n  /// DWARF information necessary to find the actual variable (navigating the\n  /// extra location information encoded in the type) based on the starting\n  /// location.  Add the DWARF information to the die.\n  void addComplexAddress(const DbgVariable &DV, DIE &Die,\n                         dwarf::Attribute Attribute,\n                         const MachineLocation &Location);\n\n  /// Add a Dwarf loclistptr attribute data and value.\n  void addLocationList(DIE &Die, dwarf::Attribute Attribute, unsigned Index);\n  void applyVariableAttributes(const DbgVariable &Var, DIE &VariableDie);\n\n  /// Add a Dwarf expression attribute data and value.\n  void addExpr(DIELoc &Die, dwarf::Form Form, const MCExpr *Expr);\n\n  void applySubprogramAttributesToDefinition(const DISubprogram *SP,\n                                             DIE &SPDie);\n\n  void applyLabelAttributes(const DbgLabel &Label, DIE &LabelDie);\n\n  /// getRanges - Get the list of ranges for this unit.\n  const SmallVectorImpl<RangeSpan> &getRanges() const { return CURanges; }\n  SmallVector<RangeSpan, 2> takeRanges() { return std::move(CURanges); }\n\n  void setBaseAddress(const MCSymbol *Base) { BaseAddress = Base; }\n  const MCSymbol *getBaseAddress() const { return BaseAddress; }\n\n  uint64_t getDWOId() const { return DWOId; }\n  void setDWOId(uint64_t DwoId) { DWOId = DwoId; }\n\n  bool hasDwarfPubSections() const;\n\n  void addBaseTypeRef(DIEValueList &Die, int64_t Idx);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_LIB_CODEGEN_ASMPRINTER_DWARFCOMPILEUNIT_H\n"}, "94": {"id": 94, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h", "content": "//===- llvm/CodeGen/DwarfDebug.h - Dwarf Debug Framework --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains support for writing dwarf debug info into asm files.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_CODEGEN_ASMPRINTER_DWARFDEBUG_H\n#define LLVM_LIB_CODEGEN_ASMPRINTER_DWARFDEBUG_H\n\n#include \"AddressPool.h\"\n#include \"DebugLocStream.h\"\n#include \"DebugLocEntry.h\"\n#include \"DwarfFile.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/CodeGen/AccelTable.h\"\n#include \"llvm/CodeGen/DbgEntityHistoryCalculator.h\"\n#include \"llvm/CodeGen/DebugHandlerBase.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/MC/MCDwarf.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Target/TargetOptions.h\"\n#include <cassert>\n#include <cstdint>\n#include <limits>\n#include <memory>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass ByteStreamer;\nclass DIE;\nclass DwarfCompileUnit;\nclass DwarfExpression;\nclass DwarfTypeUnit;\nclass DwarfUnit;\nclass LexicalScope;\nclass MachineFunction;\nclass MCSection;\nclass MCSymbol;\nclass Module;\n\n//===----------------------------------------------------------------------===//\n/// This class is defined as the common parent of DbgVariable and DbgLabel\n/// such that it could levarage polymorphism to extract common code for\n/// DbgVariable and DbgLabel.\nclass DbgEntity {\n  const DINode *Entity;\n  const DILocation *InlinedAt;\n  DIE *TheDIE = nullptr;\n  unsigned SubclassID;\n\npublic:\n  enum DbgEntityKind {\n    DbgVariableKind,\n    DbgLabelKind\n  };\n\n  DbgEntity(const DINode *N, const DILocation *IA, unsigned ID)\n    : Entity(N), InlinedAt(IA), SubclassID(ID) {}\n  virtual ~DbgEntity() {}\n\n  /// Accessors.\n  /// @{\n  const DINode *getEntity() const { return Entity; }\n  const DILocation *getInlinedAt() const { return InlinedAt; }\n  DIE *getDIE() const { return TheDIE; }\n  unsigned getDbgEntityID() const { return SubclassID; }\n  /// @}\n\n  void setDIE(DIE &D) { TheDIE = &D; }\n\n  static bool classof(const DbgEntity *N) {\n    switch (N->getDbgEntityID()) {\n    default:\n      return false;\n    case DbgVariableKind:\n    case DbgLabelKind:\n      return true;\n    }\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// This class is used to track local variable information.\n///\n/// Variables can be created from allocas, in which case they're generated from\n/// the MMI table.  Such variables can have multiple expressions and frame\n/// indices.\n///\n/// Variables can be created from \\c DBG_VALUE instructions.  Those whose\n/// location changes over time use \\a DebugLocListIndex, while those with a\n/// single location use \\a ValueLoc and (optionally) a single entry of \\a Expr.\n///\n/// Variables that have been optimized out use none of these fields.\nclass DbgVariable : public DbgEntity {\n  /// Index of the entry list in DebugLocs.\n  unsigned DebugLocListIndex = ~0u;\n  /// DW_OP_LLVM_tag_offset value from DebugLocs.\n  Optional<uint8_t> DebugLocListTagOffset;\n\n  /// Single value location description.\n  std::unique_ptr<DbgValueLoc> ValueLoc = nullptr;\n\n  struct FrameIndexExpr {\n    int FI;\n    const DIExpression *Expr;\n  };\n  mutable SmallVector<FrameIndexExpr, 1>\n      FrameIndexExprs; /// Frame index + expression.\n\npublic:\n  /// Construct a DbgVariable.\n  ///\n  /// Creates a variable without any DW_AT_location.  Call \\a initializeMMI()\n  /// for MMI entries, or \\a initializeDbgValue() for DBG_VALUE instructions.\n  DbgVariable(const DILocalVariable *V, const DILocation *IA)\n      : DbgEntity(V, IA, DbgVariableKind) {}\n\n  /// Initialize from the MMI table.\n  void initializeMMI(const DIExpression *E, int FI) {\n    assert(FrameIndexExprs.empty() && \"Already initialized?\");\n    assert(!ValueLoc.get() && \"Already initialized?\");\n\n    assert((!E || E->isValid()) && \"Expected valid expression\");\n    assert(FI != std::numeric_limits<int>::max() && \"Expected valid index\");\n\n    FrameIndexExprs.push_back({FI, E});\n  }\n\n  // Initialize variable's location.\n  void initializeDbgValue(DbgValueLoc Value) {\n    assert(FrameIndexExprs.empty() && \"Already initialized?\");\n    assert(!ValueLoc && \"Already initialized?\");\n    assert(!Value.getExpression()->isFragment() && \"Fragments not supported.\");\n\n    ValueLoc = std::make_unique<DbgValueLoc>(Value);\n    if (auto *E = ValueLoc->getExpression())\n      if (E->getNumElements())\n        FrameIndexExprs.push_back({0, E});\n  }\n\n  /// Initialize from a DBG_VALUE instruction.\n  void initializeDbgValue(const MachineInstr *DbgValue);\n\n  // Accessors.\n  const DILocalVariable *getVariable() const {\n    return cast<DILocalVariable>(getEntity());\n  }\n\n  const DIExpression *getSingleExpression() const {\n    assert(ValueLoc.get() && FrameIndexExprs.size() <= 1);\n    return FrameIndexExprs.size() ? FrameIndexExprs[0].Expr : nullptr;\n  }\n\n  void setDebugLocListIndex(unsigned O) { DebugLocListIndex = O; }\n  unsigned getDebugLocListIndex() const { return DebugLocListIndex; }\n  void setDebugLocListTagOffset(uint8_t O) { DebugLocListTagOffset = O; }\n  Optional<uint8_t> getDebugLocListTagOffset() const { return DebugLocListTagOffset; }\n  StringRef getName() const { return getVariable()->getName(); }\n  const DbgValueLoc *getValueLoc() const { return ValueLoc.get(); }\n  /// Get the FI entries, sorted by fragment offset.\n  ArrayRef<FrameIndexExpr> getFrameIndexExprs() const;\n  bool hasFrameIndexExprs() const { return !FrameIndexExprs.empty(); }\n  void addMMIEntry(const DbgVariable &V);\n\n  // Translate tag to proper Dwarf tag.\n  dwarf::Tag getTag() const {\n    // FIXME: Why don't we just infer this tag and store it all along?\n    if (getVariable()->isParameter())\n      return dwarf::DW_TAG_formal_parameter;\n\n    return dwarf::DW_TAG_variable;\n  }\n\n  /// Return true if DbgVariable is artificial.\n  bool isArtificial() const {\n    if (getVariable()->isArtificial())\n      return true;\n    if (getType()->isArtificial())\n      return true;\n    return false;\n  }\n\n  bool isObjectPointer() const {\n    if (getVariable()->isObjectPointer())\n      return true;\n    if (getType()->isObjectPointer())\n      return true;\n    return false;\n  }\n\n  bool hasComplexAddress() const {\n    assert(ValueLoc.get() && \"Expected DBG_VALUE, not MMI variable\");\n    assert((FrameIndexExprs.empty() ||\n            (FrameIndexExprs.size() == 1 &&\n             FrameIndexExprs[0].Expr->getNumElements())) &&\n           \"Invalid Expr for DBG_VALUE\");\n    return !FrameIndexExprs.empty();\n  }\n\n  const DIType *getType() const;\n\n  static bool classof(const DbgEntity *N) {\n    return N->getDbgEntityID() == DbgVariableKind;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// This class is used to track label information.\n///\n/// Labels are collected from \\c DBG_LABEL instructions.\nclass DbgLabel : public DbgEntity {\n  const MCSymbol *Sym;                  /// Symbol before DBG_LABEL instruction.\n\npublic:\n  /// We need MCSymbol information to generate DW_AT_low_pc.\n  DbgLabel(const DILabel *L, const DILocation *IA, const MCSymbol *Sym = nullptr)\n      : DbgEntity(L, IA, DbgLabelKind), Sym(Sym) {}\n\n  /// Accessors.\n  /// @{\n  const DILabel *getLabel() const { return cast<DILabel>(getEntity()); }\n  const MCSymbol *getSymbol() const { return Sym; }\n\n  StringRef getName() const { return getLabel()->getName(); }\n  /// @}\n\n  /// Translate tag to proper Dwarf tag.\n  dwarf::Tag getTag() const {\n    return dwarf::DW_TAG_label;\n  }\n\n  static bool classof(const DbgEntity *N) {\n    return N->getDbgEntityID() == DbgLabelKind;\n  }\n};\n\n/// Used for tracking debug info about call site parameters.\nclass DbgCallSiteParam {\nprivate:\n  unsigned Register; ///< Parameter register at the callee entry point.\n  DbgValueLoc Value; ///< Corresponding location for the parameter value at\n                     ///< the call site.\npublic:\n  DbgCallSiteParam(unsigned Reg, DbgValueLoc Val)\n      : Register(Reg), Value(Val) {\n    assert(Reg && \"Parameter register cannot be undef\");\n  }\n\n  unsigned getRegister() const { return Register; }\n  DbgValueLoc getValue() const { return Value; }\n};\n\n/// Collection used for storing debug call site parameters.\nusing ParamSet = SmallVector<DbgCallSiteParam, 4>;\n\n/// Helper used to pair up a symbol and its DWARF compile unit.\nstruct SymbolCU {\n  SymbolCU(DwarfCompileUnit *CU, const MCSymbol *Sym) : Sym(Sym), CU(CU) {}\n\n  const MCSymbol *Sym;\n  DwarfCompileUnit *CU;\n};\n\n/// The kind of accelerator tables we should emit.\nenum class AccelTableKind {\n  Default, ///< Platform default.\n  None,    ///< None.\n  Apple,   ///< .apple_names, .apple_namespaces, .apple_types, .apple_objc.\n  Dwarf,   ///< DWARF v5 .debug_names.\n};\n\n/// Collects and handles dwarf debug information.\nclass DwarfDebug : public DebugHandlerBase {\n  /// All DIEValues are allocated through this allocator.\n  BumpPtrAllocator DIEValueAllocator;\n\n  /// Maps MDNode with its corresponding DwarfCompileUnit.\n  MapVector<const MDNode *, DwarfCompileUnit *> CUMap;\n\n  /// Maps a CU DIE with its corresponding DwarfCompileUnit.\n  DenseMap<const DIE *, DwarfCompileUnit *> CUDieMap;\n\n  /// List of all labels used in aranges generation.\n  std::vector<SymbolCU> ArangeLabels;\n\n  /// Size of each symbol emitted (for those symbols that have a specific size).\n  DenseMap<const MCSymbol *, uint64_t> SymSize;\n\n  /// Collection of abstract variables/labels.\n  SmallVector<std::unique_ptr<DbgEntity>, 64> ConcreteEntities;\n\n  /// Collection of DebugLocEntry. Stored in a linked list so that DIELocLists\n  /// can refer to them in spite of insertions into this list.\n  DebugLocStream DebugLocs;\n\n  /// This is a collection of subprogram MDNodes that are processed to\n  /// create DIEs.\n  SetVector<const DISubprogram *, SmallVector<const DISubprogram *, 16>,\n            SmallPtrSet<const DISubprogram *, 16>>\n      ProcessedSPNodes;\n\n  /// If nonnull, stores the current machine function we're processing.\n  const MachineFunction *CurFn = nullptr;\n\n  /// If nonnull, stores the CU in which the previous subprogram was contained.\n  const DwarfCompileUnit *PrevCU = nullptr;\n\n  /// As an optimization, there is no need to emit an entry in the directory\n  /// table for the same directory as DW_AT_comp_dir.\n  StringRef CompilationDir;\n\n  /// Holder for the file specific debug information.\n  DwarfFile InfoHolder;\n\n  /// Holders for the various debug information flags that we might need to\n  /// have exposed. See accessor functions below for description.\n\n  /// Map from MDNodes for user-defined types to their type signatures. Also\n  /// used to keep track of which types we have emitted type units for.\n  DenseMap<const MDNode *, uint64_t> TypeSignatures;\n\n  DenseMap<const MCSection *, const MCSymbol *> SectionLabels;\n\n  SmallVector<\n      std::pair<std::unique_ptr<DwarfTypeUnit>, const DICompositeType *>, 1>\n      TypeUnitsUnderConstruction;\n\n  /// Whether to use the GNU TLS opcode (instead of the standard opcode).\n  bool UseGNUTLSOpcode;\n\n  /// Whether to use DWARF 2 bitfields (instead of the DWARF 4 format).\n  bool UseDWARF2Bitfields;\n\n  /// Whether to emit all linkage names, or just abstract subprograms.\n  bool UseAllLinkageNames;\n\n  /// Use inlined strings.\n  bool UseInlineStrings = false;\n\n  /// Allow emission of .debug_ranges section.\n  bool UseRangesSection = true;\n\n  /// True if the sections itself must be used as references and don't create\n  /// temp symbols inside DWARF sections.\n  bool UseSectionsAsReferences = false;\n\n  ///Allow emission of the .debug_loc section.\n  bool UseLocSection = true;\n\n  /// Generate DWARF v4 type units.\n  bool GenerateTypeUnits;\n\n  /// Emit a .debug_macro section instead of .debug_macinfo.\n  bool UseDebugMacroSection;\n\n  /// Avoid using DW_OP_convert due to consumer incompatibilities.\n  bool EnableOpConvert;\n\npublic:\n  enum class MinimizeAddrInV5 {\n    Default,\n    Disabled,\n    Ranges,\n    Expressions,\n    Form,\n  };\n\nprivate:\n  /// Force the use of DW_AT_ranges even for single-entry range lists.\n  MinimizeAddrInV5 MinimizeAddr = MinimizeAddrInV5::Disabled;\n\n  /// DWARF5 Experimental Options\n  /// @{\n  AccelTableKind TheAccelTableKind;\n  bool HasAppleExtensionAttributes;\n  bool HasSplitDwarf;\n\n  /// Whether to generate the DWARF v5 string offsets table.\n  /// It consists of a series of contributions, each preceded by a header.\n  /// The pre-DWARF v5 string offsets table for split dwarf is, in contrast,\n  /// a monolithic sequence of string offsets.\n  bool UseSegmentedStringOffsetsTable;\n\n  /// Enable production of call site parameters needed to print the debug entry\n  /// values. Useful for testing purposes when a debugger does not support the\n  /// feature yet.\n  bool EmitDebugEntryValues;\n\n  /// Separated Dwarf Variables\n  /// In general these will all be for bits that are left in the\n  /// original object file, rather than things that are meant\n  /// to be in the .dwo sections.\n\n  /// Holder for the skeleton information.\n  DwarfFile SkeletonHolder;\n\n  /// Store file names for type units under fission in a line table\n  /// header that will be emitted into debug_line.dwo.\n  // FIXME: replace this with a map from comp_dir to table so that we\n  // can emit multiple tables during LTO each of which uses directory\n  // 0, referencing the comp_dir of all the type units that use it.\n  MCDwarfDwoLineTable SplitTypeUnitFileTable;\n  /// @}\n\n  /// True iff there are multiple CUs in this module.\n  bool SingleCU;\n  bool IsDarwin;\n\n  /// Map for tracking Fortran deferred CHARACTER lengths.\n  DenseMap<const DIStringType *, unsigned> StringTypeLocMap;\n\n  AddressPool AddrPool;\n\n  /// Accelerator tables.\n  AccelTable<DWARF5AccelTableData> AccelDebugNames;\n  AccelTable<AppleAccelTableOffsetData> AccelNames;\n  AccelTable<AppleAccelTableOffsetData> AccelObjC;\n  AccelTable<AppleAccelTableOffsetData> AccelNamespace;\n  AccelTable<AppleAccelTableTypeData> AccelTypes;\n\n  // Identify a debugger for \"tuning\" the debug info.\n  DebuggerKind DebuggerTuning = DebuggerKind::Default;\n\n  MCDwarfDwoLineTable *getDwoLineTable(const DwarfCompileUnit &);\n\n  const SmallVectorImpl<std::unique_ptr<DwarfCompileUnit>> &getUnits() {\n    return InfoHolder.getUnits();\n  }\n\n  using InlinedEntity = DbgValueHistoryMap::InlinedEntity;\n\n  void ensureAbstractEntityIsCreated(DwarfCompileUnit &CU,\n                                     const DINode *Node,\n                                     const MDNode *Scope);\n  void ensureAbstractEntityIsCreatedIfScoped(DwarfCompileUnit &CU,\n                                             const DINode *Node,\n                                             const MDNode *Scope);\n\n  DbgEntity *createConcreteEntity(DwarfCompileUnit &TheCU,\n                                  LexicalScope &Scope,\n                                  const DINode *Node,\n                                  const DILocation *Location,\n                                  const MCSymbol *Sym = nullptr);\n\n  /// Construct a DIE for this abstract scope.\n  void constructAbstractSubprogramScopeDIE(DwarfCompileUnit &SrcCU, LexicalScope *Scope);\n\n  /// Construct a DIE for the subprogram definition \\p SP and return it.\n  DIE &constructSubprogramDefinitionDIE(const DISubprogram *SP);\n\n  /// Construct DIEs for call site entries describing the calls in \\p MF.\n  void constructCallSiteEntryDIEs(const DISubprogram &SP, DwarfCompileUnit &CU,\n                                  DIE &ScopeDIE, const MachineFunction &MF);\n\n  template <typename DataT>\n  void addAccelNameImpl(const DICompileUnit &CU, AccelTable<DataT> &AppleAccel,\n                        StringRef Name, const DIE &Die);\n\n  void finishEntityDefinitions();\n\n  void finishSubprogramDefinitions();\n\n  /// Finish off debug information after all functions have been\n  /// processed.\n  void finalizeModuleInfo();\n\n  /// Emit the debug info section.\n  void emitDebugInfo();\n\n  /// Emit the abbreviation section.\n  void emitAbbreviations();\n\n  /// Emit the string offsets table header.\n  void emitStringOffsetsTableHeader();\n\n  /// Emit a specified accelerator table.\n  template <typename AccelTableT>\n  void emitAccel(AccelTableT &Accel, MCSection *Section, StringRef TableName);\n\n  /// Emit DWARF v5 accelerator table.\n  void emitAccelDebugNames();\n\n  /// Emit visible names into a hashed accelerator table section.\n  void emitAccelNames();\n\n  /// Emit objective C classes and categories into a hashed\n  /// accelerator table section.\n  void emitAccelObjC();\n\n  /// Emit namespace dies into a hashed accelerator table.\n  void emitAccelNamespaces();\n\n  /// Emit type dies into a hashed accelerator table.\n  void emitAccelTypes();\n\n  /// Emit visible names and types into debug pubnames and pubtypes sections.\n  void emitDebugPubSections();\n\n  void emitDebugPubSection(bool GnuStyle, StringRef Name,\n                           DwarfCompileUnit *TheU,\n                           const StringMap<const DIE *> &Globals);\n\n  /// Emit null-terminated strings into a debug str section.\n  void emitDebugStr();\n\n  /// Emit variable locations into a debug loc section.\n  void emitDebugLoc();\n\n  /// Emit variable locations into a debug loc dwo section.\n  void emitDebugLocDWO();\n\n  void emitDebugLocImpl(MCSection *Sec);\n\n  /// Emit address ranges into a debug aranges section.\n  void emitDebugARanges();\n\n  /// Emit address ranges into a debug ranges section.\n  void emitDebugRanges();\n  void emitDebugRangesDWO();\n  void emitDebugRangesImpl(const DwarfFile &Holder, MCSection *Section);\n\n  /// Emit macros into a debug macinfo section.\n  void emitDebugMacinfo();\n  /// Emit macros into a debug macinfo.dwo section.\n  void emitDebugMacinfoDWO();\n  void emitDebugMacinfoImpl(MCSection *Section);\n  void emitMacro(DIMacro &M);\n  void emitMacroFile(DIMacroFile &F, DwarfCompileUnit &U);\n  void emitMacroFileImpl(DIMacroFile &F, DwarfCompileUnit &U,\n                         unsigned StartFile, unsigned EndFile,\n                         StringRef (*MacroFormToString)(unsigned Form));\n  void handleMacroNodes(DIMacroNodeArray Nodes, DwarfCompileUnit &U);\n\n  /// DWARF 5 Experimental Split Dwarf Emitters\n\n  /// Initialize common features of skeleton units.\n  void initSkeletonUnit(const DwarfUnit &U, DIE &Die,\n                        std::unique_ptr<DwarfCompileUnit> NewU);\n\n  /// Construct the split debug info compile unit for the debug info section.\n  /// In DWARF v5, the skeleton unit DIE may have the following attributes:\n  /// DW_AT_addr_base, DW_AT_comp_dir, DW_AT_dwo_name, DW_AT_high_pc,\n  /// DW_AT_low_pc, DW_AT_ranges, DW_AT_stmt_list, and DW_AT_str_offsets_base.\n  /// Prior to DWARF v5 it may also have DW_AT_GNU_dwo_id. DW_AT_GNU_dwo_name\n  /// is used instead of DW_AT_dwo_name, Dw_AT_GNU_addr_base instead of\n  /// DW_AT_addr_base, and DW_AT_GNU_ranges_base instead of DW_AT_rnglists_base.\n  DwarfCompileUnit &constructSkeletonCU(const DwarfCompileUnit &CU);\n\n  /// Emit the debug info dwo section.\n  void emitDebugInfoDWO();\n\n  /// Emit the debug abbrev dwo section.\n  void emitDebugAbbrevDWO();\n\n  /// Emit the debug line dwo section.\n  void emitDebugLineDWO();\n\n  /// Emit the dwo stringoffsets table header.\n  void emitStringOffsetsTableHeaderDWO();\n\n  /// Emit the debug str dwo section.\n  void emitDebugStrDWO();\n\n  /// Emit DWO addresses.\n  void emitDebugAddr();\n\n  /// Flags to let the linker know we have emitted new style pubnames. Only\n  /// emit it here if we don't have a skeleton CU for split dwarf.\n  void addGnuPubAttributes(DwarfCompileUnit &U, DIE &D) const;\n\n  /// Create new DwarfCompileUnit for the given metadata node with tag\n  /// DW_TAG_compile_unit.\n  DwarfCompileUnit &getOrCreateDwarfCompileUnit(const DICompileUnit *DIUnit);\n  void finishUnitAttributes(const DICompileUnit *DIUnit,\n                            DwarfCompileUnit &NewCU);\n\n  /// Construct imported_module or imported_declaration DIE.\n  void constructAndAddImportedEntityDIE(DwarfCompileUnit &TheCU,\n                                        const DIImportedEntity *N);\n\n  /// Register a source line with debug info. Returns the unique\n  /// label that was emitted and which provides correspondence to the\n  /// source line list.\n  void recordSourceLine(unsigned Line, unsigned Col, const MDNode *Scope,\n                        unsigned Flags);\n\n  /// Populate LexicalScope entries with variables' info.\n  void collectEntityInfo(DwarfCompileUnit &TheCU, const DISubprogram *SP,\n                         DenseSet<InlinedEntity> &ProcessedVars);\n\n  /// Build the location list for all DBG_VALUEs in the\n  /// function that describe the same variable. If the resulting \n  /// list has only one entry that is valid for entire variable's\n  /// scope return true.\n  bool buildLocationList(SmallVectorImpl<DebugLocEntry> &DebugLoc,\n                         const DbgValueHistoryMap::Entries &Entries);\n\n  /// Collect variable information from the side table maintained by MF.\n  void collectVariableInfoFromMFTable(DwarfCompileUnit &TheCU,\n                                      DenseSet<InlinedEntity> &P);\n\n  /// Emit the reference to the section.\n  void emitSectionReference(const DwarfCompileUnit &CU);\n\nprotected:\n  /// Gather pre-function debug information.\n  void beginFunctionImpl(const MachineFunction *MF) override;\n\n  /// Gather and emit post-function debug information.\n  void endFunctionImpl(const MachineFunction *MF) override;\n\n  void skippedNonDebugFunction() override;\n\npublic:\n  //===--------------------------------------------------------------------===//\n  // Main entry points.\n  //\n  DwarfDebug(AsmPrinter *A);\n\n  ~DwarfDebug() override;\n\n  /// Emit all Dwarf sections that should come prior to the\n  /// content.\n  void beginModule(Module *M) override;\n\n  /// Emit all Dwarf sections that should come after the content.\n  void endModule() override;\n\n  /// Emits inital debug location directive.\n  DebugLoc emitInitialLocDirective(const MachineFunction &MF, unsigned CUID);\n\n  /// Process beginning of an instruction.\n  void beginInstruction(const MachineInstr *MI) override;\n\n  /// Perform an MD5 checksum of \\p Identifier and return the lower 64 bits.\n  static uint64_t makeTypeSignature(StringRef Identifier);\n\n  /// Add a DIE to the set of types that we're going to pull into\n  /// type units.\n  void addDwarfTypeUnitType(DwarfCompileUnit &CU, StringRef Identifier,\n                            DIE &Die, const DICompositeType *CTy);\n\n  class NonTypeUnitContext {\n    DwarfDebug *DD;\n    decltype(DwarfDebug::TypeUnitsUnderConstruction) TypeUnitsUnderConstruction;\n    bool AddrPoolUsed;\n    friend class DwarfDebug;\n    NonTypeUnitContext(DwarfDebug *DD);\n  public:\n    NonTypeUnitContext(NonTypeUnitContext&&) = default;\n    ~NonTypeUnitContext();\n  };\n\n  NonTypeUnitContext enterNonTypeUnitContext();\n\n  /// Add a label so that arange data can be generated for it.\n  void addArangeLabel(SymbolCU SCU) { ArangeLabels.push_back(SCU); }\n\n  /// For symbols that have a size designated (e.g. common symbols),\n  /// this tracks that size.\n  void setSymbolSize(const MCSymbol *Sym, uint64_t Size) override {\n    SymSize[Sym] = Size;\n  }\n\n  /// Returns whether we should emit all DW_AT_[MIPS_]linkage_name.\n  /// If not, we still might emit certain cases.\n  bool useAllLinkageNames() const { return UseAllLinkageNames; }\n\n  /// Returns whether to use DW_OP_GNU_push_tls_address, instead of the\n  /// standard DW_OP_form_tls_address opcode\n  bool useGNUTLSOpcode() const { return UseGNUTLSOpcode; }\n\n  /// Returns whether to use the DWARF2 format for bitfields instyead of the\n  /// DWARF4 format.\n  bool useDWARF2Bitfields() const { return UseDWARF2Bitfields; }\n\n  /// Returns whether to use inline strings.\n  bool useInlineStrings() const { return UseInlineStrings; }\n\n  /// Returns whether ranges section should be emitted.\n  bool useRangesSection() const { return UseRangesSection; }\n\n  /// Returns whether range encodings should be used for single entry range\n  /// lists.\n  bool alwaysUseRanges() const {\n    return MinimizeAddr == MinimizeAddrInV5::Ranges;\n  }\n\n  // Returns whether novel exprloc addrx+offset encodings should be used to\n  // reduce debug_addr size.\n  bool useAddrOffsetExpressions() const {\n    return MinimizeAddr == MinimizeAddrInV5::Expressions;\n  }\n\n  // Returns whether addrx+offset LLVM extension form should be used to reduce\n  // debug_addr size.\n  bool useAddrOffsetForm() const {\n    return MinimizeAddr == MinimizeAddrInV5::Form;\n  }\n\n  /// Returns whether to use sections as labels rather than temp symbols.\n  bool useSectionsAsReferences() const {\n    return UseSectionsAsReferences;\n  }\n\n  /// Returns whether .debug_loc section should be emitted.\n  bool useLocSection() const { return UseLocSection; }\n\n  /// Returns whether to generate DWARF v4 type units.\n  bool generateTypeUnits() const { return GenerateTypeUnits; }\n\n  // Experimental DWARF5 features.\n\n  /// Returns what kind (if any) of accelerator tables to emit.\n  AccelTableKind getAccelTableKind() const { return TheAccelTableKind; }\n\n  bool useAppleExtensionAttributes() const {\n    return HasAppleExtensionAttributes;\n  }\n\n  /// Returns whether or not to change the current debug info for the\n  /// split dwarf proposal support.\n  bool useSplitDwarf() const { return HasSplitDwarf; }\n\n  /// Returns whether to generate a string offsets table with (possibly shared)\n  /// contributions from each CU and type unit. This implies the use of\n  /// DW_FORM_strx* indirect references with DWARF v5 and beyond. Note that\n  /// DW_FORM_GNU_str_index is also an indirect reference, but it is used with\n  /// a pre-DWARF v5 implementation of split DWARF sections, which uses a\n  /// monolithic string offsets table.\n  bool useSegmentedStringOffsetsTable() const {\n    return UseSegmentedStringOffsetsTable;\n  }\n\n  bool emitDebugEntryValues() const {\n    return EmitDebugEntryValues;\n  }\n\n  bool useOpConvert() const {\n    return EnableOpConvert;\n  }\n\n  bool shareAcrossDWOCUs() const;\n\n  /// Returns the Dwarf Version.\n  uint16_t getDwarfVersion() const;\n\n  /// Returns a suitable DWARF form to represent a section offset, i.e.\n  /// * DW_FORM_sec_offset for DWARF version >= 4;\n  /// * DW_FORM_data8 for 64-bit DWARFv3;\n  /// * DW_FORM_data4 for 32-bit DWARFv3 and DWARFv2.\n  dwarf::Form getDwarfSectionOffsetForm() const;\n\n  /// Returns the previous CU that was being updated\n  const DwarfCompileUnit *getPrevCU() const { return PrevCU; }\n  void setPrevCU(const DwarfCompileUnit *PrevCU) { this->PrevCU = PrevCU; }\n\n  /// Returns the entries for the .debug_loc section.\n  const DebugLocStream &getDebugLocs() const { return DebugLocs; }\n\n  /// Emit an entry for the debug loc section. This can be used to\n  /// handle an entry that's going to be emitted into the debug loc section.\n  void emitDebugLocEntry(ByteStreamer &Streamer,\n                         const DebugLocStream::Entry &Entry,\n                         const DwarfCompileUnit *CU);\n\n  /// Emit the location for a debug loc entry, including the size header.\n  void emitDebugLocEntryLocation(const DebugLocStream::Entry &Entry,\n                                 const DwarfCompileUnit *CU);\n\n  void addSubprogramNames(const DICompileUnit &CU, const DISubprogram *SP,\n                          DIE &Die);\n\n  AddressPool &getAddressPool() { return AddrPool; }\n\n  void addAccelName(const DICompileUnit &CU, StringRef Name, const DIE &Die);\n\n  void addAccelObjC(const DICompileUnit &CU, StringRef Name, const DIE &Die);\n\n  void addAccelNamespace(const DICompileUnit &CU, StringRef Name,\n                         const DIE &Die);\n\n  void addAccelType(const DICompileUnit &CU, StringRef Name, const DIE &Die,\n                    char Flags);\n\n  const MachineFunction *getCurrentFunction() const { return CurFn; }\n\n  /// A helper function to check whether the DIE for a given Scope is\n  /// going to be null.\n  bool isLexicalScopeDIENull(LexicalScope *Scope);\n\n  /// Find the matching DwarfCompileUnit for the given CU DIE.\n  DwarfCompileUnit *lookupCU(const DIE *Die) { return CUDieMap.lookup(Die); }\n  const DwarfCompileUnit *lookupCU(const DIE *Die) const {\n    return CUDieMap.lookup(Die);\n  }\n\n  unsigned getStringTypeLoc(const DIStringType *ST) const {\n    return StringTypeLocMap.lookup(ST);\n  }\n\n  void addStringTypeLoc(const DIStringType *ST, unsigned Loc) {\n    assert(ST);\n    if (Loc)\n      StringTypeLocMap[ST] = Loc;\n  }\n\n  /// \\defgroup DebuggerTuning Predicates to tune DWARF for a given debugger.\n  ///\n  /// Returns whether we are \"tuning\" for a given debugger.\n  /// @{\n  bool tuneForGDB() const { return DebuggerTuning == DebuggerKind::GDB; }\n  bool tuneForLLDB() const { return DebuggerTuning == DebuggerKind::LLDB; }\n  bool tuneForSCE() const { return DebuggerTuning == DebuggerKind::SCE; }\n  /// @}\n\n  const MCSymbol *getSectionLabel(const MCSection *S);\n  void insertSectionLabel(const MCSymbol *S);\n\n  static void emitDebugLocValue(const AsmPrinter &AP, const DIBasicType *BT,\n                                const DbgValueLoc &Value,\n                                DwarfExpression &DwarfExpr);\n\n  /// If the \\p File has an MD5 checksum, return it as an MD5Result\n  /// allocated in the MCContext.\n  Optional<MD5::MD5Result> getMD5AsBytes(const DIFile *File) const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_LIB_CODEGEN_ASMPRINTER_DWARFDEBUG_H\n"}, "95": {"id": 95, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h", "content": "//===- llvm/CodeGen/DwarfExpression.h - Dwarf Compile Unit ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains support for writing dwarf compile unit.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_CODEGEN_ASMPRINTER_DWARFEXPRESSION_H\n#define LLVM_LIB_CODEGEN_ASMPRINTER_DWARFEXPRESSION_H\n\n#include \"ByteStreamer.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include <cassert>\n#include <cstdint>\n#include <iterator>\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass APInt;\nclass DwarfCompileUnit;\nclass DIELoc;\nclass TargetRegisterInfo;\nclass MachineLocation;\n\n/// Holds a DIExpression and keeps track of how many operands have been consumed\n/// so far.\nclass DIExpressionCursor {\n  DIExpression::expr_op_iterator Start, End;\n\npublic:\n  DIExpressionCursor(const DIExpression *Expr) {\n    if (!Expr) {\n      assert(Start == End);\n      return;\n    }\n    Start = Expr->expr_op_begin();\n    End = Expr->expr_op_end();\n  }\n\n  DIExpressionCursor(ArrayRef<uint64_t> Expr)\n      : Start(Expr.begin()), End(Expr.end()) {}\n\n  DIExpressionCursor(const DIExpressionCursor &) = default;\n\n  /// Consume one operation.\n  Optional<DIExpression::ExprOperand> take() {\n    if (Start == End)\n      return None;\n    return *(Start++);\n  }\n\n  /// Consume N operations.\n  void consume(unsigned N) { std::advance(Start, N); }\n\n  /// Return the current operation.\n  Optional<DIExpression::ExprOperand> peek() const {\n    if (Start == End)\n      return None;\n    return *(Start);\n  }\n\n  /// Return the next operation.\n  Optional<DIExpression::ExprOperand> peekNext() const {\n    if (Start == End)\n      return None;\n\n    auto Next = Start.getNext();\n    if (Next == End)\n      return None;\n\n    return *Next;\n  }\n\n  /// Determine whether there are any operations left in this expression.\n  operator bool() const { return Start != End; }\n\n  DIExpression::expr_op_iterator begin() const { return Start; }\n  DIExpression::expr_op_iterator end() const { return End; }\n\n  /// Retrieve the fragment information, if any.\n  Optional<DIExpression::FragmentInfo> getFragmentInfo() const {\n    return DIExpression::getFragmentInfo(Start, End);\n  }\n};\n\n/// Base class containing the logic for constructing DWARF expressions\n/// independently of whether they are emitted into a DIE or into a .debug_loc\n/// entry.\n///\n/// Some DWARF operations, e.g. DW_OP_entry_value, need to calculate the size\n/// of a succeeding DWARF block before the latter is emitted to the output.\n/// To handle such cases, data can conditionally be emitted to a temporary\n/// buffer, which can later on be committed to the main output. The size of the\n/// temporary buffer is queryable, allowing for the size of the data to be\n/// emitted before the data is committed.\nclass DwarfExpression {\nprotected:\n  /// Holds information about all subregisters comprising a register location.\n  struct Register {\n    int DwarfRegNo;\n    unsigned SubRegSize;\n    const char *Comment;\n\n    /// Create a full register, no extra DW_OP_piece operators necessary.\n    static Register createRegister(int RegNo, const char *Comment) {\n      return {RegNo, 0, Comment};\n    }\n\n    /// Create a subregister that needs a DW_OP_piece operator with SizeInBits.\n    static Register createSubRegister(int RegNo, unsigned SizeInBits,\n                                      const char *Comment) {\n      return {RegNo, SizeInBits, Comment};\n    }\n\n    bool isSubRegister() const { return SubRegSize; }\n  };\n\n  /// Whether we are currently emitting an entry value operation.\n  bool IsEmittingEntryValue = false;\n\n  DwarfCompileUnit &CU;\n\n  /// The register location, if any.\n  SmallVector<Register, 2> DwarfRegs;\n\n  /// Current Fragment Offset in Bits.\n  uint64_t OffsetInBits = 0;\n\n  /// Sometimes we need to add a DW_OP_bit_piece to describe a subregister.\n  unsigned SubRegisterSizeInBits : 16;\n  unsigned SubRegisterOffsetInBits : 16;\n\n  /// The kind of location description being produced.\n  enum { Unknown = 0, Register, Memory, Implicit };\n\n  /// Additional location flags which may be combined with any location kind.\n  /// Currently, entry values are not supported for the Memory location kind.\n  enum { EntryValue = 1 << 0, Indirect = 1 << 1, CallSiteParamValue = 1 << 2 };\n\n  unsigned LocationKind : 3;\n  unsigned SavedLocationKind : 3;\n  unsigned LocationFlags : 3;\n  unsigned DwarfVersion : 4;\n\npublic:\n  /// Set the location (\\p Loc) and \\ref DIExpression (\\p DIExpr) to describe.\n  void setLocation(const MachineLocation &Loc, const DIExpression *DIExpr);\n\n  bool isUnknownLocation() const { return LocationKind == Unknown; }\n\n  bool isMemoryLocation() const { return LocationKind == Memory; }\n\n  bool isRegisterLocation() const { return LocationKind == Register; }\n\n  bool isImplicitLocation() const { return LocationKind == Implicit; }\n\n  bool isEntryValue() const { return LocationFlags & EntryValue; }\n\n  bool isIndirect() const { return LocationFlags & Indirect; }\n\n  bool isParameterValue() { return LocationFlags & CallSiteParamValue; }\n\n  Optional<uint8_t> TagOffset;\n\nprotected:\n  /// Push a DW_OP_piece / DW_OP_bit_piece for emitting later, if one is needed\n  /// to represent a subregister.\n  void setSubRegisterPiece(unsigned SizeInBits, unsigned OffsetInBits) {\n    assert(SizeInBits < 65536 && OffsetInBits < 65536);\n    SubRegisterSizeInBits = SizeInBits;\n    SubRegisterOffsetInBits = OffsetInBits;\n  }\n\n  /// Add masking operations to stencil out a subregister.\n  void maskSubRegister();\n\n  /// Output a dwarf operand and an optional assembler comment.\n  virtual void emitOp(uint8_t Op, const char *Comment = nullptr) = 0;\n\n  /// Emit a raw signed value.\n  virtual void emitSigned(int64_t Value) = 0;\n\n  /// Emit a raw unsigned value.\n  virtual void emitUnsigned(uint64_t Value) = 0;\n\n  virtual void emitData1(uint8_t Value) = 0;\n\n  virtual void emitBaseTypeRef(uint64_t Idx) = 0;\n\n  /// Start emitting data to the temporary buffer. The data stored in the\n  /// temporary buffer can be committed to the main output using\n  /// commitTemporaryBuffer().\n  virtual void enableTemporaryBuffer() = 0;\n\n  /// Disable emission to the temporary buffer. This does not commit data\n  /// in the temporary buffer to the main output.\n  virtual void disableTemporaryBuffer() = 0;\n\n  /// Return the emitted size, in number of bytes, for the data stored in the\n  /// temporary buffer.\n  virtual unsigned getTemporaryBufferSize() = 0;\n\n  /// Commit the data stored in the temporary buffer to the main output.\n  virtual void commitTemporaryBuffer() = 0;\n\n  /// Emit a normalized unsigned constant.\n  void emitConstu(uint64_t Value);\n\n  /// Return whether the given machine register is the frame register in the\n  /// current function.\n  virtual bool isFrameRegister(const TargetRegisterInfo &TRI,\n                               llvm::Register MachineReg) = 0;\n\n  /// Emit a DW_OP_reg operation. Note that this is only legal inside a DWARF\n  /// register location description.\n  void addReg(int DwarfReg, const char *Comment = nullptr);\n\n  /// Emit a DW_OP_breg operation.\n  void addBReg(int DwarfReg, int Offset);\n\n  /// Emit DW_OP_fbreg <Offset>.\n  void addFBReg(int Offset);\n\n  /// Emit a partial DWARF register operation.\n  ///\n  /// \\param MachineReg           The register number.\n  /// \\param MaxSize              If the register must be composed from\n  ///                             sub-registers this is an upper bound\n  ///                             for how many bits the emitted DW_OP_piece\n  ///                             may cover.\n  ///\n  /// If size and offset is zero an operation for the entire register is\n  /// emitted: Some targets do not provide a DWARF register number for every\n  /// register.  If this is the case, this function will attempt to emit a DWARF\n  /// register by emitting a fragment of a super-register or by piecing together\n  /// multiple subregisters that alias the register.\n  ///\n  /// \\return false if no DWARF register exists for MachineReg.\n  bool addMachineReg(const TargetRegisterInfo &TRI, llvm::Register MachineReg,\n                     unsigned MaxSize = ~1U);\n\n  /// Emit a DW_OP_piece or DW_OP_bit_piece operation for a variable fragment.\n  /// \\param OffsetInBits    This is an optional offset into the location that\n  /// is at the top of the DWARF stack.\n  void addOpPiece(unsigned SizeInBits, unsigned OffsetInBits = 0);\n\n  /// Emit a shift-right dwarf operation.\n  void addShr(unsigned ShiftBy);\n\n  /// Emit a bitwise and dwarf operation.\n  void addAnd(unsigned Mask);\n\n  /// Emit a DW_OP_stack_value, if supported.\n  ///\n  /// The proper way to describe a constant value is DW_OP_constu <const>,\n  /// DW_OP_stack_value.  Unfortunately, DW_OP_stack_value was not available\n  /// until DWARF 4, so we will continue to generate DW_OP_constu <const> for\n  /// DWARF 2 and DWARF 3. Technically, this is incorrect since DW_OP_const\n  /// <const> actually describes a value at a constant address, not a constant\n  /// value.  However, in the past there was no better way to describe a\n  /// constant value, so the producers and consumers started to rely on\n  /// heuristics to disambiguate the value vs. location status of the\n  /// expression.  See PR21176 for more details.\n  void addStackValue();\n\n  /// Finalize an entry value by emitting its size operand, and committing the\n  /// DWARF block which has been emitted to the temporary buffer.\n  void finalizeEntryValue();\n\n  /// Cancel the emission of an entry value.\n  void cancelEntryValue();\n\n  ~DwarfExpression() = default;\n\npublic:\n  DwarfExpression(unsigned DwarfVersion, DwarfCompileUnit &CU)\n      : CU(CU), SubRegisterSizeInBits(0), SubRegisterOffsetInBits(0),\n        LocationKind(Unknown), SavedLocationKind(Unknown),\n        LocationFlags(Unknown), DwarfVersion(DwarfVersion) {}\n\n  /// This needs to be called last to commit any pending changes.\n  void finalize();\n\n  /// Emit a signed constant.\n  void addSignedConstant(int64_t Value);\n\n  /// Emit an unsigned constant.\n  void addUnsignedConstant(uint64_t Value);\n\n  /// Emit an unsigned constant.\n  void addUnsignedConstant(const APInt &Value);\n\n  /// Emit an floating point constant.\n  void addConstantFP(const APFloat &Value, const AsmPrinter &AP);\n\n  /// Lock this down to become a memory location description.\n  void setMemoryLocationKind() {\n    assert(isUnknownLocation());\n    LocationKind = Memory;\n  }\n\n  /// Lock this down to become an entry value location.\n  void setEntryValueFlags(const MachineLocation &Loc);\n\n  /// Lock this down to become a call site parameter location.\n  void setCallSiteParamValueFlag() { LocationFlags |= CallSiteParamValue; }\n\n  /// Emit a machine register location. As an optimization this may also consume\n  /// the prefix of a DwarfExpression if a more efficient representation for\n  /// combining the register location and the first operation exists.\n  ///\n  /// \\param FragmentOffsetInBits     If this is one fragment out of a\n  /// fragmented\n  ///                                 location, this is the offset of the\n  ///                                 fragment inside the entire variable.\n  /// \\return                         false if no DWARF register exists\n  ///                                 for MachineReg.\n  bool addMachineRegExpression(const TargetRegisterInfo &TRI,\n                               DIExpressionCursor &Expr,\n                               llvm::Register MachineReg,\n                               unsigned FragmentOffsetInBits = 0);\n\n  /// Begin emission of an entry value dwarf operation. The entry value's\n  /// first operand is the size of the DWARF block (its second operand),\n  /// which needs to be calculated at time of emission, so we don't emit\n  /// any operands here.\n  void beginEntryValueExpression(DIExpressionCursor &ExprCursor);\n\n  /// Return the index of a base type with the given properties and\n  /// create one if necessary.\n  unsigned getOrCreateBaseType(unsigned BitSize, dwarf::TypeKind Encoding);\n\n  /// Emit all remaining operations in the DIExpressionCursor.\n  ///\n  /// \\param FragmentOffsetInBits     If this is one fragment out of multiple\n  ///                                 locations, this is the offset of the\n  ///                                 fragment inside the entire variable.\n  void addExpression(DIExpressionCursor &&Expr,\n                     unsigned FragmentOffsetInBits = 0);\n  void\n  addExpression(DIExpressionCursor &&Expr,\n                std::function<bool(unsigned, DIExpressionCursor &)> InsertArg);\n\n  /// If applicable, emit an empty DW_OP_piece / DW_OP_bit_piece to advance to\n  /// the fragment described by \\c Expr.\n  void addFragmentOffset(const DIExpression *Expr);\n\n  void emitLegacySExt(unsigned FromBits);\n  void emitLegacyZExt(unsigned FromBits);\n\n  /// Emit location information expressed via WebAssembly location + offset\n  /// The Index is an identifier for locals, globals or operand stack.\n  void addWasmLocation(unsigned Index, uint64_t Offset);\n};\n\n/// DwarfExpression implementation for .debug_loc entries.\nclass DebugLocDwarfExpression final : public DwarfExpression {\n\n  struct TempBuffer {\n    SmallString<32> Bytes;\n    std::vector<std::string> Comments;\n    BufferByteStreamer BS;\n\n    TempBuffer(bool GenerateComments) : BS(Bytes, Comments, GenerateComments) {}\n  };\n\n  std::unique_ptr<TempBuffer> TmpBuf;\n  BufferByteStreamer &OutBS;\n  bool IsBuffering = false;\n\n  /// Return the byte streamer that currently is being emitted to.\n  ByteStreamer &getActiveStreamer() { return IsBuffering ? TmpBuf->BS : OutBS; }\n\n  void emitOp(uint8_t Op, const char *Comment = nullptr) override;\n  void emitSigned(int64_t Value) override;\n  void emitUnsigned(uint64_t Value) override;\n  void emitData1(uint8_t Value) override;\n  void emitBaseTypeRef(uint64_t Idx) override;\n\n  void enableTemporaryBuffer() override;\n  void disableTemporaryBuffer() override;\n  unsigned getTemporaryBufferSize() override;\n  void commitTemporaryBuffer() override;\n\n  bool isFrameRegister(const TargetRegisterInfo &TRI,\n                       llvm::Register MachineReg) override;\n\npublic:\n  DebugLocDwarfExpression(unsigned DwarfVersion, BufferByteStreamer &BS,\n                          DwarfCompileUnit &CU)\n      : DwarfExpression(DwarfVersion, CU), OutBS(BS) {}\n};\n\n/// DwarfExpression implementation for singular DW_AT_location.\nclass DIEDwarfExpression final : public DwarfExpression {\n  const AsmPrinter &AP;\n  DIELoc &OutDIE;\n  DIELoc TmpDIE;\n  bool IsBuffering = false;\n\n  /// Return the DIE that currently is being emitted to.\n  DIELoc &getActiveDIE() { return IsBuffering ? TmpDIE : OutDIE; }\n\n  void emitOp(uint8_t Op, const char *Comment = nullptr) override;\n  void emitSigned(int64_t Value) override;\n  void emitUnsigned(uint64_t Value) override;\n  void emitData1(uint8_t Value) override;\n  void emitBaseTypeRef(uint64_t Idx) override;\n\n  void enableTemporaryBuffer() override;\n  void disableTemporaryBuffer() override;\n  unsigned getTemporaryBufferSize() override;\n  void commitTemporaryBuffer() override;\n\n  bool isFrameRegister(const TargetRegisterInfo &TRI,\n                       llvm::Register MachineReg) override;\n\npublic:\n  DIEDwarfExpression(const AsmPrinter &AP, DwarfCompileUnit &CU, DIELoc &DIE);\n\n  DIELoc *finalize() {\n    DwarfExpression::finalize();\n    return &OutDIE;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_LIB_CODEGEN_ASMPRINTER_DWARFEXPRESSION_H\n"}, "96": {"id": 96, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfFile.h", "content": "//===- llvm/CodeGen/DwarfFile.h - Dwarf Debug Framework ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_CODEGEN_ASMPRINTER_DWARFFILE_H\n#define LLVM_LIB_CODEGEN_ASMPRINTER_DWARFFILE_H\n\n#include \"DwarfStringPool.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/CodeGen/DIE.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <map>\n#include <memory>\n#include <utility>\n\nnamespace llvm {\n\nclass AsmPrinter;\nclass DbgEntity;\nclass DbgVariable;\nclass DbgLabel;\nclass DINode;\nclass DwarfCompileUnit;\nclass DwarfUnit;\nclass LexicalScope;\nclass MCSection;\nclass MDNode;\n\n// Data structure to hold a range for range lists.\nstruct RangeSpan {\n  const MCSymbol *Begin;\n  const MCSymbol *End;\n};\n\nstruct RangeSpanList {\n  // Index for locating within the debug_range section this particular span.\n  MCSymbol *Label;\n  const DwarfCompileUnit *CU;\n  // List of ranges.\n  SmallVector<RangeSpan, 2> Ranges;\n};\n\nclass DwarfFile {\n  // Target of Dwarf emission, used for sizing of abbreviations.\n  AsmPrinter *Asm;\n\n  BumpPtrAllocator AbbrevAllocator;\n\n  // Used to uniquely define abbreviations.\n  DIEAbbrevSet Abbrevs;\n\n  // A pointer to all units in the section.\n  SmallVector<std::unique_ptr<DwarfCompileUnit>, 1> CUs;\n\n  DwarfStringPool StrPool;\n\n  // List of range lists for a given compile unit, separate from the ranges for\n  // the CU itself.\n  SmallVector<RangeSpanList, 1> CURangeLists;\n\n  /// DWARF v5: The symbol that designates the start of the contribution to\n  /// the string offsets table. The contribution is shared by all units.\n  MCSymbol *StringOffsetsStartSym = nullptr;\n\n  /// DWARF v5: The symbol that designates the base of the range list table.\n  /// The table is shared by all units.\n  MCSymbol *RnglistsTableBaseSym = nullptr;\n\n  /// The variables of a lexical scope.\n  struct ScopeVars {\n    /// We need to sort Args by ArgNo and check for duplicates. This could also\n    /// be implemented as a list or vector + std::lower_bound().\n    std::map<unsigned, DbgVariable *> Args;\n    SmallVector<DbgVariable *, 8> Locals;\n  };\n  /// Collection of DbgVariables of each lexical scope.\n  DenseMap<LexicalScope *, ScopeVars> ScopeVariables;\n\n  /// Collection of DbgLabels of each lexical scope.\n  using LabelList = SmallVector<DbgLabel *, 4>;\n  DenseMap<LexicalScope *, LabelList> ScopeLabels;\n\n  // Collection of abstract subprogram DIEs.\n  DenseMap<const MDNode *, DIE *> AbstractSPDies;\n  DenseMap<const DINode *, std::unique_ptr<DbgEntity>> AbstractEntities;\n\n  /// Maps MDNodes for type system with the corresponding DIEs. These DIEs can\n  /// be shared across CUs, that is why we keep the map here instead\n  /// of in DwarfCompileUnit.\n  DenseMap<const MDNode *, DIE *> DITypeNodeToDieMap;\n\npublic:\n  DwarfFile(AsmPrinter *AP, StringRef Pref, BumpPtrAllocator &DA);\n\n  const SmallVectorImpl<std::unique_ptr<DwarfCompileUnit>> &getUnits() {\n    return CUs;\n  }\n\n  std::pair<uint32_t, RangeSpanList *> addRange(const DwarfCompileUnit &CU,\n                                                SmallVector<RangeSpan, 2> R);\n\n  /// getRangeLists - Get the vector of range lists.\n  const SmallVectorImpl<RangeSpanList> &getRangeLists() const {\n    return CURangeLists;\n  }\n\n  /// Compute the size and offset of a DIE given an incoming Offset.\n  unsigned computeSizeAndOffset(DIE &Die, unsigned Offset);\n\n  /// Compute the size and offset of all the DIEs.\n  void computeSizeAndOffsets();\n\n  /// Compute the size and offset of all the DIEs in the given unit.\n  /// \\returns The size of the root DIE.\n  unsigned computeSizeAndOffsetsForUnit(DwarfUnit *TheU);\n\n  /// Add a unit to the list of CUs.\n  void addUnit(std::unique_ptr<DwarfCompileUnit> U);\n\n  /// Emit all of the units to the section listed with the given\n  /// abbreviation section.\n  void emitUnits(bool UseOffsets);\n\n  /// Emit the given unit to its section.\n  void emitUnit(DwarfUnit *TheU, bool UseOffsets);\n\n  /// Emit a set of abbreviations to the specific section.\n  void emitAbbrevs(MCSection *);\n\n  /// Emit all of the strings to the section given. If OffsetSection is\n  /// non-null, emit a table of string offsets to it. If UseRelativeOffsets\n  /// is false, emit absolute offsets to the strings. Otherwise, emit\n  /// relocatable references to the strings if they are supported by the target.\n  void emitStrings(MCSection *StrSection, MCSection *OffsetSection = nullptr,\n                   bool UseRelativeOffsets = false);\n\n  /// Returns the string pool.\n  DwarfStringPool &getStringPool() { return StrPool; }\n\n  MCSymbol *getStringOffsetsStartSym() const { return StringOffsetsStartSym; }\n  void setStringOffsetsStartSym(MCSymbol *Sym) { StringOffsetsStartSym = Sym; }\n\n  MCSymbol *getRnglistsTableBaseSym() const { return RnglistsTableBaseSym; }\n  void setRnglistsTableBaseSym(MCSymbol *Sym) { RnglistsTableBaseSym = Sym; }\n\n  /// \\returns false if the variable was merged with a previous one.\n  bool addScopeVariable(LexicalScope *LS, DbgVariable *Var);\n\n  void addScopeLabel(LexicalScope *LS, DbgLabel *Label);\n\n  DenseMap<LexicalScope *, ScopeVars> &getScopeVariables() {\n    return ScopeVariables;\n  }\n\n  DenseMap<LexicalScope *, LabelList> &getScopeLabels() {\n    return ScopeLabels;\n  }\n\n  DenseMap<const MDNode *, DIE *> &getAbstractSPDies() {\n    return AbstractSPDies;\n  }\n\n  DenseMap<const DINode *, std::unique_ptr<DbgEntity>> &getAbstractEntities() {\n    return AbstractEntities;\n  }\n\n  void insertDIE(const MDNode *TypeMD, DIE *Die) {\n    DITypeNodeToDieMap.insert(std::make_pair(TypeMD, Die));\n  }\n\n  DIE *getDIE(const MDNode *TypeMD) {\n    return DITypeNodeToDieMap.lookup(TypeMD);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_LIB_CODEGEN_ASMPRINTER_DWARFFILE_H\n"}, "97": {"id": 97, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h", "content": "//===-- llvm/CodeGen/DwarfUnit.h - Dwarf Compile Unit ---*- C++ -*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains support for writing dwarf compile unit.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_CODEGEN_ASMPRINTER_DWARFUNIT_H\n#define LLVM_LIB_CODEGEN_ASMPRINTER_DWARFUNIT_H\n\n#include \"DwarfDebug.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/CodeGen/AsmPrinter.h\"\n#include \"llvm/CodeGen/DIE.h\"\n#include <string>\n\nnamespace llvm {\n\nclass ConstantFP;\nclass ConstantInt;\nclass DbgVariable;\nclass DwarfCompileUnit;\nclass MachineOperand;\nclass MCDwarfDwoLineTable;\nclass MCSymbol;\n\n//===----------------------------------------------------------------------===//\n/// This dwarf writer support class manages information associated with a\n/// source file.\nclass DwarfUnit : public DIEUnit {\nprotected:\n  /// MDNode for the compile unit.\n  const DICompileUnit *CUNode;\n\n  // All DIEValues are allocated through this allocator.\n  BumpPtrAllocator DIEValueAllocator;\n\n  /// Target of Dwarf emission.\n  AsmPrinter *Asm;\n\n  /// Emitted at the end of the CU and used to compute the CU Length field.\n  MCSymbol *EndLabel = nullptr;\n\n  // Holders for some common dwarf information.\n  DwarfDebug *DD;\n  DwarfFile *DU;\n\n  /// An anonymous type for index type.  Owned by DIEUnit.\n  DIE *IndexTyDie;\n\n  /// Tracks the mapping of unit level debug information variables to debug\n  /// information entries.\n  DenseMap<const MDNode *, DIE *> MDNodeToDieMap;\n\n  /// A list of all the DIEBlocks in use.\n  std::vector<DIEBlock *> DIEBlocks;\n\n  /// A list of all the DIELocs in use.\n  std::vector<DIELoc *> DIELocs;\n\n  /// This map is used to keep track of subprogram DIEs that need\n  /// DW_AT_containing_type attribute. This attribute points to a DIE that\n  /// corresponds to the MDNode mapped with the subprogram DIE.\n  DenseMap<DIE *, const DINode *> ContainingTypeMap;\n\n  DwarfUnit(dwarf::Tag, const DICompileUnit *Node, AsmPrinter *A, DwarfDebug *DW,\n            DwarfFile *DWU);\n\n  bool applySubprogramDefinitionAttributes(const DISubprogram *SP, DIE &SPDie);\n\n  bool isShareableAcrossCUs(const DINode *D) const;\n\npublic:\n  // Accessors.\n  AsmPrinter* getAsmPrinter() const { return Asm; }\n  MCSymbol *getEndLabel() const { return EndLabel; }\n  uint16_t getLanguage() const { return CUNode->getSourceLanguage(); }\n  const DICompileUnit *getCUNode() const { return CUNode; }\n  DwarfDebug &getDwarfDebug() const { return *DD; }\n\n  /// Return true if this compile unit has something to write out.\n  bool hasContent() const { return getUnitDie().hasChildren(); }\n\n  /// Get string containing language specific context for a global name.\n  ///\n  /// Walks the metadata parent chain in a language specific manner (using the\n  /// compile unit language) and returns it as a string. This is done at the\n  /// metadata level because DIEs may not currently have been added to the\n  /// parent context and walking the DIEs looking for names is more expensive\n  /// than walking the metadata.\n  std::string getParentContextString(const DIScope *Context) const;\n\n  /// Add a new global name to the compile unit.\n  virtual void addGlobalName(StringRef Name, const DIE &Die,\n                             const DIScope *Context) = 0;\n\n  /// Add a new global type to the compile unit.\n  virtual void addGlobalType(const DIType *Ty, const DIE &Die,\n                             const DIScope *Context) = 0;\n\n  /// Returns the DIE map slot for the specified debug variable.\n  ///\n  /// We delegate the request to DwarfDebug when the MDNode can be part of the\n  /// type system, since DIEs for the type system can be shared across CUs and\n  /// the mappings are kept in DwarfDebug.\n  DIE *getDIE(const DINode *D) const;\n\n  /// Returns a fresh newly allocated DIELoc.\n  DIELoc *getDIELoc() { return new (DIEValueAllocator) DIELoc; }\n\n  /// Insert DIE into the map.\n  ///\n  /// We delegate the request to DwarfDebug when the MDNode can be part of the\n  /// type system, since DIEs for the type system can be shared across CUs and\n  /// the mappings are kept in DwarfDebug.\n  void insertDIE(const DINode *Desc, DIE *D);\n\n  void insertDIE(DIE *D);\n\n  /// Add a flag that is true to the DIE.\n  void addFlag(DIE &Die, dwarf::Attribute Attribute);\n\n  /// Add an unsigned integer attribute data and value.\n  void addUInt(DIEValueList &Die, dwarf::Attribute Attribute,\n               Optional<dwarf::Form> Form, uint64_t Integer);\n\n  void addUInt(DIEValueList &Block, dwarf::Form Form, uint64_t Integer);\n\n  /// Add an signed integer attribute data and value.\n  void addSInt(DIEValueList &Die, dwarf::Attribute Attribute,\n               Optional<dwarf::Form> Form, int64_t Integer);\n\n  void addSInt(DIELoc &Die, Optional<dwarf::Form> Form, int64_t Integer);\n\n  /// Add a string attribute data and value.\n  ///\n  /// We always emit a reference to the string pool instead of immediate\n  /// strings so that DIEs have more predictable sizes. In the case of split\n  /// dwarf we emit an index into another table which gets us the static offset\n  /// into the string table.\n  void addString(DIE &Die, dwarf::Attribute Attribute, StringRef Str);\n\n  /// Add a Dwarf label attribute data and value.\n  DIEValueList::value_iterator addLabel(DIEValueList &Die,\n                                        dwarf::Attribute Attribute,\n                                        dwarf::Form Form,\n                                        const MCSymbol *Label);\n\n  void addLabel(DIELoc &Die, dwarf::Form Form, const MCSymbol *Label);\n\n  /// Add an offset into a section attribute data and value.\n  void addSectionOffset(DIE &Die, dwarf::Attribute Attribute, uint64_t Integer);\n\n  /// Add a dwarf op address data and value using the form given and an\n  /// op of either DW_FORM_addr or DW_FORM_GNU_addr_index.\n  void addOpAddress(DIELoc &Die, const MCSymbol *Sym);\n  void addPoolOpAddress(DIEValueList &Die, const MCSymbol *Label);\n\n  /// Add a label delta attribute data and value.\n  void addLabelDelta(DIEValueList &Die, dwarf::Attribute Attribute,\n                     const MCSymbol *Hi, const MCSymbol *Lo);\n\n  /// Add a DIE attribute data and value.\n  void addDIEEntry(DIE &Die, dwarf::Attribute Attribute, DIE &Entry);\n\n  /// Add a DIE attribute data and value.\n  void addDIEEntry(DIE &Die, dwarf::Attribute Attribute, DIEEntry Entry);\n\n  /// Add a type's DW_AT_signature and set the  declaration flag.\n  void addDIETypeSignature(DIE &Die, uint64_t Signature);\n\n  /// Add block data.\n  void addBlock(DIE &Die, dwarf::Attribute Attribute, DIELoc *Loc);\n\n  /// Add block data.\n  void addBlock(DIE &Die, dwarf::Attribute Attribute, DIEBlock *Block);\n  void addBlock(DIE &Die, dwarf::Attribute Attribute, dwarf::Form Form,\n                DIEBlock *Block);\n\n  /// Add location information to specified debug information entry.\n  void addSourceLine(DIE &Die, unsigned Line, const DIFile *File);\n  void addSourceLine(DIE &Die, const DILocalVariable *V);\n  void addSourceLine(DIE &Die, const DIGlobalVariable *G);\n  void addSourceLine(DIE &Die, const DISubprogram *SP);\n  void addSourceLine(DIE &Die, const DILabel *L);\n  void addSourceLine(DIE &Die, const DIType *Ty);\n  void addSourceLine(DIE &Die, const DIObjCProperty *Ty);\n\n  /// Add constant value entry in variable DIE.\n  void addConstantValue(DIE &Die, const ConstantInt *CI, const DIType *Ty);\n  void addConstantValue(DIE &Die, const APInt &Val, const DIType *Ty);\n  void addConstantValue(DIE &Die, const APInt &Val, bool Unsigned);\n  void addConstantValue(DIE &Die, uint64_t Val, const DIType *Ty);\n  void addConstantValue(DIE &Die, bool Unsigned, uint64_t Val);\n\n  /// Add constant value entry in variable DIE.\n  void addConstantFPValue(DIE &Die, const ConstantFP *CFP);\n\n  /// Add a linkage name, if it isn't empty.\n  void addLinkageName(DIE &Die, StringRef LinkageName);\n\n  /// Add template parameters in buffer.\n  void addTemplateParams(DIE &Buffer, DINodeArray TParams);\n\n  /// Add thrown types.\n  void addThrownTypes(DIE &Die, DINodeArray ThrownTypes);\n\n  /// Add a new type attribute to the specified entity.\n  ///\n  /// This takes and attribute parameter because DW_AT_friend attributes are\n  /// also type references.\n  void addType(DIE &Entity, const DIType *Ty,\n               dwarf::Attribute Attribute = dwarf::DW_AT_type);\n\n  DIE *getOrCreateNameSpace(const DINamespace *NS);\n  DIE *getOrCreateModule(const DIModule *M);\n  DIE *getOrCreateSubprogramDIE(const DISubprogram *SP, bool Minimal = false);\n\n  void applySubprogramAttributes(const DISubprogram *SP, DIE &SPDie,\n                                 bool SkipSPAttributes = false);\n\n  /// Creates type DIE with specific context.\n  DIE *createTypeDIE(const DIScope *Context, DIE &ContextDIE, const DIType *Ty);\n\n  /// Find existing DIE or create new DIE for the given type.\n  DIE *getOrCreateTypeDIE(const MDNode *TyNode);\n\n  /// Get context owner's DIE.\n  DIE *getOrCreateContextDIE(const DIScope *Context);\n\n  /// Construct DIEs for types that contain vtables.\n  void constructContainingTypeDIEs();\n\n  /// Construct function argument DIEs.\n  void constructSubprogramArguments(DIE &Buffer, DITypeRefArray Args);\n\n  /// Create a DIE with the given Tag, add the DIE to its parent, and\n  /// call insertDIE if MD is not null.\n  DIE &createAndAddDIE(unsigned Tag, DIE &Parent, const DINode *N = nullptr);\n\n  bool useSegmentedStringOffsetsTable() const {\n    return DD->useSegmentedStringOffsetsTable();\n  }\n\n  /// Compute the size of a header for this unit, not including the initial\n  /// length field.\n  virtual unsigned getHeaderSize() const {\n    return sizeof(int16_t) +               // DWARF version number\n           Asm->getDwarfOffsetByteSize() + // Offset Into Abbrev. Section\n           sizeof(int8_t) +                // Pointer Size (in bytes)\n           (DD->getDwarfVersion() >= 5 ? sizeof(int8_t)\n                                       : 0); // DWARF v5 unit type\n  }\n\n  /// Emit the header for this unit, not including the initial length field.\n  virtual void emitHeader(bool UseOffsets) = 0;\n\n  /// Add the DW_AT_str_offsets_base attribute to the unit DIE.\n  void addStringOffsetsStart();\n\n  /// Add the DW_AT_rnglists_base attribute to the unit DIE.\n  void addRnglistsBase();\n\n  virtual DwarfCompileUnit &getCU() = 0;\n\n  void constructTypeDIE(DIE &Buffer, const DICompositeType *CTy);\n\n  /// addSectionDelta - Add a label delta attribute data and value.\n  DIE::value_iterator addSectionDelta(DIE &Die, dwarf::Attribute Attribute,\n                                      const MCSymbol *Hi, const MCSymbol *Lo);\n\n  /// Add a Dwarf section label attribute data and value.\n  DIE::value_iterator addSectionLabel(DIE &Die, dwarf::Attribute Attribute,\n                                      const MCSymbol *Label,\n                                      const MCSymbol *Sec);\n\n  /// Get context owner's DIE.\n  DIE *createTypeDIE(const DICompositeType *Ty);\n\nprotected:\n  ~DwarfUnit();\n\n  /// Create new static data member DIE.\n  DIE *getOrCreateStaticMemberDIE(const DIDerivedType *DT);\n\n  /// Look up the source ID for the given file. If none currently exists,\n  /// create a new ID and insert it in the line table.\n  virtual unsigned getOrCreateSourceID(const DIFile *File) = 0;\n\n  /// Emit the common part of the header for this unit.\n  void emitCommonHeader(bool UseOffsets, dwarf::UnitType UT);\n\nprivate:\n  void constructTypeDIE(DIE &Buffer, const DIBasicType *BTy);\n  void constructTypeDIE(DIE &Buffer, const DIStringType *BTy);\n  void constructTypeDIE(DIE &Buffer, const DIDerivedType *DTy);\n  void constructTypeDIE(DIE &Buffer, const DISubroutineType *CTy);\n  void constructSubrangeDIE(DIE &Buffer, const DISubrange *SR, DIE *IndexTy);\n  void constructGenericSubrangeDIE(DIE &Buffer, const DIGenericSubrange *SR,\n                                   DIE *IndexTy);\n  void constructArrayTypeDIE(DIE &Buffer, const DICompositeType *CTy);\n  void constructEnumTypeDIE(DIE &Buffer, const DICompositeType *CTy);\n  DIE &constructMemberDIE(DIE &Buffer, const DIDerivedType *DT);\n  void constructTemplateTypeParameterDIE(DIE &Buffer,\n                                         const DITemplateTypeParameter *TP);\n  void constructTemplateValueParameterDIE(DIE &Buffer,\n                                          const DITemplateValueParameter *TVP);\n\n  /// Return the default lower bound for an array.\n  ///\n  /// If the DWARF version doesn't handle the language, return -1.\n  int64_t getDefaultLowerBound() const;\n\n  /// Get an anonymous type for index type.\n  DIE *getIndexTyDie();\n\n  /// Set D as anonymous type for index which can be reused later.\n  void setIndexTyDie(DIE *D) { IndexTyDie = D; }\n\n  virtual void finishNonUnitTypeDIE(DIE& D, const DICompositeType *CTy) = 0;\n\n  /// If this is a named finished type then include it in the list of types for\n  /// the accelerator tables.\n  void updateAcceleratorTables(const DIScope *Context, const DIType *Ty,\n                               const DIE &TyDIE);\n\n  virtual bool isDwoUnit() const = 0;\n  const MCSymbol *getCrossSectionRelativeBaseAddress() const override;\n};\n\nclass DwarfTypeUnit final : public DwarfUnit {\n  uint64_t TypeSignature;\n  const DIE *Ty;\n  DwarfCompileUnit &CU;\n  MCDwarfDwoLineTable *SplitLineTable;\n  bool UsedLineTable = false;\n\n  unsigned getOrCreateSourceID(const DIFile *File) override;\n  void finishNonUnitTypeDIE(DIE& D, const DICompositeType *CTy) override;\n  bool isDwoUnit() const override;\n\npublic:\n  DwarfTypeUnit(DwarfCompileUnit &CU, AsmPrinter *A, DwarfDebug *DW,\n                DwarfFile *DWU, MCDwarfDwoLineTable *SplitLineTable = nullptr);\n\n  void setTypeSignature(uint64_t Signature) { TypeSignature = Signature; }\n  void setType(const DIE *Ty) { this->Ty = Ty; }\n\n  /// Emit the header for this unit, not including the initial length field.\n  void emitHeader(bool UseOffsets) override;\n  unsigned getHeaderSize() const override {\n    return DwarfUnit::getHeaderSize() + sizeof(uint64_t) + // Type Signature\n           Asm->getDwarfOffsetByteSize();                  // Type DIE Offset\n  }\n  void addGlobalName(StringRef Name, const DIE &Die,\n                     const DIScope *Context) override;\n  void addGlobalType(const DIType *Ty, const DIE &Die,\n                     const DIScope *Context) override;\n  DwarfCompileUnit &getCU() override { return CU; }\n};\n} // end llvm namespace\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 3, "file": 5, "line": 916}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 5, "line": 916}, "message": "'SmallDenseMap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "a56518e4e9d3e83d5e866073c4eb1857", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 8, "line": 413}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 8, "line": 413}, "message": "'FoldingSetImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "aab45844136719ac5f801ecc109238c1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 8, "line": 531}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 8, "line": 531}, "message": "'FoldingSet' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "45d17c0c009ef8c069bc111d2fd69300", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 14, "line": 97}, "message": "'PointerUnionMembers' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "24a92f78c39febc386a77bef32999eda", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 14, "line": 100}, "message": "'PointerUnionMembers' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "11097ae7c4068865f2be3535c9a16ace", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 14, "line": 149}, "message": "'PointerUnion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "75c3146d4e3cb8f56c33112a315fa591", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 16, "line": 221}, "message": "'SmallPtrSetIteratorImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "reportHash": "6c184711d928b6db784d393e37000427", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 17, "line": 73}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 17, "line": 73}, "message": "'SmallSetIterator<T, N, C>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallSet.h", "reportHash": "bb4a048afea6961c23474ae6a3494b51", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 19, "line": 447}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 19, "line": 447}, "message": "'SparseBitVector<ElementSize>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h", "reportHash": "cab117f0fc72b55188c477e22e52a455", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 200}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 27, "line": 200}, "message": "'iplist_impl<IntrusiveListT, TraitsT>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist.h", "reportHash": "eaacc9cd33dd1bb7e8d33e2fc76d2b04", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 27, "line": 400}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 27, "line": 400}, "message": "'iplist<T, Options...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ilist.h", "reportHash": "c25c6984fc43d432f50adb0548a43d2e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 30, "line": 110}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 30, "line": 110}, "message": "'simple_ilist<T, Options...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/simple_ilist.h", "reportHash": "d01572f85774630ed5268b968c2b9bb2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 220}, "message": "'AppleAccelTableData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "b3cf350e5ee6943018aa78b8e74a4172", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 250}, "message": "'DWARF5AccelTableData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "3c9e660263dc117591c8c5395219f855", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 270}, "message": "'DWARF5AccelTableStaticData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "d8d4dd73ab310500f3c22e957dccf048", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 321}, "message": "'AppleAccelTableOffsetData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "45057bc97f266105301723f6d8c8b640", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 358}, "message": "'AppleAccelTableStaticOffsetData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h", "reportHash": "0cd11c44ec60f44a66f8b04dbf3b8d93", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 79}, "message": "'DIEAbbrev' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "dc578c3c2480b6dad08b463d89a2aa73", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 163}, "message": "'DIEInteger' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "ff82561f2fc293cf1cec61861929845c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 201}, "message": "'DIEExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "7a3351b324ed93b5bdc44c70a80d269f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 218}, "message": "'DIELabel' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "4c28b149bfd017c241a066c9997d84a4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 256}, "message": "'DIEDelta' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "36f659df6cf349d98146ac369a52ce3c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 273}, "message": "'DIEString' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "8df95718b532e80597bd757fb6ebfd85", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 314}, "message": "'DIEEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "20fe56b9c2f91f05c671763c411fcaef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 332}, "message": "'DIELocList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "bef52cb53dd2dbd6ed3d1f6f5c925845", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 515}, "message": "'IntrusiveBackListNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "d6f27bdb7b44f466407138e1aa60fcd2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 525}, "message": "'IntrusiveBackListBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "f146a109f70e6125562524ad592076a7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 33, "line": 556}, "message": "'IntrusiveBackList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "725cc400690eb4393d61aff3b3ef5715", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 662}, "message": "'DIEValueList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "ce18238d3c370e29382d58699821fcbd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 33, "line": 663}, "message": "'Node' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "b465e32eea1aa81087d9fcc400817e5b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 33, "line": 765}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 33, "line": 765}, "message": "'DIE' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "766cc898617afedeff96318d7881b619", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 33, "line": 889}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 33, "line": 889}, "message": "'DIEUnit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "eef1a72f831734608172e0a3107e1cf3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 33, "line": 915}, "message": "'BasicDIEUnit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "a67ca29ed93345507b2a3d2c5f88a05c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 33, "line": 922}, "message": "'DIELoc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DIE.h", "reportHash": "01881f13e6c99dfe3b850ee036f3e657", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 53}, "message": "'DebugHandlerBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h", "reportHash": "70933d8bb58aa0dcb0865bc9ff1f53c9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 31}, "message": "'DwarfStringPoolEntryRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/DwarfStringPoolEntry.h", "reportHash": "a3cbe5f703b97deacbefccdccaf00426", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 52}, "message": "'MBBSectionID' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h", "reportHash": "cea851a4e246f5674b8a25c8be93bcc8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 36, "line": 101}, "message": "'RegisterMaskPair' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h", "reportHash": "91d1d878659fcbf84d2c3d7274dbffb1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 37, "line": 111}, "message": "'MachineFunctionProperties' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h", "reportHash": "dec9c7c7ec3d31be43bcbedf48bb324a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 38, "line": 30}, "message": "'MachineFunctionPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h", "reportHash": "0f4a5c710ec60b0ee1a5c5ed2b6ffd81", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 39, "line": 127}, "message": "'MachineMemOperand' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h", "reportHash": "c75f5e8fad474ed32e758442a9e85780", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 39, "line": 159}, "message": "'MachineAtomicInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h", "reportHash": "62d91b36489f6f3bd8a6939f29fa57e6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 40, "line": 50}, "message": "'PBQPRAConstraintList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/PBQPRAConstraint.h", "reportHash": "ed7c1e594293bcccab00b56d063c8cda", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 94}, "message": "'FixedStackPseudoSourceValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/PseudoSourceValue.h", "reportHash": "544da81020721ee54a77a2c7e21c057e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 116}, "message": "'CallEntryPseudoSourceValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/PseudoSourceValue.h", "reportHash": "9ab545a9a9d4fd9272bca5a441979e9a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 156}, "message": "'PseudoSourceValueManager' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/PseudoSourceValue.h", "reportHash": "0b31fb644f7a0ad39c8d7716935889ca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 42, "line": 46}, "message": "'TargetRegisterClass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h", "reportHash": "917cfd76510bf6752d3084ec8974dee1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 43, "line": 29}, "message": "'Argument' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Argument.h", "reportHash": "d1d7680c18421eedcc81357dab7f7931", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 44, "line": 757}, "message": "'AttrBuilder' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "reportHash": "017b1587d11d167cdd4c1f5e7842e9ba", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 45, "line": 42}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 45, "line": 42}, "message": "'Comdat' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Comdat.h", "reportHash": "c4664dacf538160d238b03372c614b4d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 400}, "message": "'ConstantAggregate' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Constants.h", "reportHash": "5f7e745d0b8ee3a70d62be0e55e1ffa4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 424}, "message": "'ConstantArray' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Constants.h", "reportHash": "8fbc5a8fc33c4d826c250f443b01ddcf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 456}, "message": "'ConstantStruct' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Constants.h", "reportHash": "7676b435cb9f1763f693a5e124841c8f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 509}, "message": "'ConstantVector' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Constants.h", "reportHash": "24fe8097131f707fc1d4df0faa884281", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 851}, "message": "'BlockAddress' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Constants.h", "reportHash": "038130d8b657ac3c51726a7a8bc0887e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 896}, "message": "'DSOLocalEquivalent' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Constants.h", "reportHash": "55b7fe339da9d08fb56a4eddd8f5bc2b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 47, "line": 71}, "message": "'LayoutAlignElem' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DataLayout.h", "reportHash": "89fe0f4de8fb5bfb1b776b73325839d0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 47, "line": 90}, "message": "'PointerAlignElem' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DataLayout.h", "reportHash": "9b37781ad6d4163a199409906791d0e6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 47, "line": 622}, "message": "'StructLayout' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DataLayout.h", "reportHash": "718298477ebdfd491627ef3631df649c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 48, "line": 2703}, "message": "'FragmentInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "a8389b1c4359e3f2511fce76f7bb78c8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 48, "line": 2969}, "message": "'DICommonBlock' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h", "reportHash": "5f1de724cdee1947f82009f4a30148ae", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 49, "line": 40}, "message": "'IntegerType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DerivedTypes.h", "reportHash": "c92faaf76da4353fc19d02ee26857868", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 49, "line": 527}, "message": "'FixedVectorType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DerivedTypes.h", "reportHash": "5ea5de84e0df8649143fb3eb0f97027c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 49, "line": 574}, "message": "'ScalableVectorType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/DerivedTypes.h", "reportHash": "d2c5b367cc444967985d29539b6a82ad", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 50, "line": 49}, "message": "'llvm/IR/IntrinsicEnums.inc' file not found"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Intrinsics.h", "reportHash": "66fd43c8c64831667bf194039dfffe87", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 7, "file": 51, "line": 408}, "message": "'ConstantAsMetadata' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "06065c287ee60aa91f9e15cb9123569c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 51, "line": 432}, "message": "'LocalAsMetadata' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "d6d2a4cf70e942211ba3c2d41de21e00", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 51, "line": 745}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 51, "line": 745}, "message": "'MDOperand' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "becc1e3227789fd07d7661df20eef49d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 51, "line": 810}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 51, "line": 810}, "message": "'ContextAndReplaceableUses' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "b7714ff6353c4bbdc611c8a83ed7e3b5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 51, "line": 1346}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 51, "line": 1346}, "message": "'DistinctMDOperandPlaceholder' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Metadata.h", "reportHash": "515322b1287d55dc617135b992508e9c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 52, "line": 72}, "message": "'AnalysisKey' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "39e05f97d65140216c0eb6a07f42e883", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 52, "line": 82}, "message": "'AnalysisSetKey' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "41be051e60a0e9e8e50d4369d04b4845", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 52, "line": 478}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 52, "line": 478}, "message": "'PassManager<IRUnitT, AnalysisManagerT, ExtraArgTs...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "0c85c7480878f561bc803d901bea0f05", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 52, "line": 752}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 52, "line": 752}, "message": "'AnalysisManager<IRUnitT, ExtraArgTs...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "b58312cda1268b973034cc38bfee4f00", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 52, "line": 977}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 52, "line": 977}, "message": "'Result' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManager.h", "reportHash": "1055ff69b7b4e6c509ecf1a5de6ba1ae", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 53, "line": 71}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 53, "line": 71}, "message": "'PassModel<IRUnitT, PassT, PreservedAnalysesT, AnalysisManagerT, ExtraArgTs...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h", "reportHash": "f3f9134fa0c6e063fbf4167fc66b369e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 53, "line": 195}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 53, "line": 195}, "message": "'AnalysisResultModel<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, false>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h", "reportHash": "a293cbb98b1269fea44b198e233ceca0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 53, "line": 234}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 53, "line": 234}, "message": "'AnalysisResultModel<type-parameter-0-0, type-parameter-0-1, type-parameter-0-2, type-parameter-0-3, type-parameter-0-4, true>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h", "reportHash": "4ef1e7dd6e9b90d61ecdaa16a76fb984", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 53, "line": 290}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 53, "line": 290}, "message": "'AnalysisPassModel<IRUnitT, PassT, PreservedAnalysesT, InvalidatorT, ExtraArgTs...>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h", "reportHash": "c689c50c8b6bc42c8acda1d237898731", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 32}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 32}, "message": "'TrackingMDRef' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/TrackingMDRef.h", "reportHash": "13a5f7bf0e179e05205a456b16ceeef0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 54, "line": 113}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 54, "line": 113}, "message": "'TypedTrackingMDRef<T>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/TrackingMDRef.h", "reportHash": "5db49819beae902c2815d9a98d2068f4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 55, "line": 110}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 55, "line": 110}, "message": "'ValueMap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueMap.h", "reportHash": "afba52157e4801604ee71e067671d776", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 55, "line": 110}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 55, "line": 110}, "message": "'ValueMap<KeyT, ValueT, Config>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ValueMap.h", "reportHash": "04010b24361bea86c11b0c16c2775606", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 56, "line": 58}, "message": "'MCDwarfFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCDwarf.h", "reportHash": "9fd63be2f05d77717d27c2f841842d50", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 56, "line": 76}, "message": "'MCDwarfLoc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCDwarf.h", "reportHash": "b65f27bf20323ff600f51f0b06ad4b5f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 56, "line": 219}, "message": "'MCDwarfLineTableHeader' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCDwarf.h", "reportHash": "f99a01a7f50af032b3d45b0edc355078", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 60, "line": 102}, "message": "'MCLOHDirective' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h", "reportHash": "6b3d05982196599eb07826b95a7f6652", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 61, "line": 189}, "message": "'DiffListIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "18708991bfba24fd8b97990d48911fa3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 61, "line": 278}, "message": "'mc_subreg_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "91f28eed64fdaced936a984af8f261a2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 61, "line": 289}, "message": "'mc_superreg_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "e13d5be8e4bc92c46ae3cdbeb6be66e9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 587}, "message": "'MCSubRegIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "aeeb2436ccfb7dd93a45b02872d1317e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 634}, "message": "'MCSuperRegIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "1e760308c9877b48b6fe73ad71e51c58", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 670}, "message": "'MCRegUnitIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "84a22a9511e9b9819511c357aebecb7e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 61, "line": 739}, "message": "'MCRegUnitRootIterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h", "reportHash": "ecf3643d26706da97b08b823ae30f817", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 62, "line": 245}, "message": "'MCSchedModel' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/MC/MCSchedule.h", "reportHash": "cb199aa3608e145e88b74c189b5862f7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 65, "line": 298}, "message": "'FunctionPass' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Pass.h", "reportHash": "48162fdea92024b6a70d19fd6e9be2ec", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 66, "line": 123}, "message": "'RegisterAGBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/PassSupport.h", "reportHash": "337752874b1304502d2dd130237f4382", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 71, "line": 714}, "message": "'GenericOptionInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CommandLine.h", "reportHash": "bbcd717a898acac2264a2bdeaa267b1e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 74, "line": 1336}, "message": "'directory_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "0b392d46308eb9d36a80dd488f7384d1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 75, "line": 23}, "message": "'UniqueID' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem/UniqueID.h", "reportHash": "67d5518ce35b66b187f805ad25fe92ed", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 78, "line": 226}, "message": "'SMFixIt' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SourceMgr.h", "reportHash": "9d8662f05aa42b2fb401a3568a238a7f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 80, "line": 70}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 80, "line": 70}, "message": "'TimeTraceScope' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TimeProfiler.h", "reportHash": "ef03287f8745aec92950d0423a3347f6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 82, "line": 46}, "message": "'Status' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "93c9658450630c6a6cc32224b36155fe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 85, "line": 31}, "message": "'CGPassBuilderOption' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Target/CGPassBuilderOption.h", "reportHash": "25cc9381569579a1012df27cebafb399", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 86, "line": 386}, "message": "'LLVMTargetMachine' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Target/TargetMachine.h", "reportHash": "3122189d6569ff41d21408269e787f76", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 88, "line": 23}, "message": "'AddressPool' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/AddressPool.h", "reportHash": "97b7a84fffb4c79bed65e99f6a841034", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 89, "line": 38}, "message": "'APByteStreamer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/ByteStreamer.h", "reportHash": "bc55a2f4293a56f916fd4bddd9affddf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 89, "line": 59}, "message": "'HashingByteStreamer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/ByteStreamer.h", "reportHash": "2bd271b192cce7a703dbba1586f0670a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 90, "line": 26}, "message": "'DIEHash' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h", "reportHash": "007c359058516bbedd8f98d03a6e4071", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 90, "line": 28}, "message": "'DIEAttrs' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DIEHash.h", "reportHash": "609b4a796867a6e9847f10e87638ca8d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 91, "line": 40}, "message": "'DbgValueLocEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "0306ad9135548fa9e101820d5daf2175", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 91, "line": 53}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "ebd3a0a20f7c8b2ad531c483d20b56dd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 91, "line": 59}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "ebd3a0a20f7c8b2ad531c483d20b56dd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 91, "line": 108}, "message": "'DbgValueLoc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocEntry.h", "reportHash": "95d27003967f2d61a5a1de8104011836", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 92, "line": 31}, "message": "'DebugLocStream' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocStream.h", "reportHash": "3fee4c026b25bc4509d19c4977aa9685", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 92, "line": 33}, "message": "'List' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocStream.h", "reportHash": "42c3cc5cb65659ea6e562de3330e4a38", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 92, "line": 40}, "message": "'Entry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugLocStream.h", "reportHash": "a114aac3649df4afb2ac18d1ffa7cde9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 93, "line": 47}, "message": "'DwarfCompileUnit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.h", "reportHash": "8c22db8638dce04dc2e57b65a9619830", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 94, "line": 116}, "message": "'DbgVariable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h", "reportHash": "2eb60489722aa3a2f37177c59b0a9fc6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 94, "line": 233}, "message": "'DbgLabel' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h", "reportHash": "a5f6dea6b3894ba3cba160c9d6d339d3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 94, "line": 672}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 94, "line": 672}, "message": "'NonTypeUnitContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h", "reportHash": "4ea71e6c76405641ee263bbe71fddc73", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 95, "line": 367}, "message": "'DebugLocDwarfExpression' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h", "reportHash": "1090ec84c1164f0c363249c40852a324", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 95, "line": 405}, "message": "'DIEDwarfExpression' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h", "reportHash": "2aa92614010afb184665ad37bee39955", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 96, "line": 49}, "message": "'DwarfFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfFile.h", "reportHash": "c75f3226542e028d3d54a3e5b7ecd8a4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 97, "line": 337}, "message": "'DwarfTypeUnit' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h", "reportHash": "979a1728d392a3e8d9530a243456c013", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
