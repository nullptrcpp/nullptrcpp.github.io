<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/PartialDiagnostic.h", "content": "//===- PartialDiagnostic.h - Diagnostic \"closures\" --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Implements a partial diagnostic that can be emitted anwyhere\n/// in a DiagnosticBuilder stream.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_PARTIALDIAGNOSTIC_H\n#define LLVM_CLANG_BASIC_PARTIALDIAGNOSTIC_H\n\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <cassert>\n#include <cstdint>\n#include <string>\n#include <type_traits>\n#include <utility>\n\nnamespace clang {\n\nclass DeclContext;\nclass IdentifierInfo;\n\nclass PartialDiagnostic : public StreamingDiagnostic {\nprivate:\n  // NOTE: Sema assumes that PartialDiagnostic is location-invariant\n  // in the sense that its bits can be safely memcpy'ed and destructed\n  // in the new location.\n\n  /// The diagnostic ID.\n  mutable unsigned DiagID = 0;\npublic:\n  struct NullDiagnostic {};\n\n  /// Create a null partial diagnostic, which cannot carry a payload,\n  /// and only exists to be swapped with a real partial diagnostic.\n  PartialDiagnostic(NullDiagnostic) {}\n\n  PartialDiagnostic(unsigned DiagID, DiagStorageAllocator &Allocator_)\n      : StreamingDiagnostic(Allocator_), DiagID(DiagID) {}\n\n  PartialDiagnostic(const PartialDiagnostic &Other)\n      : StreamingDiagnostic(), DiagID(Other.DiagID) {\n    Allocator = Other.Allocator;\n    if (Other.DiagStorage) {\n      DiagStorage = getStorage();\n      *DiagStorage = *Other.DiagStorage;\n    }\n  }\n\n  template <typename T> const PartialDiagnostic &operator<<(const T &V) const {\n    const StreamingDiagnostic &DB = *this;\n    DB << V;\n    return *this;\n  }\n\n  // It is necessary to limit this to rvalue reference to avoid calling this\n  // function with a bitfield lvalue argument since non-const reference to\n  // bitfield is not allowed.\n  template <typename T, typename = typename std::enable_if<\n                            !std::is_lvalue_reference<T>::value>::type>\n  const PartialDiagnostic &operator<<(T &&V) const {\n    const StreamingDiagnostic &DB = *this;\n    DB << std::move(V);\n    return *this;\n  }\n\n  PartialDiagnostic(PartialDiagnostic &&Other) : DiagID(Other.DiagID) {\n    Allocator = Other.Allocator;\n    DiagStorage = Other.DiagStorage;\n    Other.DiagStorage = nullptr;\n  }\n\n  PartialDiagnostic(const PartialDiagnostic &Other,\n                    DiagnosticStorage *DiagStorage_)\n      : DiagID(Other.DiagID) {\n    Allocator = reinterpret_cast<DiagStorageAllocator *>(~uintptr_t(0));\n    DiagStorage = DiagStorage_;\n    if (Other.DiagStorage)\n      *this->DiagStorage = *Other.DiagStorage;\n  }\n\n  PartialDiagnostic(const Diagnostic &Other, DiagStorageAllocator &Allocator_)\n      : DiagID(Other.getID()) {\n    Allocator = &Allocator_;\n    // Copy arguments.\n    for (unsigned I = 0, N = Other.getNumArgs(); I != N; ++I) {\n      if (Other.getArgKind(I) == DiagnosticsEngine::ak_std_string)\n        AddString(Other.getArgStdStr(I));\n      else\n        AddTaggedVal(Other.getRawArg(I), Other.getArgKind(I));\n    }\n\n    // Copy source ranges.\n    for (unsigned I = 0, N = Other.getNumRanges(); I != N; ++I)\n      AddSourceRange(Other.getRange(I));\n\n    // Copy fix-its.\n    for (unsigned I = 0, N = Other.getNumFixItHints(); I != N; ++I)\n      AddFixItHint(Other.getFixItHint(I));\n  }\n\n  PartialDiagnostic &operator=(const PartialDiagnostic &Other) {\n    DiagID = Other.DiagID;\n    if (Other.DiagStorage) {\n      if (!DiagStorage)\n        DiagStorage = getStorage();\n\n      *DiagStorage = *Other.DiagStorage;\n    } else {\n      freeStorage();\n    }\n\n    return *this;\n  }\n\n  PartialDiagnostic &operator=(PartialDiagnostic &&Other) {\n    freeStorage();\n\n    DiagID = Other.DiagID;\n    DiagStorage = Other.DiagStorage;\n    Allocator = Other.Allocator;\n\n    Other.DiagStorage = nullptr;\n    return *this;\n  }\n\n  void swap(PartialDiagnostic &PD) {\n    std::swap(DiagID, PD.DiagID);\n    std::swap(DiagStorage, PD.DiagStorage);\n    std::swap(Allocator, PD.Allocator);\n  }\n\n  unsigned getDiagID() const { return DiagID; }\n  void setDiagID(unsigned ID) { DiagID = ID; }\n\n  void Emit(const DiagnosticBuilder &DB) const {\n    if (!DiagStorage)\n      return;\n\n    // Add all arguments.\n    for (unsigned i = 0, e = DiagStorage->NumDiagArgs; i != e; ++i) {\n      if ((DiagnosticsEngine::ArgumentKind)DiagStorage->DiagArgumentsKind[i]\n            == DiagnosticsEngine::ak_std_string)\n        DB.AddString(DiagStorage->DiagArgumentsStr[i]);\n      else\n        DB.AddTaggedVal(DiagStorage->DiagArgumentsVal[i],\n            (DiagnosticsEngine::ArgumentKind)DiagStorage->DiagArgumentsKind[i]);\n    }\n\n    // Add all ranges.\n    for (const CharSourceRange &Range : DiagStorage->DiagRanges)\n      DB.AddSourceRange(Range);\n\n    // Add all fix-its.\n    for (const FixItHint &Fix : DiagStorage->FixItHints)\n      DB.AddFixItHint(Fix);\n  }\n\n  void EmitToString(DiagnosticsEngine &Diags,\n                    SmallVectorImpl<char> &Buf) const {\n    // FIXME: It should be possible to render a diagnostic to a string without\n    //        messing with the state of the diagnostics engine.\n    DiagnosticBuilder DB(Diags.Report(getDiagID()));\n    Emit(DB);\n    Diagnostic(&Diags).FormatDiagnostic(Buf);\n    DB.Clear();\n    Diags.Clear();\n  }\n\n  /// Clear out this partial diagnostic, giving it a new diagnostic ID\n  /// and removing all of its arguments, ranges, and fix-it hints.\n  void Reset(unsigned DiagID = 0) {\n    this->DiagID = DiagID;\n    freeStorage();\n  }\n\n  bool hasStorage() const { return DiagStorage != nullptr; }\n\n  /// Retrieve the string argument at the given index.\n  StringRef getStringArg(unsigned I) {\n    assert(DiagStorage && \"No diagnostic storage?\");\n    assert(I < DiagStorage->NumDiagArgs && \"Not enough diagnostic args\");\n    assert(DiagStorage->DiagArgumentsKind[I]\n             == DiagnosticsEngine::ak_std_string && \"Not a string arg\");\n    return DiagStorage->DiagArgumentsStr[I];\n  }\n};\n\ninline const DiagnosticBuilder &operator<<(const DiagnosticBuilder &DB,\n                                           const PartialDiagnostic &PD) {\n  PD.Emit(DB);\n  return DB;\n}\n\n/// A partial diagnostic along with the source location where this\n/// diagnostic occurs.\nusing PartialDiagnosticAt = std::pair<SourceLocation, PartialDiagnostic>;\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_PARTIALDIAGNOSTIC_H\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DelayedDiagnostic.h", "content": "//===- DelayedDiagnostic.h - Delayed declarator diagnostics -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the classes clang::DelayedDiagnostic and\n/// clang::AccessedEntity.\n///\n/// DelayedDiangostic is used to record diagnostics that are being\n/// conditionally produced during declarator parsing.  Certain kinds of\n/// diagnostics -- notably deprecation and access control -- are suppressed\n/// based on semantic properties of the parsed declaration that aren't known\n/// until it is fully parsed.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_DELAYEDDIAGNOSTIC_H\n#define LLVM_CLANG_SEMA_DELAYEDDIAGNOSTIC_H\n\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <cstddef>\n#include <utility>\n\nnamespace clang {\n\nclass ObjCInterfaceDecl;\nclass ObjCPropertyDecl;\n\nnamespace sema {\n\n/// A declaration being accessed, together with information about how\n/// it was accessed.\nclass AccessedEntity {\npublic:\n  /// A member declaration found through lookup.  The target is the\n  /// member.\n  enum MemberNonce { Member };\n\n  /// A hierarchy (base-to-derived or derived-to-base) conversion.\n  /// The target is the base class.\n  enum BaseNonce { Base };\n\n  AccessedEntity(PartialDiagnostic::DiagStorageAllocator &Allocator,\n                 MemberNonce _, CXXRecordDecl *NamingClass,\n                 DeclAccessPair FoundDecl, QualType BaseObjectType)\n      : Access(FoundDecl.getAccess()), IsMember(true),\n        Target(FoundDecl.getDecl()), NamingClass(NamingClass),\n        BaseObjectType(BaseObjectType), Diag(0, Allocator) {}\n\n  AccessedEntity(PartialDiagnostic::DiagStorageAllocator &Allocator,\n                 BaseNonce _, CXXRecordDecl *BaseClass,\n                 CXXRecordDecl *DerivedClass, AccessSpecifier Access)\n      : Access(Access), IsMember(false), Target(BaseClass),\n        NamingClass(DerivedClass), Diag(0, Allocator) {}\n\n  bool isMemberAccess() const { return IsMember; }\n\n  bool isQuiet() const { return Diag.getDiagID() == 0; }\n\n  AccessSpecifier getAccess() const { return AccessSpecifier(Access); }\n\n  // These apply to member decls...\n  NamedDecl *getTargetDecl() const { return Target; }\n  CXXRecordDecl *getNamingClass() const { return NamingClass; }\n\n  // ...and these apply to hierarchy conversions.\n  CXXRecordDecl *getBaseClass() const {\n    assert(!IsMember); return cast<CXXRecordDecl>(Target);\n  }\n  CXXRecordDecl *getDerivedClass() const { return NamingClass; }\n\n  /// Retrieves the base object type, important when accessing\n  /// an instance member.\n  QualType getBaseObjectType() const { return BaseObjectType; }\n\n  /// Sets a diagnostic to be performed.  The diagnostic is given\n  /// four (additional) arguments:\n  ///   %0 - 0 if the entity was private, 1 if protected\n  ///   %1 - the DeclarationName of the entity\n  ///   %2 - the TypeDecl type of the naming class\n  ///   %3 - the TypeDecl type of the declaring class\n  void setDiag(const PartialDiagnostic &PDiag) {\n    assert(isQuiet() && \"partial diagnostic already defined\");\n    Diag = PDiag;\n  }\n  PartialDiagnostic &setDiag(unsigned DiagID) {\n    assert(isQuiet() && \"partial diagnostic already defined\");\n    assert(DiagID && \"creating null diagnostic\");\n    Diag.Reset(DiagID);\n    return Diag;\n  }\n  const PartialDiagnostic &getDiag() const {\n    return Diag;\n  }\n\nprivate:\n  unsigned Access : 2;\n  unsigned IsMember : 1;\n  NamedDecl *Target;\n  CXXRecordDecl *NamingClass;\n  QualType BaseObjectType;\n  PartialDiagnostic Diag;\n};\n\n/// A diagnostic message which has been conditionally emitted pending\n/// the complete parsing of the current declaration.\nclass DelayedDiagnostic {\npublic:\n  enum DDKind : unsigned char { Availability, Access, ForbiddenType };\n\n  DDKind Kind;\n  bool Triggered;\n\n  SourceLocation Loc;\n\n  void Destroy();\n\n  static DelayedDiagnostic makeAvailability(AvailabilityResult AR,\n                                            ArrayRef<SourceLocation> Locs,\n                                            const NamedDecl *ReferringDecl,\n                                            const NamedDecl *OffendingDecl,\n                                            const ObjCInterfaceDecl *UnknownObjCClass,\n                                            const ObjCPropertyDecl  *ObjCProperty,\n                                            StringRef Msg,\n                                            bool ObjCPropertyAccess);\n\n  static DelayedDiagnostic makeAccess(SourceLocation Loc,\n                                      const AccessedEntity &Entity) {\n    DelayedDiagnostic DD;\n    DD.Kind = Access;\n    DD.Triggered = false;\n    DD.Loc = Loc;\n    new (&DD.getAccessData()) AccessedEntity(Entity);\n    return DD;\n  }\n\n  static DelayedDiagnostic makeForbiddenType(SourceLocation loc,\n                                             unsigned diagnostic,\n                                             QualType type,\n                                             unsigned argument) {\n    DelayedDiagnostic DD;\n    DD.Kind = ForbiddenType;\n    DD.Triggered = false;\n    DD.Loc = loc;\n    DD.ForbiddenTypeData.Diagnostic = diagnostic;\n    DD.ForbiddenTypeData.OperandType = type.getAsOpaquePtr();\n    DD.ForbiddenTypeData.Argument = argument;\n    return DD;\n  }\n\n  AccessedEntity &getAccessData() {\n    assert(Kind == Access && \"Not an access diagnostic.\");\n    return *reinterpret_cast<AccessedEntity*>(AccessData);\n  }\n  const AccessedEntity &getAccessData() const {\n    assert(Kind == Access && \"Not an access diagnostic.\");\n    return *reinterpret_cast<const AccessedEntity*>(AccessData);\n  }\n\n  const NamedDecl *getAvailabilityReferringDecl() const {\n    assert(Kind == Availability && \"Not an availability diagnostic.\");\n    return AvailabilityData.ReferringDecl;\n  }\n\n  const NamedDecl *getAvailabilityOffendingDecl() const {\n    return AvailabilityData.OffendingDecl;\n  }\n\n  StringRef getAvailabilityMessage() const {\n    assert(Kind == Availability && \"Not an availability diagnostic.\");\n    return StringRef(AvailabilityData.Message, AvailabilityData.MessageLen);\n  }\n\n  ArrayRef<SourceLocation> getAvailabilitySelectorLocs() const {\n    assert(Kind == Availability && \"Not an availability diagnostic.\");\n    return llvm::makeArrayRef(AvailabilityData.SelectorLocs,\n                              AvailabilityData.NumSelectorLocs);\n  }\n\n  AvailabilityResult getAvailabilityResult() const {\n    assert(Kind == Availability && \"Not an availability diagnostic.\");\n    return AvailabilityData.AR;\n  }\n\n  /// The diagnostic ID to emit.  Used like so:\n  ///   Diag(diag.Loc, diag.getForbiddenTypeDiagnostic())\n  ///     << diag.getForbiddenTypeOperand()\n  ///     << diag.getForbiddenTypeArgument();\n  unsigned getForbiddenTypeDiagnostic() const {\n    assert(Kind == ForbiddenType && \"not a forbidden-type diagnostic\");\n    return ForbiddenTypeData.Diagnostic;\n  }\n\n  unsigned getForbiddenTypeArgument() const {\n    assert(Kind == ForbiddenType && \"not a forbidden-type diagnostic\");\n    return ForbiddenTypeData.Argument;\n  }\n\n  QualType getForbiddenTypeOperand() const {\n    assert(Kind == ForbiddenType && \"not a forbidden-type diagnostic\");\n    return QualType::getFromOpaquePtr(ForbiddenTypeData.OperandType);\n  }\n\n  const ObjCInterfaceDecl *getUnknownObjCClass() const {\n    return AvailabilityData.UnknownObjCClass;\n  }\n\n  const ObjCPropertyDecl *getObjCProperty() const {\n    return AvailabilityData.ObjCProperty;\n  }\n\n  bool getObjCPropertyAccess() const {\n    return AvailabilityData.ObjCPropertyAccess;\n  }\n\nprivate:\n  struct AD {\n    const NamedDecl *ReferringDecl;\n    const NamedDecl *OffendingDecl;\n    const ObjCInterfaceDecl *UnknownObjCClass;\n    const ObjCPropertyDecl  *ObjCProperty;\n    const char *Message;\n    size_t MessageLen;\n    SourceLocation *SelectorLocs;\n    size_t NumSelectorLocs;\n    AvailabilityResult AR;\n    bool ObjCPropertyAccess;\n  };\n\n  struct FTD {\n    unsigned Diagnostic;\n    unsigned Argument;\n    void *OperandType;\n  };\n\n  union {\n    struct AD AvailabilityData;\n    struct FTD ForbiddenTypeData;\n\n    /// Access control.\n    char AccessData[sizeof(AccessedEntity)];\n  };\n};\n\n/// A collection of diagnostics which were delayed.\nclass DelayedDiagnosticPool {\n  const DelayedDiagnosticPool *Parent;\n  SmallVector<DelayedDiagnostic, 4> Diagnostics;\n\npublic:\n  DelayedDiagnosticPool(const DelayedDiagnosticPool *parent) : Parent(parent) {}\n\n  DelayedDiagnosticPool(const DelayedDiagnosticPool &) = delete;\n  DelayedDiagnosticPool &operator=(const DelayedDiagnosticPool &) = delete;\n\n  DelayedDiagnosticPool(DelayedDiagnosticPool &&Other)\n      : Parent(Other.Parent), Diagnostics(std::move(Other.Diagnostics)) {\n    Other.Diagnostics.clear();\n  }\n\n  DelayedDiagnosticPool &operator=(DelayedDiagnosticPool &&Other) {\n    Parent = Other.Parent;\n    Diagnostics = std::move(Other.Diagnostics);\n    Other.Diagnostics.clear();\n    return *this;\n  }\n\n  ~DelayedDiagnosticPool() {\n    for (SmallVectorImpl<DelayedDiagnostic>::iterator\n           i = Diagnostics.begin(), e = Diagnostics.end(); i != e; ++i)\n      i->Destroy();\n  }\n\n  const DelayedDiagnosticPool *getParent() const { return Parent; }\n\n  /// Does this pool, or any of its ancestors, contain any diagnostics?\n  bool empty() const {\n    return (Diagnostics.empty() && (!Parent || Parent->empty()));\n  }\n\n  /// Add a diagnostic to this pool.\n  void add(const DelayedDiagnostic &diag) {\n    Diagnostics.push_back(diag);\n  }\n\n  /// Steal the diagnostics from the given pool.\n  void steal(DelayedDiagnosticPool &pool) {\n    if (pool.Diagnostics.empty()) return;\n\n    if (Diagnostics.empty()) {\n      Diagnostics = std::move(pool.Diagnostics);\n    } else {\n      Diagnostics.append(pool.pool_begin(), pool.pool_end());\n    }\n    pool.Diagnostics.clear();\n  }\n\n  using pool_iterator = SmallVectorImpl<DelayedDiagnostic>::const_iterator;\n\n  pool_iterator pool_begin() const { return Diagnostics.begin(); }\n  pool_iterator pool_end() const { return Diagnostics.end(); }\n  bool pool_empty() const { return Diagnostics.empty(); }\n};\n\n} // namespace clang\n\n/// Add a diagnostic to the current delay pool.\ninline void Sema::DelayedDiagnostics::add(const sema::DelayedDiagnostic &diag) {\n  assert(shouldDelayDiagnostics() && \"trying to delay without pool\");\n  CurPool->add(diag);\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SEMA_DELAYEDDIAGNOSTIC_H\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Overload.h", "content": "//===- Overload.h - C++ Overloading -----------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the data structures and types used in C++\n// overload resolution.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_OVERLOAD_H\n#define LLVM_CLANG_SEMA_OVERLOAD_H\n\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Sema/SemaFixItUtils.h\"\n#include \"clang/Sema/TemplateDeduction.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <utility>\n\nnamespace clang {\n\nclass APValue;\nclass ASTContext;\nclass Sema;\n\n  /// OverloadingResult - Capture the result of performing overload\n  /// resolution.\n  enum OverloadingResult {\n    /// Overload resolution succeeded.\n    OR_Success,\n\n    /// No viable function found.\n    OR_No_Viable_Function,\n\n    /// Ambiguous candidates found.\n    OR_Ambiguous,\n\n    /// Succeeded, but refers to a deleted function.\n    OR_Deleted\n  };\n\n  enum OverloadCandidateDisplayKind {\n    /// Requests that all candidates be shown.  Viable candidates will\n    /// be printed first.\n    OCD_AllCandidates,\n\n    /// Requests that only viable candidates be shown.\n    OCD_ViableCandidates,\n\n    /// Requests that only tied-for-best candidates be shown.\n    OCD_AmbiguousCandidates\n  };\n\n  /// The parameter ordering that will be used for the candidate. This is\n  /// used to represent C++20 binary operator rewrites that reverse the order\n  /// of the arguments. If the parameter ordering is Reversed, the Args list is\n  /// reversed (but obviously the ParamDecls for the function are not).\n  ///\n  /// After forming an OverloadCandidate with reversed parameters, the list\n  /// of conversions will (as always) be indexed by argument, so will be\n  /// in reverse parameter order.\n  enum class OverloadCandidateParamOrder : char { Normal, Reversed };\n\n  /// The kinds of rewrite we perform on overload candidates. Note that the\n  /// values here are chosen to serve as both bitflags and as a rank (lower\n  /// values are preferred by overload resolution).\n  enum OverloadCandidateRewriteKind : unsigned {\n    /// Candidate is not a rewritten candidate.\n    CRK_None = 0x0,\n\n    /// Candidate is a rewritten candidate with a different operator name.\n    CRK_DifferentOperator = 0x1,\n\n    /// Candidate is a rewritten candidate with a reversed order of parameters.\n    CRK_Reversed = 0x2,\n  };\n\n  /// ImplicitConversionKind - The kind of implicit conversion used to\n  /// convert an argument to a parameter's type. The enumerator values\n  /// match with the table titled 'Conversions' in [over.ics.scs] and are listed\n  /// such that better conversion kinds have smaller values.\n  enum ImplicitConversionKind {\n    /// Identity conversion (no conversion)\n    ICK_Identity = 0,\n\n    /// Lvalue-to-rvalue conversion (C++ [conv.lval])\n    ICK_Lvalue_To_Rvalue,\n\n    /// Array-to-pointer conversion (C++ [conv.array])\n    ICK_Array_To_Pointer,\n\n    /// Function-to-pointer (C++ [conv.array])\n    ICK_Function_To_Pointer,\n\n    /// Function pointer conversion (C++17 [conv.fctptr])\n    ICK_Function_Conversion,\n\n    /// Qualification conversions (C++ [conv.qual])\n    ICK_Qualification,\n\n    /// Integral promotions (C++ [conv.prom])\n    ICK_Integral_Promotion,\n\n    /// Floating point promotions (C++ [conv.fpprom])\n    ICK_Floating_Promotion,\n\n    /// Complex promotions (Clang extension)\n    ICK_Complex_Promotion,\n\n    /// Integral conversions (C++ [conv.integral])\n    ICK_Integral_Conversion,\n\n    /// Floating point conversions (C++ [conv.double]\n    ICK_Floating_Conversion,\n\n    /// Complex conversions (C99 6.3.1.6)\n    ICK_Complex_Conversion,\n\n    /// Floating-integral conversions (C++ [conv.fpint])\n    ICK_Floating_Integral,\n\n    /// Pointer conversions (C++ [conv.ptr])\n    ICK_Pointer_Conversion,\n\n    /// Pointer-to-member conversions (C++ [conv.mem])\n    ICK_Pointer_Member,\n\n    /// Boolean conversions (C++ [conv.bool])\n    ICK_Boolean_Conversion,\n\n    /// Conversions between compatible types in C99\n    ICK_Compatible_Conversion,\n\n    /// Derived-to-base (C++ [over.best.ics])\n    ICK_Derived_To_Base,\n\n    /// Vector conversions\n    ICK_Vector_Conversion,\n\n    /// Arm SVE Vector conversions\n    ICK_SVE_Vector_Conversion,\n\n    /// A vector splat from an arithmetic type\n    ICK_Vector_Splat,\n\n    /// Complex-real conversions (C99 6.3.1.7)\n    ICK_Complex_Real,\n\n    /// Block Pointer conversions\n    ICK_Block_Pointer_Conversion,\n\n    /// Transparent Union Conversions\n    ICK_TransparentUnionConversion,\n\n    /// Objective-C ARC writeback conversion\n    ICK_Writeback_Conversion,\n\n    /// Zero constant to event (OpenCL1.2 6.12.10)\n    ICK_Zero_Event_Conversion,\n\n    /// Zero constant to queue\n    ICK_Zero_Queue_Conversion,\n\n    /// Conversions allowed in C, but not C++\n    ICK_C_Only_Conversion,\n\n    /// C-only conversion between pointers with incompatible types\n    ICK_Incompatible_Pointer_Conversion,\n\n    /// The number of conversion kinds\n    ICK_Num_Conversion_Kinds,\n  };\n\n  /// ImplicitConversionRank - The rank of an implicit conversion\n  /// kind. The enumerator values match with Table 9 of (C++\n  /// 13.3.3.1.1) and are listed such that better conversion ranks\n  /// have smaller values.\n  enum ImplicitConversionRank {\n    /// Exact Match\n    ICR_Exact_Match = 0,\n\n    /// Promotion\n    ICR_Promotion,\n\n    /// Conversion\n    ICR_Conversion,\n\n    /// OpenCL Scalar Widening\n    ICR_OCL_Scalar_Widening,\n\n    /// Complex <-> Real conversion\n    ICR_Complex_Real_Conversion,\n\n    /// ObjC ARC writeback conversion\n    ICR_Writeback_Conversion,\n\n    /// Conversion only allowed in the C standard (e.g. void* to char*).\n    ICR_C_Conversion,\n\n    /// Conversion not allowed by the C standard, but that we accept as an\n    /// extension anyway.\n    ICR_C_Conversion_Extension\n  };\n\n  ImplicitConversionRank GetConversionRank(ImplicitConversionKind Kind);\n\n  /// NarrowingKind - The kind of narrowing conversion being performed by a\n  /// standard conversion sequence according to C++11 [dcl.init.list]p7.\n  enum NarrowingKind {\n    /// Not a narrowing conversion.\n    NK_Not_Narrowing,\n\n    /// A narrowing conversion by virtue of the source and destination types.\n    NK_Type_Narrowing,\n\n    /// A narrowing conversion, because a constant expression got narrowed.\n    NK_Constant_Narrowing,\n\n    /// A narrowing conversion, because a non-constant-expression variable might\n    /// have got narrowed.\n    NK_Variable_Narrowing,\n\n    /// Cannot tell whether this is a narrowing conversion because the\n    /// expression is value-dependent.\n    NK_Dependent_Narrowing,\n  };\n\n  /// StandardConversionSequence - represents a standard conversion\n  /// sequence (C++ 13.3.3.1.1). A standard conversion sequence\n  /// contains between zero and three conversions. If a particular\n  /// conversion is not needed, it will be set to the identity conversion\n  /// (ICK_Identity). Note that the three conversions are\n  /// specified as separate members (rather than in an array) so that\n  /// we can keep the size of a standard conversion sequence to a\n  /// single word.\n  class StandardConversionSequence {\n  public:\n    /// First -- The first conversion can be an lvalue-to-rvalue\n    /// conversion, array-to-pointer conversion, or\n    /// function-to-pointer conversion.\n    ImplicitConversionKind First : 8;\n\n    /// Second - The second conversion can be an integral promotion,\n    /// floating point promotion, integral conversion, floating point\n    /// conversion, floating-integral conversion, pointer conversion,\n    /// pointer-to-member conversion, or boolean conversion.\n    ImplicitConversionKind Second : 8;\n\n    /// Third - The third conversion can be a qualification conversion\n    /// or a function conversion.\n    ImplicitConversionKind Third : 8;\n\n    /// Whether this is the deprecated conversion of a\n    /// string literal to a pointer to non-const character data\n    /// (C++ 4.2p2).\n    unsigned DeprecatedStringLiteralToCharPtr : 1;\n\n    /// Whether the qualification conversion involves a change in the\n    /// Objective-C lifetime (for automatic reference counting).\n    unsigned QualificationIncludesObjCLifetime : 1;\n\n    /// IncompatibleObjC - Whether this is an Objective-C conversion\n    /// that we should warn about (if we actually use it).\n    unsigned IncompatibleObjC : 1;\n\n    /// ReferenceBinding - True when this is a reference binding\n    /// (C++ [over.ics.ref]).\n    unsigned ReferenceBinding : 1;\n\n    /// DirectBinding - True when this is a reference binding that is a\n    /// direct binding (C++ [dcl.init.ref]).\n    unsigned DirectBinding : 1;\n\n    /// Whether this is an lvalue reference binding (otherwise, it's\n    /// an rvalue reference binding).\n    unsigned IsLvalueReference : 1;\n\n    /// Whether we're binding to a function lvalue.\n    unsigned BindsToFunctionLvalue : 1;\n\n    /// Whether we're binding to an rvalue.\n    unsigned BindsToRvalue : 1;\n\n    /// Whether this binds an implicit object argument to a\n    /// non-static member function without a ref-qualifier.\n    unsigned BindsImplicitObjectArgumentWithoutRefQualifier : 1;\n\n    /// Whether this binds a reference to an object with a different\n    /// Objective-C lifetime qualifier.\n    unsigned ObjCLifetimeConversionBinding : 1;\n\n    /// FromType - The type that this conversion is converting\n    /// from. This is an opaque pointer that can be translated into a\n    /// QualType.\n    void *FromTypePtr;\n\n    /// ToType - The types that this conversion is converting to in\n    /// each step. This is an opaque pointer that can be translated\n    /// into a QualType.\n    void *ToTypePtrs[3];\n\n    /// CopyConstructor - The copy constructor that is used to perform\n    /// this conversion, when the conversion is actually just the\n    /// initialization of an object via copy constructor. Such\n    /// conversions are either identity conversions or derived-to-base\n    /// conversions.\n    CXXConstructorDecl *CopyConstructor;\n    DeclAccessPair FoundCopyConstructor;\n\n    void setFromType(QualType T) { FromTypePtr = T.getAsOpaquePtr(); }\n\n    void setToType(unsigned Idx, QualType T) {\n      assert(Idx < 3 && \"To type index is out of range\");\n      ToTypePtrs[Idx] = T.getAsOpaquePtr();\n    }\n\n    void setAllToTypes(QualType T) {\n      ToTypePtrs[0] = T.getAsOpaquePtr();\n      ToTypePtrs[1] = ToTypePtrs[0];\n      ToTypePtrs[2] = ToTypePtrs[0];\n    }\n\n    QualType getFromType() const {\n      return QualType::getFromOpaquePtr(FromTypePtr);\n    }\n\n    QualType getToType(unsigned Idx) const {\n      assert(Idx < 3 && \"To type index is out of range\");\n      return QualType::getFromOpaquePtr(ToTypePtrs[Idx]);\n    }\n\n    void setAsIdentityConversion();\n\n    bool isIdentityConversion() const {\n      return Second == ICK_Identity && Third == ICK_Identity;\n    }\n\n    ImplicitConversionRank getRank() const;\n    NarrowingKind\n    getNarrowingKind(ASTContext &Context, const Expr *Converted,\n                     APValue &ConstantValue, QualType &ConstantType,\n                     bool IgnoreFloatToIntegralConversion = false) const;\n    bool isPointerConversionToBool() const;\n    bool isPointerConversionToVoidPointer(ASTContext& Context) const;\n    void dump() const;\n  };\n\n  /// UserDefinedConversionSequence - Represents a user-defined\n  /// conversion sequence (C++ 13.3.3.1.2).\n  struct UserDefinedConversionSequence {\n    /// Represents the standard conversion that occurs before\n    /// the actual user-defined conversion.\n    ///\n    /// C++11 13.3.3.1.2p1:\n    ///   If the user-defined conversion is specified by a constructor\n    ///   (12.3.1), the initial standard conversion sequence converts\n    ///   the source type to the type required by the argument of the\n    ///   constructor. If the user-defined conversion is specified by\n    ///   a conversion function (12.3.2), the initial standard\n    ///   conversion sequence converts the source type to the implicit\n    ///   object parameter of the conversion function.\n    StandardConversionSequence Before;\n\n    /// EllipsisConversion - When this is true, it means user-defined\n    /// conversion sequence starts with a ... (ellipsis) conversion, instead of\n    /// a standard conversion. In this case, 'Before' field must be ignored.\n    // FIXME. I much rather put this as the first field. But there seems to be\n    // a gcc code gen. bug which causes a crash in a test. Putting it here seems\n    // to work around the crash.\n    bool EllipsisConversion : 1;\n\n    /// HadMultipleCandidates - When this is true, it means that the\n    /// conversion function was resolved from an overloaded set having\n    /// size greater than 1.\n    bool HadMultipleCandidates : 1;\n\n    /// After - Represents the standard conversion that occurs after\n    /// the actual user-defined conversion.\n    StandardConversionSequence After;\n\n    /// ConversionFunction - The function that will perform the\n    /// user-defined conversion. Null if the conversion is an\n    /// aggregate initialization from an initializer list.\n    FunctionDecl* ConversionFunction;\n\n    /// The declaration that we found via name lookup, which might be\n    /// the same as \\c ConversionFunction or it might be a using declaration\n    /// that refers to \\c ConversionFunction.\n    DeclAccessPair FoundConversionFunction;\n\n    void dump() const;\n  };\n\n  /// Represents an ambiguous user-defined conversion sequence.\n  struct AmbiguousConversionSequence {\n    using ConversionSet =\n        SmallVector<std::pair<NamedDecl *, FunctionDecl *>, 4>;\n\n    void *FromTypePtr;\n    void *ToTypePtr;\n    char Buffer[sizeof(ConversionSet)];\n\n    QualType getFromType() const {\n      return QualType::getFromOpaquePtr(FromTypePtr);\n    }\n\n    QualType getToType() const {\n      return QualType::getFromOpaquePtr(ToTypePtr);\n    }\n\n    void setFromType(QualType T) { FromTypePtr = T.getAsOpaquePtr(); }\n    void setToType(QualType T) { ToTypePtr = T.getAsOpaquePtr(); }\n\n    ConversionSet &conversions() {\n      return *reinterpret_cast<ConversionSet*>(Buffer);\n    }\n\n    const ConversionSet &conversions() const {\n      return *reinterpret_cast<const ConversionSet*>(Buffer);\n    }\n\n    void addConversion(NamedDecl *Found, FunctionDecl *D) {\n      conversions().push_back(std::make_pair(Found, D));\n    }\n\n    using iterator = ConversionSet::iterator;\n\n    iterator begin() { return conversions().begin(); }\n    iterator end() { return conversions().end(); }\n\n    using const_iterator = ConversionSet::const_iterator;\n\n    const_iterator begin() const { return conversions().begin(); }\n    const_iterator end() const { return conversions().end(); }\n\n    void construct();\n    void destruct();\n    void copyFrom(const AmbiguousConversionSequence &);\n  };\n\n  /// BadConversionSequence - Records information about an invalid\n  /// conversion sequence.\n  struct BadConversionSequence {\n    enum FailureKind {\n      no_conversion,\n      unrelated_class,\n      bad_qualifiers,\n      lvalue_ref_to_rvalue,\n      rvalue_ref_to_lvalue\n    };\n\n    // This can be null, e.g. for implicit object arguments.\n    Expr *FromExpr;\n\n    FailureKind Kind;\n\n  private:\n    // The type we're converting from (an opaque QualType).\n    void *FromTy;\n\n    // The type we're converting to (an opaque QualType).\n    void *ToTy;\n\n  public:\n    void init(FailureKind K, Expr *From, QualType To) {\n      init(K, From->getType(), To);\n      FromExpr = From;\n    }\n\n    void init(FailureKind K, QualType From, QualType To) {\n      Kind = K;\n      FromExpr = nullptr;\n      setFromType(From);\n      setToType(To);\n    }\n\n    QualType getFromType() const { return QualType::getFromOpaquePtr(FromTy); }\n    QualType getToType() const { return QualType::getFromOpaquePtr(ToTy); }\n\n    void setFromExpr(Expr *E) {\n      FromExpr = E;\n      setFromType(E->getType());\n    }\n\n    void setFromType(QualType T) { FromTy = T.getAsOpaquePtr(); }\n    void setToType(QualType T) { ToTy = T.getAsOpaquePtr(); }\n  };\n\n  /// ImplicitConversionSequence - Represents an implicit conversion\n  /// sequence, which may be a standard conversion sequence\n  /// (C++ 13.3.3.1.1), user-defined conversion sequence (C++ 13.3.3.1.2),\n  /// or an ellipsis conversion sequence (C++ 13.3.3.1.3).\n  class ImplicitConversionSequence {\n  public:\n    /// Kind - The kind of implicit conversion sequence. BadConversion\n    /// specifies that there is no conversion from the source type to\n    /// the target type.  AmbiguousConversion represents the unique\n    /// ambiguous conversion (C++0x [over.best.ics]p10).\n    enum Kind {\n      StandardConversion = 0,\n      UserDefinedConversion,\n      AmbiguousConversion,\n      EllipsisConversion,\n      BadConversion\n    };\n\n  private:\n    enum {\n      Uninitialized = BadConversion + 1\n    };\n\n    /// ConversionKind - The kind of implicit conversion sequence.\n    unsigned ConversionKind : 30;\n\n    /// Whether the target is really a std::initializer_list, and the\n    /// sequence only represents the worst element conversion.\n    unsigned StdInitializerListElement : 1;\n\n    void setKind(Kind K) {\n      destruct();\n      ConversionKind = K;\n    }\n\n    void destruct() {\n      if (ConversionKind == AmbiguousConversion) Ambiguous.destruct();\n    }\n\n  public:\n    union {\n      /// When ConversionKind == StandardConversion, provides the\n      /// details of the standard conversion sequence.\n      StandardConversionSequence Standard;\n\n      /// When ConversionKind == UserDefinedConversion, provides the\n      /// details of the user-defined conversion sequence.\n      UserDefinedConversionSequence UserDefined;\n\n      /// When ConversionKind == AmbiguousConversion, provides the\n      /// details of the ambiguous conversion.\n      AmbiguousConversionSequence Ambiguous;\n\n      /// When ConversionKind == BadConversion, provides the details\n      /// of the bad conversion.\n      BadConversionSequence Bad;\n    };\n\n    ImplicitConversionSequence()\n        : ConversionKind(Uninitialized), StdInitializerListElement(false) {\n      Standard.setAsIdentityConversion();\n    }\n\n    ImplicitConversionSequence(const ImplicitConversionSequence &Other)\n        : ConversionKind(Other.ConversionKind),\n          StdInitializerListElement(Other.StdInitializerListElement) {\n      switch (ConversionKind) {\n      case Uninitialized: break;\n      case StandardConversion: Standard = Other.Standard; break;\n      case UserDefinedConversion: UserDefined = Other.UserDefined; break;\n      case AmbiguousConversion: Ambiguous.copyFrom(Other.Ambiguous); break;\n      case EllipsisConversion: break;\n      case BadConversion: Bad = Other.Bad; break;\n      }\n    }\n\n    ImplicitConversionSequence &\n    operator=(const ImplicitConversionSequence &Other) {\n      destruct();\n      new (this) ImplicitConversionSequence(Other);\n      return *this;\n    }\n\n    ~ImplicitConversionSequence() {\n      destruct();\n    }\n\n    Kind getKind() const {\n      assert(isInitialized() && \"querying uninitialized conversion\");\n      return Kind(ConversionKind);\n    }\n\n    /// Return a ranking of the implicit conversion sequence\n    /// kind, where smaller ranks represent better conversion\n    /// sequences.\n    ///\n    /// In particular, this routine gives user-defined conversion\n    /// sequences and ambiguous conversion sequences the same rank,\n    /// per C++ [over.best.ics]p10.\n    unsigned getKindRank() const {\n      switch (getKind()) {\n      case StandardConversion:\n        return 0;\n\n      case UserDefinedConversion:\n      case AmbiguousConversion:\n        return 1;\n\n      case EllipsisConversion:\n        return 2;\n\n      case BadConversion:\n        return 3;\n      }\n\n      llvm_unreachable(\"Invalid ImplicitConversionSequence::Kind!\");\n    }\n\n    bool isBad() const { return getKind() == BadConversion; }\n    bool isStandard() const { return getKind() == StandardConversion; }\n    bool isEllipsis() const { return getKind() == EllipsisConversion; }\n    bool isAmbiguous() const { return getKind() == AmbiguousConversion; }\n    bool isUserDefined() const { return getKind() == UserDefinedConversion; }\n    bool isFailure() const { return isBad() || isAmbiguous(); }\n\n    /// Determines whether this conversion sequence has been\n    /// initialized.  Most operations should never need to query\n    /// uninitialized conversions and should assert as above.\n    bool isInitialized() const { return ConversionKind != Uninitialized; }\n\n    /// Sets this sequence as a bad conversion for an explicit argument.\n    void setBad(BadConversionSequence::FailureKind Failure,\n                Expr *FromExpr, QualType ToType) {\n      setKind(BadConversion);\n      Bad.init(Failure, FromExpr, ToType);\n    }\n\n    /// Sets this sequence as a bad conversion for an implicit argument.\n    void setBad(BadConversionSequence::FailureKind Failure,\n                QualType FromType, QualType ToType) {\n      setKind(BadConversion);\n      Bad.init(Failure, FromType, ToType);\n    }\n\n    void setStandard() { setKind(StandardConversion); }\n    void setEllipsis() { setKind(EllipsisConversion); }\n    void setUserDefined() { setKind(UserDefinedConversion); }\n\n    void setAmbiguous() {\n      if (ConversionKind == AmbiguousConversion) return;\n      ConversionKind = AmbiguousConversion;\n      Ambiguous.construct();\n    }\n\n    void setAsIdentityConversion(QualType T) {\n      setStandard();\n      Standard.setAsIdentityConversion();\n      Standard.setFromType(T);\n      Standard.setAllToTypes(T);\n    }\n\n    /// Whether the target is really a std::initializer_list, and the\n    /// sequence only represents the worst element conversion.\n    bool isStdInitializerListElement() const {\n      return StdInitializerListElement;\n    }\n\n    void setStdInitializerListElement(bool V = true) {\n      StdInitializerListElement = V;\n    }\n\n    /// Form an \"implicit\" conversion sequence from nullptr_t to bool, for a\n    /// direct-initialization of a bool object from nullptr_t.\n    static ImplicitConversionSequence getNullptrToBool(QualType SourceType,\n                                                       QualType DestType,\n                                                       bool NeedLValToRVal) {\n      ImplicitConversionSequence ICS;\n      ICS.setStandard();\n      ICS.Standard.setAsIdentityConversion();\n      ICS.Standard.setFromType(SourceType);\n      if (NeedLValToRVal)\n        ICS.Standard.First = ICK_Lvalue_To_Rvalue;\n      ICS.Standard.setToType(0, SourceType);\n      ICS.Standard.Second = ICK_Boolean_Conversion;\n      ICS.Standard.setToType(1, DestType);\n      ICS.Standard.setToType(2, DestType);\n      return ICS;\n    }\n\n    // The result of a comparison between implicit conversion\n    // sequences. Use Sema::CompareImplicitConversionSequences to\n    // actually perform the comparison.\n    enum CompareKind {\n      Better = -1,\n      Indistinguishable = 0,\n      Worse = 1\n    };\n\n    void DiagnoseAmbiguousConversion(Sema &S,\n                                     SourceLocation CaretLoc,\n                                     const PartialDiagnostic &PDiag) const;\n\n    void dump() const;\n  };\n\n  enum OverloadFailureKind {\n    ovl_fail_too_many_arguments,\n    ovl_fail_too_few_arguments,\n    ovl_fail_bad_conversion,\n    ovl_fail_bad_deduction,\n\n    /// This conversion candidate was not considered because it\n    /// duplicates the work of a trivial or derived-to-base\n    /// conversion.\n    ovl_fail_trivial_conversion,\n\n    /// This conversion candidate was not considered because it is\n    /// an illegal instantiation of a constructor temploid: it is\n    /// callable with one argument, we only have one argument, and\n    /// its first parameter type is exactly the type of the class.\n    ///\n    /// Defining such a constructor directly is illegal, and\n    /// template-argument deduction is supposed to ignore such\n    /// instantiations, but we can still get one with the right\n    /// kind of implicit instantiation.\n    ovl_fail_illegal_constructor,\n\n    /// This conversion candidate is not viable because its result\n    /// type is not implicitly convertible to the desired type.\n    ovl_fail_bad_final_conversion,\n\n    /// This conversion function template specialization candidate is not\n    /// viable because the final conversion was not an exact match.\n    ovl_fail_final_conversion_not_exact,\n\n    /// (CUDA) This candidate was not viable because the callee\n    /// was not accessible from the caller's target (i.e. host->device,\n    /// global->host, device->host).\n    ovl_fail_bad_target,\n\n    /// This candidate function was not viable because an enable_if\n    /// attribute disabled it.\n    ovl_fail_enable_if,\n\n    /// This candidate constructor or conversion function is explicit but\n    /// the context doesn't permit explicit functions.\n    ovl_fail_explicit,\n\n    /// This candidate was not viable because its address could not be taken.\n    ovl_fail_addr_not_available,\n\n    /// This candidate was not viable because its OpenCL extension is disabled.\n    ovl_fail_ext_disabled,\n\n    /// This inherited constructor is not viable because it would slice the\n    /// argument.\n    ovl_fail_inhctor_slice,\n\n    /// This candidate was not viable because it is a non-default multiversioned\n    /// function.\n    ovl_non_default_multiversion_function,\n\n    /// This constructor/conversion candidate fail due to an address space\n    /// mismatch between the object being constructed and the overload\n    /// candidate.\n    ovl_fail_object_addrspace_mismatch,\n\n    /// This candidate was not viable because its associated constraints were\n    /// not satisfied.\n    ovl_fail_constraints_not_satisfied,\n  };\n\n  /// A list of implicit conversion sequences for the arguments of an\n  /// OverloadCandidate.\n  using ConversionSequenceList =\n      llvm::MutableArrayRef<ImplicitConversionSequence>;\n\n  /// OverloadCandidate - A single candidate in an overload set (C++ 13.3).\n  struct OverloadCandidate {\n    /// Function - The actual function that this candidate\n    /// represents. When NULL, this is a built-in candidate\n    /// (C++ [over.oper]) or a surrogate for a conversion to a\n    /// function pointer or reference (C++ [over.call.object]).\n    FunctionDecl *Function;\n\n    /// FoundDecl - The original declaration that was looked up /\n    /// invented / otherwise found, together with its access.\n    /// Might be a UsingShadowDecl or a FunctionTemplateDecl.\n    DeclAccessPair FoundDecl;\n\n    /// BuiltinParamTypes - Provides the parameter types of a built-in overload\n    /// candidate. Only valid when Function is NULL.\n    QualType BuiltinParamTypes[3];\n\n    /// Surrogate - The conversion function for which this candidate\n    /// is a surrogate, but only if IsSurrogate is true.\n    CXXConversionDecl *Surrogate;\n\n    /// The conversion sequences used to convert the function arguments\n    /// to the function parameters. Note that these are indexed by argument,\n    /// so may not match the parameter order of Function.\n    ConversionSequenceList Conversions;\n\n    /// The FixIt hints which can be used to fix the Bad candidate.\n    ConversionFixItGenerator Fix;\n\n    /// Viable - True to indicate that this overload candidate is viable.\n    bool Viable : 1;\n\n    /// Whether this candidate is the best viable function, or tied for being\n    /// the best viable function.\n    ///\n    /// For an ambiguous overload resolution, indicates whether this candidate\n    /// was part of the ambiguity kernel: the minimal non-empty set of viable\n    /// candidates such that all elements of the ambiguity kernel are better\n    /// than all viable candidates not in the ambiguity kernel.\n    bool Best : 1;\n\n    /// IsSurrogate - True to indicate that this candidate is a\n    /// surrogate for a conversion to a function pointer or reference\n    /// (C++ [over.call.object]).\n    bool IsSurrogate : 1;\n\n    /// IgnoreObjectArgument - True to indicate that the first\n    /// argument's conversion, which for this function represents the\n    /// implicit object argument, should be ignored. This will be true\n    /// when the candidate is a static member function (where the\n    /// implicit object argument is just a placeholder) or a\n    /// non-static member function when the call doesn't have an\n    /// object argument.\n    bool IgnoreObjectArgument : 1;\n\n    /// True if the candidate was found using ADL.\n    CallExpr::ADLCallKind IsADLCandidate : 1;\n\n    /// Whether this is a rewritten candidate, and if so, of what kind?\n    unsigned RewriteKind : 2;\n\n    /// FailureKind - The reason why this candidate is not viable.\n    /// Actually an OverloadFailureKind.\n    unsigned char FailureKind;\n\n    /// The number of call arguments that were explicitly provided,\n    /// to be used while performing partial ordering of function templates.\n    unsigned ExplicitCallArguments;\n\n    union {\n      DeductionFailureInfo DeductionFailure;\n\n      /// FinalConversion - For a conversion function (where Function is\n      /// a CXXConversionDecl), the standard conversion that occurs\n      /// after the call to the overload candidate to convert the result\n      /// of calling the conversion function to the required type.\n      StandardConversionSequence FinalConversion;\n    };\n\n    /// Get RewriteKind value in OverloadCandidateRewriteKind type (This\n    /// function is to workaround the spurious GCC bitfield enum warning)\n    OverloadCandidateRewriteKind getRewriteKind() const {\n      return static_cast<OverloadCandidateRewriteKind>(RewriteKind);\n    }\n\n    bool isReversed() const { return getRewriteKind() & CRK_Reversed; }\n\n    /// hasAmbiguousConversion - Returns whether this overload\n    /// candidate requires an ambiguous conversion or not.\n    bool hasAmbiguousConversion() const {\n      for (auto &C : Conversions) {\n        if (!C.isInitialized()) return false;\n        if (C.isAmbiguous()) return true;\n      }\n      return false;\n    }\n\n    bool TryToFixBadConversion(unsigned Idx, Sema &S) {\n      bool CanFix = Fix.tryToFixConversion(\n                      Conversions[Idx].Bad.FromExpr,\n                      Conversions[Idx].Bad.getFromType(),\n                      Conversions[Idx].Bad.getToType(), S);\n\n      // If at least one conversion fails, the candidate cannot be fixed.\n      if (!CanFix)\n        Fix.clear();\n\n      return CanFix;\n    }\n\n    unsigned getNumParams() const {\n      if (IsSurrogate) {\n        QualType STy = Surrogate->getConversionType();\n        while (STy->isPointerType() || STy->isReferenceType())\n          STy = STy->getPointeeType();\n        return STy->castAs<FunctionProtoType>()->getNumParams();\n      }\n      if (Function)\n        return Function->getNumParams();\n      return ExplicitCallArguments;\n    }\n\n  private:\n    friend class OverloadCandidateSet;\n    OverloadCandidate()\n        : IsSurrogate(false), IsADLCandidate(CallExpr::NotADL), RewriteKind(CRK_None) {}\n  };\n\n  /// OverloadCandidateSet - A set of overload candidates, used in C++\n  /// overload resolution (C++ 13.3).\n  class OverloadCandidateSet {\n  public:\n    enum CandidateSetKind {\n      /// Normal lookup.\n      CSK_Normal,\n\n      /// C++ [over.match.oper]:\n      /// Lookup of operator function candidates in a call using operator\n      /// syntax. Candidates that have no parameters of class type will be\n      /// skipped unless there is a parameter of (reference to) enum type and\n      /// the corresponding argument is of the same enum type.\n      CSK_Operator,\n\n      /// C++ [over.match.copy]:\n      /// Copy-initialization of an object of class type by user-defined\n      /// conversion.\n      CSK_InitByUserDefinedConversion,\n\n      /// C++ [over.match.ctor], [over.match.list]\n      /// Initialization of an object of class type by constructor,\n      /// using either a parenthesized or braced list of arguments.\n      CSK_InitByConstructor,\n    };\n\n    /// Information about operator rewrites to consider when adding operator\n    /// functions to a candidate set.\n    struct OperatorRewriteInfo {\n      OperatorRewriteInfo()\n          : OriginalOperator(OO_None), AllowRewrittenCandidates(false) {}\n      OperatorRewriteInfo(OverloadedOperatorKind Op, bool AllowRewritten)\n          : OriginalOperator(Op), AllowRewrittenCandidates(AllowRewritten) {}\n\n      /// The original operator as written in the source.\n      OverloadedOperatorKind OriginalOperator;\n      /// Whether we should include rewritten candidates in the overload set.\n      bool AllowRewrittenCandidates;\n\n      /// Would use of this function result in a rewrite using a different\n      /// operator?\n      bool isRewrittenOperator(const FunctionDecl *FD) {\n        return OriginalOperator &&\n               FD->getDeclName().getCXXOverloadedOperator() != OriginalOperator;\n      }\n\n      bool isAcceptableCandidate(const FunctionDecl *FD) {\n        if (!OriginalOperator)\n          return true;\n\n        // For an overloaded operator, we can have candidates with a different\n        // name in our unqualified lookup set. Make sure we only consider the\n        // ones we're supposed to.\n        OverloadedOperatorKind OO =\n            FD->getDeclName().getCXXOverloadedOperator();\n        return OO && (OO == OriginalOperator ||\n                      (AllowRewrittenCandidates &&\n                       OO == getRewrittenOverloadedOperator(OriginalOperator)));\n      }\n\n      /// Determine the kind of rewrite that should be performed for this\n      /// candidate.\n      OverloadCandidateRewriteKind\n      getRewriteKind(const FunctionDecl *FD, OverloadCandidateParamOrder PO) {\n        OverloadCandidateRewriteKind CRK = CRK_None;\n        if (isRewrittenOperator(FD))\n          CRK = OverloadCandidateRewriteKind(CRK | CRK_DifferentOperator);\n        if (PO == OverloadCandidateParamOrder::Reversed)\n          CRK = OverloadCandidateRewriteKind(CRK | CRK_Reversed);\n        return CRK;\n      }\n\n      /// Determines whether this operator could be implemented by a function\n      /// with reversed parameter order.\n      bool isReversible() {\n        return AllowRewrittenCandidates && OriginalOperator &&\n               (getRewrittenOverloadedOperator(OriginalOperator) != OO_None ||\n                shouldAddReversed(OriginalOperator));\n      }\n\n      /// Determine whether we should consider looking for and adding reversed\n      /// candidates for operator Op.\n      bool shouldAddReversed(OverloadedOperatorKind Op);\n\n      /// Determine whether we should add a rewritten candidate for \\p FD with\n      /// reversed parameter order.\n      bool shouldAddReversed(ASTContext &Ctx, const FunctionDecl *FD);\n    };\n\n  private:\n    SmallVector<OverloadCandidate, 16> Candidates;\n    llvm::SmallPtrSet<uintptr_t, 16> Functions;\n\n    // Allocator for ConversionSequenceLists. We store the first few of these\n    // inline to avoid allocation for small sets.\n    llvm::BumpPtrAllocator SlabAllocator;\n\n    SourceLocation Loc;\n    CandidateSetKind Kind;\n    OperatorRewriteInfo RewriteInfo;\n\n    constexpr static unsigned NumInlineBytes =\n        24 * sizeof(ImplicitConversionSequence);\n    unsigned NumInlineBytesUsed = 0;\n    alignas(void *) char InlineSpace[NumInlineBytes];\n\n    // Address space of the object being constructed.\n    LangAS DestAS = LangAS::Default;\n\n    /// If we have space, allocates from inline storage. Otherwise, allocates\n    /// from the slab allocator.\n    /// FIXME: It would probably be nice to have a SmallBumpPtrAllocator\n    /// instead.\n    /// FIXME: Now that this only allocates ImplicitConversionSequences, do we\n    /// want to un-generalize this?\n    template <typename T>\n    T *slabAllocate(unsigned N) {\n      // It's simpler if this doesn't need to consider alignment.\n      static_assert(alignof(T) == alignof(void *),\n                    \"Only works for pointer-aligned types.\");\n      static_assert(std::is_trivial<T>::value ||\n                        std::is_same<ImplicitConversionSequence, T>::value,\n                    \"Add destruction logic to OverloadCandidateSet::clear().\");\n\n      unsigned NBytes = sizeof(T) * N;\n      if (NBytes > NumInlineBytes - NumInlineBytesUsed)\n        return SlabAllocator.Allocate<T>(N);\n      char *FreeSpaceStart = InlineSpace + NumInlineBytesUsed;\n      assert(uintptr_t(FreeSpaceStart) % alignof(void *) == 0 &&\n             \"Misaligned storage!\");\n\n      NumInlineBytesUsed += NBytes;\n      return reinterpret_cast<T *>(FreeSpaceStart);\n    }\n\n    void destroyCandidates();\n\n    /// Whether diagnostics should be deferred.\n    bool shouldDeferDiags(Sema &S, ArrayRef<Expr *> Args, SourceLocation OpLoc);\n\n  public:\n    OverloadCandidateSet(SourceLocation Loc, CandidateSetKind CSK,\n                         OperatorRewriteInfo RewriteInfo = {})\n        : Loc(Loc), Kind(CSK), RewriteInfo(RewriteInfo) {}\n    OverloadCandidateSet(const OverloadCandidateSet &) = delete;\n    OverloadCandidateSet &operator=(const OverloadCandidateSet &) = delete;\n    ~OverloadCandidateSet() { destroyCandidates(); }\n\n    SourceLocation getLocation() const { return Loc; }\n    CandidateSetKind getKind() const { return Kind; }\n    OperatorRewriteInfo getRewriteInfo() const { return RewriteInfo; }\n\n    /// Determine when this overload candidate will be new to the\n    /// overload set.\n    bool isNewCandidate(Decl *F, OverloadCandidateParamOrder PO =\n                                     OverloadCandidateParamOrder::Normal) {\n      uintptr_t Key = reinterpret_cast<uintptr_t>(F->getCanonicalDecl());\n      Key |= static_cast<uintptr_t>(PO);\n      return Functions.insert(Key).second;\n    }\n\n    /// Exclude a function from being considered by overload resolution.\n    void exclude(Decl *F) {\n      isNewCandidate(F, OverloadCandidateParamOrder::Normal);\n      isNewCandidate(F, OverloadCandidateParamOrder::Reversed);\n    }\n\n    /// Clear out all of the candidates.\n    void clear(CandidateSetKind CSK);\n\n    using iterator = SmallVectorImpl<OverloadCandidate>::iterator;\n\n    iterator begin() { return Candidates.begin(); }\n    iterator end() { return Candidates.end(); }\n\n    size_t size() const { return Candidates.size(); }\n    bool empty() const { return Candidates.empty(); }\n\n    /// Allocate storage for conversion sequences for NumConversions\n    /// conversions.\n    ConversionSequenceList\n    allocateConversionSequences(unsigned NumConversions) {\n      ImplicitConversionSequence *Conversions =\n          slabAllocate<ImplicitConversionSequence>(NumConversions);\n\n      // Construct the new objects.\n      for (unsigned I = 0; I != NumConversions; ++I)\n        new (&Conversions[I]) ImplicitConversionSequence();\n\n      return ConversionSequenceList(Conversions, NumConversions);\n    }\n\n    /// Add a new candidate with NumConversions conversion sequence slots\n    /// to the overload set.\n    OverloadCandidate &addCandidate(unsigned NumConversions = 0,\n                                    ConversionSequenceList Conversions = None) {\n      assert((Conversions.empty() || Conversions.size() == NumConversions) &&\n             \"preallocated conversion sequence has wrong length\");\n\n      Candidates.push_back(OverloadCandidate());\n      OverloadCandidate &C = Candidates.back();\n      C.Conversions = Conversions.empty()\n                          ? allocateConversionSequences(NumConversions)\n                          : Conversions;\n      return C;\n    }\n\n    /// Find the best viable function on this overload set, if it exists.\n    OverloadingResult BestViableFunction(Sema &S, SourceLocation Loc,\n                                         OverloadCandidateSet::iterator& Best);\n\n    SmallVector<OverloadCandidate *, 32> CompleteCandidates(\n        Sema &S, OverloadCandidateDisplayKind OCD, ArrayRef<Expr *> Args,\n        SourceLocation OpLoc = SourceLocation(),\n        llvm::function_ref<bool(OverloadCandidate &)> Filter =\n            [](OverloadCandidate &) { return true; });\n\n    void NoteCandidates(\n        PartialDiagnosticAt PA, Sema &S, OverloadCandidateDisplayKind OCD,\n        ArrayRef<Expr *> Args, StringRef Opc = \"\",\n        SourceLocation Loc = SourceLocation(),\n        llvm::function_ref<bool(OverloadCandidate &)> Filter =\n            [](OverloadCandidate &) { return true; });\n\n    void NoteCandidates(Sema &S, ArrayRef<Expr *> Args,\n                        ArrayRef<OverloadCandidate *> Cands,\n                        StringRef Opc = \"\",\n                        SourceLocation OpLoc = SourceLocation());\n\n    LangAS getDestAS() { return DestAS; }\n\n    void setDestAS(LangAS AS) {\n      assert((Kind == CSK_InitByConstructor ||\n              Kind == CSK_InitByUserDefinedConversion) &&\n             \"can't set the destination address space when not constructing an \"\n             \"object\");\n      DestAS = AS;\n    }\n\n  };\n\n  bool isBetterOverloadCandidate(Sema &S,\n                                 const OverloadCandidate &Cand1,\n                                 const OverloadCandidate &Cand2,\n                                 SourceLocation Loc,\n                                 OverloadCandidateSet::CandidateSetKind Kind);\n\n  struct ConstructorInfo {\n    DeclAccessPair FoundDecl;\n    CXXConstructorDecl *Constructor;\n    FunctionTemplateDecl *ConstructorTmpl;\n\n    explicit operator bool() const { return Constructor; }\n  };\n\n  // FIXME: Add an AddOverloadCandidate / AddTemplateOverloadCandidate overload\n  // that takes one of these.\n  inline ConstructorInfo getConstructorInfo(NamedDecl *ND) {\n    if (isa<UsingDecl>(ND))\n      return ConstructorInfo{};\n\n    // For constructors, the access check is performed against the underlying\n    // declaration, not the found declaration.\n    auto *D = ND->getUnderlyingDecl();\n    ConstructorInfo Info = {DeclAccessPair::make(ND, D->getAccess()), nullptr,\n                            nullptr};\n    Info.ConstructorTmpl = dyn_cast<FunctionTemplateDecl>(D);\n    if (Info.ConstructorTmpl)\n      D = Info.ConstructorTmpl->getTemplatedDecl();\n    Info.Constructor = dyn_cast<CXXConstructorDecl>(D);\n    return Info;\n  }\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SEMA_OVERLOAD_H\n"}, "45": {"id": 45, "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaExpr.cpp", "content": "//===--- SemaExpr.cpp - Semantic Analysis for Expressions -----------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file implements semantic analysis for expressions.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"TreeTransform.h\"\n#include \"UsedDeclVisitor.h\"\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTLambda.h\"\n#include \"clang/AST/ASTMutationListener.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/EvaluatedExprVisitor.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/ExprOpenMP.h\"\n#include \"clang/AST/OperationKinds.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/Basic/Builtins.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Lex/LiteralSupport.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"clang/Sema/AnalysisBasedWarnings.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"clang/Sema/DelayedDiagnostic.h\"\n#include \"clang/Sema/Designator.h\"\n#include \"clang/Sema/Initialization.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/Overload.h\"\n#include \"clang/Sema/ParsedTemplate.h\"\n#include \"clang/Sema/Scope.h\"\n#include \"clang/Sema/ScopeInfo.h\"\n#include \"clang/Sema/SemaFixItUtils.h\"\n#include \"clang/Sema/SemaInternal.h\"\n#include \"clang/Sema/Template.h\"\n#include \"llvm/Support/ConvertUTF.h\"\n#include \"llvm/Support/SaveAndRestore.h\"\nusing namespace clang;\nusing namespace sema;\nusing llvm::RoundingMode;\n\n/// Determine whether the use of this declaration is valid, without\n/// emitting diagnostics.\nbool Sema::CanUseDecl(NamedDecl *D, bool TreatUnavailableAsInvalid) {\n  // See if this is an auto-typed variable whose initializer we are parsing.\n  if (ParsingInitForAutoVars.count(D))\n    return false;\n\n  // See if this is a deleted function.\n  if (FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {\n    if (FD->isDeleted())\n      return false;\n\n    // If the function has a deduced return type, and we can't deduce it,\n    // then we can't use it either.\n    if (getLangOpts().CPlusPlus14 && FD->getReturnType()->isUndeducedType() &&\n        DeduceReturnType(FD, SourceLocation(), /*Diagnose*/ false))\n      return false;\n\n    // See if this is an aligned allocation/deallocation function that is\n    // unavailable.\n    if (TreatUnavailableAsInvalid &&\n        isUnavailableAlignedAllocationFunction(*FD))\n      return false;\n  }\n\n  // See if this function is unavailable.\n  if (TreatUnavailableAsInvalid && D->getAvailability() == AR_Unavailable &&\n      cast<Decl>(CurContext)->getAvailability() != AR_Unavailable)\n    return false;\n\n  return true;\n}\n\nstatic void DiagnoseUnusedOfDecl(Sema &S, NamedDecl *D, SourceLocation Loc) {\n  // Warn if this is used but marked unused.\n  if (const auto *A = D->getAttr<UnusedAttr>()) {\n    // [[maybe_unused]] should not diagnose uses, but __attribute__((unused))\n    // should diagnose them.\n    if (A->getSemanticSpelling() != UnusedAttr::CXX11_maybe_unused &&\n        A->getSemanticSpelling() != UnusedAttr::C2x_maybe_unused) {\n      const Decl *DC = cast_or_null<Decl>(S.getCurObjCLexicalContext());\n      if (DC && !DC->hasAttr<UnusedAttr>())\n        S.Diag(Loc, diag::warn_used_but_marked_unused) << D;\n    }\n  }\n}\n\n/// Emit a note explaining that this function is deleted.\nvoid Sema::NoteDeletedFunction(FunctionDecl *Decl) {\n  assert(Decl && Decl->isDeleted());\n\n  if (Decl->isDefaulted()) {\n    // If the method was explicitly defaulted, point at that declaration.\n    if (!Decl->isImplicit())\n      Diag(Decl->getLocation(), diag::note_implicitly_deleted);\n\n    // Try to diagnose why this special member function was implicitly\n    // deleted. This might fail, if that reason no longer applies.\n    DiagnoseDeletedDefaultedFunction(Decl);\n    return;\n  }\n\n  auto *Ctor = dyn_cast<CXXConstructorDecl>(Decl);\n  if (Ctor && Ctor->isInheritingConstructor())\n    return NoteDeletedInheritingConstructor(Ctor);\n\n  Diag(Decl->getLocation(), diag::note_availability_specified_here)\n    << Decl << 1;\n}\n\n/// Determine whether a FunctionDecl was ever declared with an\n/// explicit storage class.\nstatic bool hasAnyExplicitStorageClass(const FunctionDecl *D) {\n  for (auto I : D->redecls()) {\n    if (I->getStorageClass() != SC_None)\n      return true;\n  }\n  return false;\n}\n\n/// Check whether we're in an extern inline function and referring to a\n/// variable or function with internal linkage (C11 6.7.4p3).\n///\n/// This is only a warning because we used to silently accept this code, but\n/// in many cases it will not behave correctly. This is not enabled in C++ mode\n/// because the restriction language is a bit weaker (C++11 [basic.def.odr]p6)\n/// and so while there may still be user mistakes, most of the time we can't\n/// prove that there are errors.\nstatic void diagnoseUseOfInternalDeclInInlineFunction(Sema &S,\n                                                      const NamedDecl *D,\n                                                      SourceLocation Loc) {\n  // This is disabled under C++; there are too many ways for this to fire in\n  // contexts where the warning is a false positive, or where it is technically\n  // correct but benign.\n  if (S.getLangOpts().CPlusPlus)\n    return;\n\n  // Check if this is an inlined function or method.\n  FunctionDecl *Current = S.getCurFunctionDecl();\n  if (!Current)\n    return;\n  if (!Current->isInlined())\n    return;\n  if (!Current->isExternallyVisible())\n    return;\n\n  // Check if the decl has internal linkage.\n  if (D->getFormalLinkage() != InternalLinkage)\n    return;\n\n  // Downgrade from ExtWarn to Extension if\n  //  (1) the supposedly external inline function is in the main file,\n  //      and probably won't be included anywhere else.\n  //  (2) the thing we're referencing is a pure function.\n  //  (3) the thing we're referencing is another inline function.\n  // This last can give us false negatives, but it's better than warning on\n  // wrappers for simple C library functions.\n  const FunctionDecl *UsedFn = dyn_cast<FunctionDecl>(D);\n  bool DowngradeWarning = S.getSourceManager().isInMainFile(Loc);\n  if (!DowngradeWarning && UsedFn)\n    DowngradeWarning = UsedFn->isInlined() || UsedFn->hasAttr<ConstAttr>();\n\n  S.Diag(Loc, DowngradeWarning ? diag::ext_internal_in_extern_inline_quiet\n                               : diag::ext_internal_in_extern_inline)\n    << /*IsVar=*/!UsedFn << D;\n\n  S.MaybeSuggestAddingStaticToDecl(Current);\n\n  S.Diag(D->getCanonicalDecl()->getLocation(), diag::note_entity_declared_at)\n      << D;\n}\n\nvoid Sema::MaybeSuggestAddingStaticToDecl(const FunctionDecl *Cur) {\n  const FunctionDecl *First = Cur->getFirstDecl();\n\n  // Suggest \"static\" on the function, if possible.\n  if (!hasAnyExplicitStorageClass(First)) {\n    SourceLocation DeclBegin = First->getSourceRange().getBegin();\n    Diag(DeclBegin, diag::note_convert_inline_to_static)\n      << Cur << FixItHint::CreateInsertion(DeclBegin, \"static \");\n  }\n}\n\n/// Determine whether the use of this declaration is valid, and\n/// emit any corresponding diagnostics.\n///\n/// This routine diagnoses various problems with referencing\n/// declarations that can occur when using a declaration. For example,\n/// it might warn if a deprecated or unavailable declaration is being\n/// used, or produce an error (and return true) if a C++0x deleted\n/// function is being used.\n///\n/// \\returns true if there was an error (this declaration cannot be\n/// referenced), false otherwise.\n///\nbool Sema::DiagnoseUseOfDecl(NamedDecl *D, ArrayRef<SourceLocation> Locs,\n                             const ObjCInterfaceDecl *UnknownObjCClass,\n                             bool ObjCPropertyAccess,\n                             bool AvoidPartialAvailabilityChecks,\n                             ObjCInterfaceDecl *ClassReceiver) {\n  SourceLocation Loc = Locs.front();\n  if (getLangOpts().CPlusPlus && isa<FunctionDecl>(D)) {\n    // If there were any diagnostics suppressed by template argument deduction,\n    // emit them now.\n    auto Pos = SuppressedDiagnostics.find(D->getCanonicalDecl());\n    if (Pos != SuppressedDiagnostics.end()) {\n      for (const PartialDiagnosticAt &Suppressed : Pos->second)\n        Diag(Suppressed.first, Suppressed.second);\n\n      // Clear out the list of suppressed diagnostics, so that we don't emit\n      // them again for this specialization. However, we don't obsolete this\n      // entry from the table, because we want to avoid ever emitting these\n      // diagnostics again.\n      Pos->second.clear();\n    }\n\n    // C++ [basic.start.main]p3:\n    //   The function 'main' shall not be used within a program.\n    if (cast<FunctionDecl>(D)->isMain())\n      Diag(Loc, diag::ext_main_used);\n\n    diagnoseUnavailableAlignedAllocation(*cast<FunctionDecl>(D), Loc);\n  }\n\n  // See if this is an auto-typed variable whose initializer we are parsing.\n  if (ParsingInitForAutoVars.count(D)) {\n    if (isa<BindingDecl>(D)) {\n      Diag(Loc, diag::err_binding_cannot_appear_in_own_initializer)\n        << D->getDeclName();\n    } else {\n      Diag(Loc, diag::err_auto_variable_cannot_appear_in_own_initializer)\n        << D->getDeclName() << cast<VarDecl>(D)->getType();\n    }\n    return true;\n  }\n\n  if (FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {\n    // See if this is a deleted function.\n    if (FD->isDeleted()) {\n      auto *Ctor = dyn_cast<CXXConstructorDecl>(FD);\n      if (Ctor && Ctor->isInheritingConstructor())\n        Diag(Loc, diag::err_deleted_inherited_ctor_use)\n            << Ctor->getParent()\n            << Ctor->getInheritedConstructor().getConstructor()->getParent();\n      else\n        Diag(Loc, diag::err_deleted_function_use);\n      NoteDeletedFunction(FD);\n      return true;\n    }\n\n    // [expr.prim.id]p4\n    //   A program that refers explicitly or implicitly to a function with a\n    //   trailing requires-clause whose constraint-expression is not satisfied,\n    //   other than to declare it, is ill-formed. [...]\n    //\n    // See if this is a function with constraints that need to be satisfied.\n    // Check this before deducing the return type, as it might instantiate the\n    // definition.\n    if (FD->getTrailingRequiresClause()) {\n      ConstraintSatisfaction Satisfaction;\n      if (CheckFunctionConstraints(FD, Satisfaction, Loc))\n        // A diagnostic will have already been generated (non-constant\n        // constraint expression, for example)\n        return true;\n      if (!Satisfaction.IsSatisfied) {\n        Diag(Loc,\n             diag::err_reference_to_function_with_unsatisfied_constraints)\n            << D;\n        DiagnoseUnsatisfiedConstraint(Satisfaction);\n        return true;\n      }\n    }\n\n    // If the function has a deduced return type, and we can't deduce it,\n    // then we can't use it either.\n    if (getLangOpts().CPlusPlus14 && FD->getReturnType()->isUndeducedType() &&\n        DeduceReturnType(FD, Loc))\n      return true;\n\n    if (getLangOpts().CUDA && !CheckCUDACall(Loc, FD))\n      return true;\n\n    if (getLangOpts().SYCLIsDevice && !checkSYCLDeviceFunction(Loc, FD))\n      return true;\n  }\n\n  if (auto *MD = dyn_cast<CXXMethodDecl>(D)) {\n    // Lambdas are only default-constructible or assignable in C++2a onwards.\n    if (MD->getParent()->isLambda() &&\n        ((isa<CXXConstructorDecl>(MD) &&\n          cast<CXXConstructorDecl>(MD)->isDefaultConstructor()) ||\n         MD->isCopyAssignmentOperator() || MD->isMoveAssignmentOperator())) {\n      Diag(Loc, diag::warn_cxx17_compat_lambda_def_ctor_assign)\n        << !isa<CXXConstructorDecl>(MD);\n    }\n  }\n\n  auto getReferencedObjCProp = [](const NamedDecl *D) ->\n                                      const ObjCPropertyDecl * {\n    if (const auto *MD = dyn_cast<ObjCMethodDecl>(D))\n      return MD->findPropertyDecl();\n    return nullptr;\n  };\n  if (const ObjCPropertyDecl *ObjCPDecl = getReferencedObjCProp(D)) {\n    if (diagnoseArgIndependentDiagnoseIfAttrs(ObjCPDecl, Loc))\n      return true;\n  } else if (diagnoseArgIndependentDiagnoseIfAttrs(D, Loc)) {\n      return true;\n  }\n\n  // [OpenMP 4.0], 2.15 declare reduction Directive, Restrictions\n  // Only the variables omp_in and omp_out are allowed in the combiner.\n  // Only the variables omp_priv and omp_orig are allowed in the\n  // initializer-clause.\n  auto *DRD = dyn_cast<OMPDeclareReductionDecl>(CurContext);\n  if (LangOpts.OpenMP && DRD && !CurContext->containsDecl(D) &&\n      isa<VarDecl>(D)) {\n    Diag(Loc, diag::err_omp_wrong_var_in_declare_reduction)\n        << getCurFunction()->HasOMPDeclareReductionCombiner;\n    Diag(D->getLocation(), diag::note_entity_declared_at) << D;\n    return true;\n  }\n\n  // [OpenMP 5.0], 2.19.7.3. declare mapper Directive, Restrictions\n  //  List-items in map clauses on this construct may only refer to the declared\n  //  variable var and entities that could be referenced by a procedure defined\n  //  at the same location\n  if (LangOpts.OpenMP && isa<VarDecl>(D) &&\n      !isOpenMPDeclareMapperVarDeclAllowed(cast<VarDecl>(D))) {\n    Diag(Loc, diag::err_omp_declare_mapper_wrong_var)\n        << getOpenMPDeclareMapperVarName();\n    Diag(D->getLocation(), diag::note_entity_declared_at) << D;\n    return true;\n  }\n\n  DiagnoseAvailabilityOfDecl(D, Locs, UnknownObjCClass, ObjCPropertyAccess,\n                             AvoidPartialAvailabilityChecks, ClassReceiver);\n\n  DiagnoseUnusedOfDecl(*this, D, Loc);\n\n  diagnoseUseOfInternalDeclInInlineFunction(*this, D, Loc);\n\n  // CUDA/HIP: Diagnose invalid references of host global variables in device\n  // functions. Reference of device global variables in host functions is\n  // allowed through shadow variables therefore it is not diagnosed.\n  if (LangOpts.CUDAIsDevice) {\n    auto *FD = dyn_cast_or_null<FunctionDecl>(CurContext);\n    auto Target = IdentifyCUDATarget(FD);\n    if (FD && Target != CFT_Host) {\n      const auto *VD = dyn_cast<VarDecl>(D);\n      if (VD && VD->hasGlobalStorage() && !VD->hasAttr<CUDADeviceAttr>() &&\n          !VD->hasAttr<CUDAConstantAttr>() && !VD->hasAttr<CUDASharedAttr>() &&\n          !VD->getType()->isCUDADeviceBuiltinSurfaceType() &&\n          !VD->getType()->isCUDADeviceBuiltinTextureType() &&\n          !VD->isConstexpr() && !VD->getType().isConstQualified())\n        targetDiag(*Locs.begin(), diag::err_ref_bad_target)\n            << /*host*/ 2 << /*variable*/ 1 << VD << Target;\n    }\n  }\n\n  if (LangOpts.SYCLIsDevice || (LangOpts.OpenMP && LangOpts.OpenMPIsDevice)) {\n    if (auto *VD = dyn_cast<ValueDecl>(D))\n      checkDeviceDecl(VD, Loc);\n\n    if (!Context.getTargetInfo().isTLSSupported())\n      if (const auto *VD = dyn_cast<VarDecl>(D))\n        if (VD->getTLSKind() != VarDecl::TLS_None)\n          targetDiag(*Locs.begin(), diag::err_thread_unsupported);\n  }\n\n  if (isa<ParmVarDecl>(D) && isa<RequiresExprBodyDecl>(D->getDeclContext()) &&\n      !isUnevaluatedContext()) {\n    // C++ [expr.prim.req.nested] p3\n    //   A local parameter shall only appear as an unevaluated operand\n    //   (Clause 8) within the constraint-expression.\n    Diag(Loc, diag::err_requires_expr_parameter_referenced_in_evaluated_context)\n        << D;\n    Diag(D->getLocation(), diag::note_entity_declared_at) << D;\n    return true;\n  }\n\n  return false;\n}\n\n/// DiagnoseSentinelCalls - This routine checks whether a call or\n/// message-send is to a declaration with the sentinel attribute, and\n/// if so, it checks that the requirements of the sentinel are\n/// satisfied.\nvoid Sema::DiagnoseSentinelCalls(NamedDecl *D, SourceLocation Loc,\n                                 ArrayRef<Expr *> Args) {\n  const SentinelAttr *attr = D->getAttr<SentinelAttr>();\n  if (!attr)\n    return;\n\n  // The number of formal parameters of the declaration.\n  unsigned numFormalParams;\n\n  // The kind of declaration.  This is also an index into a %select in\n  // the diagnostic.\n  enum CalleeType { CT_Function, CT_Method, CT_Block } calleeType;\n\n  if (ObjCMethodDecl *MD = dyn_cast<ObjCMethodDecl>(D)) {\n    numFormalParams = MD->param_size();\n    calleeType = CT_Method;\n  } else if (FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {\n    numFormalParams = FD->param_size();\n    calleeType = CT_Function;\n  } else if (isa<VarDecl>(D)) {\n    QualType type = cast<ValueDecl>(D)->getType();\n    const FunctionType *fn = nullptr;\n    if (const PointerType *ptr = type->getAs<PointerType>()) {\n      fn = ptr->getPointeeType()->getAs<FunctionType>();\n      if (!fn) return;\n      calleeType = CT_Function;\n    } else if (const BlockPointerType *ptr = type->getAs<BlockPointerType>()) {\n      fn = ptr->getPointeeType()->castAs<FunctionType>();\n      calleeType = CT_Block;\n    } else {\n      return;\n    }\n\n    if (const FunctionProtoType *proto = dyn_cast<FunctionProtoType>(fn)) {\n      numFormalParams = proto->getNumParams();\n    } else {\n      numFormalParams = 0;\n    }\n  } else {\n    return;\n  }\n\n  // \"nullPos\" is the number of formal parameters at the end which\n  // effectively count as part of the variadic arguments.  This is\n  // useful if you would prefer to not have *any* formal parameters,\n  // but the language forces you to have at least one.\n  unsigned nullPos = attr->getNullPos();\n  assert((nullPos == 0 || nullPos == 1) && \"invalid null position on sentinel\");\n  numFormalParams = (nullPos > numFormalParams ? 0 : numFormalParams - nullPos);\n\n  // The number of arguments which should follow the sentinel.\n  unsigned numArgsAfterSentinel = attr->getSentinel();\n\n  // If there aren't enough arguments for all the formal parameters,\n  // the sentinel, and the args after the sentinel, complain.\n  if (Args.size() < numFormalParams + numArgsAfterSentinel + 1) {\n    Diag(Loc, diag::warn_not_enough_argument) << D->getDeclName();\n    Diag(D->getLocation(), diag::note_sentinel_here) << int(calleeType);\n    return;\n  }\n\n  // Otherwise, find the sentinel expression.\n  Expr *sentinelExpr = Args[Args.size() - numArgsAfterSentinel - 1];\n  if (!sentinelExpr) return;\n  if (sentinelExpr->isValueDependent()) return;\n  if (Context.isSentinelNullExpr(sentinelExpr)) return;\n\n  // Pick a reasonable string to insert.  Optimistically use 'nil', 'nullptr',\n  // or 'NULL' if those are actually defined in the context.  Only use\n  // 'nil' for ObjC methods, where it's much more likely that the\n  // variadic arguments form a list of object pointers.\n  SourceLocation MissingNilLoc = getLocForEndOfToken(sentinelExpr->getEndLoc());\n  std::string NullValue;\n  if (calleeType == CT_Method && PP.isMacroDefined(\"nil\"))\n    NullValue = \"nil\";\n  else if (getLangOpts().CPlusPlus11)\n    NullValue = \"nullptr\";\n  else if (PP.isMacroDefined(\"NULL\"))\n    NullValue = \"NULL\";\n  else\n    NullValue = \"(void*) 0\";\n\n  if (MissingNilLoc.isInvalid())\n    Diag(Loc, diag::warn_missing_sentinel) << int(calleeType);\n  else\n    Diag(MissingNilLoc, diag::warn_missing_sentinel)\n      << int(calleeType)\n      << FixItHint::CreateInsertion(MissingNilLoc, \", \" + NullValue);\n  Diag(D->getLocation(), diag::note_sentinel_here) << int(calleeType);\n}\n\nSourceRange Sema::getExprRange(Expr *E) const {\n  return E ? E->getSourceRange() : SourceRange();\n}\n\n//===----------------------------------------------------------------------===//\n//  Standard Promotions and Conversions\n//===----------------------------------------------------------------------===//\n\n/// DefaultFunctionArrayConversion (C99 6.3.2.1p3, C99 6.3.2.1p4).\nExprResult Sema::DefaultFunctionArrayConversion(Expr *E, bool Diagnose) {\n  // Handle any placeholder expressions which made it here.\n  if (E->getType()->isPlaceholderType()) {\n    ExprResult result = CheckPlaceholderExpr(E);\n    if (result.isInvalid()) return ExprError();\n    E = result.get();\n  }\n\n  QualType Ty = E->getType();\n  assert(!Ty.isNull() && \"DefaultFunctionArrayConversion - missing type\");\n\n  if (Ty->isFunctionType()) {\n    if (auto *DRE = dyn_cast<DeclRefExpr>(E->IgnoreParenCasts()))\n      if (auto *FD = dyn_cast<FunctionDecl>(DRE->getDecl()))\n        if (!checkAddressOfFunctionIsAvailable(FD, Diagnose, E->getExprLoc()))\n          return ExprError();\n\n    E = ImpCastExprToType(E, Context.getPointerType(Ty),\n                          CK_FunctionToPointerDecay).get();\n  } else if (Ty->isArrayType()) {\n    // In C90 mode, arrays only promote to pointers if the array expression is\n    // an lvalue.  The relevant legalese is C90 6.2.2.1p3: \"an lvalue that has\n    // type 'array of type' is converted to an expression that has type 'pointer\n    // to type'...\".  In C99 this was changed to: C99 6.3.2.1p3: \"an expression\n    // that has type 'array of type' ...\".  The relevant change is \"an lvalue\"\n    // (C90) to \"an expression\" (C99).\n    //\n    // C++ 4.2p1:\n    // An lvalue or rvalue of type \"array of N T\" or \"array of unknown bound of\n    // T\" can be converted to an rvalue of type \"pointer to T\".\n    //\n    if (getLangOpts().C99 || getLangOpts().CPlusPlus || E->isLValue())\n      E = ImpCastExprToType(E, Context.getArrayDecayedType(Ty),\n                            CK_ArrayToPointerDecay).get();\n  }\n  return E;\n}\n\nstatic void CheckForNullPointerDereference(Sema &S, Expr *E) {\n  // Check to see if we are dereferencing a null pointer.  If so,\n  // and if not volatile-qualified, this is undefined behavior that the\n  // optimizer will delete, so warn about it.  People sometimes try to use this\n  // to get a deterministic trap and are surprised by clang's behavior.  This\n  // only handles the pattern \"*null\", which is a very syntactic check.\n  const auto *UO = dyn_cast<UnaryOperator>(E->IgnoreParenCasts());\n  if (UO && UO->getOpcode() == UO_Deref &&\n      UO->getSubExpr()->getType()->isPointerType()) {\n    const LangAS AS =\n        UO->getSubExpr()->getType()->getPointeeType().getAddressSpace();\n    if ((!isTargetAddressSpace(AS) ||\n         (isTargetAddressSpace(AS) && toTargetAddressSpace(AS) == 0)) &&\n        UO->getSubExpr()->IgnoreParenCasts()->isNullPointerConstant(\n            S.Context, Expr::NPC_ValueDependentIsNotNull) &&\n        !UO->getType().isVolatileQualified()) {\n      S.DiagRuntimeBehavior(UO->getOperatorLoc(), UO,\n                            S.PDiag(diag::warn_indirection_through_null)\n                                << UO->getSubExpr()->getSourceRange());\n      S.DiagRuntimeBehavior(UO->getOperatorLoc(), UO,\n                            S.PDiag(diag::note_indirection_through_null));\n    }\n  }\n}\n\nstatic void DiagnoseDirectIsaAccess(Sema &S, const ObjCIvarRefExpr *OIRE,\n                                    SourceLocation AssignLoc,\n                                    const Expr* RHS) {\n  const ObjCIvarDecl *IV = OIRE->getDecl();\n  if (!IV)\n    return;\n\n  DeclarationName MemberName = IV->getDeclName();\n  IdentifierInfo *Member = MemberName.getAsIdentifierInfo();\n  if (!Member || !Member->isStr(\"isa\"))\n    return;\n\n  const Expr *Base = OIRE->getBase();\n  QualType BaseType = Base->getType();\n  if (OIRE->isArrow())\n    BaseType = BaseType->getPointeeType();\n  if (const ObjCObjectType *OTy = BaseType->getAs<ObjCObjectType>())\n    if (ObjCInterfaceDecl *IDecl = OTy->getInterface()) {\n      ObjCInterfaceDecl *ClassDeclared = nullptr;\n      ObjCIvarDecl *IV = IDecl->lookupInstanceVariable(Member, ClassDeclared);\n      if (!ClassDeclared->getSuperClass()\n          && (*ClassDeclared->ivar_begin()) == IV) {\n        if (RHS) {\n          NamedDecl *ObjectSetClass =\n            S.LookupSingleName(S.TUScope,\n                               &S.Context.Idents.get(\"object_setClass\"),\n                               SourceLocation(), S.LookupOrdinaryName);\n          if (ObjectSetClass) {\n            SourceLocation RHSLocEnd = S.getLocForEndOfToken(RHS->getEndLoc());\n            S.Diag(OIRE->getExprLoc(), diag::warn_objc_isa_assign)\n                << FixItHint::CreateInsertion(OIRE->getBeginLoc(),\n                                              \"object_setClass(\")\n                << FixItHint::CreateReplacement(\n                       SourceRange(OIRE->getOpLoc(), AssignLoc), \",\")\n                << FixItHint::CreateInsertion(RHSLocEnd, \")\");\n          }\n          else\n            S.Diag(OIRE->getLocation(), diag::warn_objc_isa_assign);\n        } else {\n          NamedDecl *ObjectGetClass =\n            S.LookupSingleName(S.TUScope,\n                               &S.Context.Idents.get(\"object_getClass\"),\n                               SourceLocation(), S.LookupOrdinaryName);\n          if (ObjectGetClass)\n            S.Diag(OIRE->getExprLoc(), diag::warn_objc_isa_use)\n                << FixItHint::CreateInsertion(OIRE->getBeginLoc(),\n                                              \"object_getClass(\")\n                << FixItHint::CreateReplacement(\n                       SourceRange(OIRE->getOpLoc(), OIRE->getEndLoc()), \")\");\n          else\n            S.Diag(OIRE->getLocation(), diag::warn_objc_isa_use);\n        }\n        S.Diag(IV->getLocation(), diag::note_ivar_decl);\n      }\n    }\n}\n\nExprResult Sema::DefaultLvalueConversion(Expr *E) {\n  // Handle any placeholder expressions which made it here.\n  if (E->getType()->isPlaceholderType()) {\n    ExprResult result = CheckPlaceholderExpr(E);\n    if (result.isInvalid()) return ExprError();\n    E = result.get();\n  }\n\n  // C++ [conv.lval]p1:\n  //   A glvalue of a non-function, non-array type T can be\n  //   converted to a prvalue.\n  if (!E->isGLValue()) return E;\n\n  QualType T = E->getType();\n  assert(!T.isNull() && \"r-value conversion on typeless expression?\");\n\n  // lvalue-to-rvalue conversion cannot be applied to function or array types.\n  if (T->isFunctionType() || T->isArrayType())\n    return E;\n\n  // We don't want to throw lvalue-to-rvalue casts on top of\n  // expressions of certain types in C++.\n  if (getLangOpts().CPlusPlus &&\n      (E->getType() == Context.OverloadTy ||\n       T->isDependentType() ||\n       T->isRecordType()))\n    return E;\n\n  // The C standard is actually really unclear on this point, and\n  // DR106 tells us what the result should be but not why.  It's\n  // generally best to say that void types just doesn't undergo\n  // lvalue-to-rvalue at all.  Note that expressions of unqualified\n  // 'void' type are never l-values, but qualified void can be.\n  if (T->isVoidType())\n    return E;\n\n  // OpenCL usually rejects direct accesses to values of 'half' type.\n  if (getLangOpts().OpenCL && !getOpenCLOptions().isEnabled(\"cl_khr_fp16\") &&\n      T->isHalfType()) {\n    Diag(E->getExprLoc(), diag::err_opencl_half_load_store)\n      << 0 << T;\n    return ExprError();\n  }\n\n  CheckForNullPointerDereference(*this, E);\n  if (const ObjCIsaExpr *OISA = dyn_cast<ObjCIsaExpr>(E->IgnoreParenCasts())) {\n    NamedDecl *ObjectGetClass = LookupSingleName(TUScope,\n                                     &Context.Idents.get(\"object_getClass\"),\n                                     SourceLocation(), LookupOrdinaryName);\n    if (ObjectGetClass)\n      Diag(E->getExprLoc(), diag::warn_objc_isa_use)\n          << FixItHint::CreateInsertion(OISA->getBeginLoc(), \"object_getClass(\")\n          << FixItHint::CreateReplacement(\n                 SourceRange(OISA->getOpLoc(), OISA->getIsaMemberLoc()), \")\");\n    else\n      Diag(E->getExprLoc(), diag::warn_objc_isa_use);\n  }\n  else if (const ObjCIvarRefExpr *OIRE =\n            dyn_cast<ObjCIvarRefExpr>(E->IgnoreParenCasts()))\n    DiagnoseDirectIsaAccess(*this, OIRE, SourceLocation(), /* Expr*/nullptr);\n\n  // C++ [conv.lval]p1:\n  //   [...] If T is a non-class type, the type of the prvalue is the\n  //   cv-unqualified version of T. Otherwise, the type of the\n  //   rvalue is T.\n  //\n  // C99 6.3.2.1p2:\n  //   If the lvalue has qualified type, the value has the unqualified\n  //   version of the type of the lvalue; otherwise, the value has the\n  //   type of the lvalue.\n  if (T.hasQualifiers())\n    T = T.getUnqualifiedType();\n\n  // Under the MS ABI, lock down the inheritance model now.\n  if (T->isMemberPointerType() &&\n      Context.getTargetInfo().getCXXABI().isMicrosoft())\n    (void)isCompleteType(E->getExprLoc(), T);\n\n  ExprResult Res = CheckLValueToRValueConversionOperand(E);\n  if (Res.isInvalid())\n    return Res;\n  E = Res.get();\n\n  // Loading a __weak object implicitly retains the value, so we need a cleanup to\n  // balance that.\n  if (E->getType().getObjCLifetime() == Qualifiers::OCL_Weak)\n    Cleanup.setExprNeedsCleanups(true);\n\n  if (E->getType().isDestructedType() == QualType::DK_nontrivial_c_struct)\n    Cleanup.setExprNeedsCleanups(true);\n\n  // C++ [conv.lval]p3:\n  //   If T is cv std::nullptr_t, the result is a null pointer constant.\n  CastKind CK = T->isNullPtrType() ? CK_NullToPointer : CK_LValueToRValue;\n  Res = ImplicitCastExpr::Create(Context, T, CK, E, nullptr, VK_RValue,\n                                 CurFPFeatureOverrides());\n\n  // C11 6.3.2.1p2:\n  //   ... if the lvalue has atomic type, the value has the non-atomic version\n  //   of the type of the lvalue ...\n  if (const AtomicType *Atomic = T->getAs<AtomicType>()) {\n    T = Atomic->getValueType().getUnqualifiedType();\n    Res = ImplicitCastExpr::Create(Context, T, CK_AtomicToNonAtomic, Res.get(),\n                                   nullptr, VK_RValue, FPOptionsOverride());\n  }\n\n  return Res;\n}\n\nExprResult Sema::DefaultFunctionArrayLvalueConversion(Expr *E, bool Diagnose) {\n  ExprResult Res = DefaultFunctionArrayConversion(E, Diagnose);\n  if (Res.isInvalid())\n    return ExprError();\n  Res = DefaultLvalueConversion(Res.get());\n  if (Res.isInvalid())\n    return ExprError();\n  return Res;\n}\n\n/// CallExprUnaryConversions - a special case of an unary conversion\n/// performed on a function designator of a call expression.\nExprResult Sema::CallExprUnaryConversions(Expr *E) {\n  QualType Ty = E->getType();\n  ExprResult Res = E;\n  // Only do implicit cast for a function type, but not for a pointer\n  // to function type.\n  if (Ty->isFunctionType()) {\n    Res = ImpCastExprToType(E, Context.getPointerType(Ty),\n                            CK_FunctionToPointerDecay);\n    if (Res.isInvalid())\n      return ExprError();\n  }\n  Res = DefaultLvalueConversion(Res.get());\n  if (Res.isInvalid())\n    return ExprError();\n  return Res.get();\n}\n\n/// UsualUnaryConversions - Performs various conversions that are common to most\n/// operators (C99 6.3). The conversions of array and function types are\n/// sometimes suppressed. For example, the array->pointer conversion doesn't\n/// apply if the array is an argument to the sizeof or address (&) operators.\n/// In these instances, this routine should *not* be called.\nExprResult Sema::UsualUnaryConversions(Expr *E) {\n  // First, convert to an r-value.\n  ExprResult Res = DefaultFunctionArrayLvalueConversion(E);\n  if (Res.isInvalid())\n    return ExprError();\n  E = Res.get();\n\n  QualType Ty = E->getType();\n  assert(!Ty.isNull() && \"UsualUnaryConversions - missing type\");\n\n  // Half FP have to be promoted to float unless it is natively supported\n  if (Ty->isHalfType() && !getLangOpts().NativeHalfType)\n    return ImpCastExprToType(Res.get(), Context.FloatTy, CK_FloatingCast);\n\n  // Try to perform integral promotions if the object has a theoretically\n  // promotable type.\n  if (Ty->isIntegralOrUnscopedEnumerationType()) {\n    // C99 6.3.1.1p2:\n    //\n    //   The following may be used in an expression wherever an int or\n    //   unsigned int may be used:\n    //     - an object or expression with an integer type whose integer\n    //       conversion rank is less than or equal to the rank of int\n    //       and unsigned int.\n    //     - A bit-field of type _Bool, int, signed int, or unsigned int.\n    //\n    //   If an int can represent all values of the original type, the\n    //   value is converted to an int; otherwise, it is converted to an\n    //   unsigned int. These are called the integer promotions. All\n    //   other types are unchanged by the integer promotions.\n\n    QualType PTy = Context.isPromotableBitField(E);\n    if (!PTy.isNull()) {\n      E = ImpCastExprToType(E, PTy, CK_IntegralCast).get();\n      return E;\n    }\n    if (Ty->isPromotableIntegerType()) {\n      QualType PT = Context.getPromotedIntegerType(Ty);\n      E = ImpCastExprToType(E, PT, CK_IntegralCast).get();\n      return E;\n    }\n  }\n  return E;\n}\n\n/// DefaultArgumentPromotion (C99 6.5.2.2p6). Used for function calls that\n/// do not have a prototype. Arguments that have type float or __fp16\n/// are promoted to double. All other argument types are converted by\n/// UsualUnaryConversions().\nExprResult Sema::DefaultArgumentPromotion(Expr *E) {\n  QualType Ty = E->getType();\n  assert(!Ty.isNull() && \"DefaultArgumentPromotion - missing type\");\n\n  ExprResult Res = UsualUnaryConversions(E);\n  if (Res.isInvalid())\n    return ExprError();\n  E = Res.get();\n\n  // If this is a 'float'  or '__fp16' (CVR qualified or typedef)\n  // promote to double.\n  // Note that default argument promotion applies only to float (and\n  // half/fp16); it does not apply to _Float16.\n  const BuiltinType *BTy = Ty->getAs<BuiltinType>();\n  if (BTy && (BTy->getKind() == BuiltinType::Half ||\n              BTy->getKind() == BuiltinType::Float)) {\n    if (getLangOpts().OpenCL &&\n        !getOpenCLOptions().isEnabled(\"cl_khr_fp64\")) {\n        if (BTy->getKind() == BuiltinType::Half) {\n            E = ImpCastExprToType(E, Context.FloatTy, CK_FloatingCast).get();\n        }\n    } else {\n      E = ImpCastExprToType(E, Context.DoubleTy, CK_FloatingCast).get();\n    }\n  }\n\n  // C++ performs lvalue-to-rvalue conversion as a default argument\n  // promotion, even on class types, but note:\n  //   C++11 [conv.lval]p2:\n  //     When an lvalue-to-rvalue conversion occurs in an unevaluated\n  //     operand or a subexpression thereof the value contained in the\n  //     referenced object is not accessed. Otherwise, if the glvalue\n  //     has a class type, the conversion copy-initializes a temporary\n  //     of type T from the glvalue and the result of the conversion\n  //     is a prvalue for the temporary.\n  // FIXME: add some way to gate this entire thing for correctness in\n  // potentially potentially evaluated contexts.\n  if (getLangOpts().CPlusPlus && E->isGLValue() && !isUnevaluatedContext()) {\n    ExprResult Temp = PerformCopyInitialization(\n                       InitializedEntity::InitializeTemporary(E->getType()),\n                                                E->getExprLoc(), E);\n    if (Temp.isInvalid())\n      return ExprError();\n    E = Temp.get();\n  }\n\n  return E;\n}\n\n/// Determine the degree of POD-ness for an expression.\n/// Incomplete types are considered POD, since this check can be performed\n/// when we're in an unevaluated context.\nSema::VarArgKind Sema::isValidVarArgType(const QualType &Ty) {\n  if (Ty->isIncompleteType()) {\n    // C++11 [expr.call]p7:\n    //   After these conversions, if the argument does not have arithmetic,\n    //   enumeration, pointer, pointer to member, or class type, the program\n    //   is ill-formed.\n    //\n    // Since we've already performed array-to-pointer and function-to-pointer\n    // decay, the only such type in C++ is cv void. This also handles\n    // initializer lists as variadic arguments.\n    if (Ty->isVoidType())\n      return VAK_Invalid;\n\n    if (Ty->isObjCObjectType())\n      return VAK_Invalid;\n    return VAK_Valid;\n  }\n\n  if (Ty.isDestructedType() == QualType::DK_nontrivial_c_struct)\n    return VAK_Invalid;\n\n  if (Ty.isCXX98PODType(Context))\n    return VAK_Valid;\n\n  // C++11 [expr.call]p7:\n  //   Passing a potentially-evaluated argument of class type (Clause 9)\n  //   having a non-trivial copy constructor, a non-trivial move constructor,\n  //   or a non-trivial destructor, with no corresponding parameter,\n  //   is conditionally-supported with implementation-defined semantics.\n  if (getLangOpts().CPlusPlus11 && !Ty->isDependentType())\n    if (CXXRecordDecl *Record = Ty->getAsCXXRecordDecl())\n      if (!Record->hasNonTrivialCopyConstructor() &&\n          !Record->hasNonTrivialMoveConstructor() &&\n          !Record->hasNonTrivialDestructor())\n        return VAK_ValidInCXX11;\n\n  if (getLangOpts().ObjCAutoRefCount && Ty->isObjCLifetimeType())\n    return VAK_Valid;\n\n  if (Ty->isObjCObjectType())\n    return VAK_Invalid;\n\n  if (getLangOpts().MSVCCompat)\n    return VAK_MSVCUndefined;\n\n  // FIXME: In C++11, these cases are conditionally-supported, meaning we're\n  // permitted to reject them. We should consider doing so.\n  return VAK_Undefined;\n}\n\nvoid Sema::checkVariadicArgument(const Expr *E, VariadicCallType CT) {\n  // Don't allow one to pass an Objective-C interface to a vararg.\n  const QualType &Ty = E->getType();\n  VarArgKind VAK = isValidVarArgType(Ty);\n\n  // Complain about passing non-POD types through varargs.\n  switch (VAK) {\n  case VAK_ValidInCXX11:\n    DiagRuntimeBehavior(\n        E->getBeginLoc(), nullptr,\n        PDiag(diag::warn_cxx98_compat_pass_non_pod_arg_to_vararg) << Ty << CT);\n    LLVM_FALLTHROUGH;\n  case VAK_Valid:\n    if (Ty->isRecordType()) {\n      // This is unlikely to be what the user intended. If the class has a\n      // 'c_str' member function, the user probably meant to call that.\n      DiagRuntimeBehavior(E->getBeginLoc(), nullptr,\n                          PDiag(diag::warn_pass_class_arg_to_vararg)\n                              << Ty << CT << hasCStrMethod(E) << \".c_str()\");\n    }\n    break;\n\n  case VAK_Undefined:\n  case VAK_MSVCUndefined:\n    DiagRuntimeBehavior(E->getBeginLoc(), nullptr,\n                        PDiag(diag::warn_cannot_pass_non_pod_arg_to_vararg)\n                            << getLangOpts().CPlusPlus11 << Ty << CT);\n    break;\n\n  case VAK_Invalid:\n    if (Ty.isDestructedType() == QualType::DK_nontrivial_c_struct)\n      Diag(E->getBeginLoc(),\n           diag::err_cannot_pass_non_trivial_c_struct_to_vararg)\n          << Ty << CT;\n    else if (Ty->isObjCObjectType())\n      DiagRuntimeBehavior(E->getBeginLoc(), nullptr,\n                          PDiag(diag::err_cannot_pass_objc_interface_to_vararg)\n                              << Ty << CT);\n    else\n      Diag(E->getBeginLoc(), diag::err_cannot_pass_to_vararg)\n          << isa<InitListExpr>(E) << Ty << CT;\n    break;\n  }\n}\n\n/// DefaultVariadicArgumentPromotion - Like DefaultArgumentPromotion, but\n/// will create a trap if the resulting type is not a POD type.\nExprResult Sema::DefaultVariadicArgumentPromotion(Expr *E, VariadicCallType CT,\n                                                  FunctionDecl *FDecl) {\n  if (const BuiltinType *PlaceholderTy = E->getType()->getAsPlaceholderType()) {\n    // Strip the unbridged-cast placeholder expression off, if applicable.\n    if (PlaceholderTy->getKind() == BuiltinType::ARCUnbridgedCast &&\n        (CT == VariadicMethod ||\n         (FDecl && FDecl->hasAttr<CFAuditedTransferAttr>()))) {\n      E = stripARCUnbridgedCast(E);\n\n    // Otherwise, do normal placeholder checking.\n    } else {\n      ExprResult ExprRes = CheckPlaceholderExpr(E);\n      if (ExprRes.isInvalid())\n        return ExprError();\n      E = ExprRes.get();\n    }\n  }\n\n  ExprResult ExprRes = DefaultArgumentPromotion(E);\n  if (ExprRes.isInvalid())\n    return ExprError();\n\n  // Copy blocks to the heap.\n  if (ExprRes.get()->getType()->isBlockPointerType())\n    maybeExtendBlockObject(ExprRes);\n\n  E = ExprRes.get();\n\n  // Diagnostics regarding non-POD argument types are\n  // emitted along with format string checking in Sema::CheckFunctionCall().\n  if (isValidVarArgType(E->getType()) == VAK_Undefined) {\n    // Turn this into a trap.\n    CXXScopeSpec SS;\n    SourceLocation TemplateKWLoc;\n    UnqualifiedId Name;\n    Name.setIdentifier(PP.getIdentifierInfo(\"__builtin_trap\"),\n                       E->getBeginLoc());\n    ExprResult TrapFn = ActOnIdExpression(TUScope, SS, TemplateKWLoc, Name,\n                                          /*HasTrailingLParen=*/true,\n                                          /*IsAddressOfOperand=*/false);\n    if (TrapFn.isInvalid())\n      return ExprError();\n\n    ExprResult Call = BuildCallExpr(TUScope, TrapFn.get(), E->getBeginLoc(),\n                                    None, E->getEndLoc());\n    if (Call.isInvalid())\n      return ExprError();\n\n    ExprResult Comma =\n        ActOnBinOp(TUScope, E->getBeginLoc(), tok::comma, Call.get(), E);\n    if (Comma.isInvalid())\n      return ExprError();\n    return Comma.get();\n  }\n\n  if (!getLangOpts().CPlusPlus &&\n      RequireCompleteType(E->getExprLoc(), E->getType(),\n                          diag::err_call_incomplete_argument))\n    return ExprError();\n\n  return E;\n}\n\n/// Converts an integer to complex float type.  Helper function of\n/// UsualArithmeticConversions()\n///\n/// \\return false if the integer expression is an integer type and is\n/// successfully converted to the complex type.\nstatic bool handleIntegerToComplexFloatConversion(Sema &S, ExprResult &IntExpr,\n                                                  ExprResult &ComplexExpr,\n                                                  QualType IntTy,\n                                                  QualType ComplexTy,\n                                                  bool SkipCast) {\n  if (IntTy->isComplexType() || IntTy->isRealFloatingType()) return true;\n  if (SkipCast) return false;\n  if (IntTy->isIntegerType()) {\n    QualType fpTy = cast<ComplexType>(ComplexTy)->getElementType();\n    IntExpr = S.ImpCastExprToType(IntExpr.get(), fpTy, CK_IntegralToFloating);\n    IntExpr = S.ImpCastExprToType(IntExpr.get(), ComplexTy,\n                                  CK_FloatingRealToComplex);\n  } else {\n    assert(IntTy->isComplexIntegerType());\n    IntExpr = S.ImpCastExprToType(IntExpr.get(), ComplexTy,\n                                  CK_IntegralComplexToFloatingComplex);\n  }\n  return false;\n}\n\n/// Handle arithmetic conversion with complex types.  Helper function of\n/// UsualArithmeticConversions()\nstatic QualType handleComplexFloatConversion(Sema &S, ExprResult &LHS,\n                                             ExprResult &RHS, QualType LHSType,\n                                             QualType RHSType,\n                                             bool IsCompAssign) {\n  // if we have an integer operand, the result is the complex type.\n  if (!handleIntegerToComplexFloatConversion(S, RHS, LHS, RHSType, LHSType,\n                                             /*skipCast*/false))\n    return LHSType;\n  if (!handleIntegerToComplexFloatConversion(S, LHS, RHS, LHSType, RHSType,\n                                             /*skipCast*/IsCompAssign))\n    return RHSType;\n\n  // This handles complex/complex, complex/float, or float/complex.\n  // When both operands are complex, the shorter operand is converted to the\n  // type of the longer, and that is the type of the result. This corresponds\n  // to what is done when combining two real floating-point operands.\n  // The fun begins when size promotion occur across type domains.\n  // From H&S 6.3.4: When one operand is complex and the other is a real\n  // floating-point type, the less precise type is converted, within it's\n  // real or complex domain, to the precision of the other type. For example,\n  // when combining a \"long double\" with a \"double _Complex\", the\n  // \"double _Complex\" is promoted to \"long double _Complex\".\n\n  // Compute the rank of the two types, regardless of whether they are complex.\n  int Order = S.Context.getFloatingTypeOrder(LHSType, RHSType);\n\n  auto *LHSComplexType = dyn_cast<ComplexType>(LHSType);\n  auto *RHSComplexType = dyn_cast<ComplexType>(RHSType);\n  QualType LHSElementType =\n      LHSComplexType ? LHSComplexType->getElementType() : LHSType;\n  QualType RHSElementType =\n      RHSComplexType ? RHSComplexType->getElementType() : RHSType;\n\n  QualType ResultType = S.Context.getComplexType(LHSElementType);\n  if (Order < 0) {\n    // Promote the precision of the LHS if not an assignment.\n    ResultType = S.Context.getComplexType(RHSElementType);\n    if (!IsCompAssign) {\n      if (LHSComplexType)\n        LHS =\n            S.ImpCastExprToType(LHS.get(), ResultType, CK_FloatingComplexCast);\n      else\n        LHS = S.ImpCastExprToType(LHS.get(), RHSElementType, CK_FloatingCast);\n    }\n  } else if (Order > 0) {\n    // Promote the precision of the RHS.\n    if (RHSComplexType)\n      RHS = S.ImpCastExprToType(RHS.get(), ResultType, CK_FloatingComplexCast);\n    else\n      RHS = S.ImpCastExprToType(RHS.get(), LHSElementType, CK_FloatingCast);\n  }\n  return ResultType;\n}\n\n/// Handle arithmetic conversion from integer to float.  Helper function\n/// of UsualArithmeticConversions()\nstatic QualType handleIntToFloatConversion(Sema &S, ExprResult &FloatExpr,\n                                           ExprResult &IntExpr,\n                                           QualType FloatTy, QualType IntTy,\n                                           bool ConvertFloat, bool ConvertInt) {\n  if (IntTy->isIntegerType()) {\n    if (ConvertInt)\n      // Convert intExpr to the lhs floating point type.\n      IntExpr = S.ImpCastExprToType(IntExpr.get(), FloatTy,\n                                    CK_IntegralToFloating);\n    return FloatTy;\n  }\n\n  // Convert both sides to the appropriate complex float.\n  assert(IntTy->isComplexIntegerType());\n  QualType result = S.Context.getComplexType(FloatTy);\n\n  // _Complex int -> _Complex float\n  if (ConvertInt)\n    IntExpr = S.ImpCastExprToType(IntExpr.get(), result,\n                                  CK_IntegralComplexToFloatingComplex);\n\n  // float -> _Complex float\n  if (ConvertFloat)\n    FloatExpr = S.ImpCastExprToType(FloatExpr.get(), result,\n                                    CK_FloatingRealToComplex);\n\n  return result;\n}\n\n/// Handle arithmethic conversion with floating point types.  Helper\n/// function of UsualArithmeticConversions()\nstatic QualType handleFloatConversion(Sema &S, ExprResult &LHS,\n                                      ExprResult &RHS, QualType LHSType,\n                                      QualType RHSType, bool IsCompAssign) {\n  bool LHSFloat = LHSType->isRealFloatingType();\n  bool RHSFloat = RHSType->isRealFloatingType();\n\n  // N1169 4.1.4: If one of the operands has a floating type and the other\n  //              operand has a fixed-point type, the fixed-point operand\n  //              is converted to the floating type [...]\n  if (LHSType->isFixedPointType() || RHSType->isFixedPointType()) {\n    if (LHSFloat)\n      RHS = S.ImpCastExprToType(RHS.get(), LHSType, CK_FixedPointToFloating);\n    else if (!IsCompAssign)\n      LHS = S.ImpCastExprToType(LHS.get(), RHSType, CK_FixedPointToFloating);\n    return LHSFloat ? LHSType : RHSType;\n  }\n\n  // If we have two real floating types, convert the smaller operand\n  // to the bigger result.\n  if (LHSFloat && RHSFloat) {\n    int order = S.Context.getFloatingTypeOrder(LHSType, RHSType);\n    if (order > 0) {\n      RHS = S.ImpCastExprToType(RHS.get(), LHSType, CK_FloatingCast);\n      return LHSType;\n    }\n\n    assert(order < 0 && \"illegal float comparison\");\n    if (!IsCompAssign)\n      LHS = S.ImpCastExprToType(LHS.get(), RHSType, CK_FloatingCast);\n    return RHSType;\n  }\n\n  if (LHSFloat) {\n    // Half FP has to be promoted to float unless it is natively supported\n    if (LHSType->isHalfType() && !S.getLangOpts().NativeHalfType)\n      LHSType = S.Context.FloatTy;\n\n    return handleIntToFloatConversion(S, LHS, RHS, LHSType, RHSType,\n                                      /*ConvertFloat=*/!IsCompAssign,\n                                      /*ConvertInt=*/ true);\n  }\n  assert(RHSFloat);\n  return handleIntToFloatConversion(S, RHS, LHS, RHSType, LHSType,\n                                    /*ConvertFloat=*/ true,\n                                    /*ConvertInt=*/!IsCompAssign);\n}\n\n/// Diagnose attempts to convert between __float128 and long double if\n/// there is no support for such conversion. Helper function of\n/// UsualArithmeticConversions().\nstatic bool unsupportedTypeConversion(const Sema &S, QualType LHSType,\n                                      QualType RHSType) {\n  /*  No issue converting if at least one of the types is not a floating point\n      type or the two types have the same rank.\n  */\n  if (!LHSType->isFloatingType() || !RHSType->isFloatingType() ||\n      S.Context.getFloatingTypeOrder(LHSType, RHSType) == 0)\n    return false;\n\n  assert(LHSType->isFloatingType() && RHSType->isFloatingType() &&\n         \"The remaining types must be floating point types.\");\n\n  auto *LHSComplex = LHSType->getAs<ComplexType>();\n  auto *RHSComplex = RHSType->getAs<ComplexType>();\n\n  QualType LHSElemType = LHSComplex ?\n    LHSComplex->getElementType() : LHSType;\n  QualType RHSElemType = RHSComplex ?\n    RHSComplex->getElementType() : RHSType;\n\n  // No issue if the two types have the same representation\n  if (&S.Context.getFloatTypeSemantics(LHSElemType) ==\n      &S.Context.getFloatTypeSemantics(RHSElemType))\n    return false;\n\n  bool Float128AndLongDouble = (LHSElemType == S.Context.Float128Ty &&\n                                RHSElemType == S.Context.LongDoubleTy);\n  Float128AndLongDouble |= (LHSElemType == S.Context.LongDoubleTy &&\n                            RHSElemType == S.Context.Float128Ty);\n\n  // We've handled the situation where __float128 and long double have the same\n  // representation. We allow all conversions for all possible long double types\n  // except PPC's double double.\n  return Float128AndLongDouble &&\n    (&S.Context.getFloatTypeSemantics(S.Context.LongDoubleTy) ==\n     &llvm::APFloat::PPCDoubleDouble());\n}\n\ntypedef ExprResult PerformCastFn(Sema &S, Expr *operand, QualType toType);\n\nnamespace {\n/// These helper callbacks are placed in an anonymous namespace to\n/// permit their use as function template parameters.\nExprResult doIntegralCast(Sema &S, Expr *op, QualType toType) {\n  return S.ImpCastExprToType(op, toType, CK_IntegralCast);\n}\n\nExprResult doComplexIntegralCast(Sema &S, Expr *op, QualType toType) {\n  return S.ImpCastExprToType(op, S.Context.getComplexType(toType),\n                             CK_IntegralComplexCast);\n}\n}\n\n/// Handle integer arithmetic conversions.  Helper function of\n/// UsualArithmeticConversions()\ntemplate <PerformCastFn doLHSCast, PerformCastFn doRHSCast>\nstatic QualType handleIntegerConversion(Sema &S, ExprResult &LHS,\n                                        ExprResult &RHS, QualType LHSType,\n                                        QualType RHSType, bool IsCompAssign) {\n  // The rules for this case are in C99 6.3.1.8\n  int order = S.Context.getIntegerTypeOrder(LHSType, RHSType);\n  bool LHSSigned = LHSType->hasSignedIntegerRepresentation();\n  bool RHSSigned = RHSType->hasSignedIntegerRepresentation();\n  if (LHSSigned == RHSSigned) {\n    // Same signedness; use the higher-ranked type\n    if (order >= 0) {\n      RHS = (*doRHSCast)(S, RHS.get(), LHSType);\n      return LHSType;\n    } else if (!IsCompAssign)\n      LHS = (*doLHSCast)(S, LHS.get(), RHSType);\n    return RHSType;\n  } else if (order != (LHSSigned ? 1 : -1)) {\n    // The unsigned type has greater than or equal rank to the\n    // signed type, so use the unsigned type\n    if (RHSSigned) {\n      RHS = (*doRHSCast)(S, RHS.get(), LHSType);\n      return LHSType;\n    } else if (!IsCompAssign)\n      LHS = (*doLHSCast)(S, LHS.get(), RHSType);\n    return RHSType;\n  } else if (S.Context.getIntWidth(LHSType) != S.Context.getIntWidth(RHSType)) {\n    // The two types are different widths; if we are here, that\n    // means the signed type is larger than the unsigned type, so\n    // use the signed type.\n    if (LHSSigned) {\n      RHS = (*doRHSCast)(S, RHS.get(), LHSType);\n      return LHSType;\n    } else if (!IsCompAssign)\n      LHS = (*doLHSCast)(S, LHS.get(), RHSType);\n    return RHSType;\n  } else {\n    // The signed type is higher-ranked than the unsigned type,\n    // but isn't actually any bigger (like unsigned int and long\n    // on most 32-bit systems).  Use the unsigned type corresponding\n    // to the signed type.\n    QualType result =\n      S.Context.getCorrespondingUnsignedType(LHSSigned ? LHSType : RHSType);\n    RHS = (*doRHSCast)(S, RHS.get(), result);\n    if (!IsCompAssign)\n      LHS = (*doLHSCast)(S, LHS.get(), result);\n    return result;\n  }\n}\n\n/// Handle conversions with GCC complex int extension.  Helper function\n/// of UsualArithmeticConversions()\nstatic QualType handleComplexIntConversion(Sema &S, ExprResult &LHS,\n                                           ExprResult &RHS, QualType LHSType,\n                                           QualType RHSType,\n                                           bool IsCompAssign) {\n  const ComplexType *LHSComplexInt = LHSType->getAsComplexIntegerType();\n  const ComplexType *RHSComplexInt = RHSType->getAsComplexIntegerType();\n\n  if (LHSComplexInt && RHSComplexInt) {\n    QualType LHSEltType = LHSComplexInt->getElementType();\n    QualType RHSEltType = RHSComplexInt->getElementType();\n    QualType ScalarType =\n      handleIntegerConversion<doComplexIntegralCast, doComplexIntegralCast>\n        (S, LHS, RHS, LHSEltType, RHSEltType, IsCompAssign);\n\n    return S.Context.getComplexType(ScalarType);\n  }\n\n  if (LHSComplexInt) {\n    QualType LHSEltType = LHSComplexInt->getElementType();\n    QualType ScalarType =\n      handleIntegerConversion<doComplexIntegralCast, doIntegralCast>\n        (S, LHS, RHS, LHSEltType, RHSType, IsCompAssign);\n    QualType ComplexType = S.Context.getComplexType(ScalarType);\n    RHS = S.ImpCastExprToType(RHS.get(), ComplexType,\n                              CK_IntegralRealToComplex);\n\n    return ComplexType;\n  }\n\n  assert(RHSComplexInt);\n\n  QualType RHSEltType = RHSComplexInt->getElementType();\n  QualType ScalarType =\n    handleIntegerConversion<doIntegralCast, doComplexIntegralCast>\n      (S, LHS, RHS, LHSType, RHSEltType, IsCompAssign);\n  QualType ComplexType = S.Context.getComplexType(ScalarType);\n\n  if (!IsCompAssign)\n    LHS = S.ImpCastExprToType(LHS.get(), ComplexType,\n                              CK_IntegralRealToComplex);\n  return ComplexType;\n}\n\n/// Return the rank of a given fixed point or integer type. The value itself\n/// doesn't matter, but the values must be increasing with proper increasing\n/// rank as described in N1169 4.1.1.\nstatic unsigned GetFixedPointRank(QualType Ty) {\n  const auto *BTy = Ty->getAs<BuiltinType>();\n  assert(BTy && \"Expected a builtin type.\");\n\n  switch (BTy->getKind()) {\n  case BuiltinType::ShortFract:\n  case BuiltinType::UShortFract:\n  case BuiltinType::SatShortFract:\n  case BuiltinType::SatUShortFract:\n    return 1;\n  case BuiltinType::Fract:\n  case BuiltinType::UFract:\n  case BuiltinType::SatFract:\n  case BuiltinType::SatUFract:\n    return 2;\n  case BuiltinType::LongFract:\n  case BuiltinType::ULongFract:\n  case BuiltinType::SatLongFract:\n  case BuiltinType::SatULongFract:\n    return 3;\n  case BuiltinType::ShortAccum:\n  case BuiltinType::UShortAccum:\n  case BuiltinType::SatShortAccum:\n  case BuiltinType::SatUShortAccum:\n    return 4;\n  case BuiltinType::Accum:\n  case BuiltinType::UAccum:\n  case BuiltinType::SatAccum:\n  case BuiltinType::SatUAccum:\n    return 5;\n  case BuiltinType::LongAccum:\n  case BuiltinType::ULongAccum:\n  case BuiltinType::SatLongAccum:\n  case BuiltinType::SatULongAccum:\n    return 6;\n  default:\n    if (BTy->isInteger())\n      return 0;\n    llvm_unreachable(\"Unexpected fixed point or integer type\");\n  }\n}\n\n/// handleFixedPointConversion - Fixed point operations between fixed\n/// point types and integers or other fixed point types do not fall under\n/// usual arithmetic conversion since these conversions could result in loss\n/// of precsision (N1169 4.1.4). These operations should be calculated with\n/// the full precision of their result type (N1169 4.1.6.2.1).\nstatic QualType handleFixedPointConversion(Sema &S, QualType LHSTy,\n                                           QualType RHSTy) {\n  assert((LHSTy->isFixedPointType() || RHSTy->isFixedPointType()) &&\n         \"Expected at least one of the operands to be a fixed point type\");\n  assert((LHSTy->isFixedPointOrIntegerType() ||\n          RHSTy->isFixedPointOrIntegerType()) &&\n         \"Special fixed point arithmetic operation conversions are only \"\n         \"applied to ints or other fixed point types\");\n\n  // If one operand has signed fixed-point type and the other operand has\n  // unsigned fixed-point type, then the unsigned fixed-point operand is\n  // converted to its corresponding signed fixed-point type and the resulting\n  // type is the type of the converted operand.\n  if (RHSTy->isSignedFixedPointType() && LHSTy->isUnsignedFixedPointType())\n    LHSTy = S.Context.getCorrespondingSignedFixedPointType(LHSTy);\n  else if (RHSTy->isUnsignedFixedPointType() && LHSTy->isSignedFixedPointType())\n    RHSTy = S.Context.getCorrespondingSignedFixedPointType(RHSTy);\n\n  // The result type is the type with the highest rank, whereby a fixed-point\n  // conversion rank is always greater than an integer conversion rank; if the\n  // type of either of the operands is a saturating fixedpoint type, the result\n  // type shall be the saturating fixed-point type corresponding to the type\n  // with the highest rank; the resulting value is converted (taking into\n  // account rounding and overflow) to the precision of the resulting type.\n  // Same ranks between signed and unsigned types are resolved earlier, so both\n  // types are either signed or both unsigned at this point.\n  unsigned LHSTyRank = GetFixedPointRank(LHSTy);\n  unsigned RHSTyRank = GetFixedPointRank(RHSTy);\n\n  QualType ResultTy = LHSTyRank > RHSTyRank ? LHSTy : RHSTy;\n\n  if (LHSTy->isSaturatedFixedPointType() || RHSTy->isSaturatedFixedPointType())\n    ResultTy = S.Context.getCorrespondingSaturatedType(ResultTy);\n\n  return ResultTy;\n}\n\n/// Check that the usual arithmetic conversions can be performed on this pair of\n/// expressions that might be of enumeration type.\nstatic void checkEnumArithmeticConversions(Sema &S, Expr *LHS, Expr *RHS,\n                                           SourceLocation Loc,\n                                           Sema::ArithConvKind ACK) {\n  // C++2a [expr.arith.conv]p1:\n  //   If one operand is of enumeration type and the other operand is of a\n  //   different enumeration type or a floating-point type, this behavior is\n  //   deprecated ([depr.arith.conv.enum]).\n  //\n  // Warn on this in all language modes. Produce a deprecation warning in C++20.\n  // Eventually we will presumably reject these cases (in C++23 onwards?).\n  QualType L = LHS->getType(), R = RHS->getType();\n  bool LEnum = L->isUnscopedEnumerationType(),\n       REnum = R->isUnscopedEnumerationType();\n  bool IsCompAssign = ACK == Sema::ACK_CompAssign;\n  if ((!IsCompAssign && LEnum && R->isFloatingType()) ||\n      (REnum && L->isFloatingType())) {\n    S.Diag(Loc, S.getLangOpts().CPlusPlus20\n                    ? diag::warn_arith_conv_enum_float_cxx20\n                    : diag::warn_arith_conv_enum_float)\n        << LHS->getSourceRange() << RHS->getSourceRange()\n        << (int)ACK << LEnum << L << R;\n  } else if (!IsCompAssign && LEnum && REnum &&\n             !S.Context.hasSameUnqualifiedType(L, R)) {\n    unsigned DiagID;\n    if (!L->castAs<EnumType>()->getDecl()->hasNameForLinkage() ||\n        !R->castAs<EnumType>()->getDecl()->hasNameForLinkage()) {\n      // If either enumeration type is unnamed, it's less likely that the\n      // user cares about this, but this situation is still deprecated in\n      // C++2a. Use a different warning group.\n      DiagID = S.getLangOpts().CPlusPlus20\n                    ? diag::warn_arith_conv_mixed_anon_enum_types_cxx20\n                    : diag::warn_arith_conv_mixed_anon_enum_types;\n    } else if (ACK == Sema::ACK_Conditional) {\n      // Conditional expressions are separated out because they have\n      // historically had a different warning flag.\n      DiagID = S.getLangOpts().CPlusPlus20\n                   ? diag::warn_conditional_mixed_enum_types_cxx20\n                   : diag::warn_conditional_mixed_enum_types;\n    } else if (ACK == Sema::ACK_Comparison) {\n      // Comparison expressions are separated out because they have\n      // historically had a different warning flag.\n      DiagID = S.getLangOpts().CPlusPlus20\n                   ? diag::warn_comparison_mixed_enum_types_cxx20\n                   : diag::warn_comparison_mixed_enum_types;\n    } else {\n      DiagID = S.getLangOpts().CPlusPlus20\n                   ? diag::warn_arith_conv_mixed_enum_types_cxx20\n                   : diag::warn_arith_conv_mixed_enum_types;\n    }\n    S.Diag(Loc, DiagID) << LHS->getSourceRange() << RHS->getSourceRange()\n                        << (int)ACK << L << R;\n  }\n}\n\n/// UsualArithmeticConversions - Performs various conversions that are common to\n/// binary operators (C99 6.3.1.8). If both operands aren't arithmetic, this\n/// routine returns the first non-arithmetic type found. The client is\n/// responsible for emitting appropriate error diagnostics.\nQualType Sema::UsualArithmeticConversions(ExprResult &LHS, ExprResult &RHS,\n                                          SourceLocation Loc,\n                                          ArithConvKind ACK) {\n  checkEnumArithmeticConversions(*this, LHS.get(), RHS.get(), Loc, ACK);\n\n  if (ACK != ACK_CompAssign) {\n    LHS = UsualUnaryConversions(LHS.get());\n    if (LHS.isInvalid())\n      return QualType();\n  }\n\n  RHS = UsualUnaryConversions(RHS.get());\n  if (RHS.isInvalid())\n    return QualType();\n\n  // For conversion purposes, we ignore any qualifiers.\n  // For example, \"const float\" and \"float\" are equivalent.\n  QualType LHSType =\n    Context.getCanonicalType(LHS.get()->getType()).getUnqualifiedType();\n  QualType RHSType =\n    Context.getCanonicalType(RHS.get()->getType()).getUnqualifiedType();\n\n  // For conversion purposes, we ignore any atomic qualifier on the LHS.\n  if (const AtomicType *AtomicLHS = LHSType->getAs<AtomicType>())\n    LHSType = AtomicLHS->getValueType();\n\n  // If both types are identical, no conversion is needed.\n  if (LHSType == RHSType)\n    return LHSType;\n\n  // If either side is a non-arithmetic type (e.g. a pointer), we are done.\n  // The caller can deal with this (e.g. pointer + int).\n  if (!LHSType->isArithmeticType() || !RHSType->isArithmeticType())\n    return QualType();\n\n  // Apply unary and bitfield promotions to the LHS's type.\n  QualType LHSUnpromotedType = LHSType;\n  if (LHSType->isPromotableIntegerType())\n    LHSType = Context.getPromotedIntegerType(LHSType);\n  QualType LHSBitfieldPromoteTy = Context.isPromotableBitField(LHS.get());\n  if (!LHSBitfieldPromoteTy.isNull())\n    LHSType = LHSBitfieldPromoteTy;\n  if (LHSType != LHSUnpromotedType && ACK != ACK_CompAssign)\n    LHS = ImpCastExprToType(LHS.get(), LHSType, CK_IntegralCast);\n\n  // If both types are identical, no conversion is needed.\n  if (LHSType == RHSType)\n    return LHSType;\n\n  // ExtInt types aren't subject to conversions between them or normal integers,\n  // so this fails.\n  if(LHSType->isExtIntType() || RHSType->isExtIntType())\n    return QualType();\n\n  // At this point, we have two different arithmetic types.\n\n  // Diagnose attempts to convert between __float128 and long double where\n  // such conversions currently can't be handled.\n  if (unsupportedTypeConversion(*this, LHSType, RHSType))\n    return QualType();\n\n  // Handle complex types first (C99 6.3.1.8p1).\n  if (LHSType->isComplexType() || RHSType->isComplexType())\n    return handleComplexFloatConversion(*this, LHS, RHS, LHSType, RHSType,\n                                        ACK == ACK_CompAssign);\n\n  // Now handle \"real\" floating types (i.e. float, double, long double).\n  if (LHSType->isRealFloatingType() || RHSType->isRealFloatingType())\n    return handleFloatConversion(*this, LHS, RHS, LHSType, RHSType,\n                                 ACK == ACK_CompAssign);\n\n  // Handle GCC complex int extension.\n  if (LHSType->isComplexIntegerType() || RHSType->isComplexIntegerType())\n    return handleComplexIntConversion(*this, LHS, RHS, LHSType, RHSType,\n                                      ACK == ACK_CompAssign);\n\n  if (LHSType->isFixedPointType() || RHSType->isFixedPointType())\n    return handleFixedPointConversion(*this, LHSType, RHSType);\n\n  // Finally, we have two differing integer types.\n  return handleIntegerConversion<doIntegralCast, doIntegralCast>\n           (*this, LHS, RHS, LHSType, RHSType, ACK == ACK_CompAssign);\n}\n\n//===----------------------------------------------------------------------===//\n//  Semantic Analysis for various Expression Types\n//===----------------------------------------------------------------------===//\n\n\nExprResult\nSema::ActOnGenericSelectionExpr(SourceLocation KeyLoc,\n                                SourceLocation DefaultLoc,\n                                SourceLocation RParenLoc,\n                                Expr *ControllingExpr,\n                                ArrayRef<ParsedType> ArgTypes,\n                                ArrayRef<Expr *> ArgExprs) {\n  unsigned NumAssocs = ArgTypes.size();\n  assert(NumAssocs == ArgExprs.size());\n\n  TypeSourceInfo **Types = new TypeSourceInfo*[NumAssocs];\n  for (unsigned i = 0; i < NumAssocs; ++i) {\n    if (ArgTypes[i])\n      (void) GetTypeFromParser(ArgTypes[i], &Types[i]);\n    else\n      Types[i] = nullptr;\n  }\n\n  ExprResult ER = CreateGenericSelectionExpr(KeyLoc, DefaultLoc, RParenLoc,\n                                             ControllingExpr,\n                                             llvm::makeArrayRef(Types, NumAssocs),\n                                             ArgExprs);\n  delete [] Types;\n  return ER;\n}\n\nExprResult\nSema::CreateGenericSelectionExpr(SourceLocation KeyLoc,\n                                 SourceLocation DefaultLoc,\n                                 SourceLocation RParenLoc,\n                                 Expr *ControllingExpr,\n                                 ArrayRef<TypeSourceInfo *> Types,\n                                 ArrayRef<Expr *> Exprs) {\n  unsigned NumAssocs = Types.size();\n  assert(NumAssocs == Exprs.size());\n\n  // Decay and strip qualifiers for the controlling expression type, and handle\n  // placeholder type replacement. See committee discussion from WG14 DR423.\n  {\n    EnterExpressionEvaluationContext Unevaluated(\n        *this, Sema::ExpressionEvaluationContext::Unevaluated);\n    ExprResult R = DefaultFunctionArrayLvalueConversion(ControllingExpr);\n    if (R.isInvalid())\n      return ExprError();\n    ControllingExpr = R.get();\n  }\n\n  // The controlling expression is an unevaluated operand, so side effects are\n  // likely unintended.\n  if (!inTemplateInstantiation() &&\n      ControllingExpr->HasSideEffects(Context, false))\n    Diag(ControllingExpr->getExprLoc(),\n         diag::warn_side_effects_unevaluated_context);\n\n  bool TypeErrorFound = false,\n       IsResultDependent = ControllingExpr->isTypeDependent(),\n       ContainsUnexpandedParameterPack\n         = ControllingExpr->containsUnexpandedParameterPack();\n\n  for (unsigned i = 0; i < NumAssocs; ++i) {\n    if (Exprs[i]->containsUnexpandedParameterPack())\n      ContainsUnexpandedParameterPack = true;\n\n    if (Types[i]) {\n      if (Types[i]->getType()->containsUnexpandedParameterPack())\n        ContainsUnexpandedParameterPack = true;\n\n      if (Types[i]->getType()->isDependentType()) {\n        IsResultDependent = true;\n      } else {\n        // C11 6.5.1.1p2 \"The type name in a generic association shall specify a\n        // complete object type other than a variably modified type.\"\n        unsigned D = 0;\n        if (Types[i]->getType()->isIncompleteType())\n          D = diag::err_assoc_type_incomplete;\n        else if (!Types[i]->getType()->isObjectType())\n          D = diag::err_assoc_type_nonobject;\n        else if (Types[i]->getType()->isVariablyModifiedType())\n          D = diag::err_assoc_type_variably_modified;\n\n        if (D != 0) {\n          Diag(Types[i]->getTypeLoc().getBeginLoc(), D)\n            << Types[i]->getTypeLoc().getSourceRange()\n            << Types[i]->getType();\n          TypeErrorFound = true;\n        }\n\n        // C11 6.5.1.1p2 \"No two generic associations in the same generic\n        // selection shall specify compatible types.\"\n        for (unsigned j = i+1; j < NumAssocs; ++j)\n          if (Types[j] && !Types[j]->getType()->isDependentType() &&\n              Context.typesAreCompatible(Types[i]->getType(),\n                                         Types[j]->getType())) {\n            Diag(Types[j]->getTypeLoc().getBeginLoc(),\n                 diag::err_assoc_compatible_types)\n              << Types[j]->getTypeLoc().getSourceRange()\n              << Types[j]->getType()\n              << Types[i]->getType();\n            Diag(Types[i]->getTypeLoc().getBeginLoc(),\n                 diag::note_compat_assoc)\n              << Types[i]->getTypeLoc().getSourceRange()\n              << Types[i]->getType();\n            TypeErrorFound = true;\n          }\n      }\n    }\n  }\n  if (TypeErrorFound)\n    return ExprError();\n\n  // If we determined that the generic selection is result-dependent, don't\n  // try to compute the result expression.\n  if (IsResultDependent)\n    return GenericSelectionExpr::Create(Context, KeyLoc, ControllingExpr, Types,\n                                        Exprs, DefaultLoc, RParenLoc,\n                                        ContainsUnexpandedParameterPack);\n\n  SmallVector<unsigned, 1> CompatIndices;\n  unsigned DefaultIndex = -1U;\n  for (unsigned i = 0; i < NumAssocs; ++i) {\n    if (!Types[i])\n      DefaultIndex = i;\n    else if (Context.typesAreCompatible(ControllingExpr->getType(),\n                                        Types[i]->getType()))\n      CompatIndices.push_back(i);\n  }\n\n  // C11 6.5.1.1p2 \"The controlling expression of a generic selection shall have\n  // type compatible with at most one of the types named in its generic\n  // association list.\"\n  if (CompatIndices.size() > 1) {\n    // We strip parens here because the controlling expression is typically\n    // parenthesized in macro definitions.\n    ControllingExpr = ControllingExpr->IgnoreParens();\n    Diag(ControllingExpr->getBeginLoc(), diag::err_generic_sel_multi_match)\n        << ControllingExpr->getSourceRange() << ControllingExpr->getType()\n        << (unsigned)CompatIndices.size();\n    for (unsigned I : CompatIndices) {\n      Diag(Types[I]->getTypeLoc().getBeginLoc(),\n           diag::note_compat_assoc)\n        << Types[I]->getTypeLoc().getSourceRange()\n        << Types[I]->getType();\n    }\n    return ExprError();\n  }\n\n  // C11 6.5.1.1p2 \"If a generic selection has no default generic association,\n  // its controlling expression shall have type compatible with exactly one of\n  // the types named in its generic association list.\"\n  if (DefaultIndex == -1U && CompatIndices.size() == 0) {\n    // We strip parens here because the controlling expression is typically\n    // parenthesized in macro definitions.\n    ControllingExpr = ControllingExpr->IgnoreParens();\n    Diag(ControllingExpr->getBeginLoc(), diag::err_generic_sel_no_match)\n        << ControllingExpr->getSourceRange() << ControllingExpr->getType();\n    return ExprError();\n  }\n\n  // C11 6.5.1.1p3 \"If a generic selection has a generic association with a\n  // type name that is compatible with the type of the controlling expression,\n  // then the result expression of the generic selection is the expression\n  // in that generic association. Otherwise, the result expression of the\n  // generic selection is the expression in the default generic association.\"\n  unsigned ResultIndex =\n    CompatIndices.size() ? CompatIndices[0] : DefaultIndex;\n\n  return GenericSelectionExpr::Create(\n      Context, KeyLoc, ControllingExpr, Types, Exprs, DefaultLoc, RParenLoc,\n      ContainsUnexpandedParameterPack, ResultIndex);\n}\n\n/// getUDSuffixLoc - Create a SourceLocation for a ud-suffix, given the\n/// location of the token and the offset of the ud-suffix within it.\nstatic SourceLocation getUDSuffixLoc(Sema &S, SourceLocation TokLoc,\n                                     unsigned Offset) {\n  return Lexer::AdvanceToTokenCharacter(TokLoc, Offset, S.getSourceManager(),\n                                        S.getLangOpts());\n}\n\n/// BuildCookedLiteralOperatorCall - A user-defined literal was found. Look up\n/// the corresponding cooked (non-raw) literal operator, and build a call to it.\nstatic ExprResult BuildCookedLiteralOperatorCall(Sema &S, Scope *Scope,\n                                                 IdentifierInfo *UDSuffix,\n                                                 SourceLocation UDSuffixLoc,\n                                                 ArrayRef<Expr*> Args,\n                                                 SourceLocation LitEndLoc) {\n  assert(Args.size() <= 2 && \"too many arguments for literal operator\");\n\n  QualType ArgTy[2];\n  for (unsigned ArgIdx = 0; ArgIdx != Args.size(); ++ArgIdx) {\n    ArgTy[ArgIdx] = Args[ArgIdx]->getType();\n    if (ArgTy[ArgIdx]->isArrayType())\n      ArgTy[ArgIdx] = S.Context.getArrayDecayedType(ArgTy[ArgIdx]);\n  }\n\n  DeclarationName OpName =\n    S.Context.DeclarationNames.getCXXLiteralOperatorName(UDSuffix);\n  DeclarationNameInfo OpNameInfo(OpName, UDSuffixLoc);\n  OpNameInfo.setCXXLiteralOperatorNameLoc(UDSuffixLoc);\n\n  LookupResult R(S, OpName, UDSuffixLoc, Sema::LookupOrdinaryName);\n  if (S.LookupLiteralOperator(Scope, R, llvm::makeArrayRef(ArgTy, Args.size()),\n                              /*AllowRaw*/ false, /*AllowTemplate*/ false,\n                              /*AllowStringTemplatePack*/ false,\n                              /*DiagnoseMissing*/ true) == Sema::LOLR_Error)\n    return ExprError();\n\n  return S.BuildLiteralOperatorCall(R, OpNameInfo, Args, LitEndLoc);\n}\n\n/// ActOnStringLiteral - The specified tokens were lexed as pasted string\n/// fragments (e.g. \"foo\" \"bar\" L\"baz\").  The result string has to handle string\n/// concatenation ([C99 5.1.1.2, translation phase #6]), so it may come from\n/// multiple tokens.  However, the common case is that StringToks points to one\n/// string.\n///\nExprResult\nSema::ActOnStringLiteral(ArrayRef<Token> StringToks, Scope *UDLScope) {\n  assert(!StringToks.empty() && \"Must have at least one string!\");\n\n  StringLiteralParser Literal(StringToks, PP);\n  if (Literal.hadError)\n    return ExprError();\n\n  SmallVector<SourceLocation, 4> StringTokLocs;\n  for (const Token &Tok : StringToks)\n    StringTokLocs.push_back(Tok.getLocation());\n\n  QualType CharTy = Context.CharTy;\n  StringLiteral::StringKind Kind = StringLiteral::Ascii;\n  if (Literal.isWide()) {\n    CharTy = Context.getWideCharType();\n    Kind = StringLiteral::Wide;\n  } else if (Literal.isUTF8()) {\n    if (getLangOpts().Char8)\n      CharTy = Context.Char8Ty;\n    Kind = StringLiteral::UTF8;\n  } else if (Literal.isUTF16()) {\n    CharTy = Context.Char16Ty;\n    Kind = StringLiteral::UTF16;\n  } else if (Literal.isUTF32()) {\n    CharTy = Context.Char32Ty;\n    Kind = StringLiteral::UTF32;\n  } else if (Literal.isPascal()) {\n    CharTy = Context.UnsignedCharTy;\n  }\n\n  // Warn on initializing an array of char from a u8 string literal; this\n  // becomes ill-formed in C++2a.\n  if (getLangOpts().CPlusPlus && !getLangOpts().CPlusPlus20 &&\n      !getLangOpts().Char8 && Kind == StringLiteral::UTF8) {\n    Diag(StringTokLocs.front(), diag::warn_cxx20_compat_utf8_string);\n\n    // Create removals for all 'u8' prefixes in the string literal(s). This\n    // ensures C++2a compatibility (but may change the program behavior when\n    // built by non-Clang compilers for which the execution character set is\n    // not always UTF-8).\n    auto RemovalDiag = PDiag(diag::note_cxx20_compat_utf8_string_remove_u8);\n    SourceLocation RemovalDiagLoc;\n    for (const Token &Tok : StringToks) {\n      if (Tok.getKind() == tok::utf8_string_literal) {\n        if (RemovalDiagLoc.isInvalid())\n          RemovalDiagLoc = Tok.getLocation();\n        RemovalDiag << FixItHint::CreateRemoval(CharSourceRange::getCharRange(\n            Tok.getLocation(),\n            Lexer::AdvanceToTokenCharacter(Tok.getLocation(), 2,\n                                           getSourceManager(), getLangOpts())));\n      }\n    }\n    Diag(RemovalDiagLoc, RemovalDiag);\n  }\n\n  QualType StrTy =\n      Context.getStringLiteralArrayType(CharTy, Literal.GetNumStringChars());\n\n  // Pass &StringTokLocs[0], StringTokLocs.size() to factory!\n  StringLiteral *Lit = StringLiteral::Create(Context, Literal.GetString(),\n                                             Kind, Literal.Pascal, StrTy,\n                                             &StringTokLocs[0],\n                                             StringTokLocs.size());\n  if (Literal.getUDSuffix().empty())\n    return Lit;\n\n  // We're building a user-defined literal.\n  IdentifierInfo *UDSuffix = &Context.Idents.get(Literal.getUDSuffix());\n  SourceLocation UDSuffixLoc =\n    getUDSuffixLoc(*this, StringTokLocs[Literal.getUDSuffixToken()],\n                   Literal.getUDSuffixOffset());\n\n  // Make sure we're allowed user-defined literals here.\n  if (!UDLScope)\n    return ExprError(Diag(UDSuffixLoc, diag::err_invalid_string_udl));\n\n  // C++11 [lex.ext]p5: The literal L is treated as a call of the form\n  //   operator \"\" X (str, len)\n  QualType SizeType = Context.getSizeType();\n\n  DeclarationName OpName =\n    Context.DeclarationNames.getCXXLiteralOperatorName(UDSuffix);\n  DeclarationNameInfo OpNameInfo(OpName, UDSuffixLoc);\n  OpNameInfo.setCXXLiteralOperatorNameLoc(UDSuffixLoc);\n\n  QualType ArgTy[] = {\n    Context.getArrayDecayedType(StrTy), SizeType\n  };\n\n  LookupResult R(*this, OpName, UDSuffixLoc, LookupOrdinaryName);\n  switch (LookupLiteralOperator(UDLScope, R, ArgTy,\n                                /*AllowRaw*/ false, /*AllowTemplate*/ true,\n                                /*AllowStringTemplatePack*/ true,\n                                /*DiagnoseMissing*/ true, Lit)) {\n\n  case LOLR_Cooked: {\n    llvm::APInt Len(Context.getIntWidth(SizeType), Literal.GetNumStringChars());\n    IntegerLiteral *LenArg = IntegerLiteral::Create(Context, Len, SizeType,\n                                                    StringTokLocs[0]);\n    Expr *Args[] = { Lit, LenArg };\n\n    return BuildLiteralOperatorCall(R, OpNameInfo, Args, StringTokLocs.back());\n  }\n\n  case LOLR_Template: {\n    TemplateArgumentListInfo ExplicitArgs;\n    TemplateArgument Arg(Lit);\n    TemplateArgumentLocInfo ArgInfo(Lit);\n    ExplicitArgs.addArgument(TemplateArgumentLoc(Arg, ArgInfo));\n    return BuildLiteralOperatorCall(R, OpNameInfo, None, StringTokLocs.back(),\n                                    &ExplicitArgs);\n  }\n\n  case LOLR_StringTemplatePack: {\n    TemplateArgumentListInfo ExplicitArgs;\n\n    unsigned CharBits = Context.getIntWidth(CharTy);\n    bool CharIsUnsigned = CharTy->isUnsignedIntegerType();\n    llvm::APSInt Value(CharBits, CharIsUnsigned);\n\n    TemplateArgument TypeArg(CharTy);\n    TemplateArgumentLocInfo TypeArgInfo(Context.getTrivialTypeSourceInfo(CharTy));\n    ExplicitArgs.addArgument(TemplateArgumentLoc(TypeArg, TypeArgInfo));\n\n    for (unsigned I = 0, N = Lit->getLength(); I != N; ++I) {\n      Value = Lit->getCodeUnit(I);\n      TemplateArgument Arg(Context, Value, CharTy);\n      TemplateArgumentLocInfo ArgInfo;\n      ExplicitArgs.addArgument(TemplateArgumentLoc(Arg, ArgInfo));\n    }\n    return BuildLiteralOperatorCall(R, OpNameInfo, None, StringTokLocs.back(),\n                                    &ExplicitArgs);\n  }\n  case LOLR_Raw:\n  case LOLR_ErrorNoDiagnostic:\n    llvm_unreachable(\"unexpected literal operator lookup result\");\n  case LOLR_Error:\n    return ExprError();\n  }\n  llvm_unreachable(\"unexpected literal operator lookup result\");\n}\n\nDeclRefExpr *\nSema::BuildDeclRefExpr(ValueDecl *D, QualType Ty, ExprValueKind VK,\n                       SourceLocation Loc,\n                       const CXXScopeSpec *SS) {\n  DeclarationNameInfo NameInfo(D->getDeclName(), Loc);\n  return BuildDeclRefExpr(D, Ty, VK, NameInfo, SS);\n}\n\nDeclRefExpr *\nSema::BuildDeclRefExpr(ValueDecl *D, QualType Ty, ExprValueKind VK,\n                       const DeclarationNameInfo &NameInfo,\n                       const CXXScopeSpec *SS, NamedDecl *FoundD,\n                       SourceLocation TemplateKWLoc,\n                       const TemplateArgumentListInfo *TemplateArgs) {\n  NestedNameSpecifierLoc NNS =\n      SS ? SS->getWithLocInContext(Context) : NestedNameSpecifierLoc();\n  return BuildDeclRefExpr(D, Ty, VK, NameInfo, NNS, FoundD, TemplateKWLoc,\n                          TemplateArgs);\n}\n\n// CUDA/HIP: Check whether a captured reference variable is referencing a\n// host variable in a device or host device lambda.\nstatic bool isCapturingReferenceToHostVarInCUDADeviceLambda(const Sema &S,\n                                                            VarDecl *VD) {\n  if (!S.getLangOpts().CUDA || !VD->hasInit())\n    return false;\n  assert(VD->getType()->isReferenceType());\n\n  // Check whether the reference variable is referencing a host variable.\n  auto *DRE = dyn_cast<DeclRefExpr>(VD->getInit());\n  if (!DRE)\n    return false;\n  auto *Referee = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!Referee || !Referee->hasGlobalStorage() ||\n      Referee->hasAttr<CUDADeviceAttr>())\n    return false;\n\n  // Check whether the current function is a device or host device lambda.\n  // Check whether the reference variable is a capture by getDeclContext()\n  // since refersToEnclosingVariableOrCapture() is not ready at this point.\n  auto *MD = dyn_cast_or_null<CXXMethodDecl>(S.CurContext);\n  if (MD && MD->getParent()->isLambda() &&\n      MD->getOverloadedOperator() == OO_Call && MD->hasAttr<CUDADeviceAttr>() &&\n      VD->getDeclContext() != MD)\n    return true;\n\n  return false;\n}\n\nNonOdrUseReason Sema::getNonOdrUseReasonInCurrentContext(ValueDecl *D) {\n  // A declaration named in an unevaluated operand never constitutes an odr-use.\n  if (isUnevaluatedContext())\n    return NOUR_Unevaluated;\n\n  // C++2a [basic.def.odr]p4:\n  //   A variable x whose name appears as a potentially-evaluated expression e\n  //   is odr-used by e unless [...] x is a reference that is usable in\n  //   constant expressions.\n  // CUDA/HIP:\n  //   If a reference variable referencing a host variable is captured in a\n  //   device or host device lambda, the value of the referee must be copied\n  //   to the capture and the reference variable must be treated as odr-use\n  //   since the value of the referee is not known at compile time and must\n  //   be loaded from the captured.\n  if (VarDecl *VD = dyn_cast<VarDecl>(D)) {\n    if (VD->getType()->isReferenceType() &&\n        !(getLangOpts().OpenMP && isOpenMPCapturedDecl(D)) &&\n        !isCapturingReferenceToHostVarInCUDADeviceLambda(*this, VD) &&\n        VD->isUsableInConstantExpressions(Context))\n      return NOUR_Constant;\n  }\n\n  // All remaining non-variable cases constitute an odr-use. For variables, we\n  // need to wait and see how the expression is used.\n  return NOUR_None;\n}\n\n/// BuildDeclRefExpr - Build an expression that references a\n/// declaration that does not require a closure capture.\nDeclRefExpr *\nSema::BuildDeclRefExpr(ValueDecl *D, QualType Ty, ExprValueKind VK,\n                       const DeclarationNameInfo &NameInfo,\n                       NestedNameSpecifierLoc NNS, NamedDecl *FoundD,\n                       SourceLocation TemplateKWLoc,\n                       const TemplateArgumentListInfo *TemplateArgs) {\n  bool RefersToCapturedVariable =\n      isa<VarDecl>(D) &&\n      NeedToCaptureVariable(cast<VarDecl>(D), NameInfo.getLoc());\n\n  DeclRefExpr *E = DeclRefExpr::Create(\n      Context, NNS, TemplateKWLoc, D, RefersToCapturedVariable, NameInfo, Ty,\n      VK, FoundD, TemplateArgs, getNonOdrUseReasonInCurrentContext(D));\n  MarkDeclRefReferenced(E);\n\n  // C++ [except.spec]p17:\n  //   An exception-specification is considered to be needed when:\n  //   - in an expression, the function is the unique lookup result or\n  //     the selected member of a set of overloaded functions.\n  //\n  // We delay doing this until after we've built the function reference and\n  // marked it as used so that:\n  //  a) if the function is defaulted, we get errors from defining it before /\n  //     instead of errors from computing its exception specification, and\n  //  b) if the function is a defaulted comparison, we can use the body we\n  //     build when defining it as input to the exception specification\n  //     computation rather than computing a new body.\n  if (auto *FPT = Ty->getAs<FunctionProtoType>()) {\n    if (isUnresolvedExceptionSpec(FPT->getExceptionSpecType())) {\n      if (auto *NewFPT = ResolveExceptionSpec(NameInfo.getLoc(), FPT))\n        E->setType(Context.getQualifiedType(NewFPT, Ty.getQualifiers()));\n    }\n  }\n\n  if (getLangOpts().ObjCWeak && isa<VarDecl>(D) &&\n      Ty.getObjCLifetime() == Qualifiers::OCL_Weak && !isUnevaluatedContext() &&\n      !Diags.isIgnored(diag::warn_arc_repeated_use_of_weak, E->getBeginLoc()))\n    getCurFunction()->recordUseOfWeak(E);\n\n  FieldDecl *FD = dyn_cast<FieldDecl>(D);\n  if (IndirectFieldDecl *IFD = dyn_cast<IndirectFieldDecl>(D))\n    FD = IFD->getAnonField();\n  if (FD) {\n    UnusedPrivateFields.remove(FD);\n    // Just in case we're building an illegal pointer-to-member.\n    if (FD->isBitField())\n      E->setObjectKind(OK_BitField);\n  }\n\n  // C++ [expr.prim]/8: The expression [...] is a bit-field if the identifier\n  // designates a bit-field.\n  if (auto *BD = dyn_cast<BindingDecl>(D))\n    if (auto *BE = BD->getBinding())\n      E->setObjectKind(BE->getObjectKind());\n\n  return E;\n}\n\n/// Decomposes the given name into a DeclarationNameInfo, its location, and\n/// possibly a list of template arguments.\n///\n/// If this produces template arguments, it is permitted to call\n/// DecomposeTemplateName.\n///\n/// This actually loses a lot of source location information for\n/// non-standard name kinds; we should consider preserving that in\n/// some way.\nvoid\nSema::DecomposeUnqualifiedId(const UnqualifiedId &Id,\n                             TemplateArgumentListInfo &Buffer,\n                             DeclarationNameInfo &NameInfo,\n                             const TemplateArgumentListInfo *&TemplateArgs) {\n  if (Id.getKind() == UnqualifiedIdKind::IK_TemplateId) {\n    Buffer.setLAngleLoc(Id.TemplateId->LAngleLoc);\n    Buffer.setRAngleLoc(Id.TemplateId->RAngleLoc);\n\n    ASTTemplateArgsPtr TemplateArgsPtr(Id.TemplateId->getTemplateArgs(),\n                                       Id.TemplateId->NumArgs);\n    translateTemplateArguments(TemplateArgsPtr, Buffer);\n\n    TemplateName TName = Id.TemplateId->Template.get();\n    SourceLocation TNameLoc = Id.TemplateId->TemplateNameLoc;\n    NameInfo = Context.getNameForTemplate(TName, TNameLoc);\n    TemplateArgs = &Buffer;\n  } else {\n    NameInfo = GetNameFromUnqualifiedId(Id);\n    TemplateArgs = nullptr;\n  }\n}\n\nstatic void emitEmptyLookupTypoDiagnostic(\n    const TypoCorrection &TC, Sema &SemaRef, const CXXScopeSpec &SS,\n    DeclarationName Typo, SourceLocation TypoLoc, ArrayRef<Expr *> Args,\n    unsigned DiagnosticID, unsigned DiagnosticSuggestID) {\n  DeclContext *Ctx =\n      SS.isEmpty() ? nullptr : SemaRef.computeDeclContext(SS, false);\n  if (!TC) {\n    // Emit a special diagnostic for failed member lookups.\n    // FIXME: computing the declaration context might fail here (?)\n    if (Ctx)\n      SemaRef.Diag(TypoLoc, diag::err_no_member) << Typo << Ctx\n                                                 << SS.getRange();\n    else\n      SemaRef.Diag(TypoLoc, DiagnosticID) << Typo;\n    return;\n  }\n\n  std::string CorrectedStr = TC.getAsString(SemaRef.getLangOpts());\n  bool DroppedSpecifier =\n      TC.WillReplaceSpecifier() && Typo.getAsString() == CorrectedStr;\n  unsigned NoteID = TC.getCorrectionDeclAs<ImplicitParamDecl>()\n                        ? diag::note_implicit_param_decl\n                        : diag::note_previous_decl;\n  if (!Ctx)\n    SemaRef.diagnoseTypo(TC, SemaRef.PDiag(DiagnosticSuggestID) << Typo,\n                         SemaRef.PDiag(NoteID));\n  else\n    SemaRef.diagnoseTypo(TC, SemaRef.PDiag(diag::err_no_member_suggest)\n                                 << Typo << Ctx << DroppedSpecifier\n                                 << SS.getRange(),\n                         SemaRef.PDiag(NoteID));\n}\n\n/// Diagnose a lookup that found results in an enclosing class during error\n/// recovery. This usually indicates that the results were found in a dependent\n/// base class that could not be searched as part of a template definition.\n/// Always issues a diagnostic (though this may be only a warning in MS\n/// compatibility mode).\n///\n/// Return \\c true if the error is unrecoverable, or \\c false if the caller\n/// should attempt to recover using these lookup results.\nbool Sema::DiagnoseDependentMemberLookup(LookupResult &R) {\n  // During a default argument instantiation the CurContext points\n  // to a CXXMethodDecl; but we can't apply a this-> fixit inside a\n  // function parameter list, hence add an explicit check.\n  bool isDefaultArgument =\n      !CodeSynthesisContexts.empty() &&\n      CodeSynthesisContexts.back().Kind ==\n          CodeSynthesisContext::DefaultFunctionArgumentInstantiation;\n  CXXMethodDecl *CurMethod = dyn_cast<CXXMethodDecl>(CurContext);\n  bool isInstance = CurMethod && CurMethod->isInstance() &&\n                    R.getNamingClass() == CurMethod->getParent() &&\n                    !isDefaultArgument;\n\n  // There are two ways we can find a class-scope declaration during template\n  // instantiation that we did not find in the template definition: if it is a\n  // member of a dependent base class, or if it is declared after the point of\n  // use in the same class. Distinguish these by comparing the class in which\n  // the member was found to the naming class of the lookup.\n  unsigned DiagID = diag::err_found_in_dependent_base;\n  unsigned NoteID = diag::note_member_declared_at;\n  if (R.getRepresentativeDecl()->getDeclContext()->Equals(R.getNamingClass())) {\n    DiagID = getLangOpts().MSVCCompat ? diag::ext_found_later_in_class\n                                      : diag::err_found_later_in_class;\n  } else if (getLangOpts().MSVCCompat) {\n    DiagID = diag::ext_found_in_dependent_base;\n    NoteID = diag::note_dependent_member_use;\n  }\n\n  if (isInstance) {\n    // Give a code modification hint to insert 'this->'.\n    Diag(R.getNameLoc(), DiagID)\n        << R.getLookupName()\n        << FixItHint::CreateInsertion(R.getNameLoc(), \"this->\");\n    CheckCXXThisCapture(R.getNameLoc());\n  } else {\n    // FIXME: Add a FixItHint to insert 'Base::' or 'Derived::' (assuming\n    // they're not shadowed).\n    Diag(R.getNameLoc(), DiagID) << R.getLookupName();\n  }\n\n  for (NamedDecl *D : R)\n    Diag(D->getLocation(), NoteID);\n\n  // Return true if we are inside a default argument instantiation\n  // and the found name refers to an instance member function, otherwise\n  // the caller will try to create an implicit member call and this is wrong\n  // for default arguments.\n  //\n  // FIXME: Is this special case necessary? We could allow the caller to\n  // diagnose this.\n  if (isDefaultArgument && ((*R.begin())->isCXXInstanceMember())) {\n    Diag(R.getNameLoc(), diag::err_member_call_without_object);\n    return true;\n  }\n\n  // Tell the callee to try to recover.\n  return false;\n}\n\n/// Diagnose an empty lookup.\n///\n/// \\return false if new lookup candidates were found\nbool Sema::DiagnoseEmptyLookup(Scope *S, CXXScopeSpec &SS, LookupResult &R,\n                               CorrectionCandidateCallback &CCC,\n                               TemplateArgumentListInfo *ExplicitTemplateArgs,\n                               ArrayRef<Expr *> Args, TypoExpr **Out) {\n  DeclarationName Name = R.getLookupName();\n\n  unsigned diagnostic = diag::err_undeclared_var_use;\n  unsigned diagnostic_suggest = diag::err_undeclared_var_use_suggest;\n  if (Name.getNameKind() == DeclarationName::CXXOperatorName ||\n      Name.getNameKind() == DeclarationName::CXXLiteralOperatorName ||\n      Name.getNameKind() == DeclarationName::CXXConversionFunctionName) {\n    diagnostic = diag::err_undeclared_use;\n    diagnostic_suggest = diag::err_undeclared_use_suggest;\n  }\n\n  // If the original lookup was an unqualified lookup, fake an\n  // unqualified lookup.  This is useful when (for example) the\n  // original lookup would not have found something because it was a\n  // dependent name.\n  DeclContext *DC = SS.isEmpty() ? CurContext : nullptr;\n  while (DC) {\n    if (isa<CXXRecordDecl>(DC)) {\n      LookupQualifiedName(R, DC);\n\n      if (!R.empty()) {\n        // Don't give errors about ambiguities in this lookup.\n        R.suppressDiagnostics();\n\n        // If there's a best viable function among the results, only mention\n        // that one in the notes.\n        OverloadCandidateSet Candidates(R.getNameLoc(),\n                                        OverloadCandidateSet::CSK_Normal);\n        AddOverloadedCallCandidates(R, ExplicitTemplateArgs, Args, Candidates);\n        OverloadCandidateSet::iterator Best;\n        if (Candidates.BestViableFunction(*this, R.getNameLoc(), Best) ==\n            OR_Success) {\n          R.clear();\n          R.addDecl(Best->FoundDecl.getDecl(), Best->FoundDecl.getAccess());\n          R.resolveKind();\n        }\n\n        return DiagnoseDependentMemberLookup(R);\n      }\n\n      R.clear();\n    }\n\n    DC = DC->getLookupParent();\n  }\n\n  // We didn't find anything, so try to correct for a typo.\n  TypoCorrection Corrected;\n  if (S && Out) {\n    SourceLocation TypoLoc = R.getNameLoc();\n    assert(!ExplicitTemplateArgs &&\n           \"Diagnosing an empty lookup with explicit template args!\");\n    *Out = CorrectTypoDelayed(\n        R.getLookupNameInfo(), R.getLookupKind(), S, &SS, CCC,\n        [=](const TypoCorrection &TC) {\n          emitEmptyLookupTypoDiagnostic(TC, *this, SS, Name, TypoLoc, Args,\n                                        diagnostic, diagnostic_suggest);\n        },\n        nullptr, CTK_ErrorRecovery);\n    if (*Out)\n      return true;\n  } else if (S &&\n             (Corrected = CorrectTypo(R.getLookupNameInfo(), R.getLookupKind(),\n                                      S, &SS, CCC, CTK_ErrorRecovery))) {\n    std::string CorrectedStr(Corrected.getAsString(getLangOpts()));\n    bool DroppedSpecifier =\n        Corrected.WillReplaceSpecifier() && Name.getAsString() == CorrectedStr;\n    R.setLookupName(Corrected.getCorrection());\n\n    bool AcceptableWithRecovery = false;\n    bool AcceptableWithoutRecovery = false;\n    NamedDecl *ND = Corrected.getFoundDecl();\n    if (ND) {\n      if (Corrected.isOverloaded()) {\n        OverloadCandidateSet OCS(R.getNameLoc(),\n                                 OverloadCandidateSet::CSK_Normal);\n        OverloadCandidateSet::iterator Best;\n        for (NamedDecl *CD : Corrected) {\n          if (FunctionTemplateDecl *FTD =\n                   dyn_cast<FunctionTemplateDecl>(CD))\n            AddTemplateOverloadCandidate(\n                FTD, DeclAccessPair::make(FTD, AS_none), ExplicitTemplateArgs,\n                Args, OCS);\n          else if (FunctionDecl *FD = dyn_cast<FunctionDecl>(CD))\n            if (!ExplicitTemplateArgs || ExplicitTemplateArgs->size() == 0)\n              AddOverloadCandidate(FD, DeclAccessPair::make(FD, AS_none),\n                                   Args, OCS);\n        }\n        switch (OCS.BestViableFunction(*this, R.getNameLoc(), Best)) {\n        case OR_Success:\n          ND = Best->FoundDecl;\n          Corrected.setCorrectionDecl(ND);\n          break;\n        default:\n          // FIXME: Arbitrarily pick the first declaration for the note.\n          Corrected.setCorrectionDecl(ND);\n          break;\n        }\n      }\n      R.addDecl(ND);\n      if (getLangOpts().CPlusPlus && ND->isCXXClassMember()) {\n        CXXRecordDecl *Record = nullptr;\n        if (Corrected.getCorrectionSpecifier()) {\n          const Type *Ty = Corrected.getCorrectionSpecifier()->getAsType();\n          Record = Ty->getAsCXXRecordDecl();\n        }\n        if (!Record)\n          Record = cast<CXXRecordDecl>(\n              ND->getDeclContext()->getRedeclContext());\n        R.setNamingClass(Record);\n      }\n\n      auto *UnderlyingND = ND->getUnderlyingDecl();\n      AcceptableWithRecovery = isa<ValueDecl>(UnderlyingND) ||\n                               isa<FunctionTemplateDecl>(UnderlyingND);\n      // FIXME: If we ended up with a typo for a type name or\n      // Objective-C class name, we're in trouble because the parser\n      // is in the wrong place to recover. Suggest the typo\n      // correction, but don't make it a fix-it since we're not going\n      // to recover well anyway.\n      AcceptableWithoutRecovery = isa<TypeDecl>(UnderlyingND) ||\n                                  getAsTypeTemplateDecl(UnderlyingND) ||\n                                  isa<ObjCInterfaceDecl>(UnderlyingND);\n    } else {\n      // FIXME: We found a keyword. Suggest it, but don't provide a fix-it\n      // because we aren't able to recover.\n      AcceptableWithoutRecovery = true;\n    }\n\n    if (AcceptableWithRecovery || AcceptableWithoutRecovery) {\n      unsigned NoteID = Corrected.getCorrectionDeclAs<ImplicitParamDecl>()\n                            ? diag::note_implicit_param_decl\n                            : diag::note_previous_decl;\n      if (SS.isEmpty())\n        diagnoseTypo(Corrected, PDiag(diagnostic_suggest) << Name,\n                     PDiag(NoteID), AcceptableWithRecovery);\n      else\n        diagnoseTypo(Corrected, PDiag(diag::err_no_member_suggest)\n                                  << Name << computeDeclContext(SS, false)\n                                  << DroppedSpecifier << SS.getRange(),\n                     PDiag(NoteID), AcceptableWithRecovery);\n\n      // Tell the callee whether to try to recover.\n      return !AcceptableWithRecovery;\n    }\n  }\n  R.clear();\n\n  // Emit a special diagnostic for failed member lookups.\n  // FIXME: computing the declaration context might fail here (?)\n  if (!SS.isEmpty()) {\n    Diag(R.getNameLoc(), diag::err_no_member)\n      << Name << computeDeclContext(SS, false)\n      << SS.getRange();\n    return true;\n  }\n\n  // Give up, we can't recover.\n  Diag(R.getNameLoc(), diagnostic) << Name;\n  return true;\n}\n\n/// In Microsoft mode, if we are inside a template class whose parent class has\n/// dependent base classes, and we can't resolve an unqualified identifier, then\n/// assume the identifier is a member of a dependent base class.  We can only\n/// recover successfully in static methods, instance methods, and other contexts\n/// where 'this' is available.  This doesn't precisely match MSVC's\n/// instantiation model, but it's close enough.\nstatic Expr *\nrecoverFromMSUnqualifiedLookup(Sema &S, ASTContext &Context,\n                               DeclarationNameInfo &NameInfo,\n                               SourceLocation TemplateKWLoc,\n                               const TemplateArgumentListInfo *TemplateArgs) {\n  // Only try to recover from lookup into dependent bases in static methods or\n  // contexts where 'this' is available.\n  QualType ThisType = S.getCurrentThisType();\n  const CXXRecordDecl *RD = nullptr;\n  if (!ThisType.isNull())\n    RD = ThisType->getPointeeType()->getAsCXXRecordDecl();\n  else if (auto *MD = dyn_cast<CXXMethodDecl>(S.CurContext))\n    RD = MD->getParent();\n  if (!RD || !RD->hasAnyDependentBases())\n    return nullptr;\n\n  // Diagnose this as unqualified lookup into a dependent base class.  If 'this'\n  // is available, suggest inserting 'this->' as a fixit.\n  SourceLocation Loc = NameInfo.getLoc();\n  auto DB = S.Diag(Loc, diag::ext_undeclared_unqual_id_with_dependent_base);\n  DB << NameInfo.getName() << RD;\n\n  if (!ThisType.isNull()) {\n    DB << FixItHint::CreateInsertion(Loc, \"this->\");\n    return CXXDependentScopeMemberExpr::Create(\n        Context, /*This=*/nullptr, ThisType, /*IsArrow=*/true,\n        /*Op=*/SourceLocation(), NestedNameSpecifierLoc(), TemplateKWLoc,\n        /*FirstQualifierFoundInScope=*/nullptr, NameInfo, TemplateArgs);\n  }\n\n  // Synthesize a fake NNS that points to the derived class.  This will\n  // perform name lookup during template instantiation.\n  CXXScopeSpec SS;\n  auto *NNS =\n      NestedNameSpecifier::Create(Context, nullptr, true, RD->getTypeForDecl());\n  SS.MakeTrivial(Context, NNS, SourceRange(Loc, Loc));\n  return DependentScopeDeclRefExpr::Create(\n      Context, SS.getWithLocInContext(Context), TemplateKWLoc, NameInfo,\n      TemplateArgs);\n}\n\nExprResult\nSema::ActOnIdExpression(Scope *S, CXXScopeSpec &SS,\n                        SourceLocation TemplateKWLoc, UnqualifiedId &Id,\n                        bool HasTrailingLParen, bool IsAddressOfOperand,\n                        CorrectionCandidateCallback *CCC,\n                        bool IsInlineAsmIdentifier, Token *KeywordReplacement) {\n  assert(!(IsAddressOfOperand && HasTrailingLParen) &&\n         \"cannot be direct & operand and have a trailing lparen\");\n  if (SS.isInvalid())\n    return ExprError();\n\n  TemplateArgumentListInfo TemplateArgsBuffer;\n\n  // Decompose the UnqualifiedId into the following data.\n  DeclarationNameInfo NameInfo;\n  const TemplateArgumentListInfo *TemplateArgs;\n  DecomposeUnqualifiedId(Id, TemplateArgsBuffer, NameInfo, TemplateArgs);\n\n  DeclarationName Name = NameInfo.getName();\n  IdentifierInfo *II = Name.getAsIdentifierInfo();\n  SourceLocation NameLoc = NameInfo.getLoc();\n\n  if (II && II->isEditorPlaceholder()) {\n    // FIXME: When typed placeholders are supported we can create a typed\n    // placeholder expression node.\n    return ExprError();\n  }\n\n  // C++ [temp.dep.expr]p3:\n  //   An id-expression is type-dependent if it contains:\n  //     -- an identifier that was declared with a dependent type,\n  //        (note: handled after lookup)\n  //     -- a template-id that is dependent,\n  //        (note: handled in BuildTemplateIdExpr)\n  //     -- a conversion-function-id that specifies a dependent type,\n  //     -- a nested-name-specifier that contains a class-name that\n  //        names a dependent type.\n  // Determine whether this is a member of an unknown specialization;\n  // we need to handle these differently.\n  bool DependentID = false;\n  if (Name.getNameKind() == DeclarationName::CXXConversionFunctionName &&\n      Name.getCXXNameType()->isDependentType()) {\n    DependentID = true;\n  } else if (SS.isSet()) {\n    if (DeclContext *DC = computeDeclContext(SS, false)) {\n      if (RequireCompleteDeclContext(SS, DC))\n        return ExprError();\n    } else {\n      DependentID = true;\n    }\n  }\n\n  if (DependentID)\n    return ActOnDependentIdExpression(SS, TemplateKWLoc, NameInfo,\n                                      IsAddressOfOperand, TemplateArgs);\n\n  // Perform the required lookup.\n  LookupResult R(*this, NameInfo,\n                 (Id.getKind() == UnqualifiedIdKind::IK_ImplicitSelfParam)\n                     ? LookupObjCImplicitSelfParam\n                     : LookupOrdinaryName);\n  if (TemplateKWLoc.isValid() || TemplateArgs) {\n    // Lookup the template name again to correctly establish the context in\n    // which it was found. This is really unfortunate as we already did the\n    // lookup to determine that it was a template name in the first place. If\n    // this becomes a performance hit, we can work harder to preserve those\n    // results until we get here but it's likely not worth it.\n    bool MemberOfUnknownSpecialization;\n    AssumedTemplateKind AssumedTemplate;\n    if (LookupTemplateName(R, S, SS, QualType(), /*EnteringContext=*/false,\n                           MemberOfUnknownSpecialization, TemplateKWLoc,\n                           &AssumedTemplate))\n      return ExprError();\n\n    if (MemberOfUnknownSpecialization ||\n        (R.getResultKind() == LookupResult::NotFoundInCurrentInstantiation))\n      return ActOnDependentIdExpression(SS, TemplateKWLoc, NameInfo,\n                                        IsAddressOfOperand, TemplateArgs);\n  } else {\n    bool IvarLookupFollowUp = II && !SS.isSet() && getCurMethodDecl();\n    LookupParsedName(R, S, &SS, !IvarLookupFollowUp);\n\n    // If the result might be in a dependent base class, this is a dependent\n    // id-expression.\n    if (R.getResultKind() == LookupResult::NotFoundInCurrentInstantiation)\n      return ActOnDependentIdExpression(SS, TemplateKWLoc, NameInfo,\n                                        IsAddressOfOperand, TemplateArgs);\n\n    // If this reference is in an Objective-C method, then we need to do\n    // some special Objective-C lookup, too.\n    if (IvarLookupFollowUp) {\n      ExprResult E(LookupInObjCMethod(R, S, II, true));\n      if (E.isInvalid())\n        return ExprError();\n\n      if (Expr *Ex = E.getAs<Expr>())\n        return Ex;\n    }\n  }\n\n  if (R.isAmbiguous())\n    return ExprError();\n\n  // This could be an implicitly declared function reference (legal in C90,\n  // extension in C99, forbidden in C++).\n  if (R.empty() && HasTrailingLParen && II && !getLangOpts().CPlusPlus) {\n    NamedDecl *D = ImplicitlyDefineFunction(NameLoc, *II, S);\n    if (D) R.addDecl(D);\n  }\n\n  // Determine whether this name might be a candidate for\n  // argument-dependent lookup.\n  bool ADL = UseArgumentDependentLookup(SS, R, HasTrailingLParen);\n\n  if (R.empty() && !ADL) {\n    if (SS.isEmpty() && getLangOpts().MSVCCompat) {\n      if (Expr *E = recoverFromMSUnqualifiedLookup(*this, Context, NameInfo,\n                                                   TemplateKWLoc, TemplateArgs))\n        return E;\n    }\n\n    // Don't diagnose an empty lookup for inline assembly.\n    if (IsInlineAsmIdentifier)\n      return ExprError();\n\n    // If this name wasn't predeclared and if this is not a function\n    // call, diagnose the problem.\n    TypoExpr *TE = nullptr;\n    DefaultFilterCCC DefaultValidator(II, SS.isValid() ? SS.getScopeRep()\n                                                       : nullptr);\n    DefaultValidator.IsAddressOfOperand = IsAddressOfOperand;\n    assert((!CCC || CCC->IsAddressOfOperand == IsAddressOfOperand) &&\n           \"Typo correction callback misconfigured\");\n    if (CCC) {\n      // Make sure the callback knows what the typo being diagnosed is.\n      CCC->setTypoName(II);\n      if (SS.isValid())\n        CCC->setTypoNNS(SS.getScopeRep());\n    }\n    // FIXME: DiagnoseEmptyLookup produces bad diagnostics if we're looking for\n    // a template name, but we happen to have always already looked up the name\n    // before we get here if it must be a template name.\n    if (DiagnoseEmptyLookup(S, SS, R, CCC ? *CCC : DefaultValidator, nullptr,\n                            None, &TE)) {\n      if (TE && KeywordReplacement) {\n        auto &State = getTypoExprState(TE);\n        auto BestTC = State.Consumer->getNextCorrection();\n        if (BestTC.isKeyword()) {\n          auto *II = BestTC.getCorrectionAsIdentifierInfo();\n          if (State.DiagHandler)\n            State.DiagHandler(BestTC);\n          KeywordReplacement->startToken();\n          KeywordReplacement->setKind(II->getTokenID());\n          KeywordReplacement->setIdentifierInfo(II);\n          KeywordReplacement->setLocation(BestTC.getCorrectionRange().getBegin());\n          // Clean up the state associated with the TypoExpr, since it has\n          // now been diagnosed (without a call to CorrectDelayedTyposInExpr).\n          clearDelayedTypo(TE);\n          // Signal that a correction to a keyword was performed by returning a\n          // valid-but-null ExprResult.\n          return (Expr*)nullptr;\n        }\n        State.Consumer->resetCorrectionStream();\n      }\n      return TE ? TE : ExprError();\n    }\n\n    assert(!R.empty() &&\n           \"DiagnoseEmptyLookup returned false but added no results\");\n\n    // If we found an Objective-C instance variable, let\n    // LookupInObjCMethod build the appropriate expression to\n    // reference the ivar.\n    if (ObjCIvarDecl *Ivar = R.getAsSingle<ObjCIvarDecl>()) {\n      R.clear();\n      ExprResult E(LookupInObjCMethod(R, S, Ivar->getIdentifier()));\n      // In a hopelessly buggy code, Objective-C instance variable\n      // lookup fails and no expression will be built to reference it.\n      if (!E.isInvalid() && !E.get())\n        return ExprError();\n      return E;\n    }\n  }\n\n  // This is guaranteed from this point on.\n  assert(!R.empty() || ADL);\n\n  // Check whether this might be a C++ implicit instance member access.\n  // C++ [class.mfct.non-static]p3:\n  //   When an id-expression that is not part of a class member access\n  //   syntax and not used to form a pointer to member is used in the\n  //   body of a non-static member function of class X, if name lookup\n  //   resolves the name in the id-expression to a non-static non-type\n  //   member of some class C, the id-expression is transformed into a\n  //   class member access expression using (*this) as the\n  //   postfix-expression to the left of the . operator.\n  //\n  // But we don't actually need to do this for '&' operands if R\n  // resolved to a function or overloaded function set, because the\n  // expression is ill-formed if it actually works out to be a\n  // non-static member function:\n  //\n  // C++ [expr.ref]p4:\n  //   Otherwise, if E1.E2 refers to a non-static member function. . .\n  //   [t]he expression can be used only as the left-hand operand of a\n  //   member function call.\n  //\n  // There are other safeguards against such uses, but it's important\n  // to get this right here so that we don't end up making a\n  // spuriously dependent expression if we're inside a dependent\n  // instance method.\n  if (!R.empty() && (*R.begin())->isCXXClassMember()) {\n    bool MightBeImplicitMember;\n    if (!IsAddressOfOperand)\n      MightBeImplicitMember = true;\n    else if (!SS.isEmpty())\n      MightBeImplicitMember = false;\n    else if (R.isOverloadedResult())\n      MightBeImplicitMember = false;\n    else if (R.isUnresolvableResult())\n      MightBeImplicitMember = true;\n    else\n      MightBeImplicitMember = isa<FieldDecl>(R.getFoundDecl()) ||\n                              isa<IndirectFieldDecl>(R.getFoundDecl()) ||\n                              isa<MSPropertyDecl>(R.getFoundDecl());\n\n    if (MightBeImplicitMember)\n      return BuildPossibleImplicitMemberExpr(SS, TemplateKWLoc,\n                                             R, TemplateArgs, S);\n  }\n\n  if (TemplateArgs || TemplateKWLoc.isValid()) {\n\n    // In C++1y, if this is a variable template id, then check it\n    // in BuildTemplateIdExpr().\n    // The single lookup result must be a variable template declaration.\n    if (Id.getKind() == UnqualifiedIdKind::IK_TemplateId && Id.TemplateId &&\n        Id.TemplateId->Kind == TNK_Var_template) {\n      assert(R.getAsSingle<VarTemplateDecl>() &&\n             \"There should only be one declaration found.\");\n    }\n\n    return BuildTemplateIdExpr(SS, TemplateKWLoc, R, ADL, TemplateArgs);\n  }\n\n  return BuildDeclarationNameExpr(SS, R, ADL);\n}\n\n/// BuildQualifiedDeclarationNameExpr - Build a C++ qualified\n/// declaration name, generally during template instantiation.\n/// There's a large number of things which don't need to be done along\n/// this path.\nExprResult Sema::BuildQualifiedDeclarationNameExpr(\n    CXXScopeSpec &SS, const DeclarationNameInfo &NameInfo,\n    bool IsAddressOfOperand, const Scope *S, TypeSourceInfo **RecoveryTSI) {\n  DeclContext *DC = computeDeclContext(SS, false);\n  if (!DC)\n    return BuildDependentDeclRefExpr(SS, /*TemplateKWLoc=*/SourceLocation(),\n                                     NameInfo, /*TemplateArgs=*/nullptr);\n\n  if (RequireCompleteDeclContext(SS, DC))\n    return ExprError();\n\n  LookupResult R(*this, NameInfo, LookupOrdinaryName);\n  LookupQualifiedName(R, DC);\n\n  if (R.isAmbiguous())\n    return ExprError();\n\n  if (R.getResultKind() == LookupResult::NotFoundInCurrentInstantiation)\n    return BuildDependentDeclRefExpr(SS, /*TemplateKWLoc=*/SourceLocation(),\n                                     NameInfo, /*TemplateArgs=*/nullptr);\n\n  if (R.empty()) {\n    // Don't diagnose problems with invalid record decl, the secondary no_member\n    // diagnostic during template instantiation is likely bogus, e.g. if a class\n    // is invalid because it's derived from an invalid base class, then missing\n    // members were likely supposed to be inherited.\n    if (const auto *CD = dyn_cast<CXXRecordDecl>(DC))\n      if (CD->isInvalidDecl())\n        return ExprError();\n    Diag(NameInfo.getLoc(), diag::err_no_member)\n      << NameInfo.getName() << DC << SS.getRange();\n    return ExprError();\n  }\n\n  if (const TypeDecl *TD = R.getAsSingle<TypeDecl>()) {\n    // Diagnose a missing typename if this resolved unambiguously to a type in\n    // a dependent context.  If we can recover with a type, downgrade this to\n    // a warning in Microsoft compatibility mode.\n    unsigned DiagID = diag::err_typename_missing;\n    if (RecoveryTSI && getLangOpts().MSVCCompat)\n      DiagID = diag::ext_typename_missing;\n    SourceLocation Loc = SS.getBeginLoc();\n    auto D = Diag(Loc, DiagID);\n    D << SS.getScopeRep() << NameInfo.getName().getAsString()\n      << SourceRange(Loc, NameInfo.getEndLoc());\n\n    // Don't recover if the caller isn't expecting us to or if we're in a SFINAE\n    // context.\n    if (!RecoveryTSI)\n      return ExprError();\n\n    // Only issue the fixit if we're prepared to recover.\n    D << FixItHint::CreateInsertion(Loc, \"typename \");\n\n    // Recover by pretending this was an elaborated type.\n    QualType Ty = Context.getTypeDeclType(TD);\n    TypeLocBuilder TLB;\n    TLB.pushTypeSpec(Ty).setNameLoc(NameInfo.getLoc());\n\n    QualType ET = getElaboratedType(ETK_None, SS, Ty);\n    ElaboratedTypeLoc QTL = TLB.push<ElaboratedTypeLoc>(ET);\n    QTL.setElaboratedKeywordLoc(SourceLocation());\n    QTL.setQualifierLoc(SS.getWithLocInContext(Context));\n\n    *RecoveryTSI = TLB.getTypeSourceInfo(Context, ET);\n\n    return ExprEmpty();\n  }\n\n  // Defend against this resolving to an implicit member access. We usually\n  // won't get here if this might be a legitimate a class member (we end up in\n  // BuildMemberReferenceExpr instead), but this can be valid if we're forming\n  // a pointer-to-member or in an unevaluated context in C++11.\n  if (!R.empty() && (*R.begin())->isCXXClassMember() && !IsAddressOfOperand)\n    return BuildPossibleImplicitMemberExpr(SS,\n                                           /*TemplateKWLoc=*/SourceLocation(),\n                                           R, /*TemplateArgs=*/nullptr, S);\n\n  return BuildDeclarationNameExpr(SS, R, /* ADL */ false);\n}\n\n/// The parser has read a name in, and Sema has detected that we're currently\n/// inside an ObjC method. Perform some additional checks and determine if we\n/// should form a reference to an ivar.\n///\n/// Ideally, most of this would be done by lookup, but there's\n/// actually quite a lot of extra work involved.\nDeclResult Sema::LookupIvarInObjCMethod(LookupResult &Lookup, Scope *S,\n                                        IdentifierInfo *II) {\n  SourceLocation Loc = Lookup.getNameLoc();\n  ObjCMethodDecl *CurMethod = getCurMethodDecl();\n\n  // Check for error condition which is already reported.\n  if (!CurMethod)\n    return DeclResult(true);\n\n  // There are two cases to handle here.  1) scoped lookup could have failed,\n  // in which case we should look for an ivar.  2) scoped lookup could have\n  // found a decl, but that decl is outside the current instance method (i.e.\n  // a global variable).  In these two cases, we do a lookup for an ivar with\n  // this name, if the lookup sucedes, we replace it our current decl.\n\n  // If we're in a class method, we don't normally want to look for\n  // ivars.  But if we don't find anything else, and there's an\n  // ivar, that's an error.\n  bool IsClassMethod = CurMethod->isClassMethod();\n\n  bool LookForIvars;\n  if (Lookup.empty())\n    LookForIvars = true;\n  else if (IsClassMethod)\n    LookForIvars = false;\n  else\n    LookForIvars = (Lookup.isSingleResult() &&\n                    Lookup.getFoundDecl()->isDefinedOutsideFunctionOrMethod());\n  ObjCInterfaceDecl *IFace = nullptr;\n  if (LookForIvars) {\n    IFace = CurMethod->getClassInterface();\n    ObjCInterfaceDecl *ClassDeclared;\n    ObjCIvarDecl *IV = nullptr;\n    if (IFace && (IV = IFace->lookupInstanceVariable(II, ClassDeclared))) {\n      // Diagnose using an ivar in a class method.\n      if (IsClassMethod) {\n        Diag(Loc, diag::err_ivar_use_in_class_method) << IV->getDeclName();\n        return DeclResult(true);\n      }\n\n      // Diagnose the use of an ivar outside of the declaring class.\n      if (IV->getAccessControl() == ObjCIvarDecl::Private &&\n          !declaresSameEntity(ClassDeclared, IFace) &&\n          !getLangOpts().DebuggerSupport)\n        Diag(Loc, diag::err_private_ivar_access) << IV->getDeclName();\n\n      // Success.\n      return IV;\n    }\n  } else if (CurMethod->isInstanceMethod()) {\n    // We should warn if a local variable hides an ivar.\n    if (ObjCInterfaceDecl *IFace = CurMethod->getClassInterface()) {\n      ObjCInterfaceDecl *ClassDeclared;\n      if (ObjCIvarDecl *IV = IFace->lookupInstanceVariable(II, ClassDeclared)) {\n        if (IV->getAccessControl() != ObjCIvarDecl::Private ||\n            declaresSameEntity(IFace, ClassDeclared))\n          Diag(Loc, diag::warn_ivar_use_hidden) << IV->getDeclName();\n      }\n    }\n  } else if (Lookup.isSingleResult() &&\n             Lookup.getFoundDecl()->isDefinedOutsideFunctionOrMethod()) {\n    // If accessing a stand-alone ivar in a class method, this is an error.\n    if (const ObjCIvarDecl *IV =\n            dyn_cast<ObjCIvarDecl>(Lookup.getFoundDecl())) {\n      Diag(Loc, diag::err_ivar_use_in_class_method) << IV->getDeclName();\n      return DeclResult(true);\n    }\n  }\n\n  // Didn't encounter an error, didn't find an ivar.\n  return DeclResult(false);\n}\n\nExprResult Sema::BuildIvarRefExpr(Scope *S, SourceLocation Loc,\n                                  ObjCIvarDecl *IV) {\n  ObjCMethodDecl *CurMethod = getCurMethodDecl();\n  assert(CurMethod && CurMethod->isInstanceMethod() &&\n         \"should not reference ivar from this context\");\n\n  ObjCInterfaceDecl *IFace = CurMethod->getClassInterface();\n  assert(IFace && \"should not reference ivar from this context\");\n\n  // If we're referencing an invalid decl, just return this as a silent\n  // error node.  The error diagnostic was already emitted on the decl.\n  if (IV->isInvalidDecl())\n    return ExprError();\n\n  // Check if referencing a field with __attribute__((deprecated)).\n  if (DiagnoseUseOfDecl(IV, Loc))\n    return ExprError();\n\n  // FIXME: This should use a new expr for a direct reference, don't\n  // turn this into Self->ivar, just return a BareIVarExpr or something.\n  IdentifierInfo &II = Context.Idents.get(\"self\");\n  UnqualifiedId SelfName;\n  SelfName.setImplicitSelfParam(&II);\n  CXXScopeSpec SelfScopeSpec;\n  SourceLocation TemplateKWLoc;\n  ExprResult SelfExpr =\n      ActOnIdExpression(S, SelfScopeSpec, TemplateKWLoc, SelfName,\n                        /*HasTrailingLParen=*/false,\n                        /*IsAddressOfOperand=*/false);\n  if (SelfExpr.isInvalid())\n    return ExprError();\n\n  SelfExpr = DefaultLvalueConversion(SelfExpr.get());\n  if (SelfExpr.isInvalid())\n    return ExprError();\n\n  MarkAnyDeclReferenced(Loc, IV, true);\n\n  ObjCMethodFamily MF = CurMethod->getMethodFamily();\n  if (MF != OMF_init && MF != OMF_dealloc && MF != OMF_finalize &&\n      !IvarBacksCurrentMethodAccessor(IFace, CurMethod, IV))\n    Diag(Loc, diag::warn_direct_ivar_access) << IV->getDeclName();\n\n  ObjCIvarRefExpr *Result = new (Context)\n      ObjCIvarRefExpr(IV, IV->getUsageType(SelfExpr.get()->getType()), Loc,\n                      IV->getLocation(), SelfExpr.get(), true, true);\n\n  if (IV->getType().getObjCLifetime() == Qualifiers::OCL_Weak) {\n    if (!isUnevaluatedContext() &&\n        !Diags.isIgnored(diag::warn_arc_repeated_use_of_weak, Loc))\n      getCurFunction()->recordUseOfWeak(Result);\n  }\n  if (getLangOpts().ObjCAutoRefCount)\n    if (const BlockDecl *BD = CurContext->getInnermostBlockDecl())\n      ImplicitlyRetainedSelfLocs.push_back({Loc, BD});\n\n  return Result;\n}\n\n/// The parser has read a name in, and Sema has detected that we're currently\n/// inside an ObjC method. Perform some additional checks and determine if we\n/// should form a reference to an ivar. If so, build an expression referencing\n/// that ivar.\nExprResult\nSema::LookupInObjCMethod(LookupResult &Lookup, Scope *S,\n                         IdentifierInfo *II, bool AllowBuiltinCreation) {\n  // FIXME: Integrate this lookup step into LookupParsedName.\n  DeclResult Ivar = LookupIvarInObjCMethod(Lookup, S, II);\n  if (Ivar.isInvalid())\n    return ExprError();\n  if (Ivar.isUsable())\n    return BuildIvarRefExpr(S, Lookup.getNameLoc(),\n                            cast<ObjCIvarDecl>(Ivar.get()));\n\n  if (Lookup.empty() && II && AllowBuiltinCreation)\n    LookupBuiltin(Lookup);\n\n  // Sentinel value saying that we didn't do anything special.\n  return ExprResult(false);\n}\n\n/// Cast a base object to a member's actual type.\n///\n/// There are two relevant checks:\n///\n/// C++ [class.access.base]p7:\n///\n///   If a class member access operator [...] is used to access a non-static\n///   data member or non-static member function, the reference is ill-formed if\n///   the left operand [...] cannot be implicitly converted to a pointer to the\n///   naming class of the right operand.\n///\n/// C++ [expr.ref]p7:\n///\n///   If E2 is a non-static data member or a non-static member function, the\n///   program is ill-formed if the class of which E2 is directly a member is an\n///   ambiguous base (11.8) of the naming class (11.9.3) of E2.\n///\n/// Note that the latter check does not consider access; the access of the\n/// \"real\" base class is checked as appropriate when checking the access of the\n/// member name.\nExprResult\nSema::PerformObjectMemberConversion(Expr *From,\n                                    NestedNameSpecifier *Qualifier,\n                                    NamedDecl *FoundDecl,\n                                    NamedDecl *Member) {\n  CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(Member->getDeclContext());\n  if (!RD)\n    return From;\n\n  QualType DestRecordType;\n  QualType DestType;\n  QualType FromRecordType;\n  QualType FromType = From->getType();\n  bool PointerConversions = false;\n  if (isa<FieldDecl>(Member)) {\n    DestRecordType = Context.getCanonicalType(Context.getTypeDeclType(RD));\n    auto FromPtrType = FromType->getAs<PointerType>();\n    DestRecordType = Context.getAddrSpaceQualType(\n        DestRecordType, FromPtrType\n                            ? FromType->getPointeeType().getAddressSpace()\n                            : FromType.getAddressSpace());\n\n    if (FromPtrType) {\n      DestType = Context.getPointerType(DestRecordType);\n      FromRecordType = FromPtrType->getPointeeType();\n      PointerConversions = true;\n    } else {\n      DestType = DestRecordType;\n      FromRecordType = FromType;\n    }\n  } else if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(Member)) {\n    if (Method->isStatic())\n      return From;\n\n    DestType = Method->getThisType();\n    DestRecordType = DestType->getPointeeType();\n\n    if (FromType->getAs<PointerType>()) {\n      FromRecordType = FromType->getPointeeType();\n      PointerConversions = true;\n    } else {\n      FromRecordType = FromType;\n      DestType = DestRecordType;\n    }\n\n    LangAS FromAS = FromRecordType.getAddressSpace();\n    LangAS DestAS = DestRecordType.getAddressSpace();\n    if (FromAS != DestAS) {\n      QualType FromRecordTypeWithoutAS =\n          Context.removeAddrSpaceQualType(FromRecordType);\n      QualType FromTypeWithDestAS =\n          Context.getAddrSpaceQualType(FromRecordTypeWithoutAS, DestAS);\n      if (PointerConversions)\n        FromTypeWithDestAS = Context.getPointerType(FromTypeWithDestAS);\n      From = ImpCastExprToType(From, FromTypeWithDestAS,\n                               CK_AddressSpaceConversion, From->getValueKind())\n                 .get();\n    }\n  } else {\n    // No conversion necessary.\n    return From;\n  }\n\n  if (DestType->isDependentType() || FromType->isDependentType())\n    return From;\n\n  // If the unqualified types are the same, no conversion is necessary.\n  if (Context.hasSameUnqualifiedType(FromRecordType, DestRecordType))\n    return From;\n\n  SourceRange FromRange = From->getSourceRange();\n  SourceLocation FromLoc = FromRange.getBegin();\n\n  ExprValueKind VK = From->getValueKind();\n\n  // C++ [class.member.lookup]p8:\n  //   [...] Ambiguities can often be resolved by qualifying a name with its\n  //   class name.\n  //\n  // If the member was a qualified name and the qualified referred to a\n  // specific base subobject type, we'll cast to that intermediate type\n  // first and then to the object in which the member is declared. That allows\n  // one to resolve ambiguities in, e.g., a diamond-shaped hierarchy such as:\n  //\n  //   class Base { public: int x; };\n  //   class Derived1 : public Base { };\n  //   class Derived2 : public Base { };\n  //   class VeryDerived : public Derived1, public Derived2 { void f(); };\n  //\n  //   void VeryDerived::f() {\n  //     x = 17; // error: ambiguous base subobjects\n  //     Derived1::x = 17; // okay, pick the Base subobject of Derived1\n  //   }\n  if (Qualifier && Qualifier->getAsType()) {\n    QualType QType = QualType(Qualifier->getAsType(), 0);\n    assert(QType->isRecordType() && \"lookup done with non-record type\");\n\n    QualType QRecordType = QualType(QType->getAs<RecordType>(), 0);\n\n    // In C++98, the qualifier type doesn't actually have to be a base\n    // type of the object type, in which case we just ignore it.\n    // Otherwise build the appropriate casts.\n    if (IsDerivedFrom(FromLoc, FromRecordType, QRecordType)) {\n      CXXCastPath BasePath;\n      if (CheckDerivedToBaseConversion(FromRecordType, QRecordType,\n                                       FromLoc, FromRange, &BasePath))\n        return ExprError();\n\n      if (PointerConversions)\n        QType = Context.getPointerType(QType);\n      From = ImpCastExprToType(From, QType, CK_UncheckedDerivedToBase,\n                               VK, &BasePath).get();\n\n      FromType = QType;\n      FromRecordType = QRecordType;\n\n      // If the qualifier type was the same as the destination type,\n      // we're done.\n      if (Context.hasSameUnqualifiedType(FromRecordType, DestRecordType))\n        return From;\n    }\n  }\n\n  CXXCastPath BasePath;\n  if (CheckDerivedToBaseConversion(FromRecordType, DestRecordType,\n                                   FromLoc, FromRange, &BasePath,\n                                   /*IgnoreAccess=*/true))\n    return ExprError();\n\n  return ImpCastExprToType(From, DestType, CK_UncheckedDerivedToBase,\n                           VK, &BasePath);\n}\n\nbool Sema::UseArgumentDependentLookup(const CXXScopeSpec &SS,\n                                      const LookupResult &R,\n                                      bool HasTrailingLParen) {\n  // Only when used directly as the postfix-expression of a call.\n  if (!HasTrailingLParen)\n    return false;\n\n  // Never if a scope specifier was provided.\n  if (SS.isSet())\n    return false;\n\n  // Only in C++ or ObjC++.\n  if (!getLangOpts().CPlusPlus)\n    return false;\n\n  // Turn off ADL when we find certain kinds of declarations during\n  // normal lookup:\n  for (NamedDecl *D : R) {\n    // C++0x [basic.lookup.argdep]p3:\n    //     -- a declaration of a class member\n    // Since using decls preserve this property, we check this on the\n    // original decl.\n    if (D->isCXXClassMember())\n      return false;\n\n    // C++0x [basic.lookup.argdep]p3:\n    //     -- a block-scope function declaration that is not a\n    //        using-declaration\n    // NOTE: we also trigger this for function templates (in fact, we\n    // don't check the decl type at all, since all other decl types\n    // turn off ADL anyway).\n    if (isa<UsingShadowDecl>(D))\n      D = cast<UsingShadowDecl>(D)->getTargetDecl();\n    else if (D->getLexicalDeclContext()->isFunctionOrMethod())\n      return false;\n\n    // C++0x [basic.lookup.argdep]p3:\n    //     -- a declaration that is neither a function or a function\n    //        template\n    // And also for builtin functions.\n    if (isa<FunctionDecl>(D)) {\n      FunctionDecl *FDecl = cast<FunctionDecl>(D);\n\n      // But also builtin functions.\n      if (FDecl->getBuiltinID() && FDecl->isImplicit())\n        return false;\n    } else if (!isa<FunctionTemplateDecl>(D))\n      return false;\n  }\n\n  return true;\n}\n\n\n/// Diagnoses obvious problems with the use of the given declaration\n/// as an expression.  This is only actually called for lookups that\n/// were not overloaded, and it doesn't promise that the declaration\n/// will in fact be used.\nstatic bool CheckDeclInExpr(Sema &S, SourceLocation Loc, NamedDecl *D) {\n  if (D->isInvalidDecl())\n    return true;\n\n  if (isa<TypedefNameDecl>(D)) {\n    S.Diag(Loc, diag::err_unexpected_typedef) << D->getDeclName();\n    return true;\n  }\n\n  if (isa<ObjCInterfaceDecl>(D)) {\n    S.Diag(Loc, diag::err_unexpected_interface) << D->getDeclName();\n    return true;\n  }\n\n  if (isa<NamespaceDecl>(D)) {\n    S.Diag(Loc, diag::err_unexpected_namespace) << D->getDeclName();\n    return true;\n  }\n\n  return false;\n}\n\n// Certain multiversion types should be treated as overloaded even when there is\n// only one result.\nstatic bool ShouldLookupResultBeMultiVersionOverload(const LookupResult &R) {\n  assert(R.isSingleResult() && \"Expected only a single result\");\n  const auto *FD = dyn_cast<FunctionDecl>(R.getFoundDecl());\n  return FD &&\n         (FD->isCPUDispatchMultiVersion() || FD->isCPUSpecificMultiVersion());\n}\n\nExprResult Sema::BuildDeclarationNameExpr(const CXXScopeSpec &SS,\n                                          LookupResult &R, bool NeedsADL,\n                                          bool AcceptInvalidDecl) {\n  // If this is a single, fully-resolved result and we don't need ADL,\n  // just build an ordinary singleton decl ref.\n  if (!NeedsADL && R.isSingleResult() &&\n      !R.getAsSingle<FunctionTemplateDecl>() &&\n      !ShouldLookupResultBeMultiVersionOverload(R))\n    return BuildDeclarationNameExpr(SS, R.getLookupNameInfo(), R.getFoundDecl(),\n                                    R.getRepresentativeDecl(), nullptr,\n                                    AcceptInvalidDecl);\n\n  // We only need to check the declaration if there's exactly one\n  // result, because in the overloaded case the results can only be\n  // functions and function templates.\n  if (R.isSingleResult() && !ShouldLookupResultBeMultiVersionOverload(R) &&\n      CheckDeclInExpr(*this, R.getNameLoc(), R.getFoundDecl()))\n    return ExprError();\n\n  // Otherwise, just build an unresolved lookup expression.  Suppress\n  // any lookup-related diagnostics; we'll hash these out later, when\n  // we've picked a target.\n  R.suppressDiagnostics();\n\n  UnresolvedLookupExpr *ULE\n    = UnresolvedLookupExpr::Create(Context, R.getNamingClass(),\n                                   SS.getWithLocInContext(Context),\n                                   R.getLookupNameInfo(),\n                                   NeedsADL, R.isOverloadedResult(),\n                                   R.begin(), R.end());\n\n  return ULE;\n}\n\nstatic void\ndiagnoseUncapturableValueReference(Sema &S, SourceLocation loc,\n                                   ValueDecl *var, DeclContext *DC);\n\n/// Complete semantic analysis for a reference to the given declaration.\nExprResult Sema::BuildDeclarationNameExpr(\n    const CXXScopeSpec &SS, const DeclarationNameInfo &NameInfo, NamedDecl *D,\n    NamedDecl *FoundD, const TemplateArgumentListInfo *TemplateArgs,\n    bool AcceptInvalidDecl) {\n  assert(D && \"Cannot refer to a NULL declaration\");\n  assert(!isa<FunctionTemplateDecl>(D) &&\n         \"Cannot refer unambiguously to a function template\");\n\n  SourceLocation Loc = NameInfo.getLoc();\n  if (CheckDeclInExpr(*this, Loc, D))\n    return ExprError();\n\n  if (TemplateDecl *Template = dyn_cast<TemplateDecl>(D)) {\n    // Specifically diagnose references to class templates that are missing\n    // a template argument list.\n    diagnoseMissingTemplateArguments(TemplateName(Template), Loc);\n    return ExprError();\n  }\n\n  // Make sure that we're referring to a value.\n  ValueDecl *VD = dyn_cast<ValueDecl>(D);\n  if (!VD) {\n    Diag(Loc, diag::err_ref_non_value)\n      << D << SS.getRange();\n    Diag(D->getLocation(), diag::note_declared_at);\n    return ExprError();\n  }\n\n  // Check whether this declaration can be used. Note that we suppress\n  // this check when we're going to perform argument-dependent lookup\n  // on this function name, because this might not be the function\n  // that overload resolution actually selects.\n  if (DiagnoseUseOfDecl(VD, Loc))\n    return ExprError();\n\n  // Only create DeclRefExpr's for valid Decl's.\n  if (VD->isInvalidDecl() && !AcceptInvalidDecl)\n    return ExprError();\n\n  // Handle members of anonymous structs and unions.  If we got here,\n  // and the reference is to a class member indirect field, then this\n  // must be the subject of a pointer-to-member expression.\n  if (IndirectFieldDecl *indirectField = dyn_cast<IndirectFieldDecl>(VD))\n    if (!indirectField->isCXXClassMember())\n      return BuildAnonymousStructUnionMemberReference(SS, NameInfo.getLoc(),\n                                                      indirectField);\n\n  {\n    QualType type = VD->getType();\n    if (type.isNull())\n      return ExprError();\n    ExprValueKind valueKind = VK_RValue;\n\n    // In 'T ...V;', the type of the declaration 'V' is 'T...', but the type of\n    // a reference to 'V' is simply (unexpanded) 'T'. The type, like the value,\n    // is expanded by some outer '...' in the context of the use.\n    type = type.getNonPackExpansionType();\n\n    switch (D->getKind()) {\n    // Ignore all the non-ValueDecl kinds.\n#define ABSTRACT_DECL(kind)\n#define VALUE(type, base)\n#define DECL(type, base) \\\n    case Decl::type:\n#include \"clang/AST/DeclNodes.inc\"\n      llvm_unreachable(\"invalid value decl kind\");\n\n    // These shouldn't make it here.\n    case Decl::ObjCAtDefsField:\n      llvm_unreachable(\"forming non-member reference to ivar?\");\n\n    // Enum constants are always r-values and never references.\n    // Unresolved using declarations are dependent.\n    case Decl::EnumConstant:\n    case Decl::UnresolvedUsingValue:\n    case Decl::OMPDeclareReduction:\n    case Decl::OMPDeclareMapper:\n      valueKind = VK_RValue;\n      break;\n\n    // Fields and indirect fields that got here must be for\n    // pointer-to-member expressions; we just call them l-values for\n    // internal consistency, because this subexpression doesn't really\n    // exist in the high-level semantics.\n    case Decl::Field:\n    case Decl::IndirectField:\n    case Decl::ObjCIvar:\n      assert(getLangOpts().CPlusPlus &&\n             \"building reference to field in C?\");\n\n      // These can't have reference type in well-formed programs, but\n      // for internal consistency we do this anyway.\n      type = type.getNonReferenceType();\n      valueKind = VK_LValue;\n      break;\n\n    // Non-type template parameters are either l-values or r-values\n    // depending on the type.\n    case Decl::NonTypeTemplateParm: {\n      if (const ReferenceType *reftype = type->getAs<ReferenceType>()) {\n        type = reftype->getPointeeType();\n        valueKind = VK_LValue; // even if the parameter is an r-value reference\n        break;\n      }\n\n      // [expr.prim.id.unqual]p2:\n      //   If the entity is a template parameter object for a template\n      //   parameter of type T, the type of the expression is const T.\n      //   [...] The expression is an lvalue if the entity is a [...] template\n      //   parameter object.\n      if (type->isRecordType()) {\n        type = type.getUnqualifiedType().withConst();\n        valueKind = VK_LValue;\n        break;\n      }\n\n      // For non-references, we need to strip qualifiers just in case\n      // the template parameter was declared as 'const int' or whatever.\n      valueKind = VK_RValue;\n      type = type.getUnqualifiedType();\n      break;\n    }\n\n    case Decl::Var:\n    case Decl::VarTemplateSpecialization:\n    case Decl::VarTemplatePartialSpecialization:\n    case Decl::Decomposition:\n    case Decl::OMPCapturedExpr:\n      // In C, \"extern void blah;\" is valid and is an r-value.\n      if (!getLangOpts().CPlusPlus &&\n          !type.hasQualifiers() &&\n          type->isVoidType()) {\n        valueKind = VK_RValue;\n        break;\n      }\n      LLVM_FALLTHROUGH;\n\n    case Decl::ImplicitParam:\n    case Decl::ParmVar: {\n      // These are always l-values.\n      valueKind = VK_LValue;\n      type = type.getNonReferenceType();\n\n      // FIXME: Does the addition of const really only apply in\n      // potentially-evaluated contexts? Since the variable isn't actually\n      // captured in an unevaluated context, it seems that the answer is no.\n      if (!isUnevaluatedContext()) {\n        QualType CapturedType = getCapturedDeclRefType(cast<VarDecl>(VD), Loc);\n        if (!CapturedType.isNull())\n          type = CapturedType;\n      }\n\n      break;\n    }\n\n    case Decl::Binding: {\n      // These are always lvalues.\n      valueKind = VK_LValue;\n      type = type.getNonReferenceType();\n      // FIXME: Support lambda-capture of BindingDecls, once CWG actually\n      // decides how that's supposed to work.\n      auto *BD = cast<BindingDecl>(VD);\n      if (BD->getDeclContext() != CurContext) {\n        auto *DD = dyn_cast_or_null<VarDecl>(BD->getDecomposedDecl());\n        if (DD && DD->hasLocalStorage())\n          diagnoseUncapturableValueReference(*this, Loc, BD, CurContext);\n      }\n      break;\n    }\n\n    case Decl::Function: {\n      if (unsigned BID = cast<FunctionDecl>(VD)->getBuiltinID()) {\n        if (!Context.BuiltinInfo.isPredefinedLibFunction(BID)) {\n          type = Context.BuiltinFnTy;\n          valueKind = VK_RValue;\n          break;\n        }\n      }\n\n      const FunctionType *fty = type->castAs<FunctionType>();\n\n      // If we're referring to a function with an __unknown_anytype\n      // result type, make the entire expression __unknown_anytype.\n      if (fty->getReturnType() == Context.UnknownAnyTy) {\n        type = Context.UnknownAnyTy;\n        valueKind = VK_RValue;\n        break;\n      }\n\n      // Functions are l-values in C++.\n      if (getLangOpts().CPlusPlus) {\n        valueKind = VK_LValue;\n        break;\n      }\n\n      // C99 DR 316 says that, if a function type comes from a\n      // function definition (without a prototype), that type is only\n      // used for checking compatibility. Therefore, when referencing\n      // the function, we pretend that we don't have the full function\n      // type.\n      if (!cast<FunctionDecl>(VD)->hasPrototype() &&\n          isa<FunctionProtoType>(fty))\n        type = Context.getFunctionNoProtoType(fty->getReturnType(),\n                                              fty->getExtInfo());\n\n      // Functions are r-values in C.\n      valueKind = VK_RValue;\n      break;\n    }\n\n    case Decl::CXXDeductionGuide:\n      llvm_unreachable(\"building reference to deduction guide\");\n\n    case Decl::MSProperty:\n    case Decl::MSGuid:\n    case Decl::TemplateParamObject:\n      // FIXME: Should MSGuidDecl and template parameter objects be subject to\n      // capture in OpenMP, or duplicated between host and device?\n      valueKind = VK_LValue;\n      break;\n\n    case Decl::CXXMethod:\n      // If we're referring to a method with an __unknown_anytype\n      // result type, make the entire expression __unknown_anytype.\n      // This should only be possible with a type written directly.\n      if (const FunctionProtoType *proto\n            = dyn_cast<FunctionProtoType>(VD->getType()))\n        if (proto->getReturnType() == Context.UnknownAnyTy) {\n          type = Context.UnknownAnyTy;\n          valueKind = VK_RValue;\n          break;\n        }\n\n      // C++ methods are l-values if static, r-values if non-static.\n      if (cast<CXXMethodDecl>(VD)->isStatic()) {\n        valueKind = VK_LValue;\n        break;\n      }\n      LLVM_FALLTHROUGH;\n\n    case Decl::CXXConversion:\n    case Decl::CXXDestructor:\n    case Decl::CXXConstructor:\n      valueKind = VK_RValue;\n      break;\n    }\n\n    return BuildDeclRefExpr(VD, type, valueKind, NameInfo, &SS, FoundD,\n                            /*FIXME: TemplateKWLoc*/ SourceLocation(),\n                            TemplateArgs);\n  }\n}\n\nstatic void ConvertUTF8ToWideString(unsigned CharByteWidth, StringRef Source,\n                                    SmallString<32> &Target) {\n  Target.resize(CharByteWidth * (Source.size() + 1));\n  char *ResultPtr = &Target[0];\n  const llvm::UTF8 *ErrorPtr;\n  bool success =\n      llvm::ConvertUTF8toWide(CharByteWidth, Source, ResultPtr, ErrorPtr);\n  (void)success;\n  assert(success);\n  Target.resize(ResultPtr - &Target[0]);\n}\n\nExprResult Sema::BuildPredefinedExpr(SourceLocation Loc,\n                                     PredefinedExpr::IdentKind IK) {\n  // Pick the current block, lambda, captured statement or function.\n  Decl *currentDecl = nullptr;\n  if (const BlockScopeInfo *BSI = getCurBlock())\n    currentDecl = BSI->TheDecl;\n  else if (const LambdaScopeInfo *LSI = getCurLambda())\n    currentDecl = LSI->CallOperator;\n  else if (const CapturedRegionScopeInfo *CSI = getCurCapturedRegion())\n    currentDecl = CSI->TheCapturedDecl;\n  else\n    currentDecl = getCurFunctionOrMethodDecl();\n\n  if (!currentDecl) {\n    Diag(Loc, diag::ext_predef_outside_function);\n    currentDecl = Context.getTranslationUnitDecl();\n  }\n\n  QualType ResTy;\n  StringLiteral *SL = nullptr;\n  if (cast<DeclContext>(currentDecl)->isDependentContext())\n    ResTy = Context.DependentTy;\n  else {\n    // Pre-defined identifiers are of type char[x], where x is the length of\n    // the string.\n    auto Str = PredefinedExpr::ComputeName(IK, currentDecl);\n    unsigned Length = Str.length();\n\n    llvm::APInt LengthI(32, Length + 1);\n    if (IK == PredefinedExpr::LFunction || IK == PredefinedExpr::LFuncSig) {\n      ResTy =\n          Context.adjustStringLiteralBaseType(Context.WideCharTy.withConst());\n      SmallString<32> RawChars;\n      ConvertUTF8ToWideString(Context.getTypeSizeInChars(ResTy).getQuantity(),\n                              Str, RawChars);\n      ResTy = Context.getConstantArrayType(ResTy, LengthI, nullptr,\n                                           ArrayType::Normal,\n                                           /*IndexTypeQuals*/ 0);\n      SL = StringLiteral::Create(Context, RawChars, StringLiteral::Wide,\n                                 /*Pascal*/ false, ResTy, Loc);\n    } else {\n      ResTy = Context.adjustStringLiteralBaseType(Context.CharTy.withConst());\n      ResTy = Context.getConstantArrayType(ResTy, LengthI, nullptr,\n                                           ArrayType::Normal,\n                                           /*IndexTypeQuals*/ 0);\n      SL = StringLiteral::Create(Context, Str, StringLiteral::Ascii,\n                                 /*Pascal*/ false, ResTy, Loc);\n    }\n  }\n\n  return PredefinedExpr::Create(Context, Loc, ResTy, IK, SL);\n}\n\nExprResult Sema::ActOnPredefinedExpr(SourceLocation Loc, tok::TokenKind Kind) {\n  PredefinedExpr::IdentKind IK;\n\n  switch (Kind) {\n  default: llvm_unreachable(\"Unknown simple primary expr!\");\n  case tok::kw___func__: IK = PredefinedExpr::Func; break; // [C99 6.4.2.2]\n  case tok::kw___FUNCTION__: IK = PredefinedExpr::Function; break;\n  case tok::kw___FUNCDNAME__: IK = PredefinedExpr::FuncDName; break; // [MS]\n  case tok::kw___FUNCSIG__: IK = PredefinedExpr::FuncSig; break; // [MS]\n  case tok::kw_L__FUNCTION__: IK = PredefinedExpr::LFunction; break; // [MS]\n  case tok::kw_L__FUNCSIG__: IK = PredefinedExpr::LFuncSig; break; // [MS]\n  case tok::kw___PRETTY_FUNCTION__: IK = PredefinedExpr::PrettyFunction; break;\n  }\n\n  return BuildPredefinedExpr(Loc, IK);\n}\n\nExprResult Sema::ActOnCharacterConstant(const Token &Tok, Scope *UDLScope) {\n  SmallString<16> CharBuffer;\n  bool Invalid = false;\n  StringRef ThisTok = PP.getSpelling(Tok, CharBuffer, &Invalid);\n  if (Invalid)\n    return ExprError();\n\n  CharLiteralParser Literal(ThisTok.begin(), ThisTok.end(), Tok.getLocation(),\n                            PP, Tok.getKind());\n  if (Literal.hadError())\n    return ExprError();\n\n  QualType Ty;\n  if (Literal.isWide())\n    Ty = Context.WideCharTy; // L'x' -> wchar_t in C and C++.\n  else if (Literal.isUTF8() && getLangOpts().Char8)\n    Ty = Context.Char8Ty; // u8'x' -> char8_t when it exists.\n  else if (Literal.isUTF16())\n    Ty = Context.Char16Ty; // u'x' -> char16_t in C11 and C++11.\n  else if (Literal.isUTF32())\n    Ty = Context.Char32Ty; // U'x' -> char32_t in C11 and C++11.\n  else if (!getLangOpts().CPlusPlus || Literal.isMultiChar())\n    Ty = Context.IntTy;   // 'x' -> int in C, 'wxyz' -> int in C++.\n  else\n    Ty = Context.CharTy;  // 'x' -> char in C++\n\n  CharacterLiteral::CharacterKind Kind = CharacterLiteral::Ascii;\n  if (Literal.isWide())\n    Kind = CharacterLiteral::Wide;\n  else if (Literal.isUTF16())\n    Kind = CharacterLiteral::UTF16;\n  else if (Literal.isUTF32())\n    Kind = CharacterLiteral::UTF32;\n  else if (Literal.isUTF8())\n    Kind = CharacterLiteral::UTF8;\n\n  Expr *Lit = new (Context) CharacterLiteral(Literal.getValue(), Kind, Ty,\n                                             Tok.getLocation());\n\n  if (Literal.getUDSuffix().empty())\n    return Lit;\n\n  // We're building a user-defined literal.\n  IdentifierInfo *UDSuffix = &Context.Idents.get(Literal.getUDSuffix());\n  SourceLocation UDSuffixLoc =\n    getUDSuffixLoc(*this, Tok.getLocation(), Literal.getUDSuffixOffset());\n\n  // Make sure we're allowed user-defined literals here.\n  if (!UDLScope)\n    return ExprError(Diag(UDSuffixLoc, diag::err_invalid_character_udl));\n\n  // C++11 [lex.ext]p6: The literal L is treated as a call of the form\n  //   operator \"\" X (ch)\n  return BuildCookedLiteralOperatorCall(*this, UDLScope, UDSuffix, UDSuffixLoc,\n                                        Lit, Tok.getLocation());\n}\n\nExprResult Sema::ActOnIntegerConstant(SourceLocation Loc, uint64_t Val) {\n  unsigned IntSize = Context.getTargetInfo().getIntWidth();\n  return IntegerLiteral::Create(Context, llvm::APInt(IntSize, Val),\n                                Context.IntTy, Loc);\n}\n\nstatic Expr *BuildFloatingLiteral(Sema &S, NumericLiteralParser &Literal,\n                                  QualType Ty, SourceLocation Loc) {\n  const llvm::fltSemantics &Format = S.Context.getFloatTypeSemantics(Ty);\n\n  using llvm::APFloat;\n  APFloat Val(Format);\n\n  APFloat::opStatus result = Literal.GetFloatValue(Val);\n\n  // Overflow is always an error, but underflow is only an error if\n  // we underflowed to zero (APFloat reports denormals as underflow).\n  if ((result & APFloat::opOverflow) ||\n      ((result & APFloat::opUnderflow) && Val.isZero())) {\n    unsigned diagnostic;\n    SmallString<20> buffer;\n    if (result & APFloat::opOverflow) {\n      diagnostic = diag::warn_float_overflow;\n      APFloat::getLargest(Format).toString(buffer);\n    } else {\n      diagnostic = diag::warn_float_underflow;\n      APFloat::getSmallest(Format).toString(buffer);\n    }\n\n    S.Diag(Loc, diagnostic)\n      << Ty\n      << StringRef(buffer.data(), buffer.size());\n  }\n\n  bool isExact = (result == APFloat::opOK);\n  return FloatingLiteral::Create(S.Context, Val, isExact, Ty, Loc);\n}\n\nbool Sema::CheckLoopHintExpr(Expr *E, SourceLocation Loc) {\n  assert(E && \"Invalid expression\");\n\n  if (E->isValueDependent())\n    return false;\n\n  QualType QT = E->getType();\n  if (!QT->isIntegerType() || QT->isBooleanType() || QT->isCharType()) {\n    Diag(E->getExprLoc(), diag::err_pragma_loop_invalid_argument_type) << QT;\n    return true;\n  }\n\n  llvm::APSInt ValueAPS;\n  ExprResult R = VerifyIntegerConstantExpression(E, &ValueAPS);\n\n  if (R.isInvalid())\n    return true;\n\n  bool ValueIsPositive = ValueAPS.isStrictlyPositive();\n  if (!ValueIsPositive || ValueAPS.getActiveBits() > 31) {\n    Diag(E->getExprLoc(), diag::err_pragma_loop_invalid_argument_value)\n        << ValueAPS.toString(10) << ValueIsPositive;\n    return true;\n  }\n\n  return false;\n}\n\nExprResult Sema::ActOnNumericConstant(const Token &Tok, Scope *UDLScope) {\n  // Fast path for a single digit (which is quite common).  A single digit\n  // cannot have a trigraph, escaped newline, radix prefix, or suffix.\n  if (Tok.getLength() == 1) {\n    const char Val = PP.getSpellingOfSingleCharacterNumericConstant(Tok);\n    return ActOnIntegerConstant(Tok.getLocation(), Val-'0');\n  }\n\n  SmallString<128> SpellingBuffer;\n  // NumericLiteralParser wants to overread by one character.  Add padding to\n  // the buffer in case the token is copied to the buffer.  If getSpelling()\n  // returns a StringRef to the memory buffer, it should have a null char at\n  // the EOF, so it is also safe.\n  SpellingBuffer.resize(Tok.getLength() + 1);\n\n  // Get the spelling of the token, which eliminates trigraphs, etc.\n  bool Invalid = false;\n  StringRef TokSpelling = PP.getSpelling(Tok, SpellingBuffer, &Invalid);\n  if (Invalid)\n    return ExprError();\n\n  NumericLiteralParser Literal(TokSpelling, Tok.getLocation(),\n                               PP.getSourceManager(), PP.getLangOpts(),\n                               PP.getTargetInfo(), PP.getDiagnostics());\n  if (Literal.hadError)\n    return ExprError();\n\n  if (Literal.hasUDSuffix()) {\n    // We're building a user-defined literal.\n    IdentifierInfo *UDSuffix = &Context.Idents.get(Literal.getUDSuffix());\n    SourceLocation UDSuffixLoc =\n      getUDSuffixLoc(*this, Tok.getLocation(), Literal.getUDSuffixOffset());\n\n    // Make sure we're allowed user-defined literals here.\n    if (!UDLScope)\n      return ExprError(Diag(UDSuffixLoc, diag::err_invalid_numeric_udl));\n\n    QualType CookedTy;\n    if (Literal.isFloatingLiteral()) {\n      // C++11 [lex.ext]p4: If S contains a literal operator with parameter type\n      // long double, the literal is treated as a call of the form\n      //   operator \"\" X (f L)\n      CookedTy = Context.LongDoubleTy;\n    } else {\n      // C++11 [lex.ext]p3: If S contains a literal operator with parameter type\n      // unsigned long long, the literal is treated as a call of the form\n      //   operator \"\" X (n ULL)\n      CookedTy = Context.UnsignedLongLongTy;\n    }\n\n    DeclarationName OpName =\n      Context.DeclarationNames.getCXXLiteralOperatorName(UDSuffix);\n    DeclarationNameInfo OpNameInfo(OpName, UDSuffixLoc);\n    OpNameInfo.setCXXLiteralOperatorNameLoc(UDSuffixLoc);\n\n    SourceLocation TokLoc = Tok.getLocation();\n\n    // Perform literal operator lookup to determine if we're building a raw\n    // literal or a cooked one.\n    LookupResult R(*this, OpName, UDSuffixLoc, LookupOrdinaryName);\n    switch (LookupLiteralOperator(UDLScope, R, CookedTy,\n                                  /*AllowRaw*/ true, /*AllowTemplate*/ true,\n                                  /*AllowStringTemplatePack*/ false,\n                                  /*DiagnoseMissing*/ !Literal.isImaginary)) {\n    case LOLR_ErrorNoDiagnostic:\n      // Lookup failure for imaginary constants isn't fatal, there's still the\n      // GNU extension producing _Complex types.\n      break;\n    case LOLR_Error:\n      return ExprError();\n    case LOLR_Cooked: {\n      Expr *Lit;\n      if (Literal.isFloatingLiteral()) {\n        Lit = BuildFloatingLiteral(*this, Literal, CookedTy, Tok.getLocation());\n      } else {\n        llvm::APInt ResultVal(Context.getTargetInfo().getLongLongWidth(), 0);\n        if (Literal.GetIntegerValue(ResultVal))\n          Diag(Tok.getLocation(), diag::err_integer_literal_too_large)\n              << /* Unsigned */ 1;\n        Lit = IntegerLiteral::Create(Context, ResultVal, CookedTy,\n                                     Tok.getLocation());\n      }\n      return BuildLiteralOperatorCall(R, OpNameInfo, Lit, TokLoc);\n    }\n\n    case LOLR_Raw: {\n      // C++11 [lit.ext]p3, p4: If S contains a raw literal operator, the\n      // literal is treated as a call of the form\n      //   operator \"\" X (\"n\")\n      unsigned Length = Literal.getUDSuffixOffset();\n      QualType StrTy = Context.getConstantArrayType(\n          Context.adjustStringLiteralBaseType(Context.CharTy.withConst()),\n          llvm::APInt(32, Length + 1), nullptr, ArrayType::Normal, 0);\n      Expr *Lit = StringLiteral::Create(\n          Context, StringRef(TokSpelling.data(), Length), StringLiteral::Ascii,\n          /*Pascal*/false, StrTy, &TokLoc, 1);\n      return BuildLiteralOperatorCall(R, OpNameInfo, Lit, TokLoc);\n    }\n\n    case LOLR_Template: {\n      // C++11 [lit.ext]p3, p4: Otherwise (S contains a literal operator\n      // template), L is treated as a call fo the form\n      //   operator \"\" X <'c1', 'c2', ... 'ck'>()\n      // where n is the source character sequence c1 c2 ... ck.\n      TemplateArgumentListInfo ExplicitArgs;\n      unsigned CharBits = Context.getIntWidth(Context.CharTy);\n      bool CharIsUnsigned = Context.CharTy->isUnsignedIntegerType();\n      llvm::APSInt Value(CharBits, CharIsUnsigned);\n      for (unsigned I = 0, N = Literal.getUDSuffixOffset(); I != N; ++I) {\n        Value = TokSpelling[I];\n        TemplateArgument Arg(Context, Value, Context.CharTy);\n        TemplateArgumentLocInfo ArgInfo;\n        ExplicitArgs.addArgument(TemplateArgumentLoc(Arg, ArgInfo));\n      }\n      return BuildLiteralOperatorCall(R, OpNameInfo, None, TokLoc,\n                                      &ExplicitArgs);\n    }\n    case LOLR_StringTemplatePack:\n      llvm_unreachable(\"unexpected literal operator lookup result\");\n    }\n  }\n\n  Expr *Res;\n\n  if (Literal.isFixedPointLiteral()) {\n    QualType Ty;\n\n    if (Literal.isAccum) {\n      if (Literal.isHalf) {\n        Ty = Context.ShortAccumTy;\n      } else if (Literal.isLong) {\n        Ty = Context.LongAccumTy;\n      } else {\n        Ty = Context.AccumTy;\n      }\n    } else if (Literal.isFract) {\n      if (Literal.isHalf) {\n        Ty = Context.ShortFractTy;\n      } else if (Literal.isLong) {\n        Ty = Context.LongFractTy;\n      } else {\n        Ty = Context.FractTy;\n      }\n    }\n\n    if (Literal.isUnsigned) Ty = Context.getCorrespondingUnsignedType(Ty);\n\n    bool isSigned = !Literal.isUnsigned;\n    unsigned scale = Context.getFixedPointScale(Ty);\n    unsigned bit_width = Context.getTypeInfo(Ty).Width;\n\n    llvm::APInt Val(bit_width, 0, isSigned);\n    bool Overflowed = Literal.GetFixedPointValue(Val, scale);\n    bool ValIsZero = Val.isNullValue() && !Overflowed;\n\n    auto MaxVal = Context.getFixedPointMax(Ty).getValue();\n    if (Literal.isFract && Val == MaxVal + 1 && !ValIsZero)\n      // Clause 6.4.4 - The value of a constant shall be in the range of\n      // representable values for its type, with exception for constants of a\n      // fract type with a value of exactly 1; such a constant shall denote\n      // the maximal value for the type.\n      --Val;\n    else if (Val.ugt(MaxVal) || Overflowed)\n      Diag(Tok.getLocation(), diag::err_too_large_for_fixed_point);\n\n    Res = FixedPointLiteral::CreateFromRawInt(Context, Val, Ty,\n                                              Tok.getLocation(), scale);\n  } else if (Literal.isFloatingLiteral()) {\n    QualType Ty;\n    if (Literal.isHalf){\n      if (getOpenCLOptions().isEnabled(\"cl_khr_fp16\"))\n        Ty = Context.HalfTy;\n      else {\n        Diag(Tok.getLocation(), diag::err_half_const_requires_fp16);\n        return ExprError();\n      }\n    } else if (Literal.isFloat)\n      Ty = Context.FloatTy;\n    else if (Literal.isLong)\n      Ty = Context.LongDoubleTy;\n    else if (Literal.isFloat16)\n      Ty = Context.Float16Ty;\n    else if (Literal.isFloat128)\n      Ty = Context.Float128Ty;\n    else\n      Ty = Context.DoubleTy;\n\n    Res = BuildFloatingLiteral(*this, Literal, Ty, Tok.getLocation());\n\n    if (Ty == Context.DoubleTy) {\n      if (getLangOpts().SinglePrecisionConstants) {\n        if (Ty->castAs<BuiltinType>()->getKind() != BuiltinType::Float) {\n          Res = ImpCastExprToType(Res, Context.FloatTy, CK_FloatingCast).get();\n        }\n      } else if (getLangOpts().OpenCL &&\n                 !getOpenCLOptions().isEnabled(\"cl_khr_fp64\")) {\n        // Impose single-precision float type when cl_khr_fp64 is not enabled.\n        Diag(Tok.getLocation(), diag::warn_double_const_requires_fp64);\n        Res = ImpCastExprToType(Res, Context.FloatTy, CK_FloatingCast).get();\n      }\n    }\n  } else if (!Literal.isIntegerLiteral()) {\n    return ExprError();\n  } else {\n    QualType Ty;\n\n    // 'long long' is a C99 or C++11 feature.\n    if (!getLangOpts().C99 && Literal.isLongLong) {\n      if (getLangOpts().CPlusPlus)\n        Diag(Tok.getLocation(),\n             getLangOpts().CPlusPlus11 ?\n             diag::warn_cxx98_compat_longlong : diag::ext_cxx11_longlong);\n      else\n        Diag(Tok.getLocation(), diag::ext_c99_longlong);\n    }\n\n    // Get the value in the widest-possible width.\n    unsigned MaxWidth = Context.getTargetInfo().getIntMaxTWidth();\n    llvm::APInt ResultVal(MaxWidth, 0);\n\n    if (Literal.GetIntegerValue(ResultVal)) {\n      // If this value didn't fit into uintmax_t, error and force to ull.\n      Diag(Tok.getLocation(), diag::err_integer_literal_too_large)\n          << /* Unsigned */ 1;\n      Ty = Context.UnsignedLongLongTy;\n      assert(Context.getTypeSize(Ty) == ResultVal.getBitWidth() &&\n             \"long long is not intmax_t?\");\n    } else {\n      // If this value fits into a ULL, try to figure out what else it fits into\n      // according to the rules of C99 6.4.4.1p5.\n\n      // Octal, Hexadecimal, and integers with a U suffix are allowed to\n      // be an unsigned int.\n      bool AllowUnsigned = Literal.isUnsigned || Literal.getRadix() != 10;\n\n      // Check from smallest to largest, picking the smallest type we can.\n      unsigned Width = 0;\n\n      // Microsoft specific integer suffixes are explicitly sized.\n      if (Literal.MicrosoftInteger) {\n        if (Literal.MicrosoftInteger == 8 && !Literal.isUnsigned) {\n          Width = 8;\n          Ty = Context.CharTy;\n        } else {\n          Width = Literal.MicrosoftInteger;\n          Ty = Context.getIntTypeForBitwidth(Width,\n                                             /*Signed=*/!Literal.isUnsigned);\n        }\n      }\n\n      if (Ty.isNull() && !Literal.isLong && !Literal.isLongLong) {\n        // Are int/unsigned possibilities?\n        unsigned IntSize = Context.getTargetInfo().getIntWidth();\n\n        // Does it fit in a unsigned int?\n        if (ResultVal.isIntN(IntSize)) {\n          // Does it fit in a signed int?\n          if (!Literal.isUnsigned && ResultVal[IntSize-1] == 0)\n            Ty = Context.IntTy;\n          else if (AllowUnsigned)\n            Ty = Context.UnsignedIntTy;\n          Width = IntSize;\n        }\n      }\n\n      // Are long/unsigned long possibilities?\n      if (Ty.isNull() && !Literal.isLongLong) {\n        unsigned LongSize = Context.getTargetInfo().getLongWidth();\n\n        // Does it fit in a unsigned long?\n        if (ResultVal.isIntN(LongSize)) {\n          // Does it fit in a signed long?\n          if (!Literal.isUnsigned && ResultVal[LongSize-1] == 0)\n            Ty = Context.LongTy;\n          else if (AllowUnsigned)\n            Ty = Context.UnsignedLongTy;\n          // Check according to the rules of C90 6.1.3.2p5. C++03 [lex.icon]p2\n          // is compatible.\n          else if (!getLangOpts().C99 && !getLangOpts().CPlusPlus11) {\n            const unsigned LongLongSize =\n                Context.getTargetInfo().getLongLongWidth();\n            Diag(Tok.getLocation(),\n                 getLangOpts().CPlusPlus\n                     ? Literal.isLong\n                           ? diag::warn_old_implicitly_unsigned_long_cxx\n                           : /*C++98 UB*/ diag::\n                                 ext_old_implicitly_unsigned_long_cxx\n                     : diag::warn_old_implicitly_unsigned_long)\n                << (LongLongSize > LongSize ? /*will have type 'long long'*/ 0\n                                            : /*will be ill-formed*/ 1);\n            Ty = Context.UnsignedLongTy;\n          }\n          Width = LongSize;\n        }\n      }\n\n      // Check long long if needed.\n      if (Ty.isNull()) {\n        unsigned LongLongSize = Context.getTargetInfo().getLongLongWidth();\n\n        // Does it fit in a unsigned long long?\n        if (ResultVal.isIntN(LongLongSize)) {\n          // Does it fit in a signed long long?\n          // To be compatible with MSVC, hex integer literals ending with the\n          // LL or i64 suffix are always signed in Microsoft mode.\n          if (!Literal.isUnsigned && (ResultVal[LongLongSize-1] == 0 ||\n              (getLangOpts().MSVCCompat && Literal.isLongLong)))\n            Ty = Context.LongLongTy;\n          else if (AllowUnsigned)\n            Ty = Context.UnsignedLongLongTy;\n          Width = LongLongSize;\n        }\n      }\n\n      // If we still couldn't decide a type, we probably have something that\n      // does not fit in a signed long long, but has no U suffix.\n      if (Ty.isNull()) {\n        Diag(Tok.getLocation(), diag::ext_integer_literal_too_large_for_signed);\n        Ty = Context.UnsignedLongLongTy;\n        Width = Context.getTargetInfo().getLongLongWidth();\n      }\n\n      if (ResultVal.getBitWidth() != Width)\n        ResultVal = ResultVal.trunc(Width);\n    }\n    Res = IntegerLiteral::Create(Context, ResultVal, Ty, Tok.getLocation());\n  }\n\n  // If this is an imaginary literal, create the ImaginaryLiteral wrapper.\n  if (Literal.isImaginary) {\n    Res = new (Context) ImaginaryLiteral(Res,\n                                        Context.getComplexType(Res->getType()));\n\n    Diag(Tok.getLocation(), diag::ext_imaginary_constant);\n  }\n  return Res;\n}\n\nExprResult Sema::ActOnParenExpr(SourceLocation L, SourceLocation R, Expr *E) {\n  assert(E && \"ActOnParenExpr() missing expr\");\n  return new (Context) ParenExpr(L, R, E);\n}\n\nstatic bool CheckVecStepTraitOperandType(Sema &S, QualType T,\n                                         SourceLocation Loc,\n                                         SourceRange ArgRange) {\n  // [OpenCL 1.1 6.11.12] \"The vec_step built-in function takes a built-in\n  // scalar or vector data type argument...\"\n  // Every built-in scalar type (OpenCL 1.1 6.1.1) is either an arithmetic\n  // type (C99 6.2.5p18) or void.\n  if (!(T->isArithmeticType() || T->isVoidType() || T->isVectorType())) {\n    S.Diag(Loc, diag::err_vecstep_non_scalar_vector_type)\n      << T << ArgRange;\n    return true;\n  }\n\n  assert((T->isVoidType() || !T->isIncompleteType()) &&\n         \"Scalar types should always be complete\");\n  return false;\n}\n\nstatic bool CheckExtensionTraitOperandType(Sema &S, QualType T,\n                                           SourceLocation Loc,\n                                           SourceRange ArgRange,\n                                           UnaryExprOrTypeTrait TraitKind) {\n  // Invalid types must be hard errors for SFINAE in C++.\n  if (S.LangOpts.CPlusPlus)\n    return true;\n\n  // C99 6.5.3.4p1:\n  if (T->isFunctionType() &&\n      (TraitKind == UETT_SizeOf || TraitKind == UETT_AlignOf ||\n       TraitKind == UETT_PreferredAlignOf)) {\n    // sizeof(function)/alignof(function) is allowed as an extension.\n    S.Diag(Loc, diag::ext_sizeof_alignof_function_type)\n        << getTraitSpelling(TraitKind) << ArgRange;\n    return false;\n  }\n\n  // Allow sizeof(void)/alignof(void) as an extension, unless in OpenCL where\n  // this is an error (OpenCL v1.1 s6.3.k)\n  if (T->isVoidType()) {\n    unsigned DiagID = S.LangOpts.OpenCL ? diag::err_opencl_sizeof_alignof_type\n                                        : diag::ext_sizeof_alignof_void_type;\n    S.Diag(Loc, DiagID) << getTraitSpelling(TraitKind) << ArgRange;\n    return false;\n  }\n\n  return true;\n}\n\nstatic bool CheckObjCTraitOperandConstraints(Sema &S, QualType T,\n                                             SourceLocation Loc,\n                                             SourceRange ArgRange,\n                                             UnaryExprOrTypeTrait TraitKind) {\n  // Reject sizeof(interface) and sizeof(interface<proto>) if the\n  // runtime doesn't allow it.\n  if (!S.LangOpts.ObjCRuntime.allowsSizeofAlignof() && T->isObjCObjectType()) {\n    S.Diag(Loc, diag::err_sizeof_nonfragile_interface)\n      << T << (TraitKind == UETT_SizeOf)\n      << ArgRange;\n    return true;\n  }\n\n  return false;\n}\n\n/// Check whether E is a pointer from a decayed array type (the decayed\n/// pointer type is equal to T) and emit a warning if it is.\nstatic void warnOnSizeofOnArrayDecay(Sema &S, SourceLocation Loc, QualType T,\n                                     Expr *E) {\n  // Don't warn if the operation changed the type.\n  if (T != E->getType())\n    return;\n\n  // Now look for array decays.\n  ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(E);\n  if (!ICE || ICE->getCastKind() != CK_ArrayToPointerDecay)\n    return;\n\n  S.Diag(Loc, diag::warn_sizeof_array_decay) << ICE->getSourceRange()\n                                             << ICE->getType()\n                                             << ICE->getSubExpr()->getType();\n}\n\n/// Check the constraints on expression operands to unary type expression\n/// and type traits.\n///\n/// Completes any types necessary and validates the constraints on the operand\n/// expression. The logic mostly mirrors the type-based overload, but may modify\n/// the expression as it completes the type for that expression through template\n/// instantiation, etc.\nbool Sema::CheckUnaryExprOrTypeTraitOperand(Expr *E,\n                                            UnaryExprOrTypeTrait ExprKind) {\n  QualType ExprTy = E->getType();\n  assert(!ExprTy->isReferenceType());\n\n  bool IsUnevaluatedOperand =\n      (ExprKind == UETT_SizeOf || ExprKind == UETT_AlignOf ||\n       ExprKind == UETT_PreferredAlignOf || ExprKind == UETT_VecStep);\n  if (IsUnevaluatedOperand) {\n    ExprResult Result = CheckUnevaluatedOperand(E);\n    if (Result.isInvalid())\n      return true;\n    E = Result.get();\n  }\n\n  // The operand for sizeof and alignof is in an unevaluated expression context,\n  // so side effects could result in unintended consequences.\n  // Exclude instantiation-dependent expressions, because 'sizeof' is sometimes\n  // used to build SFINAE gadgets.\n  // FIXME: Should we consider instantiation-dependent operands to 'alignof'?\n  if (IsUnevaluatedOperand && !inTemplateInstantiation() &&\n      !E->isInstantiationDependent() &&\n      E->HasSideEffects(Context, false))\n    Diag(E->getExprLoc(), diag::warn_side_effects_unevaluated_context);\n\n  if (ExprKind == UETT_VecStep)\n    return CheckVecStepTraitOperandType(*this, ExprTy, E->getExprLoc(),\n                                        E->getSourceRange());\n\n  // Explicitly list some types as extensions.\n  if (!CheckExtensionTraitOperandType(*this, ExprTy, E->getExprLoc(),\n                                      E->getSourceRange(), ExprKind))\n    return false;\n\n  // 'alignof' applied to an expression only requires the base element type of\n  // the expression to be complete. 'sizeof' requires the expression's type to\n  // be complete (and will attempt to complete it if it's an array of unknown\n  // bound).\n  if (ExprKind == UETT_AlignOf || ExprKind == UETT_PreferredAlignOf) {\n    if (RequireCompleteSizedType(\n            E->getExprLoc(), Context.getBaseElementType(E->getType()),\n            diag::err_sizeof_alignof_incomplete_or_sizeless_type,\n            getTraitSpelling(ExprKind), E->getSourceRange()))\n      return true;\n  } else {\n    if (RequireCompleteSizedExprType(\n            E, diag::err_sizeof_alignof_incomplete_or_sizeless_type,\n            getTraitSpelling(ExprKind), E->getSourceRange()))\n      return true;\n  }\n\n  // Completing the expression's type may have changed it.\n  ExprTy = E->getType();\n  assert(!ExprTy->isReferenceType());\n\n  if (ExprTy->isFunctionType()) {\n    Diag(E->getExprLoc(), diag::err_sizeof_alignof_function_type)\n        << getTraitSpelling(ExprKind) << E->getSourceRange();\n    return true;\n  }\n\n  if (CheckObjCTraitOperandConstraints(*this, ExprTy, E->getExprLoc(),\n                                       E->getSourceRange(), ExprKind))\n    return true;\n\n  if (ExprKind == UETT_SizeOf) {\n    if (DeclRefExpr *DeclRef = dyn_cast<DeclRefExpr>(E->IgnoreParens())) {\n      if (ParmVarDecl *PVD = dyn_cast<ParmVarDecl>(DeclRef->getFoundDecl())) {\n        QualType OType = PVD->getOriginalType();\n        QualType Type = PVD->getType();\n        if (Type->isPointerType() && OType->isArrayType()) {\n          Diag(E->getExprLoc(), diag::warn_sizeof_array_param)\n            << Type << OType;\n          Diag(PVD->getLocation(), diag::note_declared_at);\n        }\n      }\n    }\n\n    // Warn on \"sizeof(array op x)\" and \"sizeof(x op array)\", where the array\n    // decays into a pointer and returns an unintended result. This is most\n    // likely a typo for \"sizeof(array) op x\".\n    if (BinaryOperator *BO = dyn_cast<BinaryOperator>(E->IgnoreParens())) {\n      warnOnSizeofOnArrayDecay(*this, BO->getOperatorLoc(), BO->getType(),\n                               BO->getLHS());\n      warnOnSizeofOnArrayDecay(*this, BO->getOperatorLoc(), BO->getType(),\n                               BO->getRHS());\n    }\n  }\n\n  return false;\n}\n\n/// Check the constraints on operands to unary expression and type\n/// traits.\n///\n/// This will complete any types necessary, and validate the various constraints\n/// on those operands.\n///\n/// The UsualUnaryConversions() function is *not* called by this routine.\n/// C99 6.3.2.1p[2-4] all state:\n///   Except when it is the operand of the sizeof operator ...\n///\n/// C++ [expr.sizeof]p4\n///   The lvalue-to-rvalue, array-to-pointer, and function-to-pointer\n///   standard conversions are not applied to the operand of sizeof.\n///\n/// This policy is followed for all of the unary trait expressions.\nbool Sema::CheckUnaryExprOrTypeTraitOperand(QualType ExprType,\n                                            SourceLocation OpLoc,\n                                            SourceRange ExprRange,\n                                            UnaryExprOrTypeTrait ExprKind) {\n  if (ExprType->isDependentType())\n    return false;\n\n  // C++ [expr.sizeof]p2:\n  //     When applied to a reference or a reference type, the result\n  //     is the size of the referenced type.\n  // C++11 [expr.alignof]p3:\n  //     When alignof is applied to a reference type, the result\n  //     shall be the alignment of the referenced type.\n  if (const ReferenceType *Ref = ExprType->getAs<ReferenceType>())\n    ExprType = Ref->getPointeeType();\n\n  // C11 6.5.3.4/3, C++11 [expr.alignof]p3:\n  //   When alignof or _Alignof is applied to an array type, the result\n  //   is the alignment of the element type.\n  if (ExprKind == UETT_AlignOf || ExprKind == UETT_PreferredAlignOf ||\n      ExprKind == UETT_OpenMPRequiredSimdAlign)\n    ExprType = Context.getBaseElementType(ExprType);\n\n  if (ExprKind == UETT_VecStep)\n    return CheckVecStepTraitOperandType(*this, ExprType, OpLoc, ExprRange);\n\n  // Explicitly list some types as extensions.\n  if (!CheckExtensionTraitOperandType(*this, ExprType, OpLoc, ExprRange,\n                                      ExprKind))\n    return false;\n\n  if (RequireCompleteSizedType(\n          OpLoc, ExprType, diag::err_sizeof_alignof_incomplete_or_sizeless_type,\n          getTraitSpelling(ExprKind), ExprRange))\n    return true;\n\n  if (ExprType->isFunctionType()) {\n    Diag(OpLoc, diag::err_sizeof_alignof_function_type)\n        << getTraitSpelling(ExprKind) << ExprRange;\n    return true;\n  }\n\n  if (CheckObjCTraitOperandConstraints(*this, ExprType, OpLoc, ExprRange,\n                                       ExprKind))\n    return true;\n\n  return false;\n}\n\nstatic bool CheckAlignOfExpr(Sema &S, Expr *E, UnaryExprOrTypeTrait ExprKind) {\n  // Cannot know anything else if the expression is dependent.\n  if (E->isTypeDependent())\n    return false;\n\n  if (E->getObjectKind() == OK_BitField) {\n    S.Diag(E->getExprLoc(), diag::err_sizeof_alignof_typeof_bitfield)\n       << 1 << E->getSourceRange();\n    return true;\n  }\n\n  ValueDecl *D = nullptr;\n  Expr *Inner = E->IgnoreParens();\n  if (DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(Inner)) {\n    D = DRE->getDecl();\n  } else if (MemberExpr *ME = dyn_cast<MemberExpr>(Inner)) {\n    D = ME->getMemberDecl();\n  }\n\n  // If it's a field, require the containing struct to have a\n  // complete definition so that we can compute the layout.\n  //\n  // This can happen in C++11 onwards, either by naming the member\n  // in a way that is not transformed into a member access expression\n  // (in an unevaluated operand, for instance), or by naming the member\n  // in a trailing-return-type.\n  //\n  // For the record, since __alignof__ on expressions is a GCC\n  // extension, GCC seems to permit this but always gives the\n  // nonsensical answer 0.\n  //\n  // We don't really need the layout here --- we could instead just\n  // directly check for all the appropriate alignment-lowing\n  // attributes --- but that would require duplicating a lot of\n  // logic that just isn't worth duplicating for such a marginal\n  // use-case.\n  if (FieldDecl *FD = dyn_cast_or_null<FieldDecl>(D)) {\n    // Fast path this check, since we at least know the record has a\n    // definition if we can find a member of it.\n    if (!FD->getParent()->isCompleteDefinition()) {\n      S.Diag(E->getExprLoc(), diag::err_alignof_member_of_incomplete_type)\n        << E->getSourceRange();\n      return true;\n    }\n\n    // Otherwise, if it's a field, and the field doesn't have\n    // reference type, then it must have a complete type (or be a\n    // flexible array member, which we explicitly want to\n    // white-list anyway), which makes the following checks trivial.\n    if (!FD->getType()->isReferenceType())\n      return false;\n  }\n\n  return S.CheckUnaryExprOrTypeTraitOperand(E, ExprKind);\n}\n\nbool Sema::CheckVecStepExpr(Expr *E) {\n  E = E->IgnoreParens();\n\n  // Cannot know anything else if the expression is dependent.\n  if (E->isTypeDependent())\n    return false;\n\n  return CheckUnaryExprOrTypeTraitOperand(E, UETT_VecStep);\n}\n\nstatic void captureVariablyModifiedType(ASTContext &Context, QualType T,\n                                        CapturingScopeInfo *CSI) {\n  assert(T->isVariablyModifiedType());\n  assert(CSI != nullptr);\n\n  // We're going to walk down into the type and look for VLA expressions.\n  do {\n    const Type *Ty = T.getTypePtr();\n    switch (Ty->getTypeClass()) {\n#define TYPE(Class, Base)\n#define ABSTRACT_TYPE(Class, Base)\n#define NON_CANONICAL_TYPE(Class, Base)\n#define DEPENDENT_TYPE(Class, Base) case Type::Class:\n#define NON_CANONICAL_UNLESS_DEPENDENT_TYPE(Class, Base)\n#include \"clang/AST/TypeNodes.inc\"\n      T = QualType();\n      break;\n    // These types are never variably-modified.\n    case Type::Builtin:\n    case Type::Complex:\n    case Type::Vector:\n    case Type::ExtVector:\n    case Type::ConstantMatrix:\n    case Type::Record:\n    case Type::Enum:\n    case Type::Elaborated:\n    case Type::TemplateSpecialization:\n    case Type::ObjCObject:\n    case Type::ObjCInterface:\n    case Type::ObjCObjectPointer:\n    case Type::ObjCTypeParam:\n    case Type::Pipe:\n    case Type::ExtInt:\n      llvm_unreachable(\"type class is never variably-modified!\");\n    case Type::Adjusted:\n      T = cast<AdjustedType>(Ty)->getOriginalType();\n      break;\n    case Type::Decayed:\n      T = cast<DecayedType>(Ty)->getPointeeType();\n      break;\n    case Type::Pointer:\n      T = cast<PointerType>(Ty)->getPointeeType();\n      break;\n    case Type::BlockPointer:\n      T = cast<BlockPointerType>(Ty)->getPointeeType();\n      break;\n    case Type::LValueReference:\n    case Type::RValueReference:\n      T = cast<ReferenceType>(Ty)->getPointeeType();\n      break;\n    case Type::MemberPointer:\n      T = cast<MemberPointerType>(Ty)->getPointeeType();\n      break;\n    case Type::ConstantArray:\n    case Type::IncompleteArray:\n      // Losing element qualification here is fine.\n      T = cast<ArrayType>(Ty)->getElementType();\n      break;\n    case Type::VariableArray: {\n      // Losing element qualification here is fine.\n      const VariableArrayType *VAT = cast<VariableArrayType>(Ty);\n\n      // Unknown size indication requires no size computation.\n      // Otherwise, evaluate and record it.\n      auto Size = VAT->getSizeExpr();\n      if (Size && !CSI->isVLATypeCaptured(VAT) &&\n          (isa<CapturedRegionScopeInfo>(CSI) || isa<LambdaScopeInfo>(CSI)))\n        CSI->addVLATypeCapture(Size->getExprLoc(), VAT, Context.getSizeType());\n\n      T = VAT->getElementType();\n      break;\n    }\n    case Type::FunctionProto:\n    case Type::FunctionNoProto:\n      T = cast<FunctionType>(Ty)->getReturnType();\n      break;\n    case Type::Paren:\n    case Type::TypeOf:\n    case Type::UnaryTransform:\n    case Type::Attributed:\n    case Type::SubstTemplateTypeParm:\n    case Type::MacroQualified:\n      // Keep walking after single level desugaring.\n      T = T.getSingleStepDesugaredType(Context);\n      break;\n    case Type::Typedef:\n      T = cast<TypedefType>(Ty)->desugar();\n      break;\n    case Type::Decltype:\n      T = cast<DecltypeType>(Ty)->desugar();\n      break;\n    case Type::Auto:\n    case Type::DeducedTemplateSpecialization:\n      T = cast<DeducedType>(Ty)->getDeducedType();\n      break;\n    case Type::TypeOfExpr:\n      T = cast<TypeOfExprType>(Ty)->getUnderlyingExpr()->getType();\n      break;\n    case Type::Atomic:\n      T = cast<AtomicType>(Ty)->getValueType();\n      break;\n    }\n  } while (!T.isNull() && T->isVariablyModifiedType());\n}\n\n/// Build a sizeof or alignof expression given a type operand.\nExprResult\nSema::CreateUnaryExprOrTypeTraitExpr(TypeSourceInfo *TInfo,\n                                     SourceLocation OpLoc,\n                                     UnaryExprOrTypeTrait ExprKind,\n                                     SourceRange R) {\n  if (!TInfo)\n    return ExprError();\n\n  QualType T = TInfo->getType();\n\n  if (!T->isDependentType() &&\n      CheckUnaryExprOrTypeTraitOperand(T, OpLoc, R, ExprKind))\n    return ExprError();\n\n  if (T->isVariablyModifiedType() && FunctionScopes.size() > 1) {\n    if (auto *TT = T->getAs<TypedefType>()) {\n      for (auto I = FunctionScopes.rbegin(),\n                E = std::prev(FunctionScopes.rend());\n           I != E; ++I) {\n        auto *CSI = dyn_cast<CapturingScopeInfo>(*I);\n        if (CSI == nullptr)\n          break;\n        DeclContext *DC = nullptr;\n        if (auto *LSI = dyn_cast<LambdaScopeInfo>(CSI))\n          DC = LSI->CallOperator;\n        else if (auto *CRSI = dyn_cast<CapturedRegionScopeInfo>(CSI))\n          DC = CRSI->TheCapturedDecl;\n        else if (auto *BSI = dyn_cast<BlockScopeInfo>(CSI))\n          DC = BSI->TheDecl;\n        if (DC) {\n          if (DC->containsDecl(TT->getDecl()))\n            break;\n          captureVariablyModifiedType(Context, T, CSI);\n        }\n      }\n    }\n  }\n\n  // C99 6.5.3.4p4: the type (an unsigned integer type) is size_t.\n  return new (Context) UnaryExprOrTypeTraitExpr(\n      ExprKind, TInfo, Context.getSizeType(), OpLoc, R.getEnd());\n}\n\n/// Build a sizeof or alignof expression given an expression\n/// operand.\nExprResult\nSema::CreateUnaryExprOrTypeTraitExpr(Expr *E, SourceLocation OpLoc,\n                                     UnaryExprOrTypeTrait ExprKind) {\n  ExprResult PE = CheckPlaceholderExpr(E);\n  if (PE.isInvalid())\n    return ExprError();\n\n  E = PE.get();\n\n  // Verify that the operand is valid.\n  bool isInvalid = false;\n  if (E->isTypeDependent()) {\n    // Delay type-checking for type-dependent expressions.\n  } else if (ExprKind == UETT_AlignOf || ExprKind == UETT_PreferredAlignOf) {\n    isInvalid = CheckAlignOfExpr(*this, E, ExprKind);\n  } else if (ExprKind == UETT_VecStep) {\n    isInvalid = CheckVecStepExpr(E);\n  } else if (ExprKind == UETT_OpenMPRequiredSimdAlign) {\n      Diag(E->getExprLoc(), diag::err_openmp_default_simd_align_expr);\n      isInvalid = true;\n  } else if (E->refersToBitField()) {  // C99 6.5.3.4p1.\n    Diag(E->getExprLoc(), diag::err_sizeof_alignof_typeof_bitfield) << 0;\n    isInvalid = true;\n  } else {\n    isInvalid = CheckUnaryExprOrTypeTraitOperand(E, UETT_SizeOf);\n  }\n\n  if (isInvalid)\n    return ExprError();\n\n  if (ExprKind == UETT_SizeOf && E->getType()->isVariableArrayType()) {\n    PE = TransformToPotentiallyEvaluated(E);\n    if (PE.isInvalid()) return ExprError();\n    E = PE.get();\n  }\n\n  // C99 6.5.3.4p4: the type (an unsigned integer type) is size_t.\n  return new (Context) UnaryExprOrTypeTraitExpr(\n      ExprKind, E, Context.getSizeType(), OpLoc, E->getSourceRange().getEnd());\n}\n\n/// ActOnUnaryExprOrTypeTraitExpr - Handle @c sizeof(type) and @c sizeof @c\n/// expr and the same for @c alignof and @c __alignof\n/// Note that the ArgRange is invalid if isType is false.\nExprResult\nSema::ActOnUnaryExprOrTypeTraitExpr(SourceLocation OpLoc,\n                                    UnaryExprOrTypeTrait ExprKind, bool IsType,\n                                    void *TyOrEx, SourceRange ArgRange) {\n  // If error parsing type, ignore.\n  if (!TyOrEx) return ExprError();\n\n  if (IsType) {\n    TypeSourceInfo *TInfo;\n    (void) GetTypeFromParser(ParsedType::getFromOpaquePtr(TyOrEx), &TInfo);\n    return CreateUnaryExprOrTypeTraitExpr(TInfo, OpLoc, ExprKind, ArgRange);\n  }\n\n  Expr *ArgEx = (Expr *)TyOrEx;\n  ExprResult Result = CreateUnaryExprOrTypeTraitExpr(ArgEx, OpLoc, ExprKind);\n  return Result;\n}\n\nstatic QualType CheckRealImagOperand(Sema &S, ExprResult &V, SourceLocation Loc,\n                                     bool IsReal) {\n  if (V.get()->isTypeDependent())\n    return S.Context.DependentTy;\n\n  // _Real and _Imag are only l-values for normal l-values.\n  if (V.get()->getObjectKind() != OK_Ordinary) {\n    V = S.DefaultLvalueConversion(V.get());\n    if (V.isInvalid())\n      return QualType();\n  }\n\n  // These operators return the element type of a complex type.\n  if (const ComplexType *CT = V.get()->getType()->getAs<ComplexType>())\n    return CT->getElementType();\n\n  // Otherwise they pass through real integer and floating point types here.\n  if (V.get()->getType()->isArithmeticType())\n    return V.get()->getType();\n\n  // Test for placeholders.\n  ExprResult PR = S.CheckPlaceholderExpr(V.get());\n  if (PR.isInvalid()) return QualType();\n  if (PR.get() != V.get()) {\n    V = PR;\n    return CheckRealImagOperand(S, V, Loc, IsReal);\n  }\n\n  // Reject anything else.\n  S.Diag(Loc, diag::err_realimag_invalid_type) << V.get()->getType()\n    << (IsReal ? \"__real\" : \"__imag\");\n  return QualType();\n}\n\n\n\nExprResult\nSema::ActOnPostfixUnaryOp(Scope *S, SourceLocation OpLoc,\n                          tok::TokenKind Kind, Expr *Input) {\n  UnaryOperatorKind Opc;\n  switch (Kind) {\n  default: llvm_unreachable(\"Unknown unary op!\");\n  case tok::plusplus:   Opc = UO_PostInc; break;\n  case tok::minusminus: Opc = UO_PostDec; break;\n  }\n\n  // Since this might is a postfix expression, get rid of ParenListExprs.\n  ExprResult Result = MaybeConvertParenListExprToParenExpr(S, Input);\n  if (Result.isInvalid()) return ExprError();\n  Input = Result.get();\n\n  return BuildUnaryOp(S, OpLoc, Opc, Input);\n}\n\n/// Diagnose if arithmetic on the given ObjC pointer is illegal.\n///\n/// \\return true on error\nstatic bool checkArithmeticOnObjCPointer(Sema &S,\n                                         SourceLocation opLoc,\n                                         Expr *op) {\n  assert(op->getType()->isObjCObjectPointerType());\n  if (S.LangOpts.ObjCRuntime.allowsPointerArithmetic() &&\n      !S.LangOpts.ObjCSubscriptingLegacyRuntime)\n    return false;\n\n  S.Diag(opLoc, diag::err_arithmetic_nonfragile_interface)\n    << op->getType()->castAs<ObjCObjectPointerType>()->getPointeeType()\n    << op->getSourceRange();\n  return true;\n}\n\nstatic bool isMSPropertySubscriptExpr(Sema &S, Expr *Base) {\n  auto *BaseNoParens = Base->IgnoreParens();\n  if (auto *MSProp = dyn_cast<MSPropertyRefExpr>(BaseNoParens))\n    return MSProp->getPropertyDecl()->getType()->isArrayType();\n  return isa<MSPropertySubscriptExpr>(BaseNoParens);\n}\n\nExprResult\nSema::ActOnArraySubscriptExpr(Scope *S, Expr *base, SourceLocation lbLoc,\n                              Expr *idx, SourceLocation rbLoc) {\n  if (base && !base->getType().isNull() &&\n      base->getType()->isSpecificPlaceholderType(BuiltinType::OMPArraySection))\n    return ActOnOMPArraySectionExpr(base, lbLoc, idx, SourceLocation(),\n                                    SourceLocation(), /*Length*/ nullptr,\n                                    /*Stride=*/nullptr, rbLoc);\n\n  // Since this might be a postfix expression, get rid of ParenListExprs.\n  if (isa<ParenListExpr>(base)) {\n    ExprResult result = MaybeConvertParenListExprToParenExpr(S, base);\n    if (result.isInvalid()) return ExprError();\n    base = result.get();\n  }\n\n  // Check if base and idx form a MatrixSubscriptExpr.\n  //\n  // Helper to check for comma expressions, which are not allowed as indices for\n  // matrix subscript expressions.\n  auto CheckAndReportCommaError = [this, base, rbLoc](Expr *E) {\n    if (isa<BinaryOperator>(E) && cast<BinaryOperator>(E)->isCommaOp()) {\n      Diag(E->getExprLoc(), diag::err_matrix_subscript_comma)\n          << SourceRange(base->getBeginLoc(), rbLoc);\n      return true;\n    }\n    return false;\n  };\n  // The matrix subscript operator ([][])is considered a single operator.\n  // Separating the index expressions by parenthesis is not allowed.\n  if (base->getType()->isSpecificPlaceholderType(\n          BuiltinType::IncompleteMatrixIdx) &&\n      !isa<MatrixSubscriptExpr>(base)) {\n    Diag(base->getExprLoc(), diag::err_matrix_separate_incomplete_index)\n        << SourceRange(base->getBeginLoc(), rbLoc);\n    return ExprError();\n  }\n  // If the base is a MatrixSubscriptExpr, try to create a new\n  // MatrixSubscriptExpr.\n  auto *matSubscriptE = dyn_cast<MatrixSubscriptExpr>(base);\n  if (matSubscriptE) {\n    if (CheckAndReportCommaError(idx))\n      return ExprError();\n\n    assert(matSubscriptE->isIncomplete() &&\n           \"base has to be an incomplete matrix subscript\");\n    return CreateBuiltinMatrixSubscriptExpr(\n        matSubscriptE->getBase(), matSubscriptE->getRowIdx(), idx, rbLoc);\n  }\n\n  // Handle any non-overload placeholder types in the base and index\n  // expressions.  We can't handle overloads here because the other\n  // operand might be an overloadable type, in which case the overload\n  // resolution for the operator overload should get the first crack\n  // at the overload.\n  bool IsMSPropertySubscript = false;\n  if (base->getType()->isNonOverloadPlaceholderType()) {\n    IsMSPropertySubscript = isMSPropertySubscriptExpr(*this, base);\n    if (!IsMSPropertySubscript) {\n      ExprResult result = CheckPlaceholderExpr(base);\n      if (result.isInvalid())\n        return ExprError();\n      base = result.get();\n    }\n  }\n\n  // If the base is a matrix type, try to create a new MatrixSubscriptExpr.\n  if (base->getType()->isMatrixType()) {\n    if (CheckAndReportCommaError(idx))\n      return ExprError();\n\n    return CreateBuiltinMatrixSubscriptExpr(base, idx, nullptr, rbLoc);\n  }\n\n  // A comma-expression as the index is deprecated in C++2a onwards.\n  if (getLangOpts().CPlusPlus20 &&\n      ((isa<BinaryOperator>(idx) && cast<BinaryOperator>(idx)->isCommaOp()) ||\n       (isa<CXXOperatorCallExpr>(idx) &&\n        cast<CXXOperatorCallExpr>(idx)->getOperator() == OO_Comma))) {\n    Diag(idx->getExprLoc(), diag::warn_deprecated_comma_subscript)\n        << SourceRange(base->getBeginLoc(), rbLoc);\n  }\n\n  if (idx->getType()->isNonOverloadPlaceholderType()) {\n    ExprResult result = CheckPlaceholderExpr(idx);\n    if (result.isInvalid()) return ExprError();\n    idx = result.get();\n  }\n\n  // Build an unanalyzed expression if either operand is type-dependent.\n  if (getLangOpts().CPlusPlus &&\n      (base->isTypeDependent() || idx->isTypeDependent())) {\n    return new (Context) ArraySubscriptExpr(base, idx, Context.DependentTy,\n                                            VK_LValue, OK_Ordinary, rbLoc);\n  }\n\n  // MSDN, property (C++)\n  // https://msdn.microsoft.com/en-us/library/yhfk0thd(v=vs.120).aspx\n  // This attribute can also be used in the declaration of an empty array in a\n  // class or structure definition. For example:\n  // __declspec(property(get=GetX, put=PutX)) int x[];\n  // The above statement indicates that x[] can be used with one or more array\n  // indices. In this case, i=p->x[a][b] will be turned into i=p->GetX(a, b),\n  // and p->x[a][b] = i will be turned into p->PutX(a, b, i);\n  if (IsMSPropertySubscript) {\n    // Build MS property subscript expression if base is MS property reference\n    // or MS property subscript.\n    return new (Context) MSPropertySubscriptExpr(\n        base, idx, Context.PseudoObjectTy, VK_LValue, OK_Ordinary, rbLoc);\n  }\n\n  // Use C++ overloaded-operator rules if either operand has record\n  // type.  The spec says to do this if either type is *overloadable*,\n  // but enum types can't declare subscript operators or conversion\n  // operators, so there's nothing interesting for overload resolution\n  // to do if there aren't any record types involved.\n  //\n  // ObjC pointers have their own subscripting logic that is not tied\n  // to overload resolution and so should not take this path.\n  if (getLangOpts().CPlusPlus &&\n      (base->getType()->isRecordType() ||\n       (!base->getType()->isObjCObjectPointerType() &&\n        idx->getType()->isRecordType()))) {\n    return CreateOverloadedArraySubscriptExpr(lbLoc, rbLoc, base, idx);\n  }\n\n  ExprResult Res = CreateBuiltinArraySubscriptExpr(base, lbLoc, idx, rbLoc);\n\n  if (!Res.isInvalid() && isa<ArraySubscriptExpr>(Res.get()))\n    CheckSubscriptAccessOfNoDeref(cast<ArraySubscriptExpr>(Res.get()));\n\n  return Res;\n}\n\nExprResult Sema::tryConvertExprToType(Expr *E, QualType Ty) {\n  InitializedEntity Entity = InitializedEntity::InitializeTemporary(Ty);\n  InitializationKind Kind =\n      InitializationKind::CreateCopy(E->getBeginLoc(), SourceLocation());\n  InitializationSequence InitSeq(*this, Entity, Kind, E);\n  return InitSeq.Perform(*this, Entity, Kind, E);\n}\n\nExprResult Sema::CreateBuiltinMatrixSubscriptExpr(Expr *Base, Expr *RowIdx,\n                                                  Expr *ColumnIdx,\n                                                  SourceLocation RBLoc) {\n  ExprResult BaseR = CheckPlaceholderExpr(Base);\n  if (BaseR.isInvalid())\n    return BaseR;\n  Base = BaseR.get();\n\n  ExprResult RowR = CheckPlaceholderExpr(RowIdx);\n  if (RowR.isInvalid())\n    return RowR;\n  RowIdx = RowR.get();\n\n  if (!ColumnIdx)\n    return new (Context) MatrixSubscriptExpr(\n        Base, RowIdx, ColumnIdx, Context.IncompleteMatrixIdxTy, RBLoc);\n\n  // Build an unanalyzed expression if any of the operands is type-dependent.\n  if (Base->isTypeDependent() || RowIdx->isTypeDependent() ||\n      ColumnIdx->isTypeDependent())\n    return new (Context) MatrixSubscriptExpr(Base, RowIdx, ColumnIdx,\n                                             Context.DependentTy, RBLoc);\n\n  ExprResult ColumnR = CheckPlaceholderExpr(ColumnIdx);\n  if (ColumnR.isInvalid())\n    return ColumnR;\n  ColumnIdx = ColumnR.get();\n\n  // Check that IndexExpr is an integer expression. If it is a constant\n  // expression, check that it is less than Dim (= the number of elements in the\n  // corresponding dimension).\n  auto IsIndexValid = [&](Expr *IndexExpr, unsigned Dim,\n                          bool IsColumnIdx) -> Expr * {\n    if (!IndexExpr->getType()->isIntegerType() &&\n        !IndexExpr->isTypeDependent()) {\n      Diag(IndexExpr->getBeginLoc(), diag::err_matrix_index_not_integer)\n          << IsColumnIdx;\n      return nullptr;\n    }\n\n    if (Optional<llvm::APSInt> Idx =\n            IndexExpr->getIntegerConstantExpr(Context)) {\n      if ((*Idx < 0 || *Idx >= Dim)) {\n        Diag(IndexExpr->getBeginLoc(), diag::err_matrix_index_outside_range)\n            << IsColumnIdx << Dim;\n        return nullptr;\n      }\n    }\n\n    ExprResult ConvExpr =\n        tryConvertExprToType(IndexExpr, Context.getSizeType());\n    assert(!ConvExpr.isInvalid() &&\n           \"should be able to convert any integer type to size type\");\n    return ConvExpr.get();\n  };\n\n  auto *MTy = Base->getType()->getAs<ConstantMatrixType>();\n  RowIdx = IsIndexValid(RowIdx, MTy->getNumRows(), false);\n  ColumnIdx = IsIndexValid(ColumnIdx, MTy->getNumColumns(), true);\n  if (!RowIdx || !ColumnIdx)\n    return ExprError();\n\n  return new (Context) MatrixSubscriptExpr(Base, RowIdx, ColumnIdx,\n                                           MTy->getElementType(), RBLoc);\n}\n\nvoid Sema::CheckAddressOfNoDeref(const Expr *E) {\n  ExpressionEvaluationContextRecord &LastRecord = ExprEvalContexts.back();\n  const Expr *StrippedExpr = E->IgnoreParenImpCasts();\n\n  // For expressions like `&(*s).b`, the base is recorded and what should be\n  // checked.\n  const MemberExpr *Member = nullptr;\n  while ((Member = dyn_cast<MemberExpr>(StrippedExpr)) && !Member->isArrow())\n    StrippedExpr = Member->getBase()->IgnoreParenImpCasts();\n\n  LastRecord.PossibleDerefs.erase(StrippedExpr);\n}\n\nvoid Sema::CheckSubscriptAccessOfNoDeref(const ArraySubscriptExpr *E) {\n  if (isUnevaluatedContext())\n    return;\n\n  QualType ResultTy = E->getType();\n  ExpressionEvaluationContextRecord &LastRecord = ExprEvalContexts.back();\n\n  // Bail if the element is an array since it is not memory access.\n  if (isa<ArrayType>(ResultTy))\n    return;\n\n  if (ResultTy->hasAttr(attr::NoDeref)) {\n    LastRecord.PossibleDerefs.insert(E);\n    return;\n  }\n\n  // Check if the base type is a pointer to a member access of a struct\n  // marked with noderef.\n  const Expr *Base = E->getBase();\n  QualType BaseTy = Base->getType();\n  if (!(isa<ArrayType>(BaseTy) || isa<PointerType>(BaseTy)))\n    // Not a pointer access\n    return;\n\n  const MemberExpr *Member = nullptr;\n  while ((Member = dyn_cast<MemberExpr>(Base->IgnoreParenCasts())) &&\n         Member->isArrow())\n    Base = Member->getBase();\n\n  if (const auto *Ptr = dyn_cast<PointerType>(Base->getType())) {\n    if (Ptr->getPointeeType()->hasAttr(attr::NoDeref))\n      LastRecord.PossibleDerefs.insert(E);\n  }\n}\n\nExprResult Sema::ActOnOMPArraySectionExpr(Expr *Base, SourceLocation LBLoc,\n                                          Expr *LowerBound,\n                                          SourceLocation ColonLocFirst,\n                                          SourceLocation ColonLocSecond,\n                                          Expr *Length, Expr *Stride,\n                                          SourceLocation RBLoc) {\n  if (Base->getType()->isPlaceholderType() &&\n      !Base->getType()->isSpecificPlaceholderType(\n          BuiltinType::OMPArraySection)) {\n    ExprResult Result = CheckPlaceholderExpr(Base);\n    if (Result.isInvalid())\n      return ExprError();\n    Base = Result.get();\n  }\n  if (LowerBound && LowerBound->getType()->isNonOverloadPlaceholderType()) {\n    ExprResult Result = CheckPlaceholderExpr(LowerBound);\n    if (Result.isInvalid())\n      return ExprError();\n    Result = DefaultLvalueConversion(Result.get());\n    if (Result.isInvalid())\n      return ExprError();\n    LowerBound = Result.get();\n  }\n  if (Length && Length->getType()->isNonOverloadPlaceholderType()) {\n    ExprResult Result = CheckPlaceholderExpr(Length);\n    if (Result.isInvalid())\n      return ExprError();\n    Result = DefaultLvalueConversion(Result.get());\n    if (Result.isInvalid())\n      return ExprError();\n    Length = Result.get();\n  }\n  if (Stride && Stride->getType()->isNonOverloadPlaceholderType()) {\n    ExprResult Result = CheckPlaceholderExpr(Stride);\n    if (Result.isInvalid())\n      return ExprError();\n    Result = DefaultLvalueConversion(Result.get());\n    if (Result.isInvalid())\n      return ExprError();\n    Stride = Result.get();\n  }\n\n  // Build an unanalyzed expression if either operand is type-dependent.\n  if (Base->isTypeDependent() ||\n      (LowerBound &&\n       (LowerBound->isTypeDependent() || LowerBound->isValueDependent())) ||\n      (Length && (Length->isTypeDependent() || Length->isValueDependent())) ||\n      (Stride && (Stride->isTypeDependent() || Stride->isValueDependent()))) {\n    return new (Context) OMPArraySectionExpr(\n        Base, LowerBound, Length, Stride, Context.DependentTy, VK_LValue,\n        OK_Ordinary, ColonLocFirst, ColonLocSecond, RBLoc);\n  }\n\n  // Perform default conversions.\n  QualType OriginalTy = OMPArraySectionExpr::getBaseOriginalType(Base);\n  QualType ResultTy;\n  if (OriginalTy->isAnyPointerType()) {\n    ResultTy = OriginalTy->getPointeeType();\n  } else if (OriginalTy->isArrayType()) {\n    ResultTy = OriginalTy->getAsArrayTypeUnsafe()->getElementType();\n  } else {\n    return ExprError(\n        Diag(Base->getExprLoc(), diag::err_omp_typecheck_section_value)\n        << Base->getSourceRange());\n  }\n  // C99 6.5.2.1p1\n  if (LowerBound) {\n    auto Res = PerformOpenMPImplicitIntegerConversion(LowerBound->getExprLoc(),\n                                                      LowerBound);\n    if (Res.isInvalid())\n      return ExprError(Diag(LowerBound->getExprLoc(),\n                            diag::err_omp_typecheck_section_not_integer)\n                       << 0 << LowerBound->getSourceRange());\n    LowerBound = Res.get();\n\n    if (LowerBound->getType()->isSpecificBuiltinType(BuiltinType::Char_S) ||\n        LowerBound->getType()->isSpecificBuiltinType(BuiltinType::Char_U))\n      Diag(LowerBound->getExprLoc(), diag::warn_omp_section_is_char)\n          << 0 << LowerBound->getSourceRange();\n  }\n  if (Length) {\n    auto Res =\n        PerformOpenMPImplicitIntegerConversion(Length->getExprLoc(), Length);\n    if (Res.isInvalid())\n      return ExprError(Diag(Length->getExprLoc(),\n                            diag::err_omp_typecheck_section_not_integer)\n                       << 1 << Length->getSourceRange());\n    Length = Res.get();\n\n    if (Length->getType()->isSpecificBuiltinType(BuiltinType::Char_S) ||\n        Length->getType()->isSpecificBuiltinType(BuiltinType::Char_U))\n      Diag(Length->getExprLoc(), diag::warn_omp_section_is_char)\n          << 1 << Length->getSourceRange();\n  }\n  if (Stride) {\n    ExprResult Res =\n        PerformOpenMPImplicitIntegerConversion(Stride->getExprLoc(), Stride);\n    if (Res.isInvalid())\n      return ExprError(Diag(Stride->getExprLoc(),\n                            diag::err_omp_typecheck_section_not_integer)\n                       << 1 << Stride->getSourceRange());\n    Stride = Res.get();\n\n    if (Stride->getType()->isSpecificBuiltinType(BuiltinType::Char_S) ||\n        Stride->getType()->isSpecificBuiltinType(BuiltinType::Char_U))\n      Diag(Stride->getExprLoc(), diag::warn_omp_section_is_char)\n          << 1 << Stride->getSourceRange();\n  }\n\n  // C99 6.5.2.1p1: \"shall have type \"pointer to *object* type\". Similarly,\n  // C++ [expr.sub]p1: The type \"T\" shall be a completely-defined object\n  // type. Note that functions are not objects, and that (in C99 parlance)\n  // incomplete types are not object types.\n  if (ResultTy->isFunctionType()) {\n    Diag(Base->getExprLoc(), diag::err_omp_section_function_type)\n        << ResultTy << Base->getSourceRange();\n    return ExprError();\n  }\n\n  if (RequireCompleteType(Base->getExprLoc(), ResultTy,\n                          diag::err_omp_section_incomplete_type, Base))\n    return ExprError();\n\n  if (LowerBound && !OriginalTy->isAnyPointerType()) {\n    Expr::EvalResult Result;\n    if (LowerBound->EvaluateAsInt(Result, Context)) {\n      // OpenMP 5.0, [2.1.5 Array Sections]\n      // The array section must be a subset of the original array.\n      llvm::APSInt LowerBoundValue = Result.Val.getInt();\n      if (LowerBoundValue.isNegative()) {\n        Diag(LowerBound->getExprLoc(), diag::err_omp_section_not_subset_of_array)\n            << LowerBound->getSourceRange();\n        return ExprError();\n      }\n    }\n  }\n\n  if (Length) {\n    Expr::EvalResult Result;\n    if (Length->EvaluateAsInt(Result, Context)) {\n      // OpenMP 5.0, [2.1.5 Array Sections]\n      // The length must evaluate to non-negative integers.\n      llvm::APSInt LengthValue = Result.Val.getInt();\n      if (LengthValue.isNegative()) {\n        Diag(Length->getExprLoc(), diag::err_omp_section_length_negative)\n            << LengthValue.toString(/*Radix=*/10, /*Signed=*/true)\n            << Length->getSourceRange();\n        return ExprError();\n      }\n    }\n  } else if (ColonLocFirst.isValid() &&\n             (OriginalTy.isNull() || (!OriginalTy->isConstantArrayType() &&\n                                      !OriginalTy->isVariableArrayType()))) {\n    // OpenMP 5.0, [2.1.5 Array Sections]\n    // When the size of the array dimension is not known, the length must be\n    // specified explicitly.\n    Diag(ColonLocFirst, diag::err_omp_section_length_undefined)\n        << (!OriginalTy.isNull() && OriginalTy->isArrayType());\n    return ExprError();\n  }\n\n  if (Stride) {\n    Expr::EvalResult Result;\n    if (Stride->EvaluateAsInt(Result, Context)) {\n      // OpenMP 5.0, [2.1.5 Array Sections]\n      // The stride must evaluate to a positive integer.\n      llvm::APSInt StrideValue = Result.Val.getInt();\n      if (!StrideValue.isStrictlyPositive()) {\n        Diag(Stride->getExprLoc(), diag::err_omp_section_stride_non_positive)\n            << StrideValue.toString(/*Radix=*/10, /*Signed=*/true)\n            << Stride->getSourceRange();\n        return ExprError();\n      }\n    }\n  }\n\n  if (!Base->getType()->isSpecificPlaceholderType(\n          BuiltinType::OMPArraySection)) {\n    ExprResult Result = DefaultFunctionArrayLvalueConversion(Base);\n    if (Result.isInvalid())\n      return ExprError();\n    Base = Result.get();\n  }\n  return new (Context) OMPArraySectionExpr(\n      Base, LowerBound, Length, Stride, Context.OMPArraySectionTy, VK_LValue,\n      OK_Ordinary, ColonLocFirst, ColonLocSecond, RBLoc);\n}\n\nExprResult Sema::ActOnOMPArrayShapingExpr(Expr *Base, SourceLocation LParenLoc,\n                                          SourceLocation RParenLoc,\n                                          ArrayRef<Expr *> Dims,\n                                          ArrayRef<SourceRange> Brackets) {\n  if (Base->getType()->isPlaceholderType()) {\n    ExprResult Result = CheckPlaceholderExpr(Base);\n    if (Result.isInvalid())\n      return ExprError();\n    Result = DefaultLvalueConversion(Result.get());\n    if (Result.isInvalid())\n      return ExprError();\n    Base = Result.get();\n  }\n  QualType BaseTy = Base->getType();\n  // Delay analysis of the types/expressions if instantiation/specialization is\n  // required.\n  if (!BaseTy->isPointerType() && Base->isTypeDependent())\n    return OMPArrayShapingExpr::Create(Context, Context.DependentTy, Base,\n                                       LParenLoc, RParenLoc, Dims, Brackets);\n  if (!BaseTy->isPointerType() ||\n      (!Base->isTypeDependent() &&\n       BaseTy->getPointeeType()->isIncompleteType()))\n    return ExprError(Diag(Base->getExprLoc(),\n                          diag::err_omp_non_pointer_type_array_shaping_base)\n                     << Base->getSourceRange());\n\n  SmallVector<Expr *, 4> NewDims;\n  bool ErrorFound = false;\n  for (Expr *Dim : Dims) {\n    if (Dim->getType()->isPlaceholderType()) {\n      ExprResult Result = CheckPlaceholderExpr(Dim);\n      if (Result.isInvalid()) {\n        ErrorFound = true;\n        continue;\n      }\n      Result = DefaultLvalueConversion(Result.get());\n      if (Result.isInvalid()) {\n        ErrorFound = true;\n        continue;\n      }\n      Dim = Result.get();\n    }\n    if (!Dim->isTypeDependent()) {\n      ExprResult Result =\n          PerformOpenMPImplicitIntegerConversion(Dim->getExprLoc(), Dim);\n      if (Result.isInvalid()) {\n        ErrorFound = true;\n        Diag(Dim->getExprLoc(), diag::err_omp_typecheck_shaping_not_integer)\n            << Dim->getSourceRange();\n        continue;\n      }\n      Dim = Result.get();\n      Expr::EvalResult EvResult;\n      if (!Dim->isValueDependent() && Dim->EvaluateAsInt(EvResult, Context)) {\n        // OpenMP 5.0, [2.1.4 Array Shaping]\n        // Each si is an integral type expression that must evaluate to a\n        // positive integer.\n        llvm::APSInt Value = EvResult.Val.getInt();\n        if (!Value.isStrictlyPositive()) {\n          Diag(Dim->getExprLoc(), diag::err_omp_shaping_dimension_not_positive)\n              << Value.toString(/*Radix=*/10, /*Signed=*/true)\n              << Dim->getSourceRange();\n          ErrorFound = true;\n          continue;\n        }\n      }\n    }\n    NewDims.push_back(Dim);\n  }\n  if (ErrorFound)\n    return ExprError();\n  return OMPArrayShapingExpr::Create(Context, Context.OMPArrayShapingTy, Base,\n                                     LParenLoc, RParenLoc, NewDims, Brackets);\n}\n\nExprResult Sema::ActOnOMPIteratorExpr(Scope *S, SourceLocation IteratorKwLoc,\n                                      SourceLocation LLoc, SourceLocation RLoc,\n                                      ArrayRef<OMPIteratorData> Data) {\n  SmallVector<OMPIteratorExpr::IteratorDefinition, 4> ID;\n  bool IsCorrect = true;\n  for (const OMPIteratorData &D : Data) {\n    TypeSourceInfo *TInfo = nullptr;\n    SourceLocation StartLoc;\n    QualType DeclTy;\n    if (!D.Type.getAsOpaquePtr()) {\n      // OpenMP 5.0, 2.1.6 Iterators\n      // In an iterator-specifier, if the iterator-type is not specified then\n      // the type of that iterator is of int type.\n      DeclTy = Context.IntTy;\n      StartLoc = D.DeclIdentLoc;\n    } else {\n      DeclTy = GetTypeFromParser(D.Type, &TInfo);\n      StartLoc = TInfo->getTypeLoc().getBeginLoc();\n    }\n\n    bool IsDeclTyDependent = DeclTy->isDependentType() ||\n                             DeclTy->containsUnexpandedParameterPack() ||\n                             DeclTy->isInstantiationDependentType();\n    if (!IsDeclTyDependent) {\n      if (!DeclTy->isIntegralType(Context) && !DeclTy->isAnyPointerType()) {\n        // OpenMP 5.0, 2.1.6 Iterators, Restrictions, C/C++\n        // The iterator-type must be an integral or pointer type.\n        Diag(StartLoc, diag::err_omp_iterator_not_integral_or_pointer)\n            << DeclTy;\n        IsCorrect = false;\n        continue;\n      }\n      if (DeclTy.isConstant(Context)) {\n        // OpenMP 5.0, 2.1.6 Iterators, Restrictions, C/C++\n        // The iterator-type must not be const qualified.\n        Diag(StartLoc, diag::err_omp_iterator_not_integral_or_pointer)\n            << DeclTy;\n        IsCorrect = false;\n        continue;\n      }\n    }\n\n    // Iterator declaration.\n    assert(D.DeclIdent && \"Identifier expected.\");\n    // Always try to create iterator declarator to avoid extra error messages\n    // about unknown declarations use.\n    auto *VD = VarDecl::Create(Context, CurContext, StartLoc, D.DeclIdentLoc,\n                               D.DeclIdent, DeclTy, TInfo, SC_None);\n    VD->setImplicit();\n    if (S) {\n      // Check for conflicting previous declaration.\n      DeclarationNameInfo NameInfo(VD->getDeclName(), D.DeclIdentLoc);\n      LookupResult Previous(*this, NameInfo, LookupOrdinaryName,\n                            ForVisibleRedeclaration);\n      Previous.suppressDiagnostics();\n      LookupName(Previous, S);\n\n      FilterLookupForScope(Previous, CurContext, S, /*ConsiderLinkage=*/false,\n                           /*AllowInlineNamespace=*/false);\n      if (!Previous.empty()) {\n        NamedDecl *Old = Previous.getRepresentativeDecl();\n        Diag(D.DeclIdentLoc, diag::err_redefinition) << VD->getDeclName();\n        Diag(Old->getLocation(), diag::note_previous_definition);\n      } else {\n        PushOnScopeChains(VD, S);\n      }\n    } else {\n      CurContext->addDecl(VD);\n    }\n    Expr *Begin = D.Range.Begin;\n    if (!IsDeclTyDependent && Begin && !Begin->isTypeDependent()) {\n      ExprResult BeginRes =\n          PerformImplicitConversion(Begin, DeclTy, AA_Converting);\n      Begin = BeginRes.get();\n    }\n    Expr *End = D.Range.End;\n    if (!IsDeclTyDependent && End && !End->isTypeDependent()) {\n      ExprResult EndRes = PerformImplicitConversion(End, DeclTy, AA_Converting);\n      End = EndRes.get();\n    }\n    Expr *Step = D.Range.Step;\n    if (!IsDeclTyDependent && Step && !Step->isTypeDependent()) {\n      if (!Step->getType()->isIntegralType(Context)) {\n        Diag(Step->getExprLoc(), diag::err_omp_iterator_step_not_integral)\n            << Step << Step->getSourceRange();\n        IsCorrect = false;\n        continue;\n      }\n      Optional<llvm::APSInt> Result = Step->getIntegerConstantExpr(Context);\n      // OpenMP 5.0, 2.1.6 Iterators, Restrictions\n      // If the step expression of a range-specification equals zero, the\n      // behavior is unspecified.\n      if (Result && Result->isNullValue()) {\n        Diag(Step->getExprLoc(), diag::err_omp_iterator_step_constant_zero)\n            << Step << Step->getSourceRange();\n        IsCorrect = false;\n        continue;\n      }\n    }\n    if (!Begin || !End || !IsCorrect) {\n      IsCorrect = false;\n      continue;\n    }\n    OMPIteratorExpr::IteratorDefinition &IDElem = ID.emplace_back();\n    IDElem.IteratorDecl = VD;\n    IDElem.AssignmentLoc = D.AssignLoc;\n    IDElem.Range.Begin = Begin;\n    IDElem.Range.End = End;\n    IDElem.Range.Step = Step;\n    IDElem.ColonLoc = D.ColonLoc;\n    IDElem.SecondColonLoc = D.SecColonLoc;\n  }\n  if (!IsCorrect) {\n    // Invalidate all created iterator declarations if error is found.\n    for (const OMPIteratorExpr::IteratorDefinition &D : ID) {\n      if (Decl *ID = D.IteratorDecl)\n        ID->setInvalidDecl();\n    }\n    return ExprError();\n  }\n  SmallVector<OMPIteratorHelperData, 4> Helpers;\n  if (!CurContext->isDependentContext()) {\n    // Build number of ityeration for each iteration range.\n    // Ni = ((Stepi > 0) ? ((Endi + Stepi -1 - Begini)/Stepi) :\n    // ((Begini-Stepi-1-Endi) / -Stepi);\n    for (OMPIteratorExpr::IteratorDefinition &D : ID) {\n      // (Endi - Begini)\n      ExprResult Res = CreateBuiltinBinOp(D.AssignmentLoc, BO_Sub, D.Range.End,\n                                          D.Range.Begin);\n      if(!Res.isUsable()) {\n        IsCorrect = false;\n        continue;\n      }\n      ExprResult St, St1;\n      if (D.Range.Step) {\n        St = D.Range.Step;\n        // (Endi - Begini) + Stepi\n        Res = CreateBuiltinBinOp(D.AssignmentLoc, BO_Add, Res.get(), St.get());\n        if (!Res.isUsable()) {\n          IsCorrect = false;\n          continue;\n        }\n        // (Endi - Begini) + Stepi - 1\n        Res =\n            CreateBuiltinBinOp(D.AssignmentLoc, BO_Sub, Res.get(),\n                               ActOnIntegerConstant(D.AssignmentLoc, 1).get());\n        if (!Res.isUsable()) {\n          IsCorrect = false;\n          continue;\n        }\n        // ((Endi - Begini) + Stepi - 1) / Stepi\n        Res = CreateBuiltinBinOp(D.AssignmentLoc, BO_Div, Res.get(), St.get());\n        if (!Res.isUsable()) {\n          IsCorrect = false;\n          continue;\n        }\n        St1 = CreateBuiltinUnaryOp(D.AssignmentLoc, UO_Minus, D.Range.Step);\n        // (Begini - Endi)\n        ExprResult Res1 = CreateBuiltinBinOp(D.AssignmentLoc, BO_Sub,\n                                             D.Range.Begin, D.Range.End);\n        if (!Res1.isUsable()) {\n          IsCorrect = false;\n          continue;\n        }\n        // (Begini - Endi) - Stepi\n        Res1 =\n            CreateBuiltinBinOp(D.AssignmentLoc, BO_Add, Res1.get(), St1.get());\n        if (!Res1.isUsable()) {\n          IsCorrect = false;\n          continue;\n        }\n        // (Begini - Endi) - Stepi - 1\n        Res1 =\n            CreateBuiltinBinOp(D.AssignmentLoc, BO_Sub, Res1.get(),\n                               ActOnIntegerConstant(D.AssignmentLoc, 1).get());\n        if (!Res1.isUsable()) {\n          IsCorrect = false;\n          continue;\n        }\n        // ((Begini - Endi) - Stepi - 1) / (-Stepi)\n        Res1 =\n            CreateBuiltinBinOp(D.AssignmentLoc, BO_Div, Res1.get(), St1.get());\n        if (!Res1.isUsable()) {\n          IsCorrect = false;\n          continue;\n        }\n        // Stepi > 0.\n        ExprResult CmpRes =\n            CreateBuiltinBinOp(D.AssignmentLoc, BO_GT, D.Range.Step,\n                               ActOnIntegerConstant(D.AssignmentLoc, 0).get());\n        if (!CmpRes.isUsable()) {\n          IsCorrect = false;\n          continue;\n        }\n        Res = ActOnConditionalOp(D.AssignmentLoc, D.AssignmentLoc, CmpRes.get(),\n                                 Res.get(), Res1.get());\n        if (!Res.isUsable()) {\n          IsCorrect = false;\n          continue;\n        }\n      }\n      Res = ActOnFinishFullExpr(Res.get(), /*DiscardedValue=*/false);\n      if (!Res.isUsable()) {\n        IsCorrect = false;\n        continue;\n      }\n\n      // Build counter update.\n      // Build counter.\n      auto *CounterVD =\n          VarDecl::Create(Context, CurContext, D.IteratorDecl->getBeginLoc(),\n                          D.IteratorDecl->getBeginLoc(), nullptr,\n                          Res.get()->getType(), nullptr, SC_None);\n      CounterVD->setImplicit();\n      ExprResult RefRes =\n          BuildDeclRefExpr(CounterVD, CounterVD->getType(), VK_LValue,\n                           D.IteratorDecl->getBeginLoc());\n      // Build counter update.\n      // I = Begini + counter * Stepi;\n      ExprResult UpdateRes;\n      if (D.Range.Step) {\n        UpdateRes = CreateBuiltinBinOp(\n            D.AssignmentLoc, BO_Mul,\n            DefaultLvalueConversion(RefRes.get()).get(), St.get());\n      } else {\n        UpdateRes = DefaultLvalueConversion(RefRes.get());\n      }\n      if (!UpdateRes.isUsable()) {\n        IsCorrect = false;\n        continue;\n      }\n      UpdateRes = CreateBuiltinBinOp(D.AssignmentLoc, BO_Add, D.Range.Begin,\n                                     UpdateRes.get());\n      if (!UpdateRes.isUsable()) {\n        IsCorrect = false;\n        continue;\n      }\n      ExprResult VDRes =\n          BuildDeclRefExpr(cast<VarDecl>(D.IteratorDecl),\n                           cast<VarDecl>(D.IteratorDecl)->getType(), VK_LValue,\n                           D.IteratorDecl->getBeginLoc());\n      UpdateRes = CreateBuiltinBinOp(D.AssignmentLoc, BO_Assign, VDRes.get(),\n                                     UpdateRes.get());\n      if (!UpdateRes.isUsable()) {\n        IsCorrect = false;\n        continue;\n      }\n      UpdateRes =\n          ActOnFinishFullExpr(UpdateRes.get(), /*DiscardedValue=*/true);\n      if (!UpdateRes.isUsable()) {\n        IsCorrect = false;\n        continue;\n      }\n      ExprResult CounterUpdateRes =\n          CreateBuiltinUnaryOp(D.AssignmentLoc, UO_PreInc, RefRes.get());\n      if (!CounterUpdateRes.isUsable()) {\n        IsCorrect = false;\n        continue;\n      }\n      CounterUpdateRes =\n          ActOnFinishFullExpr(CounterUpdateRes.get(), /*DiscardedValue=*/true);\n      if (!CounterUpdateRes.isUsable()) {\n        IsCorrect = false;\n        continue;\n      }\n      OMPIteratorHelperData &HD = Helpers.emplace_back();\n      HD.CounterVD = CounterVD;\n      HD.Upper = Res.get();\n      HD.Update = UpdateRes.get();\n      HD.CounterUpdate = CounterUpdateRes.get();\n    }\n  } else {\n    Helpers.assign(ID.size(), {});\n  }\n  if (!IsCorrect) {\n    // Invalidate all created iterator declarations if error is found.\n    for (const OMPIteratorExpr::IteratorDefinition &D : ID) {\n      if (Decl *ID = D.IteratorDecl)\n        ID->setInvalidDecl();\n    }\n    return ExprError();\n  }\n  return OMPIteratorExpr::Create(Context, Context.OMPIteratorTy, IteratorKwLoc,\n                                 LLoc, RLoc, ID, Helpers);\n}\n\nExprResult\nSema::CreateBuiltinArraySubscriptExpr(Expr *Base, SourceLocation LLoc,\n                                      Expr *Idx, SourceLocation RLoc) {\n  Expr *LHSExp = Base;\n  Expr *RHSExp = Idx;\n\n  ExprValueKind VK = VK_LValue;\n  ExprObjectKind OK = OK_Ordinary;\n\n  // Per C++ core issue 1213, the result is an xvalue if either operand is\n  // a non-lvalue array, and an lvalue otherwise.\n  if (getLangOpts().CPlusPlus11) {\n    for (auto *Op : {LHSExp, RHSExp}) {\n      Op = Op->IgnoreImplicit();\n      if (Op->getType()->isArrayType() && !Op->isLValue())\n        VK = VK_XValue;\n    }\n  }\n\n  // Perform default conversions.\n  if (!LHSExp->getType()->getAs<VectorType>()) {\n    ExprResult Result = DefaultFunctionArrayLvalueConversion(LHSExp);\n    if (Result.isInvalid())\n      return ExprError();\n    LHSExp = Result.get();\n  }\n  ExprResult Result = DefaultFunctionArrayLvalueConversion(RHSExp);\n  if (Result.isInvalid())\n    return ExprError();\n  RHSExp = Result.get();\n\n  QualType LHSTy = LHSExp->getType(), RHSTy = RHSExp->getType();\n\n  // C99 6.5.2.1p2: the expression e1[e2] is by definition precisely equivalent\n  // to the expression *((e1)+(e2)). This means the array \"Base\" may actually be\n  // in the subscript position. As a result, we need to derive the array base\n  // and index from the expression types.\n  Expr *BaseExpr, *IndexExpr;\n  QualType ResultType;\n  if (LHSTy->isDependentType() || RHSTy->isDependentType()) {\n    BaseExpr = LHSExp;\n    IndexExpr = RHSExp;\n    ResultType = Context.DependentTy;\n  } else if (const PointerType *PTy = LHSTy->getAs<PointerType>()) {\n    BaseExpr = LHSExp;\n    IndexExpr = RHSExp;\n    ResultType = PTy->getPointeeType();\n  } else if (const ObjCObjectPointerType *PTy =\n               LHSTy->getAs<ObjCObjectPointerType>()) {\n    BaseExpr = LHSExp;\n    IndexExpr = RHSExp;\n\n    // Use custom logic if this should be the pseudo-object subscript\n    // expression.\n    if (!LangOpts.isSubscriptPointerArithmetic())\n      return BuildObjCSubscriptExpression(RLoc, BaseExpr, IndexExpr, nullptr,\n                                          nullptr);\n\n    ResultType = PTy->getPointeeType();\n  } else if (const PointerType *PTy = RHSTy->getAs<PointerType>()) {\n     // Handle the uncommon case of \"123[Ptr]\".\n    BaseExpr = RHSExp;\n    IndexExpr = LHSExp;\n    ResultType = PTy->getPointeeType();\n  } else if (const ObjCObjectPointerType *PTy =\n               RHSTy->getAs<ObjCObjectPointerType>()) {\n     // Handle the uncommon case of \"123[Ptr]\".\n    BaseExpr = RHSExp;\n    IndexExpr = LHSExp;\n    ResultType = PTy->getPointeeType();\n    if (!LangOpts.isSubscriptPointerArithmetic()) {\n      Diag(LLoc, diag::err_subscript_nonfragile_interface)\n        << ResultType << BaseExpr->getSourceRange();\n      return ExprError();\n    }\n  } else if (const VectorType *VTy = LHSTy->getAs<VectorType>()) {\n    BaseExpr = LHSExp;    // vectors: V[123]\n    IndexExpr = RHSExp;\n    // We apply C++ DR1213 to vector subscripting too.\n    if (getLangOpts().CPlusPlus11 && LHSExp->getValueKind() == VK_RValue) {\n      ExprResult Materialized = TemporaryMaterializationConversion(LHSExp);\n      if (Materialized.isInvalid())\n        return ExprError();\n      LHSExp = Materialized.get();\n    }\n    VK = LHSExp->getValueKind();\n    if (VK != VK_RValue)\n      OK = OK_VectorComponent;\n\n    ResultType = VTy->getElementType();\n    QualType BaseType = BaseExpr->getType();\n    Qualifiers BaseQuals = BaseType.getQualifiers();\n    Qualifiers MemberQuals = ResultType.getQualifiers();\n    Qualifiers Combined = BaseQuals + MemberQuals;\n    if (Combined != MemberQuals)\n      ResultType = Context.getQualifiedType(ResultType, Combined);\n  } else if (LHSTy->isArrayType()) {\n    // If we see an array that wasn't promoted by\n    // DefaultFunctionArrayLvalueConversion, it must be an array that\n    // wasn't promoted because of the C90 rule that doesn't\n    // allow promoting non-lvalue arrays.  Warn, then\n    // force the promotion here.\n    Diag(LHSExp->getBeginLoc(), diag::ext_subscript_non_lvalue)\n        << LHSExp->getSourceRange();\n    LHSExp = ImpCastExprToType(LHSExp, Context.getArrayDecayedType(LHSTy),\n                               CK_ArrayToPointerDecay).get();\n    LHSTy = LHSExp->getType();\n\n    BaseExpr = LHSExp;\n    IndexExpr = RHSExp;\n    ResultType = LHSTy->getAs<PointerType>()->getPointeeType();\n  } else if (RHSTy->isArrayType()) {\n    // Same as previous, except for 123[f().a] case\n    Diag(RHSExp->getBeginLoc(), diag::ext_subscript_non_lvalue)\n        << RHSExp->getSourceRange();\n    RHSExp = ImpCastExprToType(RHSExp, Context.getArrayDecayedType(RHSTy),\n                               CK_ArrayToPointerDecay).get();\n    RHSTy = RHSExp->getType();\n\n    BaseExpr = RHSExp;\n    IndexExpr = LHSExp;\n    ResultType = RHSTy->getAs<PointerType>()->getPointeeType();\n  } else {\n    return ExprError(Diag(LLoc, diag::err_typecheck_subscript_value)\n       << LHSExp->getSourceRange() << RHSExp->getSourceRange());\n  }\n  // C99 6.5.2.1p1\n  if (!IndexExpr->getType()->isIntegerType() && !IndexExpr->isTypeDependent())\n    return ExprError(Diag(LLoc, diag::err_typecheck_subscript_not_integer)\n                     << IndexExpr->getSourceRange());\n\n  if ((IndexExpr->getType()->isSpecificBuiltinType(BuiltinType::Char_S) ||\n       IndexExpr->getType()->isSpecificBuiltinType(BuiltinType::Char_U))\n         && !IndexExpr->isTypeDependent())\n    Diag(LLoc, diag::warn_subscript_is_char) << IndexExpr->getSourceRange();\n\n  // C99 6.5.2.1p1: \"shall have type \"pointer to *object* type\". Similarly,\n  // C++ [expr.sub]p1: The type \"T\" shall be a completely-defined object\n  // type. Note that Functions are not objects, and that (in C99 parlance)\n  // incomplete types are not object types.\n  if (ResultType->isFunctionType()) {\n    Diag(BaseExpr->getBeginLoc(), diag::err_subscript_function_type)\n        << ResultType << BaseExpr->getSourceRange();\n    return ExprError();\n  }\n\n  if (ResultType->isVoidType() && !getLangOpts().CPlusPlus) {\n    // GNU extension: subscripting on pointer to void\n    Diag(LLoc, diag::ext_gnu_subscript_void_type)\n      << BaseExpr->getSourceRange();\n\n    // C forbids expressions of unqualified void type from being l-values.\n    // See IsCForbiddenLValueType.\n    if (!ResultType.hasQualifiers()) VK = VK_RValue;\n  } else if (!ResultType->isDependentType() &&\n             RequireCompleteSizedType(\n                 LLoc, ResultType,\n                 diag::err_subscript_incomplete_or_sizeless_type, BaseExpr))\n    return ExprError();\n\n  assert(VK == VK_RValue || LangOpts.CPlusPlus ||\n         !ResultType.isCForbiddenLValueType());\n\n  if (LHSExp->IgnoreParenImpCasts()->getType()->isVariablyModifiedType() &&\n      FunctionScopes.size() > 1) {\n    if (auto *TT =\n            LHSExp->IgnoreParenImpCasts()->getType()->getAs<TypedefType>()) {\n      for (auto I = FunctionScopes.rbegin(),\n                E = std::prev(FunctionScopes.rend());\n           I != E; ++I) {\n        auto *CSI = dyn_cast<CapturingScopeInfo>(*I);\n        if (CSI == nullptr)\n          break;\n        DeclContext *DC = nullptr;\n        if (auto *LSI = dyn_cast<LambdaScopeInfo>(CSI))\n          DC = LSI->CallOperator;\n        else if (auto *CRSI = dyn_cast<CapturedRegionScopeInfo>(CSI))\n          DC = CRSI->TheCapturedDecl;\n        else if (auto *BSI = dyn_cast<BlockScopeInfo>(CSI))\n          DC = BSI->TheDecl;\n        if (DC) {\n          if (DC->containsDecl(TT->getDecl()))\n            break;\n          captureVariablyModifiedType(\n              Context, LHSExp->IgnoreParenImpCasts()->getType(), CSI);\n        }\n      }\n    }\n  }\n\n  return new (Context)\n      ArraySubscriptExpr(LHSExp, RHSExp, ResultType, VK, OK, RLoc);\n}\n\nbool Sema::CheckCXXDefaultArgExpr(SourceLocation CallLoc, FunctionDecl *FD,\n                                  ParmVarDecl *Param) {\n  if (Param->hasUnparsedDefaultArg()) {\n    // If we've already cleared out the location for the default argument,\n    // that means we're parsing it right now.\n    if (!UnparsedDefaultArgLocs.count(Param)) {\n      Diag(Param->getBeginLoc(), diag::err_recursive_default_argument) << FD;\n      Diag(CallLoc, diag::note_recursive_default_argument_used_here);\n      Param->setInvalidDecl();\n      return true;\n    }\n\n    Diag(CallLoc, diag::err_use_of_default_argument_to_function_declared_later)\n        << FD << cast<CXXRecordDecl>(FD->getDeclContext());\n    Diag(UnparsedDefaultArgLocs[Param],\n         diag::note_default_argument_declared_here);\n    return true;\n  }\n\n  if (Param->hasUninstantiatedDefaultArg() &&\n      InstantiateDefaultArgument(CallLoc, FD, Param))\n    return true;\n\n  assert(Param->hasInit() && \"default argument but no initializer?\");\n\n  // If the default expression creates temporaries, we need to\n  // push them to the current stack of expression temporaries so they'll\n  // be properly destroyed.\n  // FIXME: We should really be rebuilding the default argument with new\n  // bound temporaries; see the comment in PR5810.\n  // We don't need to do that with block decls, though, because\n  // blocks in default argument expression can never capture anything.\n  if (auto Init = dyn_cast<ExprWithCleanups>(Param->getInit())) {\n    // Set the \"needs cleanups\" bit regardless of whether there are\n    // any explicit objects.\n    Cleanup.setExprNeedsCleanups(Init->cleanupsHaveSideEffects());\n\n    // Append all the objects to the cleanup list.  Right now, this\n    // should always be a no-op, because blocks in default argument\n    // expressions should never be able to capture anything.\n    assert(!Init->getNumObjects() &&\n           \"default argument expression has capturing blocks?\");\n  }\n\n  // We already type-checked the argument, so we know it works.\n  // Just mark all of the declarations in this potentially-evaluated expression\n  // as being \"referenced\".\n  EnterExpressionEvaluationContext EvalContext(\n      *this, ExpressionEvaluationContext::PotentiallyEvaluated, Param);\n  MarkDeclarationsReferencedInExpr(Param->getDefaultArg(),\n                                   /*SkipLocalVariables=*/true);\n  return false;\n}\n\nExprResult Sema::BuildCXXDefaultArgExpr(SourceLocation CallLoc,\n                                        FunctionDecl *FD, ParmVarDecl *Param) {\n  assert(Param->hasDefaultArg() && \"can't build nonexistent default arg\");\n  if (CheckCXXDefaultArgExpr(CallLoc, FD, Param))\n    return ExprError();\n  return CXXDefaultArgExpr::Create(Context, CallLoc, Param, CurContext);\n}\n\nSema::VariadicCallType\nSema::getVariadicCallType(FunctionDecl *FDecl, const FunctionProtoType *Proto,\n                          Expr *Fn) {\n  if (Proto && Proto->isVariadic()) {\n    if (dyn_cast_or_null<CXXConstructorDecl>(FDecl))\n      return VariadicConstructor;\n    else if (Fn && Fn->getType()->isBlockPointerType())\n      return VariadicBlock;\n    else if (FDecl) {\n      if (CXXMethodDecl *Method = dyn_cast_or_null<CXXMethodDecl>(FDecl))\n        if (Method->isInstance())\n          return VariadicMethod;\n    } else if (Fn && Fn->getType() == Context.BoundMemberTy)\n      return VariadicMethod;\n    return VariadicFunction;\n  }\n  return VariadicDoesNotApply;\n}\n\nnamespace {\nclass FunctionCallCCC final : public FunctionCallFilterCCC {\npublic:\n  FunctionCallCCC(Sema &SemaRef, const IdentifierInfo *FuncName,\n                  unsigned NumArgs, MemberExpr *ME)\n      : FunctionCallFilterCCC(SemaRef, NumArgs, false, ME),\n        FunctionName(FuncName) {}\n\n  bool ValidateCandidate(const TypoCorrection &candidate) override {\n    if (!candidate.getCorrectionSpecifier() ||\n        candidate.getCorrectionAsIdentifierInfo() != FunctionName) {\n      return false;\n    }\n\n    return FunctionCallFilterCCC::ValidateCandidate(candidate);\n  }\n\n  std::unique_ptr<CorrectionCandidateCallback> clone() override {\n    return std::make_unique<FunctionCallCCC>(*this);\n  }\n\nprivate:\n  const IdentifierInfo *const FunctionName;\n};\n}\n\nstatic TypoCorrection TryTypoCorrectionForCall(Sema &S, Expr *Fn,\n                                               FunctionDecl *FDecl,\n                                               ArrayRef<Expr *> Args) {\n  MemberExpr *ME = dyn_cast<MemberExpr>(Fn);\n  DeclarationName FuncName = FDecl->getDeclName();\n  SourceLocation NameLoc = ME ? ME->getMemberLoc() : Fn->getBeginLoc();\n\n  FunctionCallCCC CCC(S, FuncName.getAsIdentifierInfo(), Args.size(), ME);\n  if (TypoCorrection Corrected = S.CorrectTypo(\n          DeclarationNameInfo(FuncName, NameLoc), Sema::LookupOrdinaryName,\n          S.getScopeForContext(S.CurContext), nullptr, CCC,\n          Sema::CTK_ErrorRecovery)) {\n    if (NamedDecl *ND = Corrected.getFoundDecl()) {\n      if (Corrected.isOverloaded()) {\n        OverloadCandidateSet OCS(NameLoc, OverloadCandidateSet::CSK_Normal);\n        OverloadCandidateSet::iterator Best;\n        for (NamedDecl *CD : Corrected) {\n          if (FunctionDecl *FD = dyn_cast<FunctionDecl>(CD))\n            S.AddOverloadCandidate(FD, DeclAccessPair::make(FD, AS_none), Args,\n                                   OCS);\n        }\n        switch (OCS.BestViableFunction(S, NameLoc, Best)) {\n        case OR_Success:\n          ND = Best->FoundDecl;\n          Corrected.setCorrectionDecl(ND);\n          break;\n        default:\n          break;\n        }\n      }\n      ND = ND->getUnderlyingDecl();\n      if (isa<ValueDecl>(ND) || isa<FunctionTemplateDecl>(ND))\n        return Corrected;\n    }\n  }\n  return TypoCorrection();\n}\n\n/// ConvertArgumentsForCall - Converts the arguments specified in\n/// Args/NumArgs to the parameter types of the function FDecl with\n/// function prototype Proto. Call is the call expression itself, and\n/// Fn is the function expression. For a C++ member function, this\n/// routine does not attempt to convert the object argument. Returns\n/// true if the call is ill-formed.\nbool\nSema::ConvertArgumentsForCall(CallExpr *Call, Expr *Fn,\n                              FunctionDecl *FDecl,\n                              const FunctionProtoType *Proto,\n                              ArrayRef<Expr *> Args,\n                              SourceLocation RParenLoc,\n                              bool IsExecConfig) {\n  // Bail out early if calling a builtin with custom typechecking.\n  if (FDecl)\n    if (unsigned ID = FDecl->getBuiltinID())\n      if (Context.BuiltinInfo.hasCustomTypechecking(ID))\n        return false;\n\n  // C99 6.5.2.2p7 - the arguments are implicitly converted, as if by\n  // assignment, to the types of the corresponding parameter, ...\n  unsigned NumParams = Proto->getNumParams();\n  bool Invalid = false;\n  unsigned MinArgs = FDecl ? FDecl->getMinRequiredArguments() : NumParams;\n  unsigned FnKind = Fn->getType()->isBlockPointerType()\n                       ? 1 /* block */\n                       : (IsExecConfig ? 3 /* kernel function (exec config) */\n                                       : 0 /* function */);\n\n  // If too few arguments are available (and we don't have default\n  // arguments for the remaining parameters), don't make the call.\n  if (Args.size() < NumParams) {\n    if (Args.size() < MinArgs) {\n      TypoCorrection TC;\n      if (FDecl && (TC = TryTypoCorrectionForCall(*this, Fn, FDecl, Args))) {\n        unsigned diag_id =\n            MinArgs == NumParams && !Proto->isVariadic()\n                ? diag::err_typecheck_call_too_few_args_suggest\n                : diag::err_typecheck_call_too_few_args_at_least_suggest;\n        diagnoseTypo(TC, PDiag(diag_id) << FnKind << MinArgs\n                                        << static_cast<unsigned>(Args.size())\n                                        << TC.getCorrectionRange());\n      } else if (MinArgs == 1 && FDecl && FDecl->getParamDecl(0)->getDeclName())\n        Diag(RParenLoc,\n             MinArgs == NumParams && !Proto->isVariadic()\n                 ? diag::err_typecheck_call_too_few_args_one\n                 : diag::err_typecheck_call_too_few_args_at_least_one)\n            << FnKind << FDecl->getParamDecl(0) << Fn->getSourceRange();\n      else\n        Diag(RParenLoc, MinArgs == NumParams && !Proto->isVariadic()\n                            ? diag::err_typecheck_call_too_few_args\n                            : diag::err_typecheck_call_too_few_args_at_least)\n            << FnKind << MinArgs << static_cast<unsigned>(Args.size())\n            << Fn->getSourceRange();\n\n      // Emit the location of the prototype.\n      if (!TC && FDecl && !FDecl->getBuiltinID() && !IsExecConfig)\n        Diag(FDecl->getLocation(), diag::note_callee_decl) << FDecl;\n\n      return true;\n    }\n    // We reserve space for the default arguments when we create\n    // the call expression, before calling ConvertArgumentsForCall.\n    assert((Call->getNumArgs() == NumParams) &&\n           \"We should have reserved space for the default arguments before!\");\n  }\n\n  // If too many are passed and not variadic, error on the extras and drop\n  // them.\n  if (Args.size() > NumParams) {\n    if (!Proto->isVariadic()) {\n      TypoCorrection TC;\n      if (FDecl && (TC = TryTypoCorrectionForCall(*this, Fn, FDecl, Args))) {\n        unsigned diag_id =\n            MinArgs == NumParams && !Proto->isVariadic()\n                ? diag::err_typecheck_call_too_many_args_suggest\n                : diag::err_typecheck_call_too_many_args_at_most_suggest;\n        diagnoseTypo(TC, PDiag(diag_id) << FnKind << NumParams\n                                        << static_cast<unsigned>(Args.size())\n                                        << TC.getCorrectionRange());\n      } else if (NumParams == 1 && FDecl &&\n                 FDecl->getParamDecl(0)->getDeclName())\n        Diag(Args[NumParams]->getBeginLoc(),\n             MinArgs == NumParams\n                 ? diag::err_typecheck_call_too_many_args_one\n                 : diag::err_typecheck_call_too_many_args_at_most_one)\n            << FnKind << FDecl->getParamDecl(0)\n            << static_cast<unsigned>(Args.size()) << Fn->getSourceRange()\n            << SourceRange(Args[NumParams]->getBeginLoc(),\n                           Args.back()->getEndLoc());\n      else\n        Diag(Args[NumParams]->getBeginLoc(),\n             MinArgs == NumParams\n                 ? diag::err_typecheck_call_too_many_args\n                 : diag::err_typecheck_call_too_many_args_at_most)\n            << FnKind << NumParams << static_cast<unsigned>(Args.size())\n            << Fn->getSourceRange()\n            << SourceRange(Args[NumParams]->getBeginLoc(),\n                           Args.back()->getEndLoc());\n\n      // Emit the location of the prototype.\n      if (!TC && FDecl && !FDecl->getBuiltinID() && !IsExecConfig)\n        Diag(FDecl->getLocation(), diag::note_callee_decl) << FDecl;\n\n      // This deletes the extra arguments.\n      Call->shrinkNumArgs(NumParams);\n      return true;\n    }\n  }\n  SmallVector<Expr *, 8> AllArgs;\n  VariadicCallType CallType = getVariadicCallType(FDecl, Proto, Fn);\n\n  Invalid = GatherArgumentsForCall(Call->getBeginLoc(), FDecl, Proto, 0, Args,\n                                   AllArgs, CallType);\n  if (Invalid)\n    return true;\n  unsigned TotalNumArgs = AllArgs.size();\n  for (unsigned i = 0; i < TotalNumArgs; ++i)\n    Call->setArg(i, AllArgs[i]);\n\n  return false;\n}\n\nbool Sema::GatherArgumentsForCall(SourceLocation CallLoc, FunctionDecl *FDecl,\n                                  const FunctionProtoType *Proto,\n                                  unsigned FirstParam, ArrayRef<Expr *> Args,\n                                  SmallVectorImpl<Expr *> &AllArgs,\n                                  VariadicCallType CallType, bool AllowExplicit,\n                                  bool IsListInitialization) {\n  unsigned NumParams = Proto->getNumParams();\n  bool Invalid = false;\n  size_t ArgIx = 0;\n  // Continue to check argument types (even if we have too few/many args).\n  for (unsigned i = FirstParam; i < NumParams; i++) {\n    QualType ProtoArgType = Proto->getParamType(i);\n\n    Expr *Arg;\n    ParmVarDecl *Param = FDecl ? FDecl->getParamDecl(i) : nullptr;\n    if (ArgIx < Args.size()) {\n      Arg = Args[ArgIx++];\n\n      if (RequireCompleteType(Arg->getBeginLoc(), ProtoArgType,\n                              diag::err_call_incomplete_argument, Arg))\n        return true;\n\n      // Strip the unbridged-cast placeholder expression off, if applicable.\n      bool CFAudited = false;\n      if (Arg->getType() == Context.ARCUnbridgedCastTy &&\n          FDecl && FDecl->hasAttr<CFAuditedTransferAttr>() &&\n          (!Param || !Param->hasAttr<CFConsumedAttr>()))\n        Arg = stripARCUnbridgedCast(Arg);\n      else if (getLangOpts().ObjCAutoRefCount &&\n               FDecl && FDecl->hasAttr<CFAuditedTransferAttr>() &&\n               (!Param || !Param->hasAttr<CFConsumedAttr>()))\n        CFAudited = true;\n\n      if (Proto->getExtParameterInfo(i).isNoEscape())\n        if (auto *BE = dyn_cast<BlockExpr>(Arg->IgnoreParenNoopCasts(Context)))\n          BE->getBlockDecl()->setDoesNotEscape();\n\n      InitializedEntity Entity =\n          Param ? InitializedEntity::InitializeParameter(Context, Param,\n                                                         ProtoArgType)\n                : InitializedEntity::InitializeParameter(\n                      Context, ProtoArgType, Proto->isParamConsumed(i));\n\n      // Remember that parameter belongs to a CF audited API.\n      if (CFAudited)\n        Entity.setParameterCFAudited();\n\n      ExprResult ArgE = PerformCopyInitialization(\n          Entity, SourceLocation(), Arg, IsListInitialization, AllowExplicit);\n      if (ArgE.isInvalid())\n        return true;\n\n      Arg = ArgE.getAs<Expr>();\n    } else {\n      assert(Param && \"can't use default arguments without a known callee\");\n\n      ExprResult ArgExpr = BuildCXXDefaultArgExpr(CallLoc, FDecl, Param);\n      if (ArgExpr.isInvalid())\n        return true;\n\n      Arg = ArgExpr.getAs<Expr>();\n    }\n\n    // Check for array bounds violations for each argument to the call. This\n    // check only triggers warnings when the argument isn't a more complex Expr\n    // with its own checking, such as a BinaryOperator.\n    CheckArrayAccess(Arg);\n\n    // Check for violations of C99 static array rules (C99 6.7.5.3p7).\n    CheckStaticArrayArgument(CallLoc, Param, Arg);\n\n    AllArgs.push_back(Arg);\n  }\n\n  // If this is a variadic call, handle args passed through \"...\".\n  if (CallType != VariadicDoesNotApply) {\n    // Assume that extern \"C\" functions with variadic arguments that\n    // return __unknown_anytype aren't *really* variadic.\n    if (Proto->getReturnType() == Context.UnknownAnyTy && FDecl &&\n        FDecl->isExternC()) {\n      for (Expr *A : Args.slice(ArgIx)) {\n        QualType paramType; // ignored\n        ExprResult arg = checkUnknownAnyArg(CallLoc, A, paramType);\n        Invalid |= arg.isInvalid();\n        AllArgs.push_back(arg.get());\n      }\n\n    // Otherwise do argument promotion, (C99 6.5.2.2p7).\n    } else {\n      for (Expr *A : Args.slice(ArgIx)) {\n        ExprResult Arg = DefaultVariadicArgumentPromotion(A, CallType, FDecl);\n        Invalid |= Arg.isInvalid();\n        AllArgs.push_back(Arg.get());\n      }\n    }\n\n    // Check for array bounds violations.\n    for (Expr *A : Args.slice(ArgIx))\n      CheckArrayAccess(A);\n  }\n  return Invalid;\n}\n\nstatic void DiagnoseCalleeStaticArrayParam(Sema &S, ParmVarDecl *PVD) {\n  TypeLoc TL = PVD->getTypeSourceInfo()->getTypeLoc();\n  if (DecayedTypeLoc DTL = TL.getAs<DecayedTypeLoc>())\n    TL = DTL.getOriginalLoc();\n  if (ArrayTypeLoc ATL = TL.getAs<ArrayTypeLoc>())\n    S.Diag(PVD->getLocation(), diag::note_callee_static_array)\n      << ATL.getLocalSourceRange();\n}\n\n/// CheckStaticArrayArgument - If the given argument corresponds to a static\n/// array parameter, check that it is non-null, and that if it is formed by\n/// array-to-pointer decay, the underlying array is sufficiently large.\n///\n/// C99 6.7.5.3p7: If the keyword static also appears within the [ and ] of the\n/// array type derivation, then for each call to the function, the value of the\n/// corresponding actual argument shall provide access to the first element of\n/// an array with at least as many elements as specified by the size expression.\nvoid\nSema::CheckStaticArrayArgument(SourceLocation CallLoc,\n                               ParmVarDecl *Param,\n                               const Expr *ArgExpr) {\n  // Static array parameters are not supported in C++.\n  if (!Param || getLangOpts().CPlusPlus)\n    return;\n\n  QualType OrigTy = Param->getOriginalType();\n\n  const ArrayType *AT = Context.getAsArrayType(OrigTy);\n  if (!AT || AT->getSizeModifier() != ArrayType::Static)\n    return;\n\n  if (ArgExpr->isNullPointerConstant(Context,\n                                     Expr::NPC_NeverValueDependent)) {\n    Diag(CallLoc, diag::warn_null_arg) << ArgExpr->getSourceRange();\n    DiagnoseCalleeStaticArrayParam(*this, Param);\n    return;\n  }\n\n  const ConstantArrayType *CAT = dyn_cast<ConstantArrayType>(AT);\n  if (!CAT)\n    return;\n\n  const ConstantArrayType *ArgCAT =\n    Context.getAsConstantArrayType(ArgExpr->IgnoreParenCasts()->getType());\n  if (!ArgCAT)\n    return;\n\n  if (getASTContext().hasSameUnqualifiedType(CAT->getElementType(),\n                                             ArgCAT->getElementType())) {\n    if (ArgCAT->getSize().ult(CAT->getSize())) {\n      Diag(CallLoc, diag::warn_static_array_too_small)\n          << ArgExpr->getSourceRange()\n          << (unsigned)ArgCAT->getSize().getZExtValue()\n          << (unsigned)CAT->getSize().getZExtValue() << 0;\n      DiagnoseCalleeStaticArrayParam(*this, Param);\n    }\n    return;\n  }\n\n  Optional<CharUnits> ArgSize =\n      getASTContext().getTypeSizeInCharsIfKnown(ArgCAT);\n  Optional<CharUnits> ParmSize = getASTContext().getTypeSizeInCharsIfKnown(CAT);\n  if (ArgSize && ParmSize && *ArgSize < *ParmSize) {\n    Diag(CallLoc, diag::warn_static_array_too_small)\n        << ArgExpr->getSourceRange() << (unsigned)ArgSize->getQuantity()\n        << (unsigned)ParmSize->getQuantity() << 1;\n    DiagnoseCalleeStaticArrayParam(*this, Param);\n  }\n}\n\n/// Given a function expression of unknown-any type, try to rebuild it\n/// to have a function type.\nstatic ExprResult rebuildUnknownAnyFunction(Sema &S, Expr *fn);\n\n/// Is the given type a placeholder that we need to lower out\n/// immediately during argument processing?\nstatic bool isPlaceholderToRemoveAsArg(QualType type) {\n  // Placeholders are never sugared.\n  const BuiltinType *placeholder = dyn_cast<BuiltinType>(type);\n  if (!placeholder) return false;\n\n  switch (placeholder->getKind()) {\n  // Ignore all the non-placeholder types.\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n  case BuiltinType::Id:\n#include \"clang/Basic/OpenCLImageTypes.def\"\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n  case BuiltinType::Id:\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n  // In practice we'll never use this, since all SVE types are sugared\n  // via TypedefTypes rather than exposed directly as BuiltinTypes.\n#define SVE_TYPE(Name, Id, SingletonId) \\\n  case BuiltinType::Id:\n#include \"clang/Basic/AArch64SVEACLETypes.def\"\n#define PPC_VECTOR_TYPE(Name, Id, Size) \\\n  case BuiltinType::Id:\n#include \"clang/Basic/PPCTypes.def\"\n#define RVV_TYPE(Name, Id, SingletonId) case BuiltinType::Id:\n#include \"clang/Basic/RISCVVTypes.def\"\n#define PLACEHOLDER_TYPE(ID, SINGLETON_ID)\n#define BUILTIN_TYPE(ID, SINGLETON_ID) case BuiltinType::ID:\n#include \"clang/AST/BuiltinTypes.def\"\n    return false;\n\n  // We cannot lower out overload sets; they might validly be resolved\n  // by the call machinery.\n  case BuiltinType::Overload:\n    return false;\n\n  // Unbridged casts in ARC can be handled in some call positions and\n  // should be left in place.\n  case BuiltinType::ARCUnbridgedCast:\n    return false;\n\n  // Pseudo-objects should be converted as soon as possible.\n  case BuiltinType::PseudoObject:\n    return true;\n\n  // The debugger mode could theoretically but currently does not try\n  // to resolve unknown-typed arguments based on known parameter types.\n  case BuiltinType::UnknownAny:\n    return true;\n\n  // These are always invalid as call arguments and should be reported.\n  case BuiltinType::BoundMember:\n  case BuiltinType::BuiltinFn:\n  case BuiltinType::IncompleteMatrixIdx:\n  case BuiltinType::OMPArraySection:\n  case BuiltinType::OMPArrayShaping:\n  case BuiltinType::OMPIterator:\n    return true;\n\n  }\n  llvm_unreachable(\"bad builtin type kind\");\n}\n\n/// Check an argument list for placeholders that we won't try to\n/// handle later.\nstatic bool checkArgsForPlaceholders(Sema &S, MultiExprArg args) {\n  // Apply this processing to all the arguments at once instead of\n  // dying at the first failure.\n  bool hasInvalid = false;\n  for (size_t i = 0, e = args.size(); i != e; i++) {\n    if (isPlaceholderToRemoveAsArg(args[i]->getType())) {\n      ExprResult result = S.CheckPlaceholderExpr(args[i]);\n      if (result.isInvalid()) hasInvalid = true;\n      else args[i] = result.get();\n    }\n  }\n  return hasInvalid;\n}\n\n/// If a builtin function has a pointer argument with no explicit address\n/// space, then it should be able to accept a pointer to any address\n/// space as input.  In order to do this, we need to replace the\n/// standard builtin declaration with one that uses the same address space\n/// as the call.\n///\n/// \\returns nullptr If this builtin is not a candidate for a rewrite i.e.\n///                  it does not contain any pointer arguments without\n///                  an address space qualifer.  Otherwise the rewritten\n///                  FunctionDecl is returned.\n/// TODO: Handle pointer return types.\nstatic FunctionDecl *rewriteBuiltinFunctionDecl(Sema *Sema, ASTContext &Context,\n                                                FunctionDecl *FDecl,\n                                                MultiExprArg ArgExprs) {\n\n  QualType DeclType = FDecl->getType();\n  const FunctionProtoType *FT = dyn_cast<FunctionProtoType>(DeclType);\n\n  if (!Context.BuiltinInfo.hasPtrArgsOrResult(FDecl->getBuiltinID()) || !FT ||\n      ArgExprs.size() < FT->getNumParams())\n    return nullptr;\n\n  bool NeedsNewDecl = false;\n  unsigned i = 0;\n  SmallVector<QualType, 8> OverloadParams;\n\n  for (QualType ParamType : FT->param_types()) {\n\n    // Convert array arguments to pointer to simplify type lookup.\n    ExprResult ArgRes =\n        Sema->DefaultFunctionArrayLvalueConversion(ArgExprs[i++]);\n    if (ArgRes.isInvalid())\n      return nullptr;\n    Expr *Arg = ArgRes.get();\n    QualType ArgType = Arg->getType();\n    if (!ParamType->isPointerType() ||\n        ParamType.hasAddressSpace() ||\n        !ArgType->isPointerType() ||\n        !ArgType->getPointeeType().hasAddressSpace()) {\n      OverloadParams.push_back(ParamType);\n      continue;\n    }\n\n    QualType PointeeType = ParamType->getPointeeType();\n    if (PointeeType.hasAddressSpace())\n      continue;\n\n    NeedsNewDecl = true;\n    LangAS AS = ArgType->getPointeeType().getAddressSpace();\n\n    PointeeType = Context.getAddrSpaceQualType(PointeeType, AS);\n    OverloadParams.push_back(Context.getPointerType(PointeeType));\n  }\n\n  if (!NeedsNewDecl)\n    return nullptr;\n\n  FunctionProtoType::ExtProtoInfo EPI;\n  EPI.Variadic = FT->isVariadic();\n  QualType OverloadTy = Context.getFunctionType(FT->getReturnType(),\n                                                OverloadParams, EPI);\n  DeclContext *Parent = FDecl->getParent();\n  FunctionDecl *OverloadDecl = FunctionDecl::Create(Context, Parent,\n                                                    FDecl->getLocation(),\n                                                    FDecl->getLocation(),\n                                                    FDecl->getIdentifier(),\n                                                    OverloadTy,\n                                                    /*TInfo=*/nullptr,\n                                                    SC_Extern, false,\n                                                    /*hasPrototype=*/true);\n  SmallVector<ParmVarDecl*, 16> Params;\n  FT = cast<FunctionProtoType>(OverloadTy);\n  for (unsigned i = 0, e = FT->getNumParams(); i != e; ++i) {\n    QualType ParamType = FT->getParamType(i);\n    ParmVarDecl *Parm =\n        ParmVarDecl::Create(Context, OverloadDecl, SourceLocation(),\n                                SourceLocation(), nullptr, ParamType,\n                                /*TInfo=*/nullptr, SC_None, nullptr);\n    Parm->setScopeInfo(0, i);\n    Params.push_back(Parm);\n  }\n  OverloadDecl->setParams(Params);\n  Sema->mergeDeclAttributes(OverloadDecl, FDecl);\n  return OverloadDecl;\n}\n\nstatic void checkDirectCallValidity(Sema &S, const Expr *Fn,\n                                    FunctionDecl *Callee,\n                                    MultiExprArg ArgExprs) {\n  // `Callee` (when called with ArgExprs) may be ill-formed. enable_if (and\n  // similar attributes) really don't like it when functions are called with an\n  // invalid number of args.\n  if (S.TooManyArguments(Callee->getNumParams(), ArgExprs.size(),\n                         /*PartialOverloading=*/false) &&\n      !Callee->isVariadic())\n    return;\n  if (Callee->getMinRequiredArguments() > ArgExprs.size())\n    return;\n\n  if (const EnableIfAttr *Attr =\n          S.CheckEnableIf(Callee, Fn->getBeginLoc(), ArgExprs, true)) {\n    S.Diag(Fn->getBeginLoc(),\n           isa<CXXMethodDecl>(Callee)\n               ? diag::err_ovl_no_viable_member_function_in_call\n               : diag::err_ovl_no_viable_function_in_call)\n        << Callee << Callee->getSourceRange();\n    S.Diag(Callee->getLocation(),\n           diag::note_ovl_candidate_disabled_by_function_cond_attr)\n        << Attr->getCond()->getSourceRange() << Attr->getMessage();\n    return;\n  }\n}\n\nstatic bool enclosingClassIsRelatedToClassInWhichMembersWereFound(\n    const UnresolvedMemberExpr *const UME, Sema &S) {\n\n  const auto GetFunctionLevelDCIfCXXClass =\n      [](Sema &S) -> const CXXRecordDecl * {\n    const DeclContext *const DC = S.getFunctionLevelDeclContext();\n    if (!DC || !DC->getParent())\n      return nullptr;\n\n    // If the call to some member function was made from within a member\n    // function body 'M' return return 'M's parent.\n    if (const auto *MD = dyn_cast<CXXMethodDecl>(DC))\n      return MD->getParent()->getCanonicalDecl();\n    // else the call was made from within a default member initializer of a\n    // class, so return the class.\n    if (const auto *RD = dyn_cast<CXXRecordDecl>(DC))\n      return RD->getCanonicalDecl();\n    return nullptr;\n  };\n  // If our DeclContext is neither a member function nor a class (in the\n  // case of a lambda in a default member initializer), we can't have an\n  // enclosing 'this'.\n\n  const CXXRecordDecl *const CurParentClass = GetFunctionLevelDCIfCXXClass(S);\n  if (!CurParentClass)\n    return false;\n\n  // The naming class for implicit member functions call is the class in which\n  // name lookup starts.\n  const CXXRecordDecl *const NamingClass =\n      UME->getNamingClass()->getCanonicalDecl();\n  assert(NamingClass && \"Must have naming class even for implicit access\");\n\n  // If the unresolved member functions were found in a 'naming class' that is\n  // related (either the same or derived from) to the class that contains the\n  // member function that itself contained the implicit member access.\n\n  return CurParentClass == NamingClass ||\n         CurParentClass->isDerivedFrom(NamingClass);\n}\n\nstatic void\ntryImplicitlyCaptureThisIfImplicitMemberFunctionAccessWithDependentArgs(\n    Sema &S, const UnresolvedMemberExpr *const UME, SourceLocation CallLoc) {\n\n  if (!UME)\n    return;\n\n  LambdaScopeInfo *const CurLSI = S.getCurLambda();\n  // Only try and implicitly capture 'this' within a C++ Lambda if it hasn't\n  // already been captured, or if this is an implicit member function call (if\n  // it isn't, an attempt to capture 'this' should already have been made).\n  if (!CurLSI || CurLSI->ImpCaptureStyle == CurLSI->ImpCap_None ||\n      !UME->isImplicitAccess() || CurLSI->isCXXThisCaptured())\n    return;\n\n  // Check if the naming class in which the unresolved members were found is\n  // related (same as or is a base of) to the enclosing class.\n\n  if (!enclosingClassIsRelatedToClassInWhichMembersWereFound(UME, S))\n    return;\n\n\n  DeclContext *EnclosingFunctionCtx = S.CurContext->getParent()->getParent();\n  // If the enclosing function is not dependent, then this lambda is\n  // capture ready, so if we can capture this, do so.\n  if (!EnclosingFunctionCtx->isDependentContext()) {\n    // If the current lambda and all enclosing lambdas can capture 'this' -\n    // then go ahead and capture 'this' (since our unresolved overload set\n    // contains at least one non-static member function).\n    if (!S.CheckCXXThisCapture(CallLoc, /*Explcit*/ false, /*Diagnose*/ false))\n      S.CheckCXXThisCapture(CallLoc);\n  } else if (S.CurContext->isDependentContext()) {\n    // ... since this is an implicit member reference, that might potentially\n    // involve a 'this' capture, mark 'this' for potential capture in\n    // enclosing lambdas.\n    if (CurLSI->ImpCaptureStyle != CurLSI->ImpCap_None)\n      CurLSI->addPotentialThisCapture(CallLoc);\n  }\n}\n\nExprResult Sema::ActOnCallExpr(Scope *Scope, Expr *Fn, SourceLocation LParenLoc,\n                               MultiExprArg ArgExprs, SourceLocation RParenLoc,\n                               Expr *ExecConfig) {\n  ExprResult Call =\n      BuildCallExpr(Scope, Fn, LParenLoc, ArgExprs, RParenLoc, ExecConfig,\n                    /*IsExecConfig=*/false, /*AllowRecovery=*/true);\n  if (Call.isInvalid())\n    return Call;\n\n  // Diagnose uses of the C++20 \"ADL-only template-id call\" feature in earlier\n  // language modes.\n  if (auto *ULE = dyn_cast<UnresolvedLookupExpr>(Fn)) {\n    if (ULE->hasExplicitTemplateArgs() &&\n        ULE->decls_begin() == ULE->decls_end()) {\n      Diag(Fn->getExprLoc(), getLangOpts().CPlusPlus20\n                                 ? diag::warn_cxx17_compat_adl_only_template_id\n                                 : diag::ext_adl_only_template_id)\n          << ULE->getName();\n    }\n  }\n\n  if (LangOpts.OpenMP)\n    Call = ActOnOpenMPCall(Call, Scope, LParenLoc, ArgExprs, RParenLoc,\n                           ExecConfig);\n\n  return Call;\n}\n\n/// BuildCallExpr - Handle a call to Fn with the specified array of arguments.\n/// This provides the location of the left/right parens and a list of comma\n/// locations.\nExprResult Sema::BuildCallExpr(Scope *Scope, Expr *Fn, SourceLocation LParenLoc,\n                               MultiExprArg ArgExprs, SourceLocation RParenLoc,\n                               Expr *ExecConfig, bool IsExecConfig,\n                               bool AllowRecovery) {\n  // Since this might be a postfix expression, get rid of ParenListExprs.\n  ExprResult Result = MaybeConvertParenListExprToParenExpr(Scope, Fn);\n  if (Result.isInvalid()) return ExprError();\n  Fn = Result.get();\n\n  if (checkArgsForPlaceholders(*this, ArgExprs))\n    return ExprError();\n\n  if (getLangOpts().CPlusPlus) {\n    // If this is a pseudo-destructor expression, build the call immediately.\n    if (isa<CXXPseudoDestructorExpr>(Fn)) {\n      if (!ArgExprs.empty()) {\n        // Pseudo-destructor calls should not have any arguments.\n        Diag(Fn->getBeginLoc(), diag::err_pseudo_dtor_call_with_args)\n            << FixItHint::CreateRemoval(\n                   SourceRange(ArgExprs.front()->getBeginLoc(),\n                               ArgExprs.back()->getEndLoc()));\n      }\n\n      return CallExpr::Create(Context, Fn, /*Args=*/{}, Context.VoidTy,\n                              VK_RValue, RParenLoc, CurFPFeatureOverrides());\n    }\n    if (Fn->getType() == Context.PseudoObjectTy) {\n      ExprResult result = CheckPlaceholderExpr(Fn);\n      if (result.isInvalid()) return ExprError();\n      Fn = result.get();\n    }\n\n    // Determine whether this is a dependent call inside a C++ template,\n    // in which case we won't do any semantic analysis now.\n    if (Fn->isTypeDependent() || Expr::hasAnyTypeDependentArguments(ArgExprs)) {\n      if (ExecConfig) {\n        return CUDAKernelCallExpr::Create(\n            Context, Fn, cast<CallExpr>(ExecConfig), ArgExprs,\n            Context.DependentTy, VK_RValue, RParenLoc, CurFPFeatureOverrides());\n      } else {\n\n        tryImplicitlyCaptureThisIfImplicitMemberFunctionAccessWithDependentArgs(\n            *this, dyn_cast<UnresolvedMemberExpr>(Fn->IgnoreParens()),\n            Fn->getBeginLoc());\n\n        return CallExpr::Create(Context, Fn, ArgExprs, Context.DependentTy,\n                                VK_RValue, RParenLoc, CurFPFeatureOverrides());\n      }\n    }\n\n    // Determine whether this is a call to an object (C++ [over.call.object]).\n    if (Fn->getType()->isRecordType())\n      return BuildCallToObjectOfClassType(Scope, Fn, LParenLoc, ArgExprs,\n                                          RParenLoc);\n\n    if (Fn->getType() == Context.UnknownAnyTy) {\n      ExprResult result = rebuildUnknownAnyFunction(*this, Fn);\n      if (result.isInvalid()) return ExprError();\n      Fn = result.get();\n    }\n\n    if (Fn->getType() == Context.BoundMemberTy) {\n      return BuildCallToMemberFunction(Scope, Fn, LParenLoc, ArgExprs,\n                                       RParenLoc, AllowRecovery);\n    }\n  }\n\n  // Check for overloaded calls.  This can happen even in C due to extensions.\n  if (Fn->getType() == Context.OverloadTy) {\n    OverloadExpr::FindResult find = OverloadExpr::find(Fn);\n\n    // We aren't supposed to apply this logic if there's an '&' involved.\n    if (!find.HasFormOfMemberPointer) {\n      if (Expr::hasAnyTypeDependentArguments(ArgExprs))\n        return CallExpr::Create(Context, Fn, ArgExprs, Context.DependentTy,\n                                VK_RValue, RParenLoc, CurFPFeatureOverrides());\n      OverloadExpr *ovl = find.Expression;\n      if (UnresolvedLookupExpr *ULE = dyn_cast<UnresolvedLookupExpr>(ovl))\n        return BuildOverloadedCallExpr(\n            Scope, Fn, ULE, LParenLoc, ArgExprs, RParenLoc, ExecConfig,\n            /*AllowTypoCorrection=*/true, find.IsAddressOfOperand);\n      return BuildCallToMemberFunction(Scope, Fn, LParenLoc, ArgExprs,\n                                       RParenLoc, AllowRecovery);\n    }\n  }\n\n  // If we're directly calling a function, get the appropriate declaration.\n  if (Fn->getType() == Context.UnknownAnyTy) {\n    ExprResult result = rebuildUnknownAnyFunction(*this, Fn);\n    if (result.isInvalid()) return ExprError();\n    Fn = result.get();\n  }\n\n  Expr *NakedFn = Fn->IgnoreParens();\n\n  bool CallingNDeclIndirectly = false;\n  NamedDecl *NDecl = nullptr;\n  if (UnaryOperator *UnOp = dyn_cast<UnaryOperator>(NakedFn)) {\n    if (UnOp->getOpcode() == UO_AddrOf) {\n      CallingNDeclIndirectly = true;\n      NakedFn = UnOp->getSubExpr()->IgnoreParens();\n    }\n  }\n\n  if (auto *DRE = dyn_cast<DeclRefExpr>(NakedFn)) {\n    NDecl = DRE->getDecl();\n\n    FunctionDecl *FDecl = dyn_cast<FunctionDecl>(NDecl);\n    if (FDecl && FDecl->getBuiltinID()) {\n      // Rewrite the function decl for this builtin by replacing parameters\n      // with no explicit address space with the address space of the arguments\n      // in ArgExprs.\n      if ((FDecl =\n               rewriteBuiltinFunctionDecl(this, Context, FDecl, ArgExprs))) {\n        NDecl = FDecl;\n        Fn = DeclRefExpr::Create(\n            Context, FDecl->getQualifierLoc(), SourceLocation(), FDecl, false,\n            SourceLocation(), FDecl->getType(), Fn->getValueKind(), FDecl,\n            nullptr, DRE->isNonOdrUse());\n      }\n    }\n  } else if (isa<MemberExpr>(NakedFn))\n    NDecl = cast<MemberExpr>(NakedFn)->getMemberDecl();\n\n  if (FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(NDecl)) {\n    if (CallingNDeclIndirectly && !checkAddressOfFunctionIsAvailable(\n                                      FD, /*Complain=*/true, Fn->getBeginLoc()))\n      return ExprError();\n\n    if (getLangOpts().OpenCL && checkOpenCLDisabledDecl(*FD, *Fn))\n      return ExprError();\n\n    checkDirectCallValidity(*this, Fn, FD, ArgExprs);\n  }\n\n  if (Context.isDependenceAllowed() &&\n      (Fn->isTypeDependent() || Expr::hasAnyTypeDependentArguments(ArgExprs))) {\n    assert(!getLangOpts().CPlusPlus);\n    assert((Fn->containsErrors() ||\n            llvm::any_of(ArgExprs,\n                         [](clang::Expr *E) { return E->containsErrors(); })) &&\n           \"should only occur in error-recovery path.\");\n    QualType ReturnType =\n        llvm::isa_and_nonnull<FunctionDecl>(NDecl)\n            ? cast<FunctionDecl>(NDecl)->getCallResultType()\n            : Context.DependentTy;\n    return CallExpr::Create(Context, Fn, ArgExprs, ReturnType,\n                            Expr::getValueKindForType(ReturnType), RParenLoc,\n                            CurFPFeatureOverrides());\n  }\n  return BuildResolvedCallExpr(Fn, NDecl, LParenLoc, ArgExprs, RParenLoc,\n                               ExecConfig, IsExecConfig);\n}\n\n/// ActOnAsTypeExpr - create a new asType (bitcast) from the arguments.\n///\n/// __builtin_astype( value, dst type )\n///\nExprResult Sema::ActOnAsTypeExpr(Expr *E, ParsedType ParsedDestTy,\n                                 SourceLocation BuiltinLoc,\n                                 SourceLocation RParenLoc) {\n  ExprValueKind VK = VK_RValue;\n  ExprObjectKind OK = OK_Ordinary;\n  QualType DstTy = GetTypeFromParser(ParsedDestTy);\n  QualType SrcTy = E->getType();\n  if (Context.getTypeSize(DstTy) != Context.getTypeSize(SrcTy))\n    return ExprError(Diag(BuiltinLoc,\n                          diag::err_invalid_astype_of_different_size)\n                     << DstTy\n                     << SrcTy\n                     << E->getSourceRange());\n  return new (Context) AsTypeExpr(E, DstTy, VK, OK, BuiltinLoc, RParenLoc);\n}\n\n/// ActOnConvertVectorExpr - create a new convert-vector expression from the\n/// provided arguments.\n///\n/// __builtin_convertvector( value, dst type )\n///\nExprResult Sema::ActOnConvertVectorExpr(Expr *E, ParsedType ParsedDestTy,\n                                        SourceLocation BuiltinLoc,\n                                        SourceLocation RParenLoc) {\n  TypeSourceInfo *TInfo;\n  GetTypeFromParser(ParsedDestTy, &TInfo);\n  return SemaConvertVectorExpr(E, TInfo, BuiltinLoc, RParenLoc);\n}\n\n/// BuildResolvedCallExpr - Build a call to a resolved expression,\n/// i.e. an expression not of \\p OverloadTy.  The expression should\n/// unary-convert to an expression of function-pointer or\n/// block-pointer type.\n///\n/// \\param NDecl the declaration being called, if available\nExprResult Sema::BuildResolvedCallExpr(Expr *Fn, NamedDecl *NDecl,\n                                       SourceLocation LParenLoc,\n                                       ArrayRef<Expr *> Args,\n                                       SourceLocation RParenLoc, Expr *Config,\n                                       bool IsExecConfig, ADLCallKind UsesADL) {\n  FunctionDecl *FDecl = dyn_cast_or_null<FunctionDecl>(NDecl);\n  unsigned BuiltinID = (FDecl ? FDecl->getBuiltinID() : 0);\n\n  // Functions with 'interrupt' attribute cannot be called directly.\n  if (FDecl && FDecl->hasAttr<AnyX86InterruptAttr>()) {\n    Diag(Fn->getExprLoc(), diag::err_anyx86_interrupt_called);\n    return ExprError();\n  }\n\n  // Interrupt handlers don't save off the VFP regs automatically on ARM,\n  // so there's some risk when calling out to non-interrupt handler functions\n  // that the callee might not preserve them. This is easy to diagnose here,\n  // but can be very challenging to debug.\n  // Likewise, X86 interrupt handlers may only call routines with attribute\n  // no_caller_saved_registers since there is no efficient way to\n  // save and restore the non-GPR state.\n  if (auto *Caller = getCurFunctionDecl()) {\n    if (Caller->hasAttr<ARMInterruptAttr>()) {\n      bool VFP = Context.getTargetInfo().hasFeature(\"vfp\");\n      if (VFP && (!FDecl || !FDecl->hasAttr<ARMInterruptAttr>())) {\n        Diag(Fn->getExprLoc(), diag::warn_arm_interrupt_calling_convention);\n        if (FDecl)\n          Diag(FDecl->getLocation(), diag::note_callee_decl) << FDecl;\n      }\n    }\n    if (Caller->hasAttr<AnyX86InterruptAttr>() &&\n        ((!FDecl || !FDecl->hasAttr<AnyX86NoCallerSavedRegistersAttr>()))) {\n      Diag(Fn->getExprLoc(), diag::err_anyx86_interrupt_regsave);\n      if (FDecl)\n        Diag(FDecl->getLocation(), diag::note_callee_decl) << FDecl;\n    }\n  }\n\n  // Promote the function operand.\n  // We special-case function promotion here because we only allow promoting\n  // builtin functions to function pointers in the callee of a call.\n  ExprResult Result;\n  QualType ResultTy;\n  if (BuiltinID &&\n      Fn->getType()->isSpecificBuiltinType(BuiltinType::BuiltinFn)) {\n    // Extract the return type from the (builtin) function pointer type.\n    // FIXME Several builtins still have setType in\n    // Sema::CheckBuiltinFunctionCall. One should review their definitions in\n    // Builtins.def to ensure they are correct before removing setType calls.\n    QualType FnPtrTy = Context.getPointerType(FDecl->getType());\n    Result = ImpCastExprToType(Fn, FnPtrTy, CK_BuiltinFnToFnPtr).get();\n    ResultTy = FDecl->getCallResultType();\n  } else {\n    Result = CallExprUnaryConversions(Fn);\n    ResultTy = Context.BoolTy;\n  }\n  if (Result.isInvalid())\n    return ExprError();\n  Fn = Result.get();\n\n  // Check for a valid function type, but only if it is not a builtin which\n  // requires custom type checking. These will be handled by\n  // CheckBuiltinFunctionCall below just after creation of the call expression.\n  const FunctionType *FuncT = nullptr;\n  if (!BuiltinID || !Context.BuiltinInfo.hasCustomTypechecking(BuiltinID)) {\n  retry:\n    if (const PointerType *PT = Fn->getType()->getAs<PointerType>()) {\n      // C99 6.5.2.2p1 - \"The expression that denotes the called function shall\n      // have type pointer to function\".\n      FuncT = PT->getPointeeType()->getAs<FunctionType>();\n      if (!FuncT)\n        return ExprError(Diag(LParenLoc, diag::err_typecheck_call_not_function)\n                         << Fn->getType() << Fn->getSourceRange());\n    } else if (const BlockPointerType *BPT =\n                   Fn->getType()->getAs<BlockPointerType>()) {\n      FuncT = BPT->getPointeeType()->castAs<FunctionType>();\n    } else {\n      // Handle calls to expressions of unknown-any type.\n      if (Fn->getType() == Context.UnknownAnyTy) {\n        ExprResult rewrite = rebuildUnknownAnyFunction(*this, Fn);\n        if (rewrite.isInvalid())\n          return ExprError();\n        Fn = rewrite.get();\n        goto retry;\n      }\n\n      return ExprError(Diag(LParenLoc, diag::err_typecheck_call_not_function)\n                       << Fn->getType() << Fn->getSourceRange());\n    }\n  }\n\n  // Get the number of parameters in the function prototype, if any.\n  // We will allocate space for max(Args.size(), NumParams) arguments\n  // in the call expression.\n  const auto *Proto = dyn_cast_or_null<FunctionProtoType>(FuncT);\n  unsigned NumParams = Proto ? Proto->getNumParams() : 0;\n\n  CallExpr *TheCall;\n  if (Config) {\n    assert(UsesADL == ADLCallKind::NotADL &&\n           \"CUDAKernelCallExpr should not use ADL\");\n    TheCall = CUDAKernelCallExpr::Create(Context, Fn, cast<CallExpr>(Config),\n                                         Args, ResultTy, VK_RValue, RParenLoc,\n                                         CurFPFeatureOverrides(), NumParams);\n  } else {\n    TheCall =\n        CallExpr::Create(Context, Fn, Args, ResultTy, VK_RValue, RParenLoc,\n                         CurFPFeatureOverrides(), NumParams, UsesADL);\n  }\n\n  if (!Context.isDependenceAllowed()) {\n    // Forget about the nulled arguments since typo correction\n    // do not handle them well.\n    TheCall->shrinkNumArgs(Args.size());\n    // C cannot always handle TypoExpr nodes in builtin calls and direct\n    // function calls as their argument checking don't necessarily handle\n    // dependent types properly, so make sure any TypoExprs have been\n    // dealt with.\n    ExprResult Result = CorrectDelayedTyposInExpr(TheCall);\n    if (!Result.isUsable()) return ExprError();\n    CallExpr *TheOldCall = TheCall;\n    TheCall = dyn_cast<CallExpr>(Result.get());\n    bool CorrectedTypos = TheCall != TheOldCall;\n    if (!TheCall) return Result;\n    Args = llvm::makeArrayRef(TheCall->getArgs(), TheCall->getNumArgs());\n\n    // A new call expression node was created if some typos were corrected.\n    // However it may not have been constructed with enough storage. In this\n    // case, rebuild the node with enough storage. The waste of space is\n    // immaterial since this only happens when some typos were corrected.\n    if (CorrectedTypos && Args.size() < NumParams) {\n      if (Config)\n        TheCall = CUDAKernelCallExpr::Create(\n            Context, Fn, cast<CallExpr>(Config), Args, ResultTy, VK_RValue,\n            RParenLoc, CurFPFeatureOverrides(), NumParams);\n      else\n        TheCall =\n            CallExpr::Create(Context, Fn, Args, ResultTy, VK_RValue, RParenLoc,\n                             CurFPFeatureOverrides(), NumParams, UsesADL);\n    }\n    // We can now handle the nulled arguments for the default arguments.\n    TheCall->setNumArgsUnsafe(std::max<unsigned>(Args.size(), NumParams));\n  }\n\n  // Bail out early if calling a builtin with custom type checking.\n  if (BuiltinID && Context.BuiltinInfo.hasCustomTypechecking(BuiltinID))\n    return CheckBuiltinFunctionCall(FDecl, BuiltinID, TheCall);\n\n  if (getLangOpts().CUDA) {\n    if (Config) {\n      // CUDA: Kernel calls must be to global functions\n      if (FDecl && !FDecl->hasAttr<CUDAGlobalAttr>())\n        return ExprError(Diag(LParenLoc,diag::err_kern_call_not_global_function)\n            << FDecl << Fn->getSourceRange());\n\n      // CUDA: Kernel function must have 'void' return type\n      if (!FuncT->getReturnType()->isVoidType() &&\n          !FuncT->getReturnType()->getAs<AutoType>() &&\n          !FuncT->getReturnType()->isInstantiationDependentType())\n        return ExprError(Diag(LParenLoc, diag::err_kern_type_not_void_return)\n            << Fn->getType() << Fn->getSourceRange());\n    } else {\n      // CUDA: Calls to global functions must be configured\n      if (FDecl && FDecl->hasAttr<CUDAGlobalAttr>())\n        return ExprError(Diag(LParenLoc, diag::err_global_call_not_config)\n            << FDecl << Fn->getSourceRange());\n    }\n  }\n\n  // Check for a valid return type\n  if (CheckCallReturnType(FuncT->getReturnType(), Fn->getBeginLoc(), TheCall,\n                          FDecl))\n    return ExprError();\n\n  // We know the result type of the call, set it.\n  TheCall->setType(FuncT->getCallResultType(Context));\n  TheCall->setValueKind(Expr::getValueKindForType(FuncT->getReturnType()));\n\n  if (Proto) {\n    if (ConvertArgumentsForCall(TheCall, Fn, FDecl, Proto, Args, RParenLoc,\n                                IsExecConfig))\n      return ExprError();\n  } else {\n    assert(isa<FunctionNoProtoType>(FuncT) && \"Unknown FunctionType!\");\n\n    if (FDecl) {\n      // Check if we have too few/too many template arguments, based\n      // on our knowledge of the function definition.\n      const FunctionDecl *Def = nullptr;\n      if (FDecl->hasBody(Def) && Args.size() != Def->param_size()) {\n        Proto = Def->getType()->getAs<FunctionProtoType>();\n       if (!Proto || !(Proto->isVariadic() && Args.size() >= Def->param_size()))\n          Diag(RParenLoc, diag::warn_call_wrong_number_of_arguments)\n          << (Args.size() > Def->param_size()) << FDecl << Fn->getSourceRange();\n      }\n\n      // If the function we're calling isn't a function prototype, but we have\n      // a function prototype from a prior declaratiom, use that prototype.\n      if (!FDecl->hasPrototype())\n        Proto = FDecl->getType()->getAs<FunctionProtoType>();\n    }\n\n    // Promote the arguments (C99 6.5.2.2p6).\n    for (unsigned i = 0, e = Args.size(); i != e; i++) {\n      Expr *Arg = Args[i];\n\n      if (Proto && i < Proto->getNumParams()) {\n        InitializedEntity Entity = InitializedEntity::InitializeParameter(\n            Context, Proto->getParamType(i), Proto->isParamConsumed(i));\n        ExprResult ArgE =\n            PerformCopyInitialization(Entity, SourceLocation(), Arg);\n        if (ArgE.isInvalid())\n          return true;\n\n        Arg = ArgE.getAs<Expr>();\n\n      } else {\n        ExprResult ArgE = DefaultArgumentPromotion(Arg);\n\n        if (ArgE.isInvalid())\n          return true;\n\n        Arg = ArgE.getAs<Expr>();\n      }\n\n      if (RequireCompleteType(Arg->getBeginLoc(), Arg->getType(),\n                              diag::err_call_incomplete_argument, Arg))\n        return ExprError();\n\n      TheCall->setArg(i, Arg);\n    }\n  }\n\n  if (CXXMethodDecl *Method = dyn_cast_or_null<CXXMethodDecl>(FDecl))\n    if (!Method->isStatic())\n      return ExprError(Diag(LParenLoc, diag::err_member_call_without_object)\n        << Fn->getSourceRange());\n\n  // Check for sentinels\n  if (NDecl)\n    DiagnoseSentinelCalls(NDecl, LParenLoc, Args);\n\n  // Warn for unions passing across security boundary (CMSE).\n  if (FuncT != nullptr && FuncT->getCmseNSCallAttr()) {\n    for (unsigned i = 0, e = Args.size(); i != e; i++) {\n      if (const auto *RT =\n              dyn_cast<RecordType>(Args[i]->getType().getCanonicalType())) {\n        if (RT->getDecl()->isOrContainsUnion())\n          Diag(Args[i]->getBeginLoc(), diag::warn_cmse_nonsecure_union)\n              << 0 << i;\n      }\n    }\n  }\n\n  // Do special checking on direct calls to functions.\n  if (FDecl) {\n    if (CheckFunctionCall(FDecl, TheCall, Proto))\n      return ExprError();\n\n    checkFortifiedBuiltinMemoryFunction(FDecl, TheCall);\n\n    if (BuiltinID)\n      return CheckBuiltinFunctionCall(FDecl, BuiltinID, TheCall);\n  } else if (NDecl) {\n    if (CheckPointerCall(NDecl, TheCall, Proto))\n      return ExprError();\n  } else {\n    if (CheckOtherCall(TheCall, Proto))\n      return ExprError();\n  }\n\n  return CheckForImmediateInvocation(MaybeBindToTemporary(TheCall), FDecl);\n}\n\nExprResult\nSema::ActOnCompoundLiteral(SourceLocation LParenLoc, ParsedType Ty,\n                           SourceLocation RParenLoc, Expr *InitExpr) {\n  assert(Ty && \"ActOnCompoundLiteral(): missing type\");\n  assert(InitExpr && \"ActOnCompoundLiteral(): missing expression\");\n\n  TypeSourceInfo *TInfo;\n  QualType literalType = GetTypeFromParser(Ty, &TInfo);\n  if (!TInfo)\n    TInfo = Context.getTrivialTypeSourceInfo(literalType);\n\n  return BuildCompoundLiteralExpr(LParenLoc, TInfo, RParenLoc, InitExpr);\n}\n\nExprResult\nSema::BuildCompoundLiteralExpr(SourceLocation LParenLoc, TypeSourceInfo *TInfo,\n                               SourceLocation RParenLoc, Expr *LiteralExpr) {\n  QualType literalType = TInfo->getType();\n\n  if (literalType->isArrayType()) {\n    if (RequireCompleteSizedType(\n            LParenLoc, Context.getBaseElementType(literalType),\n            diag::err_array_incomplete_or_sizeless_type,\n            SourceRange(LParenLoc, LiteralExpr->getSourceRange().getEnd())))\n      return ExprError();\n    if (literalType->isVariableArrayType())\n      return ExprError(Diag(LParenLoc, diag::err_variable_object_no_init)\n        << SourceRange(LParenLoc, LiteralExpr->getSourceRange().getEnd()));\n  } else if (!literalType->isDependentType() &&\n             RequireCompleteType(LParenLoc, literalType,\n               diag::err_typecheck_decl_incomplete_type,\n               SourceRange(LParenLoc, LiteralExpr->getSourceRange().getEnd())))\n    return ExprError();\n\n  InitializedEntity Entity\n    = InitializedEntity::InitializeCompoundLiteralInit(TInfo);\n  InitializationKind Kind\n    = InitializationKind::CreateCStyleCast(LParenLoc,\n                                           SourceRange(LParenLoc, RParenLoc),\n                                           /*InitList=*/true);\n  InitializationSequence InitSeq(*this, Entity, Kind, LiteralExpr);\n  ExprResult Result = InitSeq.Perform(*this, Entity, Kind, LiteralExpr,\n                                      &literalType);\n  if (Result.isInvalid())\n    return ExprError();\n  LiteralExpr = Result.get();\n\n  bool isFileScope = !CurContext->isFunctionOrMethod();\n\n  // In C, compound literals are l-values for some reason.\n  // For GCC compatibility, in C++, file-scope array compound literals with\n  // constant initializers are also l-values, and compound literals are\n  // otherwise prvalues.\n  //\n  // (GCC also treats C++ list-initialized file-scope array prvalues with\n  // constant initializers as l-values, but that's non-conforming, so we don't\n  // follow it there.)\n  //\n  // FIXME: It would be better to handle the lvalue cases as materializing and\n  // lifetime-extending a temporary object, but our materialized temporaries\n  // representation only supports lifetime extension from a variable, not \"out\n  // of thin air\".\n  // FIXME: For C++, we might want to instead lifetime-extend only if a pointer\n  // is bound to the result of applying array-to-pointer decay to the compound\n  // literal.\n  // FIXME: GCC supports compound literals of reference type, which should\n  // obviously have a value kind derived from the kind of reference involved.\n  ExprValueKind VK =\n      (getLangOpts().CPlusPlus && !(isFileScope && literalType->isArrayType()))\n          ? VK_RValue\n          : VK_LValue;\n\n  if (isFileScope)\n    if (auto ILE = dyn_cast<InitListExpr>(LiteralExpr))\n      for (unsigned i = 0, j = ILE->getNumInits(); i != j; i++) {\n        Expr *Init = ILE->getInit(i);\n        ILE->setInit(i, ConstantExpr::Create(Context, Init));\n      }\n\n  auto *E = new (Context) CompoundLiteralExpr(LParenLoc, TInfo, literalType,\n                                              VK, LiteralExpr, isFileScope);\n  if (isFileScope) {\n    if (!LiteralExpr->isTypeDependent() &&\n        !LiteralExpr->isValueDependent() &&\n        !literalType->isDependentType()) // C99 6.5.2.5p3\n      if (CheckForConstantInitializer(LiteralExpr, literalType))\n        return ExprError();\n  } else if (literalType.getAddressSpace() != LangAS::opencl_private &&\n             literalType.getAddressSpace() != LangAS::Default) {\n    // Embedded-C extensions to C99 6.5.2.5:\n    //   \"If the compound literal occurs inside the body of a function, the\n    //   type name shall not be qualified by an address-space qualifier.\"\n    Diag(LParenLoc, diag::err_compound_literal_with_address_space)\n      << SourceRange(LParenLoc, LiteralExpr->getSourceRange().getEnd());\n    return ExprError();\n  }\n\n  if (!isFileScope && !getLangOpts().CPlusPlus) {\n    // Compound literals that have automatic storage duration are destroyed at\n    // the end of the scope in C; in C++, they're just temporaries.\n\n    // Emit diagnostics if it is or contains a C union type that is non-trivial\n    // to destruct.\n    if (E->getType().hasNonTrivialToPrimitiveDestructCUnion())\n      checkNonTrivialCUnion(E->getType(), E->getExprLoc(),\n                            NTCUC_CompoundLiteral, NTCUK_Destruct);\n\n    // Diagnose jumps that enter or exit the lifetime of the compound literal.\n    if (literalType.isDestructedType()) {\n      Cleanup.setExprNeedsCleanups(true);\n      ExprCleanupObjects.push_back(E);\n      getCurFunction()->setHasBranchProtectedScope();\n    }\n  }\n\n  if (E->getType().hasNonTrivialToPrimitiveDefaultInitializeCUnion() ||\n      E->getType().hasNonTrivialToPrimitiveCopyCUnion())\n    checkNonTrivialCUnionInInitializer(E->getInitializer(),\n                                       E->getInitializer()->getExprLoc());\n\n  return MaybeBindToTemporary(E);\n}\n\nExprResult\nSema::ActOnInitList(SourceLocation LBraceLoc, MultiExprArg InitArgList,\n                    SourceLocation RBraceLoc) {\n  // Only produce each kind of designated initialization diagnostic once.\n  SourceLocation FirstDesignator;\n  bool DiagnosedArrayDesignator = false;\n  bool DiagnosedNestedDesignator = false;\n  bool DiagnosedMixedDesignator = false;\n\n  // Check that any designated initializers are syntactically valid in the\n  // current language mode.\n  for (unsigned I = 0, E = InitArgList.size(); I != E; ++I) {\n    if (auto *DIE = dyn_cast<DesignatedInitExpr>(InitArgList[I])) {\n      if (FirstDesignator.isInvalid())\n        FirstDesignator = DIE->getBeginLoc();\n\n      if (!getLangOpts().CPlusPlus)\n        break;\n\n      if (!DiagnosedNestedDesignator && DIE->size() > 1) {\n        DiagnosedNestedDesignator = true;\n        Diag(DIE->getBeginLoc(), diag::ext_designated_init_nested)\n          << DIE->getDesignatorsSourceRange();\n      }\n\n      for (auto &Desig : DIE->designators()) {\n        if (!Desig.isFieldDesignator() && !DiagnosedArrayDesignator) {\n          DiagnosedArrayDesignator = true;\n          Diag(Desig.getBeginLoc(), diag::ext_designated_init_array)\n            << Desig.getSourceRange();\n        }\n      }\n\n      if (!DiagnosedMixedDesignator &&\n          !isa<DesignatedInitExpr>(InitArgList[0])) {\n        DiagnosedMixedDesignator = true;\n        Diag(DIE->getBeginLoc(), diag::ext_designated_init_mixed)\n          << DIE->getSourceRange();\n        Diag(InitArgList[0]->getBeginLoc(), diag::note_designated_init_mixed)\n          << InitArgList[0]->getSourceRange();\n      }\n    } else if (getLangOpts().CPlusPlus && !DiagnosedMixedDesignator &&\n               isa<DesignatedInitExpr>(InitArgList[0])) {\n      DiagnosedMixedDesignator = true;\n      auto *DIE = cast<DesignatedInitExpr>(InitArgList[0]);\n      Diag(DIE->getBeginLoc(), diag::ext_designated_init_mixed)\n        << DIE->getSourceRange();\n      Diag(InitArgList[I]->getBeginLoc(), diag::note_designated_init_mixed)\n        << InitArgList[I]->getSourceRange();\n    }\n  }\n\n  if (FirstDesignator.isValid()) {\n    // Only diagnose designated initiaization as a C++20 extension if we didn't\n    // already diagnose use of (non-C++20) C99 designator syntax.\n    if (getLangOpts().CPlusPlus && !DiagnosedArrayDesignator &&\n        !DiagnosedNestedDesignator && !DiagnosedMixedDesignator) {\n      Diag(FirstDesignator, getLangOpts().CPlusPlus20\n                                ? diag::warn_cxx17_compat_designated_init\n                                : diag::ext_cxx_designated_init);\n    } else if (!getLangOpts().CPlusPlus && !getLangOpts().C99) {\n      Diag(FirstDesignator, diag::ext_designated_init);\n    }\n  }\n\n  return BuildInitList(LBraceLoc, InitArgList, RBraceLoc);\n}\n\nExprResult\nSema::BuildInitList(SourceLocation LBraceLoc, MultiExprArg InitArgList,\n                    SourceLocation RBraceLoc) {\n  // Semantic analysis for initializers is done by ActOnDeclarator() and\n  // CheckInitializer() - it requires knowledge of the object being initialized.\n\n  // Immediately handle non-overload placeholders.  Overloads can be\n  // resolved contextually, but everything else here can't.\n  for (unsigned I = 0, E = InitArgList.size(); I != E; ++I) {\n    if (InitArgList[I]->getType()->isNonOverloadPlaceholderType()) {\n      ExprResult result = CheckPlaceholderExpr(InitArgList[I]);\n\n      // Ignore failures; dropping the entire initializer list because\n      // of one failure would be terrible for indexing/etc.\n      if (result.isInvalid()) continue;\n\n      InitArgList[I] = result.get();\n    }\n  }\n\n  InitListExpr *E = new (Context) InitListExpr(Context, LBraceLoc, InitArgList,\n                                               RBraceLoc);\n  E->setType(Context.VoidTy); // FIXME: just a place holder for now.\n  return E;\n}\n\n/// Do an explicit extend of the given block pointer if we're in ARC.\nvoid Sema::maybeExtendBlockObject(ExprResult &E) {\n  assert(E.get()->getType()->isBlockPointerType());\n  assert(E.get()->isRValue());\n\n  // Only do this in an r-value context.\n  if (!getLangOpts().ObjCAutoRefCount) return;\n\n  E = ImplicitCastExpr::Create(\n      Context, E.get()->getType(), CK_ARCExtendBlockObject, E.get(),\n      /*base path*/ nullptr, VK_RValue, FPOptionsOverride());\n  Cleanup.setExprNeedsCleanups(true);\n}\n\n/// Prepare a conversion of the given expression to an ObjC object\n/// pointer type.\nCastKind Sema::PrepareCastToObjCObjectPointer(ExprResult &E) {\n  QualType type = E.get()->getType();\n  if (type->isObjCObjectPointerType()) {\n    return CK_BitCast;\n  } else if (type->isBlockPointerType()) {\n    maybeExtendBlockObject(E);\n    return CK_BlockPointerToObjCPointerCast;\n  } else {\n    assert(type->isPointerType());\n    return CK_CPointerToObjCPointerCast;\n  }\n}\n\n/// Prepares for a scalar cast, performing all the necessary stages\n/// except the final cast and returning the kind required.\nCastKind Sema::PrepareScalarCast(ExprResult &Src, QualType DestTy) {\n  // Both Src and Dest are scalar types, i.e. arithmetic or pointer.\n  // Also, callers should have filtered out the invalid cases with\n  // pointers.  Everything else should be possible.\n\n  QualType SrcTy = Src.get()->getType();\n  if (Context.hasSameUnqualifiedType(SrcTy, DestTy))\n    return CK_NoOp;\n\n  switch (Type::ScalarTypeKind SrcKind = SrcTy->getScalarTypeKind()) {\n  case Type::STK_MemberPointer:\n    llvm_unreachable(\"member pointer type in C\");\n\n  case Type::STK_CPointer:\n  case Type::STK_BlockPointer:\n  case Type::STK_ObjCObjectPointer:\n    switch (DestTy->getScalarTypeKind()) {\n    case Type::STK_CPointer: {\n      LangAS SrcAS = SrcTy->getPointeeType().getAddressSpace();\n      LangAS DestAS = DestTy->getPointeeType().getAddressSpace();\n      if (SrcAS != DestAS)\n        return CK_AddressSpaceConversion;\n      if (Context.hasCvrSimilarType(SrcTy, DestTy))\n        return CK_NoOp;\n      return CK_BitCast;\n    }\n    case Type::STK_BlockPointer:\n      return (SrcKind == Type::STK_BlockPointer\n                ? CK_BitCast : CK_AnyPointerToBlockPointerCast);\n    case Type::STK_ObjCObjectPointer:\n      if (SrcKind == Type::STK_ObjCObjectPointer)\n        return CK_BitCast;\n      if (SrcKind == Type::STK_CPointer)\n        return CK_CPointerToObjCPointerCast;\n      maybeExtendBlockObject(Src);\n      return CK_BlockPointerToObjCPointerCast;\n    case Type::STK_Bool:\n      return CK_PointerToBoolean;\n    case Type::STK_Integral:\n      return CK_PointerToIntegral;\n    case Type::STK_Floating:\n    case Type::STK_FloatingComplex:\n    case Type::STK_IntegralComplex:\n    case Type::STK_MemberPointer:\n    case Type::STK_FixedPoint:\n      llvm_unreachable(\"illegal cast from pointer\");\n    }\n    llvm_unreachable(\"Should have returned before this\");\n\n  case Type::STK_FixedPoint:\n    switch (DestTy->getScalarTypeKind()) {\n    case Type::STK_FixedPoint:\n      return CK_FixedPointCast;\n    case Type::STK_Bool:\n      return CK_FixedPointToBoolean;\n    case Type::STK_Integral:\n      return CK_FixedPointToIntegral;\n    case Type::STK_Floating:\n      return CK_FixedPointToFloating;\n    case Type::STK_IntegralComplex:\n    case Type::STK_FloatingComplex:\n      Diag(Src.get()->getExprLoc(),\n           diag::err_unimplemented_conversion_with_fixed_point_type)\n          << DestTy;\n      return CK_IntegralCast;\n    case Type::STK_CPointer:\n    case Type::STK_ObjCObjectPointer:\n    case Type::STK_BlockPointer:\n    case Type::STK_MemberPointer:\n      llvm_unreachable(\"illegal cast to pointer type\");\n    }\n    llvm_unreachable(\"Should have returned before this\");\n\n  case Type::STK_Bool: // casting from bool is like casting from an integer\n  case Type::STK_Integral:\n    switch (DestTy->getScalarTypeKind()) {\n    case Type::STK_CPointer:\n    case Type::STK_ObjCObjectPointer:\n    case Type::STK_BlockPointer:\n      if (Src.get()->isNullPointerConstant(Context,\n                                           Expr::NPC_ValueDependentIsNull))\n        return CK_NullToPointer;\n      return CK_IntegralToPointer;\n    case Type::STK_Bool:\n      return CK_IntegralToBoolean;\n    case Type::STK_Integral:\n      return CK_IntegralCast;\n    case Type::STK_Floating:\n      return CK_IntegralToFloating;\n    case Type::STK_IntegralComplex:\n      Src = ImpCastExprToType(Src.get(),\n                      DestTy->castAs<ComplexType>()->getElementType(),\n                      CK_IntegralCast);\n      return CK_IntegralRealToComplex;\n    case Type::STK_FloatingComplex:\n      Src = ImpCastExprToType(Src.get(),\n                      DestTy->castAs<ComplexType>()->getElementType(),\n                      CK_IntegralToFloating);\n      return CK_FloatingRealToComplex;\n    case Type::STK_MemberPointer:\n      llvm_unreachable(\"member pointer type in C\");\n    case Type::STK_FixedPoint:\n      return CK_IntegralToFixedPoint;\n    }\n    llvm_unreachable(\"Should have returned before this\");\n\n  case Type::STK_Floating:\n    switch (DestTy->getScalarTypeKind()) {\n    case Type::STK_Floating:\n      return CK_FloatingCast;\n    case Type::STK_Bool:\n      return CK_FloatingToBoolean;\n    case Type::STK_Integral:\n      return CK_FloatingToIntegral;\n    case Type::STK_FloatingComplex:\n      Src = ImpCastExprToType(Src.get(),\n                              DestTy->castAs<ComplexType>()->getElementType(),\n                              CK_FloatingCast);\n      return CK_FloatingRealToComplex;\n    case Type::STK_IntegralComplex:\n      Src = ImpCastExprToType(Src.get(),\n                              DestTy->castAs<ComplexType>()->getElementType(),\n                              CK_FloatingToIntegral);\n      return CK_IntegralRealToComplex;\n    case Type::STK_CPointer:\n    case Type::STK_ObjCObjectPointer:\n    case Type::STK_BlockPointer:\n      llvm_unreachable(\"valid float->pointer cast?\");\n    case Type::STK_MemberPointer:\n      llvm_unreachable(\"member pointer type in C\");\n    case Type::STK_FixedPoint:\n      return CK_FloatingToFixedPoint;\n    }\n    llvm_unreachable(\"Should have returned before this\");\n\n  case Type::STK_FloatingComplex:\n    switch (DestTy->getScalarTypeKind()) {\n    case Type::STK_FloatingComplex:\n      return CK_FloatingComplexCast;\n    case Type::STK_IntegralComplex:\n      return CK_FloatingComplexToIntegralComplex;\n    case Type::STK_Floating: {\n      QualType ET = SrcTy->castAs<ComplexType>()->getElementType();\n      if (Context.hasSameType(ET, DestTy))\n        return CK_FloatingComplexToReal;\n      Src = ImpCastExprToType(Src.get(), ET, CK_FloatingComplexToReal);\n      return CK_FloatingCast;\n    }\n    case Type::STK_Bool:\n      return CK_FloatingComplexToBoolean;\n    case Type::STK_Integral:\n      Src = ImpCastExprToType(Src.get(),\n                              SrcTy->castAs<ComplexType>()->getElementType(),\n                              CK_FloatingComplexToReal);\n      return CK_FloatingToIntegral;\n    case Type::STK_CPointer:\n    case Type::STK_ObjCObjectPointer:\n    case Type::STK_BlockPointer:\n      llvm_unreachable(\"valid complex float->pointer cast?\");\n    case Type::STK_MemberPointer:\n      llvm_unreachable(\"member pointer type in C\");\n    case Type::STK_FixedPoint:\n      Diag(Src.get()->getExprLoc(),\n           diag::err_unimplemented_conversion_with_fixed_point_type)\n          << SrcTy;\n      return CK_IntegralCast;\n    }\n    llvm_unreachable(\"Should have returned before this\");\n\n  case Type::STK_IntegralComplex:\n    switch (DestTy->getScalarTypeKind()) {\n    case Type::STK_FloatingComplex:\n      return CK_IntegralComplexToFloatingComplex;\n    case Type::STK_IntegralComplex:\n      return CK_IntegralComplexCast;\n    case Type::STK_Integral: {\n      QualType ET = SrcTy->castAs<ComplexType>()->getElementType();\n      if (Context.hasSameType(ET, DestTy))\n        return CK_IntegralComplexToReal;\n      Src = ImpCastExprToType(Src.get(), ET, CK_IntegralComplexToReal);\n      return CK_IntegralCast;\n    }\n    case Type::STK_Bool:\n      return CK_IntegralComplexToBoolean;\n    case Type::STK_Floating:\n      Src = ImpCastExprToType(Src.get(),\n                              SrcTy->castAs<ComplexType>()->getElementType(),\n                              CK_IntegralComplexToReal);\n      return CK_IntegralToFloating;\n    case Type::STK_CPointer:\n    case Type::STK_ObjCObjectPointer:\n    case Type::STK_BlockPointer:\n      llvm_unreachable(\"valid complex int->pointer cast?\");\n    case Type::STK_MemberPointer:\n      llvm_unreachable(\"member pointer type in C\");\n    case Type::STK_FixedPoint:\n      Diag(Src.get()->getExprLoc(),\n           diag::err_unimplemented_conversion_with_fixed_point_type)\n          << SrcTy;\n      return CK_IntegralCast;\n    }\n    llvm_unreachable(\"Should have returned before this\");\n  }\n\n  llvm_unreachable(\"Unhandled scalar cast\");\n}\n\nstatic bool breakDownVectorType(QualType type, uint64_t &len,\n                                QualType &eltType) {\n  // Vectors are simple.\n  if (const VectorType *vecType = type->getAs<VectorType>()) {\n    len = vecType->getNumElements();\n    eltType = vecType->getElementType();\n    assert(eltType->isScalarType());\n    return true;\n  }\n\n  // We allow lax conversion to and from non-vector types, but only if\n  // they're real types (i.e. non-complex, non-pointer scalar types).\n  if (!type->isRealType()) return false;\n\n  len = 1;\n  eltType = type;\n  return true;\n}\n\n/// Are the two types SVE-bitcast-compatible types? I.e. is bitcasting from the\n/// first SVE type (e.g. an SVE VLAT) to the second type (e.g. an SVE VLST)\n/// allowed?\n///\n/// This will also return false if the two given types do not make sense from\n/// the perspective of SVE bitcasts.\nbool Sema::isValidSveBitcast(QualType srcTy, QualType destTy) {\n  assert(srcTy->isVectorType() || destTy->isVectorType());\n\n  auto ValidScalableConversion = [](QualType FirstType, QualType SecondType) {\n    if (!FirstType->isSizelessBuiltinType())\n      return false;\n\n    const auto *VecTy = SecondType->getAs<VectorType>();\n    return VecTy &&\n           VecTy->getVectorKind() == VectorType::SveFixedLengthDataVector;\n  };\n\n  return ValidScalableConversion(srcTy, destTy) ||\n         ValidScalableConversion(destTy, srcTy);\n}\n\n/// Are the two types lax-compatible vector types?  That is, given\n/// that one of them is a vector, do they have equal storage sizes,\n/// where the storage size is the number of elements times the element\n/// size?\n///\n/// This will also return false if either of the types is neither a\n/// vector nor a real type.\nbool Sema::areLaxCompatibleVectorTypes(QualType srcTy, QualType destTy) {\n  assert(destTy->isVectorType() || srcTy->isVectorType());\n\n  // Disallow lax conversions between scalars and ExtVectors (these\n  // conversions are allowed for other vector types because common headers\n  // depend on them).  Most scalar OP ExtVector cases are handled by the\n  // splat path anyway, which does what we want (convert, not bitcast).\n  // What this rules out for ExtVectors is crazy things like char4*float.\n  if (srcTy->isScalarType() && destTy->isExtVectorType()) return false;\n  if (destTy->isScalarType() && srcTy->isExtVectorType()) return false;\n\n  uint64_t srcLen, destLen;\n  QualType srcEltTy, destEltTy;\n  if (!breakDownVectorType(srcTy, srcLen, srcEltTy)) return false;\n  if (!breakDownVectorType(destTy, destLen, destEltTy)) return false;\n\n  // ASTContext::getTypeSize will return the size rounded up to a\n  // power of 2, so instead of using that, we need to use the raw\n  // element size multiplied by the element count.\n  uint64_t srcEltSize = Context.getTypeSize(srcEltTy);\n  uint64_t destEltSize = Context.getTypeSize(destEltTy);\n\n  return (srcLen * srcEltSize == destLen * destEltSize);\n}\n\n/// Is this a legal conversion between two types, one of which is\n/// known to be a vector type?\nbool Sema::isLaxVectorConversion(QualType srcTy, QualType destTy) {\n  assert(destTy->isVectorType() || srcTy->isVectorType());\n\n  switch (Context.getLangOpts().getLaxVectorConversions()) {\n  case LangOptions::LaxVectorConversionKind::None:\n    return false;\n\n  case LangOptions::LaxVectorConversionKind::Integer:\n    if (!srcTy->isIntegralOrEnumerationType()) {\n      auto *Vec = srcTy->getAs<VectorType>();\n      if (!Vec || !Vec->getElementType()->isIntegralOrEnumerationType())\n        return false;\n    }\n    if (!destTy->isIntegralOrEnumerationType()) {\n      auto *Vec = destTy->getAs<VectorType>();\n      if (!Vec || !Vec->getElementType()->isIntegralOrEnumerationType())\n        return false;\n    }\n    // OK, integer (vector) -> integer (vector) bitcast.\n    break;\n\n    case LangOptions::LaxVectorConversionKind::All:\n    break;\n  }\n\n  return areLaxCompatibleVectorTypes(srcTy, destTy);\n}\n\nbool Sema::CheckVectorCast(SourceRange R, QualType VectorTy, QualType Ty,\n                           CastKind &Kind) {\n  assert(VectorTy->isVectorType() && \"Not a vector type!\");\n\n  if (Ty->isVectorType() || Ty->isIntegralType(Context)) {\n    if (!areLaxCompatibleVectorTypes(Ty, VectorTy))\n      return Diag(R.getBegin(),\n                  Ty->isVectorType() ?\n                  diag::err_invalid_conversion_between_vectors :\n                  diag::err_invalid_conversion_between_vector_and_integer)\n        << VectorTy << Ty << R;\n  } else\n    return Diag(R.getBegin(),\n                diag::err_invalid_conversion_between_vector_and_scalar)\n      << VectorTy << Ty << R;\n\n  Kind = CK_BitCast;\n  return false;\n}\n\nExprResult Sema::prepareVectorSplat(QualType VectorTy, Expr *SplattedExpr) {\n  QualType DestElemTy = VectorTy->castAs<VectorType>()->getElementType();\n\n  if (DestElemTy == SplattedExpr->getType())\n    return SplattedExpr;\n\n  assert(DestElemTy->isFloatingType() ||\n         DestElemTy->isIntegralOrEnumerationType());\n\n  CastKind CK;\n  if (VectorTy->isExtVectorType() && SplattedExpr->getType()->isBooleanType()) {\n    // OpenCL requires that we convert `true` boolean expressions to -1, but\n    // only when splatting vectors.\n    if (DestElemTy->isFloatingType()) {\n      // To avoid having to have a CK_BooleanToSignedFloating cast kind, we cast\n      // in two steps: boolean to signed integral, then to floating.\n      ExprResult CastExprRes = ImpCastExprToType(SplattedExpr, Context.IntTy,\n                                                 CK_BooleanToSignedIntegral);\n      SplattedExpr = CastExprRes.get();\n      CK = CK_IntegralToFloating;\n    } else {\n      CK = CK_BooleanToSignedIntegral;\n    }\n  } else {\n    ExprResult CastExprRes = SplattedExpr;\n    CK = PrepareScalarCast(CastExprRes, DestElemTy);\n    if (CastExprRes.isInvalid())\n      return ExprError();\n    SplattedExpr = CastExprRes.get();\n  }\n  return ImpCastExprToType(SplattedExpr, DestElemTy, CK);\n}\n\nExprResult Sema::CheckExtVectorCast(SourceRange R, QualType DestTy,\n                                    Expr *CastExpr, CastKind &Kind) {\n  assert(DestTy->isExtVectorType() && \"Not an extended vector type!\");\n\n  QualType SrcTy = CastExpr->getType();\n\n  // If SrcTy is a VectorType, the total size must match to explicitly cast to\n  // an ExtVectorType.\n  // In OpenCL, casts between vectors of different types are not allowed.\n  // (See OpenCL 6.2).\n  if (SrcTy->isVectorType()) {\n    if (!areLaxCompatibleVectorTypes(SrcTy, DestTy) ||\n        (getLangOpts().OpenCL &&\n         !Context.hasSameUnqualifiedType(DestTy, SrcTy))) {\n      Diag(R.getBegin(),diag::err_invalid_conversion_between_ext_vectors)\n        << DestTy << SrcTy << R;\n      return ExprError();\n    }\n    Kind = CK_BitCast;\n    return CastExpr;\n  }\n\n  // All non-pointer scalars can be cast to ExtVector type.  The appropriate\n  // conversion will take place first from scalar to elt type, and then\n  // splat from elt type to vector.\n  if (SrcTy->isPointerType())\n    return Diag(R.getBegin(),\n                diag::err_invalid_conversion_between_vector_and_scalar)\n      << DestTy << SrcTy << R;\n\n  Kind = CK_VectorSplat;\n  return prepareVectorSplat(DestTy, CastExpr);\n}\n\nExprResult\nSema::ActOnCastExpr(Scope *S, SourceLocation LParenLoc,\n                    Declarator &D, ParsedType &Ty,\n                    SourceLocation RParenLoc, Expr *CastExpr) {\n  assert(!D.isInvalidType() && (CastExpr != nullptr) &&\n         \"ActOnCastExpr(): missing type or expr\");\n\n  TypeSourceInfo *castTInfo = GetTypeForDeclaratorCast(D, CastExpr->getType());\n  if (D.isInvalidType())\n    return ExprError();\n\n  if (getLangOpts().CPlusPlus) {\n    // Check that there are no default arguments (C++ only).\n    CheckExtraCXXDefaultArguments(D);\n  } else {\n    // Make sure any TypoExprs have been dealt with.\n    ExprResult Res = CorrectDelayedTyposInExpr(CastExpr);\n    if (!Res.isUsable())\n      return ExprError();\n    CastExpr = Res.get();\n  }\n\n  checkUnusedDeclAttributes(D);\n\n  QualType castType = castTInfo->getType();\n  Ty = CreateParsedType(castType, castTInfo);\n\n  bool isVectorLiteral = false;\n\n  // Check for an altivec or OpenCL literal,\n  // i.e. all the elements are integer constants.\n  ParenExpr *PE = dyn_cast<ParenExpr>(CastExpr);\n  ParenListExpr *PLE = dyn_cast<ParenListExpr>(CastExpr);\n  if ((getLangOpts().AltiVec || getLangOpts().ZVector || getLangOpts().OpenCL)\n       && castType->isVectorType() && (PE || PLE)) {\n    if (PLE && PLE->getNumExprs() == 0) {\n      Diag(PLE->getExprLoc(), diag::err_altivec_empty_initializer);\n      return ExprError();\n    }\n    if (PE || PLE->getNumExprs() == 1) {\n      Expr *E = (PE ? PE->getSubExpr() : PLE->getExpr(0));\n      if (!E->isTypeDependent() && !E->getType()->isVectorType())\n        isVectorLiteral = true;\n    }\n    else\n      isVectorLiteral = true;\n  }\n\n  // If this is a vector initializer, '(' type ')' '(' init, ..., init ')'\n  // then handle it as such.\n  if (isVectorLiteral)\n    return BuildVectorLiteral(LParenLoc, RParenLoc, CastExpr, castTInfo);\n\n  // If the Expr being casted is a ParenListExpr, handle it specially.\n  // This is not an AltiVec-style cast, so turn the ParenListExpr into a\n  // sequence of BinOp comma operators.\n  if (isa<ParenListExpr>(CastExpr)) {\n    ExprResult Result = MaybeConvertParenListExprToParenExpr(S, CastExpr);\n    if (Result.isInvalid()) return ExprError();\n    CastExpr = Result.get();\n  }\n\n  if (getLangOpts().CPlusPlus && !castType->isVoidType() &&\n      !getSourceManager().isInSystemMacro(LParenLoc))\n    Diag(LParenLoc, diag::warn_old_style_cast) << CastExpr->getSourceRange();\n\n  CheckTollFreeBridgeCast(castType, CastExpr);\n\n  CheckObjCBridgeRelatedCast(castType, CastExpr);\n\n  DiscardMisalignedMemberAddress(castType.getTypePtr(), CastExpr);\n\n  return BuildCStyleCastExpr(LParenLoc, castTInfo, RParenLoc, CastExpr);\n}\n\nExprResult Sema::BuildVectorLiteral(SourceLocation LParenLoc,\n                                    SourceLocation RParenLoc, Expr *E,\n                                    TypeSourceInfo *TInfo) {\n  assert((isa<ParenListExpr>(E) || isa<ParenExpr>(E)) &&\n         \"Expected paren or paren list expression\");\n\n  Expr **exprs;\n  unsigned numExprs;\n  Expr *subExpr;\n  SourceLocation LiteralLParenLoc, LiteralRParenLoc;\n  if (ParenListExpr *PE = dyn_cast<ParenListExpr>(E)) {\n    LiteralLParenLoc = PE->getLParenLoc();\n    LiteralRParenLoc = PE->getRParenLoc();\n    exprs = PE->getExprs();\n    numExprs = PE->getNumExprs();\n  } else { // isa<ParenExpr> by assertion at function entrance\n    LiteralLParenLoc = cast<ParenExpr>(E)->getLParen();\n    LiteralRParenLoc = cast<ParenExpr>(E)->getRParen();\n    subExpr = cast<ParenExpr>(E)->getSubExpr();\n    exprs = &subExpr;\n    numExprs = 1;\n  }\n\n  QualType Ty = TInfo->getType();\n  assert(Ty->isVectorType() && \"Expected vector type\");\n\n  SmallVector<Expr *, 8> initExprs;\n  const VectorType *VTy = Ty->castAs<VectorType>();\n  unsigned numElems = VTy->getNumElements();\n\n  // '(...)' form of vector initialization in AltiVec: the number of\n  // initializers must be one or must match the size of the vector.\n  // If a single value is specified in the initializer then it will be\n  // replicated to all the components of the vector\n  if (VTy->getVectorKind() == VectorType::AltiVecVector) {\n    // The number of initializers must be one or must match the size of the\n    // vector. If a single value is specified in the initializer then it will\n    // be replicated to all the components of the vector\n    if (numExprs == 1) {\n      QualType ElemTy = VTy->getElementType();\n      ExprResult Literal = DefaultLvalueConversion(exprs[0]);\n      if (Literal.isInvalid())\n        return ExprError();\n      Literal = ImpCastExprToType(Literal.get(), ElemTy,\n                                  PrepareScalarCast(Literal, ElemTy));\n      return BuildCStyleCastExpr(LParenLoc, TInfo, RParenLoc, Literal.get());\n    }\n    else if (numExprs < numElems) {\n      Diag(E->getExprLoc(),\n           diag::err_incorrect_number_of_vector_initializers);\n      return ExprError();\n    }\n    else\n      initExprs.append(exprs, exprs + numExprs);\n  }\n  else {\n    // For OpenCL, when the number of initializers is a single value,\n    // it will be replicated to all components of the vector.\n    if (getLangOpts().OpenCL &&\n        VTy->getVectorKind() == VectorType::GenericVector &&\n        numExprs == 1) {\n        QualType ElemTy = VTy->getElementType();\n        ExprResult Literal = DefaultLvalueConversion(exprs[0]);\n        if (Literal.isInvalid())\n          return ExprError();\n        Literal = ImpCastExprToType(Literal.get(), ElemTy,\n                                    PrepareScalarCast(Literal, ElemTy));\n        return BuildCStyleCastExpr(LParenLoc, TInfo, RParenLoc, Literal.get());\n    }\n\n    initExprs.append(exprs, exprs + numExprs);\n  }\n  // FIXME: This means that pretty-printing the final AST will produce curly\n  // braces instead of the original commas.\n  InitListExpr *initE = new (Context) InitListExpr(Context, LiteralLParenLoc,\n                                                   initExprs, LiteralRParenLoc);\n  initE->setType(Ty);\n  return BuildCompoundLiteralExpr(LParenLoc, TInfo, RParenLoc, initE);\n}\n\n/// This is not an AltiVec-style cast or or C++ direct-initialization, so turn\n/// the ParenListExpr into a sequence of comma binary operators.\nExprResult\nSema::MaybeConvertParenListExprToParenExpr(Scope *S, Expr *OrigExpr) {\n  ParenListExpr *E = dyn_cast<ParenListExpr>(OrigExpr);\n  if (!E)\n    return OrigExpr;\n\n  ExprResult Result(E->getExpr(0));\n\n  for (unsigned i = 1, e = E->getNumExprs(); i != e && !Result.isInvalid(); ++i)\n    Result = ActOnBinOp(S, E->getExprLoc(), tok::comma, Result.get(),\n                        E->getExpr(i));\n\n  if (Result.isInvalid()) return ExprError();\n\n  return ActOnParenExpr(E->getLParenLoc(), E->getRParenLoc(), Result.get());\n}\n\nExprResult Sema::ActOnParenListExpr(SourceLocation L,\n                                    SourceLocation R,\n                                    MultiExprArg Val) {\n  return ParenListExpr::Create(Context, L, Val, R);\n}\n\n/// Emit a specialized diagnostic when one expression is a null pointer\n/// constant and the other is not a pointer.  Returns true if a diagnostic is\n/// emitted.\nbool Sema::DiagnoseConditionalForNull(Expr *LHSExpr, Expr *RHSExpr,\n                                      SourceLocation QuestionLoc) {\n  Expr *NullExpr = LHSExpr;\n  Expr *NonPointerExpr = RHSExpr;\n  Expr::NullPointerConstantKind NullKind =\n      NullExpr->isNullPointerConstant(Context,\n                                      Expr::NPC_ValueDependentIsNotNull);\n\n  if (NullKind == Expr::NPCK_NotNull) {\n    NullExpr = RHSExpr;\n    NonPointerExpr = LHSExpr;\n    NullKind =\n        NullExpr->isNullPointerConstant(Context,\n                                        Expr::NPC_ValueDependentIsNotNull);\n  }\n\n  if (NullKind == Expr::NPCK_NotNull)\n    return false;\n\n  if (NullKind == Expr::NPCK_ZeroExpression)\n    return false;\n\n  if (NullKind == Expr::NPCK_ZeroLiteral) {\n    // In this case, check to make sure that we got here from a \"NULL\"\n    // string in the source code.\n    NullExpr = NullExpr->IgnoreParenImpCasts();\n    SourceLocation loc = NullExpr->getExprLoc();\n    if (!findMacroSpelling(loc, \"NULL\"))\n      return false;\n  }\n\n  int DiagType = (NullKind == Expr::NPCK_CXX11_nullptr);\n  Diag(QuestionLoc, diag::err_typecheck_cond_incompatible_operands_null)\n      << NonPointerExpr->getType() << DiagType\n      << NonPointerExpr->getSourceRange();\n  return true;\n}\n\n/// Return false if the condition expression is valid, true otherwise.\nstatic bool checkCondition(Sema &S, Expr *Cond, SourceLocation QuestionLoc) {\n  QualType CondTy = Cond->getType();\n\n  // OpenCL v1.1 s6.3.i says the condition cannot be a floating point type.\n  if (S.getLangOpts().OpenCL && CondTy->isFloatingType()) {\n    S.Diag(QuestionLoc, diag::err_typecheck_cond_expect_nonfloat)\n      << CondTy << Cond->getSourceRange();\n    return true;\n  }\n\n  // C99 6.5.15p2\n  if (CondTy->isScalarType()) return false;\n\n  S.Diag(QuestionLoc, diag::err_typecheck_cond_expect_scalar)\n    << CondTy << Cond->getSourceRange();\n  return true;\n}\n\n/// Handle when one or both operands are void type.\nstatic QualType checkConditionalVoidType(Sema &S, ExprResult &LHS,\n                                         ExprResult &RHS) {\n    Expr *LHSExpr = LHS.get();\n    Expr *RHSExpr = RHS.get();\n\n    if (!LHSExpr->getType()->isVoidType())\n      S.Diag(RHSExpr->getBeginLoc(), diag::ext_typecheck_cond_one_void)\n          << RHSExpr->getSourceRange();\n    if (!RHSExpr->getType()->isVoidType())\n      S.Diag(LHSExpr->getBeginLoc(), diag::ext_typecheck_cond_one_void)\n          << LHSExpr->getSourceRange();\n    LHS = S.ImpCastExprToType(LHS.get(), S.Context.VoidTy, CK_ToVoid);\n    RHS = S.ImpCastExprToType(RHS.get(), S.Context.VoidTy, CK_ToVoid);\n    return S.Context.VoidTy;\n}\n\n/// Return false if the NullExpr can be promoted to PointerTy,\n/// true otherwise.\nstatic bool checkConditionalNullPointer(Sema &S, ExprResult &NullExpr,\n                                        QualType PointerTy) {\n  if ((!PointerTy->isAnyPointerType() && !PointerTy->isBlockPointerType()) ||\n      !NullExpr.get()->isNullPointerConstant(S.Context,\n                                            Expr::NPC_ValueDependentIsNull))\n    return true;\n\n  NullExpr = S.ImpCastExprToType(NullExpr.get(), PointerTy, CK_NullToPointer);\n  return false;\n}\n\n/// Checks compatibility between two pointers and return the resulting\n/// type.\nstatic QualType checkConditionalPointerCompatibility(Sema &S, ExprResult &LHS,\n                                                     ExprResult &RHS,\n                                                     SourceLocation Loc) {\n  QualType LHSTy = LHS.get()->getType();\n  QualType RHSTy = RHS.get()->getType();\n\n  if (S.Context.hasSameType(LHSTy, RHSTy)) {\n    // Two identical pointers types are always compatible.\n    return LHSTy;\n  }\n\n  QualType lhptee, rhptee;\n\n  // Get the pointee types.\n  bool IsBlockPointer = false;\n  if (const BlockPointerType *LHSBTy = LHSTy->getAs<BlockPointerType>()) {\n    lhptee = LHSBTy->getPointeeType();\n    rhptee = RHSTy->castAs<BlockPointerType>()->getPointeeType();\n    IsBlockPointer = true;\n  } else {\n    lhptee = LHSTy->castAs<PointerType>()->getPointeeType();\n    rhptee = RHSTy->castAs<PointerType>()->getPointeeType();\n  }\n\n  // C99 6.5.15p6: If both operands are pointers to compatible types or to\n  // differently qualified versions of compatible types, the result type is\n  // a pointer to an appropriately qualified version of the composite\n  // type.\n\n  // Only CVR-qualifiers exist in the standard, and the differently-qualified\n  // clause doesn't make sense for our extensions. E.g. address space 2 should\n  // be incompatible with address space 3: they may live on different devices or\n  // anything.\n  Qualifiers lhQual = lhptee.getQualifiers();\n  Qualifiers rhQual = rhptee.getQualifiers();\n\n  LangAS ResultAddrSpace = LangAS::Default;\n  LangAS LAddrSpace = lhQual.getAddressSpace();\n  LangAS RAddrSpace = rhQual.getAddressSpace();\n\n  // OpenCL v1.1 s6.5 - Conversion between pointers to distinct address\n  // spaces is disallowed.\n  if (lhQual.isAddressSpaceSupersetOf(rhQual))\n    ResultAddrSpace = LAddrSpace;\n  else if (rhQual.isAddressSpaceSupersetOf(lhQual))\n    ResultAddrSpace = RAddrSpace;\n  else {\n    S.Diag(Loc, diag::err_typecheck_op_on_nonoverlapping_address_space_pointers)\n        << LHSTy << RHSTy << 2 << LHS.get()->getSourceRange()\n        << RHS.get()->getSourceRange();\n    return QualType();\n  }\n\n  unsigned MergedCVRQual = lhQual.getCVRQualifiers() | rhQual.getCVRQualifiers();\n  auto LHSCastKind = CK_BitCast, RHSCastKind = CK_BitCast;\n  lhQual.removeCVRQualifiers();\n  rhQual.removeCVRQualifiers();\n\n  // OpenCL v2.0 specification doesn't extend compatibility of type qualifiers\n  // (C99 6.7.3) for address spaces. We assume that the check should behave in\n  // the same manner as it's defined for CVR qualifiers, so for OpenCL two\n  // qual types are compatible iff\n  //  * corresponded types are compatible\n  //  * CVR qualifiers are equal\n  //  * address spaces are equal\n  // Thus for conditional operator we merge CVR and address space unqualified\n  // pointees and if there is a composite type we return a pointer to it with\n  // merged qualifiers.\n  LHSCastKind =\n      LAddrSpace == ResultAddrSpace ? CK_BitCast : CK_AddressSpaceConversion;\n  RHSCastKind =\n      RAddrSpace == ResultAddrSpace ? CK_BitCast : CK_AddressSpaceConversion;\n  lhQual.removeAddressSpace();\n  rhQual.removeAddressSpace();\n\n  lhptee = S.Context.getQualifiedType(lhptee.getUnqualifiedType(), lhQual);\n  rhptee = S.Context.getQualifiedType(rhptee.getUnqualifiedType(), rhQual);\n\n  QualType CompositeTy = S.Context.mergeTypes(lhptee, rhptee);\n\n  if (CompositeTy.isNull()) {\n    // In this situation, we assume void* type. No especially good\n    // reason, but this is what gcc does, and we do have to pick\n    // to get a consistent AST.\n    QualType incompatTy;\n    incompatTy = S.Context.getPointerType(\n        S.Context.getAddrSpaceQualType(S.Context.VoidTy, ResultAddrSpace));\n    LHS = S.ImpCastExprToType(LHS.get(), incompatTy, LHSCastKind);\n    RHS = S.ImpCastExprToType(RHS.get(), incompatTy, RHSCastKind);\n\n    // FIXME: For OpenCL the warning emission and cast to void* leaves a room\n    // for casts between types with incompatible address space qualifiers.\n    // For the following code the compiler produces casts between global and\n    // local address spaces of the corresponded innermost pointees:\n    // local int *global *a;\n    // global int *global *b;\n    // a = (0 ? a : b); // see C99 6.5.16.1.p1.\n    S.Diag(Loc, diag::ext_typecheck_cond_incompatible_pointers)\n        << LHSTy << RHSTy << LHS.get()->getSourceRange()\n        << RHS.get()->getSourceRange();\n\n    return incompatTy;\n  }\n\n  // The pointer types are compatible.\n  // In case of OpenCL ResultTy should have the address space qualifier\n  // which is a superset of address spaces of both the 2nd and the 3rd\n  // operands of the conditional operator.\n  QualType ResultTy = [&, ResultAddrSpace]() {\n    if (S.getLangOpts().OpenCL) {\n      Qualifiers CompositeQuals = CompositeTy.getQualifiers();\n      CompositeQuals.setAddressSpace(ResultAddrSpace);\n      return S.Context\n          .getQualifiedType(CompositeTy.getUnqualifiedType(), CompositeQuals)\n          .withCVRQualifiers(MergedCVRQual);\n    }\n    return CompositeTy.withCVRQualifiers(MergedCVRQual);\n  }();\n  if (IsBlockPointer)\n    ResultTy = S.Context.getBlockPointerType(ResultTy);\n  else\n    ResultTy = S.Context.getPointerType(ResultTy);\n\n  LHS = S.ImpCastExprToType(LHS.get(), ResultTy, LHSCastKind);\n  RHS = S.ImpCastExprToType(RHS.get(), ResultTy, RHSCastKind);\n  return ResultTy;\n}\n\n/// Return the resulting type when the operands are both block pointers.\nstatic QualType checkConditionalBlockPointerCompatibility(Sema &S,\n                                                          ExprResult &LHS,\n                                                          ExprResult &RHS,\n                                                          SourceLocation Loc) {\n  QualType LHSTy = LHS.get()->getType();\n  QualType RHSTy = RHS.get()->getType();\n\n  if (!LHSTy->isBlockPointerType() || !RHSTy->isBlockPointerType()) {\n    if (LHSTy->isVoidPointerType() || RHSTy->isVoidPointerType()) {\n      QualType destType = S.Context.getPointerType(S.Context.VoidTy);\n      LHS = S.ImpCastExprToType(LHS.get(), destType, CK_BitCast);\n      RHS = S.ImpCastExprToType(RHS.get(), destType, CK_BitCast);\n      return destType;\n    }\n    S.Diag(Loc, diag::err_typecheck_cond_incompatible_operands)\n      << LHSTy << RHSTy << LHS.get()->getSourceRange()\n      << RHS.get()->getSourceRange();\n    return QualType();\n  }\n\n  // We have 2 block pointer types.\n  return checkConditionalPointerCompatibility(S, LHS, RHS, Loc);\n}\n\n/// Return the resulting type when the operands are both pointers.\nstatic QualType\ncheckConditionalObjectPointersCompatibility(Sema &S, ExprResult &LHS,\n                                            ExprResult &RHS,\n                                            SourceLocation Loc) {\n  // get the pointer types\n  QualType LHSTy = LHS.get()->getType();\n  QualType RHSTy = RHS.get()->getType();\n\n  // get the \"pointed to\" types\n  QualType lhptee = LHSTy->castAs<PointerType>()->getPointeeType();\n  QualType rhptee = RHSTy->castAs<PointerType>()->getPointeeType();\n\n  // ignore qualifiers on void (C99 6.5.15p3, clause 6)\n  if (lhptee->isVoidType() && rhptee->isIncompleteOrObjectType()) {\n    // Figure out necessary qualifiers (C99 6.5.15p6)\n    QualType destPointee\n      = S.Context.getQualifiedType(lhptee, rhptee.getQualifiers());\n    QualType destType = S.Context.getPointerType(destPointee);\n    // Add qualifiers if necessary.\n    LHS = S.ImpCastExprToType(LHS.get(), destType, CK_NoOp);\n    // Promote to void*.\n    RHS = S.ImpCastExprToType(RHS.get(), destType, CK_BitCast);\n    return destType;\n  }\n  if (rhptee->isVoidType() && lhptee->isIncompleteOrObjectType()) {\n    QualType destPointee\n      = S.Context.getQualifiedType(rhptee, lhptee.getQualifiers());\n    QualType destType = S.Context.getPointerType(destPointee);\n    // Add qualifiers if necessary.\n    RHS = S.ImpCastExprToType(RHS.get(), destType, CK_NoOp);\n    // Promote to void*.\n    LHS = S.ImpCastExprToType(LHS.get(), destType, CK_BitCast);\n    return destType;\n  }\n\n  return checkConditionalPointerCompatibility(S, LHS, RHS, Loc);\n}\n\n/// Return false if the first expression is not an integer and the second\n/// expression is not a pointer, true otherwise.\nstatic bool checkPointerIntegerMismatch(Sema &S, ExprResult &Int,\n                                        Expr* PointerExpr, SourceLocation Loc,\n                                        bool IsIntFirstExpr) {\n  if (!PointerExpr->getType()->isPointerType() ||\n      !Int.get()->getType()->isIntegerType())\n    return false;\n\n  Expr *Expr1 = IsIntFirstExpr ? Int.get() : PointerExpr;\n  Expr *Expr2 = IsIntFirstExpr ? PointerExpr : Int.get();\n\n  S.Diag(Loc, diag::ext_typecheck_cond_pointer_integer_mismatch)\n    << Expr1->getType() << Expr2->getType()\n    << Expr1->getSourceRange() << Expr2->getSourceRange();\n  Int = S.ImpCastExprToType(Int.get(), PointerExpr->getType(),\n                            CK_IntegralToPointer);\n  return true;\n}\n\n/// Simple conversion between integer and floating point types.\n///\n/// Used when handling the OpenCL conditional operator where the\n/// condition is a vector while the other operands are scalar.\n///\n/// OpenCL v1.1 s6.3.i and s6.11.6 together require that the scalar\n/// types are either integer or floating type. Between the two\n/// operands, the type with the higher rank is defined as the \"result\n/// type\". The other operand needs to be promoted to the same type. No\n/// other type promotion is allowed. We cannot use\n/// UsualArithmeticConversions() for this purpose, since it always\n/// promotes promotable types.\nstatic QualType OpenCLArithmeticConversions(Sema &S, ExprResult &LHS,\n                                            ExprResult &RHS,\n                                            SourceLocation QuestionLoc) {\n  LHS = S.DefaultFunctionArrayLvalueConversion(LHS.get());\n  if (LHS.isInvalid())\n    return QualType();\n  RHS = S.DefaultFunctionArrayLvalueConversion(RHS.get());\n  if (RHS.isInvalid())\n    return QualType();\n\n  // For conversion purposes, we ignore any qualifiers.\n  // For example, \"const float\" and \"float\" are equivalent.\n  QualType LHSType =\n    S.Context.getCanonicalType(LHS.get()->getType()).getUnqualifiedType();\n  QualType RHSType =\n    S.Context.getCanonicalType(RHS.get()->getType()).getUnqualifiedType();\n\n  if (!LHSType->isIntegerType() && !LHSType->isRealFloatingType()) {\n    S.Diag(QuestionLoc, diag::err_typecheck_cond_expect_int_float)\n      << LHSType << LHS.get()->getSourceRange();\n    return QualType();\n  }\n\n  if (!RHSType->isIntegerType() && !RHSType->isRealFloatingType()) {\n    S.Diag(QuestionLoc, diag::err_typecheck_cond_expect_int_float)\n      << RHSType << RHS.get()->getSourceRange();\n    return QualType();\n  }\n\n  // If both types are identical, no conversion is needed.\n  if (LHSType == RHSType)\n    return LHSType;\n\n  // Now handle \"real\" floating types (i.e. float, double, long double).\n  if (LHSType->isRealFloatingType() || RHSType->isRealFloatingType())\n    return handleFloatConversion(S, LHS, RHS, LHSType, RHSType,\n                                 /*IsCompAssign = */ false);\n\n  // Finally, we have two differing integer types.\n  return handleIntegerConversion<doIntegralCast, doIntegralCast>\n  (S, LHS, RHS, LHSType, RHSType, /*IsCompAssign = */ false);\n}\n\n/// Convert scalar operands to a vector that matches the\n///        condition in length.\n///\n/// Used when handling the OpenCL conditional operator where the\n/// condition is a vector while the other operands are scalar.\n///\n/// We first compute the \"result type\" for the scalar operands\n/// according to OpenCL v1.1 s6.3.i. Both operands are then converted\n/// into a vector of that type where the length matches the condition\n/// vector type. s6.11.6 requires that the element types of the result\n/// and the condition must have the same number of bits.\nstatic QualType\nOpenCLConvertScalarsToVectors(Sema &S, ExprResult &LHS, ExprResult &RHS,\n                              QualType CondTy, SourceLocation QuestionLoc) {\n  QualType ResTy = OpenCLArithmeticConversions(S, LHS, RHS, QuestionLoc);\n  if (ResTy.isNull()) return QualType();\n\n  const VectorType *CV = CondTy->getAs<VectorType>();\n  assert(CV);\n\n  // Determine the vector result type\n  unsigned NumElements = CV->getNumElements();\n  QualType VectorTy = S.Context.getExtVectorType(ResTy, NumElements);\n\n  // Ensure that all types have the same number of bits\n  if (S.Context.getTypeSize(CV->getElementType())\n      != S.Context.getTypeSize(ResTy)) {\n    // Since VectorTy is created internally, it does not pretty print\n    // with an OpenCL name. Instead, we just print a description.\n    std::string EleTyName = ResTy.getUnqualifiedType().getAsString();\n    SmallString<64> Str;\n    llvm::raw_svector_ostream OS(Str);\n    OS << \"(vector of \" << NumElements << \" '\" << EleTyName << \"' values)\";\n    S.Diag(QuestionLoc, diag::err_conditional_vector_element_size)\n      << CondTy << OS.str();\n    return QualType();\n  }\n\n  // Convert operands to the vector result type\n  LHS = S.ImpCastExprToType(LHS.get(), VectorTy, CK_VectorSplat);\n  RHS = S.ImpCastExprToType(RHS.get(), VectorTy, CK_VectorSplat);\n\n  return VectorTy;\n}\n\n/// Return false if this is a valid OpenCL condition vector\nstatic bool checkOpenCLConditionVector(Sema &S, Expr *Cond,\n                                       SourceLocation QuestionLoc) {\n  // OpenCL v1.1 s6.11.6 says the elements of the vector must be of\n  // integral type.\n  const VectorType *CondTy = Cond->getType()->getAs<VectorType>();\n  assert(CondTy);\n  QualType EleTy = CondTy->getElementType();\n  if (EleTy->isIntegerType()) return false;\n\n  S.Diag(QuestionLoc, diag::err_typecheck_cond_expect_nonfloat)\n    << Cond->getType() << Cond->getSourceRange();\n  return true;\n}\n\n/// Return false if the vector condition type and the vector\n///        result type are compatible.\n///\n/// OpenCL v1.1 s6.11.6 requires that both vector types have the same\n/// number of elements, and their element types have the same number\n/// of bits.\nstatic bool checkVectorResult(Sema &S, QualType CondTy, QualType VecResTy,\n                              SourceLocation QuestionLoc) {\n  const VectorType *CV = CondTy->getAs<VectorType>();\n  const VectorType *RV = VecResTy->getAs<VectorType>();\n  assert(CV && RV);\n\n  if (CV->getNumElements() != RV->getNumElements()) {\n    S.Diag(QuestionLoc, diag::err_conditional_vector_size)\n      << CondTy << VecResTy;\n    return true;\n  }\n\n  QualType CVE = CV->getElementType();\n  QualType RVE = RV->getElementType();\n\n  if (S.Context.getTypeSize(CVE) != S.Context.getTypeSize(RVE)) {\n    S.Diag(QuestionLoc, diag::err_conditional_vector_element_size)\n      << CondTy << VecResTy;\n    return true;\n  }\n\n  return false;\n}\n\n/// Return the resulting type for the conditional operator in\n///        OpenCL (aka \"ternary selection operator\", OpenCL v1.1\n///        s6.3.i) when the condition is a vector type.\nstatic QualType\nOpenCLCheckVectorConditional(Sema &S, ExprResult &Cond,\n                             ExprResult &LHS, ExprResult &RHS,\n                             SourceLocation QuestionLoc) {\n  Cond = S.DefaultFunctionArrayLvalueConversion(Cond.get());\n  if (Cond.isInvalid())\n    return QualType();\n  QualType CondTy = Cond.get()->getType();\n\n  if (checkOpenCLConditionVector(S, Cond.get(), QuestionLoc))\n    return QualType();\n\n  // If either operand is a vector then find the vector type of the\n  // result as specified in OpenCL v1.1 s6.3.i.\n  if (LHS.get()->getType()->isVectorType() ||\n      RHS.get()->getType()->isVectorType()) {\n    QualType VecResTy = S.CheckVectorOperands(LHS, RHS, QuestionLoc,\n                                              /*isCompAssign*/false,\n                                              /*AllowBothBool*/true,\n                                              /*AllowBoolConversions*/false);\n    if (VecResTy.isNull()) return QualType();\n    // The result type must match the condition type as specified in\n    // OpenCL v1.1 s6.11.6.\n    if (checkVectorResult(S, CondTy, VecResTy, QuestionLoc))\n      return QualType();\n    return VecResTy;\n  }\n\n  // Both operands are scalar.\n  return OpenCLConvertScalarsToVectors(S, LHS, RHS, CondTy, QuestionLoc);\n}\n\n/// Return true if the Expr is block type\nstatic bool checkBlockType(Sema &S, const Expr *E) {\n  if (const CallExpr *CE = dyn_cast<CallExpr>(E)) {\n    QualType Ty = CE->getCallee()->getType();\n    if (Ty->isBlockPointerType()) {\n      S.Diag(E->getExprLoc(), diag::err_opencl_ternary_with_block);\n      return true;\n    }\n  }\n  return false;\n}\n\n/// Note that LHS is not null here, even if this is the gnu \"x ?: y\" extension.\n/// In that case, LHS = cond.\n/// C99 6.5.15\nQualType Sema::CheckConditionalOperands(ExprResult &Cond, ExprResult &LHS,\n                                        ExprResult &RHS, ExprValueKind &VK,\n                                        ExprObjectKind &OK,\n                                        SourceLocation QuestionLoc) {\n\n  ExprResult LHSResult = CheckPlaceholderExpr(LHS.get());\n  if (!LHSResult.isUsable()) return QualType();\n  LHS = LHSResult;\n\n  ExprResult RHSResult = CheckPlaceholderExpr(RHS.get());\n  if (!RHSResult.isUsable()) return QualType();\n  RHS = RHSResult;\n\n  // C++ is sufficiently different to merit its own checker.\n  if (getLangOpts().CPlusPlus)\n    return CXXCheckConditionalOperands(Cond, LHS, RHS, VK, OK, QuestionLoc);\n\n  VK = VK_RValue;\n  OK = OK_Ordinary;\n\n  if (Context.isDependenceAllowed() &&\n      (Cond.get()->isTypeDependent() || LHS.get()->isTypeDependent() ||\n       RHS.get()->isTypeDependent())) {\n    assert(!getLangOpts().CPlusPlus);\n    assert((Cond.get()->containsErrors() || LHS.get()->containsErrors() ||\n            RHS.get()->containsErrors()) &&\n           \"should only occur in error-recovery path.\");\n    return Context.DependentTy;\n  }\n\n  // The OpenCL operator with a vector condition is sufficiently\n  // different to merit its own checker.\n  if ((getLangOpts().OpenCL && Cond.get()->getType()->isVectorType()) ||\n      Cond.get()->getType()->isExtVectorType())\n    return OpenCLCheckVectorConditional(*this, Cond, LHS, RHS, QuestionLoc);\n\n  // First, check the condition.\n  Cond = UsualUnaryConversions(Cond.get());\n  if (Cond.isInvalid())\n    return QualType();\n  if (checkCondition(*this, Cond.get(), QuestionLoc))\n    return QualType();\n\n  // Now check the two expressions.\n  if (LHS.get()->getType()->isVectorType() ||\n      RHS.get()->getType()->isVectorType())\n    return CheckVectorOperands(LHS, RHS, QuestionLoc, /*isCompAssign*/false,\n                               /*AllowBothBool*/true,\n                               /*AllowBoolConversions*/false);\n\n  QualType ResTy =\n      UsualArithmeticConversions(LHS, RHS, QuestionLoc, ACK_Conditional);\n  if (LHS.isInvalid() || RHS.isInvalid())\n    return QualType();\n\n  QualType LHSTy = LHS.get()->getType();\n  QualType RHSTy = RHS.get()->getType();\n\n  // Diagnose attempts to convert between __float128 and long double where\n  // such conversions currently can't be handled.\n  if (unsupportedTypeConversion(*this, LHSTy, RHSTy)) {\n    Diag(QuestionLoc,\n         diag::err_typecheck_cond_incompatible_operands) << LHSTy << RHSTy\n      << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n    return QualType();\n  }\n\n  // OpenCL v2.0 s6.12.5 - Blocks cannot be used as expressions of the ternary\n  // selection operator (?:).\n  if (getLangOpts().OpenCL &&\n      (checkBlockType(*this, LHS.get()) | checkBlockType(*this, RHS.get()))) {\n    return QualType();\n  }\n\n  // If both operands have arithmetic type, do the usual arithmetic conversions\n  // to find a common type: C99 6.5.15p3,5.\n  if (LHSTy->isArithmeticType() && RHSTy->isArithmeticType()) {\n    // Disallow invalid arithmetic conversions, such as those between ExtInts of\n    // different sizes, or between ExtInts and other types.\n    if (ResTy.isNull() && (LHSTy->isExtIntType() || RHSTy->isExtIntType())) {\n      Diag(QuestionLoc, diag::err_typecheck_cond_incompatible_operands)\n          << LHSTy << RHSTy << LHS.get()->getSourceRange()\n          << RHS.get()->getSourceRange();\n      return QualType();\n    }\n\n    LHS = ImpCastExprToType(LHS.get(), ResTy, PrepareScalarCast(LHS, ResTy));\n    RHS = ImpCastExprToType(RHS.get(), ResTy, PrepareScalarCast(RHS, ResTy));\n\n    return ResTy;\n  }\n\n  // And if they're both bfloat (which isn't arithmetic), that's fine too.\n  if (LHSTy->isBFloat16Type() && RHSTy->isBFloat16Type()) {\n    return LHSTy;\n  }\n\n  // If both operands are the same structure or union type, the result is that\n  // type.\n  if (const RecordType *LHSRT = LHSTy->getAs<RecordType>()) {    // C99 6.5.15p3\n    if (const RecordType *RHSRT = RHSTy->getAs<RecordType>())\n      if (LHSRT->getDecl() == RHSRT->getDecl())\n        // \"If both the operands have structure or union type, the result has\n        // that type.\"  This implies that CV qualifiers are dropped.\n        return LHSTy.getUnqualifiedType();\n    // FIXME: Type of conditional expression must be complete in C mode.\n  }\n\n  // C99 6.5.15p5: \"If both operands have void type, the result has void type.\"\n  // The following || allows only one side to be void (a GCC-ism).\n  if (LHSTy->isVoidType() || RHSTy->isVoidType()) {\n    return checkConditionalVoidType(*this, LHS, RHS);\n  }\n\n  // C99 6.5.15p6 - \"if one operand is a null pointer constant, the result has\n  // the type of the other operand.\"\n  if (!checkConditionalNullPointer(*this, RHS, LHSTy)) return LHSTy;\n  if (!checkConditionalNullPointer(*this, LHS, RHSTy)) return RHSTy;\n\n  // All objective-c pointer type analysis is done here.\n  QualType compositeType = FindCompositeObjCPointerType(LHS, RHS,\n                                                        QuestionLoc);\n  if (LHS.isInvalid() || RHS.isInvalid())\n    return QualType();\n  if (!compositeType.isNull())\n    return compositeType;\n\n\n  // Handle block pointer types.\n  if (LHSTy->isBlockPointerType() || RHSTy->isBlockPointerType())\n    return checkConditionalBlockPointerCompatibility(*this, LHS, RHS,\n                                                     QuestionLoc);\n\n  // Check constraints for C object pointers types (C99 6.5.15p3,6).\n  if (LHSTy->isPointerType() && RHSTy->isPointerType())\n    return checkConditionalObjectPointersCompatibility(*this, LHS, RHS,\n                                                       QuestionLoc);\n\n  // GCC compatibility: soften pointer/integer mismatch.  Note that\n  // null pointers have been filtered out by this point.\n  if (checkPointerIntegerMismatch(*this, LHS, RHS.get(), QuestionLoc,\n      /*IsIntFirstExpr=*/true))\n    return RHSTy;\n  if (checkPointerIntegerMismatch(*this, RHS, LHS.get(), QuestionLoc,\n      /*IsIntFirstExpr=*/false))\n    return LHSTy;\n\n  // Allow ?: operations in which both operands have the same\n  // built-in sizeless type.\n  if (LHSTy->isSizelessBuiltinType() && LHSTy == RHSTy)\n    return LHSTy;\n\n  // Emit a better diagnostic if one of the expressions is a null pointer\n  // constant and the other is not a pointer type. In this case, the user most\n  // likely forgot to take the address of the other expression.\n  if (DiagnoseConditionalForNull(LHS.get(), RHS.get(), QuestionLoc))\n    return QualType();\n\n  // Otherwise, the operands are not compatible.\n  Diag(QuestionLoc, diag::err_typecheck_cond_incompatible_operands)\n    << LHSTy << RHSTy << LHS.get()->getSourceRange()\n    << RHS.get()->getSourceRange();\n  return QualType();\n}\n\n/// FindCompositeObjCPointerType - Helper method to find composite type of\n/// two objective-c pointer types of the two input expressions.\nQualType Sema::FindCompositeObjCPointerType(ExprResult &LHS, ExprResult &RHS,\n                                            SourceLocation QuestionLoc) {\n  QualType LHSTy = LHS.get()->getType();\n  QualType RHSTy = RHS.get()->getType();\n\n  // Handle things like Class and struct objc_class*.  Here we case the result\n  // to the pseudo-builtin, because that will be implicitly cast back to the\n  // redefinition type if an attempt is made to access its fields.\n  if (LHSTy->isObjCClassType() &&\n      (Context.hasSameType(RHSTy, Context.getObjCClassRedefinitionType()))) {\n    RHS = ImpCastExprToType(RHS.get(), LHSTy, CK_CPointerToObjCPointerCast);\n    return LHSTy;\n  }\n  if (RHSTy->isObjCClassType() &&\n      (Context.hasSameType(LHSTy, Context.getObjCClassRedefinitionType()))) {\n    LHS = ImpCastExprToType(LHS.get(), RHSTy, CK_CPointerToObjCPointerCast);\n    return RHSTy;\n  }\n  // And the same for struct objc_object* / id\n  if (LHSTy->isObjCIdType() &&\n      (Context.hasSameType(RHSTy, Context.getObjCIdRedefinitionType()))) {\n    RHS = ImpCastExprToType(RHS.get(), LHSTy, CK_CPointerToObjCPointerCast);\n    return LHSTy;\n  }\n  if (RHSTy->isObjCIdType() &&\n      (Context.hasSameType(LHSTy, Context.getObjCIdRedefinitionType()))) {\n    LHS = ImpCastExprToType(LHS.get(), RHSTy, CK_CPointerToObjCPointerCast);\n    return RHSTy;\n  }\n  // And the same for struct objc_selector* / SEL\n  if (Context.isObjCSelType(LHSTy) &&\n      (Context.hasSameType(RHSTy, Context.getObjCSelRedefinitionType()))) {\n    RHS = ImpCastExprToType(RHS.get(), LHSTy, CK_BitCast);\n    return LHSTy;\n  }\n  if (Context.isObjCSelType(RHSTy) &&\n      (Context.hasSameType(LHSTy, Context.getObjCSelRedefinitionType()))) {\n    LHS = ImpCastExprToType(LHS.get(), RHSTy, CK_BitCast);\n    return RHSTy;\n  }\n  // Check constraints for Objective-C object pointers types.\n  if (LHSTy->isObjCObjectPointerType() && RHSTy->isObjCObjectPointerType()) {\n\n    if (Context.getCanonicalType(LHSTy) == Context.getCanonicalType(RHSTy)) {\n      // Two identical object pointer types are always compatible.\n      return LHSTy;\n    }\n    const ObjCObjectPointerType *LHSOPT = LHSTy->castAs<ObjCObjectPointerType>();\n    const ObjCObjectPointerType *RHSOPT = RHSTy->castAs<ObjCObjectPointerType>();\n    QualType compositeType = LHSTy;\n\n    // If both operands are interfaces and either operand can be\n    // assigned to the other, use that type as the composite\n    // type. This allows\n    //   xxx ? (A*) a : (B*) b\n    // where B is a subclass of A.\n    //\n    // Additionally, as for assignment, if either type is 'id'\n    // allow silent coercion. Finally, if the types are\n    // incompatible then make sure to use 'id' as the composite\n    // type so the result is acceptable for sending messages to.\n\n    // FIXME: Consider unifying with 'areComparableObjCPointerTypes'.\n    // It could return the composite type.\n    if (!(compositeType =\n          Context.areCommonBaseCompatible(LHSOPT, RHSOPT)).isNull()) {\n      // Nothing more to do.\n    } else if (Context.canAssignObjCInterfaces(LHSOPT, RHSOPT)) {\n      compositeType = RHSOPT->isObjCBuiltinType() ? RHSTy : LHSTy;\n    } else if (Context.canAssignObjCInterfaces(RHSOPT, LHSOPT)) {\n      compositeType = LHSOPT->isObjCBuiltinType() ? LHSTy : RHSTy;\n    } else if ((LHSOPT->isObjCQualifiedIdType() ||\n                RHSOPT->isObjCQualifiedIdType()) &&\n               Context.ObjCQualifiedIdTypesAreCompatible(LHSOPT, RHSOPT,\n                                                         true)) {\n      // Need to handle \"id<xx>\" explicitly.\n      // GCC allows qualified id and any Objective-C type to devolve to\n      // id. Currently localizing to here until clear this should be\n      // part of ObjCQualifiedIdTypesAreCompatible.\n      compositeType = Context.getObjCIdType();\n    } else if (LHSTy->isObjCIdType() || RHSTy->isObjCIdType()) {\n      compositeType = Context.getObjCIdType();\n    } else {\n      Diag(QuestionLoc, diag::ext_typecheck_cond_incompatible_operands)\n      << LHSTy << RHSTy\n      << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n      QualType incompatTy = Context.getObjCIdType();\n      LHS = ImpCastExprToType(LHS.get(), incompatTy, CK_BitCast);\n      RHS = ImpCastExprToType(RHS.get(), incompatTy, CK_BitCast);\n      return incompatTy;\n    }\n    // The object pointer types are compatible.\n    LHS = ImpCastExprToType(LHS.get(), compositeType, CK_BitCast);\n    RHS = ImpCastExprToType(RHS.get(), compositeType, CK_BitCast);\n    return compositeType;\n  }\n  // Check Objective-C object pointer types and 'void *'\n  if (LHSTy->isVoidPointerType() && RHSTy->isObjCObjectPointerType()) {\n    if (getLangOpts().ObjCAutoRefCount) {\n      // ARC forbids the implicit conversion of object pointers to 'void *',\n      // so these types are not compatible.\n      Diag(QuestionLoc, diag::err_cond_voidptr_arc) << LHSTy << RHSTy\n          << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n      LHS = RHS = true;\n      return QualType();\n    }\n    QualType lhptee = LHSTy->castAs<PointerType>()->getPointeeType();\n    QualType rhptee = RHSTy->castAs<ObjCObjectPointerType>()->getPointeeType();\n    QualType destPointee\n    = Context.getQualifiedType(lhptee, rhptee.getQualifiers());\n    QualType destType = Context.getPointerType(destPointee);\n    // Add qualifiers if necessary.\n    LHS = ImpCastExprToType(LHS.get(), destType, CK_NoOp);\n    // Promote to void*.\n    RHS = ImpCastExprToType(RHS.get(), destType, CK_BitCast);\n    return destType;\n  }\n  if (LHSTy->isObjCObjectPointerType() && RHSTy->isVoidPointerType()) {\n    if (getLangOpts().ObjCAutoRefCount) {\n      // ARC forbids the implicit conversion of object pointers to 'void *',\n      // so these types are not compatible.\n      Diag(QuestionLoc, diag::err_cond_voidptr_arc) << LHSTy << RHSTy\n          << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n      LHS = RHS = true;\n      return QualType();\n    }\n    QualType lhptee = LHSTy->castAs<ObjCObjectPointerType>()->getPointeeType();\n    QualType rhptee = RHSTy->castAs<PointerType>()->getPointeeType();\n    QualType destPointee\n    = Context.getQualifiedType(rhptee, lhptee.getQualifiers());\n    QualType destType = Context.getPointerType(destPointee);\n    // Add qualifiers if necessary.\n    RHS = ImpCastExprToType(RHS.get(), destType, CK_NoOp);\n    // Promote to void*.\n    LHS = ImpCastExprToType(LHS.get(), destType, CK_BitCast);\n    return destType;\n  }\n  return QualType();\n}\n\n/// SuggestParentheses - Emit a note with a fixit hint that wraps\n/// ParenRange in parentheses.\nstatic void SuggestParentheses(Sema &Self, SourceLocation Loc,\n                               const PartialDiagnostic &Note,\n                               SourceRange ParenRange) {\n  SourceLocation EndLoc = Self.getLocForEndOfToken(ParenRange.getEnd());\n  if (ParenRange.getBegin().isFileID() && ParenRange.getEnd().isFileID() &&\n      EndLoc.isValid()) {\n    Self.Diag(Loc, Note)\n      << FixItHint::CreateInsertion(ParenRange.getBegin(), \"(\")\n      << FixItHint::CreateInsertion(EndLoc, \")\");\n  } else {\n    // We can't display the parentheses, so just show the bare note.\n    Self.Diag(Loc, Note) << ParenRange;\n  }\n}\n\nstatic bool IsArithmeticOp(BinaryOperatorKind Opc) {\n  return BinaryOperator::isAdditiveOp(Opc) ||\n         BinaryOperator::isMultiplicativeOp(Opc) ||\n         BinaryOperator::isShiftOp(Opc) || Opc == BO_And || Opc == BO_Or;\n  // This only checks for bitwise-or and bitwise-and, but not bitwise-xor and\n  // not any of the logical operators.  Bitwise-xor is commonly used as a\n  // logical-xor because there is no logical-xor operator.  The logical\n  // operators, including uses of xor, have a high false positive rate for\n  // precedence warnings.\n}\n\n/// IsArithmeticBinaryExpr - Returns true if E is an arithmetic binary\n/// expression, either using a built-in or overloaded operator,\n/// and sets *OpCode to the opcode and *RHSExprs to the right-hand side\n/// expression.\nstatic bool IsArithmeticBinaryExpr(Expr *E, BinaryOperatorKind *Opcode,\n                                   Expr **RHSExprs) {\n  // Don't strip parenthesis: we should not warn if E is in parenthesis.\n  E = E->IgnoreImpCasts();\n  E = E->IgnoreConversionOperatorSingleStep();\n  E = E->IgnoreImpCasts();\n  if (auto *MTE = dyn_cast<MaterializeTemporaryExpr>(E)) {\n    E = MTE->getSubExpr();\n    E = E->IgnoreImpCasts();\n  }\n\n  // Built-in binary operator.\n  if (BinaryOperator *OP = dyn_cast<BinaryOperator>(E)) {\n    if (IsArithmeticOp(OP->getOpcode())) {\n      *Opcode = OP->getOpcode();\n      *RHSExprs = OP->getRHS();\n      return true;\n    }\n  }\n\n  // Overloaded operator.\n  if (CXXOperatorCallExpr *Call = dyn_cast<CXXOperatorCallExpr>(E)) {\n    if (Call->getNumArgs() != 2)\n      return false;\n\n    // Make sure this is really a binary operator that is safe to pass into\n    // BinaryOperator::getOverloadedOpcode(), e.g. it's not a subscript op.\n    OverloadedOperatorKind OO = Call->getOperator();\n    if (OO < OO_Plus || OO > OO_Arrow ||\n        OO == OO_PlusPlus || OO == OO_MinusMinus)\n      return false;\n\n    BinaryOperatorKind OpKind = BinaryOperator::getOverloadedOpcode(OO);\n    if (IsArithmeticOp(OpKind)) {\n      *Opcode = OpKind;\n      *RHSExprs = Call->getArg(1);\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/// ExprLooksBoolean - Returns true if E looks boolean, i.e. it has boolean type\n/// or is a logical expression such as (x==y) which has int type, but is\n/// commonly interpreted as boolean.\nstatic bool ExprLooksBoolean(Expr *E) {\n  E = E->IgnoreParenImpCasts();\n\n  if (E->getType()->isBooleanType())\n    return true;\n  if (BinaryOperator *OP = dyn_cast<BinaryOperator>(E))\n    return OP->isComparisonOp() || OP->isLogicalOp();\n  if (UnaryOperator *OP = dyn_cast<UnaryOperator>(E))\n    return OP->getOpcode() == UO_LNot;\n  if (E->getType()->isPointerType())\n    return true;\n  // FIXME: What about overloaded operator calls returning \"unspecified boolean\n  // type\"s (commonly pointer-to-members)?\n\n  return false;\n}\n\n/// DiagnoseConditionalPrecedence - Emit a warning when a conditional operator\n/// and binary operator are mixed in a way that suggests the programmer assumed\n/// the conditional operator has higher precedence, for example:\n/// \"int x = a + someBinaryCondition ? 1 : 2\".\nstatic void DiagnoseConditionalPrecedence(Sema &Self,\n                                          SourceLocation OpLoc,\n                                          Expr *Condition,\n                                          Expr *LHSExpr,\n                                          Expr *RHSExpr) {\n  BinaryOperatorKind CondOpcode;\n  Expr *CondRHS;\n\n  if (!IsArithmeticBinaryExpr(Condition, &CondOpcode, &CondRHS))\n    return;\n  if (!ExprLooksBoolean(CondRHS))\n    return;\n\n  // The condition is an arithmetic binary expression, with a right-\n  // hand side that looks boolean, so warn.\n\n  unsigned DiagID = BinaryOperator::isBitwiseOp(CondOpcode)\n                        ? diag::warn_precedence_bitwise_conditional\n                        : diag::warn_precedence_conditional;\n\n  Self.Diag(OpLoc, DiagID)\n      << Condition->getSourceRange()\n      << BinaryOperator::getOpcodeStr(CondOpcode);\n\n  SuggestParentheses(\n      Self, OpLoc,\n      Self.PDiag(diag::note_precedence_silence)\n          << BinaryOperator::getOpcodeStr(CondOpcode),\n      SourceRange(Condition->getBeginLoc(), Condition->getEndLoc()));\n\n  SuggestParentheses(Self, OpLoc,\n                     Self.PDiag(diag::note_precedence_conditional_first),\n                     SourceRange(CondRHS->getBeginLoc(), RHSExpr->getEndLoc()));\n}\n\n/// Compute the nullability of a conditional expression.\nstatic QualType computeConditionalNullability(QualType ResTy, bool IsBin,\n                                              QualType LHSTy, QualType RHSTy,\n                                              ASTContext &Ctx) {\n  if (!ResTy->isAnyPointerType())\n    return ResTy;\n\n  auto GetNullability = [&Ctx](QualType Ty) {\n    Optional<NullabilityKind> Kind = Ty->getNullability(Ctx);\n    if (Kind) {\n      // For our purposes, treat _Nullable_result as _Nullable.\n      if (*Kind == NullabilityKind::NullableResult)\n        return NullabilityKind::Nullable;\n      return *Kind;\n    }\n    return NullabilityKind::Unspecified;\n  };\n\n  auto LHSKind = GetNullability(LHSTy), RHSKind = GetNullability(RHSTy);\n  NullabilityKind MergedKind;\n\n  // Compute nullability of a binary conditional expression.\n  if (IsBin) {\n    if (LHSKind == NullabilityKind::NonNull)\n      MergedKind = NullabilityKind::NonNull;\n    else\n      MergedKind = RHSKind;\n  // Compute nullability of a normal conditional expression.\n  } else {\n    if (LHSKind == NullabilityKind::Nullable ||\n        RHSKind == NullabilityKind::Nullable)\n      MergedKind = NullabilityKind::Nullable;\n    else if (LHSKind == NullabilityKind::NonNull)\n      MergedKind = RHSKind;\n    else if (RHSKind == NullabilityKind::NonNull)\n      MergedKind = LHSKind;\n    else\n      MergedKind = NullabilityKind::Unspecified;\n  }\n\n  // Return if ResTy already has the correct nullability.\n  if (GetNullability(ResTy) == MergedKind)\n    return ResTy;\n\n  // Strip all nullability from ResTy.\n  while (ResTy->getNullability(Ctx))\n    ResTy = ResTy.getSingleStepDesugaredType(Ctx);\n\n  // Create a new AttributedType with the new nullability kind.\n  auto NewAttr = AttributedType::getNullabilityAttrKind(MergedKind);\n  return Ctx.getAttributedType(NewAttr, ResTy, ResTy);\n}\n\n/// ActOnConditionalOp - Parse a ?: operation.  Note that 'LHS' may be null\n/// in the case of a the GNU conditional expr extension.\nExprResult Sema::ActOnConditionalOp(SourceLocation QuestionLoc,\n                                    SourceLocation ColonLoc,\n                                    Expr *CondExpr, Expr *LHSExpr,\n                                    Expr *RHSExpr) {\n  if (!Context.isDependenceAllowed()) {\n    // C cannot handle TypoExpr nodes in the condition because it\n    // doesn't handle dependent types properly, so make sure any TypoExprs have\n    // been dealt with before checking the operands.\n    ExprResult CondResult = CorrectDelayedTyposInExpr(CondExpr);\n    ExprResult LHSResult = CorrectDelayedTyposInExpr(LHSExpr);\n    ExprResult RHSResult = CorrectDelayedTyposInExpr(RHSExpr);\n\n    if (!CondResult.isUsable())\n      return ExprError();\n\n    if (LHSExpr) {\n      if (!LHSResult.isUsable())\n        return ExprError();\n    }\n\n    if (!RHSResult.isUsable())\n      return ExprError();\n\n    CondExpr = CondResult.get();\n    LHSExpr = LHSResult.get();\n    RHSExpr = RHSResult.get();\n  }\n\n  // If this is the gnu \"x ?: y\" extension, analyze the types as though the LHS\n  // was the condition.\n  OpaqueValueExpr *opaqueValue = nullptr;\n  Expr *commonExpr = nullptr;\n  if (!LHSExpr) {\n    commonExpr = CondExpr;\n    // Lower out placeholder types first.  This is important so that we don't\n    // try to capture a placeholder. This happens in few cases in C++; such\n    // as Objective-C++'s dictionary subscripting syntax.\n    if (commonExpr->hasPlaceholderType()) {\n      ExprResult result = CheckPlaceholderExpr(commonExpr);\n      if (!result.isUsable()) return ExprError();\n      commonExpr = result.get();\n    }\n    // We usually want to apply unary conversions *before* saving, except\n    // in the special case of a C++ l-value conditional.\n    if (!(getLangOpts().CPlusPlus\n          && !commonExpr->isTypeDependent()\n          && commonExpr->getValueKind() == RHSExpr->getValueKind()\n          && commonExpr->isGLValue()\n          && commonExpr->isOrdinaryOrBitFieldObject()\n          && RHSExpr->isOrdinaryOrBitFieldObject()\n          && Context.hasSameType(commonExpr->getType(), RHSExpr->getType()))) {\n      ExprResult commonRes = UsualUnaryConversions(commonExpr);\n      if (commonRes.isInvalid())\n        return ExprError();\n      commonExpr = commonRes.get();\n    }\n\n    // If the common expression is a class or array prvalue, materialize it\n    // so that we can safely refer to it multiple times.\n    if (commonExpr->isRValue() && (commonExpr->getType()->isRecordType() ||\n                                   commonExpr->getType()->isArrayType())) {\n      ExprResult MatExpr = TemporaryMaterializationConversion(commonExpr);\n      if (MatExpr.isInvalid())\n        return ExprError();\n      commonExpr = MatExpr.get();\n    }\n\n    opaqueValue = new (Context) OpaqueValueExpr(commonExpr->getExprLoc(),\n                                                commonExpr->getType(),\n                                                commonExpr->getValueKind(),\n                                                commonExpr->getObjectKind(),\n                                                commonExpr);\n    LHSExpr = CondExpr = opaqueValue;\n  }\n\n  QualType LHSTy = LHSExpr->getType(), RHSTy = RHSExpr->getType();\n  ExprValueKind VK = VK_RValue;\n  ExprObjectKind OK = OK_Ordinary;\n  ExprResult Cond = CondExpr, LHS = LHSExpr, RHS = RHSExpr;\n  QualType result = CheckConditionalOperands(Cond, LHS, RHS,\n                                             VK, OK, QuestionLoc);\n  if (result.isNull() || Cond.isInvalid() || LHS.isInvalid() ||\n      RHS.isInvalid())\n    return ExprError();\n\n  DiagnoseConditionalPrecedence(*this, QuestionLoc, Cond.get(), LHS.get(),\n                                RHS.get());\n\n  CheckBoolLikeConversion(Cond.get(), QuestionLoc);\n\n  result = computeConditionalNullability(result, commonExpr, LHSTy, RHSTy,\n                                         Context);\n\n  if (!commonExpr)\n    return new (Context)\n        ConditionalOperator(Cond.get(), QuestionLoc, LHS.get(), ColonLoc,\n                            RHS.get(), result, VK, OK);\n\n  return new (Context) BinaryConditionalOperator(\n      commonExpr, opaqueValue, Cond.get(), LHS.get(), RHS.get(), QuestionLoc,\n      ColonLoc, result, VK, OK);\n}\n\n// Check if we have a conversion between incompatible cmse function pointer\n// types, that is, a conversion between a function pointer with the\n// cmse_nonsecure_call attribute and one without.\nstatic bool IsInvalidCmseNSCallConversion(Sema &S, QualType FromType,\n                                          QualType ToType) {\n  if (const auto *ToFn =\n          dyn_cast<FunctionType>(S.Context.getCanonicalType(ToType))) {\n    if (const auto *FromFn =\n            dyn_cast<FunctionType>(S.Context.getCanonicalType(FromType))) {\n      FunctionType::ExtInfo ToEInfo = ToFn->getExtInfo();\n      FunctionType::ExtInfo FromEInfo = FromFn->getExtInfo();\n\n      return ToEInfo.getCmseNSCall() != FromEInfo.getCmseNSCall();\n    }\n  }\n  return false;\n}\n\n// checkPointerTypesForAssignment - This is a very tricky routine (despite\n// being closely modeled after the C99 spec:-). The odd characteristic of this\n// routine is it effectively iqnores the qualifiers on the top level pointee.\n// This circumvents the usual type rules specified in 6.2.7p1 & 6.7.5.[1-3].\n// FIXME: add a couple examples in this comment.\nstatic Sema::AssignConvertType\ncheckPointerTypesForAssignment(Sema &S, QualType LHSType, QualType RHSType) {\n  assert(LHSType.isCanonical() && \"LHS not canonicalized!\");\n  assert(RHSType.isCanonical() && \"RHS not canonicalized!\");\n\n  // get the \"pointed to\" type (ignoring qualifiers at the top level)\n  const Type *lhptee, *rhptee;\n  Qualifiers lhq, rhq;\n  std::tie(lhptee, lhq) =\n      cast<PointerType>(LHSType)->getPointeeType().split().asPair();\n  std::tie(rhptee, rhq) =\n      cast<PointerType>(RHSType)->getPointeeType().split().asPair();\n\n  Sema::AssignConvertType ConvTy = Sema::Compatible;\n\n  // C99 6.5.16.1p1: This following citation is common to constraints\n  // 3 & 4 (below). ...and the type *pointed to* by the left has all the\n  // qualifiers of the type *pointed to* by the right;\n\n  // As a special case, 'non-__weak A *' -> 'non-__weak const *' is okay.\n  if (lhq.getObjCLifetime() != rhq.getObjCLifetime() &&\n      lhq.compatiblyIncludesObjCLifetime(rhq)) {\n    // Ignore lifetime for further calculation.\n    lhq.removeObjCLifetime();\n    rhq.removeObjCLifetime();\n  }\n\n  if (!lhq.compatiblyIncludes(rhq)) {\n    // Treat address-space mismatches as fatal.\n    if (!lhq.isAddressSpaceSupersetOf(rhq))\n      return Sema::IncompatiblePointerDiscardsQualifiers;\n\n    // It's okay to add or remove GC or lifetime qualifiers when converting to\n    // and from void*.\n    else if (lhq.withoutObjCGCAttr().withoutObjCLifetime()\n                        .compatiblyIncludes(\n                                rhq.withoutObjCGCAttr().withoutObjCLifetime())\n             && (lhptee->isVoidType() || rhptee->isVoidType()))\n      ; // keep old\n\n    // Treat lifetime mismatches as fatal.\n    else if (lhq.getObjCLifetime() != rhq.getObjCLifetime())\n      ConvTy = Sema::IncompatiblePointerDiscardsQualifiers;\n\n    // For GCC/MS compatibility, other qualifier mismatches are treated\n    // as still compatible in C.\n    else ConvTy = Sema::CompatiblePointerDiscardsQualifiers;\n  }\n\n  // C99 6.5.16.1p1 (constraint 4): If one operand is a pointer to an object or\n  // incomplete type and the other is a pointer to a qualified or unqualified\n  // version of void...\n  if (lhptee->isVoidType()) {\n    if (rhptee->isIncompleteOrObjectType())\n      return ConvTy;\n\n    // As an extension, we allow cast to/from void* to function pointer.\n    assert(rhptee->isFunctionType());\n    return Sema::FunctionVoidPointer;\n  }\n\n  if (rhptee->isVoidType()) {\n    if (lhptee->isIncompleteOrObjectType())\n      return ConvTy;\n\n    // As an extension, we allow cast to/from void* to function pointer.\n    assert(lhptee->isFunctionType());\n    return Sema::FunctionVoidPointer;\n  }\n\n  // C99 6.5.16.1p1 (constraint 3): both operands are pointers to qualified or\n  // unqualified versions of compatible types, ...\n  QualType ltrans = QualType(lhptee, 0), rtrans = QualType(rhptee, 0);\n  if (!S.Context.typesAreCompatible(ltrans, rtrans)) {\n    // Check if the pointee types are compatible ignoring the sign.\n    // We explicitly check for char so that we catch \"char\" vs\n    // \"unsigned char\" on systems where \"char\" is unsigned.\n    if (lhptee->isCharType())\n      ltrans = S.Context.UnsignedCharTy;\n    else if (lhptee->hasSignedIntegerRepresentation())\n      ltrans = S.Context.getCorrespondingUnsignedType(ltrans);\n\n    if (rhptee->isCharType())\n      rtrans = S.Context.UnsignedCharTy;\n    else if (rhptee->hasSignedIntegerRepresentation())\n      rtrans = S.Context.getCorrespondingUnsignedType(rtrans);\n\n    if (ltrans == rtrans) {\n      // Types are compatible ignoring the sign. Qualifier incompatibility\n      // takes priority over sign incompatibility because the sign\n      // warning can be disabled.\n      if (ConvTy != Sema::Compatible)\n        return ConvTy;\n\n      return Sema::IncompatiblePointerSign;\n    }\n\n    // If we are a multi-level pointer, it's possible that our issue is simply\n    // one of qualification - e.g. char ** -> const char ** is not allowed. If\n    // the eventual target type is the same and the pointers have the same\n    // level of indirection, this must be the issue.\n    if (isa<PointerType>(lhptee) && isa<PointerType>(rhptee)) {\n      do {\n        std::tie(lhptee, lhq) =\n          cast<PointerType>(lhptee)->getPointeeType().split().asPair();\n        std::tie(rhptee, rhq) =\n          cast<PointerType>(rhptee)->getPointeeType().split().asPair();\n\n        // Inconsistent address spaces at this point is invalid, even if the\n        // address spaces would be compatible.\n        // FIXME: This doesn't catch address space mismatches for pointers of\n        // different nesting levels, like:\n        //   __local int *** a;\n        //   int ** b = a;\n        // It's not clear how to actually determine when such pointers are\n        // invalidly incompatible.\n        if (lhq.getAddressSpace() != rhq.getAddressSpace())\n          return Sema::IncompatibleNestedPointerAddressSpaceMismatch;\n\n      } while (isa<PointerType>(lhptee) && isa<PointerType>(rhptee));\n\n      if (lhptee == rhptee)\n        return Sema::IncompatibleNestedPointerQualifiers;\n    }\n\n    // General pointer incompatibility takes priority over qualifiers.\n    if (RHSType->isFunctionPointerType() && LHSType->isFunctionPointerType())\n      return Sema::IncompatibleFunctionPointer;\n    return Sema::IncompatiblePointer;\n  }\n  if (!S.getLangOpts().CPlusPlus &&\n      S.IsFunctionConversion(ltrans, rtrans, ltrans))\n    return Sema::IncompatibleFunctionPointer;\n  if (IsInvalidCmseNSCallConversion(S, ltrans, rtrans))\n    return Sema::IncompatibleFunctionPointer;\n  return ConvTy;\n}\n\n/// checkBlockPointerTypesForAssignment - This routine determines whether two\n/// block pointer types are compatible or whether a block and normal pointer\n/// are compatible. It is more restrict than comparing two function pointer\n// types.\nstatic Sema::AssignConvertType\ncheckBlockPointerTypesForAssignment(Sema &S, QualType LHSType,\n                                    QualType RHSType) {\n  assert(LHSType.isCanonical() && \"LHS not canonicalized!\");\n  assert(RHSType.isCanonical() && \"RHS not canonicalized!\");\n\n  QualType lhptee, rhptee;\n\n  // get the \"pointed to\" type (ignoring qualifiers at the top level)\n  lhptee = cast<BlockPointerType>(LHSType)->getPointeeType();\n  rhptee = cast<BlockPointerType>(RHSType)->getPointeeType();\n\n  // In C++, the types have to match exactly.\n  if (S.getLangOpts().CPlusPlus)\n    return Sema::IncompatibleBlockPointer;\n\n  Sema::AssignConvertType ConvTy = Sema::Compatible;\n\n  // For blocks we enforce that qualifiers are identical.\n  Qualifiers LQuals = lhptee.getLocalQualifiers();\n  Qualifiers RQuals = rhptee.getLocalQualifiers();\n  if (S.getLangOpts().OpenCL) {\n    LQuals.removeAddressSpace();\n    RQuals.removeAddressSpace();\n  }\n  if (LQuals != RQuals)\n    ConvTy = Sema::CompatiblePointerDiscardsQualifiers;\n\n  // FIXME: OpenCL doesn't define the exact compile time semantics for a block\n  // assignment.\n  // The current behavior is similar to C++ lambdas. A block might be\n  // assigned to a variable iff its return type and parameters are compatible\n  // (C99 6.2.7) with the corresponding return type and parameters of the LHS of\n  // an assignment. Presumably it should behave in way that a function pointer\n  // assignment does in C, so for each parameter and return type:\n  //  * CVR and address space of LHS should be a superset of CVR and address\n  //  space of RHS.\n  //  * unqualified types should be compatible.\n  if (S.getLangOpts().OpenCL) {\n    if (!S.Context.typesAreBlockPointerCompatible(\n            S.Context.getQualifiedType(LHSType.getUnqualifiedType(), LQuals),\n            S.Context.getQualifiedType(RHSType.getUnqualifiedType(), RQuals)))\n      return Sema::IncompatibleBlockPointer;\n  } else if (!S.Context.typesAreBlockPointerCompatible(LHSType, RHSType))\n    return Sema::IncompatibleBlockPointer;\n\n  return ConvTy;\n}\n\n/// checkObjCPointerTypesForAssignment - Compares two objective-c pointer types\n/// for assignment compatibility.\nstatic Sema::AssignConvertType\ncheckObjCPointerTypesForAssignment(Sema &S, QualType LHSType,\n                                   QualType RHSType) {\n  assert(LHSType.isCanonical() && \"LHS was not canonicalized!\");\n  assert(RHSType.isCanonical() && \"RHS was not canonicalized!\");\n\n  if (LHSType->isObjCBuiltinType()) {\n    // Class is not compatible with ObjC object pointers.\n    if (LHSType->isObjCClassType() && !RHSType->isObjCBuiltinType() &&\n        !RHSType->isObjCQualifiedClassType())\n      return Sema::IncompatiblePointer;\n    return Sema::Compatible;\n  }\n  if (RHSType->isObjCBuiltinType()) {\n    if (RHSType->isObjCClassType() && !LHSType->isObjCBuiltinType() &&\n        !LHSType->isObjCQualifiedClassType())\n      return Sema::IncompatiblePointer;\n    return Sema::Compatible;\n  }\n  QualType lhptee = LHSType->castAs<ObjCObjectPointerType>()->getPointeeType();\n  QualType rhptee = RHSType->castAs<ObjCObjectPointerType>()->getPointeeType();\n\n  if (!lhptee.isAtLeastAsQualifiedAs(rhptee) &&\n      // make an exception for id<P>\n      !LHSType->isObjCQualifiedIdType())\n    return Sema::CompatiblePointerDiscardsQualifiers;\n\n  if (S.Context.typesAreCompatible(LHSType, RHSType))\n    return Sema::Compatible;\n  if (LHSType->isObjCQualifiedIdType() || RHSType->isObjCQualifiedIdType())\n    return Sema::IncompatibleObjCQualifiedId;\n  return Sema::IncompatiblePointer;\n}\n\nSema::AssignConvertType\nSema::CheckAssignmentConstraints(SourceLocation Loc,\n                                 QualType LHSType, QualType RHSType) {\n  // Fake up an opaque expression.  We don't actually care about what\n  // cast operations are required, so if CheckAssignmentConstraints\n  // adds casts to this they'll be wasted, but fortunately that doesn't\n  // usually happen on valid code.\n  OpaqueValueExpr RHSExpr(Loc, RHSType, VK_RValue);\n  ExprResult RHSPtr = &RHSExpr;\n  CastKind K;\n\n  return CheckAssignmentConstraints(LHSType, RHSPtr, K, /*ConvertRHS=*/false);\n}\n\n/// This helper function returns true if QT is a vector type that has element\n/// type ElementType.\nstatic bool isVector(QualType QT, QualType ElementType) {\n  if (const VectorType *VT = QT->getAs<VectorType>())\n    return VT->getElementType().getCanonicalType() == ElementType;\n  return false;\n}\n\n/// CheckAssignmentConstraints (C99 6.5.16) - This routine currently\n/// has code to accommodate several GCC extensions when type checking\n/// pointers. Here are some objectionable examples that GCC considers warnings:\n///\n///  int a, *pint;\n///  short *pshort;\n///  struct foo *pfoo;\n///\n///  pint = pshort; // warning: assignment from incompatible pointer type\n///  a = pint; // warning: assignment makes integer from pointer without a cast\n///  pint = a; // warning: assignment makes pointer from integer without a cast\n///  pint = pfoo; // warning: assignment from incompatible pointer type\n///\n/// As a result, the code for dealing with pointers is more complex than the\n/// C99 spec dictates.\n///\n/// Sets 'Kind' for any result kind except Incompatible.\nSema::AssignConvertType\nSema::CheckAssignmentConstraints(QualType LHSType, ExprResult &RHS,\n                                 CastKind &Kind, bool ConvertRHS) {\n  QualType RHSType = RHS.get()->getType();\n  QualType OrigLHSType = LHSType;\n\n  // Get canonical types.  We're not formatting these types, just comparing\n  // them.\n  LHSType = Context.getCanonicalType(LHSType).getUnqualifiedType();\n  RHSType = Context.getCanonicalType(RHSType).getUnqualifiedType();\n\n  // Common case: no conversion required.\n  if (LHSType == RHSType) {\n    Kind = CK_NoOp;\n    return Compatible;\n  }\n\n  // If we have an atomic type, try a non-atomic assignment, then just add an\n  // atomic qualification step.\n  if (const AtomicType *AtomicTy = dyn_cast<AtomicType>(LHSType)) {\n    Sema::AssignConvertType result =\n      CheckAssignmentConstraints(AtomicTy->getValueType(), RHS, Kind);\n    if (result != Compatible)\n      return result;\n    if (Kind != CK_NoOp && ConvertRHS)\n      RHS = ImpCastExprToType(RHS.get(), AtomicTy->getValueType(), Kind);\n    Kind = CK_NonAtomicToAtomic;\n    return Compatible;\n  }\n\n  // If the left-hand side is a reference type, then we are in a\n  // (rare!) case where we've allowed the use of references in C,\n  // e.g., as a parameter type in a built-in function. In this case,\n  // just make sure that the type referenced is compatible with the\n  // right-hand side type. The caller is responsible for adjusting\n  // LHSType so that the resulting expression does not have reference\n  // type.\n  if (const ReferenceType *LHSTypeRef = LHSType->getAs<ReferenceType>()) {\n    if (Context.typesAreCompatible(LHSTypeRef->getPointeeType(), RHSType)) {\n      Kind = CK_LValueBitCast;\n      return Compatible;\n    }\n    return Incompatible;\n  }\n\n  // Allow scalar to ExtVector assignments, and assignments of an ExtVector type\n  // to the same ExtVector type.\n  if (LHSType->isExtVectorType()) {\n    if (RHSType->isExtVectorType())\n      return Incompatible;\n    if (RHSType->isArithmeticType()) {\n      // CK_VectorSplat does T -> vector T, so first cast to the element type.\n      if (ConvertRHS)\n        RHS = prepareVectorSplat(LHSType, RHS.get());\n      Kind = CK_VectorSplat;\n      return Compatible;\n    }\n  }\n\n  // Conversions to or from vector type.\n  if (LHSType->isVectorType() || RHSType->isVectorType()) {\n    if (LHSType->isVectorType() && RHSType->isVectorType()) {\n      // Allow assignments of an AltiVec vector type to an equivalent GCC\n      // vector type and vice versa\n      if (Context.areCompatibleVectorTypes(LHSType, RHSType)) {\n        Kind = CK_BitCast;\n        return Compatible;\n      }\n\n      // If we are allowing lax vector conversions, and LHS and RHS are both\n      // vectors, the total size only needs to be the same. This is a bitcast;\n      // no bits are changed but the result type is different.\n      if (isLaxVectorConversion(RHSType, LHSType)) {\n        Kind = CK_BitCast;\n        return IncompatibleVectors;\n      }\n    }\n\n    // When the RHS comes from another lax conversion (e.g. binops between\n    // scalars and vectors) the result is canonicalized as a vector. When the\n    // LHS is also a vector, the lax is allowed by the condition above. Handle\n    // the case where LHS is a scalar.\n    if (LHSType->isScalarType()) {\n      const VectorType *VecType = RHSType->getAs<VectorType>();\n      if (VecType && VecType->getNumElements() == 1 &&\n          isLaxVectorConversion(RHSType, LHSType)) {\n        ExprResult *VecExpr = &RHS;\n        *VecExpr = ImpCastExprToType(VecExpr->get(), LHSType, CK_BitCast);\n        Kind = CK_BitCast;\n        return Compatible;\n      }\n    }\n\n    // Allow assignments between fixed-length and sizeless SVE vectors.\n    if ((LHSType->isSizelessBuiltinType() && RHSType->isVectorType()) ||\n        (LHSType->isVectorType() && RHSType->isSizelessBuiltinType()))\n      if (Context.areCompatibleSveTypes(LHSType, RHSType) ||\n          Context.areLaxCompatibleSveTypes(LHSType, RHSType)) {\n        Kind = CK_BitCast;\n        return Compatible;\n      }\n\n    return Incompatible;\n  }\n\n  // Diagnose attempts to convert between __float128 and long double where\n  // such conversions currently can't be handled.\n  if (unsupportedTypeConversion(*this, LHSType, RHSType))\n    return Incompatible;\n\n  // Disallow assigning a _Complex to a real type in C++ mode since it simply\n  // discards the imaginary part.\n  if (getLangOpts().CPlusPlus && RHSType->getAs<ComplexType>() &&\n      !LHSType->getAs<ComplexType>())\n    return Incompatible;\n\n  // Arithmetic conversions.\n  if (LHSType->isArithmeticType() && RHSType->isArithmeticType() &&\n      !(getLangOpts().CPlusPlus && LHSType->isEnumeralType())) {\n    if (ConvertRHS)\n      Kind = PrepareScalarCast(RHS, LHSType);\n    return Compatible;\n  }\n\n  // Conversions to normal pointers.\n  if (const PointerType *LHSPointer = dyn_cast<PointerType>(LHSType)) {\n    // U* -> T*\n    if (isa<PointerType>(RHSType)) {\n      LangAS AddrSpaceL = LHSPointer->getPointeeType().getAddressSpace();\n      LangAS AddrSpaceR = RHSType->getPointeeType().getAddressSpace();\n      if (AddrSpaceL != AddrSpaceR)\n        Kind = CK_AddressSpaceConversion;\n      else if (Context.hasCvrSimilarType(RHSType, LHSType))\n        Kind = CK_NoOp;\n      else\n        Kind = CK_BitCast;\n      return checkPointerTypesForAssignment(*this, LHSType, RHSType);\n    }\n\n    // int -> T*\n    if (RHSType->isIntegerType()) {\n      Kind = CK_IntegralToPointer; // FIXME: null?\n      return IntToPointer;\n    }\n\n    // C pointers are not compatible with ObjC object pointers,\n    // with two exceptions:\n    if (isa<ObjCObjectPointerType>(RHSType)) {\n      //  - conversions to void*\n      if (LHSPointer->getPointeeType()->isVoidType()) {\n        Kind = CK_BitCast;\n        return Compatible;\n      }\n\n      //  - conversions from 'Class' to the redefinition type\n      if (RHSType->isObjCClassType() &&\n          Context.hasSameType(LHSType,\n                              Context.getObjCClassRedefinitionType())) {\n        Kind = CK_BitCast;\n        return Compatible;\n      }\n\n      Kind = CK_BitCast;\n      return IncompatiblePointer;\n    }\n\n    // U^ -> void*\n    if (RHSType->getAs<BlockPointerType>()) {\n      if (LHSPointer->getPointeeType()->isVoidType()) {\n        LangAS AddrSpaceL = LHSPointer->getPointeeType().getAddressSpace();\n        LangAS AddrSpaceR = RHSType->getAs<BlockPointerType>()\n                                ->getPointeeType()\n                                .getAddressSpace();\n        Kind =\n            AddrSpaceL != AddrSpaceR ? CK_AddressSpaceConversion : CK_BitCast;\n        return Compatible;\n      }\n    }\n\n    return Incompatible;\n  }\n\n  // Conversions to block pointers.\n  if (isa<BlockPointerType>(LHSType)) {\n    // U^ -> T^\n    if (RHSType->isBlockPointerType()) {\n      LangAS AddrSpaceL = LHSType->getAs<BlockPointerType>()\n                              ->getPointeeType()\n                              .getAddressSpace();\n      LangAS AddrSpaceR = RHSType->getAs<BlockPointerType>()\n                              ->getPointeeType()\n                              .getAddressSpace();\n      Kind = AddrSpaceL != AddrSpaceR ? CK_AddressSpaceConversion : CK_BitCast;\n      return checkBlockPointerTypesForAssignment(*this, LHSType, RHSType);\n    }\n\n    // int or null -> T^\n    if (RHSType->isIntegerType()) {\n      Kind = CK_IntegralToPointer; // FIXME: null\n      return IntToBlockPointer;\n    }\n\n    // id -> T^\n    if (getLangOpts().ObjC && RHSType->isObjCIdType()) {\n      Kind = CK_AnyPointerToBlockPointerCast;\n      return Compatible;\n    }\n\n    // void* -> T^\n    if (const PointerType *RHSPT = RHSType->getAs<PointerType>())\n      if (RHSPT->getPointeeType()->isVoidType()) {\n        Kind = CK_AnyPointerToBlockPointerCast;\n        return Compatible;\n      }\n\n    return Incompatible;\n  }\n\n  // Conversions to Objective-C pointers.\n  if (isa<ObjCObjectPointerType>(LHSType)) {\n    // A* -> B*\n    if (RHSType->isObjCObjectPointerType()) {\n      Kind = CK_BitCast;\n      Sema::AssignConvertType result =\n        checkObjCPointerTypesForAssignment(*this, LHSType, RHSType);\n      if (getLangOpts().allowsNonTrivialObjCLifetimeQualifiers() &&\n          result == Compatible &&\n          !CheckObjCARCUnavailableWeakConversion(OrigLHSType, RHSType))\n        result = IncompatibleObjCWeakRef;\n      return result;\n    }\n\n    // int or null -> A*\n    if (RHSType->isIntegerType()) {\n      Kind = CK_IntegralToPointer; // FIXME: null\n      return IntToPointer;\n    }\n\n    // In general, C pointers are not compatible with ObjC object pointers,\n    // with two exceptions:\n    if (isa<PointerType>(RHSType)) {\n      Kind = CK_CPointerToObjCPointerCast;\n\n      //  - conversions from 'void*'\n      if (RHSType->isVoidPointerType()) {\n        return Compatible;\n      }\n\n      //  - conversions to 'Class' from its redefinition type\n      if (LHSType->isObjCClassType() &&\n          Context.hasSameType(RHSType,\n                              Context.getObjCClassRedefinitionType())) {\n        return Compatible;\n      }\n\n      return IncompatiblePointer;\n    }\n\n    // Only under strict condition T^ is compatible with an Objective-C pointer.\n    if (RHSType->isBlockPointerType() &&\n        LHSType->isBlockCompatibleObjCPointerType(Context)) {\n      if (ConvertRHS)\n        maybeExtendBlockObject(RHS);\n      Kind = CK_BlockPointerToObjCPointerCast;\n      return Compatible;\n    }\n\n    return Incompatible;\n  }\n\n  // Conversions from pointers that are not covered by the above.\n  if (isa<PointerType>(RHSType)) {\n    // T* -> _Bool\n    if (LHSType == Context.BoolTy) {\n      Kind = CK_PointerToBoolean;\n      return Compatible;\n    }\n\n    // T* -> int\n    if (LHSType->isIntegerType()) {\n      Kind = CK_PointerToIntegral;\n      return PointerToInt;\n    }\n\n    return Incompatible;\n  }\n\n  // Conversions from Objective-C pointers that are not covered by the above.\n  if (isa<ObjCObjectPointerType>(RHSType)) {\n    // T* -> _Bool\n    if (LHSType == Context.BoolTy) {\n      Kind = CK_PointerToBoolean;\n      return Compatible;\n    }\n\n    // T* -> int\n    if (LHSType->isIntegerType()) {\n      Kind = CK_PointerToIntegral;\n      return PointerToInt;\n    }\n\n    return Incompatible;\n  }\n\n  // struct A -> struct B\n  if (isa<TagType>(LHSType) && isa<TagType>(RHSType)) {\n    if (Context.typesAreCompatible(LHSType, RHSType)) {\n      Kind = CK_NoOp;\n      return Compatible;\n    }\n  }\n\n  if (LHSType->isSamplerT() && RHSType->isIntegerType()) {\n    Kind = CK_IntToOCLSampler;\n    return Compatible;\n  }\n\n  return Incompatible;\n}\n\n/// Constructs a transparent union from an expression that is\n/// used to initialize the transparent union.\nstatic void ConstructTransparentUnion(Sema &S, ASTContext &C,\n                                      ExprResult &EResult, QualType UnionType,\n                                      FieldDecl *Field) {\n  // Build an initializer list that designates the appropriate member\n  // of the transparent union.\n  Expr *E = EResult.get();\n  InitListExpr *Initializer = new (C) InitListExpr(C, SourceLocation(),\n                                                   E, SourceLocation());\n  Initializer->setType(UnionType);\n  Initializer->setInitializedFieldInUnion(Field);\n\n  // Build a compound literal constructing a value of the transparent\n  // union type from this initializer list.\n  TypeSourceInfo *unionTInfo = C.getTrivialTypeSourceInfo(UnionType);\n  EResult = new (C) CompoundLiteralExpr(SourceLocation(), unionTInfo, UnionType,\n                                        VK_RValue, Initializer, false);\n}\n\nSema::AssignConvertType\nSema::CheckTransparentUnionArgumentConstraints(QualType ArgType,\n                                               ExprResult &RHS) {\n  QualType RHSType = RHS.get()->getType();\n\n  // If the ArgType is a Union type, we want to handle a potential\n  // transparent_union GCC extension.\n  const RecordType *UT = ArgType->getAsUnionType();\n  if (!UT || !UT->getDecl()->hasAttr<TransparentUnionAttr>())\n    return Incompatible;\n\n  // The field to initialize within the transparent union.\n  RecordDecl *UD = UT->getDecl();\n  FieldDecl *InitField = nullptr;\n  // It's compatible if the expression matches any of the fields.\n  for (auto *it : UD->fields()) {\n    if (it->getType()->isPointerType()) {\n      // If the transparent union contains a pointer type, we allow:\n      // 1) void pointer\n      // 2) null pointer constant\n      if (RHSType->isPointerType())\n        if (RHSType->castAs<PointerType>()->getPointeeType()->isVoidType()) {\n          RHS = ImpCastExprToType(RHS.get(), it->getType(), CK_BitCast);\n          InitField = it;\n          break;\n        }\n\n      if (RHS.get()->isNullPointerConstant(Context,\n                                           Expr::NPC_ValueDependentIsNull)) {\n        RHS = ImpCastExprToType(RHS.get(), it->getType(),\n                                CK_NullToPointer);\n        InitField = it;\n        break;\n      }\n    }\n\n    CastKind Kind;\n    if (CheckAssignmentConstraints(it->getType(), RHS, Kind)\n          == Compatible) {\n      RHS = ImpCastExprToType(RHS.get(), it->getType(), Kind);\n      InitField = it;\n      break;\n    }\n  }\n\n  if (!InitField)\n    return Incompatible;\n\n  ConstructTransparentUnion(*this, Context, RHS, ArgType, InitField);\n  return Compatible;\n}\n\nSema::AssignConvertType\nSema::CheckSingleAssignmentConstraints(QualType LHSType, ExprResult &CallerRHS,\n                                       bool Diagnose,\n                                       bool DiagnoseCFAudited,\n                                       bool ConvertRHS) {\n  // We need to be able to tell the caller whether we diagnosed a problem, if\n  // they ask us to issue diagnostics.\n  assert((ConvertRHS || !Diagnose) && \"can't indicate whether we diagnosed\");\n\n  // If ConvertRHS is false, we want to leave the caller's RHS untouched. Sadly,\n  // we can't avoid *all* modifications at the moment, so we need some somewhere\n  // to put the updated value.\n  ExprResult LocalRHS = CallerRHS;\n  ExprResult &RHS = ConvertRHS ? CallerRHS : LocalRHS;\n\n  if (const auto *LHSPtrType = LHSType->getAs<PointerType>()) {\n    if (const auto *RHSPtrType = RHS.get()->getType()->getAs<PointerType>()) {\n      if (RHSPtrType->getPointeeType()->hasAttr(attr::NoDeref) &&\n          !LHSPtrType->getPointeeType()->hasAttr(attr::NoDeref)) {\n        Diag(RHS.get()->getExprLoc(),\n             diag::warn_noderef_to_dereferenceable_pointer)\n            << RHS.get()->getSourceRange();\n      }\n    }\n  }\n\n  if (getLangOpts().CPlusPlus) {\n    if (!LHSType->isRecordType() && !LHSType->isAtomicType()) {\n      // C++ 5.17p3: If the left operand is not of class type, the\n      // expression is implicitly converted (C++ 4) to the\n      // cv-unqualified type of the left operand.\n      QualType RHSType = RHS.get()->getType();\n      if (Diagnose) {\n        RHS = PerformImplicitConversion(RHS.get(), LHSType.getUnqualifiedType(),\n                                        AA_Assigning);\n      } else {\n        ImplicitConversionSequence ICS =\n            TryImplicitConversion(RHS.get(), LHSType.getUnqualifiedType(),\n                                  /*SuppressUserConversions=*/false,\n                                  AllowedExplicit::None,\n                                  /*InOverloadResolution=*/false,\n                                  /*CStyle=*/false,\n                                  /*AllowObjCWritebackConversion=*/false);\n        if (ICS.isFailure())\n          return Incompatible;\n        RHS = PerformImplicitConversion(RHS.get(), LHSType.getUnqualifiedType(),\n                                        ICS, AA_Assigning);\n      }\n      if (RHS.isInvalid())\n        return Incompatible;\n      Sema::AssignConvertType result = Compatible;\n      if (getLangOpts().allowsNonTrivialObjCLifetimeQualifiers() &&\n          !CheckObjCARCUnavailableWeakConversion(LHSType, RHSType))\n        result = IncompatibleObjCWeakRef;\n      return result;\n    }\n\n    // FIXME: Currently, we fall through and treat C++ classes like C\n    // structures.\n    // FIXME: We also fall through for atomics; not sure what should\n    // happen there, though.\n  } else if (RHS.get()->getType() == Context.OverloadTy) {\n    // As a set of extensions to C, we support overloading on functions. These\n    // functions need to be resolved here.\n    DeclAccessPair DAP;\n    if (FunctionDecl *FD = ResolveAddressOfOverloadedFunction(\n            RHS.get(), LHSType, /*Complain=*/false, DAP))\n      RHS = FixOverloadedFunctionReference(RHS.get(), DAP, FD);\n    else\n      return Incompatible;\n  }\n\n  // C99 6.5.16.1p1: the left operand is a pointer and the right is\n  // a null pointer constant.\n  if ((LHSType->isPointerType() || LHSType->isObjCObjectPointerType() ||\n       LHSType->isBlockPointerType()) &&\n      RHS.get()->isNullPointerConstant(Context,\n                                       Expr::NPC_ValueDependentIsNull)) {\n    if (Diagnose || ConvertRHS) {\n      CastKind Kind;\n      CXXCastPath Path;\n      CheckPointerConversion(RHS.get(), LHSType, Kind, Path,\n                             /*IgnoreBaseAccess=*/false, Diagnose);\n      if (ConvertRHS)\n        RHS = ImpCastExprToType(RHS.get(), LHSType, Kind, VK_RValue, &Path);\n    }\n    return Compatible;\n  }\n\n  // OpenCL queue_t type assignment.\n  if (LHSType->isQueueT() && RHS.get()->isNullPointerConstant(\n                                 Context, Expr::NPC_ValueDependentIsNull)) {\n    RHS = ImpCastExprToType(RHS.get(), LHSType, CK_NullToPointer);\n    return Compatible;\n  }\n\n  // This check seems unnatural, however it is necessary to ensure the proper\n  // conversion of functions/arrays. If the conversion were done for all\n  // DeclExpr's (created by ActOnIdExpression), it would mess up the unary\n  // expressions that suppress this implicit conversion (&, sizeof).\n  //\n  // Suppress this for references: C++ 8.5.3p5.\n  if (!LHSType->isReferenceType()) {\n    // FIXME: We potentially allocate here even if ConvertRHS is false.\n    RHS = DefaultFunctionArrayLvalueConversion(RHS.get(), Diagnose);\n    if (RHS.isInvalid())\n      return Incompatible;\n  }\n  CastKind Kind;\n  Sema::AssignConvertType result =\n    CheckAssignmentConstraints(LHSType, RHS, Kind, ConvertRHS);\n\n  // C99 6.5.16.1p2: The value of the right operand is converted to the\n  // type of the assignment expression.\n  // CheckAssignmentConstraints allows the left-hand side to be a reference,\n  // so that we can use references in built-in functions even in C.\n  // The getNonReferenceType() call makes sure that the resulting expression\n  // does not have reference type.\n  if (result != Incompatible && RHS.get()->getType() != LHSType) {\n    QualType Ty = LHSType.getNonLValueExprType(Context);\n    Expr *E = RHS.get();\n\n    // Check for various Objective-C errors. If we are not reporting\n    // diagnostics and just checking for errors, e.g., during overload\n    // resolution, return Incompatible to indicate the failure.\n    if (getLangOpts().allowsNonTrivialObjCLifetimeQualifiers() &&\n        CheckObjCConversion(SourceRange(), Ty, E, CCK_ImplicitConversion,\n                            Diagnose, DiagnoseCFAudited) != ACR_okay) {\n      if (!Diagnose)\n        return Incompatible;\n    }\n    if (getLangOpts().ObjC &&\n        (CheckObjCBridgeRelatedConversions(E->getBeginLoc(), LHSType,\n                                           E->getType(), E, Diagnose) ||\n         CheckConversionToObjCLiteral(LHSType, E, Diagnose))) {\n      if (!Diagnose)\n        return Incompatible;\n      // Replace the expression with a corrected version and continue so we\n      // can find further errors.\n      RHS = E;\n      return Compatible;\n    }\n\n    if (ConvertRHS)\n      RHS = ImpCastExprToType(E, Ty, Kind);\n  }\n\n  return result;\n}\n\nnamespace {\n/// The original operand to an operator, prior to the application of the usual\n/// arithmetic conversions and converting the arguments of a builtin operator\n/// candidate.\nstruct OriginalOperand {\n  explicit OriginalOperand(Expr *Op) : Orig(Op), Conversion(nullptr) {\n    if (auto *MTE = dyn_cast<MaterializeTemporaryExpr>(Op))\n      Op = MTE->getSubExpr();\n    if (auto *BTE = dyn_cast<CXXBindTemporaryExpr>(Op))\n      Op = BTE->getSubExpr();\n    if (auto *ICE = dyn_cast<ImplicitCastExpr>(Op)) {\n      Orig = ICE->getSubExprAsWritten();\n      Conversion = ICE->getConversionFunction();\n    }\n  }\n\n  QualType getType() const { return Orig->getType(); }\n\n  Expr *Orig;\n  NamedDecl *Conversion;\n};\n}\n\nQualType Sema::InvalidOperands(SourceLocation Loc, ExprResult &LHS,\n                               ExprResult &RHS) {\n  OriginalOperand OrigLHS(LHS.get()), OrigRHS(RHS.get());\n\n  Diag(Loc, diag::err_typecheck_invalid_operands)\n    << OrigLHS.getType() << OrigRHS.getType()\n    << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n\n  // If a user-defined conversion was applied to either of the operands prior\n  // to applying the built-in operator rules, tell the user about it.\n  if (OrigLHS.Conversion) {\n    Diag(OrigLHS.Conversion->getLocation(),\n         diag::note_typecheck_invalid_operands_converted)\n      << 0 << LHS.get()->getType();\n  }\n  if (OrigRHS.Conversion) {\n    Diag(OrigRHS.Conversion->getLocation(),\n         diag::note_typecheck_invalid_operands_converted)\n      << 1 << RHS.get()->getType();\n  }\n\n  return QualType();\n}\n\n// Diagnose cases where a scalar was implicitly converted to a vector and\n// diagnose the underlying types. Otherwise, diagnose the error\n// as invalid vector logical operands for non-C++ cases.\nQualType Sema::InvalidLogicalVectorOperands(SourceLocation Loc, ExprResult &LHS,\n                                            ExprResult &RHS) {\n  QualType LHSType = LHS.get()->IgnoreImpCasts()->getType();\n  QualType RHSType = RHS.get()->IgnoreImpCasts()->getType();\n\n  bool LHSNatVec = LHSType->isVectorType();\n  bool RHSNatVec = RHSType->isVectorType();\n\n  if (!(LHSNatVec && RHSNatVec)) {\n    Expr *Vector = LHSNatVec ? LHS.get() : RHS.get();\n    Expr *NonVector = !LHSNatVec ? LHS.get() : RHS.get();\n    Diag(Loc, diag::err_typecheck_logical_vector_expr_gnu_cpp_restrict)\n        << 0 << Vector->getType() << NonVector->IgnoreImpCasts()->getType()\n        << Vector->getSourceRange();\n    return QualType();\n  }\n\n  Diag(Loc, diag::err_typecheck_logical_vector_expr_gnu_cpp_restrict)\n      << 1 << LHSType << RHSType << LHS.get()->getSourceRange()\n      << RHS.get()->getSourceRange();\n\n  return QualType();\n}\n\n/// Try to convert a value of non-vector type to a vector type by converting\n/// the type to the element type of the vector and then performing a splat.\n/// If the language is OpenCL, we only use conversions that promote scalar\n/// rank; for C, Obj-C, and C++ we allow any real scalar conversion except\n/// for float->int.\n///\n/// OpenCL V2.0 6.2.6.p2:\n/// An error shall occur if any scalar operand type has greater rank\n/// than the type of the vector element.\n///\n/// \\param scalar - if non-null, actually perform the conversions\n/// \\return true if the operation fails (but without diagnosing the failure)\nstatic bool tryVectorConvertAndSplat(Sema &S, ExprResult *scalar,\n                                     QualType scalarTy,\n                                     QualType vectorEltTy,\n                                     QualType vectorTy,\n                                     unsigned &DiagID) {\n  // The conversion to apply to the scalar before splatting it,\n  // if necessary.\n  CastKind scalarCast = CK_NoOp;\n\n  if (vectorEltTy->isIntegralType(S.Context)) {\n    if (S.getLangOpts().OpenCL && (scalarTy->isRealFloatingType() ||\n        (scalarTy->isIntegerType() &&\n         S.Context.getIntegerTypeOrder(vectorEltTy, scalarTy) < 0))) {\n      DiagID = diag::err_opencl_scalar_type_rank_greater_than_vector_type;\n      return true;\n    }\n    if (!scalarTy->isIntegralType(S.Context))\n      return true;\n    scalarCast = CK_IntegralCast;\n  } else if (vectorEltTy->isRealFloatingType()) {\n    if (scalarTy->isRealFloatingType()) {\n      if (S.getLangOpts().OpenCL &&\n          S.Context.getFloatingTypeOrder(vectorEltTy, scalarTy) < 0) {\n        DiagID = diag::err_opencl_scalar_type_rank_greater_than_vector_type;\n        return true;\n      }\n      scalarCast = CK_FloatingCast;\n    }\n    else if (scalarTy->isIntegralType(S.Context))\n      scalarCast = CK_IntegralToFloating;\n    else\n      return true;\n  } else {\n    return true;\n  }\n\n  // Adjust scalar if desired.\n  if (scalar) {\n    if (scalarCast != CK_NoOp)\n      *scalar = S.ImpCastExprToType(scalar->get(), vectorEltTy, scalarCast);\n    *scalar = S.ImpCastExprToType(scalar->get(), vectorTy, CK_VectorSplat);\n  }\n  return false;\n}\n\n/// Convert vector E to a vector with the same number of elements but different\n/// element type.\nstatic ExprResult convertVector(Expr *E, QualType ElementType, Sema &S) {\n  const auto *VecTy = E->getType()->getAs<VectorType>();\n  assert(VecTy && \"Expression E must be a vector\");\n  QualType NewVecTy = S.Context.getVectorType(ElementType,\n                                              VecTy->getNumElements(),\n                                              VecTy->getVectorKind());\n\n  // Look through the implicit cast. Return the subexpression if its type is\n  // NewVecTy.\n  if (auto *ICE = dyn_cast<ImplicitCastExpr>(E))\n    if (ICE->getSubExpr()->getType() == NewVecTy)\n      return ICE->getSubExpr();\n\n  auto Cast = ElementType->isIntegerType() ? CK_IntegralCast : CK_FloatingCast;\n  return S.ImpCastExprToType(E, NewVecTy, Cast);\n}\n\n/// Test if a (constant) integer Int can be casted to another integer type\n/// IntTy without losing precision.\nstatic bool canConvertIntToOtherIntTy(Sema &S, ExprResult *Int,\n                                      QualType OtherIntTy) {\n  QualType IntTy = Int->get()->getType().getUnqualifiedType();\n\n  // Reject cases where the value of the Int is unknown as that would\n  // possibly cause truncation, but accept cases where the scalar can be\n  // demoted without loss of precision.\n  Expr::EvalResult EVResult;\n  bool CstInt = Int->get()->EvaluateAsInt(EVResult, S.Context);\n  int Order = S.Context.getIntegerTypeOrder(OtherIntTy, IntTy);\n  bool IntSigned = IntTy->hasSignedIntegerRepresentation();\n  bool OtherIntSigned = OtherIntTy->hasSignedIntegerRepresentation();\n\n  if (CstInt) {\n    // If the scalar is constant and is of a higher order and has more active\n    // bits that the vector element type, reject it.\n    llvm::APSInt Result = EVResult.Val.getInt();\n    unsigned NumBits = IntSigned\n                           ? (Result.isNegative() ? Result.getMinSignedBits()\n                                                  : Result.getActiveBits())\n                           : Result.getActiveBits();\n    if (Order < 0 && S.Context.getIntWidth(OtherIntTy) < NumBits)\n      return true;\n\n    // If the signedness of the scalar type and the vector element type\n    // differs and the number of bits is greater than that of the vector\n    // element reject it.\n    return (IntSigned != OtherIntSigned &&\n            NumBits > S.Context.getIntWidth(OtherIntTy));\n  }\n\n  // Reject cases where the value of the scalar is not constant and it's\n  // order is greater than that of the vector element type.\n  return (Order < 0);\n}\n\n/// Test if a (constant) integer Int can be casted to floating point type\n/// FloatTy without losing precision.\nstatic bool canConvertIntTyToFloatTy(Sema &S, ExprResult *Int,\n                                     QualType FloatTy) {\n  QualType IntTy = Int->get()->getType().getUnqualifiedType();\n\n  // Determine if the integer constant can be expressed as a floating point\n  // number of the appropriate type.\n  Expr::EvalResult EVResult;\n  bool CstInt = Int->get()->EvaluateAsInt(EVResult, S.Context);\n\n  uint64_t Bits = 0;\n  if (CstInt) {\n    // Reject constants that would be truncated if they were converted to\n    // the floating point type. Test by simple to/from conversion.\n    // FIXME: Ideally the conversion to an APFloat and from an APFloat\n    //        could be avoided if there was a convertFromAPInt method\n    //        which could signal back if implicit truncation occurred.\n    llvm::APSInt Result = EVResult.Val.getInt();\n    llvm::APFloat Float(S.Context.getFloatTypeSemantics(FloatTy));\n    Float.convertFromAPInt(Result, IntTy->hasSignedIntegerRepresentation(),\n                           llvm::APFloat::rmTowardZero);\n    llvm::APSInt ConvertBack(S.Context.getIntWidth(IntTy),\n                             !IntTy->hasSignedIntegerRepresentation());\n    bool Ignored = false;\n    Float.convertToInteger(ConvertBack, llvm::APFloat::rmNearestTiesToEven,\n                           &Ignored);\n    if (Result != ConvertBack)\n      return true;\n  } else {\n    // Reject types that cannot be fully encoded into the mantissa of\n    // the float.\n    Bits = S.Context.getTypeSize(IntTy);\n    unsigned FloatPrec = llvm::APFloat::semanticsPrecision(\n        S.Context.getFloatTypeSemantics(FloatTy));\n    if (Bits > FloatPrec)\n      return true;\n  }\n\n  return false;\n}\n\n/// Attempt to convert and splat Scalar into a vector whose types matches\n/// Vector following GCC conversion rules. The rule is that implicit\n/// conversion can occur when Scalar can be casted to match Vector's element\n/// type without causing truncation of Scalar.\nstatic bool tryGCCVectorConvertAndSplat(Sema &S, ExprResult *Scalar,\n                                        ExprResult *Vector) {\n  QualType ScalarTy = Scalar->get()->getType().getUnqualifiedType();\n  QualType VectorTy = Vector->get()->getType().getUnqualifiedType();\n  const VectorType *VT = VectorTy->getAs<VectorType>();\n\n  assert(!isa<ExtVectorType>(VT) &&\n         \"ExtVectorTypes should not be handled here!\");\n\n  QualType VectorEltTy = VT->getElementType();\n\n  // Reject cases where the vector element type or the scalar element type are\n  // not integral or floating point types.\n  if (!VectorEltTy->isArithmeticType() || !ScalarTy->isArithmeticType())\n    return true;\n\n  // The conversion to apply to the scalar before splatting it,\n  // if necessary.\n  CastKind ScalarCast = CK_NoOp;\n\n  // Accept cases where the vector elements are integers and the scalar is\n  // an integer.\n  // FIXME: Notionally if the scalar was a floating point value with a precise\n  //        integral representation, we could cast it to an appropriate integer\n  //        type and then perform the rest of the checks here. GCC will perform\n  //        this conversion in some cases as determined by the input language.\n  //        We should accept it on a language independent basis.\n  if (VectorEltTy->isIntegralType(S.Context) &&\n      ScalarTy->isIntegralType(S.Context) &&\n      S.Context.getIntegerTypeOrder(VectorEltTy, ScalarTy)) {\n\n    if (canConvertIntToOtherIntTy(S, Scalar, VectorEltTy))\n      return true;\n\n    ScalarCast = CK_IntegralCast;\n  } else if (VectorEltTy->isIntegralType(S.Context) &&\n             ScalarTy->isRealFloatingType()) {\n    if (S.Context.getTypeSize(VectorEltTy) == S.Context.getTypeSize(ScalarTy))\n      ScalarCast = CK_FloatingToIntegral;\n    else\n      return true;\n  } else if (VectorEltTy->isRealFloatingType()) {\n    if (ScalarTy->isRealFloatingType()) {\n\n      // Reject cases where the scalar type is not a constant and has a higher\n      // Order than the vector element type.\n      llvm::APFloat Result(0.0);\n\n      // Determine whether this is a constant scalar. In the event that the\n      // value is dependent (and thus cannot be evaluated by the constant\n      // evaluator), skip the evaluation. This will then diagnose once the\n      // expression is instantiated.\n      bool CstScalar = Scalar->get()->isValueDependent() ||\n                       Scalar->get()->EvaluateAsFloat(Result, S.Context);\n      int Order = S.Context.getFloatingTypeOrder(VectorEltTy, ScalarTy);\n      if (!CstScalar && Order < 0)\n        return true;\n\n      // If the scalar cannot be safely casted to the vector element type,\n      // reject it.\n      if (CstScalar) {\n        bool Truncated = false;\n        Result.convert(S.Context.getFloatTypeSemantics(VectorEltTy),\n                       llvm::APFloat::rmNearestTiesToEven, &Truncated);\n        if (Truncated)\n          return true;\n      }\n\n      ScalarCast = CK_FloatingCast;\n    } else if (ScalarTy->isIntegralType(S.Context)) {\n      if (canConvertIntTyToFloatTy(S, Scalar, VectorEltTy))\n        return true;\n\n      ScalarCast = CK_IntegralToFloating;\n    } else\n      return true;\n  } else if (ScalarTy->isEnumeralType())\n    return true;\n\n  // Adjust scalar if desired.\n  if (Scalar) {\n    if (ScalarCast != CK_NoOp)\n      *Scalar = S.ImpCastExprToType(Scalar->get(), VectorEltTy, ScalarCast);\n    *Scalar = S.ImpCastExprToType(Scalar->get(), VectorTy, CK_VectorSplat);\n  }\n  return false;\n}\n\nQualType Sema::CheckVectorOperands(ExprResult &LHS, ExprResult &RHS,\n                                   SourceLocation Loc, bool IsCompAssign,\n                                   bool AllowBothBool,\n                                   bool AllowBoolConversions) {\n  if (!IsCompAssign) {\n    LHS = DefaultFunctionArrayLvalueConversion(LHS.get());\n    if (LHS.isInvalid())\n      return QualType();\n  }\n  RHS = DefaultFunctionArrayLvalueConversion(RHS.get());\n  if (RHS.isInvalid())\n    return QualType();\n\n  // For conversion purposes, we ignore any qualifiers.\n  // For example, \"const float\" and \"float\" are equivalent.\n  QualType LHSType = LHS.get()->getType().getUnqualifiedType();\n  QualType RHSType = RHS.get()->getType().getUnqualifiedType();\n\n  const VectorType *LHSVecType = LHSType->getAs<VectorType>();\n  const VectorType *RHSVecType = RHSType->getAs<VectorType>();\n  assert(LHSVecType || RHSVecType);\n\n  if ((LHSVecType && LHSVecType->getElementType()->isBFloat16Type()) ||\n      (RHSVecType && RHSVecType->getElementType()->isBFloat16Type()))\n    return InvalidOperands(Loc, LHS, RHS);\n\n  // AltiVec-style \"vector bool op vector bool\" combinations are allowed\n  // for some operators but not others.\n  if (!AllowBothBool &&\n      LHSVecType && LHSVecType->getVectorKind() == VectorType::AltiVecBool &&\n      RHSVecType && RHSVecType->getVectorKind() == VectorType::AltiVecBool)\n    return InvalidOperands(Loc, LHS, RHS);\n\n  // If the vector types are identical, return.\n  if (Context.hasSameType(LHSType, RHSType))\n    return LHSType;\n\n  // If we have compatible AltiVec and GCC vector types, use the AltiVec type.\n  if (LHSVecType && RHSVecType &&\n      Context.areCompatibleVectorTypes(LHSType, RHSType)) {\n    if (isa<ExtVectorType>(LHSVecType)) {\n      RHS = ImpCastExprToType(RHS.get(), LHSType, CK_BitCast);\n      return LHSType;\n    }\n\n    if (!IsCompAssign)\n      LHS = ImpCastExprToType(LHS.get(), RHSType, CK_BitCast);\n    return RHSType;\n  }\n\n  // AllowBoolConversions says that bool and non-bool AltiVec vectors\n  // can be mixed, with the result being the non-bool type.  The non-bool\n  // operand must have integer element type.\n  if (AllowBoolConversions && LHSVecType && RHSVecType &&\n      LHSVecType->getNumElements() == RHSVecType->getNumElements() &&\n      (Context.getTypeSize(LHSVecType->getElementType()) ==\n       Context.getTypeSize(RHSVecType->getElementType()))) {\n    if (LHSVecType->getVectorKind() == VectorType::AltiVecVector &&\n        LHSVecType->getElementType()->isIntegerType() &&\n        RHSVecType->getVectorKind() == VectorType::AltiVecBool) {\n      RHS = ImpCastExprToType(RHS.get(), LHSType, CK_BitCast);\n      return LHSType;\n    }\n    if (!IsCompAssign &&\n        LHSVecType->getVectorKind() == VectorType::AltiVecBool &&\n        RHSVecType->getVectorKind() == VectorType::AltiVecVector &&\n        RHSVecType->getElementType()->isIntegerType()) {\n      LHS = ImpCastExprToType(LHS.get(), RHSType, CK_BitCast);\n      return RHSType;\n    }\n  }\n\n  // Expressions containing fixed-length and sizeless SVE vectors are invalid\n  // since the ambiguity can affect the ABI.\n  auto IsSveConversion = [](QualType FirstType, QualType SecondType) {\n    const VectorType *VecType = SecondType->getAs<VectorType>();\n    return FirstType->isSizelessBuiltinType() && VecType &&\n           (VecType->getVectorKind() == VectorType::SveFixedLengthDataVector ||\n            VecType->getVectorKind() ==\n                VectorType::SveFixedLengthPredicateVector);\n  };\n\n  if (IsSveConversion(LHSType, RHSType) || IsSveConversion(RHSType, LHSType)) {\n    Diag(Loc, diag::err_typecheck_sve_ambiguous) << LHSType << RHSType;\n    return QualType();\n  }\n\n  // Expressions containing GNU and SVE (fixed or sizeless) vectors are invalid\n  // since the ambiguity can affect the ABI.\n  auto IsSveGnuConversion = [](QualType FirstType, QualType SecondType) {\n    const VectorType *FirstVecType = FirstType->getAs<VectorType>();\n    const VectorType *SecondVecType = SecondType->getAs<VectorType>();\n\n    if (FirstVecType && SecondVecType)\n      return FirstVecType->getVectorKind() == VectorType::GenericVector &&\n             (SecondVecType->getVectorKind() ==\n                  VectorType::SveFixedLengthDataVector ||\n              SecondVecType->getVectorKind() ==\n                  VectorType::SveFixedLengthPredicateVector);\n\n    return FirstType->isSizelessBuiltinType() && SecondVecType &&\n           SecondVecType->getVectorKind() == VectorType::GenericVector;\n  };\n\n  if (IsSveGnuConversion(LHSType, RHSType) ||\n      IsSveGnuConversion(RHSType, LHSType)) {\n    Diag(Loc, diag::err_typecheck_sve_gnu_ambiguous) << LHSType << RHSType;\n    return QualType();\n  }\n\n  // If there's a vector type and a scalar, try to convert the scalar to\n  // the vector element type and splat.\n  unsigned DiagID = diag::err_typecheck_vector_not_convertable;\n  if (!RHSVecType) {\n    if (isa<ExtVectorType>(LHSVecType)) {\n      if (!tryVectorConvertAndSplat(*this, &RHS, RHSType,\n                                    LHSVecType->getElementType(), LHSType,\n                                    DiagID))\n        return LHSType;\n    } else {\n      if (!tryGCCVectorConvertAndSplat(*this, &RHS, &LHS))\n        return LHSType;\n    }\n  }\n  if (!LHSVecType) {\n    if (isa<ExtVectorType>(RHSVecType)) {\n      if (!tryVectorConvertAndSplat(*this, (IsCompAssign ? nullptr : &LHS),\n                                    LHSType, RHSVecType->getElementType(),\n                                    RHSType, DiagID))\n        return RHSType;\n    } else {\n      if (LHS.get()->getValueKind() == VK_LValue ||\n          !tryGCCVectorConvertAndSplat(*this, &LHS, &RHS))\n        return RHSType;\n    }\n  }\n\n  // FIXME: The code below also handles conversion between vectors and\n  // non-scalars, we should break this down into fine grained specific checks\n  // and emit proper diagnostics.\n  QualType VecType = LHSVecType ? LHSType : RHSType;\n  const VectorType *VT = LHSVecType ? LHSVecType : RHSVecType;\n  QualType OtherType = LHSVecType ? RHSType : LHSType;\n  ExprResult *OtherExpr = LHSVecType ? &RHS : &LHS;\n  if (isLaxVectorConversion(OtherType, VecType)) {\n    // If we're allowing lax vector conversions, only the total (data) size\n    // needs to be the same. For non compound assignment, if one of the types is\n    // scalar, the result is always the vector type.\n    if (!IsCompAssign) {\n      *OtherExpr = ImpCastExprToType(OtherExpr->get(), VecType, CK_BitCast);\n      return VecType;\n    // In a compound assignment, lhs += rhs, 'lhs' is a lvalue src, forbidding\n    // any implicit cast. Here, the 'rhs' should be implicit casted to 'lhs'\n    // type. Note that this is already done by non-compound assignments in\n    // CheckAssignmentConstraints. If it's a scalar type, only bitcast for\n    // <1 x T> -> T. The result is also a vector type.\n    } else if (OtherType->isExtVectorType() || OtherType->isVectorType() ||\n               (OtherType->isScalarType() && VT->getNumElements() == 1)) {\n      ExprResult *RHSExpr = &RHS;\n      *RHSExpr = ImpCastExprToType(RHSExpr->get(), LHSType, CK_BitCast);\n      return VecType;\n    }\n  }\n\n  // Okay, the expression is invalid.\n\n  // If there's a non-vector, non-real operand, diagnose that.\n  if ((!RHSVecType && !RHSType->isRealType()) ||\n      (!LHSVecType && !LHSType->isRealType())) {\n    Diag(Loc, diag::err_typecheck_vector_not_convertable_non_scalar)\n      << LHSType << RHSType\n      << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n    return QualType();\n  }\n\n  // OpenCL V1.1 6.2.6.p1:\n  // If the operands are of more than one vector type, then an error shall\n  // occur. Implicit conversions between vector types are not permitted, per\n  // section 6.2.1.\n  if (getLangOpts().OpenCL &&\n      RHSVecType && isa<ExtVectorType>(RHSVecType) &&\n      LHSVecType && isa<ExtVectorType>(LHSVecType)) {\n    Diag(Loc, diag::err_opencl_implicit_vector_conversion) << LHSType\n                                                           << RHSType;\n    return QualType();\n  }\n\n\n  // If there is a vector type that is not a ExtVector and a scalar, we reach\n  // this point if scalar could not be converted to the vector's element type\n  // without truncation.\n  if ((RHSVecType && !isa<ExtVectorType>(RHSVecType)) ||\n      (LHSVecType && !isa<ExtVectorType>(LHSVecType))) {\n    QualType Scalar = LHSVecType ? RHSType : LHSType;\n    QualType Vector = LHSVecType ? LHSType : RHSType;\n    unsigned ScalarOrVector = LHSVecType && RHSVecType ? 1 : 0;\n    Diag(Loc,\n         diag::err_typecheck_vector_not_convertable_implict_truncation)\n        << ScalarOrVector << Scalar << Vector;\n\n    return QualType();\n  }\n\n  // Otherwise, use the generic diagnostic.\n  Diag(Loc, DiagID)\n    << LHSType << RHSType\n    << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n  return QualType();\n}\n\n// checkArithmeticNull - Detect when a NULL constant is used improperly in an\n// expression.  These are mainly cases where the null pointer is used as an\n// integer instead of a pointer.\nstatic void checkArithmeticNull(Sema &S, ExprResult &LHS, ExprResult &RHS,\n                                SourceLocation Loc, bool IsCompare) {\n  // The canonical way to check for a GNU null is with isNullPointerConstant,\n  // but we use a bit of a hack here for speed; this is a relatively\n  // hot path, and isNullPointerConstant is slow.\n  bool LHSNull = isa<GNUNullExpr>(LHS.get()->IgnoreParenImpCasts());\n  bool RHSNull = isa<GNUNullExpr>(RHS.get()->IgnoreParenImpCasts());\n\n  QualType NonNullType = LHSNull ? RHS.get()->getType() : LHS.get()->getType();\n\n  // Avoid analyzing cases where the result will either be invalid (and\n  // diagnosed as such) or entirely valid and not something to warn about.\n  if ((!LHSNull && !RHSNull) || NonNullType->isBlockPointerType() ||\n      NonNullType->isMemberPointerType() || NonNullType->isFunctionType())\n    return;\n\n  // Comparison operations would not make sense with a null pointer no matter\n  // what the other expression is.\n  if (!IsCompare) {\n    S.Diag(Loc, diag::warn_null_in_arithmetic_operation)\n        << (LHSNull ? LHS.get()->getSourceRange() : SourceRange())\n        << (RHSNull ? RHS.get()->getSourceRange() : SourceRange());\n    return;\n  }\n\n  // The rest of the operations only make sense with a null pointer\n  // if the other expression is a pointer.\n  if (LHSNull == RHSNull || NonNullType->isAnyPointerType() ||\n      NonNullType->canDecayToPointerType())\n    return;\n\n  S.Diag(Loc, diag::warn_null_in_comparison_operation)\n      << LHSNull /* LHS is NULL */ << NonNullType\n      << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n}\n\nstatic void DiagnoseDivisionSizeofPointerOrArray(Sema &S, Expr *LHS, Expr *RHS,\n                                          SourceLocation Loc) {\n  const auto *LUE = dyn_cast<UnaryExprOrTypeTraitExpr>(LHS);\n  const auto *RUE = dyn_cast<UnaryExprOrTypeTraitExpr>(RHS);\n  if (!LUE || !RUE)\n    return;\n  if (LUE->getKind() != UETT_SizeOf || LUE->isArgumentType() ||\n      RUE->getKind() != UETT_SizeOf)\n    return;\n\n  const Expr *LHSArg = LUE->getArgumentExpr()->IgnoreParens();\n  QualType LHSTy = LHSArg->getType();\n  QualType RHSTy;\n\n  if (RUE->isArgumentType())\n    RHSTy = RUE->getArgumentType().getNonReferenceType();\n  else\n    RHSTy = RUE->getArgumentExpr()->IgnoreParens()->getType();\n\n  if (LHSTy->isPointerType() && !RHSTy->isPointerType()) {\n    if (!S.Context.hasSameUnqualifiedType(LHSTy->getPointeeType(), RHSTy))\n      return;\n\n    S.Diag(Loc, diag::warn_division_sizeof_ptr) << LHS << LHS->getSourceRange();\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(LHSArg)) {\n      if (const ValueDecl *LHSArgDecl = DRE->getDecl())\n        S.Diag(LHSArgDecl->getLocation(), diag::note_pointer_declared_here)\n            << LHSArgDecl;\n    }\n  } else if (const auto *ArrayTy = S.Context.getAsArrayType(LHSTy)) {\n    QualType ArrayElemTy = ArrayTy->getElementType();\n    if (ArrayElemTy != S.Context.getBaseElementType(ArrayTy) ||\n        ArrayElemTy->isDependentType() || RHSTy->isDependentType() ||\n        RHSTy->isReferenceType() || ArrayElemTy->isCharType() ||\n        S.Context.getTypeSize(ArrayElemTy) == S.Context.getTypeSize(RHSTy))\n      return;\n    S.Diag(Loc, diag::warn_division_sizeof_array)\n        << LHSArg->getSourceRange() << ArrayElemTy << RHSTy;\n    if (const auto *DRE = dyn_cast<DeclRefExpr>(LHSArg)) {\n      if (const ValueDecl *LHSArgDecl = DRE->getDecl())\n        S.Diag(LHSArgDecl->getLocation(), diag::note_array_declared_here)\n            << LHSArgDecl;\n    }\n\n    S.Diag(Loc, diag::note_precedence_silence) << RHS;\n  }\n}\n\nstatic void DiagnoseBadDivideOrRemainderValues(Sema& S, ExprResult &LHS,\n                                               ExprResult &RHS,\n                                               SourceLocation Loc, bool IsDiv) {\n  // Check for division/remainder by zero.\n  Expr::EvalResult RHSValue;\n  if (!RHS.get()->isValueDependent() &&\n      RHS.get()->EvaluateAsInt(RHSValue, S.Context) &&\n      RHSValue.Val.getInt() == 0)\n    S.DiagRuntimeBehavior(Loc, RHS.get(),\n                          S.PDiag(diag::warn_remainder_division_by_zero)\n                            << IsDiv << RHS.get()->getSourceRange());\n}\n\nQualType Sema::CheckMultiplyDivideOperands(ExprResult &LHS, ExprResult &RHS,\n                                           SourceLocation Loc,\n                                           bool IsCompAssign, bool IsDiv) {\n  checkArithmeticNull(*this, LHS, RHS, Loc, /*IsCompare=*/false);\n\n  if (LHS.get()->getType()->isVectorType() ||\n      RHS.get()->getType()->isVectorType())\n    return CheckVectorOperands(LHS, RHS, Loc, IsCompAssign,\n                               /*AllowBothBool*/getLangOpts().AltiVec,\n                               /*AllowBoolConversions*/false);\n  if (!IsDiv && (LHS.get()->getType()->isConstantMatrixType() ||\n                 RHS.get()->getType()->isConstantMatrixType()))\n    return CheckMatrixMultiplyOperands(LHS, RHS, Loc, IsCompAssign);\n\n  QualType compType = UsualArithmeticConversions(\n      LHS, RHS, Loc, IsCompAssign ? ACK_CompAssign : ACK_Arithmetic);\n  if (LHS.isInvalid() || RHS.isInvalid())\n    return QualType();\n\n\n  if (compType.isNull() || !compType->isArithmeticType())\n    return InvalidOperands(Loc, LHS, RHS);\n  if (IsDiv) {\n    DiagnoseBadDivideOrRemainderValues(*this, LHS, RHS, Loc, IsDiv);\n    DiagnoseDivisionSizeofPointerOrArray(*this, LHS.get(), RHS.get(), Loc);\n  }\n  return compType;\n}\n\nQualType Sema::CheckRemainderOperands(\n  ExprResult &LHS, ExprResult &RHS, SourceLocation Loc, bool IsCompAssign) {\n  checkArithmeticNull(*this, LHS, RHS, Loc, /*IsCompare=*/false);\n\n  if (LHS.get()->getType()->isVectorType() ||\n      RHS.get()->getType()->isVectorType()) {\n    if (LHS.get()->getType()->hasIntegerRepresentation() &&\n        RHS.get()->getType()->hasIntegerRepresentation())\n      return CheckVectorOperands(LHS, RHS, Loc, IsCompAssign,\n                                 /*AllowBothBool*/getLangOpts().AltiVec,\n                                 /*AllowBoolConversions*/false);\n    return InvalidOperands(Loc, LHS, RHS);\n  }\n\n  QualType compType = UsualArithmeticConversions(\n      LHS, RHS, Loc, IsCompAssign ? ACK_CompAssign : ACK_Arithmetic);\n  if (LHS.isInvalid() || RHS.isInvalid())\n    return QualType();\n\n  if (compType.isNull() || !compType->isIntegerType())\n    return InvalidOperands(Loc, LHS, RHS);\n  DiagnoseBadDivideOrRemainderValues(*this, LHS, RHS, Loc, false /* IsDiv */);\n  return compType;\n}\n\n/// Diagnose invalid arithmetic on two void pointers.\nstatic void diagnoseArithmeticOnTwoVoidPointers(Sema &S, SourceLocation Loc,\n                                                Expr *LHSExpr, Expr *RHSExpr) {\n  S.Diag(Loc, S.getLangOpts().CPlusPlus\n                ? diag::err_typecheck_pointer_arith_void_type\n                : diag::ext_gnu_void_ptr)\n    << 1 /* two pointers */ << LHSExpr->getSourceRange()\n                            << RHSExpr->getSourceRange();\n}\n\n/// Diagnose invalid arithmetic on a void pointer.\nstatic void diagnoseArithmeticOnVoidPointer(Sema &S, SourceLocation Loc,\n                                            Expr *Pointer) {\n  S.Diag(Loc, S.getLangOpts().CPlusPlus\n                ? diag::err_typecheck_pointer_arith_void_type\n                : diag::ext_gnu_void_ptr)\n    << 0 /* one pointer */ << Pointer->getSourceRange();\n}\n\n/// Diagnose invalid arithmetic on a null pointer.\n///\n/// If \\p IsGNUIdiom is true, the operation is using the 'p = (i8*)nullptr + n'\n/// idiom, which we recognize as a GNU extension.\n///\nstatic void diagnoseArithmeticOnNullPointer(Sema &S, SourceLocation Loc,\n                                            Expr *Pointer, bool IsGNUIdiom) {\n  if (IsGNUIdiom)\n    S.Diag(Loc, diag::warn_gnu_null_ptr_arith)\n      << Pointer->getSourceRange();\n  else\n    S.Diag(Loc, diag::warn_pointer_arith_null_ptr)\n      << S.getLangOpts().CPlusPlus << Pointer->getSourceRange();\n}\n\n/// Diagnose invalid arithmetic on two function pointers.\nstatic void diagnoseArithmeticOnTwoFunctionPointers(Sema &S, SourceLocation Loc,\n                                                    Expr *LHS, Expr *RHS) {\n  assert(LHS->getType()->isAnyPointerType());\n  assert(RHS->getType()->isAnyPointerType());\n  S.Diag(Loc, S.getLangOpts().CPlusPlus\n                ? diag::err_typecheck_pointer_arith_function_type\n                : diag::ext_gnu_ptr_func_arith)\n    << 1 /* two pointers */ << LHS->getType()->getPointeeType()\n    // We only show the second type if it differs from the first.\n    << (unsigned)!S.Context.hasSameUnqualifiedType(LHS->getType(),\n                                                   RHS->getType())\n    << RHS->getType()->getPointeeType()\n    << LHS->getSourceRange() << RHS->getSourceRange();\n}\n\n/// Diagnose invalid arithmetic on a function pointer.\nstatic void diagnoseArithmeticOnFunctionPointer(Sema &S, SourceLocation Loc,\n                                                Expr *Pointer) {\n  assert(Pointer->getType()->isAnyPointerType());\n  S.Diag(Loc, S.getLangOpts().CPlusPlus\n                ? diag::err_typecheck_pointer_arith_function_type\n                : diag::ext_gnu_ptr_func_arith)\n    << 0 /* one pointer */ << Pointer->getType()->getPointeeType()\n    << 0 /* one pointer, so only one type */\n    << Pointer->getSourceRange();\n}\n\n/// Emit error if Operand is incomplete pointer type\n///\n/// \\returns True if pointer has incomplete type\nstatic bool checkArithmeticIncompletePointerType(Sema &S, SourceLocation Loc,\n                                                 Expr *Operand) {\n  QualType ResType = Operand->getType();\n  if (const AtomicType *ResAtomicType = ResType->getAs<AtomicType>())\n    ResType = ResAtomicType->getValueType();\n\n  assert(ResType->isAnyPointerType() && !ResType->isDependentType());\n  QualType PointeeTy = ResType->getPointeeType();\n  return S.RequireCompleteSizedType(\n      Loc, PointeeTy,\n      diag::err_typecheck_arithmetic_incomplete_or_sizeless_type,\n      Operand->getSourceRange());\n}\n\n/// Check the validity of an arithmetic pointer operand.\n///\n/// If the operand has pointer type, this code will check for pointer types\n/// which are invalid in arithmetic operations. These will be diagnosed\n/// appropriately, including whether or not the use is supported as an\n/// extension.\n///\n/// \\returns True when the operand is valid to use (even if as an extension).\nstatic bool checkArithmeticOpPointerOperand(Sema &S, SourceLocation Loc,\n                                            Expr *Operand) {\n  QualType ResType = Operand->getType();\n  if (const AtomicType *ResAtomicType = ResType->getAs<AtomicType>())\n    ResType = ResAtomicType->getValueType();\n\n  if (!ResType->isAnyPointerType()) return true;\n\n  QualType PointeeTy = ResType->getPointeeType();\n  if (PointeeTy->isVoidType()) {\n    diagnoseArithmeticOnVoidPointer(S, Loc, Operand);\n    return !S.getLangOpts().CPlusPlus;\n  }\n  if (PointeeTy->isFunctionType()) {\n    diagnoseArithmeticOnFunctionPointer(S, Loc, Operand);\n    return !S.getLangOpts().CPlusPlus;\n  }\n\n  if (checkArithmeticIncompletePointerType(S, Loc, Operand)) return false;\n\n  return true;\n}\n\n/// Check the validity of a binary arithmetic operation w.r.t. pointer\n/// operands.\n///\n/// This routine will diagnose any invalid arithmetic on pointer operands much\n/// like \\see checkArithmeticOpPointerOperand. However, it has special logic\n/// for emitting a single diagnostic even for operations where both LHS and RHS\n/// are (potentially problematic) pointers.\n///\n/// \\returns True when the operand is valid to use (even if as an extension).\nstatic bool checkArithmeticBinOpPointerOperands(Sema &S, SourceLocation Loc,\n                                                Expr *LHSExpr, Expr *RHSExpr) {\n  bool isLHSPointer = LHSExpr->getType()->isAnyPointerType();\n  bool isRHSPointer = RHSExpr->getType()->isAnyPointerType();\n  if (!isLHSPointer && !isRHSPointer) return true;\n\n  QualType LHSPointeeTy, RHSPointeeTy;\n  if (isLHSPointer) LHSPointeeTy = LHSExpr->getType()->getPointeeType();\n  if (isRHSPointer) RHSPointeeTy = RHSExpr->getType()->getPointeeType();\n\n  // if both are pointers check if operation is valid wrt address spaces\n  if (isLHSPointer && isRHSPointer) {\n    if (!LHSPointeeTy.isAddressSpaceOverlapping(RHSPointeeTy)) {\n      S.Diag(Loc,\n             diag::err_typecheck_op_on_nonoverlapping_address_space_pointers)\n          << LHSExpr->getType() << RHSExpr->getType() << 1 /*arithmetic op*/\n          << LHSExpr->getSourceRange() << RHSExpr->getSourceRange();\n      return false;\n    }\n  }\n\n  // Check for arithmetic on pointers to incomplete types.\n  bool isLHSVoidPtr = isLHSPointer && LHSPointeeTy->isVoidType();\n  bool isRHSVoidPtr = isRHSPointer && RHSPointeeTy->isVoidType();\n  if (isLHSVoidPtr || isRHSVoidPtr) {\n    if (!isRHSVoidPtr) diagnoseArithmeticOnVoidPointer(S, Loc, LHSExpr);\n    else if (!isLHSVoidPtr) diagnoseArithmeticOnVoidPointer(S, Loc, RHSExpr);\n    else diagnoseArithmeticOnTwoVoidPointers(S, Loc, LHSExpr, RHSExpr);\n\n    return !S.getLangOpts().CPlusPlus;\n  }\n\n  bool isLHSFuncPtr = isLHSPointer && LHSPointeeTy->isFunctionType();\n  bool isRHSFuncPtr = isRHSPointer && RHSPointeeTy->isFunctionType();\n  if (isLHSFuncPtr || isRHSFuncPtr) {\n    if (!isRHSFuncPtr) diagnoseArithmeticOnFunctionPointer(S, Loc, LHSExpr);\n    else if (!isLHSFuncPtr) diagnoseArithmeticOnFunctionPointer(S, Loc,\n                                                                RHSExpr);\n    else diagnoseArithmeticOnTwoFunctionPointers(S, Loc, LHSExpr, RHSExpr);\n\n    return !S.getLangOpts().CPlusPlus;\n  }\n\n  if (isLHSPointer && checkArithmeticIncompletePointerType(S, Loc, LHSExpr))\n    return false;\n  if (isRHSPointer && checkArithmeticIncompletePointerType(S, Loc, RHSExpr))\n    return false;\n\n  return true;\n}\n\n/// diagnoseStringPlusInt - Emit a warning when adding an integer to a string\n/// literal.\nstatic void diagnoseStringPlusInt(Sema &Self, SourceLocation OpLoc,\n                                  Expr *LHSExpr, Expr *RHSExpr) {\n  StringLiteral* StrExpr = dyn_cast<StringLiteral>(LHSExpr->IgnoreImpCasts());\n  Expr* IndexExpr = RHSExpr;\n  if (!StrExpr) {\n    StrExpr = dyn_cast<StringLiteral>(RHSExpr->IgnoreImpCasts());\n    IndexExpr = LHSExpr;\n  }\n\n  bool IsStringPlusInt = StrExpr &&\n      IndexExpr->getType()->isIntegralOrUnscopedEnumerationType();\n  if (!IsStringPlusInt || IndexExpr->isValueDependent())\n    return;\n\n  SourceRange DiagRange(LHSExpr->getBeginLoc(), RHSExpr->getEndLoc());\n  Self.Diag(OpLoc, diag::warn_string_plus_int)\n      << DiagRange << IndexExpr->IgnoreImpCasts()->getType();\n\n  // Only print a fixit for \"str\" + int, not for int + \"str\".\n  if (IndexExpr == RHSExpr) {\n    SourceLocation EndLoc = Self.getLocForEndOfToken(RHSExpr->getEndLoc());\n    Self.Diag(OpLoc, diag::note_string_plus_scalar_silence)\n        << FixItHint::CreateInsertion(LHSExpr->getBeginLoc(), \"&\")\n        << FixItHint::CreateReplacement(SourceRange(OpLoc), \"[\")\n        << FixItHint::CreateInsertion(EndLoc, \"]\");\n  } else\n    Self.Diag(OpLoc, diag::note_string_plus_scalar_silence);\n}\n\n/// Emit a warning when adding a char literal to a string.\nstatic void diagnoseStringPlusChar(Sema &Self, SourceLocation OpLoc,\n                                   Expr *LHSExpr, Expr *RHSExpr) {\n  const Expr *StringRefExpr = LHSExpr;\n  const CharacterLiteral *CharExpr =\n      dyn_cast<CharacterLiteral>(RHSExpr->IgnoreImpCasts());\n\n  if (!CharExpr) {\n    CharExpr = dyn_cast<CharacterLiteral>(LHSExpr->IgnoreImpCasts());\n    StringRefExpr = RHSExpr;\n  }\n\n  if (!CharExpr || !StringRefExpr)\n    return;\n\n  const QualType StringType = StringRefExpr->getType();\n\n  // Return if not a PointerType.\n  if (!StringType->isAnyPointerType())\n    return;\n\n  // Return if not a CharacterType.\n  if (!StringType->getPointeeType()->isAnyCharacterType())\n    return;\n\n  ASTContext &Ctx = Self.getASTContext();\n  SourceRange DiagRange(LHSExpr->getBeginLoc(), RHSExpr->getEndLoc());\n\n  const QualType CharType = CharExpr->getType();\n  if (!CharType->isAnyCharacterType() &&\n      CharType->isIntegerType() &&\n      llvm::isUIntN(Ctx.getCharWidth(), CharExpr->getValue())) {\n    Self.Diag(OpLoc, diag::warn_string_plus_char)\n        << DiagRange << Ctx.CharTy;\n  } else {\n    Self.Diag(OpLoc, diag::warn_string_plus_char)\n        << DiagRange << CharExpr->getType();\n  }\n\n  // Only print a fixit for str + char, not for char + str.\n  if (isa<CharacterLiteral>(RHSExpr->IgnoreImpCasts())) {\n    SourceLocation EndLoc = Self.getLocForEndOfToken(RHSExpr->getEndLoc());\n    Self.Diag(OpLoc, diag::note_string_plus_scalar_silence)\n        << FixItHint::CreateInsertion(LHSExpr->getBeginLoc(), \"&\")\n        << FixItHint::CreateReplacement(SourceRange(OpLoc), \"[\")\n        << FixItHint::CreateInsertion(EndLoc, \"]\");\n  } else {\n    Self.Diag(OpLoc, diag::note_string_plus_scalar_silence);\n  }\n}\n\n/// Emit error when two pointers are incompatible.\nstatic void diagnosePointerIncompatibility(Sema &S, SourceLocation Loc,\n                                           Expr *LHSExpr, Expr *RHSExpr) {\n  assert(LHSExpr->getType()->isAnyPointerType());\n  assert(RHSExpr->getType()->isAnyPointerType());\n  S.Diag(Loc, diag::err_typecheck_sub_ptr_compatible)\n    << LHSExpr->getType() << RHSExpr->getType() << LHSExpr->getSourceRange()\n    << RHSExpr->getSourceRange();\n}\n\n// C99 6.5.6\nQualType Sema::CheckAdditionOperands(ExprResult &LHS, ExprResult &RHS,\n                                     SourceLocation Loc, BinaryOperatorKind Opc,\n                                     QualType* CompLHSTy) {\n  checkArithmeticNull(*this, LHS, RHS, Loc, /*IsCompare=*/false);\n\n  if (LHS.get()->getType()->isVectorType() ||\n      RHS.get()->getType()->isVectorType()) {\n    QualType compType = CheckVectorOperands(\n        LHS, RHS, Loc, CompLHSTy,\n        /*AllowBothBool*/getLangOpts().AltiVec,\n        /*AllowBoolConversions*/getLangOpts().ZVector);\n    if (CompLHSTy) *CompLHSTy = compType;\n    return compType;\n  }\n\n  if (LHS.get()->getType()->isConstantMatrixType() ||\n      RHS.get()->getType()->isConstantMatrixType()) {\n    QualType compType =\n        CheckMatrixElementwiseOperands(LHS, RHS, Loc, CompLHSTy);\n    if (CompLHSTy)\n      *CompLHSTy = compType;\n    return compType;\n  }\n\n  QualType compType = UsualArithmeticConversions(\n      LHS, RHS, Loc, CompLHSTy ? ACK_CompAssign : ACK_Arithmetic);\n  if (LHS.isInvalid() || RHS.isInvalid())\n    return QualType();\n\n  // Diagnose \"string literal\" '+' int and string '+' \"char literal\".\n  if (Opc == BO_Add) {\n    diagnoseStringPlusInt(*this, Loc, LHS.get(), RHS.get());\n    diagnoseStringPlusChar(*this, Loc, LHS.get(), RHS.get());\n  }\n\n  // handle the common case first (both operands are arithmetic).\n  if (!compType.isNull() && compType->isArithmeticType()) {\n    if (CompLHSTy) *CompLHSTy = compType;\n    return compType;\n  }\n\n  // Type-checking.  Ultimately the pointer's going to be in PExp;\n  // note that we bias towards the LHS being the pointer.\n  Expr *PExp = LHS.get(), *IExp = RHS.get();\n\n  bool isObjCPointer;\n  if (PExp->getType()->isPointerType()) {\n    isObjCPointer = false;\n  } else if (PExp->getType()->isObjCObjectPointerType()) {\n    isObjCPointer = true;\n  } else {\n    std::swap(PExp, IExp);\n    if (PExp->getType()->isPointerType()) {\n      isObjCPointer = false;\n    } else if (PExp->getType()->isObjCObjectPointerType()) {\n      isObjCPointer = true;\n    } else {\n      return InvalidOperands(Loc, LHS, RHS);\n    }\n  }\n  assert(PExp->getType()->isAnyPointerType());\n\n  if (!IExp->getType()->isIntegerType())\n    return InvalidOperands(Loc, LHS, RHS);\n\n  // Adding to a null pointer results in undefined behavior.\n  if (PExp->IgnoreParenCasts()->isNullPointerConstant(\n          Context, Expr::NPC_ValueDependentIsNotNull)) {\n    // In C++ adding zero to a null pointer is defined.\n    Expr::EvalResult KnownVal;\n    if (!getLangOpts().CPlusPlus ||\n        (!IExp->isValueDependent() &&\n         (!IExp->EvaluateAsInt(KnownVal, Context) ||\n          KnownVal.Val.getInt() != 0))) {\n      // Check the conditions to see if this is the 'p = nullptr + n' idiom.\n      bool IsGNUIdiom = BinaryOperator::isNullPointerArithmeticExtension(\n          Context, BO_Add, PExp, IExp);\n      diagnoseArithmeticOnNullPointer(*this, Loc, PExp, IsGNUIdiom);\n    }\n  }\n\n  if (!checkArithmeticOpPointerOperand(*this, Loc, PExp))\n    return QualType();\n\n  if (isObjCPointer && checkArithmeticOnObjCPointer(*this, Loc, PExp))\n    return QualType();\n\n  // Check array bounds for pointer arithemtic\n  CheckArrayAccess(PExp, IExp);\n\n  if (CompLHSTy) {\n    QualType LHSTy = Context.isPromotableBitField(LHS.get());\n    if (LHSTy.isNull()) {\n      LHSTy = LHS.get()->getType();\n      if (LHSTy->isPromotableIntegerType())\n        LHSTy = Context.getPromotedIntegerType(LHSTy);\n    }\n    *CompLHSTy = LHSTy;\n  }\n\n  return PExp->getType();\n}\n\n// C99 6.5.6\nQualType Sema::CheckSubtractionOperands(ExprResult &LHS, ExprResult &RHS,\n                                        SourceLocation Loc,\n                                        QualType* CompLHSTy) {\n  checkArithmeticNull(*this, LHS, RHS, Loc, /*IsCompare=*/false);\n\n  if (LHS.get()->getType()->isVectorType() ||\n      RHS.get()->getType()->isVectorType()) {\n    QualType compType = CheckVectorOperands(\n        LHS, RHS, Loc, CompLHSTy,\n        /*AllowBothBool*/getLangOpts().AltiVec,\n        /*AllowBoolConversions*/getLangOpts().ZVector);\n    if (CompLHSTy) *CompLHSTy = compType;\n    return compType;\n  }\n\n  if (LHS.get()->getType()->isConstantMatrixType() ||\n      RHS.get()->getType()->isConstantMatrixType()) {\n    QualType compType =\n        CheckMatrixElementwiseOperands(LHS, RHS, Loc, CompLHSTy);\n    if (CompLHSTy)\n      *CompLHSTy = compType;\n    return compType;\n  }\n\n  QualType compType = UsualArithmeticConversions(\n      LHS, RHS, Loc, CompLHSTy ? ACK_CompAssign : ACK_Arithmetic);\n  if (LHS.isInvalid() || RHS.isInvalid())\n    return QualType();\n\n  // Enforce type constraints: C99 6.5.6p3.\n\n  // Handle the common case first (both operands are arithmetic).\n  if (!compType.isNull() && compType->isArithmeticType()) {\n    if (CompLHSTy) *CompLHSTy = compType;\n    return compType;\n  }\n\n  // Either ptr - int   or   ptr - ptr.\n  if (LHS.get()->getType()->isAnyPointerType()) {\n    QualType lpointee = LHS.get()->getType()->getPointeeType();\n\n    // Diagnose bad cases where we step over interface counts.\n    if (LHS.get()->getType()->isObjCObjectPointerType() &&\n        checkArithmeticOnObjCPointer(*this, Loc, LHS.get()))\n      return QualType();\n\n    // The result type of a pointer-int computation is the pointer type.\n    if (RHS.get()->getType()->isIntegerType()) {\n      // Subtracting from a null pointer should produce a warning.\n      // The last argument to the diagnose call says this doesn't match the\n      // GNU int-to-pointer idiom.\n      if (LHS.get()->IgnoreParenCasts()->isNullPointerConstant(Context,\n                                           Expr::NPC_ValueDependentIsNotNull)) {\n        // In C++ adding zero to a null pointer is defined.\n        Expr::EvalResult KnownVal;\n        if (!getLangOpts().CPlusPlus ||\n            (!RHS.get()->isValueDependent() &&\n             (!RHS.get()->EvaluateAsInt(KnownVal, Context) ||\n              KnownVal.Val.getInt() != 0))) {\n          diagnoseArithmeticOnNullPointer(*this, Loc, LHS.get(), false);\n        }\n      }\n\n      if (!checkArithmeticOpPointerOperand(*this, Loc, LHS.get()))\n        return QualType();\n\n      // Check array bounds for pointer arithemtic\n      CheckArrayAccess(LHS.get(), RHS.get(), /*ArraySubscriptExpr*/nullptr,\n                       /*AllowOnePastEnd*/true, /*IndexNegated*/true);\n\n      if (CompLHSTy) *CompLHSTy = LHS.get()->getType();\n      return LHS.get()->getType();\n    }\n\n    // Handle pointer-pointer subtractions.\n    if (const PointerType *RHSPTy\n          = RHS.get()->getType()->getAs<PointerType>()) {\n      QualType rpointee = RHSPTy->getPointeeType();\n\n      if (getLangOpts().CPlusPlus) {\n        // Pointee types must be the same: C++ [expr.add]\n        if (!Context.hasSameUnqualifiedType(lpointee, rpointee)) {\n          diagnosePointerIncompatibility(*this, Loc, LHS.get(), RHS.get());\n        }\n      } else {\n        // Pointee types must be compatible C99 6.5.6p3\n        if (!Context.typesAreCompatible(\n                Context.getCanonicalType(lpointee).getUnqualifiedType(),\n                Context.getCanonicalType(rpointee).getUnqualifiedType())) {\n          diagnosePointerIncompatibility(*this, Loc, LHS.get(), RHS.get());\n          return QualType();\n        }\n      }\n\n      if (!checkArithmeticBinOpPointerOperands(*this, Loc,\n                                               LHS.get(), RHS.get()))\n        return QualType();\n\n      // FIXME: Add warnings for nullptr - ptr.\n\n      // The pointee type may have zero size.  As an extension, a structure or\n      // union may have zero size or an array may have zero length.  In this\n      // case subtraction does not make sense.\n      if (!rpointee->isVoidType() && !rpointee->isFunctionType()) {\n        CharUnits ElementSize = Context.getTypeSizeInChars(rpointee);\n        if (ElementSize.isZero()) {\n          Diag(Loc,diag::warn_sub_ptr_zero_size_types)\n            << rpointee.getUnqualifiedType()\n            << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n        }\n      }\n\n      if (CompLHSTy) *CompLHSTy = LHS.get()->getType();\n      return Context.getPointerDiffType();\n    }\n  }\n\n  return InvalidOperands(Loc, LHS, RHS);\n}\n\nstatic bool isScopedEnumerationType(QualType T) {\n  if (const EnumType *ET = T->getAs<EnumType>())\n    return ET->getDecl()->isScoped();\n  return false;\n}\n\nstatic void DiagnoseBadShiftValues(Sema& S, ExprResult &LHS, ExprResult &RHS,\n                                   SourceLocation Loc, BinaryOperatorKind Opc,\n                                   QualType LHSType) {\n  // OpenCL 6.3j: shift values are effectively % word size of LHS (more defined),\n  // so skip remaining warnings as we don't want to modify values within Sema.\n  if (S.getLangOpts().OpenCL)\n    return;\n\n  // Check right/shifter operand\n  Expr::EvalResult RHSResult;\n  if (RHS.get()->isValueDependent() ||\n      !RHS.get()->EvaluateAsInt(RHSResult, S.Context))\n    return;\n  llvm::APSInt Right = RHSResult.Val.getInt();\n\n  if (Right.isNegative()) {\n    S.DiagRuntimeBehavior(Loc, RHS.get(),\n                          S.PDiag(diag::warn_shift_negative)\n                            << RHS.get()->getSourceRange());\n    return;\n  }\n\n  QualType LHSExprType = LHS.get()->getType();\n  uint64_t LeftSize = S.Context.getTypeSize(LHSExprType);\n  if (LHSExprType->isExtIntType())\n    LeftSize = S.Context.getIntWidth(LHSExprType);\n  else if (LHSExprType->isFixedPointType()) {\n    auto FXSema = S.Context.getFixedPointSemantics(LHSExprType);\n    LeftSize = FXSema.getWidth() - (unsigned)FXSema.hasUnsignedPadding();\n  }\n  llvm::APInt LeftBits(Right.getBitWidth(), LeftSize);\n  if (Right.uge(LeftBits)) {\n    S.DiagRuntimeBehavior(Loc, RHS.get(),\n                          S.PDiag(diag::warn_shift_gt_typewidth)\n                            << RHS.get()->getSourceRange());\n    return;\n  }\n\n  // FIXME: We probably need to handle fixed point types specially here.\n  if (Opc != BO_Shl || LHSExprType->isFixedPointType())\n    return;\n\n  // When left shifting an ICE which is signed, we can check for overflow which\n  // according to C++ standards prior to C++2a has undefined behavior\n  // ([expr.shift] 5.8/2). Unsigned integers have defined behavior modulo one\n  // more than the maximum value representable in the result type, so never\n  // warn for those. (FIXME: Unsigned left-shift overflow in a constant\n  // expression is still probably a bug.)\n  Expr::EvalResult LHSResult;\n  if (LHS.get()->isValueDependent() ||\n      LHSType->hasUnsignedIntegerRepresentation() ||\n      !LHS.get()->EvaluateAsInt(LHSResult, S.Context))\n    return;\n  llvm::APSInt Left = LHSResult.Val.getInt();\n\n  // If LHS does not have a signed type and non-negative value\n  // then, the behavior is undefined before C++2a. Warn about it.\n  if (Left.isNegative() && !S.getLangOpts().isSignedOverflowDefined() &&\n      !S.getLangOpts().CPlusPlus20) {\n    S.DiagRuntimeBehavior(Loc, LHS.get(),\n                          S.PDiag(diag::warn_shift_lhs_negative)\n                            << LHS.get()->getSourceRange());\n    return;\n  }\n\n  llvm::APInt ResultBits =\n      static_cast<llvm::APInt&>(Right) + Left.getMinSignedBits();\n  if (LeftBits.uge(ResultBits))\n    return;\n  llvm::APSInt Result = Left.extend(ResultBits.getLimitedValue());\n  Result = Result.shl(Right);\n\n  // Print the bit representation of the signed integer as an unsigned\n  // hexadecimal number.\n  SmallString<40> HexResult;\n  Result.toString(HexResult, 16, /*Signed =*/false, /*Literal =*/true);\n\n  // If we are only missing a sign bit, this is less likely to result in actual\n  // bugs -- if the result is cast back to an unsigned type, it will have the\n  // expected value. Thus we place this behind a different warning that can be\n  // turned off separately if needed.\n  if (LeftBits == ResultBits - 1) {\n    S.Diag(Loc, diag::warn_shift_result_sets_sign_bit)\n        << HexResult << LHSType\n        << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n    return;\n  }\n\n  S.Diag(Loc, diag::warn_shift_result_gt_typewidth)\n    << HexResult.str() << Result.getMinSignedBits() << LHSType\n    << Left.getBitWidth() << LHS.get()->getSourceRange()\n    << RHS.get()->getSourceRange();\n}\n\n/// Return the resulting type when a vector is shifted\n///        by a scalar or vector shift amount.\nstatic QualType checkVectorShift(Sema &S, ExprResult &LHS, ExprResult &RHS,\n                                 SourceLocation Loc, bool IsCompAssign) {\n  // OpenCL v1.1 s6.3.j says RHS can be a vector only if LHS is a vector.\n  if ((S.LangOpts.OpenCL || S.LangOpts.ZVector) &&\n      !LHS.get()->getType()->isVectorType()) {\n    S.Diag(Loc, diag::err_shift_rhs_only_vector)\n      << RHS.get()->getType() << LHS.get()->getType()\n      << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n    return QualType();\n  }\n\n  if (!IsCompAssign) {\n    LHS = S.UsualUnaryConversions(LHS.get());\n    if (LHS.isInvalid()) return QualType();\n  }\n\n  RHS = S.UsualUnaryConversions(RHS.get());\n  if (RHS.isInvalid()) return QualType();\n\n  QualType LHSType = LHS.get()->getType();\n  // Note that LHS might be a scalar because the routine calls not only in\n  // OpenCL case.\n  const VectorType *LHSVecTy = LHSType->getAs<VectorType>();\n  QualType LHSEleType = LHSVecTy ? LHSVecTy->getElementType() : LHSType;\n\n  // Note that RHS might not be a vector.\n  QualType RHSType = RHS.get()->getType();\n  const VectorType *RHSVecTy = RHSType->getAs<VectorType>();\n  QualType RHSEleType = RHSVecTy ? RHSVecTy->getElementType() : RHSType;\n\n  // The operands need to be integers.\n  if (!LHSEleType->isIntegerType()) {\n    S.Diag(Loc, diag::err_typecheck_expect_int)\n      << LHS.get()->getType() << LHS.get()->getSourceRange();\n    return QualType();\n  }\n\n  if (!RHSEleType->isIntegerType()) {\n    S.Diag(Loc, diag::err_typecheck_expect_int)\n      << RHS.get()->getType() << RHS.get()->getSourceRange();\n    return QualType();\n  }\n\n  if (!LHSVecTy) {\n    assert(RHSVecTy);\n    if (IsCompAssign)\n      return RHSType;\n    if (LHSEleType != RHSEleType) {\n      LHS = S.ImpCastExprToType(LHS.get(),RHSEleType, CK_IntegralCast);\n      LHSEleType = RHSEleType;\n    }\n    QualType VecTy =\n        S.Context.getExtVectorType(LHSEleType, RHSVecTy->getNumElements());\n    LHS = S.ImpCastExprToType(LHS.get(), VecTy, CK_VectorSplat);\n    LHSType = VecTy;\n  } else if (RHSVecTy) {\n    // OpenCL v1.1 s6.3.j says that for vector types, the operators\n    // are applied component-wise. So if RHS is a vector, then ensure\n    // that the number of elements is the same as LHS...\n    if (RHSVecTy->getNumElements() != LHSVecTy->getNumElements()) {\n      S.Diag(Loc, diag::err_typecheck_vector_lengths_not_equal)\n        << LHS.get()->getType() << RHS.get()->getType()\n        << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n      return QualType();\n    }\n    if (!S.LangOpts.OpenCL && !S.LangOpts.ZVector) {\n      const BuiltinType *LHSBT = LHSEleType->getAs<clang::BuiltinType>();\n      const BuiltinType *RHSBT = RHSEleType->getAs<clang::BuiltinType>();\n      if (LHSBT != RHSBT &&\n          S.Context.getTypeSize(LHSBT) != S.Context.getTypeSize(RHSBT)) {\n        S.Diag(Loc, diag::warn_typecheck_vector_element_sizes_not_equal)\n            << LHS.get()->getType() << RHS.get()->getType()\n            << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n      }\n    }\n  } else {\n    // ...else expand RHS to match the number of elements in LHS.\n    QualType VecTy =\n      S.Context.getExtVectorType(RHSEleType, LHSVecTy->getNumElements());\n    RHS = S.ImpCastExprToType(RHS.get(), VecTy, CK_VectorSplat);\n  }\n\n  return LHSType;\n}\n\n// C99 6.5.7\nQualType Sema::CheckShiftOperands(ExprResult &LHS, ExprResult &RHS,\n                                  SourceLocation Loc, BinaryOperatorKind Opc,\n                                  bool IsCompAssign) {\n  checkArithmeticNull(*this, LHS, RHS, Loc, /*IsCompare=*/false);\n\n  // Vector shifts promote their scalar inputs to vector type.\n  if (LHS.get()->getType()->isVectorType() ||\n      RHS.get()->getType()->isVectorType()) {\n    if (LangOpts.ZVector) {\n      // The shift operators for the z vector extensions work basically\n      // like general shifts, except that neither the LHS nor the RHS is\n      // allowed to be a \"vector bool\".\n      if (auto LHSVecType = LHS.get()->getType()->getAs<VectorType>())\n        if (LHSVecType->getVectorKind() == VectorType::AltiVecBool)\n          return InvalidOperands(Loc, LHS, RHS);\n      if (auto RHSVecType = RHS.get()->getType()->getAs<VectorType>())\n        if (RHSVecType->getVectorKind() == VectorType::AltiVecBool)\n          return InvalidOperands(Loc, LHS, RHS);\n    }\n    return checkVectorShift(*this, LHS, RHS, Loc, IsCompAssign);\n  }\n\n  // Shifts don't perform usual arithmetic conversions, they just do integer\n  // promotions on each operand. C99 6.5.7p3\n\n  // For the LHS, do usual unary conversions, but then reset them away\n  // if this is a compound assignment.\n  ExprResult OldLHS = LHS;\n  LHS = UsualUnaryConversions(LHS.get());\n  if (LHS.isInvalid())\n    return QualType();\n  QualType LHSType = LHS.get()->getType();\n  if (IsCompAssign) LHS = OldLHS;\n\n  // The RHS is simpler.\n  RHS = UsualUnaryConversions(RHS.get());\n  if (RHS.isInvalid())\n    return QualType();\n  QualType RHSType = RHS.get()->getType();\n\n  // C99 6.5.7p2: Each of the operands shall have integer type.\n  // Embedded-C 4.1.6.2.2: The LHS may also be fixed-point.\n  if ((!LHSType->isFixedPointOrIntegerType() &&\n       !LHSType->hasIntegerRepresentation()) ||\n      !RHSType->hasIntegerRepresentation())\n    return InvalidOperands(Loc, LHS, RHS);\n\n  // C++0x: Don't allow scoped enums. FIXME: Use something better than\n  // hasIntegerRepresentation() above instead of this.\n  if (isScopedEnumerationType(LHSType) ||\n      isScopedEnumerationType(RHSType)) {\n    return InvalidOperands(Loc, LHS, RHS);\n  }\n  // Sanity-check shift operands\n  DiagnoseBadShiftValues(*this, LHS, RHS, Loc, Opc, LHSType);\n\n  // \"The type of the result is that of the promoted left operand.\"\n  return LHSType;\n}\n\n/// Diagnose bad pointer comparisons.\nstatic void diagnoseDistinctPointerComparison(Sema &S, SourceLocation Loc,\n                                              ExprResult &LHS, ExprResult &RHS,\n                                              bool IsError) {\n  S.Diag(Loc, IsError ? diag::err_typecheck_comparison_of_distinct_pointers\n                      : diag::ext_typecheck_comparison_of_distinct_pointers)\n    << LHS.get()->getType() << RHS.get()->getType()\n    << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n}\n\n/// Returns false if the pointers are converted to a composite type,\n/// true otherwise.\nstatic bool convertPointersToCompositeType(Sema &S, SourceLocation Loc,\n                                           ExprResult &LHS, ExprResult &RHS) {\n  // C++ [expr.rel]p2:\n  //   [...] Pointer conversions (4.10) and qualification\n  //   conversions (4.4) are performed on pointer operands (or on\n  //   a pointer operand and a null pointer constant) to bring\n  //   them to their composite pointer type. [...]\n  //\n  // C++ [expr.eq]p1 uses the same notion for (in)equality\n  // comparisons of pointers.\n\n  QualType LHSType = LHS.get()->getType();\n  QualType RHSType = RHS.get()->getType();\n  assert(LHSType->isPointerType() || RHSType->isPointerType() ||\n         LHSType->isMemberPointerType() || RHSType->isMemberPointerType());\n\n  QualType T = S.FindCompositePointerType(Loc, LHS, RHS);\n  if (T.isNull()) {\n    if ((LHSType->isAnyPointerType() || LHSType->isMemberPointerType()) &&\n        (RHSType->isAnyPointerType() || RHSType->isMemberPointerType()))\n      diagnoseDistinctPointerComparison(S, Loc, LHS, RHS, /*isError*/true);\n    else\n      S.InvalidOperands(Loc, LHS, RHS);\n    return true;\n  }\n\n  return false;\n}\n\nstatic void diagnoseFunctionPointerToVoidComparison(Sema &S, SourceLocation Loc,\n                                                    ExprResult &LHS,\n                                                    ExprResult &RHS,\n                                                    bool IsError) {\n  S.Diag(Loc, IsError ? diag::err_typecheck_comparison_of_fptr_to_void\n                      : diag::ext_typecheck_comparison_of_fptr_to_void)\n    << LHS.get()->getType() << RHS.get()->getType()\n    << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n}\n\nstatic bool isObjCObjectLiteral(ExprResult &E) {\n  switch (E.get()->IgnoreParenImpCasts()->getStmtClass()) {\n  case Stmt::ObjCArrayLiteralClass:\n  case Stmt::ObjCDictionaryLiteralClass:\n  case Stmt::ObjCStringLiteralClass:\n  case Stmt::ObjCBoxedExprClass:\n    return true;\n  default:\n    // Note that ObjCBoolLiteral is NOT an object literal!\n    return false;\n  }\n}\n\nstatic bool hasIsEqualMethod(Sema &S, const Expr *LHS, const Expr *RHS) {\n  const ObjCObjectPointerType *Type =\n    LHS->getType()->getAs<ObjCObjectPointerType>();\n\n  // If this is not actually an Objective-C object, bail out.\n  if (!Type)\n    return false;\n\n  // Get the LHS object's interface type.\n  QualType InterfaceType = Type->getPointeeType();\n\n  // If the RHS isn't an Objective-C object, bail out.\n  if (!RHS->getType()->isObjCObjectPointerType())\n    return false;\n\n  // Try to find the -isEqual: method.\n  Selector IsEqualSel = S.NSAPIObj->getIsEqualSelector();\n  ObjCMethodDecl *Method = S.LookupMethodInObjectType(IsEqualSel,\n                                                      InterfaceType,\n                                                      /*IsInstance=*/true);\n  if (!Method) {\n    if (Type->isObjCIdType()) {\n      // For 'id', just check the global pool.\n      Method = S.LookupInstanceMethodInGlobalPool(IsEqualSel, SourceRange(),\n                                                  /*receiverId=*/true);\n    } else {\n      // Check protocols.\n      Method = S.LookupMethodInQualifiedType(IsEqualSel, Type,\n                                             /*IsInstance=*/true);\n    }\n  }\n\n  if (!Method)\n    return false;\n\n  QualType T = Method->parameters()[0]->getType();\n  if (!T->isObjCObjectPointerType())\n    return false;\n\n  QualType R = Method->getReturnType();\n  if (!R->isScalarType())\n    return false;\n\n  return true;\n}\n\nSema::ObjCLiteralKind Sema::CheckLiteralKind(Expr *FromE) {\n  FromE = FromE->IgnoreParenImpCasts();\n  switch (FromE->getStmtClass()) {\n    default:\n      break;\n    case Stmt::ObjCStringLiteralClass:\n      // \"string literal\"\n      return LK_String;\n    case Stmt::ObjCArrayLiteralClass:\n      // \"array literal\"\n      return LK_Array;\n    case Stmt::ObjCDictionaryLiteralClass:\n      // \"dictionary literal\"\n      return LK_Dictionary;\n    case Stmt::BlockExprClass:\n      return LK_Block;\n    case Stmt::ObjCBoxedExprClass: {\n      Expr *Inner = cast<ObjCBoxedExpr>(FromE)->getSubExpr()->IgnoreParens();\n      switch (Inner->getStmtClass()) {\n        case Stmt::IntegerLiteralClass:\n        case Stmt::FloatingLiteralClass:\n        case Stmt::CharacterLiteralClass:\n        case Stmt::ObjCBoolLiteralExprClass:\n        case Stmt::CXXBoolLiteralExprClass:\n          // \"numeric literal\"\n          return LK_Numeric;\n        case Stmt::ImplicitCastExprClass: {\n          CastKind CK = cast<CastExpr>(Inner)->getCastKind();\n          // Boolean literals can be represented by implicit casts.\n          if (CK == CK_IntegralToBoolean || CK == CK_IntegralCast)\n            return LK_Numeric;\n          break;\n        }\n        default:\n          break;\n      }\n      return LK_Boxed;\n    }\n  }\n  return LK_None;\n}\n\nstatic void diagnoseObjCLiteralComparison(Sema &S, SourceLocation Loc,\n                                          ExprResult &LHS, ExprResult &RHS,\n                                          BinaryOperator::Opcode Opc){\n  Expr *Literal;\n  Expr *Other;\n  if (isObjCObjectLiteral(LHS)) {\n    Literal = LHS.get();\n    Other = RHS.get();\n  } else {\n    Literal = RHS.get();\n    Other = LHS.get();\n  }\n\n  // Don't warn on comparisons against nil.\n  Other = Other->IgnoreParenCasts();\n  if (Other->isNullPointerConstant(S.getASTContext(),\n                                   Expr::NPC_ValueDependentIsNotNull))\n    return;\n\n  // This should be kept in sync with warn_objc_literal_comparison.\n  // LK_String should always be after the other literals, since it has its own\n  // warning flag.\n  Sema::ObjCLiteralKind LiteralKind = S.CheckLiteralKind(Literal);\n  assert(LiteralKind != Sema::LK_Block);\n  if (LiteralKind == Sema::LK_None) {\n    llvm_unreachable(\"Unknown Objective-C object literal kind\");\n  }\n\n  if (LiteralKind == Sema::LK_String)\n    S.Diag(Loc, diag::warn_objc_string_literal_comparison)\n      << Literal->getSourceRange();\n  else\n    S.Diag(Loc, diag::warn_objc_literal_comparison)\n      << LiteralKind << Literal->getSourceRange();\n\n  if (BinaryOperator::isEqualityOp(Opc) &&\n      hasIsEqualMethod(S, LHS.get(), RHS.get())) {\n    SourceLocation Start = LHS.get()->getBeginLoc();\n    SourceLocation End = S.getLocForEndOfToken(RHS.get()->getEndLoc());\n    CharSourceRange OpRange =\n      CharSourceRange::getCharRange(Loc, S.getLocForEndOfToken(Loc));\n\n    S.Diag(Loc, diag::note_objc_literal_comparison_isequal)\n      << FixItHint::CreateInsertion(Start, Opc == BO_EQ ? \"[\" : \"![\")\n      << FixItHint::CreateReplacement(OpRange, \" isEqual:\")\n      << FixItHint::CreateInsertion(End, \"]\");\n  }\n}\n\n/// Warns on !x < y, !x & y where !(x < y), !(x & y) was probably intended.\nstatic void diagnoseLogicalNotOnLHSofCheck(Sema &S, ExprResult &LHS,\n                                           ExprResult &RHS, SourceLocation Loc,\n                                           BinaryOperatorKind Opc) {\n  // Check that left hand side is !something.\n  UnaryOperator *UO = dyn_cast<UnaryOperator>(LHS.get()->IgnoreImpCasts());\n  if (!UO || UO->getOpcode() != UO_LNot) return;\n\n  // Only check if the right hand side is non-bool arithmetic type.\n  if (RHS.get()->isKnownToHaveBooleanValue()) return;\n\n  // Make sure that the something in !something is not bool.\n  Expr *SubExpr = UO->getSubExpr()->IgnoreImpCasts();\n  if (SubExpr->isKnownToHaveBooleanValue()) return;\n\n  // Emit warning.\n  bool IsBitwiseOp = Opc == BO_And || Opc == BO_Or || Opc == BO_Xor;\n  S.Diag(UO->getOperatorLoc(), diag::warn_logical_not_on_lhs_of_check)\n      << Loc << IsBitwiseOp;\n\n  // First note suggest !(x < y)\n  SourceLocation FirstOpen = SubExpr->getBeginLoc();\n  SourceLocation FirstClose = RHS.get()->getEndLoc();\n  FirstClose = S.getLocForEndOfToken(FirstClose);\n  if (FirstClose.isInvalid())\n    FirstOpen = SourceLocation();\n  S.Diag(UO->getOperatorLoc(), diag::note_logical_not_fix)\n      << IsBitwiseOp\n      << FixItHint::CreateInsertion(FirstOpen, \"(\")\n      << FixItHint::CreateInsertion(FirstClose, \")\");\n\n  // Second note suggests (!x) < y\n  SourceLocation SecondOpen = LHS.get()->getBeginLoc();\n  SourceLocation SecondClose = LHS.get()->getEndLoc();\n  SecondClose = S.getLocForEndOfToken(SecondClose);\n  if (SecondClose.isInvalid())\n    SecondOpen = SourceLocation();\n  S.Diag(UO->getOperatorLoc(), diag::note_logical_not_silence_with_parens)\n      << FixItHint::CreateInsertion(SecondOpen, \"(\")\n      << FixItHint::CreateInsertion(SecondClose, \")\");\n}\n\n// Returns true if E refers to a non-weak array.\nstatic bool checkForArray(const Expr *E) {\n  const ValueDecl *D = nullptr;\n  if (const DeclRefExpr *DR = dyn_cast<DeclRefExpr>(E)) {\n    D = DR->getDecl();\n  } else if (const MemberExpr *Mem = dyn_cast<MemberExpr>(E)) {\n    if (Mem->isImplicitAccess())\n      D = Mem->getMemberDecl();\n  }\n  if (!D)\n    return false;\n  return D->getType()->isArrayType() && !D->isWeak();\n}\n\n/// Diagnose some forms of syntactically-obvious tautological comparison.\nstatic void diagnoseTautologicalComparison(Sema &S, SourceLocation Loc,\n                                           Expr *LHS, Expr *RHS,\n                                           BinaryOperatorKind Opc) {\n  Expr *LHSStripped = LHS->IgnoreParenImpCasts();\n  Expr *RHSStripped = RHS->IgnoreParenImpCasts();\n\n  QualType LHSType = LHS->getType();\n  QualType RHSType = RHS->getType();\n  if (LHSType->hasFloatingRepresentation() ||\n      (LHSType->isBlockPointerType() && !BinaryOperator::isEqualityOp(Opc)) ||\n      S.inTemplateInstantiation())\n    return;\n\n  // Comparisons between two array types are ill-formed for operator<=>, so\n  // we shouldn't emit any additional warnings about it.\n  if (Opc == BO_Cmp && LHSType->isArrayType() && RHSType->isArrayType())\n    return;\n\n  // For non-floating point types, check for self-comparisons of the form\n  // x == x, x != x, x < x, etc.  These always evaluate to a constant, and\n  // often indicate logic errors in the program.\n  //\n  // NOTE: Don't warn about comparison expressions resulting from macro\n  // expansion. Also don't warn about comparisons which are only self\n  // comparisons within a template instantiation. The warnings should catch\n  // obvious cases in the definition of the template anyways. The idea is to\n  // warn when the typed comparison operator will always evaluate to the same\n  // result.\n\n  // Used for indexing into %select in warn_comparison_always\n  enum {\n    AlwaysConstant,\n    AlwaysTrue,\n    AlwaysFalse,\n    AlwaysEqual, // std::strong_ordering::equal from operator<=>\n  };\n\n  // C++2a [depr.array.comp]:\n  //   Equality and relational comparisons ([expr.eq], [expr.rel]) between two\n  //   operands of array type are deprecated.\n  if (S.getLangOpts().CPlusPlus20 && LHSStripped->getType()->isArrayType() &&\n      RHSStripped->getType()->isArrayType()) {\n    S.Diag(Loc, diag::warn_depr_array_comparison)\n        << LHS->getSourceRange() << RHS->getSourceRange()\n        << LHSStripped->getType() << RHSStripped->getType();\n    // Carry on to produce the tautological comparison warning, if this\n    // expression is potentially-evaluated, we can resolve the array to a\n    // non-weak declaration, and so on.\n  }\n\n  if (!LHS->getBeginLoc().isMacroID() && !RHS->getBeginLoc().isMacroID()) {\n    if (Expr::isSameComparisonOperand(LHS, RHS)) {\n      unsigned Result;\n      switch (Opc) {\n      case BO_EQ:\n      case BO_LE:\n      case BO_GE:\n        Result = AlwaysTrue;\n        break;\n      case BO_NE:\n      case BO_LT:\n      case BO_GT:\n        Result = AlwaysFalse;\n        break;\n      case BO_Cmp:\n        Result = AlwaysEqual;\n        break;\n      default:\n        Result = AlwaysConstant;\n        break;\n      }\n      S.DiagRuntimeBehavior(Loc, nullptr,\n                            S.PDiag(diag::warn_comparison_always)\n                                << 0 /*self-comparison*/\n                                << Result);\n    } else if (checkForArray(LHSStripped) && checkForArray(RHSStripped)) {\n      // What is it always going to evaluate to?\n      unsigned Result;\n      switch (Opc) {\n      case BO_EQ: // e.g. array1 == array2\n        Result = AlwaysFalse;\n        break;\n      case BO_NE: // e.g. array1 != array2\n        Result = AlwaysTrue;\n        break;\n      default: // e.g. array1 <= array2\n        // The best we can say is 'a constant'\n        Result = AlwaysConstant;\n        break;\n      }\n      S.DiagRuntimeBehavior(Loc, nullptr,\n                            S.PDiag(diag::warn_comparison_always)\n                                << 1 /*array comparison*/\n                                << Result);\n    }\n  }\n\n  if (isa<CastExpr>(LHSStripped))\n    LHSStripped = LHSStripped->IgnoreParenCasts();\n  if (isa<CastExpr>(RHSStripped))\n    RHSStripped = RHSStripped->IgnoreParenCasts();\n\n  // Warn about comparisons against a string constant (unless the other\n  // operand is null); the user probably wants string comparison function.\n  Expr *LiteralString = nullptr;\n  Expr *LiteralStringStripped = nullptr;\n  if ((isa<StringLiteral>(LHSStripped) || isa<ObjCEncodeExpr>(LHSStripped)) &&\n      !RHSStripped->isNullPointerConstant(S.Context,\n                                          Expr::NPC_ValueDependentIsNull)) {\n    LiteralString = LHS;\n    LiteralStringStripped = LHSStripped;\n  } else if ((isa<StringLiteral>(RHSStripped) ||\n              isa<ObjCEncodeExpr>(RHSStripped)) &&\n             !LHSStripped->isNullPointerConstant(S.Context,\n                                          Expr::NPC_ValueDependentIsNull)) {\n    LiteralString = RHS;\n    LiteralStringStripped = RHSStripped;\n  }\n\n  if (LiteralString) {\n    S.DiagRuntimeBehavior(Loc, nullptr,\n                          S.PDiag(diag::warn_stringcompare)\n                              << isa<ObjCEncodeExpr>(LiteralStringStripped)\n                              << LiteralString->getSourceRange());\n  }\n}\n\nstatic ImplicitConversionKind castKindToImplicitConversionKind(CastKind CK) {\n  switch (CK) {\n  default: {\n#ifndef NDEBUG\n    llvm::errs() << \"unhandled cast kind: \" << CastExpr::getCastKindName(CK)\n                 << \"\\n\";\n#endif\n    llvm_unreachable(\"unhandled cast kind\");\n  }\n  case CK_UserDefinedConversion:\n    return ICK_Identity;\n  case CK_LValueToRValue:\n    return ICK_Lvalue_To_Rvalue;\n  case CK_ArrayToPointerDecay:\n    return ICK_Array_To_Pointer;\n  case CK_FunctionToPointerDecay:\n    return ICK_Function_To_Pointer;\n  case CK_IntegralCast:\n    return ICK_Integral_Conversion;\n  case CK_FloatingCast:\n    return ICK_Floating_Conversion;\n  case CK_IntegralToFloating:\n  case CK_FloatingToIntegral:\n    return ICK_Floating_Integral;\n  case CK_IntegralComplexCast:\n  case CK_FloatingComplexCast:\n  case CK_FloatingComplexToIntegralComplex:\n  case CK_IntegralComplexToFloatingComplex:\n    return ICK_Complex_Conversion;\n  case CK_FloatingComplexToReal:\n  case CK_FloatingRealToComplex:\n  case CK_IntegralComplexToReal:\n  case CK_IntegralRealToComplex:\n    return ICK_Complex_Real;\n  }\n}\n\nstatic bool checkThreeWayNarrowingConversion(Sema &S, QualType ToType, Expr *E,\n                                             QualType FromType,\n                                             SourceLocation Loc) {\n  // Check for a narrowing implicit conversion.\n  StandardConversionSequence SCS;\n  SCS.setAsIdentityConversion();\n  SCS.setToType(0, FromType);\n  SCS.setToType(1, ToType);\n  if (const auto *ICE = dyn_cast<ImplicitCastExpr>(E))\n    SCS.Second = castKindToImplicitConversionKind(ICE->getCastKind());\n\n  APValue PreNarrowingValue;\n  QualType PreNarrowingType;\n  switch (SCS.getNarrowingKind(S.Context, E, PreNarrowingValue,\n                               PreNarrowingType,\n                               /*IgnoreFloatToIntegralConversion*/ true)) {\n  case NK_Dependent_Narrowing:\n    // Implicit conversion to a narrower type, but the expression is\n    // value-dependent so we can't tell whether it's actually narrowing.\n  case NK_Not_Narrowing:\n    return false;\n\n  case NK_Constant_Narrowing:\n    // Implicit conversion to a narrower type, and the value is not a constant\n    // expression.\n    S.Diag(E->getBeginLoc(), diag::err_spaceship_argument_narrowing)\n        << /*Constant*/ 1\n        << PreNarrowingValue.getAsString(S.Context, PreNarrowingType) << ToType;\n    return true;\n\n  case NK_Variable_Narrowing:\n    // Implicit conversion to a narrower type, and the value is not a constant\n    // expression.\n  case NK_Type_Narrowing:\n    S.Diag(E->getBeginLoc(), diag::err_spaceship_argument_narrowing)\n        << /*Constant*/ 0 << FromType << ToType;\n    // TODO: It's not a constant expression, but what if the user intended it\n    // to be? Can we produce notes to help them figure out why it isn't?\n    return true;\n  }\n  llvm_unreachable(\"unhandled case in switch\");\n}\n\nstatic QualType checkArithmeticOrEnumeralThreeWayCompare(Sema &S,\n                                                         ExprResult &LHS,\n                                                         ExprResult &RHS,\n                                                         SourceLocation Loc) {\n  QualType LHSType = LHS.get()->getType();\n  QualType RHSType = RHS.get()->getType();\n  // Dig out the original argument type and expression before implicit casts\n  // were applied. These are the types/expressions we need to check the\n  // [expr.spaceship] requirements against.\n  ExprResult LHSStripped = LHS.get()->IgnoreParenImpCasts();\n  ExprResult RHSStripped = RHS.get()->IgnoreParenImpCasts();\n  QualType LHSStrippedType = LHSStripped.get()->getType();\n  QualType RHSStrippedType = RHSStripped.get()->getType();\n\n  // C++2a [expr.spaceship]p3: If one of the operands is of type bool and the\n  // other is not, the program is ill-formed.\n  if (LHSStrippedType->isBooleanType() != RHSStrippedType->isBooleanType()) {\n    S.InvalidOperands(Loc, LHSStripped, RHSStripped);\n    return QualType();\n  }\n\n  // FIXME: Consider combining this with checkEnumArithmeticConversions.\n  int NumEnumArgs = (int)LHSStrippedType->isEnumeralType() +\n                    RHSStrippedType->isEnumeralType();\n  if (NumEnumArgs == 1) {\n    bool LHSIsEnum = LHSStrippedType->isEnumeralType();\n    QualType OtherTy = LHSIsEnum ? RHSStrippedType : LHSStrippedType;\n    if (OtherTy->hasFloatingRepresentation()) {\n      S.InvalidOperands(Loc, LHSStripped, RHSStripped);\n      return QualType();\n    }\n  }\n  if (NumEnumArgs == 2) {\n    // C++2a [expr.spaceship]p5: If both operands have the same enumeration\n    // type E, the operator yields the result of converting the operands\n    // to the underlying type of E and applying <=> to the converted operands.\n    if (!S.Context.hasSameUnqualifiedType(LHSStrippedType, RHSStrippedType)) {\n      S.InvalidOperands(Loc, LHS, RHS);\n      return QualType();\n    }\n    QualType IntType =\n        LHSStrippedType->castAs<EnumType>()->getDecl()->getIntegerType();\n    assert(IntType->isArithmeticType());\n\n    // We can't use `CK_IntegralCast` when the underlying type is 'bool', so we\n    // promote the boolean type, and all other promotable integer types, to\n    // avoid this.\n    if (IntType->isPromotableIntegerType())\n      IntType = S.Context.getPromotedIntegerType(IntType);\n\n    LHS = S.ImpCastExprToType(LHS.get(), IntType, CK_IntegralCast);\n    RHS = S.ImpCastExprToType(RHS.get(), IntType, CK_IntegralCast);\n    LHSType = RHSType = IntType;\n  }\n\n  // C++2a [expr.spaceship]p4: If both operands have arithmetic types, the\n  // usual arithmetic conversions are applied to the operands.\n  QualType Type =\n      S.UsualArithmeticConversions(LHS, RHS, Loc, Sema::ACK_Comparison);\n  if (LHS.isInvalid() || RHS.isInvalid())\n    return QualType();\n  if (Type.isNull())\n    return S.InvalidOperands(Loc, LHS, RHS);\n\n  Optional<ComparisonCategoryType> CCT =\n      getComparisonCategoryForBuiltinCmp(Type);\n  if (!CCT)\n    return S.InvalidOperands(Loc, LHS, RHS);\n\n  bool HasNarrowing = checkThreeWayNarrowingConversion(\n      S, Type, LHS.get(), LHSType, LHS.get()->getBeginLoc());\n  HasNarrowing |= checkThreeWayNarrowingConversion(S, Type, RHS.get(), RHSType,\n                                                   RHS.get()->getBeginLoc());\n  if (HasNarrowing)\n    return QualType();\n\n  assert(!Type.isNull() && \"composite type for <=> has not been set\");\n\n  return S.CheckComparisonCategoryType(\n      *CCT, Loc, Sema::ComparisonCategoryUsage::OperatorInExpression);\n}\n\nstatic QualType checkArithmeticOrEnumeralCompare(Sema &S, ExprResult &LHS,\n                                                 ExprResult &RHS,\n                                                 SourceLocation Loc,\n                                                 BinaryOperatorKind Opc) {\n  if (Opc == BO_Cmp)\n    return checkArithmeticOrEnumeralThreeWayCompare(S, LHS, RHS, Loc);\n\n  // C99 6.5.8p3 / C99 6.5.9p4\n  QualType Type =\n      S.UsualArithmeticConversions(LHS, RHS, Loc, Sema::ACK_Comparison);\n  if (LHS.isInvalid() || RHS.isInvalid())\n    return QualType();\n  if (Type.isNull())\n    return S.InvalidOperands(Loc, LHS, RHS);\n  assert(Type->isArithmeticType() || Type->isEnumeralType());\n\n  if (Type->isAnyComplexType() && BinaryOperator::isRelationalOp(Opc))\n    return S.InvalidOperands(Loc, LHS, RHS);\n\n  // Check for comparisons of floating point operands using != and ==.\n  if (Type->hasFloatingRepresentation() && BinaryOperator::isEqualityOp(Opc))\n    S.CheckFloatComparison(Loc, LHS.get(), RHS.get());\n\n  // The result of comparisons is 'bool' in C++, 'int' in C.\n  return S.Context.getLogicalOperationType();\n}\n\nvoid Sema::CheckPtrComparisonWithNullChar(ExprResult &E, ExprResult &NullE) {\n  if (!NullE.get()->getType()->isAnyPointerType())\n    return;\n  int NullValue = PP.isMacroDefined(\"NULL\") ? 0 : 1;\n  if (!E.get()->getType()->isAnyPointerType() &&\n      E.get()->isNullPointerConstant(Context,\n                                     Expr::NPC_ValueDependentIsNotNull) ==\n        Expr::NPCK_ZeroExpression) {\n    if (const auto *CL = dyn_cast<CharacterLiteral>(E.get())) {\n      if (CL->getValue() == 0)\n        Diag(E.get()->getExprLoc(), diag::warn_pointer_compare)\n            << NullValue\n            << FixItHint::CreateReplacement(E.get()->getExprLoc(),\n                                            NullValue ? \"NULL\" : \"(void *)0\");\n    } else if (const auto *CE = dyn_cast<CStyleCastExpr>(E.get())) {\n        TypeSourceInfo *TI = CE->getTypeInfoAsWritten();\n        QualType T = Context.getCanonicalType(TI->getType()).getUnqualifiedType();\n        if (T == Context.CharTy)\n          Diag(E.get()->getExprLoc(), diag::warn_pointer_compare)\n              << NullValue\n              << FixItHint::CreateReplacement(E.get()->getExprLoc(),\n                                              NullValue ? \"NULL\" : \"(void *)0\");\n      }\n  }\n}\n\n// C99 6.5.8, C++ [expr.rel]\nQualType Sema::CheckCompareOperands(ExprResult &LHS, ExprResult &RHS,\n                                    SourceLocation Loc,\n                                    BinaryOperatorKind Opc) {\n  bool IsRelational = BinaryOperator::isRelationalOp(Opc);\n  bool IsThreeWay = Opc == BO_Cmp;\n  bool IsOrdered = IsRelational || IsThreeWay;\n  auto IsAnyPointerType = [](ExprResult E) {\n    QualType Ty = E.get()->getType();\n    return Ty->isPointerType() || Ty->isMemberPointerType();\n  };\n\n  // C++2a [expr.spaceship]p6: If at least one of the operands is of pointer\n  // type, array-to-pointer, ..., conversions are performed on both operands to\n  // bring them to their composite type.\n  // Otherwise, all comparisons expect an rvalue, so convert to rvalue before\n  // any type-related checks.\n  if (!IsThreeWay || IsAnyPointerType(LHS) || IsAnyPointerType(RHS)) {\n    LHS = DefaultFunctionArrayLvalueConversion(LHS.get());\n    if (LHS.isInvalid())\n      return QualType();\n    RHS = DefaultFunctionArrayLvalueConversion(RHS.get());\n    if (RHS.isInvalid())\n      return QualType();\n  } else {\n    LHS = DefaultLvalueConversion(LHS.get());\n    if (LHS.isInvalid())\n      return QualType();\n    RHS = DefaultLvalueConversion(RHS.get());\n    if (RHS.isInvalid())\n      return QualType();\n  }\n\n  checkArithmeticNull(*this, LHS, RHS, Loc, /*IsCompare=*/true);\n  if (!getLangOpts().CPlusPlus && BinaryOperator::isEqualityOp(Opc)) {\n    CheckPtrComparisonWithNullChar(LHS, RHS);\n    CheckPtrComparisonWithNullChar(RHS, LHS);\n  }\n\n  // Handle vector comparisons separately.\n  if (LHS.get()->getType()->isVectorType() ||\n      RHS.get()->getType()->isVectorType())\n    return CheckVectorCompareOperands(LHS, RHS, Loc, Opc);\n\n  diagnoseLogicalNotOnLHSofCheck(*this, LHS, RHS, Loc, Opc);\n  diagnoseTautologicalComparison(*this, Loc, LHS.get(), RHS.get(), Opc);\n\n  QualType LHSType = LHS.get()->getType();\n  QualType RHSType = RHS.get()->getType();\n  if ((LHSType->isArithmeticType() || LHSType->isEnumeralType()) &&\n      (RHSType->isArithmeticType() || RHSType->isEnumeralType()))\n    return checkArithmeticOrEnumeralCompare(*this, LHS, RHS, Loc, Opc);\n\n  const Expr::NullPointerConstantKind LHSNullKind =\n      LHS.get()->isNullPointerConstant(Context, Expr::NPC_ValueDependentIsNull);\n  const Expr::NullPointerConstantKind RHSNullKind =\n      RHS.get()->isNullPointerConstant(Context, Expr::NPC_ValueDependentIsNull);\n  bool LHSIsNull = LHSNullKind != Expr::NPCK_NotNull;\n  bool RHSIsNull = RHSNullKind != Expr::NPCK_NotNull;\n\n  auto computeResultTy = [&]() {\n    if (Opc != BO_Cmp)\n      return Context.getLogicalOperationType();\n    assert(getLangOpts().CPlusPlus);\n    assert(Context.hasSameType(LHS.get()->getType(), RHS.get()->getType()));\n\n    QualType CompositeTy = LHS.get()->getType();\n    assert(!CompositeTy->isReferenceType());\n\n    Optional<ComparisonCategoryType> CCT =\n        getComparisonCategoryForBuiltinCmp(CompositeTy);\n    if (!CCT)\n      return InvalidOperands(Loc, LHS, RHS);\n\n    if (CompositeTy->isPointerType() && LHSIsNull != RHSIsNull) {\n      // P0946R0: Comparisons between a null pointer constant and an object\n      // pointer result in std::strong_equality, which is ill-formed under\n      // P1959R0.\n      Diag(Loc, diag::err_typecheck_three_way_comparison_of_pointer_and_zero)\n          << (LHSIsNull ? LHS.get()->getSourceRange()\n                        : RHS.get()->getSourceRange());\n      return QualType();\n    }\n\n    return CheckComparisonCategoryType(\n        *CCT, Loc, ComparisonCategoryUsage::OperatorInExpression);\n  };\n\n  if (!IsOrdered && LHSIsNull != RHSIsNull) {\n    bool IsEquality = Opc == BO_EQ;\n    if (RHSIsNull)\n      DiagnoseAlwaysNonNullPointer(LHS.get(), RHSNullKind, IsEquality,\n                                   RHS.get()->getSourceRange());\n    else\n      DiagnoseAlwaysNonNullPointer(RHS.get(), LHSNullKind, IsEquality,\n                                   LHS.get()->getSourceRange());\n  }\n\n  if ((LHSType->isIntegerType() && !LHSIsNull) ||\n      (RHSType->isIntegerType() && !RHSIsNull)) {\n    // Skip normal pointer conversion checks in this case; we have better\n    // diagnostics for this below.\n  } else if (getLangOpts().CPlusPlus) {\n    // Equality comparison of a function pointer to a void pointer is invalid,\n    // but we allow it as an extension.\n    // FIXME: If we really want to allow this, should it be part of composite\n    // pointer type computation so it works in conditionals too?\n    if (!IsOrdered &&\n        ((LHSType->isFunctionPointerType() && RHSType->isVoidPointerType()) ||\n         (RHSType->isFunctionPointerType() && LHSType->isVoidPointerType()))) {\n      // This is a gcc extension compatibility comparison.\n      // In a SFINAE context, we treat this as a hard error to maintain\n      // conformance with the C++ standard.\n      diagnoseFunctionPointerToVoidComparison(\n          *this, Loc, LHS, RHS, /*isError*/ (bool)isSFINAEContext());\n\n      if (isSFINAEContext())\n        return QualType();\n\n      RHS = ImpCastExprToType(RHS.get(), LHSType, CK_BitCast);\n      return computeResultTy();\n    }\n\n    // C++ [expr.eq]p2:\n    //   If at least one operand is a pointer [...] bring them to their\n    //   composite pointer type.\n    // C++ [expr.spaceship]p6\n    //  If at least one of the operands is of pointer type, [...] bring them\n    //  to their composite pointer type.\n    // C++ [expr.rel]p2:\n    //   If both operands are pointers, [...] bring them to their composite\n    //   pointer type.\n    // For <=>, the only valid non-pointer types are arrays and functions, and\n    // we already decayed those, so this is really the same as the relational\n    // comparison rule.\n    if ((int)LHSType->isPointerType() + (int)RHSType->isPointerType() >=\n            (IsOrdered ? 2 : 1) &&\n        (!LangOpts.ObjCAutoRefCount || !(LHSType->isObjCObjectPointerType() ||\n                                         RHSType->isObjCObjectPointerType()))) {\n      if (convertPointersToCompositeType(*this, Loc, LHS, RHS))\n        return QualType();\n      return computeResultTy();\n    }\n  } else if (LHSType->isPointerType() &&\n             RHSType->isPointerType()) { // C99 6.5.8p2\n    // All of the following pointer-related warnings are GCC extensions, except\n    // when handling null pointer constants.\n    QualType LCanPointeeTy =\n      LHSType->castAs<PointerType>()->getPointeeType().getCanonicalType();\n    QualType RCanPointeeTy =\n      RHSType->castAs<PointerType>()->getPointeeType().getCanonicalType();\n\n    // C99 6.5.9p2 and C99 6.5.8p2\n    if (Context.typesAreCompatible(LCanPointeeTy.getUnqualifiedType(),\n                                   RCanPointeeTy.getUnqualifiedType())) {\n      if (IsRelational) {\n        // Pointers both need to point to complete or incomplete types\n        if ((LCanPointeeTy->isIncompleteType() !=\n             RCanPointeeTy->isIncompleteType()) &&\n            !getLangOpts().C11) {\n          Diag(Loc, diag::ext_typecheck_compare_complete_incomplete_pointers)\n              << LHS.get()->getSourceRange() << RHS.get()->getSourceRange()\n              << LHSType << RHSType << LCanPointeeTy->isIncompleteType()\n              << RCanPointeeTy->isIncompleteType();\n        }\n        if (LCanPointeeTy->isFunctionType()) {\n          // Valid unless a relational comparison of function pointers\n          Diag(Loc, diag::ext_typecheck_ordered_comparison_of_function_pointers)\n              << LHSType << RHSType << LHS.get()->getSourceRange()\n              << RHS.get()->getSourceRange();\n        }\n      }\n    } else if (!IsRelational &&\n               (LCanPointeeTy->isVoidType() || RCanPointeeTy->isVoidType())) {\n      // Valid unless comparison between non-null pointer and function pointer\n      if ((LCanPointeeTy->isFunctionType() || RCanPointeeTy->isFunctionType())\n          && !LHSIsNull && !RHSIsNull)\n        diagnoseFunctionPointerToVoidComparison(*this, Loc, LHS, RHS,\n                                                /*isError*/false);\n    } else {\n      // Invalid\n      diagnoseDistinctPointerComparison(*this, Loc, LHS, RHS, /*isError*/false);\n    }\n    if (LCanPointeeTy != RCanPointeeTy) {\n      // Treat NULL constant as a special case in OpenCL.\n      if (getLangOpts().OpenCL && !LHSIsNull && !RHSIsNull) {\n        if (!LCanPointeeTy.isAddressSpaceOverlapping(RCanPointeeTy)) {\n          Diag(Loc,\n               diag::err_typecheck_op_on_nonoverlapping_address_space_pointers)\n              << LHSType << RHSType << 0 /* comparison */\n              << LHS.get()->getSourceRange() << RHS.get()->getSourceRange();\n        }\n      }\n      LangAS AddrSpaceL = LCanPointeeTy.getAddressSpace();\n      LangAS AddrSpaceR = RCanPointeeTy.getAddressSpace();\n      CastKind Kind = AddrSpaceL != AddrSpaceR ? CK_AddressSpaceConversion\n                                               : CK_BitCast;\n      if (LHSIsNull && !RHSIsNull)\n        LHS = ImpCastExprToType(LHS.get(), RHSType, Kind);\n      else\n        RHS = ImpCastExprToType(RHS.get(), LHSType, Kind);\n    }\n    return computeResultTy();\n  }\n\n  if (getLangOpts().CPlusPlus) {\n    // C++ [expr.eq]p4:\n    //   Two operands of type std::nullptr_t or one operand of type\n    //   std::nullptr_t and the other a null pointer constant compare equal.\n    if (!IsOrdered && LHSIsNull && RHSIsNull) {\n      if (LHSType->isNullPtrType()) {\n        RHS = ImpCastExprToType(RHS.get(), LHSType, CK_NullToPointer);\n        return computeResultTy();\n      }\n      if (RHSType->isNullPtrType()) {\n        LHS = ImpCastExprToType(LHS.get(), RHSType, CK_NullToPointer);\n        return computeResultTy();\n      }\n    }\n\n    // Comparison of Objective-C pointers and block pointers against nullptr_t.\n    // These aren't covered by the composite pointer type rules.\n    if (!IsOrdered && RHSType->isNullPtrType() &&\n        (LHSType->isObjCObjectPointerType() || LHSType->isBlockPointerType())) {\n      RHS = ImpCastExprToType(RHS.get(), LHSType, CK_NullToPointer);\n      return computeResultTy();\n    }\n    if (!IsOrdered && LHSType->isNullPtrType() &&\n        (RHSType->isObjCObjectPointerType() || RHSType->isBlockPointerType())) {\n      LHS = ImpCastExprToType(LHS.get(), RHSType, CK_NullToPointer);\n      return computeResultTy();\n    }\n\n    if (IsRelational &&\n        ((LHSType->isNullPtrType() && RHSType->isPointerType()) ||\n         (RHSType->isNullPtrType() && LHSType->isPointerType()))) {\n      // HACK: Relational comparison of nullptr_t against a pointer type is\n      // invalid per DR583, but we allow it within std::less<> and friends,\n      // since otherwise common uses of it break.\n      // FIXME: Consider removing this hack once LWG fixes std::less<> and\n      // friends to have std::nullptr_t overload candidates.\n      DeclContext *DC = CurContext;\n      if (isa<FunctionDecl>(DC))\n        DC = DC->getParent();\n      if (auto *CTSD = dyn_cast<ClassTemplateSpecializationDecl>(DC)) {\n        if (CTSD->isInStdNamespace() &&\n            llvm::StringSwitch<bool>(CTSD->getName())\n                .Cases(\"less\", \"less_equal\", \"greater\", \"greater_equal\", true)\n                .Default(false)) {\n          if (RHSType->isNullPtrType())\n            RHS = ImpCastExprToType(RHS.get(), LHSType, CK_NullToPointer);\n          else\n            LHS = ImpCastExprToType(LHS.get(), RHSType, CK_NullToPointer);\n          return computeResultTy();\n        }\n      }\n    }\n\n    // C++ [expr.eq]p2:\n    //   If at least one operand is a pointer to member, [...] bring them to\n    //   their composite pointer type.\n    if (!IsOrdered &&\n        (LHSType->isMemberPointerType() || RHSType->isMemberPointerType())) {\n      if (convertPointersToCompositeType(*this, Loc, LHS, RHS))\n        return QualType();\n      else\n        return computeResultTy();\n    }\n  }\n\n  // Handle block pointer types.\n  if (!IsOrdered && LHSType->isBlockPointerType() &&\n      RHSType->isBlockPointerType()) {\n    QualType lpointee = LHSType->castAs<BlockPointerType>()->getPointeeType();\n    QualType rpointee = RHSType->castAs<BlockPointerType>()->getPointeeType();\n\n    if (!LHSIsNull && !RHSIsNull &&\n        !Context.typesAreCompatible(lpointee, rpointee)) {\n      Diag(Loc, diag::err_typecheck_comparison_of_distinct_blocks)\n        << LHSType << RHSType << LHS.get()->getSourceRange()\n        << RHS.get()->getSourceRange();\n    }\n    RHS = ImpCastExprToType(RHS.get(), LHSType, CK_BitCast);\n    return computeResultTy();\n  }\n\n  // Allow block pointers to be compared with null pointer constants.\n  if (!IsOrdered\n      && ((LHSType->isBlockPointerType() && RHSType->isPointerType())\n          || (LHSType->isPointerType() && RHSType->isBlockPointerType()))) {\n    if (!LHSIsNull && !RHSIsNull) {\n      if (!((RHSType->isPointerType() && RHSType->castAs<PointerType>()\n             ->getPointeeType()->isVoidType())\n            || (LHSType->isPointerType() && LHSType->castAs<PointerType>()\n                ->getPointeeType()->isVoidType())))\n        Diag(Loc, diag::err_typecheck_comparison_of_distinct_blocks)\n          << LHSType << RHSType << LHS.get()->getSourceRange()\n          << RHS.get()->getSourceRange();\n    }\n    if (LHSIsNull && !RHSIsNull)\n      LHS = ImpCastExprToType(LHS.get(), RHSType,\n                              RHSType->isPointerType() ? CK_BitCast\n                                : CK_AnyPointerToBlockPointerCast);\n    else\n      RHS = ImpCastExprToType(RHS.get(), LHSType,\n                              LHSType->isPointerType() ? CK_BitCast\n                                : CK_AnyPointerToBlockPointerCast);\n    return computeResultTy();\n  }\n\n  if (LHSType->isObjCObjectPointerType() ||\n      RHSType->isObjCObjectPointerType()) {\n    const PointerType *LPT = LHSType->getAs<PointerType>();\n    const PointerType *RPT = RHSType->getAs<PointerType>();\n    if (LPT || RPT) {\n      bool LPtrToVoid = LPT ? LPT->getPointeeType()->isVoidType() : false;\n      bool RPtrToVoid = RPT ? RPT->getPointeeType()->isVoidType() : false;\n\n      if (!LPtrToVoid && !RPtrToVoid &&\n          !Context.typesAreCompatible(LHSType, RHSType)) {\n        diagnoseDistinctPointerComparison(*this, Loc, LHS, RHS,\n                                          /*isError*/false);\n      }\n      // FIXME: If LPtrToVoid, we should presumably convert the LHS rather than\n      // the RHS, but we have test coverage for this behavior.\n      // FIXME: Consider using convertPointersToCompositeType in C++.\n      if (LHSIsNull && !RHSIsNull) {\n        Expr *E = LHS.get();\n        if (getLangOpts().ObjCAutoRefCount)\n          CheckObjCConversion(SourceRange(), RHSType, E,\n                              CCK_ImplicitConversion);\n        LHS = ImpCastExprToType(E, RHSType,\n                                RPT ? CK_BitCast :CK_CPointerToObjCPointerCast);\n      }\n      else {\n        Expr *E = RHS.get();\n        if (getLangOpts().ObjCAutoRefCount)\n          CheckObjCConversion(SourceRange(), LHSType, E, CCK_ImplicitConversion,\n                              /*Diagnose=*/true,\n                              /*DiagnoseCFAudited=*/false, Opc);\n        RHS = ImpCastExprToType(E, LHSType,\n                                LPT ? CK_BitCast :CK_CPointerToObjCPointerCast);\n      }\n      return computeResultTy();\n    }\n    if (LHSType->isObjCObjectPointerType() &&\n        RHSType->isObjCObjectPointerType()) {\n      if (!Context.areComparableObjCPointerTypes(LHSType, RHSType))\n        diagnoseDistinctPointerComparison(*this, Loc, LHS, RHS,\n                                          /*isError*/false);\n      if (isObjCObjectLiteral(LHS) || isObjCObjectLiteral(RHS))\n        diagnoseObjCLiteralComparison(*this, Loc, LHS, RHS, Opc);\n\n      if (LHSIsNull && !RHSIsNull)\n        LHS = ImpCastExprToType(LHS.get(), RHSType, CK_BitCast);\n      else\n        RHS = ImpCastExprToType(RHS.get(), LHSType, CK_BitCast);\n      return computeResultTy();\n    }\n\n    if (!IsOrdered && LHSType->isBlockPointerType() &&\n        RHSType->isBlockCompatibleObjCPointerType(Context)) {\n      LHS = ImpCastExprToType(LHS.get(), RHSType,\n                              CK_BlockPointerToObjCPointerCast);\n      return computeResultTy();\n    } else if (!IsOrdered &&\n               LHSType->isBlockCompatibleObjCPointerType(Context) &&\n               RHSType->isBlockPointerType()) {\n      RHS = ImpCastExprToType(RHS.get(), LHSType,\n                              CK_BlockPointerToObjCPointerCast);\n      return computeResultTy();\n    }\n  }\n  if ((LHSType->isAnyPointerType() && RHSType->isIntegerType()) ||\n      (LHSType->isIntegerType() && RHSType->isAnyPointerType())) {\n    unsigned DiagID = 0;\n    bool isError = false;\n    if (LangOpts.DebuggerSupport) {\n      // Under a debugger, allow the comparison of pointers to integers,\n      // since users tend to want to compare addresses.\n    } else if ((LHSIsNull && LHSType->isIntegerType()) ||\n               (RHSIsNull && RHSType->isIntegerType())) {\n      if (IsOrdered) {\n        isError = getLangOpts().CPlusPlus;\n        DiagID =\n          isError ? diag::err_typecheck_ordered_comparison_of_pointer_and_zero\n                  : diag::ext_typecheck_ordered_comparison_of_pointer_and_zero;\n      }\n    } else if (getLangOpts().CPlusPlus) {\n      DiagID = diag::err_typecheck_comparison_of_pointer_integer;\n      isError = true;\n    } else if (IsOrdered)\n      DiagID = diag::ext_typecheck_ordered_comparison_of_pointer_integer;\n    else\n      DiagID = diag::ext_typecheck_comparison_of_pointer_integer;\n\n    if (DiagID) {\n      Diag(Loc, DiagID)\n        << LHSType << RHSType << LHS.get()->getSourceRange()\n        << RHS.get()->getSourceRange();\n      if (isError)\n        return QualType();\n    }\n\n    if (LHSType->isIntegerType())\n      LHS = ImpCastExprToType(LHS.get(), RHSType,\n                        LHSIsNull ? CK_NullToPointer : CK_IntegralToPointer);\n    else\n      RHS = ImpCastExprToType(RHS.get(), LHSType,\n                        RHSIsNull ? CK_NullToPointer : CK_IntegralToPointer);\n    return computeResultTy();\n  }\n\n  // Handle block pointers.\n  if (!IsOrdered && RHSIsNull\n      && LHSType->isBlockPointerType() && RHSType->isIntegerType()) {\n    RHS = ImpCastExprToType(RHS.get(), LHSType, CK_NullToPointer);\n    return computeResultTy();\n  }\n  if (!IsOrdered && LHSIsNull\n      && LHSType->isIntegerType() && RHSType->isBlockPointerType()) {\n    LHS = ImpCastExprToType(LHS.get(), RHSType, CK_NullToPointer);\n    return computeResultTy();\n  }\n\n  if (getLangOpts().OpenCLVersion >= 200 || getLangOpts().OpenCLCPlusPlus) {\n    if (LHSType->isClkEventT() && RHSType->isClkEventT()) {\n      return computeResultTy();\n    }\n\n    if (LHSType->isQueueT() && RHSType->isQueueT()) {\n      return computeResultTy();\n    }\n\n    if (LHSIsNull && RHSType->isQueueT()) {\n      LHS = ImpCastExprToType(LHS.get(), RHSType, CK_NullToPointer);\n      return computeResultTy();\n    }\n\n    if (LHSType->isQueueT() && RHSIsNull) {\n      RHS = ImpCastExprToType(RHS.get(), LHSType, CK_NullToPointer);\n      return computeResultTy();\n    }\n  }\n\n  return InvalidOperands(Loc, LHS, RHS);\n}\n\n// Return a signed ext_vector_type that is of identical size and number of\n// elements. For floating point vectors, return an integer type of identical\n// size and number of elements. In the non ext_vector_type case, search from\n// the largest type to the smallest type to avoid cases where long long == long,\n// where long gets picked over long long.\nQualType Sema::GetSignedVectorType(QualType V) {\n  const VectorType *VTy = V->castAs<VectorType>();\n  unsigned TypeSize = Context.getTypeSize(VTy->getElementType());\n\n  if (isa<ExtVectorType>(VTy)) {\n    if (TypeSize == Context.getTypeSize(Context.CharTy))\n      return Context.getExtVectorType(Context.CharTy, VTy->getNumElements());\n    else if (TypeSize == Context.getTypeSize(Context.ShortTy))\n      return Context.getExtVectorType(Context.ShortTy, VTy->getNumElements());\n    else if (TypeSize == Context.getTypeSize(Context.IntTy))\n      return Context.getExtVectorType(Context.IntTy, VTy->getNumElements());\n    else if (TypeSize == Context.getTypeSize(Context.LongTy))\n      return Context.getExtVectorType(Context.LongTy, VTy->getNumElements());\n    assert(TypeSize == Context.getTypeSize(Context.LongLongTy) &&\n           \"Unhandled vector element size in vector compare\");\n    return Context.getExtVectorType(Context.LongLongTy, VTy->getNumElements());\n  }\n\n  if (TypeSize == Context.getTypeSize(Context.LongLongTy))\n    return Context.getVectorType(Context.LongLongTy, VTy->getNumElements(),\n                                 VectorType::GenericVector);\n  else if (TypeSize == Context.getTypeSize(Context.LongTy))\n    return Context.getVectorType(Context.LongTy, VTy->getNumElements(),\n                                 VectorType::GenericVector);\n  else if (TypeSize == Context.getTypeSize(Context.IntTy))\n    return Context.getVectorType(Context.IntTy, VTy->getNumElements(),\n                                 VectorType::GenericVector);\n  else if (TypeSize == Context.getTypeSize(Context.ShortTy))\n    return Context.getVectorType(Context.ShortTy, VTy->getNumElements(),\n                                 VectorType::GenericVector);\n  assert(TypeSize == Context.getTypeSize(Context.CharTy) &&\n         \"Unhandled vector element size in vector compare\");\n  return Context.getVectorType(Context.CharTy, VTy->getNumElements(),\n                               VectorType::GenericVector);\n}\n\n/// CheckVectorCompareOperands - vector comparisons are a clang extension that\n/// operates on extended vector types.  Instead of producing an IntTy result,\n/// like a scalar comparison, a vector comparison produces a vector of integer\n/// types.\nQualType Sema::CheckVectorCompareOperands(ExprResult &LHS, ExprResult &RHS,\n                                          SourceLocation Loc,\n                                          BinaryOperatorKind Opc) {\n  if (Opc == BO_Cmp) {\n    Diag(Loc, diag::err_three_way_vector_comparison);\n    return QualType();\n  }\n\n  // Check to make sure we're operating on vectors of the same type and width,\n  // Allowing one side to be a scalar of element type.\n  QualType vType = CheckVectorOperands(LHS, RHS, Loc, /*isCompAssign*/false,\n                              /*AllowBothBool*/true,\n                              /*AllowBoolConversions*/getLangOpts().ZVector);\n  if (vType.isNull())\n    return vType;\n\n  QualType LHSType = LHS.get()->getType();\n\n  // If AltiVec, the comparison results in a numeric type, i.e.\n  // bool for C++, int for C\n  if (getLangOpts().AltiVec &&\n      vType->castAs<VectorType>()->getVectorKind() == VectorType::AltiVecVector)\n    return Context.getLogicalOperationType();\n\n  // For non-floating point types, check for self-comparisons of the form\n  // x == x, x != x, x < x, etc.  These always evaluate to a constant, and\n  // often indicate logic errors in the program.\n  diagnoseTautologicalComparison(*this, Loc, LHS.get(), RHS.get(), Opc);\n\n  // Check for comparisons of floating point operands using != and ==.\n  if (BinaryOperator::isEqualityOp(Opc) &&\n      LHSType->hasFloatingRepresentation()) {\n    assert(RHS.get()->getType()->hasFloatingRepresentation());\n    CheckFloatComparison(Loc, LHS.get(), RHS.get());\n  }\n\n  // Return a signed type for the vector.\n  return GetSignedVectorType(vType);\n}\n\nstatic void diagnoseXorMisusedAsPow(Sema &S, const ExprResult &XorLHS,\n                                    const ExprResult &XorRHS,\n                                    const SourceLocation Loc) {\n  // Do not diagnose macros.\n  if (Loc.isMacroID())\n    return;\n\n  // Do not diagnose if both LHS and RHS are macros.\n  if (XorLHS.get()->getExprLoc().isMacroID() &&\n      XorRHS.get()->getExprLoc().isMacroID())\n    return;\n\n  bool Negative = false;\n  bool ExplicitPlus = false;\n  const auto *LHSInt = dyn_cast<IntegerLiteral>(XorLHS.get());\n  const auto *RHSInt = dyn_cast<IntegerLiteral>(XorRHS.get());\n\n  if (!LHSInt)\n    return;\n  if (!RHSInt) {\n    // Check negative literals.\n    if (const auto *UO = dyn_cast<UnaryOperator>(XorRHS.get())) {\n      UnaryOperatorKind Opc = UO->getOpcode();\n      if (Opc != UO_Minus && Opc != UO_Plus)\n        return;\n      RHSInt = dyn_cast<IntegerLiteral>(UO->getSubExpr());\n      if (!RHSInt)\n        return;\n      Negative = (Opc == UO_Minus);\n      ExplicitPlus = !Negative;\n    } else {\n      return;\n    }\n  }\n\n  const llvm::APInt &LeftSideValue = LHSInt->getValue();\n  llvm::APInt RightSideValue = RHSInt->getValue();\n  if (LeftSideValue != 2 && LeftSideValue != 10)\n    return;\n\n  if (LeftSideValue.getBitWidth() != RightSideValue.getBitWidth())\n    return;\n\n  CharSourceRange ExprRange = CharSourceRange::getCharRange(\n      LHSInt->getBeginLoc(), S.getLocForEndOfToken(RHSInt->getLocation()));\n  llvm::StringRef ExprStr =\n      Lexer::getSourceText(ExprRange, S.getSourceManager(), S.getLangOpts());\n\n  CharSourceRange XorRange =\n      CharSourceRange::getCharRange(Loc, S.getLocForEndOfToken(Loc));\n  llvm::StringRef XorStr =\n      Lexer::getSourceText(XorRange, S.getSourceManager(), S.getLangOpts());\n  // Do not diagnose if xor keyword/macro is used.\n  if (XorStr == \"xor\")\n    return;\n\n  std::string LHSStr = std::string(Lexer::getSourceText(\n      CharSourceRange::getTokenRange(LHSInt->getSourceRange()),\n      S.getSourceManager(), S.getLangOpts()));\n  std::string RHSStr = std::string(Lexer::getSourceText(\n      CharSourceRange::getTokenRange(RHSInt->getSourceRange()),\n      S.getSourceManager(), S.getLangOpts()));\n\n  if (Negative) {\n    RightSideValue = -RightSideValue;\n    RHSStr = \"-\" + RHSStr;\n  } else if (ExplicitPlus) {\n    RHSStr = \"+\" + RHSStr;\n  }\n\n  StringRef LHSStrRef = LHSStr;\n  StringRef RHSStrRef = RHSStr;\n  // Do not diagnose literals with digit separators, binary, hexadecimal, octal\n  // literals.\n  if (LHSStrRef.startswith(\"0b\") || LHSStrRef.startswith(\"0B\") ||\n      RHSStrRef.startswith(\"0b\") || RHSStrRef.startswith(\"0B\") ||\n      LHSStrRef.startswith(\"0x\") || LHSStrRef.startswith(\"0X\") ||\n      RHSStrRef.startswith(\"0x\") || RHSStrRef.startswith(\"0X\") ||\n      (LHSStrRef.size() > 1 && LHSStrRef.startswith(\"0\")) ||\n      (RHSStrRef.size() > 1 && RHSStrRef.startswith(\"0\")) ||\n      LHSStrRef.find('\\'') != StringRef::npos ||\n      RHSStrRef.find('\\'') != StringRef::npos)\n    return;\n\n  bool SuggestXor = S.getLangOpts().CPlusPlus || S.getPreprocessor().isMacroDefined(\"xor\");\n  const llvm::APInt XorValue = LeftSideValue ^ RightSideValue;\n  int64_t RightSideIntValue = RightSideValue.getSExtValue();\n  if (LeftSideValue == 2 && RightSideIntValue >= 0) {\n    std::string SuggestedExpr = \"1 << \" + RHSStr;\n    bool Overflow = false;\n    llvm::APInt One = (LeftSideValue - 1);\n    llvm::APInt PowValue = One.sshl_ov(RightSideValue, Overflow);\n    if (Overflow) {\n      if (RightSideIntValue < 64)\n        S.Diag(Loc, diag::warn_xor_used_as_pow_base)\n            << ExprStr << XorValue.toString(10, true) << (\"1LL << \" + RHSStr)\n            << FixItHint::CreateReplacement(ExprRange, \"1LL << \" + RHSStr);\n      else if (RightSideIntValue == 64)\n        S.Diag(Loc, diag::warn_xor_used_as_pow) << ExprStr << XorValue.toString(10, true);\n      else\n        return;\n    } else {\n      S.Diag(Loc, diag::warn_xor_used_as_pow_base_extra)\n          << ExprStr << XorValue.toString(10, true) << SuggestedExpr\n          << PowValue.toString(10, true)\n          << FixItHint::CreateReplacement(\n                 ExprRange, (RightSideIntValue == 0) ? \"1\" : SuggestedExpr);\n    }\n\n    S.Diag(Loc, diag::note_xor_used_as_pow_silence) << (\"0x2 ^ \" + RHSStr) << SuggestXor;\n  } else if (LeftSideValue == 10) {\n    std::string SuggestedValue = \"1e\" + std::to_string(RightSideIntValue);\n    S.Diag(Loc, diag::warn_xor_used_as_pow_base)\n        << ExprStr << XorValue.toString(10, true) << SuggestedValue\n        << FixItHint::CreateReplacement(ExprRange, SuggestedValue);\n    S.Diag(Loc, diag::note_xor_used_as_pow_silence) << (\"0xA ^ \" + RHSStr) << SuggestXor;\n  }\n}\n\nQualType Sema::CheckVectorLogicalOperands(ExprResult &LHS, ExprResult &RHS,\n                                          SourceLocation Loc) {\n  // Ensure that either both operands are of the same vector type, or\n  // one operand is of a vector type and the other is of its element type.\n  QualType vType = CheckVectorOperands(LHS, RHS, Loc, false,\n                                       /*AllowBothBool*/true,\n                                       /*AllowBoolConversions*/false);\n  if (vType.isNull())\n    return InvalidOperands(Loc, LHS, RHS);\n  if (getLangOpts().OpenCL && getLangOpts().OpenCLVersion < 120 &&\n      !getLangOpts().OpenCLCPlusPlus && vType->hasFloatingRepresentation())\n    return InvalidOperands(Loc, LHS, RHS);\n  // FIXME: The check for C++ here is for GCC compatibility. GCC rejects the\n  //        usage of the logical operators && and || with vectors in C. This\n  //        check could be notionally dropped.\n  if (!getLangOpts().CPlusPlus &&\n      !(isa<ExtVectorType>(vType->getAs<VectorType>())))\n    return InvalidLogicalVectorOperands(Loc, LHS, RHS);\n\n  return GetSignedVectorType(LHS.get()->getType());\n}\n\nQualType Sema::CheckMatrixElementwiseOperands(ExprResult &LHS, ExprResult &RHS,\n                                              SourceLocation Loc,\n                                              bool IsCompAssign) {\n  if (!IsCompAssign) {\n    LHS = DefaultFunctionArrayLvalueConversion(LHS.get());\n    if (LHS.isInvalid())\n      return QualType();\n  }\n  RHS = DefaultFunctionArrayLvalueConversion(RHS.get());\n  if (RHS.isInvalid())\n    return QualType();\n\n  // For conversion purposes, we ignore any qualifiers.\n  // For example, \"const float\" and \"float\" are equivalent.\n  QualType LHSType = LHS.get()->getType().getUnqualifiedType();\n  QualType RHSType = RHS.get()->getType().getUnqualifiedType();\n\n  const MatrixType *LHSMatType = LHSType->getAs<MatrixType>();\n  const MatrixType *RHSMatType = RHSType->getAs<MatrixType>();\n  assert((LHSMatType || RHSMatType) && \"At least one operand must be a matrix\");\n\n  if (Context.hasSameType(LHSType, RHSType))\n    return LHSType;\n\n  // Type conversion may change LHS/RHS. Keep copies to the original results, in\n  // case we have to return InvalidOperands.\n  ExprResult OriginalLHS = LHS;\n  ExprResult OriginalRHS = RHS;\n  if (LHSMatType && !RHSMatType) {\n    RHS = tryConvertExprToType(RHS.get(), LHSMatType->getElementType());\n    if (!RHS.isInvalid())\n      return LHSType;\n\n    return InvalidOperands(Loc, OriginalLHS, OriginalRHS);\n  }\n\n  if (!LHSMatType && RHSMatType) {\n    LHS = tryConvertExprToType(LHS.get(), RHSMatType->getElementType());\n    if (!LHS.isInvalid())\n      return RHSType;\n    return InvalidOperands(Loc, OriginalLHS, OriginalRHS);\n  }\n\n  return InvalidOperands(Loc, LHS, RHS);\n}\n\nQualType Sema::CheckMatrixMultiplyOperands(ExprResult &LHS, ExprResult &RHS,\n                                           SourceLocation Loc,\n                                           bool IsCompAssign) {\n  if (!IsCompAssign) {\n    LHS = DefaultFunctionArrayLvalueConversion(LHS.get());\n    if (LHS.isInvalid())\n      return QualType();\n  }\n  RHS = DefaultFunctionArrayLvalueConversion(RHS.get());\n  if (RHS.isInvalid())\n    return QualType();\n\n  auto *LHSMatType = LHS.get()->getType()->getAs<ConstantMatrixType>();\n  auto *RHSMatType = RHS.get()->getType()->getAs<ConstantMatrixType>();\n  assert((LHSMatType || RHSMatType) && \"At least one operand must be a matrix\");\n\n  if (LHSMatType && RHSMatType) {\n    if (LHSMatType->getNumColumns() != RHSMatType->getNumRows())\n      return InvalidOperands(Loc, LHS, RHS);\n\n    if (!Context.hasSameType(LHSMatType->getElementType(),\n                             RHSMatType->getElementType()))\n      return InvalidOperands(Loc, LHS, RHS);\n\n    return Context.getConstantMatrixType(LHSMatType->getElementType(),\n                                         LHSMatType->getNumRows(),\n                                         RHSMatType->getNumColumns());\n  }\n  return CheckMatrixElementwiseOperands(LHS, RHS, Loc, IsCompAssign);\n}\n\ninline QualType Sema::CheckBitwiseOperands(ExprResult &LHS, ExprResult &RHS,\n                                           SourceLocation Loc,\n                                           BinaryOperatorKind Opc) {\n  checkArithmeticNull(*this, LHS, RHS, Loc, /*IsCompare=*/false);\n\n  bool IsCompAssign =\n      Opc == BO_AndAssign || Opc == BO_OrAssign || Opc == BO_XorAssign;\n\n  if (LHS.get()->getType()->isVectorType() ||\n      RHS.get()->getType()->isVectorType()) {\n    if (LHS.get()->getType()->hasIntegerRepresentation() &&\n        RHS.get()->getType()->hasIntegerRepresentation())\n      return CheckVectorOperands(LHS, RHS, Loc, IsCompAssign,\n                        /*AllowBothBool*/true,\n                        /*AllowBoolConversions*/getLangOpts().ZVector);\n    return InvalidOperands(Loc, LHS, RHS);\n  }\n\n  if (Opc == BO_And)\n    diagnoseLogicalNotOnLHSofCheck(*this, LHS, RHS, Loc, Opc);\n\n  if (LHS.get()->getType()->hasFloatingRepresentation() ||\n      RHS.get()->getType()->hasFloatingRepresentation())\n    return InvalidOperands(Loc, LHS, RHS);\n\n  ExprResult LHSResult = LHS, RHSResult = RHS;\n  QualType compType = UsualArithmeticConversions(\n      LHSResult, RHSResult, Loc, IsCompAssign ? ACK_CompAssign : ACK_BitwiseOp);\n  if (LHSResult.isInvalid() || RHSResult.isInvalid())\n    return QualType();\n  LHS = LHSResult.get();\n  RHS = RHSResult.get();\n\n  if (Opc == BO_Xor)\n    diagnoseXorMisusedAsPow(*this, LHS, RHS, Loc);\n\n  if (!compType.isNull() && compType->isIntegralOrUnscopedEnumerationType())\n    return compType;\n  return InvalidOperands(Loc, LHS, RHS);\n}\n\n// C99 6.5.[13,14]\ninline QualType Sema::CheckLogicalOperands(ExprResult &LHS, ExprResult &RHS,\n                                           SourceLocation Loc,\n                                           BinaryOperatorKind Opc) {\n  // Check vector operands differently.\n  if (LHS.get()->getType()->isVectorType() || RHS.get()->getType()->isVectorType())\n    return CheckVectorLogicalOperands(LHS, RHS, Loc);\n\n  bool EnumConstantInBoolContext = false;\n  for (const ExprResult &HS : {LHS, RHS}) {\n    if (const auto *DREHS = dyn_cast<DeclRefExpr>(HS.get())) {\n      const auto *ECDHS = dyn_cast<EnumConstantDecl>(DREHS->getDecl());\n      if (ECDHS && ECDHS->getInitVal() != 0 && ECDHS->getInitVal() != 1)\n        EnumConstantInBoolContext = true;\n    }\n  }\n\n  if (EnumConstantInBoolContext)\n    Diag(Loc, diag::warn_enum_constant_in_bool_context);\n\n  // Diagnose cases where the user write a logical and/or but probably meant a\n  // bitwise one.  We do this when the LHS is a non-bool integer and the RHS\n  // is a constant.\n  if (!EnumConstantInBoolContext && LHS.get()->getType()->isIntegerType() &&\n      !LHS.get()->getType()->isBooleanType() &&\n      RHS.get()->getType()->isIntegerType() && !RHS.get()->isValueDependent() &&\n      // Don't warn in macros or template instantiations.\n      !Loc.isMacroID() && !inTemplateInstantiation()) {\n    // If the RHS can be constant folded, and if it constant folds to something\n    // that isn't 0 or 1 (which indicate a potential logical operation that\n    // happened to fold to true/false) then warn.\n    // Parens on the RHS are ignored.\n    Expr::EvalResult EVResult;\n    if (RHS.get()->EvaluateAsInt(EVResult, Context)) {\n      llvm::APSInt Result = EVResult.Val.getInt();\n      if ((getLangOpts().Bool && !RHS.get()->getType()->isBooleanType() &&\n           !RHS.get()->getExprLoc().isMacroID()) ||\n          (Result != 0 && Result != 1)) {\n        Diag(Loc, diag::warn_logical_instead_of_bitwise)\n          << RHS.get()->getSourceRange()\n          << (Opc == BO_LAnd ? \"&&\" : \"||\");\n        // Suggest replacing the logical operator with the bitwise version\n        Diag(Loc, diag::note_logical_instead_of_bitwise_change_operator)\n            << (Opc == BO_LAnd ? \"&\" : \"|\")\n            << FixItHint::CreateReplacement(SourceRange(\n                                                 Loc, getLocForEndOfToken(Loc)),\n                                            Opc == BO_LAnd ? \"&\" : \"|\");\n        if (Opc == BO_LAnd)\n          // Suggest replacing \"Foo() && kNonZero\" with \"Foo()\"\n          Diag(Loc, diag::note_logical_instead_of_bitwise_remove_constant)\n              << FixItHint::CreateRemoval(\n                     SourceRange(getLocForEndOfToken(LHS.get()->getEndLoc()),\n                                 RHS.get()->getEndLoc()));\n      }\n    }\n  }\n\n  if (!Context.getLangOpts().CPlusPlus) {\n    // OpenCL v1.1 s6.3.g: The logical operators and (&&), or (||) do\n    // not operate on the built-in scalar and vector float types.\n    if (Context.getLangOpts().OpenCL &&\n        Context.getLangOpts().OpenCLVersion < 120) {\n      if (LHS.get()->getType()->isFloatingType() ||\n          RHS.get()->getType()->isFloatingType())\n        return InvalidOperands(Loc, LHS, RHS);\n    }\n\n    LHS = UsualUnaryConversions(LHS.get());\n    if (LHS.isInvalid())\n      return QualType();\n\n    RHS = UsualUnaryConversions(RHS.get());\n    if (RHS.isInvalid())\n      return QualType();\n\n    if (!LHS.get()->getType()->isScalarType() ||\n        !RHS.get()->getType()->isScalarType())\n      return InvalidOperands(Loc, LHS, RHS);\n\n    return Context.IntTy;\n  }\n\n  // The following is safe because we only use this method for\n  // non-overloadable operands.\n\n  // C++ [expr.log.and]p1\n  // C++ [expr.log.or]p1\n  // The operands are both contextually converted to type bool.\n  ExprResult LHSRes = PerformContextuallyConvertToBool(LHS.get());\n  if (LHSRes.isInvalid())\n    return InvalidOperands(Loc, LHS, RHS);\n  LHS = LHSRes;\n\n  ExprResult RHSRes = PerformContextuallyConvertToBool(RHS.get());\n  if (RHSRes.isInvalid())\n    return InvalidOperands(Loc, LHS, RHS);\n  RHS = RHSRes;\n\n  // C++ [expr.log.and]p2\n  // C++ [expr.log.or]p2\n  // The result is a bool.\n  return Context.BoolTy;\n}\n\nstatic bool IsReadonlyMessage(Expr *E, Sema &S) {\n  const MemberExpr *ME = dyn_cast<MemberExpr>(E);\n  if (!ME) return false;\n  if (!isa<FieldDecl>(ME->getMemberDecl())) return false;\n  ObjCMessageExpr *Base = dyn_cast<ObjCMessageExpr>(\n      ME->getBase()->IgnoreImplicit()->IgnoreParenImpCasts());\n  if (!Base) return false;\n  return Base->getMethodDecl() != nullptr;\n}\n\n/// Is the given expression (which must be 'const') a reference to a\n/// variable which was originally non-const, but which has become\n/// 'const' due to being captured within a block?\nenum NonConstCaptureKind { NCCK_None, NCCK_Block, NCCK_Lambda };\nstatic NonConstCaptureKind isReferenceToNonConstCapture(Sema &S, Expr *E) {\n  assert(E->isLValue() && E->getType().isConstQualified());\n  E = E->IgnoreParens();\n\n  // Must be a reference to a declaration from an enclosing scope.\n  DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E);\n  if (!DRE) return NCCK_None;\n  if (!DRE->refersToEnclosingVariableOrCapture()) return NCCK_None;\n\n  // The declaration must be a variable which is not declared 'const'.\n  VarDecl *var = dyn_cast<VarDecl>(DRE->getDecl());\n  if (!var) return NCCK_None;\n  if (var->getType().isConstQualified()) return NCCK_None;\n  assert(var->hasLocalStorage() && \"capture added 'const' to non-local?\");\n\n  // Decide whether the first capture was for a block or a lambda.\n  DeclContext *DC = S.CurContext, *Prev = nullptr;\n  // Decide whether the first capture was for a block or a lambda.\n  while (DC) {\n    // For init-capture, it is possible that the variable belongs to the\n    // template pattern of the current context.\n    if (auto *FD = dyn_cast<FunctionDecl>(DC))\n      if (var->isInitCapture() &&\n          FD->getTemplateInstantiationPattern() == var->getDeclContext())\n        break;\n    if (DC == var->getDeclContext())\n      break;\n    Prev = DC;\n    DC = DC->getParent();\n  }\n  // Unless we have an init-capture, we've gone one step too far.\n  if (!var->isInitCapture())\n    DC = Prev;\n  return (isa<BlockDecl>(DC) ? NCCK_Block : NCCK_Lambda);\n}\n\nstatic bool IsTypeModifiable(QualType Ty, bool IsDereference) {\n  Ty = Ty.getNonReferenceType();\n  if (IsDereference && Ty->isPointerType())\n    Ty = Ty->getPointeeType();\n  return !Ty.isConstQualified();\n}\n\n// Update err_typecheck_assign_const and note_typecheck_assign_const\n// when this enum is changed.\nenum {\n  ConstFunction,\n  ConstVariable,\n  ConstMember,\n  ConstMethod,\n  NestedConstMember,\n  ConstUnknown,  // Keep as last element\n};\n\n/// Emit the \"read-only variable not assignable\" error and print notes to give\n/// more information about why the variable is not assignable, such as pointing\n/// to the declaration of a const variable, showing that a method is const, or\n/// that the function is returning a const reference.\nstatic void DiagnoseConstAssignment(Sema &S, const Expr *E,\n                                    SourceLocation Loc) {\n  SourceRange ExprRange = E->getSourceRange();\n\n  // Only emit one error on the first const found.  All other consts will emit\n  // a note to the error.\n  bool DiagnosticEmitted = false;\n\n  // Track if the current expression is the result of a dereference, and if the\n  // next checked expression is the result of a dereference.\n  bool IsDereference = false;\n  bool NextIsDereference = false;\n\n  // Loop to process MemberExpr chains.\n  while (true) {\n    IsDereference = NextIsDereference;\n\n    E = E->IgnoreImplicit()->IgnoreParenImpCasts();\n    if (const MemberExpr *ME = dyn_cast<MemberExpr>(E)) {\n      NextIsDereference = ME->isArrow();\n      const ValueDecl *VD = ME->getMemberDecl();\n      if (const FieldDecl *Field = dyn_cast<FieldDecl>(VD)) {\n        // Mutable fields can be modified even if the class is const.\n        if (Field->isMutable()) {\n          assert(DiagnosticEmitted && \"Expected diagnostic not emitted.\");\n          break;\n        }\n\n        if (!IsTypeModifiable(Field->getType(), IsDereference)) {\n          if (!DiagnosticEmitted) {\n            S.Diag(Loc, diag::err_typecheck_assign_const)\n                << ExprRange << ConstMember << false /*static*/ << Field\n                << Field->getType();\n            DiagnosticEmitted = true;\n          }\n          S.Diag(VD->getLocation(), diag::note_typecheck_assign_const)\n              << ConstMember << false /*static*/ << Field << Field->getType()\n              << Field->getSourceRange();\n        }\n        E = ME->getBase();\n        continue;\n      } else if (const VarDecl *VDecl = dyn_cast<VarDecl>(VD)) {\n        if (VDecl->getType().isConstQualified()) {\n          if (!DiagnosticEmitted) {\n            S.Diag(Loc, diag::err_typecheck_assign_const)\n                << ExprRange << ConstMember << true /*static*/ << VDecl\n                << VDecl->getType();\n            DiagnosticEmitted = true;\n          }\n          S.Diag(VD->getLocation(), diag::note_typecheck_assign_const)\n              << ConstMember << true /*static*/ << VDecl << VDecl->getType()\n              << VDecl->getSourceRange();\n        }\n        // Static fields do not inherit constness from parents.\n        break;\n      }\n      break; // End MemberExpr\n    } else if (const ArraySubscriptExpr *ASE =\n                   dyn_cast<ArraySubscriptExpr>(E)) {\n      E = ASE->getBase()->IgnoreParenImpCasts();\n      continue;\n    } else if (const ExtVectorElementExpr *EVE =\n                   dyn_cast<ExtVectorElementExpr>(E)) {\n      E = EVE->getBase()->IgnoreParenImpCasts();\n      continue;\n    }\n    break;\n  }\n\n  if (const CallExpr *CE = dyn_cast<CallExpr>(E)) {\n    // Function calls\n    const FunctionDecl *FD = CE->getDirectCallee();\n    if (FD && !IsTypeModifiable(FD->getReturnType(), IsDereference)) {\n      if (!DiagnosticEmitted) {\n        S.Diag(Loc, diag::err_typecheck_assign_const) << ExprRange\n                                                      << ConstFunction << FD;\n        DiagnosticEmitted = true;\n      }\n      S.Diag(FD->getReturnTypeSourceRange().getBegin(),\n             diag::note_typecheck_assign_const)\n          << ConstFunction << FD << FD->getReturnType()\n          << FD->getReturnTypeSourceRange();\n    }\n  } else if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E)) {\n    // Point to variable declaration.\n    if (const ValueDecl *VD = DRE->getDecl()) {\n      if (!IsTypeModifiable(VD->getType(), IsDereference)) {\n        if (!DiagnosticEmitted) {\n          S.Diag(Loc, diag::err_typecheck_assign_const)\n              << ExprRange << ConstVariable << VD << VD->getType();\n          DiagnosticEmitted = true;\n        }\n        S.Diag(VD->getLocation(), diag::note_typecheck_assign_const)\n            << ConstVariable << VD << VD->getType() << VD->getSourceRange();\n      }\n    }\n  } else if (isa<CXXThisExpr>(E)) {\n    if (const DeclContext *DC = S.getFunctionLevelDeclContext()) {\n      if (const CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(DC)) {\n        if (MD->isConst()) {\n          if (!DiagnosticEmitted) {\n            S.Diag(Loc, diag::err_typecheck_assign_const) << ExprRange\n                                                          << ConstMethod << MD;\n            DiagnosticEmitted = true;\n          }\n          S.Diag(MD->getLocation(), diag::note_typecheck_assign_const)\n              << ConstMethod << MD << MD->getSourceRange();\n        }\n      }\n    }\n  }\n\n  if (DiagnosticEmitted)\n    return;\n\n  // Can't determine a more specific message, so display the generic error.\n  S.Diag(Loc, diag::err_typecheck_assign_const) << ExprRange << ConstUnknown;\n}\n\nenum OriginalExprKind {\n  OEK_Variable,\n  OEK_Member,\n  OEK_LValue\n};\n\nstatic void DiagnoseRecursiveConstFields(Sema &S, const ValueDecl *VD,\n                                         const RecordType *Ty,\n                                         SourceLocation Loc, SourceRange Range,\n                                         OriginalExprKind OEK,\n                                         bool &DiagnosticEmitted) {\n  std::vector<const RecordType *> RecordTypeList;\n  RecordTypeList.push_back(Ty);\n  unsigned NextToCheckIndex = 0;\n  // We walk the record hierarchy breadth-first to ensure that we print\n  // diagnostics in field nesting order.\n  while (RecordTypeList.size() > NextToCheckIndex) {\n    bool IsNested = NextToCheckIndex > 0;\n    for (const FieldDecl *Field :\n         RecordTypeList[NextToCheckIndex]->getDecl()->fields()) {\n      // First, check every field for constness.\n      QualType FieldTy = Field->getType();\n      if (FieldTy.isConstQualified()) {\n        if (!DiagnosticEmitted) {\n          S.Diag(Loc, diag::err_typecheck_assign_const)\n              << Range << NestedConstMember << OEK << VD\n              << IsNested << Field;\n          DiagnosticEmitted = true;\n        }\n        S.Diag(Field->getLocation(), diag::note_typecheck_assign_const)\n            << NestedConstMember << IsNested << Field\n            << FieldTy << Field->getSourceRange();\n      }\n\n      // Then we append it to the list to check next in order.\n      FieldTy = FieldTy.getCanonicalType();\n      if (const auto *FieldRecTy = FieldTy->getAs<RecordType>()) {\n        if (llvm::find(RecordTypeList, FieldRecTy) == RecordTypeList.end())\n          RecordTypeList.push_back(FieldRecTy);\n      }\n    }\n    ++NextToCheckIndex;\n  }\n}\n\n/// Emit an error for the case where a record we are trying to assign to has a\n/// const-qualified field somewhere in its hierarchy.\nstatic void DiagnoseRecursiveConstFields(Sema &S, const Expr *E,\n                                         SourceLocation Loc) {\n  QualType Ty = E->getType();\n  assert(Ty->isRecordType() && \"lvalue was not record?\");\n  SourceRange Range = E->getSourceRange();\n  const RecordType *RTy = Ty.getCanonicalType()->getAs<RecordType>();\n  bool DiagEmitted = false;\n\n  if (const MemberExpr *ME = dyn_cast<MemberExpr>(E))\n    DiagnoseRecursiveConstFields(S, ME->getMemberDecl(), RTy, Loc,\n            Range, OEK_Member, DiagEmitted);\n  else if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E))\n    DiagnoseRecursiveConstFields(S, DRE->getDecl(), RTy, Loc,\n            Range, OEK_Variable, DiagEmitted);\n  else\n    DiagnoseRecursiveConstFields(S, nullptr, RTy, Loc,\n            Range, OEK_LValue, DiagEmitted);\n  if (!DiagEmitted)\n    DiagnoseConstAssignment(S, E, Loc);\n}\n\n/// CheckForModifiableLvalue - Verify that E is a modifiable lvalue.  If not,\n/// emit an error and return true.  If so, return false.\nstatic bool CheckForModifiableLvalue(Expr *E, SourceLocation Loc, Sema &S) {\n  assert(!E->hasPlaceholderType(BuiltinType::PseudoObject));\n\n  S.CheckShadowingDeclModification(E, Loc);\n\n  SourceLocation OrigLoc = Loc;\n  Expr::isModifiableLvalueResult IsLV = E->isModifiableLvalue(S.Context,\n                                                              &Loc);\n  if (IsLV == Expr::MLV_ClassTemporary && IsReadonlyMessage(E, S))\n    IsLV = Expr::MLV_InvalidMessageExpression;\n  if (IsLV == Expr::MLV_Valid)\n    return false;\n\n  unsigned DiagID = 0;\n  bool NeedType = false;\n  switch (IsLV) { // C99 6.5.16p2\n  case Expr::MLV_ConstQualified:\n    // Use a specialized diagnostic when we're assigning to an object\n    // from an enclosing function or block.\n    if (NonConstCaptureKind NCCK = isReferenceToNonConstCapture(S, E)) {\n      if (NCCK == NCCK_Block)\n        DiagID = diag::err_block_decl_ref_not_modifiable_lvalue;\n      else\n        DiagID = diag::err_lambda_decl_ref_not_modifiable_lvalue;\n      break;\n    }\n\n    // In ARC, use some specialized diagnostics for occasions where we\n    // infer 'const'.  These are always pseudo-strong variables.\n    if (S.getLangOpts().ObjCAutoRefCount) {\n      DeclRefExpr *declRef = dyn_cast<DeclRefExpr>(E->IgnoreParenCasts());\n      if (declRef && isa<VarDecl>(declRef->getDecl())) {\n        VarDecl *var = cast<VarDecl>(declRef->getDecl());\n\n        // Use the normal diagnostic if it's pseudo-__strong but the\n        // user actually wrote 'const'.\n        if (var->isARCPseudoStrong() &&\n            (!var->getTypeSourceInfo() ||\n             !var->getTypeSourceInfo()->getType().isConstQualified())) {\n          // There are three pseudo-strong cases:\n          //  - self\n          ObjCMethodDecl *method = S.getCurMethodDecl();\n          if (method && var == method->getSelfDecl()) {\n            DiagID = method->isClassMethod()\n              ? diag::err_typecheck_arc_assign_self_class_method\n              : diag::err_typecheck_arc_assign_self;\n\n          //  - Objective-C externally_retained attribute.\n          } else if (var->hasAttr<ObjCExternallyRetainedAttr>() ||\n                     isa<ParmVarDecl>(var)) {\n            DiagID = diag::err_typecheck_arc_assign_externally_retained;\n\n          //  - fast enumeration variables\n          } else {\n            DiagID = diag::err_typecheck_arr_assign_enumeration;\n          }\n\n          SourceRange Assign;\n          if (Loc != OrigLoc)\n            Assign = SourceRange(OrigLoc, OrigLoc);\n          S.Diag(Loc, DiagID) << E->getSourceRange() << Assign;\n          // We need to preserve the AST regardless, so migration tool\n          // can do its job.\n          return false;\n        }\n      }\n    }\n\n    // If none of the special cases above are triggered, then this is a\n    // simple const assignment.\n    if (DiagID == 0) {\n      DiagnoseConstAssignment(S, E, Loc);\n      return true;\n    }\n\n    break;\n  case Expr::MLV_ConstAddrSpace:\n    DiagnoseConstAssignment(S, E, Loc);\n    return true;\n  case Expr::MLV_ConstQualifiedField:\n    DiagnoseRecursiveConstFields(S, E, Loc);\n    return true;\n  case Expr::MLV_ArrayType:\n  case Expr::MLV_ArrayTemporary:\n    DiagID = diag::err_typecheck_array_not_modifiable_lvalue;\n    NeedType = true;\n    break;\n  case Expr::MLV_NotObjectType:\n    DiagID = diag::err_typecheck_non_object_not_modifiable_lvalue;\n    NeedType = true;\n    break;\n  case Expr::MLV_LValueCast:\n    DiagID = diag::err_typecheck_lvalue_casts_not_supported;\n    break;\n  case Expr::MLV_Valid:\n    llvm_unreachable(\"did not take early return for MLV_Valid\");\n  case Expr::MLV_InvalidExpression:\n  case Expr::MLV_MemberFunction:\n  case Expr::MLV_ClassTemporary:\n    DiagID = diag::err_typecheck_expression_not_modifiable_lvalue;\n    break;\n  case Expr::MLV_IncompleteType:\n  case Expr::MLV_IncompleteVoidType:\n    return S.RequireCompleteType(Loc, E->getType(),\n             diag::err_typecheck_incomplete_type_not_modifiable_lvalue, E);\n  case Expr::MLV_DuplicateVectorComponents:\n    DiagID = diag::err_typecheck_duplicate_vector_components_not_mlvalue;\n    break;\n  case Expr::MLV_NoSetterProperty:\n    llvm_unreachable(\"readonly properties should be processed differently\");\n  case Expr::MLV_InvalidMessageExpression:\n    DiagID = diag::err_readonly_message_assignment;\n    break;\n  case Expr::MLV_SubObjCPropertySetting:\n    DiagID = diag::err_no_subobject_property_setting;\n    break;\n  }\n\n  SourceRange Assign;\n  if (Loc != OrigLoc)\n    Assign = SourceRange(OrigLoc, OrigLoc);\n  if (NeedType)\n    S.Diag(Loc, DiagID) << E->getType() << E->getSourceRange() << Assign;\n  else\n    S.Diag(Loc, DiagID) << E->getSourceRange() << Assign;\n  return true;\n}\n\nstatic void CheckIdentityFieldAssignment(Expr *LHSExpr, Expr *RHSExpr,\n                                         SourceLocation Loc,\n                                         Sema &Sema) {\n  if (Sema.inTemplateInstantiation())\n    return;\n  if (Sema.isUnevaluatedContext())\n    return;\n  if (Loc.isInvalid() || Loc.isMacroID())\n    return;\n  if (LHSExpr->getExprLoc().isMacroID() || RHSExpr->getExprLoc().isMacroID())\n    return;\n\n  // C / C++ fields\n  MemberExpr *ML = dyn_cast<MemberExpr>(LHSExpr);\n  MemberExpr *MR = dyn_cast<MemberExpr>(RHSExpr);\n  if (ML && MR) {\n    if (!(isa<CXXThisExpr>(ML->getBase()) && isa<CXXThisExpr>(MR->getBase())))\n      return;\n    const ValueDecl *LHSDecl =\n        cast<ValueDecl>(ML->getMemberDecl()->getCanonicalDecl());\n    const ValueDecl *RHSDecl =\n        cast<ValueDecl>(MR->getMemberDecl()->getCanonicalDecl());\n    if (LHSDecl != RHSDecl)\n      return;\n    if (LHSDecl->getType().isVolatileQualified())\n      return;\n    if (const ReferenceType *RefTy = LHSDecl->getType()->getAs<ReferenceType>())\n      if (RefTy->getPointeeType().isVolatileQualified())\n        return;\n\n    Sema.Diag(Loc, diag::warn_identity_field_assign) << 0;\n  }\n\n  // Objective-C instance variables\n  ObjCIvarRefExpr *OL = dyn_cast<ObjCIvarRefExpr>(LHSExpr);\n  ObjCIvarRefExpr *OR = dyn_cast<ObjCIvarRefExpr>(RHSExpr);\n  if (OL && OR && OL->getDecl() == OR->getDecl()) {\n    DeclRefExpr *RL = dyn_cast<DeclRefExpr>(OL->getBase()->IgnoreImpCasts());\n    DeclRefExpr *RR = dyn_cast<DeclRefExpr>(OR->getBase()->IgnoreImpCasts());\n    if (RL && RR && RL->getDecl() == RR->getDecl())\n      Sema.Diag(Loc, diag::warn_identity_field_assign) << 1;\n  }\n}\n\n// C99 6.5.16.1\nQualType Sema::CheckAssignmentOperands(Expr *LHSExpr, ExprResult &RHS,\n                                       SourceLocation Loc,\n                                       QualType CompoundType) {\n  assert(!LHSExpr->hasPlaceholderType(BuiltinType::PseudoObject));\n\n  // Verify that LHS is a modifiable lvalue, and emit error if not.\n  if (CheckForModifiableLvalue(LHSExpr, Loc, *this))\n    return QualType();\n\n  QualType LHSType = LHSExpr->getType();\n  QualType RHSType = CompoundType.isNull() ? RHS.get()->getType() :\n                                             CompoundType;\n  // OpenCL v1.2 s6.1.1.1 p2:\n  // The half data type can only be used to declare a pointer to a buffer that\n  // contains half values\n  if (getLangOpts().OpenCL && !getOpenCLOptions().isEnabled(\"cl_khr_fp16\") &&\n    LHSType->isHalfType()) {\n    Diag(Loc, diag::err_opencl_half_load_store) << 1\n        << LHSType.getUnqualifiedType();\n    return QualType();\n  }\n\n  AssignConvertType ConvTy;\n  if (CompoundType.isNull()) {\n    Expr *RHSCheck = RHS.get();\n\n    CheckIdentityFieldAssignment(LHSExpr, RHSCheck, Loc, *this);\n\n    QualType LHSTy(LHSType);\n    ConvTy = CheckSingleAssignmentConstraints(LHSTy, RHS);\n    if (RHS.isInvalid())\n      return QualType();\n    // Special case of NSObject attributes on c-style pointer types.\n    if (ConvTy == IncompatiblePointer &&\n        ((Context.isObjCNSObjectType(LHSType) &&\n          RHSType->isObjCObjectPointerType()) ||\n         (Context.isObjCNSObjectType(RHSType) &&\n          LHSType->isObjCObjectPointerType())))\n      ConvTy = Compatible;\n\n    if (ConvTy == Compatible &&\n        LHSType->isObjCObjectType())\n        Diag(Loc, diag::err_objc_object_assignment)\n          << LHSType;\n\n    // If the RHS is a unary plus or minus, check to see if they = and + are\n    // right next to each other.  If so, the user may have typo'd \"x =+ 4\"\n    // instead of \"x += 4\".\n    if (ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(RHSCheck))\n      RHSCheck = ICE->getSubExpr();\n    if (UnaryOperator *UO = dyn_cast<UnaryOperator>(RHSCheck)) {\n      if ((UO->getOpcode() == UO_Plus || UO->getOpcode() == UO_Minus) &&\n          Loc.isFileID() && UO->getOperatorLoc().isFileID() &&\n          // Only if the two operators are exactly adjacent.\n          Loc.getLocWithOffset(1) == UO->getOperatorLoc() &&\n          // And there is a space or other character before the subexpr of the\n          // unary +/-.  We don't want to warn on \"x=-1\".\n          Loc.getLocWithOffset(2) != UO->getSubExpr()->getBeginLoc() &&\n          UO->getSubExpr()->getBeginLoc().isFileID()) {\n        Diag(Loc, diag::warn_not_compound_assign)\n          << (UO->getOpcode() == UO_Plus ? \"+\" : \"-\")\n          << SourceRange(UO->getOperatorLoc(), UO->getOperatorLoc());\n      }\n    }\n\n    if (ConvTy == Compatible) {\n      if (LHSType.getObjCLifetime() == Qualifiers::OCL_Strong) {\n        // Warn about retain cycles where a block captures the LHS, but\n        // not if the LHS is a simple variable into which the block is\n        // being stored...unless that variable can be captured by reference!\n        const Expr *InnerLHS = LHSExpr->IgnoreParenCasts();\n        const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(InnerLHS);\n        if (!DRE || DRE->getDecl()->hasAttr<BlocksAttr>())\n          checkRetainCycles(LHSExpr, RHS.get());\n      }\n\n      if (LHSType.getObjCLifetime() == Qualifiers::OCL_Strong ||\n          LHSType.isNonWeakInMRRWithObjCWeak(Context)) {\n        // It is safe to assign a weak reference into a strong variable.\n        // Although this code can still have problems:\n        //   id x = self.weakProp;\n        //   id y = self.weakProp;\n        // we do not warn to warn spuriously when 'x' and 'y' are on separate\n        // paths through the function. This should be revisited if\n        // -Wrepeated-use-of-weak is made flow-sensitive.\n        // For ObjCWeak only, we do not warn if the assign is to a non-weak\n        // variable, which will be valid for the current autorelease scope.\n        if (!Diags.isIgnored(diag::warn_arc_repeated_use_of_weak,\n                             RHS.get()->getBeginLoc()))\n          getCurFunction()->markSafeWeakUse(RHS.get());\n\n      } else if (getLangOpts().ObjCAutoRefCount || getLangOpts().ObjCWeak) {\n        checkUnsafeExprAssigns(Loc, LHSExpr, RHS.get());\n      }\n    }\n  } else {\n    // Compound assignment \"x += y\"\n    ConvTy = CheckAssignmentConstraints(Loc, LHSType, RHSType);\n  }\n\n  if (DiagnoseAssignmentResult(ConvTy, Loc, LHSType, RHSType,\n                               RHS.get(), AA_Assigning))\n    return QualType();\n\n  CheckForNullPointerDereference(*this, LHSExpr);\n\n  if (getLangOpts().CPlusPlus20 && LHSType.isVolatileQualified()) {\n    if (CompoundType.isNull()) {\n      // C++2a [expr.ass]p5:\n      //   A simple-assignment whose left operand is of a volatile-qualified\n      //   type is deprecated unless the assignment is either a discarded-value\n      //   expression or an unevaluated operand\n      ExprEvalContexts.back().VolatileAssignmentLHSs.push_back(LHSExpr);\n    } else {\n      // C++2a [expr.ass]p6:\n      //   [Compound-assignment] expressions are deprecated if E1 has\n      //   volatile-qualified type\n      Diag(Loc, diag::warn_deprecated_compound_assign_volatile) << LHSType;\n    }\n  }\n\n  // C99 6.5.16p3: The type of an assignment expression is the type of the\n  // left operand unless the left operand has qualified type, in which case\n  // it is the unqualified version of the type of the left operand.\n  // C99 6.5.16.1p2: In simple assignment, the value of the right operand\n  // is converted to the type of the assignment expression (above).\n  // C++ 5.17p1: the type of the assignment expression is that of its left\n  // operand.\n  return (getLangOpts().CPlusPlus\n          ? LHSType : LHSType.getUnqualifiedType());\n}\n\n// Only ignore explicit casts to void.\nstatic bool IgnoreCommaOperand(const Expr *E) {\n  E = E->IgnoreParens();\n\n  if (const CastExpr *CE = dyn_cast<CastExpr>(E)) {\n    if (CE->getCastKind() == CK_ToVoid) {\n      return true;\n    }\n\n    // static_cast<void> on a dependent type will not show up as CK_ToVoid.\n    if (CE->getCastKind() == CK_Dependent && E->getType()->isVoidType() &&\n        CE->getSubExpr()->getType()->isDependentType()) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Look for instances where it is likely the comma operator is confused with\n// another operator.  There is an explicit list of acceptable expressions for\n// the left hand side of the comma operator, otherwise emit a warning.\nvoid Sema::DiagnoseCommaOperator(const Expr *LHS, SourceLocation Loc) {\n  // No warnings in macros\n  if (Loc.isMacroID())\n    return;\n\n  // Don't warn in template instantiations.\n  if (inTemplateInstantiation())\n    return;\n\n  // Scope isn't fine-grained enough to explicitly list the specific cases, so\n  // instead, skip more than needed, then call back into here with the\n  // CommaVisitor in SemaStmt.cpp.\n  // The listed locations are the initialization and increment portions\n  // of a for loop.  The additional checks are on the condition of\n  // if statements, do/while loops, and for loops.\n  // Differences in scope flags for C89 mode requires the extra logic.\n  const unsigned ForIncrementFlags =\n      getLangOpts().C99 || getLangOpts().CPlusPlus\n          ? Scope::ControlScope | Scope::ContinueScope | Scope::BreakScope\n          : Scope::ContinueScope | Scope::BreakScope;\n  const unsigned ForInitFlags = Scope::ControlScope | Scope::DeclScope;\n  const unsigned ScopeFlags = getCurScope()->getFlags();\n  if ((ScopeFlags & ForIncrementFlags) == ForIncrementFlags ||\n      (ScopeFlags & ForInitFlags) == ForInitFlags)\n    return;\n\n  // If there are multiple comma operators used together, get the RHS of the\n  // of the comma operator as the LHS.\n  while (const BinaryOperator *BO = dyn_cast<BinaryOperator>(LHS)) {\n    if (BO->getOpcode() != BO_Comma)\n      break;\n    LHS = BO->getRHS();\n  }\n\n  // Only allow some expressions on LHS to not warn.\n  if (IgnoreCommaOperand(LHS))\n    return;\n\n  Diag(Loc, diag::warn_comma_operator);\n  Diag(LHS->getBeginLoc(), diag::note_cast_to_void)\n      << LHS->getSourceRange()\n      << FixItHint::CreateInsertion(LHS->getBeginLoc(),\n                                    LangOpts.CPlusPlus ? \"static_cast<void>(\"\n                                                       : \"(void)(\")\n      << FixItHint::CreateInsertion(PP.getLocForEndOfToken(LHS->getEndLoc()),\n                                    \")\");\n}\n\n// C99 6.5.17\nstatic QualType CheckCommaOperands(Sema &S, ExprResult &LHS, ExprResult &RHS,\n                                   SourceLocation Loc) {\n  LHS = S.CheckPlaceholderExpr(LHS.get());\n  RHS = S.CheckPlaceholderExpr(RHS.get());\n  if (LHS.isInvalid() || RHS.isInvalid())\n    return QualType();\n\n  // C's comma performs lvalue conversion (C99 6.3.2.1) on both its\n  // operands, but not unary promotions.\n  // C++'s comma does not do any conversions at all (C++ [expr.comma]p1).\n\n  // So we treat the LHS as a ignored value, and in C++ we allow the\n  // containing site to determine what should be done with the RHS.\n  LHS = S.IgnoredValueConversions(LHS.get());\n  if (LHS.isInvalid())\n    return QualType();\n\n  S.DiagnoseUnusedExprResult(LHS.get());\n\n  if (!S.getLangOpts().CPlusPlus) {\n    RHS = S.DefaultFunctionArrayLvalueConversion(RHS.get());\n    if (RHS.isInvalid())\n      return QualType();\n    if (!RHS.get()->getType()->isVoidType())\n      S.RequireCompleteType(Loc, RHS.get()->getType(),\n                            diag::err_incomplete_type);\n  }\n\n  if (!S.getDiagnostics().isIgnored(diag::warn_comma_operator, Loc))\n    S.DiagnoseCommaOperator(LHS.get(), Loc);\n\n  return RHS.get()->getType();\n}\n\n/// CheckIncrementDecrementOperand - unlike most \"Check\" methods, this routine\n/// doesn't need to call UsualUnaryConversions or UsualArithmeticConversions.\nstatic QualType CheckIncrementDecrementOperand(Sema &S, Expr *Op,\n                                               ExprValueKind &VK,\n                                               ExprObjectKind &OK,\n                                               SourceLocation OpLoc,\n                                               bool IsInc, bool IsPrefix) {\n  if (Op->isTypeDependent())\n    return S.Context.DependentTy;\n\n  QualType ResType = Op->getType();\n  // Atomic types can be used for increment / decrement where the non-atomic\n  // versions can, so ignore the _Atomic() specifier for the purpose of\n  // checking.\n  if (const AtomicType *ResAtomicType = ResType->getAs<AtomicType>())\n    ResType = ResAtomicType->getValueType();\n\n  assert(!ResType.isNull() && \"no type for increment/decrement expression\");\n\n  if (S.getLangOpts().CPlusPlus && ResType->isBooleanType()) {\n    // Decrement of bool is not allowed.\n    if (!IsInc) {\n      S.Diag(OpLoc, diag::err_decrement_bool) << Op->getSourceRange();\n      return QualType();\n    }\n    // Increment of bool sets it to true, but is deprecated.\n    S.Diag(OpLoc, S.getLangOpts().CPlusPlus17 ? diag::ext_increment_bool\n                                              : diag::warn_increment_bool)\n      << Op->getSourceRange();\n  } else if (S.getLangOpts().CPlusPlus && ResType->isEnumeralType()) {\n    // Error on enum increments and decrements in C++ mode\n    S.Diag(OpLoc, diag::err_increment_decrement_enum) << IsInc << ResType;\n    return QualType();\n  } else if (ResType->isRealType()) {\n    // OK!\n  } else if (ResType->isPointerType()) {\n    // C99 6.5.2.4p2, 6.5.6p2\n    if (!checkArithmeticOpPointerOperand(S, OpLoc, Op))\n      return QualType();\n  } else if (ResType->isObjCObjectPointerType()) {\n    // On modern runtimes, ObjC pointer arithmetic is forbidden.\n    // Otherwise, we just need a complete type.\n    if (checkArithmeticIncompletePointerType(S, OpLoc, Op) ||\n        checkArithmeticOnObjCPointer(S, OpLoc, Op))\n      return QualType();\n  } else if (ResType->isAnyComplexType()) {\n    // C99 does not support ++/-- on complex types, we allow as an extension.\n    S.Diag(OpLoc, diag::ext_integer_increment_complex)\n      << ResType << Op->getSourceRange();\n  } else if (ResType->isPlaceholderType()) {\n    ExprResult PR = S.CheckPlaceholderExpr(Op);\n    if (PR.isInvalid()) return QualType();\n    return CheckIncrementDecrementOperand(S, PR.get(), VK, OK, OpLoc,\n                                          IsInc, IsPrefix);\n  } else if (S.getLangOpts().AltiVec && ResType->isVectorType()) {\n    // OK! ( C/C++ Language Extensions for CBEA(Version 2.6) 10.3 )\n  } else if (S.getLangOpts().ZVector && ResType->isVectorType() &&\n             (ResType->castAs<VectorType>()->getVectorKind() !=\n              VectorType::AltiVecBool)) {\n    // The z vector extensions allow ++ and -- for non-bool vectors.\n  } else if(S.getLangOpts().OpenCL && ResType->isVectorType() &&\n            ResType->castAs<VectorType>()->getElementType()->isIntegerType()) {\n    // OpenCL V1.2 6.3 says dec/inc ops operate on integer vector types.\n  } else {\n    S.Diag(OpLoc, diag::err_typecheck_illegal_increment_decrement)\n      << ResType << int(IsInc) << Op->getSourceRange();\n    return QualType();\n  }\n  // At this point, we know we have a real, complex or pointer type.\n  // Now make sure the operand is a modifiable lvalue.\n  if (CheckForModifiableLvalue(Op, OpLoc, S))\n    return QualType();\n  if (S.getLangOpts().CPlusPlus20 && ResType.isVolatileQualified()) {\n    // C++2a [expr.pre.inc]p1, [expr.post.inc]p1:\n    //   An operand with volatile-qualified type is deprecated\n    S.Diag(OpLoc, diag::warn_deprecated_increment_decrement_volatile)\n        << IsInc << ResType;\n  }\n  // In C++, a prefix increment is the same type as the operand. Otherwise\n  // (in C or with postfix), the increment is the unqualified type of the\n  // operand.\n  if (IsPrefix && S.getLangOpts().CPlusPlus) {\n    VK = VK_LValue;\n    OK = Op->getObjectKind();\n    return ResType;\n  } else {\n    VK = VK_RValue;\n    return ResType.getUnqualifiedType();\n  }\n}\n\n\n/// getPrimaryDecl - Helper function for CheckAddressOfOperand().\n/// This routine allows us to typecheck complex/recursive expressions\n/// where the declaration is needed for type checking. We only need to\n/// handle cases when the expression references a function designator\n/// or is an lvalue. Here are some examples:\n///  - &(x) => x\n///  - &*****f => f for f a function designator.\n///  - &s.xx => s\n///  - &s.zz[1].yy -> s, if zz is an array\n///  - *(x + 1) -> x, if x is an array\n///  - &\"123\"[2] -> 0\n///  - & __real__ x -> x\n///\n/// FIXME: We don't recurse to the RHS of a comma, nor handle pointers to\n/// members.\nstatic ValueDecl *getPrimaryDecl(Expr *E) {\n  switch (E->getStmtClass()) {\n  case Stmt::DeclRefExprClass:\n    return cast<DeclRefExpr>(E)->getDecl();\n  case Stmt::MemberExprClass:\n    // If this is an arrow operator, the address is an offset from\n    // the base's value, so the object the base refers to is\n    // irrelevant.\n    if (cast<MemberExpr>(E)->isArrow())\n      return nullptr;\n    // Otherwise, the expression refers to a part of the base\n    return getPrimaryDecl(cast<MemberExpr>(E)->getBase());\n  case Stmt::ArraySubscriptExprClass: {\n    // FIXME: This code shouldn't be necessary!  We should catch the implicit\n    // promotion of register arrays earlier.\n    Expr* Base = cast<ArraySubscriptExpr>(E)->getBase();\n    if (ImplicitCastExpr* ICE = dyn_cast<ImplicitCastExpr>(Base)) {\n      if (ICE->getSubExpr()->getType()->isArrayType())\n        return getPrimaryDecl(ICE->getSubExpr());\n    }\n    return nullptr;\n  }\n  case Stmt::UnaryOperatorClass: {\n    UnaryOperator *UO = cast<UnaryOperator>(E);\n\n    switch(UO->getOpcode()) {\n    case UO_Real:\n    case UO_Imag:\n    case UO_Extension:\n      return getPrimaryDecl(UO->getSubExpr());\n    default:\n      return nullptr;\n    }\n  }\n  case Stmt::ParenExprClass:\n    return getPrimaryDecl(cast<ParenExpr>(E)->getSubExpr());\n  case Stmt::ImplicitCastExprClass:\n    // If the result of an implicit cast is an l-value, we care about\n    // the sub-expression; otherwise, the result here doesn't matter.\n    return getPrimaryDecl(cast<ImplicitCastExpr>(E)->getSubExpr());\n  case Stmt::CXXUuidofExprClass:\n    return cast<CXXUuidofExpr>(E)->getGuidDecl();\n  default:\n    return nullptr;\n  }\n}\n\nnamespace {\nenum {\n  AO_Bit_Field = 0,\n  AO_Vector_Element = 1,\n  AO_Property_Expansion = 2,\n  AO_Register_Variable = 3,\n  AO_Matrix_Element = 4,\n  AO_No_Error = 5\n};\n}\n/// Diagnose invalid operand for address of operations.\n///\n/// \\param Type The type of operand which cannot have its address taken.\nstatic void diagnoseAddressOfInvalidType(Sema &S, SourceLocation Loc,\n                                         Expr *E, unsigned Type) {\n  S.Diag(Loc, diag::err_typecheck_address_of) << Type << E->getSourceRange();\n}\n\n/// CheckAddressOfOperand - The operand of & must be either a function\n/// designator or an lvalue designating an object. If it is an lvalue, the\n/// object cannot be declared with storage class register or be a bit field.\n/// Note: The usual conversions are *not* applied to the operand of the &\n/// operator (C99 6.3.2.1p[2-4]), and its result is never an lvalue.\n/// In C++, the operand might be an overloaded function name, in which case\n/// we allow the '&' but retain the overloaded-function type.\nQualType Sema::CheckAddressOfOperand(ExprResult &OrigOp, SourceLocation OpLoc) {\n  if (const BuiltinType *PTy = OrigOp.get()->getType()->getAsPlaceholderType()){\n    if (PTy->getKind() == BuiltinType::Overload) {\n      Expr *E = OrigOp.get()->IgnoreParens();\n      if (!isa<OverloadExpr>(E)) {\n        assert(cast<UnaryOperator>(E)->getOpcode() == UO_AddrOf);\n        Diag(OpLoc, diag::err_typecheck_invalid_lvalue_addrof_addrof_function)\n          << OrigOp.get()->getSourceRange();\n        return QualType();\n      }\n\n      OverloadExpr *Ovl = cast<OverloadExpr>(E);\n      if (isa<UnresolvedMemberExpr>(Ovl))\n        if (!ResolveSingleFunctionTemplateSpecialization(Ovl)) {\n          Diag(OpLoc, diag::err_invalid_form_pointer_member_function)\n            << OrigOp.get()->getSourceRange();\n          return QualType();\n        }\n\n      return Context.OverloadTy;\n    }\n\n    if (PTy->getKind() == BuiltinType::UnknownAny)\n      return Context.UnknownAnyTy;\n\n    if (PTy->getKind() == BuiltinType::BoundMember) {\n      Diag(OpLoc, diag::err_invalid_form_pointer_member_function)\n        << OrigOp.get()->getSourceRange();\n      return QualType();\n    }\n\n    OrigOp = CheckPlaceholderExpr(OrigOp.get());\n    if (OrigOp.isInvalid()) return QualType();\n  }\n\n  if (OrigOp.get()->isTypeDependent())\n    return Context.DependentTy;\n\n  assert(!OrigOp.get()->getType()->isPlaceholderType());\n\n  // Make sure to ignore parentheses in subsequent checks\n  Expr *op = OrigOp.get()->IgnoreParens();\n\n  // In OpenCL captures for blocks called as lambda functions\n  // are located in the private address space. Blocks used in\n  // enqueue_kernel can be located in a different address space\n  // depending on a vendor implementation. Thus preventing\n  // taking an address of the capture to avoid invalid AS casts.\n  if (LangOpts.OpenCL) {\n    auto* VarRef = dyn_cast<DeclRefExpr>(op);\n    if (VarRef && VarRef->refersToEnclosingVariableOrCapture()) {\n      Diag(op->getExprLoc(), diag::err_opencl_taking_address_capture);\n      return QualType();\n    }\n  }\n\n  if (getLangOpts().C99) {\n    // Implement C99-only parts of addressof rules.\n    if (UnaryOperator* uOp = dyn_cast<UnaryOperator>(op)) {\n      if (uOp->getOpcode() == UO_Deref)\n        // Per C99 6.5.3.2, the address of a deref always returns a valid result\n        // (assuming the deref expression is valid).\n        return uOp->getSubExpr()->getType();\n    }\n    // Technically, there should be a check for array subscript\n    // expressions here, but the result of one is always an lvalue anyway.\n  }\n  ValueDecl *dcl = getPrimaryDecl(op);\n\n  if (auto *FD = dyn_cast_or_null<FunctionDecl>(dcl))\n    if (!checkAddressOfFunctionIsAvailable(FD, /*Complain=*/true,\n                                           op->getBeginLoc()))\n      return QualType();\n\n  Expr::LValueClassification lval = op->ClassifyLValue(Context);\n  unsigned AddressOfError = AO_No_Error;\n\n  if (lval == Expr::LV_ClassTemporary || lval == Expr::LV_ArrayTemporary) {\n    bool sfinae = (bool)isSFINAEContext();\n    Diag(OpLoc, isSFINAEContext() ? diag::err_typecheck_addrof_temporary\n                                  : diag::ext_typecheck_addrof_temporary)\n      << op->getType() << op->getSourceRange();\n    if (sfinae)\n      return QualType();\n    // Materialize the temporary as an lvalue so that we can take its address.\n    OrigOp = op =\n        CreateMaterializeTemporaryExpr(op->getType(), OrigOp.get(), true);\n  } else if (isa<ObjCSelectorExpr>(op)) {\n    return Context.getPointerType(op->getType());\n  } else if (lval == Expr::LV_MemberFunction) {\n    // If it's an instance method, make a member pointer.\n    // The expression must have exactly the form &A::foo.\n\n    // If the underlying expression isn't a decl ref, give up.\n    if (!isa<DeclRefExpr>(op)) {\n      Diag(OpLoc, diag::err_invalid_form_pointer_member_function)\n        << OrigOp.get()->getSourceRange();\n      return QualType();\n    }\n    DeclRefExpr *DRE = cast<DeclRefExpr>(op);\n    CXXMethodDecl *MD = cast<CXXMethodDecl>(DRE->getDecl());\n\n    // The id-expression was parenthesized.\n    if (OrigOp.get() != DRE) {\n      Diag(OpLoc, diag::err_parens_pointer_member_function)\n        << OrigOp.get()->getSourceRange();\n\n    // The method was named without a qualifier.\n    } else if (!DRE->getQualifier()) {\n      if (MD->getParent()->getName().empty())\n        Diag(OpLoc, diag::err_unqualified_pointer_member_function)\n          << op->getSourceRange();\n      else {\n        SmallString<32> Str;\n        StringRef Qual = (MD->getParent()->getName() + \"::\").toStringRef(Str);\n        Diag(OpLoc, diag::err_unqualified_pointer_member_function)\n          << op->getSourceRange()\n          << FixItHint::CreateInsertion(op->getSourceRange().getBegin(), Qual);\n      }\n    }\n\n    // Taking the address of a dtor is illegal per C++ [class.dtor]p2.\n    if (isa<CXXDestructorDecl>(MD))\n      Diag(OpLoc, diag::err_typecheck_addrof_dtor) << op->getSourceRange();\n\n    QualType MPTy = Context.getMemberPointerType(\n        op->getType(), Context.getTypeDeclType(MD->getParent()).getTypePtr());\n    // Under the MS ABI, lock down the inheritance model now.\n    if (Context.getTargetInfo().getCXXABI().isMicrosoft())\n      (void)isCompleteType(OpLoc, MPTy);\n    return MPTy;\n  } else if (lval != Expr::LV_Valid && lval != Expr::LV_IncompleteVoidType) {\n    // C99 6.5.3.2p1\n    // The operand must be either an l-value or a function designator\n    if (!op->getType()->isFunctionType()) {\n      // Use a special diagnostic for loads from property references.\n      if (isa<PseudoObjectExpr>(op)) {\n        AddressOfError = AO_Property_Expansion;\n      } else {\n        Diag(OpLoc, diag::err_typecheck_invalid_lvalue_addrof)\n          << op->getType() << op->getSourceRange();\n        return QualType();\n      }\n    }\n  } else if (op->getObjectKind() == OK_BitField) { // C99 6.5.3.2p1\n    // The operand cannot be a bit-field\n    AddressOfError = AO_Bit_Field;\n  } else if (op->getObjectKind() == OK_VectorComponent) {\n    // The operand cannot be an element of a vector\n    AddressOfError = AO_Vector_Element;\n  } else if (op->getObjectKind() == OK_MatrixComponent) {\n    // The operand cannot be an element of a matrix.\n    AddressOfError = AO_Matrix_Element;\n  } else if (dcl) { // C99 6.5.3.2p1\n    // We have an lvalue with a decl. Make sure the decl is not declared\n    // with the register storage-class specifier.\n    if (const VarDecl *vd = dyn_cast<VarDecl>(dcl)) {\n      // in C++ it is not error to take address of a register\n      // variable (c++03 7.1.1P3)\n      if (vd->getStorageClass() == SC_Register &&\n          !getLangOpts().CPlusPlus) {\n        AddressOfError = AO_Register_Variable;\n      }\n    } else if (isa<MSPropertyDecl>(dcl)) {\n      AddressOfError = AO_Property_Expansion;\n    } else if (isa<FunctionTemplateDecl>(dcl)) {\n      return Context.OverloadTy;\n    } else if (isa<FieldDecl>(dcl) || isa<IndirectFieldDecl>(dcl)) {\n      // Okay: we can take the address of a field.\n      // Could be a pointer to member, though, if there is an explicit\n      // scope qualifier for the class.\n      if (isa<DeclRefExpr>(op) && cast<DeclRefExpr>(op)->getQualifier()) {\n        DeclContext *Ctx = dcl->getDeclContext();\n        if (Ctx && Ctx->isRecord()) {\n          if (dcl->getType()->isReferenceType()) {\n            Diag(OpLoc,\n                 diag::err_cannot_form_pointer_to_member_of_reference_type)\n              << dcl->getDeclName() << dcl->getType();\n            return QualType();\n          }\n\n          while (cast<RecordDecl>(Ctx)->isAnonymousStructOrUnion())\n            Ctx = Ctx->getParent();\n\n          QualType MPTy = Context.getMemberPointerType(\n              op->getType(),\n              Context.getTypeDeclType(cast<RecordDecl>(Ctx)).getTypePtr());\n          // Under the MS ABI, lock down the inheritance model now.\n          if (Context.getTargetInfo().getCXXABI().isMicrosoft())\n            (void)isCompleteType(OpLoc, MPTy);\n          return MPTy;\n        }\n      }\n    } else if (!isa<FunctionDecl>(dcl) && !isa<NonTypeTemplateParmDecl>(dcl) &&\n               !isa<BindingDecl>(dcl) && !isa<MSGuidDecl>(dcl))\n      llvm_unreachable(\"Unknown/unexpected decl type\");\n  }\n\n  if (AddressOfError != AO_No_Error) {\n    diagnoseAddressOfInvalidType(*this, OpLoc, op, AddressOfError);\n    return QualType();\n  }\n\n  if (lval == Expr::LV_IncompleteVoidType) {\n    // Taking the address of a void variable is technically illegal, but we\n    // allow it in cases which are otherwise valid.\n    // Example: \"extern void x; void* y = &x;\".\n    Diag(OpLoc, diag::ext_typecheck_addrof_void) << op->getSourceRange();\n  }\n\n  // If the operand has type \"type\", the result has type \"pointer to type\".\n  if (op->getType()->isObjCObjectType())\n    return Context.getObjCObjectPointerType(op->getType());\n\n  CheckAddressOfPackedMember(op);\n\n  return Context.getPointerType(op->getType());\n}\n\nstatic void RecordModifiableNonNullParam(Sema &S, const Expr *Exp) {\n  const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(Exp);\n  if (!DRE)\n    return;\n  const Decl *D = DRE->getDecl();\n  if (!D)\n    return;\n  const ParmVarDecl *Param = dyn_cast<ParmVarDecl>(D);\n  if (!Param)\n    return;\n  if (const FunctionDecl* FD = dyn_cast<FunctionDecl>(Param->getDeclContext()))\n    if (!FD->hasAttr<NonNullAttr>() && !Param->hasAttr<NonNullAttr>())\n      return;\n  if (FunctionScopeInfo *FD = S.getCurFunction())\n    if (!FD->ModifiedNonNullParams.count(Param))\n      FD->ModifiedNonNullParams.insert(Param);\n}\n\n/// CheckIndirectionOperand - Type check unary indirection (prefix '*').\nstatic QualType CheckIndirectionOperand(Sema &S, Expr *Op, ExprValueKind &VK,\n                                        SourceLocation OpLoc) {\n  if (Op->isTypeDependent())\n    return S.Context.DependentTy;\n\n  ExprResult ConvResult = S.UsualUnaryConversions(Op);\n  if (ConvResult.isInvalid())\n    return QualType();\n  Op = ConvResult.get();\n  QualType OpTy = Op->getType();\n  QualType Result;\n\n  if (isa<CXXReinterpretCastExpr>(Op)) {\n    QualType OpOrigType = Op->IgnoreParenCasts()->getType();\n    S.CheckCompatibleReinterpretCast(OpOrigType, OpTy, /*IsDereference*/true,\n                                     Op->getSourceRange());\n  }\n\n  if (const PointerType *PT = OpTy->getAs<PointerType>())\n  {\n    Result = PT->getPointeeType();\n  }\n  else if (const ObjCObjectPointerType *OPT =\n             OpTy->getAs<ObjCObjectPointerType>())\n    Result = OPT->getPointeeType();\n  else {\n    ExprResult PR = S.CheckPlaceholderExpr(Op);\n    if (PR.isInvalid()) return QualType();\n    if (PR.get() != Op)\n      return CheckIndirectionOperand(S, PR.get(), VK, OpLoc);\n  }\n\n  if (Result.isNull()) {\n    S.Diag(OpLoc, diag::err_typecheck_indirection_requires_pointer)\n      << OpTy << Op->getSourceRange();\n    return QualType();\n  }\n\n  // Note that per both C89 and C99, indirection is always legal, even if Result\n  // is an incomplete type or void.  It would be possible to warn about\n  // dereferencing a void pointer, but it's completely well-defined, and such a\n  // warning is unlikely to catch any mistakes. In C++, indirection is not valid\n  // for pointers to 'void' but is fine for any other pointer type:\n  //\n  // C++ [expr.unary.op]p1:\n  //   [...] the expression to which [the unary * operator] is applied shall\n  //   be a pointer to an object type, or a pointer to a function type\n  if (S.getLangOpts().CPlusPlus && Result->isVoidType())\n    S.Diag(OpLoc, diag::ext_typecheck_indirection_through_void_pointer)\n      << OpTy << Op->getSourceRange();\n\n  // Dereferences are usually l-values...\n  VK = VK_LValue;\n\n  // ...except that certain expressions are never l-values in C.\n  if (!S.getLangOpts().CPlusPlus && Result.isCForbiddenLValueType())\n    VK = VK_RValue;\n\n  return Result;\n}\n\nBinaryOperatorKind Sema::ConvertTokenKindToBinaryOpcode(tok::TokenKind Kind) {\n  BinaryOperatorKind Opc;\n  switch (Kind) {\n  default: llvm_unreachable(\"Unknown binop!\");\n  case tok::periodstar:           Opc = BO_PtrMemD; break;\n  case tok::arrowstar:            Opc = BO_PtrMemI; break;\n  case tok::star:                 Opc = BO_Mul; break;\n  case tok::slash:                Opc = BO_Div; break;\n  case tok::percent:              Opc = BO_Rem; break;\n  case tok::plus:                 Opc = BO_Add; break;\n  case tok::minus:                Opc = BO_Sub; break;\n  case tok::lessless:             Opc = BO_Shl; break;\n  case tok::greatergreater:       Opc = BO_Shr; break;\n  case tok::lessequal:            Opc = BO_LE; break;\n  case tok::less:                 Opc = BO_LT; break;\n  case tok::greaterequal:         Opc = BO_GE; break;\n  case tok::greater:              Opc = BO_GT; break;\n  case tok::exclaimequal:         Opc = BO_NE; break;\n  case tok::equalequal:           Opc = BO_EQ; break;\n  case tok::spaceship:            Opc = BO_Cmp; break;\n  case tok::amp:                  Opc = BO_And; break;\n  case tok::caret:                Opc = BO_Xor; break;\n  case tok::pipe:                 Opc = BO_Or; break;\n  case tok::ampamp:               Opc = BO_LAnd; break;\n  case tok::pipepipe:             Opc = BO_LOr; break;\n  case tok::equal:                Opc = BO_Assign; break;\n  case tok::starequal:            Opc = BO_MulAssign; break;\n  case tok::slashequal:           Opc = BO_DivAssign; break;\n  case tok::percentequal:         Opc = BO_RemAssign; break;\n  case tok::plusequal:            Opc = BO_AddAssign; break;\n  case tok::minusequal:           Opc = BO_SubAssign; break;\n  case tok::lesslessequal:        Opc = BO_ShlAssign; break;\n  case tok::greatergreaterequal:  Opc = BO_ShrAssign; break;\n  case tok::ampequal:             Opc = BO_AndAssign; break;\n  case tok::caretequal:           Opc = BO_XorAssign; break;\n  case tok::pipeequal:            Opc = BO_OrAssign; break;\n  case tok::comma:                Opc = BO_Comma; break;\n  }\n  return Opc;\n}\n\nstatic inline UnaryOperatorKind ConvertTokenKindToUnaryOpcode(\n  tok::TokenKind Kind) {\n  UnaryOperatorKind Opc;\n  switch (Kind) {\n  default: llvm_unreachable(\"Unknown unary op!\");\n  case tok::plusplus:     Opc = UO_PreInc; break;\n  case tok::minusminus:   Opc = UO_PreDec; break;\n  case tok::amp:          Opc = UO_AddrOf; break;\n  case tok::star:         Opc = UO_Deref; break;\n  case tok::plus:         Opc = UO_Plus; break;\n  case tok::minus:        Opc = UO_Minus; break;\n  case tok::tilde:        Opc = UO_Not; break;\n  case tok::exclaim:      Opc = UO_LNot; break;\n  case tok::kw___real:    Opc = UO_Real; break;\n  case tok::kw___imag:    Opc = UO_Imag; break;\n  case tok::kw___extension__: Opc = UO_Extension; break;\n  }\n  return Opc;\n}\n\n/// DiagnoseSelfAssignment - Emits a warning if a value is assigned to itself.\n/// This warning suppressed in the event of macro expansions.\nstatic void DiagnoseSelfAssignment(Sema &S, Expr *LHSExpr, Expr *RHSExpr,\n                                   SourceLocation OpLoc, bool IsBuiltin) {\n  if (S.inTemplateInstantiation())\n    return;\n  if (S.isUnevaluatedContext())\n    return;\n  if (OpLoc.isInvalid() || OpLoc.isMacroID())\n    return;\n  LHSExpr = LHSExpr->IgnoreParenImpCasts();\n  RHSExpr = RHSExpr->IgnoreParenImpCasts();\n  const DeclRefExpr *LHSDeclRef = dyn_cast<DeclRefExpr>(LHSExpr);\n  const DeclRefExpr *RHSDeclRef = dyn_cast<DeclRefExpr>(RHSExpr);\n  if (!LHSDeclRef || !RHSDeclRef ||\n      LHSDeclRef->getLocation().isMacroID() ||\n      RHSDeclRef->getLocation().isMacroID())\n    return;\n  const ValueDecl *LHSDecl =\n    cast<ValueDecl>(LHSDeclRef->getDecl()->getCanonicalDecl());\n  const ValueDecl *RHSDecl =\n    cast<ValueDecl>(RHSDeclRef->getDecl()->getCanonicalDecl());\n  if (LHSDecl != RHSDecl)\n    return;\n  if (LHSDecl->getType().isVolatileQualified())\n    return;\n  if (const ReferenceType *RefTy = LHSDecl->getType()->getAs<ReferenceType>())\n    if (RefTy->getPointeeType().isVolatileQualified())\n      return;\n\n  S.Diag(OpLoc, IsBuiltin ? diag::warn_self_assignment_builtin\n                          : diag::warn_self_assignment_overloaded)\n      << LHSDeclRef->getType() << LHSExpr->getSourceRange()\n      << RHSExpr->getSourceRange();\n}\n\n/// Check if a bitwise-& is performed on an Objective-C pointer.  This\n/// is usually indicative of introspection within the Objective-C pointer.\nstatic void checkObjCPointerIntrospection(Sema &S, ExprResult &L, ExprResult &R,\n                                          SourceLocation OpLoc) {\n  if (!S.getLangOpts().ObjC)\n    return;\n\n  const Expr *ObjCPointerExpr = nullptr, *OtherExpr = nullptr;\n  const Expr *LHS = L.get();\n  const Expr *RHS = R.get();\n\n  if (LHS->IgnoreParenCasts()->getType()->isObjCObjectPointerType()) {\n    ObjCPointerExpr = LHS;\n    OtherExpr = RHS;\n  }\n  else if (RHS->IgnoreParenCasts()->getType()->isObjCObjectPointerType()) {\n    ObjCPointerExpr = RHS;\n    OtherExpr = LHS;\n  }\n\n  // This warning is deliberately made very specific to reduce false\n  // positives with logic that uses '&' for hashing.  This logic mainly\n  // looks for code trying to introspect into tagged pointers, which\n  // code should generally never do.\n  if (ObjCPointerExpr && isa<IntegerLiteral>(OtherExpr->IgnoreParenCasts())) {\n    unsigned Diag = diag::warn_objc_pointer_masking;\n    // Determine if we are introspecting the result of performSelectorXXX.\n    const Expr *Ex = ObjCPointerExpr->IgnoreParenCasts();\n    // Special case messages to -performSelector and friends, which\n    // can return non-pointer values boxed in a pointer value.\n    // Some clients may wish to silence warnings in this subcase.\n    if (const ObjCMessageExpr *ME = dyn_cast<ObjCMessageExpr>(Ex)) {\n      Selector S = ME->getSelector();\n      StringRef SelArg0 = S.getNameForSlot(0);\n      if (SelArg0.startswith(\"performSelector\"))\n        Diag = diag::warn_objc_pointer_masking_performSelector;\n    }\n\n    S.Diag(OpLoc, Diag)\n      << ObjCPointerExpr->getSourceRange();\n  }\n}\n\nstatic NamedDecl *getDeclFromExpr(Expr *E) {\n  if (!E)\n    return nullptr;\n  if (auto *DRE = dyn_cast<DeclRefExpr>(E))\n    return DRE->getDecl();\n  if (auto *ME = dyn_cast<MemberExpr>(E))\n    return ME->getMemberDecl();\n  if (auto *IRE = dyn_cast<ObjCIvarRefExpr>(E))\n    return IRE->getDecl();\n  return nullptr;\n}\n\n// This helper function promotes a binary operator's operands (which are of a\n// half vector type) to a vector of floats and then truncates the result to\n// a vector of either half or short.\nstatic ExprResult convertHalfVecBinOp(Sema &S, ExprResult LHS, ExprResult RHS,\n                                      BinaryOperatorKind Opc, QualType ResultTy,\n                                      ExprValueKind VK, ExprObjectKind OK,\n                                      bool IsCompAssign, SourceLocation OpLoc,\n                                      FPOptionsOverride FPFeatures) {\n  auto &Context = S.getASTContext();\n  assert((isVector(ResultTy, Context.HalfTy) ||\n          isVector(ResultTy, Context.ShortTy)) &&\n         \"Result must be a vector of half or short\");\n  assert(isVector(LHS.get()->getType(), Context.HalfTy) &&\n         isVector(RHS.get()->getType(), Context.HalfTy) &&\n         \"both operands expected to be a half vector\");\n\n  RHS = convertVector(RHS.get(), Context.FloatTy, S);\n  QualType BinOpResTy = RHS.get()->getType();\n\n  // If Opc is a comparison, ResultType is a vector of shorts. In that case,\n  // change BinOpResTy to a vector of ints.\n  if (isVector(ResultTy, Context.ShortTy))\n    BinOpResTy = S.GetSignedVectorType(BinOpResTy);\n\n  if (IsCompAssign)\n    return CompoundAssignOperator::Create(Context, LHS.get(), RHS.get(), Opc,\n                                          ResultTy, VK, OK, OpLoc, FPFeatures,\n                                          BinOpResTy, BinOpResTy);\n\n  LHS = convertVector(LHS.get(), Context.FloatTy, S);\n  auto *BO = BinaryOperator::Create(Context, LHS.get(), RHS.get(), Opc,\n                                    BinOpResTy, VK, OK, OpLoc, FPFeatures);\n  return convertVector(BO, ResultTy->castAs<VectorType>()->getElementType(), S);\n}\n\nstatic std::pair<ExprResult, ExprResult>\nCorrectDelayedTyposInBinOp(Sema &S, BinaryOperatorKind Opc, Expr *LHSExpr,\n                           Expr *RHSExpr) {\n  ExprResult LHS = LHSExpr, RHS = RHSExpr;\n  if (!S.Context.isDependenceAllowed()) {\n    // C cannot handle TypoExpr nodes on either side of a binop because it\n    // doesn't handle dependent types properly, so make sure any TypoExprs have\n    // been dealt with before checking the operands.\n    LHS = S.CorrectDelayedTyposInExpr(LHS);\n    RHS = S.CorrectDelayedTyposInExpr(\n        RHS, /*InitDecl=*/nullptr, /*RecoverUncorrectedTypos=*/false,\n        [Opc, LHS](Expr *E) {\n          if (Opc != BO_Assign)\n            return ExprResult(E);\n          // Avoid correcting the RHS to the same Expr as the LHS.\n          Decl *D = getDeclFromExpr(E);\n          return (D && D == getDeclFromExpr(LHS.get())) ? ExprError() : E;\n        });\n  }\n  return std::make_pair(LHS, RHS);\n}\n\n/// Returns true if conversion between vectors of halfs and vectors of floats\n/// is needed.\nstatic bool needsConversionOfHalfVec(bool OpRequiresConversion, ASTContext &Ctx,\n                                     Expr *E0, Expr *E1 = nullptr) {\n  if (!OpRequiresConversion || Ctx.getLangOpts().NativeHalfType ||\n      Ctx.getTargetInfo().useFP16ConversionIntrinsics())\n    return false;\n\n  auto HasVectorOfHalfType = [&Ctx](Expr *E) {\n    QualType Ty = E->IgnoreImplicit()->getType();\n\n    // Don't promote half precision neon vectors like float16x4_t in arm_neon.h\n    // to vectors of floats. Although the element type of the vectors is __fp16,\n    // the vectors shouldn't be treated as storage-only types. See the\n    // discussion here: https://reviews.llvm.org/rG825235c140e7\n    if (const VectorType *VT = Ty->getAs<VectorType>()) {\n      if (VT->getVectorKind() == VectorType::NeonVector)\n        return false;\n      return VT->getElementType().getCanonicalType() == Ctx.HalfTy;\n    }\n    return false;\n  };\n\n  return HasVectorOfHalfType(E0) && (!E1 || HasVectorOfHalfType(E1));\n}\n\n/// CreateBuiltinBinOp - Creates a new built-in binary operation with\n/// operator @p Opc at location @c TokLoc. This routine only supports\n/// built-in operations; ActOnBinOp handles overloaded operators.\nExprResult Sema::CreateBuiltinBinOp(SourceLocation OpLoc,\n                                    BinaryOperatorKind Opc,\n                                    Expr *LHSExpr, Expr *RHSExpr) {\n  if (getLangOpts().CPlusPlus11 && isa<InitListExpr>(RHSExpr)) {\n    // The syntax only allows initializer lists on the RHS of assignment,\n    // so we don't need to worry about accepting invalid code for\n    // non-assignment operators.\n    // C++11 5.17p9:\n    //   The meaning of x = {v} [...] is that of x = T(v) [...]. The meaning\n    //   of x = {} is x = T().\n    InitializationKind Kind = InitializationKind::CreateDirectList(\n        RHSExpr->getBeginLoc(), RHSExpr->getBeginLoc(), RHSExpr->getEndLoc());\n    InitializedEntity Entity =\n        InitializedEntity::InitializeTemporary(LHSExpr->getType());\n    InitializationSequence InitSeq(*this, Entity, Kind, RHSExpr);\n    ExprResult Init = InitSeq.Perform(*this, Entity, Kind, RHSExpr);\n    if (Init.isInvalid())\n      return Init;\n    RHSExpr = Init.get();\n  }\n\n  ExprResult LHS = LHSExpr, RHS = RHSExpr;\n  QualType ResultTy;     // Result type of the binary operator.\n  // The following two variables are used for compound assignment operators\n  QualType CompLHSTy;    // Type of LHS after promotions for computation\n  QualType CompResultTy; // Type of computation result\n  ExprValueKind VK = VK_RValue;\n  ExprObjectKind OK = OK_Ordinary;\n  bool ConvertHalfVec = false;\n\n  std::tie(LHS, RHS) = CorrectDelayedTyposInBinOp(*this, Opc, LHSExpr, RHSExpr);\n  if (!LHS.isUsable() || !RHS.isUsable())\n    return ExprError();\n\n  if (getLangOpts().OpenCL) {\n    QualType LHSTy = LHSExpr->getType();\n    QualType RHSTy = RHSExpr->getType();\n    // OpenCLC v2.0 s6.13.11.1 allows atomic variables to be initialized by\n    // the ATOMIC_VAR_INIT macro.\n    if (LHSTy->isAtomicType() || RHSTy->isAtomicType()) {\n      SourceRange SR(LHSExpr->getBeginLoc(), RHSExpr->getEndLoc());\n      if (BO_Assign == Opc)\n        Diag(OpLoc, diag::err_opencl_atomic_init) << 0 << SR;\n      else\n        ResultTy = InvalidOperands(OpLoc, LHS, RHS);\n      return ExprError();\n    }\n\n    // OpenCL special types - image, sampler, pipe, and blocks are to be used\n    // only with a builtin functions and therefore should be disallowed here.\n    if (LHSTy->isImageType() || RHSTy->isImageType() ||\n        LHSTy->isSamplerT() || RHSTy->isSamplerT() ||\n        LHSTy->isPipeType() || RHSTy->isPipeType() ||\n        LHSTy->isBlockPointerType() || RHSTy->isBlockPointerType()) {\n      ResultTy = InvalidOperands(OpLoc, LHS, RHS);\n      return ExprError();\n    }\n  }\n\n  switch (Opc) {\n  case BO_Assign:\n    ResultTy = CheckAssignmentOperands(LHS.get(), RHS, OpLoc, QualType());\n    if (getLangOpts().CPlusPlus &&\n        LHS.get()->getObjectKind() != OK_ObjCProperty) {\n      VK = LHS.get()->getValueKind();\n      OK = LHS.get()->getObjectKind();\n    }\n    if (!ResultTy.isNull()) {\n      DiagnoseSelfAssignment(*this, LHS.get(), RHS.get(), OpLoc, true);\n      DiagnoseSelfMove(LHS.get(), RHS.get(), OpLoc);\n\n      // Avoid copying a block to the heap if the block is assigned to a local\n      // auto variable that is declared in the same scope as the block. This\n      // optimization is unsafe if the local variable is declared in an outer\n      // scope. For example:\n      //\n      // BlockTy b;\n      // {\n      //   b = ^{...};\n      // }\n      // // It is unsafe to invoke the block here if it wasn't copied to the\n      // // heap.\n      // b();\n\n      if (auto *BE = dyn_cast<BlockExpr>(RHS.get()->IgnoreParens()))\n        if (auto *DRE = dyn_cast<DeclRefExpr>(LHS.get()->IgnoreParens()))\n          if (auto *VD = dyn_cast<VarDecl>(DRE->getDecl()))\n            if (VD->hasLocalStorage() && getCurScope()->isDeclScope(VD))\n              BE->getBlockDecl()->setCanAvoidCopyToHeap();\n\n      if (LHS.get()->getType().hasNonTrivialToPrimitiveCopyCUnion())\n        checkNonTrivialCUnion(LHS.get()->getType(), LHS.get()->getExprLoc(),\n                              NTCUC_Assignment, NTCUK_Copy);\n    }\n    RecordModifiableNonNullParam(*this, LHS.get());\n    break;\n  case BO_PtrMemD:\n  case BO_PtrMemI:\n    ResultTy = CheckPointerToMemberOperands(LHS, RHS, VK, OpLoc,\n                                            Opc == BO_PtrMemI);\n    break;\n  case BO_Mul:\n  case BO_Div:\n    ConvertHalfVec = true;\n    ResultTy = CheckMultiplyDivideOperands(LHS, RHS, OpLoc, false,\n                                           Opc == BO_Div);\n    break;\n  case BO_Rem:\n    ResultTy = CheckRemainderOperands(LHS, RHS, OpLoc);\n    break;\n  case BO_Add:\n    ConvertHalfVec = true;\n    ResultTy = CheckAdditionOperands(LHS, RHS, OpLoc, Opc);\n    break;\n  case BO_Sub:\n    ConvertHalfVec = true;\n    ResultTy = CheckSubtractionOperands(LHS, RHS, OpLoc);\n    break;\n  case BO_Shl:\n  case BO_Shr:\n    ResultTy = CheckShiftOperands(LHS, RHS, OpLoc, Opc);\n    break;\n  case BO_LE:\n  case BO_LT:\n  case BO_GE:\n  case BO_GT:\n    ConvertHalfVec = true;\n    ResultTy = CheckCompareOperands(LHS, RHS, OpLoc, Opc);\n    break;\n  case BO_EQ:\n  case BO_NE:\n    ConvertHalfVec = true;\n    ResultTy = CheckCompareOperands(LHS, RHS, OpLoc, Opc);\n    break;\n  case BO_Cmp:\n    ConvertHalfVec = true;\n    ResultTy = CheckCompareOperands(LHS, RHS, OpLoc, Opc);\n    assert(ResultTy.isNull() || ResultTy->getAsCXXRecordDecl());\n    break;\n  case BO_And:\n    checkObjCPointerIntrospection(*this, LHS, RHS, OpLoc);\n    LLVM_FALLTHROUGH;\n  case BO_Xor:\n  case BO_Or:\n    ResultTy = CheckBitwiseOperands(LHS, RHS, OpLoc, Opc);\n    break;\n  case BO_LAnd:\n  case BO_LOr:\n    ConvertHalfVec = true;\n    ResultTy = CheckLogicalOperands(LHS, RHS, OpLoc, Opc);\n    break;\n  case BO_MulAssign:\n  case BO_DivAssign:\n    ConvertHalfVec = true;\n    CompResultTy = CheckMultiplyDivideOperands(LHS, RHS, OpLoc, true,\n                                               Opc == BO_DivAssign);\n    CompLHSTy = CompResultTy;\n    if (!CompResultTy.isNull() && !LHS.isInvalid() && !RHS.isInvalid())\n      ResultTy = CheckAssignmentOperands(LHS.get(), RHS, OpLoc, CompResultTy);\n    break;\n  case BO_RemAssign:\n    CompResultTy = CheckRemainderOperands(LHS, RHS, OpLoc, true);\n    CompLHSTy = CompResultTy;\n    if (!CompResultTy.isNull() && !LHS.isInvalid() && !RHS.isInvalid())\n      ResultTy = CheckAssignmentOperands(LHS.get(), RHS, OpLoc, CompResultTy);\n    break;\n  case BO_AddAssign:\n    ConvertHalfVec = true;\n    CompResultTy = CheckAdditionOperands(LHS, RHS, OpLoc, Opc, &CompLHSTy);\n    if (!CompResultTy.isNull() && !LHS.isInvalid() && !RHS.isInvalid())\n      ResultTy = CheckAssignmentOperands(LHS.get(), RHS, OpLoc, CompResultTy);\n    break;\n  case BO_SubAssign:\n    ConvertHalfVec = true;\n    CompResultTy = CheckSubtractionOperands(LHS, RHS, OpLoc, &CompLHSTy);\n    if (!CompResultTy.isNull() && !LHS.isInvalid() && !RHS.isInvalid())\n      ResultTy = CheckAssignmentOperands(LHS.get(), RHS, OpLoc, CompResultTy);\n    break;\n  case BO_ShlAssign:\n  case BO_ShrAssign:\n    CompResultTy = CheckShiftOperands(LHS, RHS, OpLoc, Opc, true);\n    CompLHSTy = CompResultTy;\n    if (!CompResultTy.isNull() && !LHS.isInvalid() && !RHS.isInvalid())\n      ResultTy = CheckAssignmentOperands(LHS.get(), RHS, OpLoc, CompResultTy);\n    break;\n  case BO_AndAssign:\n  case BO_OrAssign: // fallthrough\n    DiagnoseSelfAssignment(*this, LHS.get(), RHS.get(), OpLoc, true);\n    LLVM_FALLTHROUGH;\n  case BO_XorAssign:\n    CompResultTy = CheckBitwiseOperands(LHS, RHS, OpLoc, Opc);\n    CompLHSTy = CompResultTy;\n    if (!CompResultTy.isNull() && !LHS.isInvalid() && !RHS.isInvalid())\n      ResultTy = CheckAssignmentOperands(LHS.get(), RHS, OpLoc, CompResultTy);\n    break;\n  case BO_Comma:\n    ResultTy = CheckCommaOperands(*this, LHS, RHS, OpLoc);\n    if (getLangOpts().CPlusPlus && !RHS.isInvalid()) {\n      VK = RHS.get()->getValueKind();\n      OK = RHS.get()->getObjectKind();\n    }\n    break;\n  }\n  if (ResultTy.isNull() || LHS.isInvalid() || RHS.isInvalid())\n    return ExprError();\n\n  // Some of the binary operations require promoting operands of half vector to\n  // float vectors and truncating the result back to half vector. For now, we do\n  // this only when HalfArgsAndReturn is set (that is, when the target is arm or\n  // arm64).\n  assert(\n      (Opc == BO_Comma || isVector(RHS.get()->getType(), Context.HalfTy) ==\n                              isVector(LHS.get()->getType(), Context.HalfTy)) &&\n      \"both sides are half vectors or neither sides are\");\n  ConvertHalfVec =\n      needsConversionOfHalfVec(ConvertHalfVec, Context, LHS.get(), RHS.get());\n\n  // Check for array bounds violations for both sides of the BinaryOperator\n  CheckArrayAccess(LHS.get());\n  CheckArrayAccess(RHS.get());\n\n  if (const ObjCIsaExpr *OISA = dyn_cast<ObjCIsaExpr>(LHS.get()->IgnoreParenCasts())) {\n    NamedDecl *ObjectSetClass = LookupSingleName(TUScope,\n                                                 &Context.Idents.get(\"object_setClass\"),\n                                                 SourceLocation(), LookupOrdinaryName);\n    if (ObjectSetClass && isa<ObjCIsaExpr>(LHS.get())) {\n      SourceLocation RHSLocEnd = getLocForEndOfToken(RHS.get()->getEndLoc());\n      Diag(LHS.get()->getExprLoc(), diag::warn_objc_isa_assign)\n          << FixItHint::CreateInsertion(LHS.get()->getBeginLoc(),\n                                        \"object_setClass(\")\n          << FixItHint::CreateReplacement(SourceRange(OISA->getOpLoc(), OpLoc),\n                                          \",\")\n          << FixItHint::CreateInsertion(RHSLocEnd, \")\");\n    }\n    else\n      Diag(LHS.get()->getExprLoc(), diag::warn_objc_isa_assign);\n  }\n  else if (const ObjCIvarRefExpr *OIRE =\n           dyn_cast<ObjCIvarRefExpr>(LHS.get()->IgnoreParenCasts()))\n    DiagnoseDirectIsaAccess(*this, OIRE, OpLoc, RHS.get());\n\n  // Opc is not a compound assignment if CompResultTy is null.\n  if (CompResultTy.isNull()) {\n    if (ConvertHalfVec)\n      return convertHalfVecBinOp(*this, LHS, RHS, Opc, ResultTy, VK, OK, false,\n                                 OpLoc, CurFPFeatureOverrides());\n    return BinaryOperator::Create(Context, LHS.get(), RHS.get(), Opc, ResultTy,\n                                  VK, OK, OpLoc, CurFPFeatureOverrides());\n  }\n\n  // Handle compound assignments.\n  if (getLangOpts().CPlusPlus && LHS.get()->getObjectKind() !=\n      OK_ObjCProperty) {\n    VK = VK_LValue;\n    OK = LHS.get()->getObjectKind();\n  }\n\n  // The LHS is not converted to the result type for fixed-point compound\n  // assignment as the common type is computed on demand. Reset the CompLHSTy\n  // to the LHS type we would have gotten after unary conversions.\n  if (CompResultTy->isFixedPointType())\n    CompLHSTy = UsualUnaryConversions(LHS.get()).get()->getType();\n\n  if (ConvertHalfVec)\n    return convertHalfVecBinOp(*this, LHS, RHS, Opc, ResultTy, VK, OK, true,\n                               OpLoc, CurFPFeatureOverrides());\n\n  return CompoundAssignOperator::Create(\n      Context, LHS.get(), RHS.get(), Opc, ResultTy, VK, OK, OpLoc,\n      CurFPFeatureOverrides(), CompLHSTy, CompResultTy);\n}\n\n/// DiagnoseBitwisePrecedence - Emit a warning when bitwise and comparison\n/// operators are mixed in a way that suggests that the programmer forgot that\n/// comparison operators have higher precedence. The most typical example of\n/// such code is \"flags & 0x0020 != 0\", which is equivalent to \"flags & 1\".\nstatic void DiagnoseBitwisePrecedence(Sema &Self, BinaryOperatorKind Opc,\n                                      SourceLocation OpLoc, Expr *LHSExpr,\n                                      Expr *RHSExpr) {\n  BinaryOperator *LHSBO = dyn_cast<BinaryOperator>(LHSExpr);\n  BinaryOperator *RHSBO = dyn_cast<BinaryOperator>(RHSExpr);\n\n  // Check that one of the sides is a comparison operator and the other isn't.\n  bool isLeftComp = LHSBO && LHSBO->isComparisonOp();\n  bool isRightComp = RHSBO && RHSBO->isComparisonOp();\n  if (isLeftComp == isRightComp)\n    return;\n\n  // Bitwise operations are sometimes used as eager logical ops.\n  // Don't diagnose this.\n  bool isLeftBitwise = LHSBO && LHSBO->isBitwiseOp();\n  bool isRightBitwise = RHSBO && RHSBO->isBitwiseOp();\n  if (isLeftBitwise || isRightBitwise)\n    return;\n\n  SourceRange DiagRange = isLeftComp\n                              ? SourceRange(LHSExpr->getBeginLoc(), OpLoc)\n                              : SourceRange(OpLoc, RHSExpr->getEndLoc());\n  StringRef OpStr = isLeftComp ? LHSBO->getOpcodeStr() : RHSBO->getOpcodeStr();\n  SourceRange ParensRange =\n      isLeftComp\n          ? SourceRange(LHSBO->getRHS()->getBeginLoc(), RHSExpr->getEndLoc())\n          : SourceRange(LHSExpr->getBeginLoc(), RHSBO->getLHS()->getEndLoc());\n\n  Self.Diag(OpLoc, diag::warn_precedence_bitwise_rel)\n    << DiagRange << BinaryOperator::getOpcodeStr(Opc) << OpStr;\n  SuggestParentheses(Self, OpLoc,\n    Self.PDiag(diag::note_precedence_silence) << OpStr,\n    (isLeftComp ? LHSExpr : RHSExpr)->getSourceRange());\n  SuggestParentheses(Self, OpLoc,\n    Self.PDiag(diag::note_precedence_bitwise_first)\n      << BinaryOperator::getOpcodeStr(Opc),\n    ParensRange);\n}\n\n/// It accepts a '&&' expr that is inside a '||' one.\n/// Emit a diagnostic together with a fixit hint that wraps the '&&' expression\n/// in parentheses.\nstatic void\nEmitDiagnosticForLogicalAndInLogicalOr(Sema &Self, SourceLocation OpLoc,\n                                       BinaryOperator *Bop) {\n  assert(Bop->getOpcode() == BO_LAnd);\n  Self.Diag(Bop->getOperatorLoc(), diag::warn_logical_and_in_logical_or)\n      << Bop->getSourceRange() << OpLoc;\n  SuggestParentheses(Self, Bop->getOperatorLoc(),\n    Self.PDiag(diag::note_precedence_silence)\n      << Bop->getOpcodeStr(),\n    Bop->getSourceRange());\n}\n\n/// Returns true if the given expression can be evaluated as a constant\n/// 'true'.\nstatic bool EvaluatesAsTrue(Sema &S, Expr *E) {\n  bool Res;\n  return !E->isValueDependent() &&\n         E->EvaluateAsBooleanCondition(Res, S.getASTContext()) && Res;\n}\n\n/// Returns true if the given expression can be evaluated as a constant\n/// 'false'.\nstatic bool EvaluatesAsFalse(Sema &S, Expr *E) {\n  bool Res;\n  return !E->isValueDependent() &&\n         E->EvaluateAsBooleanCondition(Res, S.getASTContext()) && !Res;\n}\n\n/// Look for '&&' in the left hand of a '||' expr.\nstatic void DiagnoseLogicalAndInLogicalOrLHS(Sema &S, SourceLocation OpLoc,\n                                             Expr *LHSExpr, Expr *RHSExpr) {\n  if (BinaryOperator *Bop = dyn_cast<BinaryOperator>(LHSExpr)) {\n    if (Bop->getOpcode() == BO_LAnd) {\n      // If it's \"a && b || 0\" don't warn since the precedence doesn't matter.\n      if (EvaluatesAsFalse(S, RHSExpr))\n        return;\n      // If it's \"1 && a || b\" don't warn since the precedence doesn't matter.\n      if (!EvaluatesAsTrue(S, Bop->getLHS()))\n        return EmitDiagnosticForLogicalAndInLogicalOr(S, OpLoc, Bop);\n    } else if (Bop->getOpcode() == BO_LOr) {\n      if (BinaryOperator *RBop = dyn_cast<BinaryOperator>(Bop->getRHS())) {\n        // If it's \"a || b && 1 || c\" we didn't warn earlier for\n        // \"a || b && 1\", but warn now.\n        if (RBop->getOpcode() == BO_LAnd && EvaluatesAsTrue(S, RBop->getRHS()))\n          return EmitDiagnosticForLogicalAndInLogicalOr(S, OpLoc, RBop);\n      }\n    }\n  }\n}\n\n/// Look for '&&' in the right hand of a '||' expr.\nstatic void DiagnoseLogicalAndInLogicalOrRHS(Sema &S, SourceLocation OpLoc,\n                                             Expr *LHSExpr, Expr *RHSExpr) {\n  if (BinaryOperator *Bop = dyn_cast<BinaryOperator>(RHSExpr)) {\n    if (Bop->getOpcode() == BO_LAnd) {\n      // If it's \"0 || a && b\" don't warn since the precedence doesn't matter.\n      if (EvaluatesAsFalse(S, LHSExpr))\n        return;\n      // If it's \"a || b && 1\" don't warn since the precedence doesn't matter.\n      if (!EvaluatesAsTrue(S, Bop->getRHS()))\n        return EmitDiagnosticForLogicalAndInLogicalOr(S, OpLoc, Bop);\n    }\n  }\n}\n\n/// Look for bitwise op in the left or right hand of a bitwise op with\n/// lower precedence and emit a diagnostic together with a fixit hint that wraps\n/// the '&' expression in parentheses.\nstatic void DiagnoseBitwiseOpInBitwiseOp(Sema &S, BinaryOperatorKind Opc,\n                                         SourceLocation OpLoc, Expr *SubExpr) {\n  if (BinaryOperator *Bop = dyn_cast<BinaryOperator>(SubExpr)) {\n    if (Bop->isBitwiseOp() && Bop->getOpcode() < Opc) {\n      S.Diag(Bop->getOperatorLoc(), diag::warn_bitwise_op_in_bitwise_op)\n        << Bop->getOpcodeStr() << BinaryOperator::getOpcodeStr(Opc)\n        << Bop->getSourceRange() << OpLoc;\n      SuggestParentheses(S, Bop->getOperatorLoc(),\n        S.PDiag(diag::note_precedence_silence)\n          << Bop->getOpcodeStr(),\n        Bop->getSourceRange());\n    }\n  }\n}\n\nstatic void DiagnoseAdditionInShift(Sema &S, SourceLocation OpLoc,\n                                    Expr *SubExpr, StringRef Shift) {\n  if (BinaryOperator *Bop = dyn_cast<BinaryOperator>(SubExpr)) {\n    if (Bop->getOpcode() == BO_Add || Bop->getOpcode() == BO_Sub) {\n      StringRef Op = Bop->getOpcodeStr();\n      S.Diag(Bop->getOperatorLoc(), diag::warn_addition_in_bitshift)\n          << Bop->getSourceRange() << OpLoc << Shift << Op;\n      SuggestParentheses(S, Bop->getOperatorLoc(),\n          S.PDiag(diag::note_precedence_silence) << Op,\n          Bop->getSourceRange());\n    }\n  }\n}\n\nstatic void DiagnoseShiftCompare(Sema &S, SourceLocation OpLoc,\n                                 Expr *LHSExpr, Expr *RHSExpr) {\n  CXXOperatorCallExpr *OCE = dyn_cast<CXXOperatorCallExpr>(LHSExpr);\n  if (!OCE)\n    return;\n\n  FunctionDecl *FD = OCE->getDirectCallee();\n  if (!FD || !FD->isOverloadedOperator())\n    return;\n\n  OverloadedOperatorKind Kind = FD->getOverloadedOperator();\n  if (Kind != OO_LessLess && Kind != OO_GreaterGreater)\n    return;\n\n  S.Diag(OpLoc, diag::warn_overloaded_shift_in_comparison)\n      << LHSExpr->getSourceRange() << RHSExpr->getSourceRange()\n      << (Kind == OO_LessLess);\n  SuggestParentheses(S, OCE->getOperatorLoc(),\n                     S.PDiag(diag::note_precedence_silence)\n                         << (Kind == OO_LessLess ? \"<<\" : \">>\"),\n                     OCE->getSourceRange());\n  SuggestParentheses(\n      S, OpLoc, S.PDiag(diag::note_evaluate_comparison_first),\n      SourceRange(OCE->getArg(1)->getBeginLoc(), RHSExpr->getEndLoc()));\n}\n\n/// DiagnoseBinOpPrecedence - Emit warnings for expressions with tricky\n/// precedence.\nstatic void DiagnoseBinOpPrecedence(Sema &Self, BinaryOperatorKind Opc,\n                                    SourceLocation OpLoc, Expr *LHSExpr,\n                                    Expr *RHSExpr){\n  // Diagnose \"arg1 'bitwise' arg2 'eq' arg3\".\n  if (BinaryOperator::isBitwiseOp(Opc))\n    DiagnoseBitwisePrecedence(Self, Opc, OpLoc, LHSExpr, RHSExpr);\n\n  // Diagnose \"arg1 & arg2 | arg3\"\n  if ((Opc == BO_Or || Opc == BO_Xor) &&\n      !OpLoc.isMacroID()/* Don't warn in macros. */) {\n    DiagnoseBitwiseOpInBitwiseOp(Self, Opc, OpLoc, LHSExpr);\n    DiagnoseBitwiseOpInBitwiseOp(Self, Opc, OpLoc, RHSExpr);\n  }\n\n  // Warn about arg1 || arg2 && arg3, as GCC 4.3+ does.\n  // We don't warn for 'assert(a || b && \"bad\")' since this is safe.\n  if (Opc == BO_LOr && !OpLoc.isMacroID()/* Don't warn in macros. */) {\n    DiagnoseLogicalAndInLogicalOrLHS(Self, OpLoc, LHSExpr, RHSExpr);\n    DiagnoseLogicalAndInLogicalOrRHS(Self, OpLoc, LHSExpr, RHSExpr);\n  }\n\n  if ((Opc == BO_Shl && LHSExpr->getType()->isIntegralType(Self.getASTContext()))\n      || Opc == BO_Shr) {\n    StringRef Shift = BinaryOperator::getOpcodeStr(Opc);\n    DiagnoseAdditionInShift(Self, OpLoc, LHSExpr, Shift);\n    DiagnoseAdditionInShift(Self, OpLoc, RHSExpr, Shift);\n  }\n\n  // Warn on overloaded shift operators and comparisons, such as:\n  // cout << 5 == 4;\n  if (BinaryOperator::isComparisonOp(Opc))\n    DiagnoseShiftCompare(Self, OpLoc, LHSExpr, RHSExpr);\n}\n\n// Binary Operators.  'Tok' is the token for the operator.\nExprResult Sema::ActOnBinOp(Scope *S, SourceLocation TokLoc,\n                            tok::TokenKind Kind,\n                            Expr *LHSExpr, Expr *RHSExpr) {\n  BinaryOperatorKind Opc = ConvertTokenKindToBinaryOpcode(Kind);\n  assert(LHSExpr && \"ActOnBinOp(): missing left expression\");\n  assert(RHSExpr && \"ActOnBinOp(): missing right expression\");\n\n  // Emit warnings for tricky precedence issues, e.g. \"bitfield & 0x4 == 0\"\n  DiagnoseBinOpPrecedence(*this, Opc, TokLoc, LHSExpr, RHSExpr);\n\n  return BuildBinOp(S, TokLoc, Opc, LHSExpr, RHSExpr);\n}\n\nvoid Sema::LookupBinOp(Scope *S, SourceLocation OpLoc, BinaryOperatorKind Opc,\n                       UnresolvedSetImpl &Functions) {\n  OverloadedOperatorKind OverOp = BinaryOperator::getOverloadedOperator(Opc);\n  if (OverOp != OO_None && OverOp != OO_Equal)\n    LookupOverloadedOperatorName(OverOp, S, Functions);\n\n  // In C++20 onwards, we may have a second operator to look up.\n  if (getLangOpts().CPlusPlus20) {\n    if (OverloadedOperatorKind ExtraOp = getRewrittenOverloadedOperator(OverOp))\n      LookupOverloadedOperatorName(ExtraOp, S, Functions);\n  }\n}\n\n/// Build an overloaded binary operator expression in the given scope.\nstatic ExprResult BuildOverloadedBinOp(Sema &S, Scope *Sc, SourceLocation OpLoc,\n                                       BinaryOperatorKind Opc,\n                                       Expr *LHS, Expr *RHS) {\n  switch (Opc) {\n  case BO_Assign:\n  case BO_DivAssign:\n  case BO_RemAssign:\n  case BO_SubAssign:\n  case BO_AndAssign:\n  case BO_OrAssign:\n  case BO_XorAssign:\n    DiagnoseSelfAssignment(S, LHS, RHS, OpLoc, false);\n    CheckIdentityFieldAssignment(LHS, RHS, OpLoc, S);\n    break;\n  default:\n    break;\n  }\n\n  // Find all of the overloaded operators visible from this point.\n  UnresolvedSet<16> Functions;\n  S.LookupBinOp(Sc, OpLoc, Opc, Functions);\n\n  // Build the (potentially-overloaded, potentially-dependent)\n  // binary operation.\n  return S.CreateOverloadedBinOp(OpLoc, Opc, Functions, LHS, RHS);\n}\n\nExprResult Sema::BuildBinOp(Scope *S, SourceLocation OpLoc,\n                            BinaryOperatorKind Opc,\n                            Expr *LHSExpr, Expr *RHSExpr) {\n  ExprResult LHS, RHS;\n  std::tie(LHS, RHS) = CorrectDelayedTyposInBinOp(*this, Opc, LHSExpr, RHSExpr);\n  if (!LHS.isUsable() || !RHS.isUsable())\n    return ExprError();\n  LHSExpr = LHS.get();\n  RHSExpr = RHS.get();\n\n  // We want to end up calling one of checkPseudoObjectAssignment\n  // (if the LHS is a pseudo-object), BuildOverloadedBinOp (if\n  // both expressions are overloadable or either is type-dependent),\n  // or CreateBuiltinBinOp (in any other case).  We also want to get\n  // any placeholder types out of the way.\n\n  // Handle pseudo-objects in the LHS.\n  if (const BuiltinType *pty = LHSExpr->getType()->getAsPlaceholderType()) {\n    // Assignments with a pseudo-object l-value need special analysis.\n    if (pty->getKind() == BuiltinType::PseudoObject &&\n        BinaryOperator::isAssignmentOp(Opc))\n      return checkPseudoObjectAssignment(S, OpLoc, Opc, LHSExpr, RHSExpr);\n\n    // Don't resolve overloads if the other type is overloadable.\n    if (getLangOpts().CPlusPlus && pty->getKind() == BuiltinType::Overload) {\n      // We can't actually test that if we still have a placeholder,\n      // though.  Fortunately, none of the exceptions we see in that\n      // code below are valid when the LHS is an overload set.  Note\n      // that an overload set can be dependently-typed, but it never\n      // instantiates to having an overloadable type.\n      ExprResult resolvedRHS = CheckPlaceholderExpr(RHSExpr);\n      if (resolvedRHS.isInvalid()) return ExprError();\n      RHSExpr = resolvedRHS.get();\n\n      if (RHSExpr->isTypeDependent() ||\n          RHSExpr->getType()->isOverloadableType())\n        return BuildOverloadedBinOp(*this, S, OpLoc, Opc, LHSExpr, RHSExpr);\n    }\n\n    // If we're instantiating \"a.x < b\" or \"A::x < b\" and 'x' names a function\n    // template, diagnose the missing 'template' keyword instead of diagnosing\n    // an invalid use of a bound member function.\n    //\n    // Note that \"A::x < b\" might be valid if 'b' has an overloadable type due\n    // to C++1z [over.over]/1.4, but we already checked for that case above.\n    if (Opc == BO_LT && inTemplateInstantiation() &&\n        (pty->getKind() == BuiltinType::BoundMember ||\n         pty->getKind() == BuiltinType::Overload)) {\n      auto *OE = dyn_cast<OverloadExpr>(LHSExpr);\n      if (OE && !OE->hasTemplateKeyword() && !OE->hasExplicitTemplateArgs() &&\n          std::any_of(OE->decls_begin(), OE->decls_end(), [](NamedDecl *ND) {\n            return isa<FunctionTemplateDecl>(ND);\n          })) {\n        Diag(OE->getQualifier() ? OE->getQualifierLoc().getBeginLoc()\n                                : OE->getNameLoc(),\n             diag::err_template_kw_missing)\n          << OE->getName().getAsString() << \"\";\n        return ExprError();\n      }\n    }\n\n    ExprResult LHS = CheckPlaceholderExpr(LHSExpr);\n    if (LHS.isInvalid()) return ExprError();\n    LHSExpr = LHS.get();\n  }\n\n  // Handle pseudo-objects in the RHS.\n  if (const BuiltinType *pty = RHSExpr->getType()->getAsPlaceholderType()) {\n    // An overload in the RHS can potentially be resolved by the type\n    // being assigned to.\n    if (Opc == BO_Assign && pty->getKind() == BuiltinType::Overload) {\n      if (getLangOpts().CPlusPlus &&\n          (LHSExpr->isTypeDependent() || RHSExpr->isTypeDependent() ||\n           LHSExpr->getType()->isOverloadableType()))\n        return BuildOverloadedBinOp(*this, S, OpLoc, Opc, LHSExpr, RHSExpr);\n\n      return CreateBuiltinBinOp(OpLoc, Opc, LHSExpr, RHSExpr);\n    }\n\n    // Don't resolve overloads if the other type is overloadable.\n    if (getLangOpts().CPlusPlus && pty->getKind() == BuiltinType::Overload &&\n        LHSExpr->getType()->isOverloadableType())\n      return BuildOverloadedBinOp(*this, S, OpLoc, Opc, LHSExpr, RHSExpr);\n\n    ExprResult resolvedRHS = CheckPlaceholderExpr(RHSExpr);\n    if (!resolvedRHS.isUsable()) return ExprError();\n    RHSExpr = resolvedRHS.get();\n  }\n\n  if (getLangOpts().CPlusPlus) {\n    // If either expression is type-dependent, always build an\n    // overloaded op.\n    if (LHSExpr->isTypeDependent() || RHSExpr->isTypeDependent())\n      return BuildOverloadedBinOp(*this, S, OpLoc, Opc, LHSExpr, RHSExpr);\n\n    // Otherwise, build an overloaded op if either expression has an\n    // overloadable type.\n    if (LHSExpr->getType()->isOverloadableType() ||\n        RHSExpr->getType()->isOverloadableType())\n      return BuildOverloadedBinOp(*this, S, OpLoc, Opc, LHSExpr, RHSExpr);\n  }\n\n  if (getLangOpts().RecoveryAST &&\n      (LHSExpr->isTypeDependent() || RHSExpr->isTypeDependent())) {\n    assert(!getLangOpts().CPlusPlus);\n    assert((LHSExpr->containsErrors() || RHSExpr->containsErrors()) &&\n           \"Should only occur in error-recovery path.\");\n    if (BinaryOperator::isCompoundAssignmentOp(Opc))\n      // C [6.15.16] p3:\n      // An assignment expression has the value of the left operand after the\n      // assignment, but is not an lvalue.\n      return CompoundAssignOperator::Create(\n          Context, LHSExpr, RHSExpr, Opc,\n          LHSExpr->getType().getUnqualifiedType(), VK_RValue, OK_Ordinary,\n          OpLoc, CurFPFeatureOverrides());\n    QualType ResultType;\n    switch (Opc) {\n    case BO_Assign:\n      ResultType = LHSExpr->getType().getUnqualifiedType();\n      break;\n    case BO_LT:\n    case BO_GT:\n    case BO_LE:\n    case BO_GE:\n    case BO_EQ:\n    case BO_NE:\n    case BO_LAnd:\n    case BO_LOr:\n      // These operators have a fixed result type regardless of operands.\n      ResultType = Context.IntTy;\n      break;\n    case BO_Comma:\n      ResultType = RHSExpr->getType();\n      break;\n    default:\n      ResultType = Context.DependentTy;\n      break;\n    }\n    return BinaryOperator::Create(Context, LHSExpr, RHSExpr, Opc, ResultType,\n                                  VK_RValue, OK_Ordinary, OpLoc,\n                                  CurFPFeatureOverrides());\n  }\n\n  // Build a built-in binary operation.\n  return CreateBuiltinBinOp(OpLoc, Opc, LHSExpr, RHSExpr);\n}\n\nstatic bool isOverflowingIntegerType(ASTContext &Ctx, QualType T) {\n  if (T.isNull() || T->isDependentType())\n    return false;\n\n  if (!T->isPromotableIntegerType())\n    return true;\n\n  return Ctx.getIntWidth(T) >= Ctx.getIntWidth(Ctx.IntTy);\n}\n\nExprResult Sema::CreateBuiltinUnaryOp(SourceLocation OpLoc,\n                                      UnaryOperatorKind Opc,\n                                      Expr *InputExpr) {\n  ExprResult Input = InputExpr;\n  ExprValueKind VK = VK_RValue;\n  ExprObjectKind OK = OK_Ordinary;\n  QualType resultType;\n  bool CanOverflow = false;\n\n  bool ConvertHalfVec = false;\n  if (getLangOpts().OpenCL) {\n    QualType Ty = InputExpr->getType();\n    // The only legal unary operation for atomics is '&'.\n    if ((Opc != UO_AddrOf && Ty->isAtomicType()) ||\n    // OpenCL special types - image, sampler, pipe, and blocks are to be used\n    // only with a builtin functions and therefore should be disallowed here.\n        (Ty->isImageType() || Ty->isSamplerT() || Ty->isPipeType()\n        || Ty->isBlockPointerType())) {\n      return ExprError(Diag(OpLoc, diag::err_typecheck_unary_expr)\n                       << InputExpr->getType()\n                       << Input.get()->getSourceRange());\n    }\n  }\n\n  switch (Opc) {\n  case UO_PreInc:\n  case UO_PreDec:\n  case UO_PostInc:\n  case UO_PostDec:\n    resultType = CheckIncrementDecrementOperand(*this, Input.get(), VK, OK,\n                                                OpLoc,\n                                                Opc == UO_PreInc ||\n                                                Opc == UO_PostInc,\n                                                Opc == UO_PreInc ||\n                                                Opc == UO_PreDec);\n    CanOverflow = isOverflowingIntegerType(Context, resultType);\n    break;\n  case UO_AddrOf:\n    resultType = CheckAddressOfOperand(Input, OpLoc);\n    CheckAddressOfNoDeref(InputExpr);\n    RecordModifiableNonNullParam(*this, InputExpr);\n    break;\n  case UO_Deref: {\n    Input = DefaultFunctionArrayLvalueConversion(Input.get());\n    if (Input.isInvalid()) return ExprError();\n    resultType = CheckIndirectionOperand(*this, Input.get(), VK, OpLoc);\n    break;\n  }\n  case UO_Plus:\n  case UO_Minus:\n    CanOverflow = Opc == UO_Minus &&\n                  isOverflowingIntegerType(Context, Input.get()->getType());\n    Input = UsualUnaryConversions(Input.get());\n    if (Input.isInvalid()) return ExprError();\n    // Unary plus and minus require promoting an operand of half vector to a\n    // float vector and truncating the result back to a half vector. For now, we\n    // do this only when HalfArgsAndReturns is set (that is, when the target is\n    // arm or arm64).\n    ConvertHalfVec = needsConversionOfHalfVec(true, Context, Input.get());\n\n    // If the operand is a half vector, promote it to a float vector.\n    if (ConvertHalfVec)\n      Input = convertVector(Input.get(), Context.FloatTy, *this);\n    resultType = Input.get()->getType();\n    if (resultType->isDependentType())\n      break;\n    if (resultType->isArithmeticType()) // C99 6.5.3.3p1\n      break;\n    else if (resultType->isVectorType() &&\n             // The z vector extensions don't allow + or - with bool vectors.\n             (!Context.getLangOpts().ZVector ||\n              resultType->castAs<VectorType>()->getVectorKind() !=\n              VectorType::AltiVecBool))\n      break;\n    else if (getLangOpts().CPlusPlus && // C++ [expr.unary.op]p6\n             Opc == UO_Plus &&\n             resultType->isPointerType())\n      break;\n\n    return ExprError(Diag(OpLoc, diag::err_typecheck_unary_expr)\n      << resultType << Input.get()->getSourceRange());\n\n  case UO_Not: // bitwise complement\n    Input = UsualUnaryConversions(Input.get());\n    if (Input.isInvalid())\n      return ExprError();\n    resultType = Input.get()->getType();\n    if (resultType->isDependentType())\n      break;\n    // C99 6.5.3.3p1. We allow complex int and float as a GCC extension.\n    if (resultType->isComplexType() || resultType->isComplexIntegerType())\n      // C99 does not support '~' for complex conjugation.\n      Diag(OpLoc, diag::ext_integer_complement_complex)\n          << resultType << Input.get()->getSourceRange();\n    else if (resultType->hasIntegerRepresentation())\n      break;\n    else if (resultType->isExtVectorType() && Context.getLangOpts().OpenCL) {\n      // OpenCL v1.1 s6.3.f: The bitwise operator not (~) does not operate\n      // on vector float types.\n      QualType T = resultType->castAs<ExtVectorType>()->getElementType();\n      if (!T->isIntegerType())\n        return ExprError(Diag(OpLoc, diag::err_typecheck_unary_expr)\n                          << resultType << Input.get()->getSourceRange());\n    } else {\n      return ExprError(Diag(OpLoc, diag::err_typecheck_unary_expr)\n                       << resultType << Input.get()->getSourceRange());\n    }\n    break;\n\n  case UO_LNot: // logical negation\n    // Unlike +/-/~, integer promotions aren't done here (C99 6.5.3.3p5).\n    Input = DefaultFunctionArrayLvalueConversion(Input.get());\n    if (Input.isInvalid()) return ExprError();\n    resultType = Input.get()->getType();\n\n    // Though we still have to promote half FP to float...\n    if (resultType->isHalfType() && !Context.getLangOpts().NativeHalfType) {\n      Input = ImpCastExprToType(Input.get(), Context.FloatTy, CK_FloatingCast).get();\n      resultType = Context.FloatTy;\n    }\n\n    if (resultType->isDependentType())\n      break;\n    if (resultType->isScalarType() && !isScopedEnumerationType(resultType)) {\n      // C99 6.5.3.3p1: ok, fallthrough;\n      if (Context.getLangOpts().CPlusPlus) {\n        // C++03 [expr.unary.op]p8, C++0x [expr.unary.op]p9:\n        // operand contextually converted to bool.\n        Input = ImpCastExprToType(Input.get(), Context.BoolTy,\n                                  ScalarTypeToBooleanCastKind(resultType));\n      } else if (Context.getLangOpts().OpenCL &&\n                 Context.getLangOpts().OpenCLVersion < 120) {\n        // OpenCL v1.1 6.3.h: The logical operator not (!) does not\n        // operate on scalar float types.\n        if (!resultType->isIntegerType() && !resultType->isPointerType())\n          return ExprError(Diag(OpLoc, diag::err_typecheck_unary_expr)\n                           << resultType << Input.get()->getSourceRange());\n      }\n    } else if (resultType->isExtVectorType()) {\n      if (Context.getLangOpts().OpenCL &&\n          Context.getLangOpts().OpenCLVersion < 120 &&\n          !Context.getLangOpts().OpenCLCPlusPlus) {\n        // OpenCL v1.1 6.3.h: The logical operator not (!) does not\n        // operate on vector float types.\n        QualType T = resultType->castAs<ExtVectorType>()->getElementType();\n        if (!T->isIntegerType())\n          return ExprError(Diag(OpLoc, diag::err_typecheck_unary_expr)\n                           << resultType << Input.get()->getSourceRange());\n      }\n      // Vector logical not returns the signed variant of the operand type.\n      resultType = GetSignedVectorType(resultType);\n      break;\n    } else if (Context.getLangOpts().CPlusPlus && resultType->isVectorType()) {\n      const VectorType *VTy = resultType->castAs<VectorType>();\n      if (VTy->getVectorKind() != VectorType::GenericVector)\n        return ExprError(Diag(OpLoc, diag::err_typecheck_unary_expr)\n                         << resultType << Input.get()->getSourceRange());\n\n      // Vector logical not returns the signed variant of the operand type.\n      resultType = GetSignedVectorType(resultType);\n      break;\n    } else {\n      return ExprError(Diag(OpLoc, diag::err_typecheck_unary_expr)\n        << resultType << Input.get()->getSourceRange());\n    }\n\n    // LNot always has type int. C99 6.5.3.3p5.\n    // In C++, it's bool. C++ 5.3.1p8\n    resultType = Context.getLogicalOperationType();\n    break;\n  case UO_Real:\n  case UO_Imag:\n    resultType = CheckRealImagOperand(*this, Input, OpLoc, Opc == UO_Real);\n    // _Real maps ordinary l-values into ordinary l-values. _Imag maps ordinary\n    // complex l-values to ordinary l-values and all other values to r-values.\n    if (Input.isInvalid()) return ExprError();\n    if (Opc == UO_Real || Input.get()->getType()->isAnyComplexType()) {\n      if (Input.get()->getValueKind() != VK_RValue &&\n          Input.get()->getObjectKind() == OK_Ordinary)\n        VK = Input.get()->getValueKind();\n    } else if (!getLangOpts().CPlusPlus) {\n      // In C, a volatile scalar is read by __imag. In C++, it is not.\n      Input = DefaultLvalueConversion(Input.get());\n    }\n    break;\n  case UO_Extension:\n    resultType = Input.get()->getType();\n    VK = Input.get()->getValueKind();\n    OK = Input.get()->getObjectKind();\n    break;\n  case UO_Coawait:\n    // It's unnecessary to represent the pass-through operator co_await in the\n    // AST; just return the input expression instead.\n    assert(!Input.get()->getType()->isDependentType() &&\n                   \"the co_await expression must be non-dependant before \"\n                   \"building operator co_await\");\n    return Input;\n  }\n  if (resultType.isNull() || Input.isInvalid())\n    return ExprError();\n\n  // Check for array bounds violations in the operand of the UnaryOperator,\n  // except for the '*' and '&' operators that have to be handled specially\n  // by CheckArrayAccess (as there are special cases like &array[arraysize]\n  // that are explicitly defined as valid by the standard).\n  if (Opc != UO_AddrOf && Opc != UO_Deref)\n    CheckArrayAccess(Input.get());\n\n  auto *UO =\n      UnaryOperator::Create(Context, Input.get(), Opc, resultType, VK, OK,\n                            OpLoc, CanOverflow, CurFPFeatureOverrides());\n\n  if (Opc == UO_Deref && UO->getType()->hasAttr(attr::NoDeref) &&\n      !isa<ArrayType>(UO->getType().getDesugaredType(Context)) &&\n      !isUnevaluatedContext())\n    ExprEvalContexts.back().PossibleDerefs.insert(UO);\n\n  // Convert the result back to a half vector.\n  if (ConvertHalfVec)\n    return convertVector(UO, Context.HalfTy, *this);\n  return UO;\n}\n\n/// Determine whether the given expression is a qualified member\n/// access expression, of a form that could be turned into a pointer to member\n/// with the address-of operator.\nbool Sema::isQualifiedMemberAccess(Expr *E) {\n  if (DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E)) {\n    if (!DRE->getQualifier())\n      return false;\n\n    ValueDecl *VD = DRE->getDecl();\n    if (!VD->isCXXClassMember())\n      return false;\n\n    if (isa<FieldDecl>(VD) || isa<IndirectFieldDecl>(VD))\n      return true;\n    if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(VD))\n      return Method->isInstance();\n\n    return false;\n  }\n\n  if (UnresolvedLookupExpr *ULE = dyn_cast<UnresolvedLookupExpr>(E)) {\n    if (!ULE->getQualifier())\n      return false;\n\n    for (NamedDecl *D : ULE->decls()) {\n      if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(D)) {\n        if (Method->isInstance())\n          return true;\n      } else {\n        // Overload set does not contain methods.\n        break;\n      }\n    }\n\n    return false;\n  }\n\n  return false;\n}\n\nExprResult Sema::BuildUnaryOp(Scope *S, SourceLocation OpLoc,\n                              UnaryOperatorKind Opc, Expr *Input) {\n  // First things first: handle placeholders so that the\n  // overloaded-operator check considers the right type.\n  if (const BuiltinType *pty = Input->getType()->getAsPlaceholderType()) {\n    // Increment and decrement of pseudo-object references.\n    if (pty->getKind() == BuiltinType::PseudoObject &&\n        UnaryOperator::isIncrementDecrementOp(Opc))\n      return checkPseudoObjectIncDec(S, OpLoc, Opc, Input);\n\n    // extension is always a builtin operator.\n    if (Opc == UO_Extension)\n      return CreateBuiltinUnaryOp(OpLoc, Opc, Input);\n\n    // & gets special logic for several kinds of placeholder.\n    // The builtin code knows what to do.\n    if (Opc == UO_AddrOf &&\n        (pty->getKind() == BuiltinType::Overload ||\n         pty->getKind() == BuiltinType::UnknownAny ||\n         pty->getKind() == BuiltinType::BoundMember))\n      return CreateBuiltinUnaryOp(OpLoc, Opc, Input);\n\n    // Anything else needs to be handled now.\n    ExprResult Result = CheckPlaceholderExpr(Input);\n    if (Result.isInvalid()) return ExprError();\n    Input = Result.get();\n  }\n\n  if (getLangOpts().CPlusPlus && Input->getType()->isOverloadableType() &&\n      UnaryOperator::getOverloadedOperator(Opc) != OO_None &&\n      !(Opc == UO_AddrOf && isQualifiedMemberAccess(Input))) {\n    // Find all of the overloaded operators visible from this point.\n    UnresolvedSet<16> Functions;\n    OverloadedOperatorKind OverOp = UnaryOperator::getOverloadedOperator(Opc);\n    if (S && OverOp != OO_None)\n      LookupOverloadedOperatorName(OverOp, S, Functions);\n\n    return CreateOverloadedUnaryOp(OpLoc, Opc, Functions, Input);\n  }\n\n  return CreateBuiltinUnaryOp(OpLoc, Opc, Input);\n}\n\n// Unary Operators.  'Tok' is the token for the operator.\nExprResult Sema::ActOnUnaryOp(Scope *S, SourceLocation OpLoc,\n                              tok::TokenKind Op, Expr *Input) {\n  return BuildUnaryOp(S, OpLoc, ConvertTokenKindToUnaryOpcode(Op), Input);\n}\n\n/// ActOnAddrLabel - Parse the GNU address of label extension: \"&&foo\".\nExprResult Sema::ActOnAddrLabel(SourceLocation OpLoc, SourceLocation LabLoc,\n                                LabelDecl *TheDecl) {\n  TheDecl->markUsed(Context);\n  // Create the AST node.  The address of a label always has type 'void*'.\n  return new (Context) AddrLabelExpr(OpLoc, LabLoc, TheDecl,\n                                     Context.getPointerType(Context.VoidTy));\n}\n\nvoid Sema::ActOnStartStmtExpr() {\n  PushExpressionEvaluationContext(ExprEvalContexts.back().Context);\n}\n\nvoid Sema::ActOnStmtExprError() {\n  // Note that function is also called by TreeTransform when leaving a\n  // StmtExpr scope without rebuilding anything.\n\n  DiscardCleanupsInEvaluationContext();\n  PopExpressionEvaluationContext();\n}\n\nExprResult Sema::ActOnStmtExpr(Scope *S, SourceLocation LPLoc, Stmt *SubStmt,\n                               SourceLocation RPLoc) {\n  return BuildStmtExpr(LPLoc, SubStmt, RPLoc, getTemplateDepth(S));\n}\n\nExprResult Sema::BuildStmtExpr(SourceLocation LPLoc, Stmt *SubStmt,\n                               SourceLocation RPLoc, unsigned TemplateDepth) {\n  assert(SubStmt && isa<CompoundStmt>(SubStmt) && \"Invalid action invocation!\");\n  CompoundStmt *Compound = cast<CompoundStmt>(SubStmt);\n\n  if (hasAnyUnrecoverableErrorsInThisFunction())\n    DiscardCleanupsInEvaluationContext();\n  assert(!Cleanup.exprNeedsCleanups() &&\n         \"cleanups within StmtExpr not correctly bound!\");\n  PopExpressionEvaluationContext();\n\n  // FIXME: there are a variety of strange constraints to enforce here, for\n  // example, it is not possible to goto into a stmt expression apparently.\n  // More semantic analysis is needed.\n\n  // If there are sub-stmts in the compound stmt, take the type of the last one\n  // as the type of the stmtexpr.\n  QualType Ty = Context.VoidTy;\n  bool StmtExprMayBindToTemp = false;\n  if (!Compound->body_empty()) {\n    // For GCC compatibility we get the last Stmt excluding trailing NullStmts.\n    if (const auto *LastStmt =\n            dyn_cast<ValueStmt>(Compound->getStmtExprResult())) {\n      if (const Expr *Value = LastStmt->getExprStmt()) {\n        StmtExprMayBindToTemp = true;\n        Ty = Value->getType();\n      }\n    }\n  }\n\n  // FIXME: Check that expression type is complete/non-abstract; statement\n  // expressions are not lvalues.\n  Expr *ResStmtExpr =\n      new (Context) StmtExpr(Compound, Ty, LPLoc, RPLoc, TemplateDepth);\n  if (StmtExprMayBindToTemp)\n    return MaybeBindToTemporary(ResStmtExpr);\n  return ResStmtExpr;\n}\n\nExprResult Sema::ActOnStmtExprResult(ExprResult ER) {\n  if (ER.isInvalid())\n    return ExprError();\n\n  // Do function/array conversion on the last expression, but not\n  // lvalue-to-rvalue.  However, initialize an unqualified type.\n  ER = DefaultFunctionArrayConversion(ER.get());\n  if (ER.isInvalid())\n    return ExprError();\n  Expr *E = ER.get();\n\n  if (E->isTypeDependent())\n    return E;\n\n  // In ARC, if the final expression ends in a consume, splice\n  // the consume out and bind it later.  In the alternate case\n  // (when dealing with a retainable type), the result\n  // initialization will create a produce.  In both cases the\n  // result will be +1, and we'll need to balance that out with\n  // a bind.\n  auto *Cast = dyn_cast<ImplicitCastExpr>(E);\n  if (Cast && Cast->getCastKind() == CK_ARCConsumeObject)\n    return Cast->getSubExpr();\n\n  // FIXME: Provide a better location for the initialization.\n  return PerformCopyInitialization(\n      InitializedEntity::InitializeStmtExprResult(\n          E->getBeginLoc(), E->getType().getUnqualifiedType()),\n      SourceLocation(), E);\n}\n\nExprResult Sema::BuildBuiltinOffsetOf(SourceLocation BuiltinLoc,\n                                      TypeSourceInfo *TInfo,\n                                      ArrayRef<OffsetOfComponent> Components,\n                                      SourceLocation RParenLoc) {\n  QualType ArgTy = TInfo->getType();\n  bool Dependent = ArgTy->isDependentType();\n  SourceRange TypeRange = TInfo->getTypeLoc().getLocalSourceRange();\n\n  // We must have at least one component that refers to the type, and the first\n  // one is known to be a field designator.  Verify that the ArgTy represents\n  // a struct/union/class.\n  if (!Dependent && !ArgTy->isRecordType())\n    return ExprError(Diag(BuiltinLoc, diag::err_offsetof_record_type)\n                       << ArgTy << TypeRange);\n\n  // Type must be complete per C99 7.17p3 because a declaring a variable\n  // with an incomplete type would be ill-formed.\n  if (!Dependent\n      && RequireCompleteType(BuiltinLoc, ArgTy,\n                             diag::err_offsetof_incomplete_type, TypeRange))\n    return ExprError();\n\n  bool DidWarnAboutNonPOD = false;\n  QualType CurrentType = ArgTy;\n  SmallVector<OffsetOfNode, 4> Comps;\n  SmallVector<Expr*, 4> Exprs;\n  for (const OffsetOfComponent &OC : Components) {\n    if (OC.isBrackets) {\n      // Offset of an array sub-field.  TODO: Should we allow vector elements?\n      if (!CurrentType->isDependentType()) {\n        const ArrayType *AT = Context.getAsArrayType(CurrentType);\n        if(!AT)\n          return ExprError(Diag(OC.LocEnd, diag::err_offsetof_array_type)\n                           << CurrentType);\n        CurrentType = AT->getElementType();\n      } else\n        CurrentType = Context.DependentTy;\n\n      ExprResult IdxRval = DefaultLvalueConversion(static_cast<Expr*>(OC.U.E));\n      if (IdxRval.isInvalid())\n        return ExprError();\n      Expr *Idx = IdxRval.get();\n\n      // The expression must be an integral expression.\n      // FIXME: An integral constant expression?\n      if (!Idx->isTypeDependent() && !Idx->isValueDependent() &&\n          !Idx->getType()->isIntegerType())\n        return ExprError(\n            Diag(Idx->getBeginLoc(), diag::err_typecheck_subscript_not_integer)\n            << Idx->getSourceRange());\n\n      // Record this array index.\n      Comps.push_back(OffsetOfNode(OC.LocStart, Exprs.size(), OC.LocEnd));\n      Exprs.push_back(Idx);\n      continue;\n    }\n\n    // Offset of a field.\n    if (CurrentType->isDependentType()) {\n      // We have the offset of a field, but we can't look into the dependent\n      // type. Just record the identifier of the field.\n      Comps.push_back(OffsetOfNode(OC.LocStart, OC.U.IdentInfo, OC.LocEnd));\n      CurrentType = Context.DependentTy;\n      continue;\n    }\n\n    // We need to have a complete type to look into.\n    if (RequireCompleteType(OC.LocStart, CurrentType,\n                            diag::err_offsetof_incomplete_type))\n      return ExprError();\n\n    // Look for the designated field.\n    const RecordType *RC = CurrentType->getAs<RecordType>();\n    if (!RC)\n      return ExprError(Diag(OC.LocEnd, diag::err_offsetof_record_type)\n                       << CurrentType);\n    RecordDecl *RD = RC->getDecl();\n\n    // C++ [lib.support.types]p5:\n    //   The macro offsetof accepts a restricted set of type arguments in this\n    //   International Standard. type shall be a POD structure or a POD union\n    //   (clause 9).\n    // C++11 [support.types]p4:\n    //   If type is not a standard-layout class (Clause 9), the results are\n    //   undefined.\n    if (CXXRecordDecl *CRD = dyn_cast<CXXRecordDecl>(RD)) {\n      bool IsSafe = LangOpts.CPlusPlus11? CRD->isStandardLayout() : CRD->isPOD();\n      unsigned DiagID =\n        LangOpts.CPlusPlus11? diag::ext_offsetof_non_standardlayout_type\n                            : diag::ext_offsetof_non_pod_type;\n\n      if (!IsSafe && !DidWarnAboutNonPOD &&\n          DiagRuntimeBehavior(BuiltinLoc, nullptr,\n                              PDiag(DiagID)\n                              << SourceRange(Components[0].LocStart, OC.LocEnd)\n                              << CurrentType))\n        DidWarnAboutNonPOD = true;\n    }\n\n    // Look for the field.\n    LookupResult R(*this, OC.U.IdentInfo, OC.LocStart, LookupMemberName);\n    LookupQualifiedName(R, RD);\n    FieldDecl *MemberDecl = R.getAsSingle<FieldDecl>();\n    IndirectFieldDecl *IndirectMemberDecl = nullptr;\n    if (!MemberDecl) {\n      if ((IndirectMemberDecl = R.getAsSingle<IndirectFieldDecl>()))\n        MemberDecl = IndirectMemberDecl->getAnonField();\n    }\n\n    if (!MemberDecl)\n      return ExprError(Diag(BuiltinLoc, diag::err_no_member)\n                       << OC.U.IdentInfo << RD << SourceRange(OC.LocStart,\n                                                              OC.LocEnd));\n\n    // C99 7.17p3:\n    //   (If the specified member is a bit-field, the behavior is undefined.)\n    //\n    // We diagnose this as an error.\n    if (MemberDecl->isBitField()) {\n      Diag(OC.LocEnd, diag::err_offsetof_bitfield)\n        << MemberDecl->getDeclName()\n        << SourceRange(BuiltinLoc, RParenLoc);\n      Diag(MemberDecl->getLocation(), diag::note_bitfield_decl);\n      return ExprError();\n    }\n\n    RecordDecl *Parent = MemberDecl->getParent();\n    if (IndirectMemberDecl)\n      Parent = cast<RecordDecl>(IndirectMemberDecl->getDeclContext());\n\n    // If the member was found in a base class, introduce OffsetOfNodes for\n    // the base class indirections.\n    CXXBasePaths Paths;\n    if (IsDerivedFrom(OC.LocStart, CurrentType, Context.getTypeDeclType(Parent),\n                      Paths)) {\n      if (Paths.getDetectedVirtual()) {\n        Diag(OC.LocEnd, diag::err_offsetof_field_of_virtual_base)\n          << MemberDecl->getDeclName()\n          << SourceRange(BuiltinLoc, RParenLoc);\n        return ExprError();\n      }\n\n      CXXBasePath &Path = Paths.front();\n      for (const CXXBasePathElement &B : Path)\n        Comps.push_back(OffsetOfNode(B.Base));\n    }\n\n    if (IndirectMemberDecl) {\n      for (auto *FI : IndirectMemberDecl->chain()) {\n        assert(isa<FieldDecl>(FI));\n        Comps.push_back(OffsetOfNode(OC.LocStart,\n                                     cast<FieldDecl>(FI), OC.LocEnd));\n      }\n    } else\n      Comps.push_back(OffsetOfNode(OC.LocStart, MemberDecl, OC.LocEnd));\n\n    CurrentType = MemberDecl->getType().getNonReferenceType();\n  }\n\n  return OffsetOfExpr::Create(Context, Context.getSizeType(), BuiltinLoc, TInfo,\n                              Comps, Exprs, RParenLoc);\n}\n\nExprResult Sema::ActOnBuiltinOffsetOf(Scope *S,\n                                      SourceLocation BuiltinLoc,\n                                      SourceLocation TypeLoc,\n                                      ParsedType ParsedArgTy,\n                                      ArrayRef<OffsetOfComponent> Components,\n                                      SourceLocation RParenLoc) {\n\n  TypeSourceInfo *ArgTInfo;\n  QualType ArgTy = GetTypeFromParser(ParsedArgTy, &ArgTInfo);\n  if (ArgTy.isNull())\n    return ExprError();\n\n  if (!ArgTInfo)\n    ArgTInfo = Context.getTrivialTypeSourceInfo(ArgTy, TypeLoc);\n\n  return BuildBuiltinOffsetOf(BuiltinLoc, ArgTInfo, Components, RParenLoc);\n}\n\n\nExprResult Sema::ActOnChooseExpr(SourceLocation BuiltinLoc,\n                                 Expr *CondExpr,\n                                 Expr *LHSExpr, Expr *RHSExpr,\n                                 SourceLocation RPLoc) {\n  assert((CondExpr && LHSExpr && RHSExpr) && \"Missing type argument(s)\");\n\n  ExprValueKind VK = VK_RValue;\n  ExprObjectKind OK = OK_Ordinary;\n  QualType resType;\n  bool CondIsTrue = false;\n  if (CondExpr->isTypeDependent() || CondExpr->isValueDependent()) {\n    resType = Context.DependentTy;\n  } else {\n    // The conditional expression is required to be a constant expression.\n    llvm::APSInt condEval(32);\n    ExprResult CondICE = VerifyIntegerConstantExpression(\n        CondExpr, &condEval, diag::err_typecheck_choose_expr_requires_constant);\n    if (CondICE.isInvalid())\n      return ExprError();\n    CondExpr = CondICE.get();\n    CondIsTrue = condEval.getZExtValue();\n\n    // If the condition is > zero, then the AST type is the same as the LHSExpr.\n    Expr *ActiveExpr = CondIsTrue ? LHSExpr : RHSExpr;\n\n    resType = ActiveExpr->getType();\n    VK = ActiveExpr->getValueKind();\n    OK = ActiveExpr->getObjectKind();\n  }\n\n  return new (Context) ChooseExpr(BuiltinLoc, CondExpr, LHSExpr, RHSExpr,\n                                  resType, VK, OK, RPLoc, CondIsTrue);\n}\n\n//===----------------------------------------------------------------------===//\n// Clang Extensions.\n//===----------------------------------------------------------------------===//\n\n/// ActOnBlockStart - This callback is invoked when a block literal is started.\nvoid Sema::ActOnBlockStart(SourceLocation CaretLoc, Scope *CurScope) {\n  BlockDecl *Block = BlockDecl::Create(Context, CurContext, CaretLoc);\n\n  if (LangOpts.CPlusPlus) {\n    MangleNumberingContext *MCtx;\n    Decl *ManglingContextDecl;\n    std::tie(MCtx, ManglingContextDecl) =\n        getCurrentMangleNumberContext(Block->getDeclContext());\n    if (MCtx) {\n      unsigned ManglingNumber = MCtx->getManglingNumber(Block);\n      Block->setBlockMangling(ManglingNumber, ManglingContextDecl);\n    }\n  }\n\n  PushBlockScope(CurScope, Block);\n  CurContext->addDecl(Block);\n  if (CurScope)\n    PushDeclContext(CurScope, Block);\n  else\n    CurContext = Block;\n\n  getCurBlock()->HasImplicitReturnType = true;\n\n  // Enter a new evaluation context to insulate the block from any\n  // cleanups from the enclosing full-expression.\n  PushExpressionEvaluationContext(\n      ExpressionEvaluationContext::PotentiallyEvaluated);\n}\n\nvoid Sema::ActOnBlockArguments(SourceLocation CaretLoc, Declarator &ParamInfo,\n                               Scope *CurScope) {\n  assert(ParamInfo.getIdentifier() == nullptr &&\n         \"block-id should have no identifier!\");\n  assert(ParamInfo.getContext() == DeclaratorContext::BlockLiteral);\n  BlockScopeInfo *CurBlock = getCurBlock();\n\n  TypeSourceInfo *Sig = GetTypeForDeclarator(ParamInfo, CurScope);\n  QualType T = Sig->getType();\n\n  // FIXME: We should allow unexpanded parameter packs here, but that would,\n  // in turn, make the block expression contain unexpanded parameter packs.\n  if (DiagnoseUnexpandedParameterPack(CaretLoc, Sig, UPPC_Block)) {\n    // Drop the parameters.\n    FunctionProtoType::ExtProtoInfo EPI;\n    EPI.HasTrailingReturn = false;\n    EPI.TypeQuals.addConst();\n    T = Context.getFunctionType(Context.DependentTy, None, EPI);\n    Sig = Context.getTrivialTypeSourceInfo(T);\n  }\n\n  // GetTypeForDeclarator always produces a function type for a block\n  // literal signature.  Furthermore, it is always a FunctionProtoType\n  // unless the function was written with a typedef.\n  assert(T->isFunctionType() &&\n         \"GetTypeForDeclarator made a non-function block signature\");\n\n  // Look for an explicit signature in that function type.\n  FunctionProtoTypeLoc ExplicitSignature;\n\n  if ((ExplicitSignature = Sig->getTypeLoc()\n                               .getAsAdjusted<FunctionProtoTypeLoc>())) {\n\n    // Check whether that explicit signature was synthesized by\n    // GetTypeForDeclarator.  If so, don't save that as part of the\n    // written signature.\n    if (ExplicitSignature.getLocalRangeBegin() ==\n        ExplicitSignature.getLocalRangeEnd()) {\n      // This would be much cheaper if we stored TypeLocs instead of\n      // TypeSourceInfos.\n      TypeLoc Result = ExplicitSignature.getReturnLoc();\n      unsigned Size = Result.getFullDataSize();\n      Sig = Context.CreateTypeSourceInfo(Result.getType(), Size);\n      Sig->getTypeLoc().initializeFullCopy(Result, Size);\n\n      ExplicitSignature = FunctionProtoTypeLoc();\n    }\n  }\n\n  CurBlock->TheDecl->setSignatureAsWritten(Sig);\n  CurBlock->FunctionType = T;\n\n  const auto *Fn = T->castAs<FunctionType>();\n  QualType RetTy = Fn->getReturnType();\n  bool isVariadic =\n      (isa<FunctionProtoType>(Fn) && cast<FunctionProtoType>(Fn)->isVariadic());\n\n  CurBlock->TheDecl->setIsVariadic(isVariadic);\n\n  // Context.DependentTy is used as a placeholder for a missing block\n  // return type.  TODO:  what should we do with declarators like:\n  //   ^ * { ... }\n  // If the answer is \"apply template argument deduction\"....\n  if (RetTy != Context.DependentTy) {\n    CurBlock->ReturnType = RetTy;\n    CurBlock->TheDecl->setBlockMissingReturnType(false);\n    CurBlock->HasImplicitReturnType = false;\n  }\n\n  // Push block parameters from the declarator if we had them.\n  SmallVector<ParmVarDecl*, 8> Params;\n  if (ExplicitSignature) {\n    for (unsigned I = 0, E = ExplicitSignature.getNumParams(); I != E; ++I) {\n      ParmVarDecl *Param = ExplicitSignature.getParam(I);\n      if (Param->getIdentifier() == nullptr && !Param->isImplicit() &&\n          !Param->isInvalidDecl() && !getLangOpts().CPlusPlus) {\n        // Diagnose this as an extension in C17 and earlier.\n        if (!getLangOpts().C2x)\n          Diag(Param->getLocation(), diag::ext_parameter_name_omitted_c2x);\n      }\n      Params.push_back(Param);\n    }\n\n  // Fake up parameter variables if we have a typedef, like\n  //   ^ fntype { ... }\n  } else if (const FunctionProtoType *Fn = T->getAs<FunctionProtoType>()) {\n    for (const auto &I : Fn->param_types()) {\n      ParmVarDecl *Param = BuildParmVarDeclForTypedef(\n          CurBlock->TheDecl, ParamInfo.getBeginLoc(), I);\n      Params.push_back(Param);\n    }\n  }\n\n  // Set the parameters on the block decl.\n  if (!Params.empty()) {\n    CurBlock->TheDecl->setParams(Params);\n    CheckParmsForFunctionDef(CurBlock->TheDecl->parameters(),\n                             /*CheckParameterNames=*/false);\n  }\n\n  // Finally we can process decl attributes.\n  ProcessDeclAttributes(CurScope, CurBlock->TheDecl, ParamInfo);\n\n  // Put the parameter variables in scope.\n  for (auto AI : CurBlock->TheDecl->parameters()) {\n    AI->setOwningFunction(CurBlock->TheDecl);\n\n    // If this has an identifier, add it to the scope stack.\n    if (AI->getIdentifier()) {\n      CheckShadow(CurBlock->TheScope, AI);\n\n      PushOnScopeChains(AI, CurBlock->TheScope);\n    }\n  }\n}\n\n/// ActOnBlockError - If there is an error parsing a block, this callback\n/// is invoked to pop the information about the block from the action impl.\nvoid Sema::ActOnBlockError(SourceLocation CaretLoc, Scope *CurScope) {\n  // Leave the expression-evaluation context.\n  DiscardCleanupsInEvaluationContext();\n  PopExpressionEvaluationContext();\n\n  // Pop off CurBlock, handle nested blocks.\n  PopDeclContext();\n  PopFunctionScopeInfo();\n}\n\n/// ActOnBlockStmtExpr - This is called when the body of a block statement\n/// literal was successfully completed.  ^(int x){...}\nExprResult Sema::ActOnBlockStmtExpr(SourceLocation CaretLoc,\n                                    Stmt *Body, Scope *CurScope) {\n  // If blocks are disabled, emit an error.\n  if (!LangOpts.Blocks)\n    Diag(CaretLoc, diag::err_blocks_disable) << LangOpts.OpenCL;\n\n  // Leave the expression-evaluation context.\n  if (hasAnyUnrecoverableErrorsInThisFunction())\n    DiscardCleanupsInEvaluationContext();\n  assert(!Cleanup.exprNeedsCleanups() &&\n         \"cleanups within block not correctly bound!\");\n  PopExpressionEvaluationContext();\n\n  BlockScopeInfo *BSI = cast<BlockScopeInfo>(FunctionScopes.back());\n  BlockDecl *BD = BSI->TheDecl;\n\n  if (BSI->HasImplicitReturnType)\n    deduceClosureReturnType(*BSI);\n\n  QualType RetTy = Context.VoidTy;\n  if (!BSI->ReturnType.isNull())\n    RetTy = BSI->ReturnType;\n\n  bool NoReturn = BD->hasAttr<NoReturnAttr>();\n  QualType BlockTy;\n\n  // If the user wrote a function type in some form, try to use that.\n  if (!BSI->FunctionType.isNull()) {\n    const FunctionType *FTy = BSI->FunctionType->castAs<FunctionType>();\n\n    FunctionType::ExtInfo Ext = FTy->getExtInfo();\n    if (NoReturn && !Ext.getNoReturn()) Ext = Ext.withNoReturn(true);\n\n    // Turn protoless block types into nullary block types.\n    if (isa<FunctionNoProtoType>(FTy)) {\n      FunctionProtoType::ExtProtoInfo EPI;\n      EPI.ExtInfo = Ext;\n      BlockTy = Context.getFunctionType(RetTy, None, EPI);\n\n    // Otherwise, if we don't need to change anything about the function type,\n    // preserve its sugar structure.\n    } else if (FTy->getReturnType() == RetTy &&\n               (!NoReturn || FTy->getNoReturnAttr())) {\n      BlockTy = BSI->FunctionType;\n\n    // Otherwise, make the minimal modifications to the function type.\n    } else {\n      const FunctionProtoType *FPT = cast<FunctionProtoType>(FTy);\n      FunctionProtoType::ExtProtoInfo EPI = FPT->getExtProtoInfo();\n      EPI.TypeQuals = Qualifiers();\n      EPI.ExtInfo = Ext;\n      BlockTy = Context.getFunctionType(RetTy, FPT->getParamTypes(), EPI);\n    }\n\n  // If we don't have a function type, just build one from nothing.\n  } else {\n    FunctionProtoType::ExtProtoInfo EPI;\n    EPI.ExtInfo = FunctionType::ExtInfo().withNoReturn(NoReturn);\n    BlockTy = Context.getFunctionType(RetTy, None, EPI);\n  }\n\n  DiagnoseUnusedParameters(BD->parameters());\n  BlockTy = Context.getBlockPointerType(BlockTy);\n\n  // If needed, diagnose invalid gotos and switches in the block.\n  if (getCurFunction()->NeedsScopeChecking() &&\n      !PP.isCodeCompletionEnabled())\n    DiagnoseInvalidJumps(cast<CompoundStmt>(Body));\n\n  BD->setBody(cast<CompoundStmt>(Body));\n\n  if (Body && getCurFunction()->HasPotentialAvailabilityViolations)\n    DiagnoseUnguardedAvailabilityViolations(BD);\n\n  // Try to apply the named return value optimization. We have to check again\n  // if we can do this, though, because blocks keep return statements around\n  // to deduce an implicit return type.\n  if (getLangOpts().CPlusPlus && RetTy->isRecordType() &&\n      !BD->isDependentContext())\n    computeNRVO(Body, BSI);\n\n  if (RetTy.hasNonTrivialToPrimitiveDestructCUnion() ||\n      RetTy.hasNonTrivialToPrimitiveCopyCUnion())\n    checkNonTrivialCUnion(RetTy, BD->getCaretLocation(), NTCUC_FunctionReturn,\n                          NTCUK_Destruct|NTCUK_Copy);\n\n  PopDeclContext();\n\n  // Set the captured variables on the block.\n  SmallVector<BlockDecl::Capture, 4> Captures;\n  for (Capture &Cap : BSI->Captures) {\n    if (Cap.isInvalid() || Cap.isThisCapture())\n      continue;\n\n    VarDecl *Var = Cap.getVariable();\n    Expr *CopyExpr = nullptr;\n    if (getLangOpts().CPlusPlus && Cap.isCopyCapture()) {\n      if (const RecordType *Record =\n              Cap.getCaptureType()->getAs<RecordType>()) {\n        // The capture logic needs the destructor, so make sure we mark it.\n        // Usually this is unnecessary because most local variables have\n        // their destructors marked at declaration time, but parameters are\n        // an exception because it's technically only the call site that\n        // actually requires the destructor.\n        if (isa<ParmVarDecl>(Var))\n          FinalizeVarWithDestructor(Var, Record);\n\n        // Enter a separate potentially-evaluated context while building block\n        // initializers to isolate their cleanups from those of the block\n        // itself.\n        // FIXME: Is this appropriate even when the block itself occurs in an\n        // unevaluated operand?\n        EnterExpressionEvaluationContext EvalContext(\n            *this, ExpressionEvaluationContext::PotentiallyEvaluated);\n\n        SourceLocation Loc = Cap.getLocation();\n\n        ExprResult Result = BuildDeclarationNameExpr(\n            CXXScopeSpec(), DeclarationNameInfo(Var->getDeclName(), Loc), Var);\n\n        // According to the blocks spec, the capture of a variable from\n        // the stack requires a const copy constructor.  This is not true\n        // of the copy/move done to move a __block variable to the heap.\n        if (!Result.isInvalid() &&\n            !Result.get()->getType().isConstQualified()) {\n          Result = ImpCastExprToType(Result.get(),\n                                     Result.get()->getType().withConst(),\n                                     CK_NoOp, VK_LValue);\n        }\n\n        if (!Result.isInvalid()) {\n          Result = PerformCopyInitialization(\n              InitializedEntity::InitializeBlock(Var->getLocation(),\n                                                 Cap.getCaptureType(), false),\n              Loc, Result.get());\n        }\n\n        // Build a full-expression copy expression if initialization\n        // succeeded and used a non-trivial constructor.  Recover from\n        // errors by pretending that the copy isn't necessary.\n        if (!Result.isInvalid() &&\n            !cast<CXXConstructExpr>(Result.get())->getConstructor()\n                ->isTrivial()) {\n          Result = MaybeCreateExprWithCleanups(Result);\n          CopyExpr = Result.get();\n        }\n      }\n    }\n\n    BlockDecl::Capture NewCap(Var, Cap.isBlockCapture(), Cap.isNested(),\n                              CopyExpr);\n    Captures.push_back(NewCap);\n  }\n  BD->setCaptures(Context, Captures, BSI->CXXThisCaptureIndex != 0);\n\n  // Pop the block scope now but keep it alive to the end of this function.\n  AnalysisBasedWarnings::Policy WP = AnalysisWarnings.getDefaultPolicy();\n  PoppedFunctionScopePtr ScopeRAII = PopFunctionScopeInfo(&WP, BD, BlockTy);\n\n  BlockExpr *Result = new (Context) BlockExpr(BD, BlockTy);\n\n  // If the block isn't obviously global, i.e. it captures anything at\n  // all, then we need to do a few things in the surrounding context:\n  if (Result->getBlockDecl()->hasCaptures()) {\n    // First, this expression has a new cleanup object.\n    ExprCleanupObjects.push_back(Result->getBlockDecl());\n    Cleanup.setExprNeedsCleanups(true);\n\n    // It also gets a branch-protected scope if any of the captured\n    // variables needs destruction.\n    for (const auto &CI : Result->getBlockDecl()->captures()) {\n      const VarDecl *var = CI.getVariable();\n      if (var->getType().isDestructedType() != QualType::DK_none) {\n        setFunctionHasBranchProtectedScope();\n        break;\n      }\n    }\n  }\n\n  if (getCurFunction())\n    getCurFunction()->addBlock(BD);\n\n  return Result;\n}\n\nExprResult Sema::ActOnVAArg(SourceLocation BuiltinLoc, Expr *E, ParsedType Ty,\n                            SourceLocation RPLoc) {\n  TypeSourceInfo *TInfo;\n  GetTypeFromParser(Ty, &TInfo);\n  return BuildVAArgExpr(BuiltinLoc, E, TInfo, RPLoc);\n}\n\nExprResult Sema::BuildVAArgExpr(SourceLocation BuiltinLoc,\n                                Expr *E, TypeSourceInfo *TInfo,\n                                SourceLocation RPLoc) {\n  Expr *OrigExpr = E;\n  bool IsMS = false;\n\n  // CUDA device code does not support varargs.\n  if (getLangOpts().CUDA && getLangOpts().CUDAIsDevice) {\n    if (const FunctionDecl *F = dyn_cast<FunctionDecl>(CurContext)) {\n      CUDAFunctionTarget T = IdentifyCUDATarget(F);\n      if (T == CFT_Global || T == CFT_Device || T == CFT_HostDevice)\n        return ExprError(Diag(E->getBeginLoc(), diag::err_va_arg_in_device));\n    }\n  }\n\n  // NVPTX does not support va_arg expression.\n  if (getLangOpts().OpenMP && getLangOpts().OpenMPIsDevice &&\n      Context.getTargetInfo().getTriple().isNVPTX())\n    targetDiag(E->getBeginLoc(), diag::err_va_arg_in_device);\n\n  // It might be a __builtin_ms_va_list. (But don't ever mark a va_arg()\n  // as Microsoft ABI on an actual Microsoft platform, where\n  // __builtin_ms_va_list and __builtin_va_list are the same.)\n  if (!E->isTypeDependent() && Context.getTargetInfo().hasBuiltinMSVaList() &&\n      Context.getTargetInfo().getBuiltinVaListKind() != TargetInfo::CharPtrBuiltinVaList) {\n    QualType MSVaListType = Context.getBuiltinMSVaListType();\n    if (Context.hasSameType(MSVaListType, E->getType())) {\n      if (CheckForModifiableLvalue(E, BuiltinLoc, *this))\n        return ExprError();\n      IsMS = true;\n    }\n  }\n\n  // Get the va_list type\n  QualType VaListType = Context.getBuiltinVaListType();\n  if (!IsMS) {\n    if (VaListType->isArrayType()) {\n      // Deal with implicit array decay; for example, on x86-64,\n      // va_list is an array, but it's supposed to decay to\n      // a pointer for va_arg.\n      VaListType = Context.getArrayDecayedType(VaListType);\n      // Make sure the input expression also decays appropriately.\n      ExprResult Result = UsualUnaryConversions(E);\n      if (Result.isInvalid())\n        return ExprError();\n      E = Result.get();\n    } else if (VaListType->isRecordType() && getLangOpts().CPlusPlus) {\n      // If va_list is a record type and we are compiling in C++ mode,\n      // check the argument using reference binding.\n      InitializedEntity Entity = InitializedEntity::InitializeParameter(\n          Context, Context.getLValueReferenceType(VaListType), false);\n      ExprResult Init = PerformCopyInitialization(Entity, SourceLocation(), E);\n      if (Init.isInvalid())\n        return ExprError();\n      E = Init.getAs<Expr>();\n    } else {\n      // Otherwise, the va_list argument must be an l-value because\n      // it is modified by va_arg.\n      if (!E->isTypeDependent() &&\n          CheckForModifiableLvalue(E, BuiltinLoc, *this))\n        return ExprError();\n    }\n  }\n\n  if (!IsMS && !E->isTypeDependent() &&\n      !Context.hasSameType(VaListType, E->getType()))\n    return ExprError(\n        Diag(E->getBeginLoc(),\n             diag::err_first_argument_to_va_arg_not_of_type_va_list)\n        << OrigExpr->getType() << E->getSourceRange());\n\n  if (!TInfo->getType()->isDependentType()) {\n    if (RequireCompleteType(TInfo->getTypeLoc().getBeginLoc(), TInfo->getType(),\n                            diag::err_second_parameter_to_va_arg_incomplete,\n                            TInfo->getTypeLoc()))\n      return ExprError();\n\n    if (RequireNonAbstractType(TInfo->getTypeLoc().getBeginLoc(),\n                               TInfo->getType(),\n                               diag::err_second_parameter_to_va_arg_abstract,\n                               TInfo->getTypeLoc()))\n      return ExprError();\n\n    if (!TInfo->getType().isPODType(Context)) {\n      Diag(TInfo->getTypeLoc().getBeginLoc(),\n           TInfo->getType()->isObjCLifetimeType()\n             ? diag::warn_second_parameter_to_va_arg_ownership_qualified\n             : diag::warn_second_parameter_to_va_arg_not_pod)\n        << TInfo->getType()\n        << TInfo->getTypeLoc().getSourceRange();\n    }\n\n    // Check for va_arg where arguments of the given type will be promoted\n    // (i.e. this va_arg is guaranteed to have undefined behavior).\n    QualType PromoteType;\n    if (TInfo->getType()->isPromotableIntegerType()) {\n      PromoteType = Context.getPromotedIntegerType(TInfo->getType());\n      if (Context.typesAreCompatible(PromoteType, TInfo->getType()))\n        PromoteType = QualType();\n    }\n    if (TInfo->getType()->isSpecificBuiltinType(BuiltinType::Float))\n      PromoteType = Context.DoubleTy;\n    if (!PromoteType.isNull())\n      DiagRuntimeBehavior(TInfo->getTypeLoc().getBeginLoc(), E,\n                  PDiag(diag::warn_second_parameter_to_va_arg_never_compatible)\n                          << TInfo->getType()\n                          << PromoteType\n                          << TInfo->getTypeLoc().getSourceRange());\n  }\n\n  QualType T = TInfo->getType().getNonLValueExprType(Context);\n  return new (Context) VAArgExpr(BuiltinLoc, E, TInfo, RPLoc, T, IsMS);\n}\n\nExprResult Sema::ActOnGNUNullExpr(SourceLocation TokenLoc) {\n  // The type of __null will be int or long, depending on the size of\n  // pointers on the target.\n  QualType Ty;\n  unsigned pw = Context.getTargetInfo().getPointerWidth(0);\n  if (pw == Context.getTargetInfo().getIntWidth())\n    Ty = Context.IntTy;\n  else if (pw == Context.getTargetInfo().getLongWidth())\n    Ty = Context.LongTy;\n  else if (pw == Context.getTargetInfo().getLongLongWidth())\n    Ty = Context.LongLongTy;\n  else {\n    llvm_unreachable(\"I don't know size of pointer!\");\n  }\n\n  return new (Context) GNUNullExpr(Ty, TokenLoc);\n}\n\nExprResult Sema::ActOnSourceLocExpr(SourceLocExpr::IdentKind Kind,\n                                    SourceLocation BuiltinLoc,\n                                    SourceLocation RPLoc) {\n  return BuildSourceLocExpr(Kind, BuiltinLoc, RPLoc, CurContext);\n}\n\nExprResult Sema::BuildSourceLocExpr(SourceLocExpr::IdentKind Kind,\n                                    SourceLocation BuiltinLoc,\n                                    SourceLocation RPLoc,\n                                    DeclContext *ParentContext) {\n  return new (Context)\n      SourceLocExpr(Context, Kind, BuiltinLoc, RPLoc, ParentContext);\n}\n\nbool Sema::CheckConversionToObjCLiteral(QualType DstType, Expr *&Exp,\n                                        bool Diagnose) {\n  if (!getLangOpts().ObjC)\n    return false;\n\n  const ObjCObjectPointerType *PT = DstType->getAs<ObjCObjectPointerType>();\n  if (!PT)\n    return false;\n  const ObjCInterfaceDecl *ID = PT->getInterfaceDecl();\n\n  // Ignore any parens, implicit casts (should only be\n  // array-to-pointer decays), and not-so-opaque values.  The last is\n  // important for making this trigger for property assignments.\n  Expr *SrcExpr = Exp->IgnoreParenImpCasts();\n  if (OpaqueValueExpr *OV = dyn_cast<OpaqueValueExpr>(SrcExpr))\n    if (OV->getSourceExpr())\n      SrcExpr = OV->getSourceExpr()->IgnoreParenImpCasts();\n\n  if (auto *SL = dyn_cast<StringLiteral>(SrcExpr)) {\n    if (!PT->isObjCIdType() &&\n        !(ID && ID->getIdentifier()->isStr(\"NSString\")))\n      return false;\n    if (!SL->isAscii())\n      return false;\n\n    if (Diagnose) {\n      Diag(SL->getBeginLoc(), diag::err_missing_atsign_prefix)\n          << /*string*/0 << FixItHint::CreateInsertion(SL->getBeginLoc(), \"@\");\n      Exp = BuildObjCStringLiteral(SL->getBeginLoc(), SL).get();\n    }\n    return true;\n  }\n\n  if ((isa<IntegerLiteral>(SrcExpr) || isa<CharacterLiteral>(SrcExpr) ||\n      isa<FloatingLiteral>(SrcExpr) || isa<ObjCBoolLiteralExpr>(SrcExpr) ||\n      isa<CXXBoolLiteralExpr>(SrcExpr)) &&\n      !SrcExpr->isNullPointerConstant(\n          getASTContext(), Expr::NPC_NeverValueDependent)) {\n    if (!ID || !ID->getIdentifier()->isStr(\"NSNumber\"))\n      return false;\n    if (Diagnose) {\n      Diag(SrcExpr->getBeginLoc(), diag::err_missing_atsign_prefix)\n          << /*number*/1\n          << FixItHint::CreateInsertion(SrcExpr->getBeginLoc(), \"@\");\n      Expr *NumLit =\n          BuildObjCNumericLiteral(SrcExpr->getBeginLoc(), SrcExpr).get();\n      if (NumLit)\n        Exp = NumLit;\n    }\n    return true;\n  }\n\n  return false;\n}\n\nstatic bool maybeDiagnoseAssignmentToFunction(Sema &S, QualType DstType,\n                                              const Expr *SrcExpr) {\n  if (!DstType->isFunctionPointerType() ||\n      !SrcExpr->getType()->isFunctionType())\n    return false;\n\n  auto *DRE = dyn_cast<DeclRefExpr>(SrcExpr->IgnoreParenImpCasts());\n  if (!DRE)\n    return false;\n\n  auto *FD = dyn_cast<FunctionDecl>(DRE->getDecl());\n  if (!FD)\n    return false;\n\n  return !S.checkAddressOfFunctionIsAvailable(FD,\n                                              /*Complain=*/true,\n                                              SrcExpr->getBeginLoc());\n}\n\nbool Sema::DiagnoseAssignmentResult(AssignConvertType ConvTy,\n                                    SourceLocation Loc,\n                                    QualType DstType, QualType SrcType,\n                                    Expr *SrcExpr, AssignmentAction Action,\n                                    bool *Complained) {\n  if (Complained)\n    *Complained = false;\n\n  // Decode the result (notice that AST's are still created for extensions).\n  bool CheckInferredResultType = false;\n  bool isInvalid = false;\n  unsigned DiagKind = 0;\n  ConversionFixItGenerator ConvHints;\n  bool MayHaveConvFixit = false;\n  bool MayHaveFunctionDiff = false;\n  const ObjCInterfaceDecl *IFace = nullptr;\n  const ObjCProtocolDecl *PDecl = nullptr;\n\n  switch (ConvTy) {\n  case Compatible:\n      DiagnoseAssignmentEnum(DstType, SrcType, SrcExpr);\n      return false;\n\n  case PointerToInt:\n    if (getLangOpts().CPlusPlus) {\n      DiagKind = diag::err_typecheck_convert_pointer_int;\n      isInvalid = true;\n    } else {\n      DiagKind = diag::ext_typecheck_convert_pointer_int;\n    }\n    ConvHints.tryToFixConversion(SrcExpr, SrcType, DstType, *this);\n    MayHaveConvFixit = true;\n    break;\n  case IntToPointer:\n    if (getLangOpts().CPlusPlus) {\n      DiagKind = diag::err_typecheck_convert_int_pointer;\n      isInvalid = true;\n    } else {\n      DiagKind = diag::ext_typecheck_convert_int_pointer;\n    }\n    ConvHints.tryToFixConversion(SrcExpr, SrcType, DstType, *this);\n    MayHaveConvFixit = true;\n    break;\n  case IncompatibleFunctionPointer:\n    if (getLangOpts().CPlusPlus) {\n      DiagKind = diag::err_typecheck_convert_incompatible_function_pointer;\n      isInvalid = true;\n    } else {\n      DiagKind = diag::ext_typecheck_convert_incompatible_function_pointer;\n    }\n    ConvHints.tryToFixConversion(SrcExpr, SrcType, DstType, *this);\n    MayHaveConvFixit = true;\n    break;\n  case IncompatiblePointer:\n    if (Action == AA_Passing_CFAudited) {\n      DiagKind = diag::err_arc_typecheck_convert_incompatible_pointer;\n    } else if (getLangOpts().CPlusPlus) {\n      DiagKind = diag::err_typecheck_convert_incompatible_pointer;\n      isInvalid = true;\n    } else {\n      DiagKind = diag::ext_typecheck_convert_incompatible_pointer;\n    }\n    CheckInferredResultType = DstType->isObjCObjectPointerType() &&\n      SrcType->isObjCObjectPointerType();\n    if (!CheckInferredResultType) {\n      ConvHints.tryToFixConversion(SrcExpr, SrcType, DstType, *this);\n    } else if (CheckInferredResultType) {\n      SrcType = SrcType.getUnqualifiedType();\n      DstType = DstType.getUnqualifiedType();\n    }\n    MayHaveConvFixit = true;\n    break;\n  case IncompatiblePointerSign:\n    if (getLangOpts().CPlusPlus) {\n      DiagKind = diag::err_typecheck_convert_incompatible_pointer_sign;\n      isInvalid = true;\n    } else {\n      DiagKind = diag::ext_typecheck_convert_incompatible_pointer_sign;\n    }\n    break;\n  case FunctionVoidPointer:\n    if (getLangOpts().CPlusPlus) {\n      DiagKind = diag::err_typecheck_convert_pointer_void_func;\n      isInvalid = true;\n    } else {\n      DiagKind = diag::ext_typecheck_convert_pointer_void_func;\n    }\n    break;\n  case IncompatiblePointerDiscardsQualifiers: {\n    // Perform array-to-pointer decay if necessary.\n    if (SrcType->isArrayType()) SrcType = Context.getArrayDecayedType(SrcType);\n\n    isInvalid = true;\n\n    Qualifiers lhq = SrcType->getPointeeType().getQualifiers();\n    Qualifiers rhq = DstType->getPointeeType().getQualifiers();\n    if (lhq.getAddressSpace() != rhq.getAddressSpace()) {\n      DiagKind = diag::err_typecheck_incompatible_address_space;\n      break;\n\n    } else if (lhq.getObjCLifetime() != rhq.getObjCLifetime()) {\n      DiagKind = diag::err_typecheck_incompatible_ownership;\n      break;\n    }\n\n    llvm_unreachable(\"unknown error case for discarding qualifiers!\");\n    // fallthrough\n  }\n  case CompatiblePointerDiscardsQualifiers:\n    // If the qualifiers lost were because we were applying the\n    // (deprecated) C++ conversion from a string literal to a char*\n    // (or wchar_t*), then there was no error (C++ 4.2p2).  FIXME:\n    // Ideally, this check would be performed in\n    // checkPointerTypesForAssignment. However, that would require a\n    // bit of refactoring (so that the second argument is an\n    // expression, rather than a type), which should be done as part\n    // of a larger effort to fix checkPointerTypesForAssignment for\n    // C++ semantics.\n    if (getLangOpts().CPlusPlus &&\n        IsStringLiteralToNonConstPointerConversion(SrcExpr, DstType))\n      return false;\n    if (getLangOpts().CPlusPlus) {\n      DiagKind =  diag::err_typecheck_convert_discards_qualifiers;\n      isInvalid = true;\n    } else {\n      DiagKind =  diag::ext_typecheck_convert_discards_qualifiers;\n    }\n\n    break;\n  case IncompatibleNestedPointerQualifiers:\n    if (getLangOpts().CPlusPlus) {\n      isInvalid = true;\n      DiagKind = diag::err_nested_pointer_qualifier_mismatch;\n    } else {\n      DiagKind = diag::ext_nested_pointer_qualifier_mismatch;\n    }\n    break;\n  case IncompatibleNestedPointerAddressSpaceMismatch:\n    DiagKind = diag::err_typecheck_incompatible_nested_address_space;\n    isInvalid = true;\n    break;\n  case IntToBlockPointer:\n    DiagKind = diag::err_int_to_block_pointer;\n    isInvalid = true;\n    break;\n  case IncompatibleBlockPointer:\n    DiagKind = diag::err_typecheck_convert_incompatible_block_pointer;\n    isInvalid = true;\n    break;\n  case IncompatibleObjCQualifiedId: {\n    if (SrcType->isObjCQualifiedIdType()) {\n      const ObjCObjectPointerType *srcOPT =\n                SrcType->castAs<ObjCObjectPointerType>();\n      for (auto *srcProto : srcOPT->quals()) {\n        PDecl = srcProto;\n        break;\n      }\n      if (const ObjCInterfaceType *IFaceT =\n            DstType->castAs<ObjCObjectPointerType>()->getInterfaceType())\n        IFace = IFaceT->getDecl();\n    }\n    else if (DstType->isObjCQualifiedIdType()) {\n      const ObjCObjectPointerType *dstOPT =\n        DstType->castAs<ObjCObjectPointerType>();\n      for (auto *dstProto : dstOPT->quals()) {\n        PDecl = dstProto;\n        break;\n      }\n      if (const ObjCInterfaceType *IFaceT =\n            SrcType->castAs<ObjCObjectPointerType>()->getInterfaceType())\n        IFace = IFaceT->getDecl();\n    }\n    if (getLangOpts().CPlusPlus) {\n      DiagKind = diag::err_incompatible_qualified_id;\n      isInvalid = true;\n    } else {\n      DiagKind = diag::warn_incompatible_qualified_id;\n    }\n    break;\n  }\n  case IncompatibleVectors:\n    if (getLangOpts().CPlusPlus) {\n      DiagKind = diag::err_incompatible_vectors;\n      isInvalid = true;\n    } else {\n      DiagKind = diag::warn_incompatible_vectors;\n    }\n    break;\n  case IncompatibleObjCWeakRef:\n    DiagKind = diag::err_arc_weak_unavailable_assign;\n    isInvalid = true;\n    break;\n  case Incompatible:\n    if (maybeDiagnoseAssignmentToFunction(*this, DstType, SrcExpr)) {\n      if (Complained)\n        *Complained = true;\n      return true;\n    }\n\n    DiagKind = diag::err_typecheck_convert_incompatible;\n    ConvHints.tryToFixConversion(SrcExpr, SrcType, DstType, *this);\n    MayHaveConvFixit = true;\n    isInvalid = true;\n    MayHaveFunctionDiff = true;\n    break;\n  }\n\n  QualType FirstType, SecondType;\n  switch (Action) {\n  case AA_Assigning:\n  case AA_Initializing:\n    // The destination type comes first.\n    FirstType = DstType;\n    SecondType = SrcType;\n    break;\n\n  case AA_Returning:\n  case AA_Passing:\n  case AA_Passing_CFAudited:\n  case AA_Converting:\n  case AA_Sending:\n  case AA_Casting:\n    // The source type comes first.\n    FirstType = SrcType;\n    SecondType = DstType;\n    break;\n  }\n\n  PartialDiagnostic FDiag = PDiag(DiagKind);\n  if (Action == AA_Passing_CFAudited)\n    FDiag << FirstType << SecondType << AA_Passing << SrcExpr->getSourceRange();\n  else\n    FDiag << FirstType << SecondType << Action << SrcExpr->getSourceRange();\n\n  if (DiagKind == diag::ext_typecheck_convert_incompatible_pointer_sign ||\n      DiagKind == diag::err_typecheck_convert_incompatible_pointer_sign) {\n    auto isPlainChar = [](const clang::Type *Type) {\n      return Type->isSpecificBuiltinType(BuiltinType::Char_S) ||\n             Type->isSpecificBuiltinType(BuiltinType::Char_U);\n    };\n    FDiag << (isPlainChar(FirstType->getPointeeOrArrayElementType()) ||\n              isPlainChar(SecondType->getPointeeOrArrayElementType()));\n  }\n\n  // If we can fix the conversion, suggest the FixIts.\n  if (!ConvHints.isNull()) {\n    for (FixItHint &H : ConvHints.Hints)\n      FDiag << H;\n  }\n\n  if (MayHaveConvFixit) { FDiag << (unsigned) (ConvHints.Kind); }\n\n  if (MayHaveFunctionDiff)\n    HandleFunctionTypeMismatch(FDiag, SecondType, FirstType);\n\n  Diag(Loc, FDiag);\n  if ((DiagKind == diag::warn_incompatible_qualified_id ||\n       DiagKind == diag::err_incompatible_qualified_id) &&\n      PDecl && IFace && !IFace->hasDefinition())\n    Diag(IFace->getLocation(), diag::note_incomplete_class_and_qualified_id)\n        << IFace << PDecl;\n\n  if (SecondType == Context.OverloadTy)\n    NoteAllOverloadCandidates(OverloadExpr::find(SrcExpr).Expression,\n                              FirstType, /*TakingAddress=*/true);\n\n  if (CheckInferredResultType)\n    EmitRelatedResultTypeNote(SrcExpr);\n\n  if (Action == AA_Returning && ConvTy == IncompatiblePointer)\n    EmitRelatedResultTypeNoteForReturn(DstType);\n\n  if (Complained)\n    *Complained = true;\n  return isInvalid;\n}\n\nExprResult Sema::VerifyIntegerConstantExpression(Expr *E,\n                                                 llvm::APSInt *Result,\n                                                 AllowFoldKind CanFold) {\n  class SimpleICEDiagnoser : public VerifyICEDiagnoser {\n  public:\n    SemaDiagnosticBuilder diagnoseNotICEType(Sema &S, SourceLocation Loc,\n                                             QualType T) override {\n      return S.Diag(Loc, diag::err_ice_not_integral)\n             << T << S.LangOpts.CPlusPlus;\n    }\n    SemaDiagnosticBuilder diagnoseNotICE(Sema &S, SourceLocation Loc) override {\n      return S.Diag(Loc, diag::err_expr_not_ice) << S.LangOpts.CPlusPlus;\n    }\n  } Diagnoser;\n\n  return VerifyIntegerConstantExpression(E, Result, Diagnoser, CanFold);\n}\n\nExprResult Sema::VerifyIntegerConstantExpression(Expr *E,\n                                                 llvm::APSInt *Result,\n                                                 unsigned DiagID,\n                                                 AllowFoldKind CanFold) {\n  class IDDiagnoser : public VerifyICEDiagnoser {\n    unsigned DiagID;\n\n  public:\n    IDDiagnoser(unsigned DiagID)\n      : VerifyICEDiagnoser(DiagID == 0), DiagID(DiagID) { }\n\n    SemaDiagnosticBuilder diagnoseNotICE(Sema &S, SourceLocation Loc) override {\n      return S.Diag(Loc, DiagID);\n    }\n  } Diagnoser(DiagID);\n\n  return VerifyIntegerConstantExpression(E, Result, Diagnoser, CanFold);\n}\n\nSema::SemaDiagnosticBuilder\nSema::VerifyICEDiagnoser::diagnoseNotICEType(Sema &S, SourceLocation Loc,\n                                             QualType T) {\n  return diagnoseNotICE(S, Loc);\n}\n\nSema::SemaDiagnosticBuilder\nSema::VerifyICEDiagnoser::diagnoseFold(Sema &S, SourceLocation Loc) {\n  return S.Diag(Loc, diag::ext_expr_not_ice) << S.LangOpts.CPlusPlus;\n}\n\nExprResult\nSema::VerifyIntegerConstantExpression(Expr *E, llvm::APSInt *Result,\n                                      VerifyICEDiagnoser &Diagnoser,\n                                      AllowFoldKind CanFold) {\n  SourceLocation DiagLoc = E->getBeginLoc();\n\n  if (getLangOpts().CPlusPlus11) {\n    // C++11 [expr.const]p5:\n    //   If an expression of literal class type is used in a context where an\n    //   integral constant expression is required, then that class type shall\n    //   have a single non-explicit conversion function to an integral or\n    //   unscoped enumeration type\n    ExprResult Converted;\n    class CXX11ConvertDiagnoser : public ICEConvertDiagnoser {\n      VerifyICEDiagnoser &BaseDiagnoser;\n    public:\n      CXX11ConvertDiagnoser(VerifyICEDiagnoser &BaseDiagnoser)\n          : ICEConvertDiagnoser(/*AllowScopedEnumerations*/ false,\n                                BaseDiagnoser.Suppress, true),\n            BaseDiagnoser(BaseDiagnoser) {}\n\n      SemaDiagnosticBuilder diagnoseNotInt(Sema &S, SourceLocation Loc,\n                                           QualType T) override {\n        return BaseDiagnoser.diagnoseNotICEType(S, Loc, T);\n      }\n\n      SemaDiagnosticBuilder diagnoseIncomplete(\n          Sema &S, SourceLocation Loc, QualType T) override {\n        return S.Diag(Loc, diag::err_ice_incomplete_type) << T;\n      }\n\n      SemaDiagnosticBuilder diagnoseExplicitConv(\n          Sema &S, SourceLocation Loc, QualType T, QualType ConvTy) override {\n        return S.Diag(Loc, diag::err_ice_explicit_conversion) << T << ConvTy;\n      }\n\n      SemaDiagnosticBuilder noteExplicitConv(\n          Sema &S, CXXConversionDecl *Conv, QualType ConvTy) override {\n        return S.Diag(Conv->getLocation(), diag::note_ice_conversion_here)\n                 << ConvTy->isEnumeralType() << ConvTy;\n      }\n\n      SemaDiagnosticBuilder diagnoseAmbiguous(\n          Sema &S, SourceLocation Loc, QualType T) override {\n        return S.Diag(Loc, diag::err_ice_ambiguous_conversion) << T;\n      }\n\n      SemaDiagnosticBuilder noteAmbiguous(\n          Sema &S, CXXConversionDecl *Conv, QualType ConvTy) override {\n        return S.Diag(Conv->getLocation(), diag::note_ice_conversion_here)\n                 << ConvTy->isEnumeralType() << ConvTy;\n      }\n\n      SemaDiagnosticBuilder diagnoseConversion(\n          Sema &S, SourceLocation Loc, QualType T, QualType ConvTy) override {\n        llvm_unreachable(\"conversion functions are permitted\");\n      }\n    } ConvertDiagnoser(Diagnoser);\n\n    Converted = PerformContextualImplicitConversion(DiagLoc, E,\n                                                    ConvertDiagnoser);\n    if (Converted.isInvalid())\n      return Converted;\n    E = Converted.get();\n    if (!E->getType()->isIntegralOrUnscopedEnumerationType())\n      return ExprError();\n  } else if (!E->getType()->isIntegralOrUnscopedEnumerationType()) {\n    // An ICE must be of integral or unscoped enumeration type.\n    if (!Diagnoser.Suppress)\n      Diagnoser.diagnoseNotICEType(*this, DiagLoc, E->getType())\n          << E->getSourceRange();\n    return ExprError();\n  }\n\n  ExprResult RValueExpr = DefaultLvalueConversion(E);\n  if (RValueExpr.isInvalid())\n    return ExprError();\n\n  E = RValueExpr.get();\n\n  // Circumvent ICE checking in C++11 to avoid evaluating the expression twice\n  // in the non-ICE case.\n  if (!getLangOpts().CPlusPlus11 && E->isIntegerConstantExpr(Context)) {\n    if (Result)\n      *Result = E->EvaluateKnownConstIntCheckOverflow(Context);\n    if (!isa<ConstantExpr>(E))\n      E = Result ? ConstantExpr::Create(Context, E, APValue(*Result))\n                 : ConstantExpr::Create(Context, E);\n    return E;\n  }\n\n  Expr::EvalResult EvalResult;\n  SmallVector<PartialDiagnosticAt, 8> Notes;\n  EvalResult.Diag = &Notes;\n\n  // Try to evaluate the expression, and produce diagnostics explaining why it's\n  // not a constant expression as a side-effect.\n  bool Folded =\n      E->EvaluateAsRValue(EvalResult, Context, /*isConstantContext*/ true) &&\n      EvalResult.Val.isInt() && !EvalResult.HasSideEffects;\n\n  if (!isa<ConstantExpr>(E))\n    E = ConstantExpr::Create(Context, E, EvalResult.Val);\n\n  // In C++11, we can rely on diagnostics being produced for any expression\n  // which is not a constant expression. If no diagnostics were produced, then\n  // this is a constant expression.\n  if (Folded && getLangOpts().CPlusPlus11 && Notes.empty()) {\n    if (Result)\n      *Result = EvalResult.Val.getInt();\n    return E;\n  }\n\n  // If our only note is the usual \"invalid subexpression\" note, just point\n  // the caret at its location rather than producing an essentially\n  // redundant note.\n  if (Notes.size() == 1 && Notes[0].second.getDiagID() ==\n        diag::note_invalid_subexpr_in_const_expr) {\n    DiagLoc = Notes[0].first;\n    Notes.clear();\n  }\n\n  if (!Folded || !CanFold) {\n    if (!Diagnoser.Suppress) {\n      Diagnoser.diagnoseNotICE(*this, DiagLoc) << E->getSourceRange();\n      for (const PartialDiagnosticAt &Note : Notes)\n        Diag(Note.first, Note.second);\n    }\n\n    return ExprError();\n  }\n\n  Diagnoser.diagnoseFold(*this, DiagLoc) << E->getSourceRange();\n  for (const PartialDiagnosticAt &Note : Notes)\n    Diag(Note.first, Note.second);\n\n  if (Result)\n    *Result = EvalResult.Val.getInt();\n  return E;\n}\n\nnamespace {\n  // Handle the case where we conclude a expression which we speculatively\n  // considered to be unevaluated is actually evaluated.\n  class TransformToPE : public TreeTransform<TransformToPE> {\n    typedef TreeTransform<TransformToPE> BaseTransform;\n\n  public:\n    TransformToPE(Sema &SemaRef) : BaseTransform(SemaRef) { }\n\n    // Make sure we redo semantic analysis\n    bool AlwaysRebuild() { return true; }\n    bool ReplacingOriginal() { return true; }\n\n    // We need to special-case DeclRefExprs referring to FieldDecls which\n    // are not part of a member pointer formation; normal TreeTransforming\n    // doesn't catch this case because of the way we represent them in the AST.\n    // FIXME: This is a bit ugly; is it really the best way to handle this\n    // case?\n    //\n    // Error on DeclRefExprs referring to FieldDecls.\n    ExprResult TransformDeclRefExpr(DeclRefExpr *E) {\n      if (isa<FieldDecl>(E->getDecl()) &&\n          !SemaRef.isUnevaluatedContext())\n        return SemaRef.Diag(E->getLocation(),\n                            diag::err_invalid_non_static_member_use)\n            << E->getDecl() << E->getSourceRange();\n\n      return BaseTransform::TransformDeclRefExpr(E);\n    }\n\n    // Exception: filter out member pointer formation\n    ExprResult TransformUnaryOperator(UnaryOperator *E) {\n      if (E->getOpcode() == UO_AddrOf && E->getType()->isMemberPointerType())\n        return E;\n\n      return BaseTransform::TransformUnaryOperator(E);\n    }\n\n    // The body of a lambda-expression is in a separate expression evaluation\n    // context so never needs to be transformed.\n    // FIXME: Ideally we wouldn't transform the closure type either, and would\n    // just recreate the capture expressions and lambda expression.\n    StmtResult TransformLambdaBody(LambdaExpr *E, Stmt *Body) {\n      return SkipLambdaBody(E, Body);\n    }\n  };\n}\n\nExprResult Sema::TransformToPotentiallyEvaluated(Expr *E) {\n  assert(isUnevaluatedContext() &&\n         \"Should only transform unevaluated expressions\");\n  ExprEvalContexts.back().Context =\n      ExprEvalContexts[ExprEvalContexts.size()-2].Context;\n  if (isUnevaluatedContext())\n    return E;\n  return TransformToPE(*this).TransformExpr(E);\n}\n\nvoid\nSema::PushExpressionEvaluationContext(\n    ExpressionEvaluationContext NewContext, Decl *LambdaContextDecl,\n    ExpressionEvaluationContextRecord::ExpressionKind ExprContext) {\n  ExprEvalContexts.emplace_back(NewContext, ExprCleanupObjects.size(), Cleanup,\n                                LambdaContextDecl, ExprContext);\n  Cleanup.reset();\n  if (!MaybeODRUseExprs.empty())\n    std::swap(MaybeODRUseExprs, ExprEvalContexts.back().SavedMaybeODRUseExprs);\n}\n\nvoid\nSema::PushExpressionEvaluationContext(\n    ExpressionEvaluationContext NewContext, ReuseLambdaContextDecl_t,\n    ExpressionEvaluationContextRecord::ExpressionKind ExprContext) {\n  Decl *ClosureContextDecl = ExprEvalContexts.back().ManglingContextDecl;\n  PushExpressionEvaluationContext(NewContext, ClosureContextDecl, ExprContext);\n}\n\nnamespace {\n\nconst DeclRefExpr *CheckPossibleDeref(Sema &S, const Expr *PossibleDeref) {\n  PossibleDeref = PossibleDeref->IgnoreParenImpCasts();\n  if (const auto *E = dyn_cast<UnaryOperator>(PossibleDeref)) {\n    if (E->getOpcode() == UO_Deref)\n      return CheckPossibleDeref(S, E->getSubExpr());\n  } else if (const auto *E = dyn_cast<ArraySubscriptExpr>(PossibleDeref)) {\n    return CheckPossibleDeref(S, E->getBase());\n  } else if (const auto *E = dyn_cast<MemberExpr>(PossibleDeref)) {\n    return CheckPossibleDeref(S, E->getBase());\n  } else if (const auto E = dyn_cast<DeclRefExpr>(PossibleDeref)) {\n    QualType Inner;\n    QualType Ty = E->getType();\n    if (const auto *Ptr = Ty->getAs<PointerType>())\n      Inner = Ptr->getPointeeType();\n    else if (const auto *Arr = S.Context.getAsArrayType(Ty))\n      Inner = Arr->getElementType();\n    else\n      return nullptr;\n\n    if (Inner->hasAttr(attr::NoDeref))\n      return E;\n  }\n  return nullptr;\n}\n\n} // namespace\n\nvoid Sema::WarnOnPendingNoDerefs(ExpressionEvaluationContextRecord &Rec) {\n  for (const Expr *E : Rec.PossibleDerefs) {\n    const DeclRefExpr *DeclRef = CheckPossibleDeref(*this, E);\n    if (DeclRef) {\n      const ValueDecl *Decl = DeclRef->getDecl();\n      Diag(E->getExprLoc(), diag::warn_dereference_of_noderef_type)\n          << Decl->getName() << E->getSourceRange();\n      Diag(Decl->getLocation(), diag::note_previous_decl) << Decl->getName();\n    } else {\n      Diag(E->getExprLoc(), diag::warn_dereference_of_noderef_type_no_decl)\n          << E->getSourceRange();\n    }\n  }\n  Rec.PossibleDerefs.clear();\n}\n\n/// Check whether E, which is either a discarded-value expression or an\n/// unevaluated operand, is a simple-assignment to a volatlie-qualified lvalue,\n/// and if so, remove it from the list of volatile-qualified assignments that\n/// we are going to warn are deprecated.\nvoid Sema::CheckUnusedVolatileAssignment(Expr *E) {\n  if (!E->getType().isVolatileQualified() || !getLangOpts().CPlusPlus20)\n    return;\n\n  // Note: ignoring parens here is not justified by the standard rules, but\n  // ignoring parentheses seems like a more reasonable approach, and this only\n  // drives a deprecation warning so doesn't affect conformance.\n  if (auto *BO = dyn_cast<BinaryOperator>(E->IgnoreParenImpCasts())) {\n    if (BO->getOpcode() == BO_Assign) {\n      auto &LHSs = ExprEvalContexts.back().VolatileAssignmentLHSs;\n      LHSs.erase(std::remove(LHSs.begin(), LHSs.end(), BO->getLHS()),\n                 LHSs.end());\n    }\n  }\n}\n\nExprResult Sema::CheckForImmediateInvocation(ExprResult E, FunctionDecl *Decl) {\n  if (!E.isUsable() || !Decl || !Decl->isConsteval() || isConstantEvaluated() ||\n      RebuildingImmediateInvocation)\n    return E;\n\n  /// Opportunistically remove the callee from ReferencesToConsteval if we can.\n  /// It's OK if this fails; we'll also remove this in\n  /// HandleImmediateInvocations, but catching it here allows us to avoid\n  /// walking the AST looking for it in simple cases.\n  if (auto *Call = dyn_cast<CallExpr>(E.get()->IgnoreImplicit()))\n    if (auto *DeclRef =\n            dyn_cast<DeclRefExpr>(Call->getCallee()->IgnoreImplicit()))\n      ExprEvalContexts.back().ReferenceToConsteval.erase(DeclRef);\n\n  E = MaybeCreateExprWithCleanups(E);\n\n  ConstantExpr *Res = ConstantExpr::Create(\n      getASTContext(), E.get(),\n      ConstantExpr::getStorageKind(Decl->getReturnType().getTypePtr(),\n                                   getASTContext()),\n      /*IsImmediateInvocation*/ true);\n  ExprEvalContexts.back().ImmediateInvocationCandidates.emplace_back(Res, 0);\n  return Res;\n}\n\nstatic void EvaluateAndDiagnoseImmediateInvocation(\n    Sema &SemaRef, Sema::ImmediateInvocationCandidate Candidate) {\n  llvm::SmallVector<PartialDiagnosticAt, 8> Notes;\n  Expr::EvalResult Eval;\n  Eval.Diag = &Notes;\n  ConstantExpr *CE = Candidate.getPointer();\n  bool Result = CE->EvaluateAsConstantExpr(\n      Eval, SemaRef.getASTContext(), ConstantExprKind::ImmediateInvocation);\n  if (!Result || !Notes.empty()) {\n    Expr *InnerExpr = CE->getSubExpr()->IgnoreImplicit();\n    if (auto *FunctionalCast = dyn_cast<CXXFunctionalCastExpr>(InnerExpr))\n      InnerExpr = FunctionalCast->getSubExpr();\n    FunctionDecl *FD = nullptr;\n    if (auto *Call = dyn_cast<CallExpr>(InnerExpr))\n      FD = cast<FunctionDecl>(Call->getCalleeDecl());\n    else if (auto *Call = dyn_cast<CXXConstructExpr>(InnerExpr))\n      FD = Call->getConstructor();\n    else\n      llvm_unreachable(\"unhandled decl kind\");\n    assert(FD->isConsteval());\n    SemaRef.Diag(CE->getBeginLoc(), diag::err_invalid_consteval_call) << FD;\n    for (auto &Note : Notes)\n      SemaRef.Diag(Note.first, Note.second);\n    return;\n  }\n  CE->MoveIntoResult(Eval.Val, SemaRef.getASTContext());\n}\n\nstatic void RemoveNestedImmediateInvocation(\n    Sema &SemaRef, Sema::ExpressionEvaluationContextRecord &Rec,\n    SmallVector<Sema::ImmediateInvocationCandidate, 4>::reverse_iterator It) {\n  struct ComplexRemove : TreeTransform<ComplexRemove> {\n    using Base = TreeTransform<ComplexRemove>;\n    llvm::SmallPtrSetImpl<DeclRefExpr *> &DRSet;\n    SmallVector<Sema::ImmediateInvocationCandidate, 4> &IISet;\n    SmallVector<Sema::ImmediateInvocationCandidate, 4>::reverse_iterator\n        CurrentII;\n    ComplexRemove(Sema &SemaRef, llvm::SmallPtrSetImpl<DeclRefExpr *> &DR,\n                  SmallVector<Sema::ImmediateInvocationCandidate, 4> &II,\n                  SmallVector<Sema::ImmediateInvocationCandidate,\n                              4>::reverse_iterator Current)\n        : Base(SemaRef), DRSet(DR), IISet(II), CurrentII(Current) {}\n    void RemoveImmediateInvocation(ConstantExpr* E) {\n      auto It = std::find_if(CurrentII, IISet.rend(),\n                             [E](Sema::ImmediateInvocationCandidate Elem) {\n                               return Elem.getPointer() == E;\n                             });\n      assert(It != IISet.rend() &&\n             \"ConstantExpr marked IsImmediateInvocation should \"\n             \"be present\");\n      It->setInt(1); // Mark as deleted\n    }\n    ExprResult TransformConstantExpr(ConstantExpr *E) {\n      if (!E->isImmediateInvocation())\n        return Base::TransformConstantExpr(E);\n      RemoveImmediateInvocation(E);\n      return Base::TransformExpr(E->getSubExpr());\n    }\n    /// Base::TransfromCXXOperatorCallExpr doesn't traverse the callee so\n    /// we need to remove its DeclRefExpr from the DRSet.\n    ExprResult TransformCXXOperatorCallExpr(CXXOperatorCallExpr *E) {\n      DRSet.erase(cast<DeclRefExpr>(E->getCallee()->IgnoreImplicit()));\n      return Base::TransformCXXOperatorCallExpr(E);\n    }\n    /// Base::TransformInitializer skip ConstantExpr so we need to visit them\n    /// here.\n    ExprResult TransformInitializer(Expr *Init, bool NotCopyInit) {\n      if (!Init)\n        return Init;\n      /// ConstantExpr are the first layer of implicit node to be removed so if\n      /// Init isn't a ConstantExpr, no ConstantExpr will be skipped.\n      if (auto *CE = dyn_cast<ConstantExpr>(Init))\n        if (CE->isImmediateInvocation())\n          RemoveImmediateInvocation(CE);\n      return Base::TransformInitializer(Init, NotCopyInit);\n    }\n    ExprResult TransformDeclRefExpr(DeclRefExpr *E) {\n      DRSet.erase(E);\n      return E;\n    }\n    bool AlwaysRebuild() { return false; }\n    bool ReplacingOriginal() { return true; }\n    bool AllowSkippingCXXConstructExpr() {\n      bool Res = AllowSkippingFirstCXXConstructExpr;\n      AllowSkippingFirstCXXConstructExpr = true;\n      return Res;\n    }\n    bool AllowSkippingFirstCXXConstructExpr = true;\n  } Transformer(SemaRef, Rec.ReferenceToConsteval,\n                Rec.ImmediateInvocationCandidates, It);\n\n  /// CXXConstructExpr with a single argument are getting skipped by\n  /// TreeTransform in some situtation because they could be implicit. This\n  /// can only occur for the top-level CXXConstructExpr because it is used\n  /// nowhere in the expression being transformed therefore will not be rebuilt.\n  /// Setting AllowSkippingFirstCXXConstructExpr to false will prevent from\n  /// skipping the first CXXConstructExpr.\n  if (isa<CXXConstructExpr>(It->getPointer()->IgnoreImplicit()))\n    Transformer.AllowSkippingFirstCXXConstructExpr = false;\n\n  ExprResult Res = Transformer.TransformExpr(It->getPointer()->getSubExpr());\n  assert(Res.isUsable());\n  Res = SemaRef.MaybeCreateExprWithCleanups(Res);\n  It->getPointer()->setSubExpr(Res.get());\n}\n\nstatic void\nHandleImmediateInvocations(Sema &SemaRef,\n                           Sema::ExpressionEvaluationContextRecord &Rec) {\n  if ((Rec.ImmediateInvocationCandidates.size() == 0 &&\n       Rec.ReferenceToConsteval.size() == 0) ||\n      SemaRef.RebuildingImmediateInvocation)\n    return;\n\n  /// When we have more then 1 ImmediateInvocationCandidates we need to check\n  /// for nested ImmediateInvocationCandidates. when we have only 1 we only\n  /// need to remove ReferenceToConsteval in the immediate invocation.\n  if (Rec.ImmediateInvocationCandidates.size() > 1) {\n\n    /// Prevent sema calls during the tree transform from adding pointers that\n    /// are already in the sets.\n    llvm::SaveAndRestore<bool> DisableIITracking(\n        SemaRef.RebuildingImmediateInvocation, true);\n\n    /// Prevent diagnostic during tree transfrom as they are duplicates\n    Sema::TentativeAnalysisScope DisableDiag(SemaRef);\n\n    for (auto It = Rec.ImmediateInvocationCandidates.rbegin();\n         It != Rec.ImmediateInvocationCandidates.rend(); It++)\n      if (!It->getInt())\n        RemoveNestedImmediateInvocation(SemaRef, Rec, It);\n  } else if (Rec.ImmediateInvocationCandidates.size() == 1 &&\n             Rec.ReferenceToConsteval.size()) {\n    struct SimpleRemove : RecursiveASTVisitor<SimpleRemove> {\n      llvm::SmallPtrSetImpl<DeclRefExpr *> &DRSet;\n      SimpleRemove(llvm::SmallPtrSetImpl<DeclRefExpr *> &S) : DRSet(S) {}\n      bool VisitDeclRefExpr(DeclRefExpr *E) {\n        DRSet.erase(E);\n        return DRSet.size();\n      }\n    } Visitor(Rec.ReferenceToConsteval);\n    Visitor.TraverseStmt(\n        Rec.ImmediateInvocationCandidates.front().getPointer()->getSubExpr());\n  }\n  for (auto CE : Rec.ImmediateInvocationCandidates)\n    if (!CE.getInt())\n      EvaluateAndDiagnoseImmediateInvocation(SemaRef, CE);\n  for (auto DR : Rec.ReferenceToConsteval) {\n    auto *FD = cast<FunctionDecl>(DR->getDecl());\n    SemaRef.Diag(DR->getBeginLoc(), diag::err_invalid_consteval_take_address)\n        << FD;\n    SemaRef.Diag(FD->getLocation(), diag::note_declared_at);\n  }\n}\n\nvoid Sema::PopExpressionEvaluationContext() {\n  ExpressionEvaluationContextRecord& Rec = ExprEvalContexts.back();\n  unsigned NumTypos = Rec.NumTypos;\n\n  if (!Rec.Lambdas.empty()) {\n    using ExpressionKind = ExpressionEvaluationContextRecord::ExpressionKind;\n    if (Rec.ExprContext == ExpressionKind::EK_TemplateArgument || Rec.isUnevaluated() ||\n        (Rec.isConstantEvaluated() && !getLangOpts().CPlusPlus17)) {\n      unsigned D;\n      if (Rec.isUnevaluated()) {\n        // C++11 [expr.prim.lambda]p2:\n        //   A lambda-expression shall not appear in an unevaluated operand\n        //   (Clause 5).\n        D = diag::err_lambda_unevaluated_operand;\n      } else if (Rec.isConstantEvaluated() && !getLangOpts().CPlusPlus17) {\n        // C++1y [expr.const]p2:\n        //   A conditional-expression e is a core constant expression unless the\n        //   evaluation of e, following the rules of the abstract machine, would\n        //   evaluate [...] a lambda-expression.\n        D = diag::err_lambda_in_constant_expression;\n      } else if (Rec.ExprContext == ExpressionKind::EK_TemplateArgument) {\n        // C++17 [expr.prim.lamda]p2:\n        // A lambda-expression shall not appear [...] in a template-argument.\n        D = diag::err_lambda_in_invalid_context;\n      } else\n        llvm_unreachable(\"Couldn't infer lambda error message.\");\n\n      for (const auto *L : Rec.Lambdas)\n        Diag(L->getBeginLoc(), D);\n    }\n  }\n\n  WarnOnPendingNoDerefs(Rec);\n  HandleImmediateInvocations(*this, Rec);\n\n  // Warn on any volatile-qualified simple-assignments that are not discarded-\n  // value expressions nor unevaluated operands (those cases get removed from\n  // this list by CheckUnusedVolatileAssignment).\n  for (auto *BO : Rec.VolatileAssignmentLHSs)\n    Diag(BO->getBeginLoc(), diag::warn_deprecated_simple_assign_volatile)\n        << BO->getType();\n\n  // When are coming out of an unevaluated context, clear out any\n  // temporaries that we may have created as part of the evaluation of\n  // the expression in that context: they aren't relevant because they\n  // will never be constructed.\n  if (Rec.isUnevaluated() || Rec.isConstantEvaluated()) {\n    ExprCleanupObjects.erase(ExprCleanupObjects.begin() + Rec.NumCleanupObjects,\n                             ExprCleanupObjects.end());\n    Cleanup = Rec.ParentCleanup;\n    CleanupVarDeclMarking();\n    std::swap(MaybeODRUseExprs, Rec.SavedMaybeODRUseExprs);\n  // Otherwise, merge the contexts together.\n  } else {\n    Cleanup.mergeFrom(Rec.ParentCleanup);\n    MaybeODRUseExprs.insert(Rec.SavedMaybeODRUseExprs.begin(),\n                            Rec.SavedMaybeODRUseExprs.end());\n  }\n\n  // Pop the current expression evaluation context off the stack.\n  ExprEvalContexts.pop_back();\n\n  // The global expression evaluation context record is never popped.\n  ExprEvalContexts.back().NumTypos += NumTypos;\n}\n\nvoid Sema::DiscardCleanupsInEvaluationContext() {\n  ExprCleanupObjects.erase(\n         ExprCleanupObjects.begin() + ExprEvalContexts.back().NumCleanupObjects,\n         ExprCleanupObjects.end());\n  Cleanup.reset();\n  MaybeODRUseExprs.clear();\n}\n\nExprResult Sema::HandleExprEvaluationContextForTypeof(Expr *E) {\n  ExprResult Result = CheckPlaceholderExpr(E);\n  if (Result.isInvalid())\n    return ExprError();\n  E = Result.get();\n  if (!E->getType()->isVariablyModifiedType())\n    return E;\n  return TransformToPotentiallyEvaluated(E);\n}\n\n/// Are we in a context that is potentially constant evaluated per C++20\n/// [expr.const]p12?\nstatic bool isPotentiallyConstantEvaluatedContext(Sema &SemaRef) {\n  /// C++2a [expr.const]p12:\n  //   An expression or conversion is potentially constant evaluated if it is\n  switch (SemaRef.ExprEvalContexts.back().Context) {\n    case Sema::ExpressionEvaluationContext::ConstantEvaluated:\n      // -- a manifestly constant-evaluated expression,\n    case Sema::ExpressionEvaluationContext::PotentiallyEvaluated:\n    case Sema::ExpressionEvaluationContext::PotentiallyEvaluatedIfUsed:\n    case Sema::ExpressionEvaluationContext::DiscardedStatement:\n      // -- a potentially-evaluated expression,\n    case Sema::ExpressionEvaluationContext::UnevaluatedList:\n      // -- an immediate subexpression of a braced-init-list,\n\n      // -- [FIXME] an expression of the form & cast-expression that occurs\n      //    within a templated entity\n      // -- a subexpression of one of the above that is not a subexpression of\n      // a nested unevaluated operand.\n      return true;\n\n    case Sema::ExpressionEvaluationContext::Unevaluated:\n    case Sema::ExpressionEvaluationContext::UnevaluatedAbstract:\n      // Expressions in this context are never evaluated.\n      return false;\n  }\n  llvm_unreachable(\"Invalid context\");\n}\n\n/// Return true if this function has a calling convention that requires mangling\n/// in the size of the parameter pack.\nstatic bool funcHasParameterSizeMangling(Sema &S, FunctionDecl *FD) {\n  // These manglings don't do anything on non-Windows or non-x86 platforms, so\n  // we don't need parameter type sizes.\n  const llvm::Triple &TT = S.Context.getTargetInfo().getTriple();\n  if (!TT.isOSWindows() || !TT.isX86())\n    return false;\n\n  // If this is C++ and this isn't an extern \"C\" function, parameters do not\n  // need to be complete. In this case, C++ mangling will apply, which doesn't\n  // use the size of the parameters.\n  if (S.getLangOpts().CPlusPlus && !FD->isExternC())\n    return false;\n\n  // Stdcall, fastcall, and vectorcall need this special treatment.\n  CallingConv CC = FD->getType()->castAs<FunctionType>()->getCallConv();\n  switch (CC) {\n  case CC_X86StdCall:\n  case CC_X86FastCall:\n  case CC_X86VectorCall:\n    return true;\n  default:\n    break;\n  }\n  return false;\n}\n\n/// Require that all of the parameter types of function be complete. Normally,\n/// parameter types are only required to be complete when a function is called\n/// or defined, but to mangle functions with certain calling conventions, the\n/// mangler needs to know the size of the parameter list. In this situation,\n/// MSVC doesn't emit an error or instantiate templates. Instead, MSVC mangles\n/// the function as _foo@0, i.e. zero bytes of parameters, which will usually\n/// result in a linker error. Clang doesn't implement this behavior, and instead\n/// attempts to error at compile time.\nstatic void CheckCompleteParameterTypesForMangler(Sema &S, FunctionDecl *FD,\n                                                  SourceLocation Loc) {\n  class ParamIncompleteTypeDiagnoser : public Sema::TypeDiagnoser {\n    FunctionDecl *FD;\n    ParmVarDecl *Param;\n\n  public:\n    ParamIncompleteTypeDiagnoser(FunctionDecl *FD, ParmVarDecl *Param)\n        : FD(FD), Param(Param) {}\n\n    void diagnose(Sema &S, SourceLocation Loc, QualType T) override {\n      CallingConv CC = FD->getType()->castAs<FunctionType>()->getCallConv();\n      StringRef CCName;\n      switch (CC) {\n      case CC_X86StdCall:\n        CCName = \"stdcall\";\n        break;\n      case CC_X86FastCall:\n        CCName = \"fastcall\";\n        break;\n      case CC_X86VectorCall:\n        CCName = \"vectorcall\";\n        break;\n      default:\n        llvm_unreachable(\"CC does not need mangling\");\n      }\n\n      S.Diag(Loc, diag::err_cconv_incomplete_param_type)\n          << Param->getDeclName() << FD->getDeclName() << CCName;\n    }\n  };\n\n  for (ParmVarDecl *Param : FD->parameters()) {\n    ParamIncompleteTypeDiagnoser Diagnoser(FD, Param);\n    S.RequireCompleteType(Loc, Param->getType(), Diagnoser);\n  }\n}\n\nnamespace {\nenum class OdrUseContext {\n  /// Declarations in this context are not odr-used.\n  None,\n  /// Declarations in this context are formally odr-used, but this is a\n  /// dependent context.\n  Dependent,\n  /// Declarations in this context are odr-used but not actually used (yet).\n  FormallyOdrUsed,\n  /// Declarations in this context are used.\n  Used\n};\n}\n\n/// Are we within a context in which references to resolved functions or to\n/// variables result in odr-use?\nstatic OdrUseContext isOdrUseContext(Sema &SemaRef) {\n  OdrUseContext Result;\n\n  switch (SemaRef.ExprEvalContexts.back().Context) {\n    case Sema::ExpressionEvaluationContext::Unevaluated:\n    case Sema::ExpressionEvaluationContext::UnevaluatedList:\n    case Sema::ExpressionEvaluationContext::UnevaluatedAbstract:\n      return OdrUseContext::None;\n\n    case Sema::ExpressionEvaluationContext::ConstantEvaluated:\n    case Sema::ExpressionEvaluationContext::PotentiallyEvaluated:\n      Result = OdrUseContext::Used;\n      break;\n\n    case Sema::ExpressionEvaluationContext::DiscardedStatement:\n      Result = OdrUseContext::FormallyOdrUsed;\n      break;\n\n    case Sema::ExpressionEvaluationContext::PotentiallyEvaluatedIfUsed:\n      // A default argument formally results in odr-use, but doesn't actually\n      // result in a use in any real sense until it itself is used.\n      Result = OdrUseContext::FormallyOdrUsed;\n      break;\n  }\n\n  if (SemaRef.CurContext->isDependentContext())\n    return OdrUseContext::Dependent;\n\n  return Result;\n}\n\nstatic bool isImplicitlyDefinableConstexprFunction(FunctionDecl *Func) {\n  if (!Func->isConstexpr())\n    return false;\n\n  if (Func->isImplicitlyInstantiable() || !Func->isUserProvided())\n    return true;\n  auto *CCD = dyn_cast<CXXConstructorDecl>(Func);\n  return CCD && CCD->getInheritedConstructor();\n}\n\n/// Mark a function referenced, and check whether it is odr-used\n/// (C++ [basic.def.odr]p2, C99 6.9p3)\nvoid Sema::MarkFunctionReferenced(SourceLocation Loc, FunctionDecl *Func,\n                                  bool MightBeOdrUse) {\n  assert(Func && \"No function?\");\n\n  Func->setReferenced();\n\n  // Recursive functions aren't really used until they're used from some other\n  // context.\n  bool IsRecursiveCall = CurContext == Func;\n\n  // C++11 [basic.def.odr]p3:\n  //   A function whose name appears as a potentially-evaluated expression is\n  //   odr-used if it is the unique lookup result or the selected member of a\n  //   set of overloaded functions [...].\n  //\n  // We (incorrectly) mark overload resolution as an unevaluated context, so we\n  // can just check that here.\n  OdrUseContext OdrUse =\n      MightBeOdrUse ? isOdrUseContext(*this) : OdrUseContext::None;\n  if (IsRecursiveCall && OdrUse == OdrUseContext::Used)\n    OdrUse = OdrUseContext::FormallyOdrUsed;\n\n  // Trivial default constructors and destructors are never actually used.\n  // FIXME: What about other special members?\n  if (Func->isTrivial() && !Func->hasAttr<DLLExportAttr>() &&\n      OdrUse == OdrUseContext::Used) {\n    if (auto *Constructor = dyn_cast<CXXConstructorDecl>(Func))\n      if (Constructor->isDefaultConstructor())\n        OdrUse = OdrUseContext::FormallyOdrUsed;\n    if (isa<CXXDestructorDecl>(Func))\n      OdrUse = OdrUseContext::FormallyOdrUsed;\n  }\n\n  // C++20 [expr.const]p12:\n  //   A function [...] is needed for constant evaluation if it is [...] a\n  //   constexpr function that is named by an expression that is potentially\n  //   constant evaluated\n  bool NeededForConstantEvaluation =\n      isPotentiallyConstantEvaluatedContext(*this) &&\n      isImplicitlyDefinableConstexprFunction(Func);\n\n  // Determine whether we require a function definition to exist, per\n  // C++11 [temp.inst]p3:\n  //   Unless a function template specialization has been explicitly\n  //   instantiated or explicitly specialized, the function template\n  //   specialization is implicitly instantiated when the specialization is\n  //   referenced in a context that requires a function definition to exist.\n  // C++20 [temp.inst]p7:\n  //   The existence of a definition of a [...] function is considered to\n  //   affect the semantics of the program if the [...] function is needed for\n  //   constant evaluation by an expression\n  // C++20 [basic.def.odr]p10:\n  //   Every program shall contain exactly one definition of every non-inline\n  //   function or variable that is odr-used in that program outside of a\n  //   discarded statement\n  // C++20 [special]p1:\n  //   The implementation will implicitly define [defaulted special members]\n  //   if they are odr-used or needed for constant evaluation.\n  //\n  // Note that we skip the implicit instantiation of templates that are only\n  // used in unused default arguments or by recursive calls to themselves.\n  // This is formally non-conforming, but seems reasonable in practice.\n  bool NeedDefinition = !IsRecursiveCall && (OdrUse == OdrUseContext::Used ||\n                                             NeededForConstantEvaluation);\n\n  // C++14 [temp.expl.spec]p6:\n  //   If a template [...] is explicitly specialized then that specialization\n  //   shall be declared before the first use of that specialization that would\n  //   cause an implicit instantiation to take place, in every translation unit\n  //   in which such a use occurs\n  if (NeedDefinition &&\n      (Func->getTemplateSpecializationKind() != TSK_Undeclared ||\n       Func->getMemberSpecializationInfo()))\n    checkSpecializationVisibility(Loc, Func);\n\n  if (getLangOpts().CUDA)\n    CheckCUDACall(Loc, Func);\n\n  if (getLangOpts().SYCLIsDevice)\n    checkSYCLDeviceFunction(Loc, Func);\n\n  // If we need a definition, try to create one.\n  if (NeedDefinition && !Func->getBody()) {\n    runWithSufficientStackSpace(Loc, [&] {\n      if (CXXConstructorDecl *Constructor =\n              dyn_cast<CXXConstructorDecl>(Func)) {\n        Constructor = cast<CXXConstructorDecl>(Constructor->getFirstDecl());\n        if (Constructor->isDefaulted() && !Constructor->isDeleted()) {\n          if (Constructor->isDefaultConstructor()) {\n            if (Constructor->isTrivial() &&\n                !Constructor->hasAttr<DLLExportAttr>())\n              return;\n            DefineImplicitDefaultConstructor(Loc, Constructor);\n          } else if (Constructor->isCopyConstructor()) {\n            DefineImplicitCopyConstructor(Loc, Constructor);\n          } else if (Constructor->isMoveConstructor()) {\n            DefineImplicitMoveConstructor(Loc, Constructor);\n          }\n        } else if (Constructor->getInheritedConstructor()) {\n          DefineInheritingConstructor(Loc, Constructor);\n        }\n      } else if (CXXDestructorDecl *Destructor =\n                     dyn_cast<CXXDestructorDecl>(Func)) {\n        Destructor = cast<CXXDestructorDecl>(Destructor->getFirstDecl());\n        if (Destructor->isDefaulted() && !Destructor->isDeleted()) {\n          if (Destructor->isTrivial() && !Destructor->hasAttr<DLLExportAttr>())\n            return;\n          DefineImplicitDestructor(Loc, Destructor);\n        }\n        if (Destructor->isVirtual() && getLangOpts().AppleKext)\n          MarkVTableUsed(Loc, Destructor->getParent());\n      } else if (CXXMethodDecl *MethodDecl = dyn_cast<CXXMethodDecl>(Func)) {\n        if (MethodDecl->isOverloadedOperator() &&\n            MethodDecl->getOverloadedOperator() == OO_Equal) {\n          MethodDecl = cast<CXXMethodDecl>(MethodDecl->getFirstDecl());\n          if (MethodDecl->isDefaulted() && !MethodDecl->isDeleted()) {\n            if (MethodDecl->isCopyAssignmentOperator())\n              DefineImplicitCopyAssignment(Loc, MethodDecl);\n            else if (MethodDecl->isMoveAssignmentOperator())\n              DefineImplicitMoveAssignment(Loc, MethodDecl);\n          }\n        } else if (isa<CXXConversionDecl>(MethodDecl) &&\n                   MethodDecl->getParent()->isLambda()) {\n          CXXConversionDecl *Conversion =\n              cast<CXXConversionDecl>(MethodDecl->getFirstDecl());\n          if (Conversion->isLambdaToBlockPointerConversion())\n            DefineImplicitLambdaToBlockPointerConversion(Loc, Conversion);\n          else\n            DefineImplicitLambdaToFunctionPointerConversion(Loc, Conversion);\n        } else if (MethodDecl->isVirtual() && getLangOpts().AppleKext)\n          MarkVTableUsed(Loc, MethodDecl->getParent());\n      }\n\n      if (Func->isDefaulted() && !Func->isDeleted()) {\n        DefaultedComparisonKind DCK = getDefaultedComparisonKind(Func);\n        if (DCK != DefaultedComparisonKind::None)\n          DefineDefaultedComparison(Loc, Func, DCK);\n      }\n\n      // Implicit instantiation of function templates and member functions of\n      // class templates.\n      if (Func->isImplicitlyInstantiable()) {\n        TemplateSpecializationKind TSK =\n            Func->getTemplateSpecializationKindForInstantiation();\n        SourceLocation PointOfInstantiation = Func->getPointOfInstantiation();\n        bool FirstInstantiation = PointOfInstantiation.isInvalid();\n        if (FirstInstantiation) {\n          PointOfInstantiation = Loc;\n          if (auto *MSI = Func->getMemberSpecializationInfo())\n            MSI->setPointOfInstantiation(Loc);\n            // FIXME: Notify listener.\n          else\n            Func->setTemplateSpecializationKind(TSK, PointOfInstantiation);\n        } else if (TSK != TSK_ImplicitInstantiation) {\n          // Use the point of use as the point of instantiation, instead of the\n          // point of explicit instantiation (which we track as the actual point\n          // of instantiation). This gives better backtraces in diagnostics.\n          PointOfInstantiation = Loc;\n        }\n\n        if (FirstInstantiation || TSK != TSK_ImplicitInstantiation ||\n            Func->isConstexpr()) {\n          if (isa<CXXRecordDecl>(Func->getDeclContext()) &&\n              cast<CXXRecordDecl>(Func->getDeclContext())->isLocalClass() &&\n              CodeSynthesisContexts.size())\n            PendingLocalImplicitInstantiations.push_back(\n                std::make_pair(Func, PointOfInstantiation));\n          else if (Func->isConstexpr())\n            // Do not defer instantiations of constexpr functions, to avoid the\n            // expression evaluator needing to call back into Sema if it sees a\n            // call to such a function.\n            InstantiateFunctionDefinition(PointOfInstantiation, Func);\n          else {\n            Func->setInstantiationIsPending(true);\n            PendingInstantiations.push_back(\n                std::make_pair(Func, PointOfInstantiation));\n            // Notify the consumer that a function was implicitly instantiated.\n            Consumer.HandleCXXImplicitFunctionInstantiation(Func);\n          }\n        }\n      } else {\n        // Walk redefinitions, as some of them may be instantiable.\n        for (auto i : Func->redecls()) {\n          if (!i->isUsed(false) && i->isImplicitlyInstantiable())\n            MarkFunctionReferenced(Loc, i, MightBeOdrUse);\n        }\n      }\n    });\n  }\n\n  // C++14 [except.spec]p17:\n  //   An exception-specification is considered to be needed when:\n  //   - the function is odr-used or, if it appears in an unevaluated operand,\n  //     would be odr-used if the expression were potentially-evaluated;\n  //\n  // Note, we do this even if MightBeOdrUse is false. That indicates that the\n  // function is a pure virtual function we're calling, and in that case the\n  // function was selected by overload resolution and we need to resolve its\n  // exception specification for a different reason.\n  const FunctionProtoType *FPT = Func->getType()->getAs<FunctionProtoType>();\n  if (FPT && isUnresolvedExceptionSpec(FPT->getExceptionSpecType()))\n    ResolveExceptionSpec(Loc, FPT);\n\n  // If this is the first \"real\" use, act on that.\n  if (OdrUse == OdrUseContext::Used && !Func->isUsed(/*CheckUsedAttr=*/false)) {\n    // Keep track of used but undefined functions.\n    if (!Func->isDefined()) {\n      if (mightHaveNonExternalLinkage(Func))\n        UndefinedButUsed.insert(std::make_pair(Func->getCanonicalDecl(), Loc));\n      else if (Func->getMostRecentDecl()->isInlined() &&\n               !LangOpts.GNUInline &&\n               !Func->getMostRecentDecl()->hasAttr<GNUInlineAttr>())\n        UndefinedButUsed.insert(std::make_pair(Func->getCanonicalDecl(), Loc));\n      else if (isExternalWithNoLinkageType(Func))\n        UndefinedButUsed.insert(std::make_pair(Func->getCanonicalDecl(), Loc));\n    }\n\n    // Some x86 Windows calling conventions mangle the size of the parameter\n    // pack into the name. Computing the size of the parameters requires the\n    // parameter types to be complete. Check that now.\n    if (funcHasParameterSizeMangling(*this, Func))\n      CheckCompleteParameterTypesForMangler(*this, Func, Loc);\n\n    // In the MS C++ ABI, the compiler emits destructor variants where they are\n    // used. If the destructor is used here but defined elsewhere, mark the\n    // virtual base destructors referenced. If those virtual base destructors\n    // are inline, this will ensure they are defined when emitting the complete\n    // destructor variant. This checking may be redundant if the destructor is\n    // provided later in this TU.\n    if (Context.getTargetInfo().getCXXABI().isMicrosoft()) {\n      if (auto *Dtor = dyn_cast<CXXDestructorDecl>(Func)) {\n        CXXRecordDecl *Parent = Dtor->getParent();\n        if (Parent->getNumVBases() > 0 && !Dtor->getBody())\n          CheckCompleteDestructorVariant(Loc, Dtor);\n      }\n    }\n\n    Func->markUsed(Context);\n  }\n}\n\n/// Directly mark a variable odr-used. Given a choice, prefer to use\n/// MarkVariableReferenced since it does additional checks and then\n/// calls MarkVarDeclODRUsed.\n/// If the variable must be captured:\n///  - if FunctionScopeIndexToStopAt is null, capture it in the CurContext\n///  - else capture it in the DeclContext that maps to the\n///    *FunctionScopeIndexToStopAt on the FunctionScopeInfo stack.\nstatic void\nMarkVarDeclODRUsed(VarDecl *Var, SourceLocation Loc, Sema &SemaRef,\n                   const unsigned *const FunctionScopeIndexToStopAt = nullptr) {\n  // Keep track of used but undefined variables.\n  // FIXME: We shouldn't suppress this warning for static data members.\n  if (Var->hasDefinition(SemaRef.Context) == VarDecl::DeclarationOnly &&\n      (!Var->isExternallyVisible() || Var->isInline() ||\n       SemaRef.isExternalWithNoLinkageType(Var)) &&\n      !(Var->isStaticDataMember() && Var->hasInit())) {\n    SourceLocation &old = SemaRef.UndefinedButUsed[Var->getCanonicalDecl()];\n    if (old.isInvalid())\n      old = Loc;\n  }\n  QualType CaptureType, DeclRefType;\n  if (SemaRef.LangOpts.OpenMP)\n    SemaRef.tryCaptureOpenMPLambdas(Var);\n  SemaRef.tryCaptureVariable(Var, Loc, Sema::TryCapture_Implicit,\n    /*EllipsisLoc*/ SourceLocation(),\n    /*BuildAndDiagnose*/ true,\n    CaptureType, DeclRefType,\n    FunctionScopeIndexToStopAt);\n\n  Var->markUsed(SemaRef.Context);\n}\n\nvoid Sema::MarkCaptureUsedInEnclosingContext(VarDecl *Capture,\n                                             SourceLocation Loc,\n                                             unsigned CapturingScopeIndex) {\n  MarkVarDeclODRUsed(Capture, Loc, *this, &CapturingScopeIndex);\n}\n\nstatic void\ndiagnoseUncapturableValueReference(Sema &S, SourceLocation loc,\n                                   ValueDecl *var, DeclContext *DC) {\n  DeclContext *VarDC = var->getDeclContext();\n\n  //  If the parameter still belongs to the translation unit, then\n  //  we're actually just using one parameter in the declaration of\n  //  the next.\n  if (isa<ParmVarDecl>(var) &&\n      isa<TranslationUnitDecl>(VarDC))\n    return;\n\n  // For C code, don't diagnose about capture if we're not actually in code\n  // right now; it's impossible to write a non-constant expression outside of\n  // function context, so we'll get other (more useful) diagnostics later.\n  //\n  // For C++, things get a bit more nasty... it would be nice to suppress this\n  // diagnostic for certain cases like using a local variable in an array bound\n  // for a member of a local class, but the correct predicate is not obvious.\n  if (!S.getLangOpts().CPlusPlus && !S.CurContext->isFunctionOrMethod())\n    return;\n\n  unsigned ValueKind = isa<BindingDecl>(var) ? 1 : 0;\n  unsigned ContextKind = 3; // unknown\n  if (isa<CXXMethodDecl>(VarDC) &&\n      cast<CXXRecordDecl>(VarDC->getParent())->isLambda()) {\n    ContextKind = 2;\n  } else if (isa<FunctionDecl>(VarDC)) {\n    ContextKind = 0;\n  } else if (isa<BlockDecl>(VarDC)) {\n    ContextKind = 1;\n  }\n\n  S.Diag(loc, diag::err_reference_to_local_in_enclosing_context)\n    << var << ValueKind << ContextKind << VarDC;\n  S.Diag(var->getLocation(), diag::note_entity_declared_at)\n      << var;\n\n  // FIXME: Add additional diagnostic info about class etc. which prevents\n  // capture.\n}\n\n\nstatic bool isVariableAlreadyCapturedInScopeInfo(CapturingScopeInfo *CSI, VarDecl *Var,\n                                      bool &SubCapturesAreNested,\n                                      QualType &CaptureType,\n                                      QualType &DeclRefType) {\n   // Check whether we've already captured it.\n  if (CSI->CaptureMap.count(Var)) {\n    // If we found a capture, any subcaptures are nested.\n    SubCapturesAreNested = true;\n\n    // Retrieve the capture type for this variable.\n    CaptureType = CSI->getCapture(Var).getCaptureType();\n\n    // Compute the type of an expression that refers to this variable.\n    DeclRefType = CaptureType.getNonReferenceType();\n\n    // Similarly to mutable captures in lambda, all the OpenMP captures by copy\n    // are mutable in the sense that user can change their value - they are\n    // private instances of the captured declarations.\n    const Capture &Cap = CSI->getCapture(Var);\n    if (Cap.isCopyCapture() &&\n        !(isa<LambdaScopeInfo>(CSI) && cast<LambdaScopeInfo>(CSI)->Mutable) &&\n        !(isa<CapturedRegionScopeInfo>(CSI) &&\n          cast<CapturedRegionScopeInfo>(CSI)->CapRegionKind == CR_OpenMP))\n      DeclRefType.addConst();\n    return true;\n  }\n  return false;\n}\n\n// Only block literals, captured statements, and lambda expressions can\n// capture; other scopes don't work.\nstatic DeclContext *getParentOfCapturingContextOrNull(DeclContext *DC, VarDecl *Var,\n                                 SourceLocation Loc,\n                                 const bool Diagnose, Sema &S) {\n  if (isa<BlockDecl>(DC) || isa<CapturedDecl>(DC) || isLambdaCallOperator(DC))\n    return getLambdaAwareParentOfDeclContext(DC);\n  else if (Var->hasLocalStorage()) {\n    if (Diagnose)\n       diagnoseUncapturableValueReference(S, Loc, Var, DC);\n  }\n  return nullptr;\n}\n\n// Certain capturing entities (lambdas, blocks etc.) are not allowed to capture\n// certain types of variables (unnamed, variably modified types etc.)\n// so check for eligibility.\nstatic bool isVariableCapturable(CapturingScopeInfo *CSI, VarDecl *Var,\n                                 SourceLocation Loc,\n                                 const bool Diagnose, Sema &S) {\n\n  bool IsBlock = isa<BlockScopeInfo>(CSI);\n  bool IsLambda = isa<LambdaScopeInfo>(CSI);\n\n  // Lambdas are not allowed to capture unnamed variables\n  // (e.g. anonymous unions).\n  // FIXME: The C++11 rule don't actually state this explicitly, but I'm\n  // assuming that's the intent.\n  if (IsLambda && !Var->getDeclName()) {\n    if (Diagnose) {\n      S.Diag(Loc, diag::err_lambda_capture_anonymous_var);\n      S.Diag(Var->getLocation(), diag::note_declared_at);\n    }\n    return false;\n  }\n\n  // Prohibit variably-modified types in blocks; they're difficult to deal with.\n  if (Var->getType()->isVariablyModifiedType() && IsBlock) {\n    if (Diagnose) {\n      S.Diag(Loc, diag::err_ref_vm_type);\n      S.Diag(Var->getLocation(), diag::note_previous_decl) << Var;\n    }\n    return false;\n  }\n  // Prohibit structs with flexible array members too.\n  // We cannot capture what is in the tail end of the struct.\n  if (const RecordType *VTTy = Var->getType()->getAs<RecordType>()) {\n    if (VTTy->getDecl()->hasFlexibleArrayMember()) {\n      if (Diagnose) {\n        if (IsBlock)\n          S.Diag(Loc, diag::err_ref_flexarray_type);\n        else\n          S.Diag(Loc, diag::err_lambda_capture_flexarray_type) << Var;\n        S.Diag(Var->getLocation(), diag::note_previous_decl) << Var;\n      }\n      return false;\n    }\n  }\n  const bool HasBlocksAttr = Var->hasAttr<BlocksAttr>();\n  // Lambdas and captured statements are not allowed to capture __block\n  // variables; they don't support the expected semantics.\n  if (HasBlocksAttr && (IsLambda || isa<CapturedRegionScopeInfo>(CSI))) {\n    if (Diagnose) {\n      S.Diag(Loc, diag::err_capture_block_variable) << Var << !IsLambda;\n      S.Diag(Var->getLocation(), diag::note_previous_decl) << Var;\n    }\n    return false;\n  }\n  // OpenCL v2.0 s6.12.5: Blocks cannot reference/capture other blocks\n  if (S.getLangOpts().OpenCL && IsBlock &&\n      Var->getType()->isBlockPointerType()) {\n    if (Diagnose)\n      S.Diag(Loc, diag::err_opencl_block_ref_block);\n    return false;\n  }\n\n  return true;\n}\n\n// Returns true if the capture by block was successful.\nstatic bool captureInBlock(BlockScopeInfo *BSI, VarDecl *Var,\n                                 SourceLocation Loc,\n                                 const bool BuildAndDiagnose,\n                                 QualType &CaptureType,\n                                 QualType &DeclRefType,\n                                 const bool Nested,\n                                 Sema &S, bool Invalid) {\n  bool ByRef = false;\n\n  // Blocks are not allowed to capture arrays, excepting OpenCL.\n  // OpenCL v2.0 s1.12.5 (revision 40): arrays are captured by reference\n  // (decayed to pointers).\n  if (!Invalid && !S.getLangOpts().OpenCL && CaptureType->isArrayType()) {\n    if (BuildAndDiagnose) {\n      S.Diag(Loc, diag::err_ref_array_type);\n      S.Diag(Var->getLocation(), diag::note_previous_decl) << Var;\n      Invalid = true;\n    } else {\n      return false;\n    }\n  }\n\n  // Forbid the block-capture of autoreleasing variables.\n  if (!Invalid &&\n      CaptureType.getObjCLifetime() == Qualifiers::OCL_Autoreleasing) {\n    if (BuildAndDiagnose) {\n      S.Diag(Loc, diag::err_arc_autoreleasing_capture)\n        << /*block*/ 0;\n      S.Diag(Var->getLocation(), diag::note_previous_decl) << Var;\n      Invalid = true;\n    } else {\n      return false;\n    }\n  }\n\n  // Warn about implicitly autoreleasing indirect parameters captured by blocks.\n  if (const auto *PT = CaptureType->getAs<PointerType>()) {\n    QualType PointeeTy = PT->getPointeeType();\n\n    if (!Invalid && PointeeTy->getAs<ObjCObjectPointerType>() &&\n        PointeeTy.getObjCLifetime() == Qualifiers::OCL_Autoreleasing &&\n        !S.Context.hasDirectOwnershipQualifier(PointeeTy)) {\n      if (BuildAndDiagnose) {\n        SourceLocation VarLoc = Var->getLocation();\n        S.Diag(Loc, diag::warn_block_capture_autoreleasing);\n        S.Diag(VarLoc, diag::note_declare_parameter_strong);\n      }\n    }\n  }\n\n  const bool HasBlocksAttr = Var->hasAttr<BlocksAttr>();\n  if (HasBlocksAttr || CaptureType->isReferenceType() ||\n      (S.getLangOpts().OpenMP && S.isOpenMPCapturedDecl(Var))) {\n    // Block capture by reference does not change the capture or\n    // declaration reference types.\n    ByRef = true;\n  } else {\n    // Block capture by copy introduces 'const'.\n    CaptureType = CaptureType.getNonReferenceType().withConst();\n    DeclRefType = CaptureType;\n  }\n\n  // Actually capture the variable.\n  if (BuildAndDiagnose)\n    BSI->addCapture(Var, HasBlocksAttr, ByRef, Nested, Loc, SourceLocation(),\n                    CaptureType, Invalid);\n\n  return !Invalid;\n}\n\n\n/// Capture the given variable in the captured region.\nstatic bool captureInCapturedRegion(\n    CapturedRegionScopeInfo *RSI, VarDecl *Var, SourceLocation Loc,\n    const bool BuildAndDiagnose, QualType &CaptureType, QualType &DeclRefType,\n    const bool RefersToCapturedVariable, Sema::TryCaptureKind Kind,\n    bool IsTopScope, Sema &S, bool Invalid) {\n  // By default, capture variables by reference.\n  bool ByRef = true;\n  if (IsTopScope && Kind != Sema::TryCapture_Implicit) {\n    ByRef = (Kind == Sema::TryCapture_ExplicitByRef);\n  } else if (S.getLangOpts().OpenMP && RSI->CapRegionKind == CR_OpenMP) {\n    // Using an LValue reference type is consistent with Lambdas (see below).\n    if (S.isOpenMPCapturedDecl(Var)) {\n      bool HasConst = DeclRefType.isConstQualified();\n      DeclRefType = DeclRefType.getUnqualifiedType();\n      // Don't lose diagnostics about assignments to const.\n      if (HasConst)\n        DeclRefType.addConst();\n    }\n    // Do not capture firstprivates in tasks.\n    if (S.isOpenMPPrivateDecl(Var, RSI->OpenMPLevel, RSI->OpenMPCaptureLevel) !=\n        OMPC_unknown)\n      return true;\n    ByRef = S.isOpenMPCapturedByRef(Var, RSI->OpenMPLevel,\n                                    RSI->OpenMPCaptureLevel);\n  }\n\n  if (ByRef)\n    CaptureType = S.Context.getLValueReferenceType(DeclRefType);\n  else\n    CaptureType = DeclRefType;\n\n  // Actually capture the variable.\n  if (BuildAndDiagnose)\n    RSI->addCapture(Var, /*isBlock*/ false, ByRef, RefersToCapturedVariable,\n                    Loc, SourceLocation(), CaptureType, Invalid);\n\n  return !Invalid;\n}\n\n/// Capture the given variable in the lambda.\nstatic bool captureInLambda(LambdaScopeInfo *LSI,\n                            VarDecl *Var,\n                            SourceLocation Loc,\n                            const bool BuildAndDiagnose,\n                            QualType &CaptureType,\n                            QualType &DeclRefType,\n                            const bool RefersToCapturedVariable,\n                            const Sema::TryCaptureKind Kind,\n                            SourceLocation EllipsisLoc,\n                            const bool IsTopScope,\n                            Sema &S, bool Invalid) {\n  // Determine whether we are capturing by reference or by value.\n  bool ByRef = false;\n  if (IsTopScope && Kind != Sema::TryCapture_Implicit) {\n    ByRef = (Kind == Sema::TryCapture_ExplicitByRef);\n  } else {\n    ByRef = (LSI->ImpCaptureStyle == LambdaScopeInfo::ImpCap_LambdaByref);\n  }\n\n  // Compute the type of the field that will capture this variable.\n  if (ByRef) {\n    // C++11 [expr.prim.lambda]p15:\n    //   An entity is captured by reference if it is implicitly or\n    //   explicitly captured but not captured by copy. It is\n    //   unspecified whether additional unnamed non-static data\n    //   members are declared in the closure type for entities\n    //   captured by reference.\n    //\n    // FIXME: It is not clear whether we want to build an lvalue reference\n    // to the DeclRefType or to CaptureType.getNonReferenceType(). GCC appears\n    // to do the former, while EDG does the latter. Core issue 1249 will\n    // clarify, but for now we follow GCC because it's a more permissive and\n    // easily defensible position.\n    CaptureType = S.Context.getLValueReferenceType(DeclRefType);\n  } else {\n    // C++11 [expr.prim.lambda]p14:\n    //   For each entity captured by copy, an unnamed non-static\n    //   data member is declared in the closure type. The\n    //   declaration order of these members is unspecified. The type\n    //   of such a data member is the type of the corresponding\n    //   captured entity if the entity is not a reference to an\n    //   object, or the referenced type otherwise. [Note: If the\n    //   captured entity is a reference to a function, the\n    //   corresponding data member is also a reference to a\n    //   function. - end note ]\n    if (const ReferenceType *RefType = CaptureType->getAs<ReferenceType>()){\n      if (!RefType->getPointeeType()->isFunctionType())\n        CaptureType = RefType->getPointeeType();\n    }\n\n    // Forbid the lambda copy-capture of autoreleasing variables.\n    if (!Invalid &&\n        CaptureType.getObjCLifetime() == Qualifiers::OCL_Autoreleasing) {\n      if (BuildAndDiagnose) {\n        S.Diag(Loc, diag::err_arc_autoreleasing_capture) << /*lambda*/ 1;\n        S.Diag(Var->getLocation(), diag::note_previous_decl)\n          << Var->getDeclName();\n        Invalid = true;\n      } else {\n        return false;\n      }\n    }\n\n    // Make sure that by-copy captures are of a complete and non-abstract type.\n    if (!Invalid && BuildAndDiagnose) {\n      if (!CaptureType->isDependentType() &&\n          S.RequireCompleteSizedType(\n              Loc, CaptureType,\n              diag::err_capture_of_incomplete_or_sizeless_type,\n              Var->getDeclName()))\n        Invalid = true;\n      else if (S.RequireNonAbstractType(Loc, CaptureType,\n                                        diag::err_capture_of_abstract_type))\n        Invalid = true;\n    }\n  }\n\n  // Compute the type of a reference to this captured variable.\n  if (ByRef)\n    DeclRefType = CaptureType.getNonReferenceType();\n  else {\n    // C++ [expr.prim.lambda]p5:\n    //   The closure type for a lambda-expression has a public inline\n    //   function call operator [...]. This function call operator is\n    //   declared const (9.3.1) if and only if the lambda-expression's\n    //   parameter-declaration-clause is not followed by mutable.\n    DeclRefType = CaptureType.getNonReferenceType();\n    if (!LSI->Mutable && !CaptureType->isReferenceType())\n      DeclRefType.addConst();\n  }\n\n  // Add the capture.\n  if (BuildAndDiagnose)\n    LSI->addCapture(Var, /*isBlock=*/false, ByRef, RefersToCapturedVariable,\n                    Loc, EllipsisLoc, CaptureType, Invalid);\n\n  return !Invalid;\n}\n\nbool Sema::tryCaptureVariable(\n    VarDecl *Var, SourceLocation ExprLoc, TryCaptureKind Kind,\n    SourceLocation EllipsisLoc, bool BuildAndDiagnose, QualType &CaptureType,\n    QualType &DeclRefType, const unsigned *const FunctionScopeIndexToStopAt) {\n  // An init-capture is notionally from the context surrounding its\n  // declaration, but its parent DC is the lambda class.\n  DeclContext *VarDC = Var->getDeclContext();\n  if (Var->isInitCapture())\n    VarDC = VarDC->getParent();\n\n  DeclContext *DC = CurContext;\n  const unsigned MaxFunctionScopesIndex = FunctionScopeIndexToStopAt\n      ? *FunctionScopeIndexToStopAt : FunctionScopes.size() - 1;\n  // We need to sync up the Declaration Context with the\n  // FunctionScopeIndexToStopAt\n  if (FunctionScopeIndexToStopAt) {\n    unsigned FSIndex = FunctionScopes.size() - 1;\n    while (FSIndex != MaxFunctionScopesIndex) {\n      DC = getLambdaAwareParentOfDeclContext(DC);\n      --FSIndex;\n    }\n  }\n\n\n  // If the variable is declared in the current context, there is no need to\n  // capture it.\n  if (VarDC == DC) return true;\n\n  // Capture global variables if it is required to use private copy of this\n  // variable.\n  bool IsGlobal = !Var->hasLocalStorage();\n  if (IsGlobal &&\n      !(LangOpts.OpenMP && isOpenMPCapturedDecl(Var, /*CheckScopeInfo=*/true,\n                                                MaxFunctionScopesIndex)))\n    return true;\n  Var = Var->getCanonicalDecl();\n\n  // Walk up the stack to determine whether we can capture the variable,\n  // performing the \"simple\" checks that don't depend on type. We stop when\n  // we've either hit the declared scope of the variable or find an existing\n  // capture of that variable.  We start from the innermost capturing-entity\n  // (the DC) and ensure that all intervening capturing-entities\n  // (blocks/lambdas etc.) between the innermost capturer and the variable`s\n  // declcontext can either capture the variable or have already captured\n  // the variable.\n  CaptureType = Var->getType();\n  DeclRefType = CaptureType.getNonReferenceType();\n  bool Nested = false;\n  bool Explicit = (Kind != TryCapture_Implicit);\n  unsigned FunctionScopesIndex = MaxFunctionScopesIndex;\n  do {\n    // Only block literals, captured statements, and lambda expressions can\n    // capture; other scopes don't work.\n    DeclContext *ParentDC = getParentOfCapturingContextOrNull(DC, Var,\n                                                              ExprLoc,\n                                                              BuildAndDiagnose,\n                                                              *this);\n    // We need to check for the parent *first* because, if we *have*\n    // private-captured a global variable, we need to recursively capture it in\n    // intermediate blocks, lambdas, etc.\n    if (!ParentDC) {\n      if (IsGlobal) {\n        FunctionScopesIndex = MaxFunctionScopesIndex - 1;\n        break;\n      }\n      return true;\n    }\n\n    FunctionScopeInfo  *FSI = FunctionScopes[FunctionScopesIndex];\n    CapturingScopeInfo *CSI = cast<CapturingScopeInfo>(FSI);\n\n\n    // Check whether we've already captured it.\n    if (isVariableAlreadyCapturedInScopeInfo(CSI, Var, Nested, CaptureType,\n                                             DeclRefType)) {\n      CSI->getCapture(Var).markUsed(BuildAndDiagnose);\n      break;\n    }\n    // If we are instantiating a generic lambda call operator body,\n    // we do not want to capture new variables.  What was captured\n    // during either a lambdas transformation or initial parsing\n    // should be used.\n    if (isGenericLambdaCallOperatorSpecialization(DC)) {\n      if (BuildAndDiagnose) {\n        LambdaScopeInfo *LSI = cast<LambdaScopeInfo>(CSI);\n        if (LSI->ImpCaptureStyle == CapturingScopeInfo::ImpCap_None) {\n          Diag(ExprLoc, diag::err_lambda_impcap) << Var;\n          Diag(Var->getLocation(), diag::note_previous_decl) << Var;\n          Diag(LSI->Lambda->getBeginLoc(), diag::note_lambda_decl);\n        } else\n          diagnoseUncapturableValueReference(*this, ExprLoc, Var, DC);\n      }\n      return true;\n    }\n\n    // Try to capture variable-length arrays types.\n    if (Var->getType()->isVariablyModifiedType()) {\n      // We're going to walk down into the type and look for VLA\n      // expressions.\n      QualType QTy = Var->getType();\n      if (ParmVarDecl *PVD = dyn_cast_or_null<ParmVarDecl>(Var))\n        QTy = PVD->getOriginalType();\n      captureVariablyModifiedType(Context, QTy, CSI);\n    }\n\n    if (getLangOpts().OpenMP) {\n      if (auto *RSI = dyn_cast<CapturedRegionScopeInfo>(CSI)) {\n        // OpenMP private variables should not be captured in outer scope, so\n        // just break here. Similarly, global variables that are captured in a\n        // target region should not be captured outside the scope of the region.\n        if (RSI->CapRegionKind == CR_OpenMP) {\n          OpenMPClauseKind IsOpenMPPrivateDecl = isOpenMPPrivateDecl(\n              Var, RSI->OpenMPLevel, RSI->OpenMPCaptureLevel);\n          // If the variable is private (i.e. not captured) and has variably\n          // modified type, we still need to capture the type for correct\n          // codegen in all regions, associated with the construct. Currently,\n          // it is captured in the innermost captured region only.\n          if (IsOpenMPPrivateDecl != OMPC_unknown &&\n              Var->getType()->isVariablyModifiedType()) {\n            QualType QTy = Var->getType();\n            if (ParmVarDecl *PVD = dyn_cast_or_null<ParmVarDecl>(Var))\n              QTy = PVD->getOriginalType();\n            for (int I = 1, E = getNumberOfConstructScopes(RSI->OpenMPLevel);\n                 I < E; ++I) {\n              auto *OuterRSI = cast<CapturedRegionScopeInfo>(\n                  FunctionScopes[FunctionScopesIndex - I]);\n              assert(RSI->OpenMPLevel == OuterRSI->OpenMPLevel &&\n                     \"Wrong number of captured regions associated with the \"\n                     \"OpenMP construct.\");\n              captureVariablyModifiedType(Context, QTy, OuterRSI);\n            }\n          }\n          bool IsTargetCap =\n              IsOpenMPPrivateDecl != OMPC_private &&\n              isOpenMPTargetCapturedDecl(Var, RSI->OpenMPLevel,\n                                         RSI->OpenMPCaptureLevel);\n          // Do not capture global if it is not privatized in outer regions.\n          bool IsGlobalCap =\n              IsGlobal && isOpenMPGlobalCapturedDecl(Var, RSI->OpenMPLevel,\n                                                     RSI->OpenMPCaptureLevel);\n\n          // When we detect target captures we are looking from inside the\n          // target region, therefore we need to propagate the capture from the\n          // enclosing region. Therefore, the capture is not initially nested.\n          if (IsTargetCap)\n            adjustOpenMPTargetScopeIndex(FunctionScopesIndex, RSI->OpenMPLevel);\n\n          if (IsTargetCap || IsOpenMPPrivateDecl == OMPC_private ||\n              (IsGlobal && !IsGlobalCap)) {\n            Nested = !IsTargetCap;\n            bool HasConst = DeclRefType.isConstQualified();\n            DeclRefType = DeclRefType.getUnqualifiedType();\n            // Don't lose diagnostics about assignments to const.\n            if (HasConst)\n              DeclRefType.addConst();\n            CaptureType = Context.getLValueReferenceType(DeclRefType);\n            break;\n          }\n        }\n      }\n    }\n    if (CSI->ImpCaptureStyle == CapturingScopeInfo::ImpCap_None && !Explicit) {\n      // No capture-default, and this is not an explicit capture\n      // so cannot capture this variable.\n      if (BuildAndDiagnose) {\n        Diag(ExprLoc, diag::err_lambda_impcap) << Var;\n        Diag(Var->getLocation(), diag::note_previous_decl) << Var;\n        if (cast<LambdaScopeInfo>(CSI)->Lambda)\n          Diag(cast<LambdaScopeInfo>(CSI)->Lambda->getBeginLoc(),\n               diag::note_lambda_decl);\n        // FIXME: If we error out because an outer lambda can not implicitly\n        // capture a variable that an inner lambda explicitly captures, we\n        // should have the inner lambda do the explicit capture - because\n        // it makes for cleaner diagnostics later.  This would purely be done\n        // so that the diagnostic does not misleadingly claim that a variable\n        // can not be captured by a lambda implicitly even though it is captured\n        // explicitly.  Suggestion:\n        //  - create const bool VariableCaptureWasInitiallyExplicit = Explicit\n        //    at the function head\n        //  - cache the StartingDeclContext - this must be a lambda\n        //  - captureInLambda in the innermost lambda the variable.\n      }\n      return true;\n    }\n\n    FunctionScopesIndex--;\n    DC = ParentDC;\n    Explicit = false;\n  } while (!VarDC->Equals(DC));\n\n  // Walk back down the scope stack, (e.g. from outer lambda to inner lambda)\n  // computing the type of the capture at each step, checking type-specific\n  // requirements, and adding captures if requested.\n  // If the variable had already been captured previously, we start capturing\n  // at the lambda nested within that one.\n  bool Invalid = false;\n  for (unsigned I = ++FunctionScopesIndex, N = MaxFunctionScopesIndex + 1; I != N;\n       ++I) {\n    CapturingScopeInfo *CSI = cast<CapturingScopeInfo>(FunctionScopes[I]);\n\n    // Certain capturing entities (lambdas, blocks etc.) are not allowed to capture\n    // certain types of variables (unnamed, variably modified types etc.)\n    // so check for eligibility.\n    if (!Invalid)\n      Invalid =\n          !isVariableCapturable(CSI, Var, ExprLoc, BuildAndDiagnose, *this);\n\n    // After encountering an error, if we're actually supposed to capture, keep\n    // capturing in nested contexts to suppress any follow-on diagnostics.\n    if (Invalid && !BuildAndDiagnose)\n      return true;\n\n    if (BlockScopeInfo *BSI = dyn_cast<BlockScopeInfo>(CSI)) {\n      Invalid = !captureInBlock(BSI, Var, ExprLoc, BuildAndDiagnose, CaptureType,\n                               DeclRefType, Nested, *this, Invalid);\n      Nested = true;\n    } else if (CapturedRegionScopeInfo *RSI = dyn_cast<CapturedRegionScopeInfo>(CSI)) {\n      Invalid = !captureInCapturedRegion(\n          RSI, Var, ExprLoc, BuildAndDiagnose, CaptureType, DeclRefType, Nested,\n          Kind, /*IsTopScope*/ I == N - 1, *this, Invalid);\n      Nested = true;\n    } else {\n      LambdaScopeInfo *LSI = cast<LambdaScopeInfo>(CSI);\n      Invalid =\n          !captureInLambda(LSI, Var, ExprLoc, BuildAndDiagnose, CaptureType,\n                           DeclRefType, Nested, Kind, EllipsisLoc,\n                           /*IsTopScope*/ I == N - 1, *this, Invalid);\n      Nested = true;\n    }\n\n    if (Invalid && !BuildAndDiagnose)\n      return true;\n  }\n  return Invalid;\n}\n\nbool Sema::tryCaptureVariable(VarDecl *Var, SourceLocation Loc,\n                              TryCaptureKind Kind, SourceLocation EllipsisLoc) {\n  QualType CaptureType;\n  QualType DeclRefType;\n  return tryCaptureVariable(Var, Loc, Kind, EllipsisLoc,\n                            /*BuildAndDiagnose=*/true, CaptureType,\n                            DeclRefType, nullptr);\n}\n\nbool Sema::NeedToCaptureVariable(VarDecl *Var, SourceLocation Loc) {\n  QualType CaptureType;\n  QualType DeclRefType;\n  return !tryCaptureVariable(Var, Loc, TryCapture_Implicit, SourceLocation(),\n                             /*BuildAndDiagnose=*/false, CaptureType,\n                             DeclRefType, nullptr);\n}\n\nQualType Sema::getCapturedDeclRefType(VarDecl *Var, SourceLocation Loc) {\n  QualType CaptureType;\n  QualType DeclRefType;\n\n  // Determine whether we can capture this variable.\n  if (tryCaptureVariable(Var, Loc, TryCapture_Implicit, SourceLocation(),\n                         /*BuildAndDiagnose=*/false, CaptureType,\n                         DeclRefType, nullptr))\n    return QualType();\n\n  return DeclRefType;\n}\n\nnamespace {\n// Helper to copy the template arguments from a DeclRefExpr or MemberExpr.\n// The produced TemplateArgumentListInfo* points to data stored within this\n// object, so should only be used in contexts where the pointer will not be\n// used after the CopiedTemplateArgs object is destroyed.\nclass CopiedTemplateArgs {\n  bool HasArgs;\n  TemplateArgumentListInfo TemplateArgStorage;\npublic:\n  template<typename RefExpr>\n  CopiedTemplateArgs(RefExpr *E) : HasArgs(E->hasExplicitTemplateArgs()) {\n    if (HasArgs)\n      E->copyTemplateArgumentsInto(TemplateArgStorage);\n  }\n  operator TemplateArgumentListInfo*()\n#ifdef __has_cpp_attribute\n#if __has_cpp_attribute(clang::lifetimebound)\n  [[clang::lifetimebound]]\n#endif\n#endif\n  {\n    return HasArgs ? &TemplateArgStorage : nullptr;\n  }\n};\n}\n\n/// Walk the set of potential results of an expression and mark them all as\n/// non-odr-uses if they satisfy the side-conditions of the NonOdrUseReason.\n///\n/// \\return A new expression if we found any potential results, ExprEmpty() if\n///         not, and ExprError() if we diagnosed an error.\nstatic ExprResult rebuildPotentialResultsAsNonOdrUsed(Sema &S, Expr *E,\n                                                      NonOdrUseReason NOUR) {\n  // Per C++11 [basic.def.odr], a variable is odr-used \"unless it is\n  // an object that satisfies the requirements for appearing in a\n  // constant expression (5.19) and the lvalue-to-rvalue conversion (4.1)\n  // is immediately applied.\"  This function handles the lvalue-to-rvalue\n  // conversion part.\n  //\n  // If we encounter a node that claims to be an odr-use but shouldn't be, we\n  // transform it into the relevant kind of non-odr-use node and rebuild the\n  // tree of nodes leading to it.\n  //\n  // This is a mini-TreeTransform that only transforms a restricted subset of\n  // nodes (and only certain operands of them).\n\n  // Rebuild a subexpression.\n  auto Rebuild = [&](Expr *Sub) {\n    return rebuildPotentialResultsAsNonOdrUsed(S, Sub, NOUR);\n  };\n\n  // Check whether a potential result satisfies the requirements of NOUR.\n  auto IsPotentialResultOdrUsed = [&](NamedDecl *D) {\n    // Any entity other than a VarDecl is always odr-used whenever it's named\n    // in a potentially-evaluated expression.\n    auto *VD = dyn_cast<VarDecl>(D);\n    if (!VD)\n      return true;\n\n    // C++2a [basic.def.odr]p4:\n    //   A variable x whose name appears as a potentially-evalauted expression\n    //   e is odr-used by e unless\n    //   -- x is a reference that is usable in constant expressions, or\n    //   -- x is a variable of non-reference type that is usable in constant\n    //      expressions and has no mutable subobjects, and e is an element of\n    //      the set of potential results of an expression of\n    //      non-volatile-qualified non-class type to which the lvalue-to-rvalue\n    //      conversion is applied, or\n    //   -- x is a variable of non-reference type, and e is an element of the\n    //      set of potential results of a discarded-value expression to which\n    //      the lvalue-to-rvalue conversion is not applied\n    //\n    // We check the first bullet and the \"potentially-evaluated\" condition in\n    // BuildDeclRefExpr. We check the type requirements in the second bullet\n    // in CheckLValueToRValueConversionOperand below.\n    switch (NOUR) {\n    case NOUR_None:\n    case NOUR_Unevaluated:\n      llvm_unreachable(\"unexpected non-odr-use-reason\");\n\n    case NOUR_Constant:\n      // Constant references were handled when they were built.\n      if (VD->getType()->isReferenceType())\n        return true;\n      if (auto *RD = VD->getType()->getAsCXXRecordDecl())\n        if (RD->hasMutableFields())\n          return true;\n      if (!VD->isUsableInConstantExpressions(S.Context))\n        return true;\n      break;\n\n    case NOUR_Discarded:\n      if (VD->getType()->isReferenceType())\n        return true;\n      break;\n    }\n    return false;\n  };\n\n  // Mark that this expression does not constitute an odr-use.\n  auto MarkNotOdrUsed = [&] {\n    S.MaybeODRUseExprs.remove(E);\n    if (LambdaScopeInfo *LSI = S.getCurLambda())\n      LSI->markVariableExprAsNonODRUsed(E);\n  };\n\n  // C++2a [basic.def.odr]p2:\n  //   The set of potential results of an expression e is defined as follows:\n  switch (E->getStmtClass()) {\n  //   -- If e is an id-expression, ...\n  case Expr::DeclRefExprClass: {\n    auto *DRE = cast<DeclRefExpr>(E);\n    if (DRE->isNonOdrUse() || IsPotentialResultOdrUsed(DRE->getDecl()))\n      break;\n\n    // Rebuild as a non-odr-use DeclRefExpr.\n    MarkNotOdrUsed();\n    return DeclRefExpr::Create(\n        S.Context, DRE->getQualifierLoc(), DRE->getTemplateKeywordLoc(),\n        DRE->getDecl(), DRE->refersToEnclosingVariableOrCapture(),\n        DRE->getNameInfo(), DRE->getType(), DRE->getValueKind(),\n        DRE->getFoundDecl(), CopiedTemplateArgs(DRE), NOUR);\n  }\n\n  case Expr::FunctionParmPackExprClass: {\n    auto *FPPE = cast<FunctionParmPackExpr>(E);\n    // If any of the declarations in the pack is odr-used, then the expression\n    // as a whole constitutes an odr-use.\n    for (VarDecl *D : *FPPE)\n      if (IsPotentialResultOdrUsed(D))\n        return ExprEmpty();\n\n    // FIXME: Rebuild as a non-odr-use FunctionParmPackExpr? In practice,\n    // nothing cares about whether we marked this as an odr-use, but it might\n    // be useful for non-compiler tools.\n    MarkNotOdrUsed();\n    break;\n  }\n\n  //   -- If e is a subscripting operation with an array operand...\n  case Expr::ArraySubscriptExprClass: {\n    auto *ASE = cast<ArraySubscriptExpr>(E);\n    Expr *OldBase = ASE->getBase()->IgnoreImplicit();\n    if (!OldBase->getType()->isArrayType())\n      break;\n    ExprResult Base = Rebuild(OldBase);\n    if (!Base.isUsable())\n      return Base;\n    Expr *LHS = ASE->getBase() == ASE->getLHS() ? Base.get() : ASE->getLHS();\n    Expr *RHS = ASE->getBase() == ASE->getRHS() ? Base.get() : ASE->getRHS();\n    SourceLocation LBracketLoc = ASE->getBeginLoc(); // FIXME: Not stored.\n    return S.ActOnArraySubscriptExpr(nullptr, LHS, LBracketLoc, RHS,\n                                     ASE->getRBracketLoc());\n  }\n\n  case Expr::MemberExprClass: {\n    auto *ME = cast<MemberExpr>(E);\n    // -- If e is a class member access expression [...] naming a non-static\n    //    data member...\n    if (isa<FieldDecl>(ME->getMemberDecl())) {\n      ExprResult Base = Rebuild(ME->getBase());\n      if (!Base.isUsable())\n        return Base;\n      return MemberExpr::Create(\n          S.Context, Base.get(), ME->isArrow(), ME->getOperatorLoc(),\n          ME->getQualifierLoc(), ME->getTemplateKeywordLoc(),\n          ME->getMemberDecl(), ME->getFoundDecl(), ME->getMemberNameInfo(),\n          CopiedTemplateArgs(ME), ME->getType(), ME->getValueKind(),\n          ME->getObjectKind(), ME->isNonOdrUse());\n    }\n\n    if (ME->getMemberDecl()->isCXXInstanceMember())\n      break;\n\n    // -- If e is a class member access expression naming a static data member,\n    //    ...\n    if (ME->isNonOdrUse() || IsPotentialResultOdrUsed(ME->getMemberDecl()))\n      break;\n\n    // Rebuild as a non-odr-use MemberExpr.\n    MarkNotOdrUsed();\n    return MemberExpr::Create(\n        S.Context, ME->getBase(), ME->isArrow(), ME->getOperatorLoc(),\n        ME->getQualifierLoc(), ME->getTemplateKeywordLoc(), ME->getMemberDecl(),\n        ME->getFoundDecl(), ME->getMemberNameInfo(), CopiedTemplateArgs(ME),\n        ME->getType(), ME->getValueKind(), ME->getObjectKind(), NOUR);\n    return ExprEmpty();\n  }\n\n  case Expr::BinaryOperatorClass: {\n    auto *BO = cast<BinaryOperator>(E);\n    Expr *LHS = BO->getLHS();\n    Expr *RHS = BO->getRHS();\n    // -- If e is a pointer-to-member expression of the form e1 .* e2 ...\n    if (BO->getOpcode() == BO_PtrMemD) {\n      ExprResult Sub = Rebuild(LHS);\n      if (!Sub.isUsable())\n        return Sub;\n      LHS = Sub.get();\n    //   -- If e is a comma expression, ...\n    } else if (BO->getOpcode() == BO_Comma) {\n      ExprResult Sub = Rebuild(RHS);\n      if (!Sub.isUsable())\n        return Sub;\n      RHS = Sub.get();\n    } else {\n      break;\n    }\n    return S.BuildBinOp(nullptr, BO->getOperatorLoc(), BO->getOpcode(),\n                        LHS, RHS);\n  }\n\n  //   -- If e has the form (e1)...\n  case Expr::ParenExprClass: {\n    auto *PE = cast<ParenExpr>(E);\n    ExprResult Sub = Rebuild(PE->getSubExpr());\n    if (!Sub.isUsable())\n      return Sub;\n    return S.ActOnParenExpr(PE->getLParen(), PE->getRParen(), Sub.get());\n  }\n\n  //   -- If e is a glvalue conditional expression, ...\n  // We don't apply this to a binary conditional operator. FIXME: Should we?\n  case Expr::ConditionalOperatorClass: {\n    auto *CO = cast<ConditionalOperator>(E);\n    ExprResult LHS = Rebuild(CO->getLHS());\n    if (LHS.isInvalid())\n      return ExprError();\n    ExprResult RHS = Rebuild(CO->getRHS());\n    if (RHS.isInvalid())\n      return ExprError();\n    if (!LHS.isUsable() && !RHS.isUsable())\n      return ExprEmpty();\n    if (!LHS.isUsable())\n      LHS = CO->getLHS();\n    if (!RHS.isUsable())\n      RHS = CO->getRHS();\n    return S.ActOnConditionalOp(CO->getQuestionLoc(), CO->getColonLoc(),\n                                CO->getCond(), LHS.get(), RHS.get());\n  }\n\n  // [Clang extension]\n  //   -- If e has the form __extension__ e1...\n  case Expr::UnaryOperatorClass: {\n    auto *UO = cast<UnaryOperator>(E);\n    if (UO->getOpcode() != UO_Extension)\n      break;\n    ExprResult Sub = Rebuild(UO->getSubExpr());\n    if (!Sub.isUsable())\n      return Sub;\n    return S.BuildUnaryOp(nullptr, UO->getOperatorLoc(), UO_Extension,\n                          Sub.get());\n  }\n\n  // [Clang extension]\n  //   -- If e has the form _Generic(...), the set of potential results is the\n  //      union of the sets of potential results of the associated expressions.\n  case Expr::GenericSelectionExprClass: {\n    auto *GSE = cast<GenericSelectionExpr>(E);\n\n    SmallVector<Expr *, 4> AssocExprs;\n    bool AnyChanged = false;\n    for (Expr *OrigAssocExpr : GSE->getAssocExprs()) {\n      ExprResult AssocExpr = Rebuild(OrigAssocExpr);\n      if (AssocExpr.isInvalid())\n        return ExprError();\n      if (AssocExpr.isUsable()) {\n        AssocExprs.push_back(AssocExpr.get());\n        AnyChanged = true;\n      } else {\n        AssocExprs.push_back(OrigAssocExpr);\n      }\n    }\n\n    return AnyChanged ? S.CreateGenericSelectionExpr(\n                            GSE->getGenericLoc(), GSE->getDefaultLoc(),\n                            GSE->getRParenLoc(), GSE->getControllingExpr(),\n                            GSE->getAssocTypeSourceInfos(), AssocExprs)\n                      : ExprEmpty();\n  }\n\n  // [Clang extension]\n  //   -- If e has the form __builtin_choose_expr(...), the set of potential\n  //      results is the union of the sets of potential results of the\n  //      second and third subexpressions.\n  case Expr::ChooseExprClass: {\n    auto *CE = cast<ChooseExpr>(E);\n\n    ExprResult LHS = Rebuild(CE->getLHS());\n    if (LHS.isInvalid())\n      return ExprError();\n\n    ExprResult RHS = Rebuild(CE->getLHS());\n    if (RHS.isInvalid())\n      return ExprError();\n\n    if (!LHS.get() && !RHS.get())\n      return ExprEmpty();\n    if (!LHS.isUsable())\n      LHS = CE->getLHS();\n    if (!RHS.isUsable())\n      RHS = CE->getRHS();\n\n    return S.ActOnChooseExpr(CE->getBuiltinLoc(), CE->getCond(), LHS.get(),\n                             RHS.get(), CE->getRParenLoc());\n  }\n\n  // Step through non-syntactic nodes.\n  case Expr::ConstantExprClass: {\n    auto *CE = cast<ConstantExpr>(E);\n    ExprResult Sub = Rebuild(CE->getSubExpr());\n    if (!Sub.isUsable())\n      return Sub;\n    return ConstantExpr::Create(S.Context, Sub.get());\n  }\n\n  // We could mostly rely on the recursive rebuilding to rebuild implicit\n  // casts, but not at the top level, so rebuild them here.\n  case Expr::ImplicitCastExprClass: {\n    auto *ICE = cast<ImplicitCastExpr>(E);\n    // Only step through the narrow set of cast kinds we expect to encounter.\n    // Anything else suggests we've left the region in which potential results\n    // can be found.\n    switch (ICE->getCastKind()) {\n    case CK_NoOp:\n    case CK_DerivedToBase:\n    case CK_UncheckedDerivedToBase: {\n      ExprResult Sub = Rebuild(ICE->getSubExpr());\n      if (!Sub.isUsable())\n        return Sub;\n      CXXCastPath Path(ICE->path());\n      return S.ImpCastExprToType(Sub.get(), ICE->getType(), ICE->getCastKind(),\n                                 ICE->getValueKind(), &Path);\n    }\n\n    default:\n      break;\n    }\n    break;\n  }\n\n  default:\n    break;\n  }\n\n  // Can't traverse through this node. Nothing to do.\n  return ExprEmpty();\n}\n\nExprResult Sema::CheckLValueToRValueConversionOperand(Expr *E) {\n  // Check whether the operand is or contains an object of non-trivial C union\n  // type.\n  if (E->getType().isVolatileQualified() &&\n      (E->getType().hasNonTrivialToPrimitiveDestructCUnion() ||\n       E->getType().hasNonTrivialToPrimitiveCopyCUnion()))\n    checkNonTrivialCUnion(E->getType(), E->getExprLoc(),\n                          Sema::NTCUC_LValueToRValueVolatile,\n                          NTCUK_Destruct|NTCUK_Copy);\n\n  // C++2a [basic.def.odr]p4:\n  //   [...] an expression of non-volatile-qualified non-class type to which\n  //   the lvalue-to-rvalue conversion is applied [...]\n  if (E->getType().isVolatileQualified() || E->getType()->getAs<RecordType>())\n    return E;\n\n  ExprResult Result =\n      rebuildPotentialResultsAsNonOdrUsed(*this, E, NOUR_Constant);\n  if (Result.isInvalid())\n    return ExprError();\n  return Result.get() ? Result : E;\n}\n\nExprResult Sema::ActOnConstantExpression(ExprResult Res) {\n  Res = CorrectDelayedTyposInExpr(Res);\n\n  if (!Res.isUsable())\n    return Res;\n\n  // If a constant-expression is a reference to a variable where we delay\n  // deciding whether it is an odr-use, just assume we will apply the\n  // lvalue-to-rvalue conversion.  In the one case where this doesn't happen\n  // (a non-type template argument), we have special handling anyway.\n  return CheckLValueToRValueConversionOperand(Res.get());\n}\n\nvoid Sema::CleanupVarDeclMarking() {\n  // Iterate through a local copy in case MarkVarDeclODRUsed makes a recursive\n  // call.\n  MaybeODRUseExprSet LocalMaybeODRUseExprs;\n  std::swap(LocalMaybeODRUseExprs, MaybeODRUseExprs);\n\n  for (Expr *E : LocalMaybeODRUseExprs) {\n    if (auto *DRE = dyn_cast<DeclRefExpr>(E)) {\n      MarkVarDeclODRUsed(cast<VarDecl>(DRE->getDecl()),\n                         DRE->getLocation(), *this);\n    } else if (auto *ME = dyn_cast<MemberExpr>(E)) {\n      MarkVarDeclODRUsed(cast<VarDecl>(ME->getMemberDecl()), ME->getMemberLoc(),\n                         *this);\n    } else if (auto *FP = dyn_cast<FunctionParmPackExpr>(E)) {\n      for (VarDecl *VD : *FP)\n        MarkVarDeclODRUsed(VD, FP->getParameterPackLocation(), *this);\n    } else {\n      llvm_unreachable(\"Unexpected expression\");\n    }\n  }\n\n  assert(MaybeODRUseExprs.empty() &&\n         \"MarkVarDeclODRUsed failed to cleanup MaybeODRUseExprs?\");\n}\n\nstatic void DoMarkVarDeclReferenced(Sema &SemaRef, SourceLocation Loc,\n                                    VarDecl *Var, Expr *E) {\n  assert((!E || isa<DeclRefExpr>(E) || isa<MemberExpr>(E) ||\n          isa<FunctionParmPackExpr>(E)) &&\n         \"Invalid Expr argument to DoMarkVarDeclReferenced\");\n  Var->setReferenced();\n\n  if (Var->isInvalidDecl())\n    return;\n\n  // Record a CUDA/HIP static device/constant variable if it is referenced\n  // by host code. This is done conservatively, when the variable is referenced\n  // in any of the following contexts:\n  //   - a non-function context\n  //   - a host function\n  //   - a host device function\n  // This also requires the reference of the static device/constant variable by\n  // host code to be visible in the device compilation for the compiler to be\n  // able to externalize the static device/constant variable.\n  if (SemaRef.getASTContext().mayExternalizeStaticVar(Var)) {\n    auto *CurContext = SemaRef.CurContext;\n    if (!CurContext || !isa<FunctionDecl>(CurContext) ||\n        cast<FunctionDecl>(CurContext)->hasAttr<CUDAHostAttr>() ||\n        (!cast<FunctionDecl>(CurContext)->hasAttr<CUDADeviceAttr>() &&\n         !cast<FunctionDecl>(CurContext)->hasAttr<CUDAGlobalAttr>()))\n      SemaRef.getASTContext().CUDAStaticDeviceVarReferencedByHost.insert(Var);\n  }\n\n  auto *MSI = Var->getMemberSpecializationInfo();\n  TemplateSpecializationKind TSK = MSI ? MSI->getTemplateSpecializationKind()\n                                       : Var->getTemplateSpecializationKind();\n\n  OdrUseContext OdrUse = isOdrUseContext(SemaRef);\n  bool UsableInConstantExpr =\n      Var->mightBeUsableInConstantExpressions(SemaRef.Context);\n\n  // C++20 [expr.const]p12:\n  //   A variable [...] is needed for constant evaluation if it is [...] a\n  //   variable whose name appears as a potentially constant evaluated\n  //   expression that is either a contexpr variable or is of non-volatile\n  //   const-qualified integral type or of reference type\n  bool NeededForConstantEvaluation =\n      isPotentiallyConstantEvaluatedContext(SemaRef) && UsableInConstantExpr;\n\n  bool NeedDefinition =\n      OdrUse == OdrUseContext::Used || NeededForConstantEvaluation;\n\n  assert(!isa<VarTemplatePartialSpecializationDecl>(Var) &&\n         \"Can't instantiate a partial template specialization.\");\n\n  // If this might be a member specialization of a static data member, check\n  // the specialization is visible. We already did the checks for variable\n  // template specializations when we created them.\n  if (NeedDefinition && TSK != TSK_Undeclared &&\n      !isa<VarTemplateSpecializationDecl>(Var))\n    SemaRef.checkSpecializationVisibility(Loc, Var);\n\n  // Perform implicit instantiation of static data members, static data member\n  // templates of class templates, and variable template specializations. Delay\n  // instantiations of variable templates, except for those that could be used\n  // in a constant expression.\n  if (NeedDefinition && isTemplateInstantiation(TSK)) {\n    // Per C++17 [temp.explicit]p10, we may instantiate despite an explicit\n    // instantiation declaration if a variable is usable in a constant\n    // expression (among other cases).\n    bool TryInstantiating =\n        TSK == TSK_ImplicitInstantiation ||\n        (TSK == TSK_ExplicitInstantiationDeclaration && UsableInConstantExpr);\n\n    if (TryInstantiating) {\n      SourceLocation PointOfInstantiation =\n          MSI ? MSI->getPointOfInstantiation() : Var->getPointOfInstantiation();\n      bool FirstInstantiation = PointOfInstantiation.isInvalid();\n      if (FirstInstantiation) {\n        PointOfInstantiation = Loc;\n        if (MSI)\n          MSI->setPointOfInstantiation(PointOfInstantiation);\n          // FIXME: Notify listener.\n        else\n          Var->setTemplateSpecializationKind(TSK, PointOfInstantiation);\n      }\n\n      if (UsableInConstantExpr) {\n        // Do not defer instantiations of variables that could be used in a\n        // constant expression.\n        SemaRef.runWithSufficientStackSpace(PointOfInstantiation, [&] {\n          SemaRef.InstantiateVariableDefinition(PointOfInstantiation, Var);\n        });\n\n        // Re-set the member to trigger a recomputation of the dependence bits\n        // for the expression.\n        if (auto *DRE = dyn_cast_or_null<DeclRefExpr>(E))\n          DRE->setDecl(DRE->getDecl());\n        else if (auto *ME = dyn_cast_or_null<MemberExpr>(E))\n          ME->setMemberDecl(ME->getMemberDecl());\n      } else if (FirstInstantiation ||\n                 isa<VarTemplateSpecializationDecl>(Var)) {\n        // FIXME: For a specialization of a variable template, we don't\n        // distinguish between \"declaration and type implicitly instantiated\"\n        // and \"implicit instantiation of definition requested\", so we have\n        // no direct way to avoid enqueueing the pending instantiation\n        // multiple times.\n        SemaRef.PendingInstantiations\n            .push_back(std::make_pair(Var, PointOfInstantiation));\n      }\n    }\n  }\n\n  // C++2a [basic.def.odr]p4:\n  //   A variable x whose name appears as a potentially-evaluated expression e\n  //   is odr-used by e unless\n  //   -- x is a reference that is usable in constant expressions\n  //   -- x is a variable of non-reference type that is usable in constant\n  //      expressions and has no mutable subobjects [FIXME], and e is an\n  //      element of the set of potential results of an expression of\n  //      non-volatile-qualified non-class type to which the lvalue-to-rvalue\n  //      conversion is applied\n  //   -- x is a variable of non-reference type, and e is an element of the set\n  //      of potential results of a discarded-value expression to which the\n  //      lvalue-to-rvalue conversion is not applied [FIXME]\n  //\n  // We check the first part of the second bullet here, and\n  // Sema::CheckLValueToRValueConversionOperand deals with the second part.\n  // FIXME: To get the third bullet right, we need to delay this even for\n  // variables that are not usable in constant expressions.\n\n  // If we already know this isn't an odr-use, there's nothing more to do.\n  if (DeclRefExpr *DRE = dyn_cast_or_null<DeclRefExpr>(E))\n    if (DRE->isNonOdrUse())\n      return;\n  if (MemberExpr *ME = dyn_cast_or_null<MemberExpr>(E))\n    if (ME->isNonOdrUse())\n      return;\n\n  switch (OdrUse) {\n  case OdrUseContext::None:\n    assert((!E || isa<FunctionParmPackExpr>(E)) &&\n           \"missing non-odr-use marking for unevaluated decl ref\");\n    break;\n\n  case OdrUseContext::FormallyOdrUsed:\n    // FIXME: Ignoring formal odr-uses results in incorrect lambda capture\n    // behavior.\n    break;\n\n  case OdrUseContext::Used:\n    // If we might later find that this expression isn't actually an odr-use,\n    // delay the marking.\n    if (E && Var->isUsableInConstantExpressions(SemaRef.Context))\n      SemaRef.MaybeODRUseExprs.insert(E);\n    else\n      MarkVarDeclODRUsed(Var, Loc, SemaRef);\n    break;\n\n  case OdrUseContext::Dependent:\n    // If this is a dependent context, we don't need to mark variables as\n    // odr-used, but we may still need to track them for lambda capture.\n    // FIXME: Do we also need to do this inside dependent typeid expressions\n    // (which are modeled as unevaluated at this point)?\n    const bool RefersToEnclosingScope =\n        (SemaRef.CurContext != Var->getDeclContext() &&\n         Var->getDeclContext()->isFunctionOrMethod() && Var->hasLocalStorage());\n    if (RefersToEnclosingScope) {\n      LambdaScopeInfo *const LSI =\n          SemaRef.getCurLambda(/*IgnoreNonLambdaCapturingScope=*/true);\n      if (LSI && (!LSI->CallOperator ||\n                  !LSI->CallOperator->Encloses(Var->getDeclContext()))) {\n        // If a variable could potentially be odr-used, defer marking it so\n        // until we finish analyzing the full expression for any\n        // lvalue-to-rvalue\n        // or discarded value conversions that would obviate odr-use.\n        // Add it to the list of potential captures that will be analyzed\n        // later (ActOnFinishFullExpr) for eventual capture and odr-use marking\n        // unless the variable is a reference that was initialized by a constant\n        // expression (this will never need to be captured or odr-used).\n        //\n        // FIXME: We can simplify this a lot after implementing P0588R1.\n        assert(E && \"Capture variable should be used in an expression.\");\n        if (!Var->getType()->isReferenceType() ||\n            !Var->isUsableInConstantExpressions(SemaRef.Context))\n          LSI->addPotentialCapture(E->IgnoreParens());\n      }\n    }\n    break;\n  }\n}\n\n/// Mark a variable referenced, and check whether it is odr-used\n/// (C++ [basic.def.odr]p2, C99 6.9p3).  Note that this should not be\n/// used directly for normal expressions referring to VarDecl.\nvoid Sema::MarkVariableReferenced(SourceLocation Loc, VarDecl *Var) {\n  DoMarkVarDeclReferenced(*this, Loc, Var, nullptr);\n}\n\nstatic void MarkExprReferenced(Sema &SemaRef, SourceLocation Loc,\n                               Decl *D, Expr *E, bool MightBeOdrUse) {\n  if (SemaRef.isInOpenMPDeclareTargetContext())\n    SemaRef.checkDeclIsAllowedInOpenMPTarget(E, D);\n\n  if (VarDecl *Var = dyn_cast<VarDecl>(D)) {\n    DoMarkVarDeclReferenced(SemaRef, Loc, Var, E);\n    return;\n  }\n\n  SemaRef.MarkAnyDeclReferenced(Loc, D, MightBeOdrUse);\n\n  // If this is a call to a method via a cast, also mark the method in the\n  // derived class used in case codegen can devirtualize the call.\n  const MemberExpr *ME = dyn_cast<MemberExpr>(E);\n  if (!ME)\n    return;\n  CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(ME->getMemberDecl());\n  if (!MD)\n    return;\n  // Only attempt to devirtualize if this is truly a virtual call.\n  bool IsVirtualCall = MD->isVirtual() &&\n                          ME->performsVirtualDispatch(SemaRef.getLangOpts());\n  if (!IsVirtualCall)\n    return;\n\n  // If it's possible to devirtualize the call, mark the called function\n  // referenced.\n  CXXMethodDecl *DM = MD->getDevirtualizedMethod(\n      ME->getBase(), SemaRef.getLangOpts().AppleKext);\n  if (DM)\n    SemaRef.MarkAnyDeclReferenced(Loc, DM, MightBeOdrUse);\n}\n\n/// Perform reference-marking and odr-use handling for a DeclRefExpr.\n///\n/// Note, this may change the dependence of the DeclRefExpr, and so needs to be\n/// handled with care if the DeclRefExpr is not newly-created.\nvoid Sema::MarkDeclRefReferenced(DeclRefExpr *E, const Expr *Base) {\n  // TODO: update this with DR# once a defect report is filed.\n  // C++11 defect. The address of a pure member should not be an ODR use, even\n  // if it's a qualified reference.\n  bool OdrUse = true;\n  if (const CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(E->getDecl()))\n    if (Method->isVirtual() &&\n        !Method->getDevirtualizedMethod(Base, getLangOpts().AppleKext))\n      OdrUse = false;\n\n  if (auto *FD = dyn_cast<FunctionDecl>(E->getDecl()))\n    if (!isConstantEvaluated() && FD->isConsteval() &&\n        !RebuildingImmediateInvocation)\n      ExprEvalContexts.back().ReferenceToConsteval.insert(E);\n  MarkExprReferenced(*this, E->getLocation(), E->getDecl(), E, OdrUse);\n}\n\n/// Perform reference-marking and odr-use handling for a MemberExpr.\nvoid Sema::MarkMemberReferenced(MemberExpr *E) {\n  // C++11 [basic.def.odr]p2:\n  //   A non-overloaded function whose name appears as a potentially-evaluated\n  //   expression or a member of a set of candidate functions, if selected by\n  //   overload resolution when referred to from a potentially-evaluated\n  //   expression, is odr-used, unless it is a pure virtual function and its\n  //   name is not explicitly qualified.\n  bool MightBeOdrUse = true;\n  if (E->performsVirtualDispatch(getLangOpts())) {\n    if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(E->getMemberDecl()))\n      if (Method->isPure())\n        MightBeOdrUse = false;\n  }\n  SourceLocation Loc =\n      E->getMemberLoc().isValid() ? E->getMemberLoc() : E->getBeginLoc();\n  MarkExprReferenced(*this, Loc, E->getMemberDecl(), E, MightBeOdrUse);\n}\n\n/// Perform reference-marking and odr-use handling for a FunctionParmPackExpr.\nvoid Sema::MarkFunctionParmPackReferenced(FunctionParmPackExpr *E) {\n  for (VarDecl *VD : *E)\n    MarkExprReferenced(*this, E->getParameterPackLocation(), VD, E, true);\n}\n\n/// Perform marking for a reference to an arbitrary declaration.  It\n/// marks the declaration referenced, and performs odr-use checking for\n/// functions and variables. This method should not be used when building a\n/// normal expression which refers to a variable.\nvoid Sema::MarkAnyDeclReferenced(SourceLocation Loc, Decl *D,\n                                 bool MightBeOdrUse) {\n  if (MightBeOdrUse) {\n    if (auto *VD = dyn_cast<VarDecl>(D)) {\n      MarkVariableReferenced(Loc, VD);\n      return;\n    }\n  }\n  if (auto *FD = dyn_cast<FunctionDecl>(D)) {\n    MarkFunctionReferenced(Loc, FD, MightBeOdrUse);\n    return;\n  }\n  D->setReferenced();\n}\n\nnamespace {\n  // Mark all of the declarations used by a type as referenced.\n  // FIXME: Not fully implemented yet! We need to have a better understanding\n  // of when we're entering a context we should not recurse into.\n  // FIXME: This is and EvaluatedExprMarker are more-or-less equivalent to\n  // TreeTransforms rebuilding the type in a new context. Rather than\n  // duplicating the TreeTransform logic, we should consider reusing it here.\n  // Currently that causes problems when rebuilding LambdaExprs.\n  class MarkReferencedDecls : public RecursiveASTVisitor<MarkReferencedDecls> {\n    Sema &S;\n    SourceLocation Loc;\n\n  public:\n    typedef RecursiveASTVisitor<MarkReferencedDecls> Inherited;\n\n    MarkReferencedDecls(Sema &S, SourceLocation Loc) : S(S), Loc(Loc) { }\n\n    bool TraverseTemplateArgument(const TemplateArgument &Arg);\n  };\n}\n\nbool MarkReferencedDecls::TraverseTemplateArgument(\n    const TemplateArgument &Arg) {\n  {\n    // A non-type template argument is a constant-evaluated context.\n    EnterExpressionEvaluationContext Evaluated(\n        S, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n    if (Arg.getKind() == TemplateArgument::Declaration) {\n      if (Decl *D = Arg.getAsDecl())\n        S.MarkAnyDeclReferenced(Loc, D, true);\n    } else if (Arg.getKind() == TemplateArgument::Expression) {\n      S.MarkDeclarationsReferencedInExpr(Arg.getAsExpr(), false);\n    }\n  }\n\n  return Inherited::TraverseTemplateArgument(Arg);\n}\n\nvoid Sema::MarkDeclarationsReferencedInType(SourceLocation Loc, QualType T) {\n  MarkReferencedDecls Marker(*this, Loc);\n  Marker.TraverseType(T);\n}\n\nnamespace {\n/// Helper class that marks all of the declarations referenced by\n/// potentially-evaluated subexpressions as \"referenced\".\nclass EvaluatedExprMarker : public UsedDeclVisitor<EvaluatedExprMarker> {\npublic:\n  typedef UsedDeclVisitor<EvaluatedExprMarker> Inherited;\n  bool SkipLocalVariables;\n\n  EvaluatedExprMarker(Sema &S, bool SkipLocalVariables)\n      : Inherited(S), SkipLocalVariables(SkipLocalVariables) {}\n\n  void visitUsedDecl(SourceLocation Loc, Decl *D) {\n    S.MarkFunctionReferenced(Loc, cast<FunctionDecl>(D));\n  }\n\n  void VisitDeclRefExpr(DeclRefExpr *E) {\n    // If we were asked not to visit local variables, don't.\n    if (SkipLocalVariables) {\n      if (VarDecl *VD = dyn_cast<VarDecl>(E->getDecl()))\n        if (VD->hasLocalStorage())\n          return;\n    }\n\n    // FIXME: This can trigger the instantiation of the initializer of a\n    // variable, which can cause the expression to become value-dependent\n    // or error-dependent. Do we need to propagate the new dependence bits?\n    S.MarkDeclRefReferenced(E);\n  }\n\n  void VisitMemberExpr(MemberExpr *E) {\n    S.MarkMemberReferenced(E);\n    Visit(E->getBase());\n  }\n};\n} // namespace\n\n/// Mark any declarations that appear within this expression or any\n/// potentially-evaluated subexpressions as \"referenced\".\n///\n/// \\param SkipLocalVariables If true, don't mark local variables as\n/// 'referenced'.\nvoid Sema::MarkDeclarationsReferencedInExpr(Expr *E,\n                                            bool SkipLocalVariables) {\n  EvaluatedExprMarker(*this, SkipLocalVariables).Visit(E);\n}\n\n/// Emit a diagnostic that describes an effect on the run-time behavior\n/// of the program being compiled.\n///\n/// This routine emits the given diagnostic when the code currently being\n/// type-checked is \"potentially evaluated\", meaning that there is a\n/// possibility that the code will actually be executable. Code in sizeof()\n/// expressions, code used only during overload resolution, etc., are not\n/// potentially evaluated. This routine will suppress such diagnostics or,\n/// in the absolutely nutty case of potentially potentially evaluated\n/// expressions (C++ typeid), queue the diagnostic to potentially emit it\n/// later.\n///\n/// This routine should be used for all diagnostics that describe the run-time\n/// behavior of a program, such as passing a non-POD value through an ellipsis.\n/// Failure to do so will likely result in spurious diagnostics or failures\n/// during overload resolution or within sizeof/alignof/typeof/typeid.\nbool Sema::DiagRuntimeBehavior(SourceLocation Loc, ArrayRef<const Stmt*> Stmts,\n                               const PartialDiagnostic &PD) {\n  switch (ExprEvalContexts.back().Context) {\n  case ExpressionEvaluationContext::Unevaluated:\n  case ExpressionEvaluationContext::UnevaluatedList:\n  case ExpressionEvaluationContext::UnevaluatedAbstract:\n  case ExpressionEvaluationContext::DiscardedStatement:\n    // The argument will never be evaluated, so don't complain.\n    break;\n\n  case ExpressionEvaluationContext::ConstantEvaluated:\n    // Relevant diagnostics should be produced by constant evaluation.\n    break;\n\n  case ExpressionEvaluationContext::PotentiallyEvaluated:\n  case ExpressionEvaluationContext::PotentiallyEvaluatedIfUsed:\n    if (!Stmts.empty() && getCurFunctionOrMethodDecl()) {\n      FunctionScopes.back()->PossiblyUnreachableDiags.\n        push_back(sema::PossiblyUnreachableDiag(PD, Loc, Stmts));\n      return true;\n    }\n\n    // The initializer of a constexpr variable or of the first declaration of a\n    // static data member is not syntactically a constant evaluated constant,\n    // but nonetheless is always required to be a constant expression, so we\n    // can skip diagnosing.\n    // FIXME: Using the mangling context here is a hack.\n    if (auto *VD = dyn_cast_or_null<VarDecl>(\n            ExprEvalContexts.back().ManglingContextDecl)) {\n      if (VD->isConstexpr() ||\n          (VD->isStaticDataMember() && VD->isFirstDecl() && !VD->isInline()))\n        break;\n      // FIXME: For any other kind of variable, we should build a CFG for its\n      // initializer and check whether the context in question is reachable.\n    }\n\n    Diag(Loc, PD);\n    return true;\n  }\n\n  return false;\n}\n\nbool Sema::DiagRuntimeBehavior(SourceLocation Loc, const Stmt *Statement,\n                               const PartialDiagnostic &PD) {\n  return DiagRuntimeBehavior(\n      Loc, Statement ? llvm::makeArrayRef(Statement) : llvm::None, PD);\n}\n\nbool Sema::CheckCallReturnType(QualType ReturnType, SourceLocation Loc,\n                               CallExpr *CE, FunctionDecl *FD) {\n  if (ReturnType->isVoidType() || !ReturnType->isIncompleteType())\n    return false;\n\n  // If we're inside a decltype's expression, don't check for a valid return\n  // type or construct temporaries until we know whether this is the last call.\n  if (ExprEvalContexts.back().ExprContext ==\n      ExpressionEvaluationContextRecord::EK_Decltype) {\n    ExprEvalContexts.back().DelayedDecltypeCalls.push_back(CE);\n    return false;\n  }\n\n  class CallReturnIncompleteDiagnoser : public TypeDiagnoser {\n    FunctionDecl *FD;\n    CallExpr *CE;\n\n  public:\n    CallReturnIncompleteDiagnoser(FunctionDecl *FD, CallExpr *CE)\n      : FD(FD), CE(CE) { }\n\n    void diagnose(Sema &S, SourceLocation Loc, QualType T) override {\n      if (!FD) {\n        S.Diag(Loc, diag::err_call_incomplete_return)\n          << T << CE->getSourceRange();\n        return;\n      }\n\n      S.Diag(Loc, diag::err_call_function_incomplete_return)\n          << CE->getSourceRange() << FD << T;\n      S.Diag(FD->getLocation(), diag::note_entity_declared_at)\n          << FD->getDeclName();\n    }\n  } Diagnoser(FD, CE);\n\n  if (RequireCompleteType(Loc, ReturnType, Diagnoser))\n    return true;\n\n  return false;\n}\n\n// Diagnose the s/=/==/ and s/\\|=/!=/ typos. Note that adding parentheses\n// will prevent this condition from triggering, which is what we want.\nvoid Sema::DiagnoseAssignmentAsCondition(Expr *E) {\n  SourceLocation Loc;\n\n  unsigned diagnostic = diag::warn_condition_is_assignment;\n  bool IsOrAssign = false;\n\n  if (BinaryOperator *Op = dyn_cast<BinaryOperator>(E)) {\n    if (Op->getOpcode() != BO_Assign && Op->getOpcode() != BO_OrAssign)\n      return;\n\n    IsOrAssign = Op->getOpcode() == BO_OrAssign;\n\n    // Greylist some idioms by putting them into a warning subcategory.\n    if (ObjCMessageExpr *ME\n          = dyn_cast<ObjCMessageExpr>(Op->getRHS()->IgnoreParenCasts())) {\n      Selector Sel = ME->getSelector();\n\n      // self = [<foo> init...]\n      if (isSelfExpr(Op->getLHS()) && ME->getMethodFamily() == OMF_init)\n        diagnostic = diag::warn_condition_is_idiomatic_assignment;\n\n      // <foo> = [<bar> nextObject]\n      else if (Sel.isUnarySelector() && Sel.getNameForSlot(0) == \"nextObject\")\n        diagnostic = diag::warn_condition_is_idiomatic_assignment;\n    }\n\n    Loc = Op->getOperatorLoc();\n  } else if (CXXOperatorCallExpr *Op = dyn_cast<CXXOperatorCallExpr>(E)) {\n    if (Op->getOperator() != OO_Equal && Op->getOperator() != OO_PipeEqual)\n      return;\n\n    IsOrAssign = Op->getOperator() == OO_PipeEqual;\n    Loc = Op->getOperatorLoc();\n  } else if (PseudoObjectExpr *POE = dyn_cast<PseudoObjectExpr>(E))\n    return DiagnoseAssignmentAsCondition(POE->getSyntacticForm());\n  else {\n    // Not an assignment.\n    return;\n  }\n\n  Diag(Loc, diagnostic) << E->getSourceRange();\n\n  SourceLocation Open = E->getBeginLoc();\n  SourceLocation Close = getLocForEndOfToken(E->getSourceRange().getEnd());\n  Diag(Loc, diag::note_condition_assign_silence)\n        << FixItHint::CreateInsertion(Open, \"(\")\n        << FixItHint::CreateInsertion(Close, \")\");\n\n  if (IsOrAssign)\n    Diag(Loc, diag::note_condition_or_assign_to_comparison)\n      << FixItHint::CreateReplacement(Loc, \"!=\");\n  else\n    Diag(Loc, diag::note_condition_assign_to_comparison)\n      << FixItHint::CreateReplacement(Loc, \"==\");\n}\n\n/// Redundant parentheses over an equality comparison can indicate\n/// that the user intended an assignment used as condition.\nvoid Sema::DiagnoseEqualityWithExtraParens(ParenExpr *ParenE) {\n  // Don't warn if the parens came from a macro.\n  SourceLocation parenLoc = ParenE->getBeginLoc();\n  if (parenLoc.isInvalid() || parenLoc.isMacroID())\n    return;\n  // Don't warn for dependent expressions.\n  if (ParenE->isTypeDependent())\n    return;\n\n  Expr *E = ParenE->IgnoreParens();\n\n  if (BinaryOperator *opE = dyn_cast<BinaryOperator>(E))\n    if (opE->getOpcode() == BO_EQ &&\n        opE->getLHS()->IgnoreParenImpCasts()->isModifiableLvalue(Context)\n                                                           == Expr::MLV_Valid) {\n      SourceLocation Loc = opE->getOperatorLoc();\n\n      Diag(Loc, diag::warn_equality_with_extra_parens) << E->getSourceRange();\n      SourceRange ParenERange = ParenE->getSourceRange();\n      Diag(Loc, diag::note_equality_comparison_silence)\n        << FixItHint::CreateRemoval(ParenERange.getBegin())\n        << FixItHint::CreateRemoval(ParenERange.getEnd());\n      Diag(Loc, diag::note_equality_comparison_to_assign)\n        << FixItHint::CreateReplacement(Loc, \"=\");\n    }\n}\n\nExprResult Sema::CheckBooleanCondition(SourceLocation Loc, Expr *E,\n                                       bool IsConstexpr) {\n  DiagnoseAssignmentAsCondition(E);\n  if (ParenExpr *parenE = dyn_cast<ParenExpr>(E))\n    DiagnoseEqualityWithExtraParens(parenE);\n\n  ExprResult result = CheckPlaceholderExpr(E);\n  if (result.isInvalid()) return ExprError();\n  E = result.get();\n\n  if (!E->isTypeDependent()) {\n    if (getLangOpts().CPlusPlus)\n      return CheckCXXBooleanCondition(E, IsConstexpr); // C++ 6.4p4\n\n    ExprResult ERes = DefaultFunctionArrayLvalueConversion(E);\n    if (ERes.isInvalid())\n      return ExprError();\n    E = ERes.get();\n\n    QualType T = E->getType();\n    if (!T->isScalarType()) { // C99 6.8.4.1p1\n      Diag(Loc, diag::err_typecheck_statement_requires_scalar)\n        << T << E->getSourceRange();\n      return ExprError();\n    }\n    CheckBoolLikeConversion(E, Loc);\n  }\n\n  return E;\n}\n\nSema::ConditionResult Sema::ActOnCondition(Scope *S, SourceLocation Loc,\n                                           Expr *SubExpr, ConditionKind CK) {\n  // Empty conditions are valid in for-statements.\n  if (!SubExpr)\n    return ConditionResult();\n\n  ExprResult Cond;\n  switch (CK) {\n  case ConditionKind::Boolean:\n    Cond = CheckBooleanCondition(Loc, SubExpr);\n    break;\n\n  case ConditionKind::ConstexprIf:\n    Cond = CheckBooleanCondition(Loc, SubExpr, true);\n    break;\n\n  case ConditionKind::Switch:\n    Cond = CheckSwitchCondition(Loc, SubExpr);\n    break;\n  }\n  if (Cond.isInvalid()) {\n    Cond = CreateRecoveryExpr(SubExpr->getBeginLoc(), SubExpr->getEndLoc(),\n                              {SubExpr});\n    if (!Cond.get())\n      return ConditionError();\n  }\n  // FIXME: FullExprArg doesn't have an invalid bit, so check nullness instead.\n  FullExprArg FullExpr = MakeFullExpr(Cond.get(), Loc);\n  if (!FullExpr.get())\n    return ConditionError();\n\n  return ConditionResult(*this, nullptr, FullExpr,\n                         CK == ConditionKind::ConstexprIf);\n}\n\nnamespace {\n  /// A visitor for rebuilding a call to an __unknown_any expression\n  /// to have an appropriate type.\n  struct RebuildUnknownAnyFunction\n    : StmtVisitor<RebuildUnknownAnyFunction, ExprResult> {\n\n    Sema &S;\n\n    RebuildUnknownAnyFunction(Sema &S) : S(S) {}\n\n    ExprResult VisitStmt(Stmt *S) {\n      llvm_unreachable(\"unexpected statement!\");\n    }\n\n    ExprResult VisitExpr(Expr *E) {\n      S.Diag(E->getExprLoc(), diag::err_unsupported_unknown_any_call)\n        << E->getSourceRange();\n      return ExprError();\n    }\n\n    /// Rebuild an expression which simply semantically wraps another\n    /// expression which it shares the type and value kind of.\n    template <class T> ExprResult rebuildSugarExpr(T *E) {\n      ExprResult SubResult = Visit(E->getSubExpr());\n      if (SubResult.isInvalid()) return ExprError();\n\n      Expr *SubExpr = SubResult.get();\n      E->setSubExpr(SubExpr);\n      E->setType(SubExpr->getType());\n      E->setValueKind(SubExpr->getValueKind());\n      assert(E->getObjectKind() == OK_Ordinary);\n      return E;\n    }\n\n    ExprResult VisitParenExpr(ParenExpr *E) {\n      return rebuildSugarExpr(E);\n    }\n\n    ExprResult VisitUnaryExtension(UnaryOperator *E) {\n      return rebuildSugarExpr(E);\n    }\n\n    ExprResult VisitUnaryAddrOf(UnaryOperator *E) {\n      ExprResult SubResult = Visit(E->getSubExpr());\n      if (SubResult.isInvalid()) return ExprError();\n\n      Expr *SubExpr = SubResult.get();\n      E->setSubExpr(SubExpr);\n      E->setType(S.Context.getPointerType(SubExpr->getType()));\n      assert(E->getValueKind() == VK_RValue);\n      assert(E->getObjectKind() == OK_Ordinary);\n      return E;\n    }\n\n    ExprResult resolveDecl(Expr *E, ValueDecl *VD) {\n      if (!isa<FunctionDecl>(VD)) return VisitExpr(E);\n\n      E->setType(VD->getType());\n\n      assert(E->getValueKind() == VK_RValue);\n      if (S.getLangOpts().CPlusPlus &&\n          !(isa<CXXMethodDecl>(VD) &&\n            cast<CXXMethodDecl>(VD)->isInstance()))\n        E->setValueKind(VK_LValue);\n\n      return E;\n    }\n\n    ExprResult VisitMemberExpr(MemberExpr *E) {\n      return resolveDecl(E, E->getMemberDecl());\n    }\n\n    ExprResult VisitDeclRefExpr(DeclRefExpr *E) {\n      return resolveDecl(E, E->getDecl());\n    }\n  };\n}\n\n/// Given a function expression of unknown-any type, try to rebuild it\n/// to have a function type.\nstatic ExprResult rebuildUnknownAnyFunction(Sema &S, Expr *FunctionExpr) {\n  ExprResult Result = RebuildUnknownAnyFunction(S).Visit(FunctionExpr);\n  if (Result.isInvalid()) return ExprError();\n  return S.DefaultFunctionArrayConversion(Result.get());\n}\n\nnamespace {\n  /// A visitor for rebuilding an expression of type __unknown_anytype\n  /// into one which resolves the type directly on the referring\n  /// expression.  Strict preservation of the original source\n  /// structure is not a goal.\n  struct RebuildUnknownAnyExpr\n    : StmtVisitor<RebuildUnknownAnyExpr, ExprResult> {\n\n    Sema &S;\n\n    /// The current destination type.\n    QualType DestType;\n\n    RebuildUnknownAnyExpr(Sema &S, QualType CastType)\n      : S(S), DestType(CastType) {}\n\n    ExprResult VisitStmt(Stmt *S) {\n      llvm_unreachable(\"unexpected statement!\");\n    }\n\n    ExprResult VisitExpr(Expr *E) {\n      S.Diag(E->getExprLoc(), diag::err_unsupported_unknown_any_expr)\n        << E->getSourceRange();\n      return ExprError();\n    }\n\n    ExprResult VisitCallExpr(CallExpr *E);\n    ExprResult VisitObjCMessageExpr(ObjCMessageExpr *E);\n\n    /// Rebuild an expression which simply semantically wraps another\n    /// expression which it shares the type and value kind of.\n    template <class T> ExprResult rebuildSugarExpr(T *E) {\n      ExprResult SubResult = Visit(E->getSubExpr());\n      if (SubResult.isInvalid()) return ExprError();\n      Expr *SubExpr = SubResult.get();\n      E->setSubExpr(SubExpr);\n      E->setType(SubExpr->getType());\n      E->setValueKind(SubExpr->getValueKind());\n      assert(E->getObjectKind() == OK_Ordinary);\n      return E;\n    }\n\n    ExprResult VisitParenExpr(ParenExpr *E) {\n      return rebuildSugarExpr(E);\n    }\n\n    ExprResult VisitUnaryExtension(UnaryOperator *E) {\n      return rebuildSugarExpr(E);\n    }\n\n    ExprResult VisitUnaryAddrOf(UnaryOperator *E) {\n      const PointerType *Ptr = DestType->getAs<PointerType>();\n      if (!Ptr) {\n        S.Diag(E->getOperatorLoc(), diag::err_unknown_any_addrof)\n          << E->getSourceRange();\n        return ExprError();\n      }\n\n      if (isa<CallExpr>(E->getSubExpr())) {\n        S.Diag(E->getOperatorLoc(), diag::err_unknown_any_addrof_call)\n          << E->getSourceRange();\n        return ExprError();\n      }\n\n      assert(E->getValueKind() == VK_RValue);\n      assert(E->getObjectKind() == OK_Ordinary);\n      E->setType(DestType);\n\n      // Build the sub-expression as if it were an object of the pointee type.\n      DestType = Ptr->getPointeeType();\n      ExprResult SubResult = Visit(E->getSubExpr());\n      if (SubResult.isInvalid()) return ExprError();\n      E->setSubExpr(SubResult.get());\n      return E;\n    }\n\n    ExprResult VisitImplicitCastExpr(ImplicitCastExpr *E);\n\n    ExprResult resolveDecl(Expr *E, ValueDecl *VD);\n\n    ExprResult VisitMemberExpr(MemberExpr *E) {\n      return resolveDecl(E, E->getMemberDecl());\n    }\n\n    ExprResult VisitDeclRefExpr(DeclRefExpr *E) {\n      return resolveDecl(E, E->getDecl());\n    }\n  };\n}\n\n/// Rebuilds a call expression which yielded __unknown_anytype.\nExprResult RebuildUnknownAnyExpr::VisitCallExpr(CallExpr *E) {\n  Expr *CalleeExpr = E->getCallee();\n\n  enum FnKind {\n    FK_MemberFunction,\n    FK_FunctionPointer,\n    FK_BlockPointer\n  };\n\n  FnKind Kind;\n  QualType CalleeType = CalleeExpr->getType();\n  if (CalleeType == S.Context.BoundMemberTy) {\n    assert(isa<CXXMemberCallExpr>(E) || isa<CXXOperatorCallExpr>(E));\n    Kind = FK_MemberFunction;\n    CalleeType = Expr::findBoundMemberType(CalleeExpr);\n  } else if (const PointerType *Ptr = CalleeType->getAs<PointerType>()) {\n    CalleeType = Ptr->getPointeeType();\n    Kind = FK_FunctionPointer;\n  } else {\n    CalleeType = CalleeType->castAs<BlockPointerType>()->getPointeeType();\n    Kind = FK_BlockPointer;\n  }\n  const FunctionType *FnType = CalleeType->castAs<FunctionType>();\n\n  // Verify that this is a legal result type of a function.\n  if (DestType->isArrayType() || DestType->isFunctionType()) {\n    unsigned diagID = diag::err_func_returning_array_function;\n    if (Kind == FK_BlockPointer)\n      diagID = diag::err_block_returning_array_function;\n\n    S.Diag(E->getExprLoc(), diagID)\n      << DestType->isFunctionType() << DestType;\n    return ExprError();\n  }\n\n  // Otherwise, go ahead and set DestType as the call's result.\n  E->setType(DestType.getNonLValueExprType(S.Context));\n  E->setValueKind(Expr::getValueKindForType(DestType));\n  assert(E->getObjectKind() == OK_Ordinary);\n\n  // Rebuild the function type, replacing the result type with DestType.\n  const FunctionProtoType *Proto = dyn_cast<FunctionProtoType>(FnType);\n  if (Proto) {\n    // __unknown_anytype(...) is a special case used by the debugger when\n    // it has no idea what a function's signature is.\n    //\n    // We want to build this call essentially under the K&R\n    // unprototyped rules, but making a FunctionNoProtoType in C++\n    // would foul up all sorts of assumptions.  However, we cannot\n    // simply pass all arguments as variadic arguments, nor can we\n    // portably just call the function under a non-variadic type; see\n    // the comment on IR-gen's TargetInfo::isNoProtoCallVariadic.\n    // However, it turns out that in practice it is generally safe to\n    // call a function declared as \"A foo(B,C,D);\" under the prototype\n    // \"A foo(B,C,D,...);\".  The only known exception is with the\n    // Windows ABI, where any variadic function is implicitly cdecl\n    // regardless of its normal CC.  Therefore we change the parameter\n    // types to match the types of the arguments.\n    //\n    // This is a hack, but it is far superior to moving the\n    // corresponding target-specific code from IR-gen to Sema/AST.\n\n    ArrayRef<QualType> ParamTypes = Proto->getParamTypes();\n    SmallVector<QualType, 8> ArgTypes;\n    if (ParamTypes.empty() && Proto->isVariadic()) { // the special case\n      ArgTypes.reserve(E->getNumArgs());\n      for (unsigned i = 0, e = E->getNumArgs(); i != e; ++i) {\n        Expr *Arg = E->getArg(i);\n        QualType ArgType = Arg->getType();\n        if (E->isLValue()) {\n          ArgType = S.Context.getLValueReferenceType(ArgType);\n        } else if (E->isXValue()) {\n          ArgType = S.Context.getRValueReferenceType(ArgType);\n        }\n        ArgTypes.push_back(ArgType);\n      }\n      ParamTypes = ArgTypes;\n    }\n    DestType = S.Context.getFunctionType(DestType, ParamTypes,\n                                         Proto->getExtProtoInfo());\n  } else {\n    DestType = S.Context.getFunctionNoProtoType(DestType,\n                                                FnType->getExtInfo());\n  }\n\n  // Rebuild the appropriate pointer-to-function type.\n  switch (Kind) {\n  case FK_MemberFunction:\n    // Nothing to do.\n    break;\n\n  case FK_FunctionPointer:\n    DestType = S.Context.getPointerType(DestType);\n    break;\n\n  case FK_BlockPointer:\n    DestType = S.Context.getBlockPointerType(DestType);\n    break;\n  }\n\n  // Finally, we can recurse.\n  ExprResult CalleeResult = Visit(CalleeExpr);\n  if (!CalleeResult.isUsable()) return ExprError();\n  E->setCallee(CalleeResult.get());\n\n  // Bind a temporary if necessary.\n  return S.MaybeBindToTemporary(E);\n}\n\nExprResult RebuildUnknownAnyExpr::VisitObjCMessageExpr(ObjCMessageExpr *E) {\n  // Verify that this is a legal result type of a call.\n  if (DestType->isArrayType() || DestType->isFunctionType()) {\n    S.Diag(E->getExprLoc(), diag::err_func_returning_array_function)\n      << DestType->isFunctionType() << DestType;\n    return ExprError();\n  }\n\n  // Rewrite the method result type if available.\n  if (ObjCMethodDecl *Method = E->getMethodDecl()) {\n    assert(Method->getReturnType() == S.Context.UnknownAnyTy);\n    Method->setReturnType(DestType);\n  }\n\n  // Change the type of the message.\n  E->setType(DestType.getNonReferenceType());\n  E->setValueKind(Expr::getValueKindForType(DestType));\n\n  return S.MaybeBindToTemporary(E);\n}\n\nExprResult RebuildUnknownAnyExpr::VisitImplicitCastExpr(ImplicitCastExpr *E) {\n  // The only case we should ever see here is a function-to-pointer decay.\n  if (E->getCastKind() == CK_FunctionToPointerDecay) {\n    assert(E->getValueKind() == VK_RValue);\n    assert(E->getObjectKind() == OK_Ordinary);\n\n    E->setType(DestType);\n\n    // Rebuild the sub-expression as the pointee (function) type.\n    DestType = DestType->castAs<PointerType>()->getPointeeType();\n\n    ExprResult Result = Visit(E->getSubExpr());\n    if (!Result.isUsable()) return ExprError();\n\n    E->setSubExpr(Result.get());\n    return E;\n  } else if (E->getCastKind() == CK_LValueToRValue) {\n    assert(E->getValueKind() == VK_RValue);\n    assert(E->getObjectKind() == OK_Ordinary);\n\n    assert(isa<BlockPointerType>(E->getType()));\n\n    E->setType(DestType);\n\n    // The sub-expression has to be a lvalue reference, so rebuild it as such.\n    DestType = S.Context.getLValueReferenceType(DestType);\n\n    ExprResult Result = Visit(E->getSubExpr());\n    if (!Result.isUsable()) return ExprError();\n\n    E->setSubExpr(Result.get());\n    return E;\n  } else {\n    llvm_unreachable(\"Unhandled cast type!\");\n  }\n}\n\nExprResult RebuildUnknownAnyExpr::resolveDecl(Expr *E, ValueDecl *VD) {\n  ExprValueKind ValueKind = VK_LValue;\n  QualType Type = DestType;\n\n  // We know how to make this work for certain kinds of decls:\n\n  //  - functions\n  if (FunctionDecl *FD = dyn_cast<FunctionDecl>(VD)) {\n    if (const PointerType *Ptr = Type->getAs<PointerType>()) {\n      DestType = Ptr->getPointeeType();\n      ExprResult Result = resolveDecl(E, VD);\n      if (Result.isInvalid()) return ExprError();\n      return S.ImpCastExprToType(Result.get(), Type,\n                                 CK_FunctionToPointerDecay, VK_RValue);\n    }\n\n    if (!Type->isFunctionType()) {\n      S.Diag(E->getExprLoc(), diag::err_unknown_any_function)\n        << VD << E->getSourceRange();\n      return ExprError();\n    }\n    if (const FunctionProtoType *FT = Type->getAs<FunctionProtoType>()) {\n      // We must match the FunctionDecl's type to the hack introduced in\n      // RebuildUnknownAnyExpr::VisitCallExpr to vararg functions of unknown\n      // type. See the lengthy commentary in that routine.\n      QualType FDT = FD->getType();\n      const FunctionType *FnType = FDT->castAs<FunctionType>();\n      const FunctionProtoType *Proto = dyn_cast_or_null<FunctionProtoType>(FnType);\n      DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E);\n      if (DRE && Proto && Proto->getParamTypes().empty() && Proto->isVariadic()) {\n        SourceLocation Loc = FD->getLocation();\n        FunctionDecl *NewFD = FunctionDecl::Create(\n            S.Context, FD->getDeclContext(), Loc, Loc,\n            FD->getNameInfo().getName(), DestType, FD->getTypeSourceInfo(),\n            SC_None, false /*isInlineSpecified*/, FD->hasPrototype(),\n            /*ConstexprKind*/ ConstexprSpecKind::Unspecified);\n\n        if (FD->getQualifier())\n          NewFD->setQualifierInfo(FD->getQualifierLoc());\n\n        SmallVector<ParmVarDecl*, 16> Params;\n        for (const auto &AI : FT->param_types()) {\n          ParmVarDecl *Param =\n            S.BuildParmVarDeclForTypedef(FD, Loc, AI);\n          Param->setScopeInfo(0, Params.size());\n          Params.push_back(Param);\n        }\n        NewFD->setParams(Params);\n        DRE->setDecl(NewFD);\n        VD = DRE->getDecl();\n      }\n    }\n\n    if (CXXMethodDecl *MD = dyn_cast<CXXMethodDecl>(FD))\n      if (MD->isInstance()) {\n        ValueKind = VK_RValue;\n        Type = S.Context.BoundMemberTy;\n      }\n\n    // Function references aren't l-values in C.\n    if (!S.getLangOpts().CPlusPlus)\n      ValueKind = VK_RValue;\n\n  //  - variables\n  } else if (isa<VarDecl>(VD)) {\n    if (const ReferenceType *RefTy = Type->getAs<ReferenceType>()) {\n      Type = RefTy->getPointeeType();\n    } else if (Type->isFunctionType()) {\n      S.Diag(E->getExprLoc(), diag::err_unknown_any_var_function_type)\n        << VD << E->getSourceRange();\n      return ExprError();\n    }\n\n  //  - nothing else\n  } else {\n    S.Diag(E->getExprLoc(), diag::err_unsupported_unknown_any_decl)\n      << VD << E->getSourceRange();\n    return ExprError();\n  }\n\n  // Modifying the declaration like this is friendly to IR-gen but\n  // also really dangerous.\n  VD->setType(DestType);\n  E->setType(Type);\n  E->setValueKind(ValueKind);\n  return E;\n}\n\n/// Check a cast of an unknown-any type.  We intentionally only\n/// trigger this for C-style casts.\nExprResult Sema::checkUnknownAnyCast(SourceRange TypeRange, QualType CastType,\n                                     Expr *CastExpr, CastKind &CastKind,\n                                     ExprValueKind &VK, CXXCastPath &Path) {\n  // The type we're casting to must be either void or complete.\n  if (!CastType->isVoidType() &&\n      RequireCompleteType(TypeRange.getBegin(), CastType,\n                          diag::err_typecheck_cast_to_incomplete))\n    return ExprError();\n\n  // Rewrite the casted expression from scratch.\n  ExprResult result = RebuildUnknownAnyExpr(*this, CastType).Visit(CastExpr);\n  if (!result.isUsable()) return ExprError();\n\n  CastExpr = result.get();\n  VK = CastExpr->getValueKind();\n  CastKind = CK_NoOp;\n\n  return CastExpr;\n}\n\nExprResult Sema::forceUnknownAnyToType(Expr *E, QualType ToType) {\n  return RebuildUnknownAnyExpr(*this, ToType).Visit(E);\n}\n\nExprResult Sema::checkUnknownAnyArg(SourceLocation callLoc,\n                                    Expr *arg, QualType &paramType) {\n  // If the syntactic form of the argument is not an explicit cast of\n  // any sort, just do default argument promotion.\n  ExplicitCastExpr *castArg = dyn_cast<ExplicitCastExpr>(arg->IgnoreParens());\n  if (!castArg) {\n    ExprResult result = DefaultArgumentPromotion(arg);\n    if (result.isInvalid()) return ExprError();\n    paramType = result.get()->getType();\n    return result;\n  }\n\n  // Otherwise, use the type that was written in the explicit cast.\n  assert(!arg->hasPlaceholderType());\n  paramType = castArg->getTypeAsWritten();\n\n  // Copy-initialize a parameter of that type.\n  InitializedEntity entity =\n    InitializedEntity::InitializeParameter(Context, paramType,\n                                           /*consumed*/ false);\n  return PerformCopyInitialization(entity, callLoc, arg);\n}\n\nstatic ExprResult diagnoseUnknownAnyExpr(Sema &S, Expr *E) {\n  Expr *orig = E;\n  unsigned diagID = diag::err_uncasted_use_of_unknown_any;\n  while (true) {\n    E = E->IgnoreParenImpCasts();\n    if (CallExpr *call = dyn_cast<CallExpr>(E)) {\n      E = call->getCallee();\n      diagID = diag::err_uncasted_call_of_unknown_any;\n    } else {\n      break;\n    }\n  }\n\n  SourceLocation loc;\n  NamedDecl *d;\n  if (DeclRefExpr *ref = dyn_cast<DeclRefExpr>(E)) {\n    loc = ref->getLocation();\n    d = ref->getDecl();\n  } else if (MemberExpr *mem = dyn_cast<MemberExpr>(E)) {\n    loc = mem->getMemberLoc();\n    d = mem->getMemberDecl();\n  } else if (ObjCMessageExpr *msg = dyn_cast<ObjCMessageExpr>(E)) {\n    diagID = diag::err_uncasted_call_of_unknown_any;\n    loc = msg->getSelectorStartLoc();\n    d = msg->getMethodDecl();\n    if (!d) {\n      S.Diag(loc, diag::err_uncasted_send_to_unknown_any_method)\n        << static_cast<unsigned>(msg->isClassMessage()) << msg->getSelector()\n        << orig->getSourceRange();\n      return ExprError();\n    }\n  } else {\n    S.Diag(E->getExprLoc(), diag::err_unsupported_unknown_any_expr)\n      << E->getSourceRange();\n    return ExprError();\n  }\n\n  S.Diag(loc, diagID) << d << orig->getSourceRange();\n\n  // Never recoverable.\n  return ExprError();\n}\n\n/// Check for operands with placeholder types and complain if found.\n/// Returns ExprError() if there was an error and no recovery was possible.\nExprResult Sema::CheckPlaceholderExpr(Expr *E) {\n  if (!Context.isDependenceAllowed()) {\n    // C cannot handle TypoExpr nodes on either side of a binop because it\n    // doesn't handle dependent types properly, so make sure any TypoExprs have\n    // been dealt with before checking the operands.\n    ExprResult Result = CorrectDelayedTyposInExpr(E);\n    if (!Result.isUsable()) return ExprError();\n    E = Result.get();\n  }\n\n  const BuiltinType *placeholderType = E->getType()->getAsPlaceholderType();\n  if (!placeholderType) return E;\n\n  switch (placeholderType->getKind()) {\n\n  // Overloaded expressions.\n  case BuiltinType::Overload: {\n    // Try to resolve a single function template specialization.\n    // This is obligatory.\n    ExprResult Result = E;\n    if (ResolveAndFixSingleFunctionTemplateSpecialization(Result, false))\n      return Result;\n\n    // No guarantees that ResolveAndFixSingleFunctionTemplateSpecialization\n    // leaves Result unchanged on failure.\n    Result = E;\n    if (resolveAndFixAddressOfSingleOverloadCandidate(Result))\n      return Result;\n\n    // If that failed, try to recover with a call.\n    tryToRecoverWithCall(Result, PDiag(diag::err_ovl_unresolvable),\n                         /*complain*/ true);\n    return Result;\n  }\n\n  // Bound member functions.\n  case BuiltinType::BoundMember: {\n    ExprResult result = E;\n    const Expr *BME = E->IgnoreParens();\n    PartialDiagnostic PD = PDiag(diag::err_bound_member_function);\n    // Try to give a nicer diagnostic if it is a bound member that we recognize.\n    if (isa<CXXPseudoDestructorExpr>(BME)) {\n      PD = PDiag(diag::err_dtor_expr_without_call) << /*pseudo-destructor*/ 1;\n    } else if (const auto *ME = dyn_cast<MemberExpr>(BME)) {\n      if (ME->getMemberNameInfo().getName().getNameKind() ==\n          DeclarationName::CXXDestructorName)\n        PD = PDiag(diag::err_dtor_expr_without_call) << /*destructor*/ 0;\n    }\n    tryToRecoverWithCall(result, PD,\n                         /*complain*/ true);\n    return result;\n  }\n\n  // ARC unbridged casts.\n  case BuiltinType::ARCUnbridgedCast: {\n    Expr *realCast = stripARCUnbridgedCast(E);\n    diagnoseARCUnbridgedCast(realCast);\n    return realCast;\n  }\n\n  // Expressions of unknown type.\n  case BuiltinType::UnknownAny:\n    return diagnoseUnknownAnyExpr(*this, E);\n\n  // Pseudo-objects.\n  case BuiltinType::PseudoObject:\n    return checkPseudoObjectRValue(E);\n\n  case BuiltinType::BuiltinFn: {\n    // Accept __noop without parens by implicitly converting it to a call expr.\n    auto *DRE = dyn_cast<DeclRefExpr>(E->IgnoreParenImpCasts());\n    if (DRE) {\n      auto *FD = cast<FunctionDecl>(DRE->getDecl());\n      if (FD->getBuiltinID() == Builtin::BI__noop) {\n        E = ImpCastExprToType(E, Context.getPointerType(FD->getType()),\n                              CK_BuiltinFnToFnPtr)\n                .get();\n        return CallExpr::Create(Context, E, /*Args=*/{}, Context.IntTy,\n                                VK_RValue, SourceLocation(),\n                                FPOptionsOverride());\n      }\n    }\n\n    Diag(E->getBeginLoc(), diag::err_builtin_fn_use);\n    return ExprError();\n  }\n\n  case BuiltinType::IncompleteMatrixIdx:\n    Diag(cast<MatrixSubscriptExpr>(E->IgnoreParens())\n             ->getRowIdx()\n             ->getBeginLoc(),\n         diag::err_matrix_incomplete_index);\n    return ExprError();\n\n  // Expressions of unknown type.\n  case BuiltinType::OMPArraySection:\n    Diag(E->getBeginLoc(), diag::err_omp_array_section_use);\n    return ExprError();\n\n  // Expressions of unknown type.\n  case BuiltinType::OMPArrayShaping:\n    return ExprError(Diag(E->getBeginLoc(), diag::err_omp_array_shaping_use));\n\n  case BuiltinType::OMPIterator:\n    return ExprError(Diag(E->getBeginLoc(), diag::err_omp_iterator_use));\n\n  // Everything else should be impossible.\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n  case BuiltinType::Id:\n#include \"clang/Basic/OpenCLImageTypes.def\"\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n  case BuiltinType::Id:\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n#define SVE_TYPE(Name, Id, SingletonId) \\\n  case BuiltinType::Id:\n#include \"clang/Basic/AArch64SVEACLETypes.def\"\n#define PPC_VECTOR_TYPE(Name, Id, Size) \\\n  case BuiltinType::Id:\n#include \"clang/Basic/PPCTypes.def\"\n#define RVV_TYPE(Name, Id, SingletonId) case BuiltinType::Id:\n#include \"clang/Basic/RISCVVTypes.def\"\n#define BUILTIN_TYPE(Id, SingletonId) case BuiltinType::Id:\n#define PLACEHOLDER_TYPE(Id, SingletonId)\n#include \"clang/AST/BuiltinTypes.def\"\n    break;\n  }\n\n  llvm_unreachable(\"invalid placeholder type!\");\n}\n\nbool Sema::CheckCaseExpression(Expr *E) {\n  if (E->isTypeDependent())\n    return true;\n  if (E->isValueDependent() || E->isIntegerConstantExpr(Context))\n    return E->getType()->isIntegralOrEnumerationType();\n  return false;\n}\n\n/// ActOnObjCBoolLiteral - Parse {__objc_yes,__objc_no} literals.\nExprResult\nSema::ActOnObjCBoolLiteral(SourceLocation OpLoc, tok::TokenKind Kind) {\n  assert((Kind == tok::kw___objc_yes || Kind == tok::kw___objc_no) &&\n         \"Unknown Objective-C Boolean value!\");\n  QualType BoolT = Context.ObjCBuiltinBoolTy;\n  if (!Context.getBOOLDecl()) {\n    LookupResult Result(*this, &Context.Idents.get(\"BOOL\"), OpLoc,\n                        Sema::LookupOrdinaryName);\n    if (LookupName(Result, getCurScope()) && Result.isSingleResult()) {\n      NamedDecl *ND = Result.getFoundDecl();\n      if (TypedefDecl *TD = dyn_cast<TypedefDecl>(ND))\n        Context.setBOOLDecl(TD);\n    }\n  }\n  if (Context.getBOOLDecl())\n    BoolT = Context.getBOOLType();\n  return new (Context)\n      ObjCBoolLiteralExpr(Kind == tok::kw___objc_yes, BoolT, OpLoc);\n}\n\nExprResult Sema::ActOnObjCAvailabilityCheckExpr(\n    llvm::ArrayRef<AvailabilitySpec> AvailSpecs, SourceLocation AtLoc,\n    SourceLocation RParen) {\n\n  StringRef Platform = getASTContext().getTargetInfo().getPlatformName();\n\n  auto Spec = llvm::find_if(AvailSpecs, [&](const AvailabilitySpec &Spec) {\n    return Spec.getPlatform() == Platform;\n  });\n\n  VersionTuple Version;\n  if (Spec != AvailSpecs.end())\n    Version = Spec->getVersion();\n\n  // The use of `@available` in the enclosing function should be analyzed to\n  // warn when it's used inappropriately (i.e. not if(@available)).\n  if (getCurFunctionOrMethodDecl())\n    getEnclosingFunction()->HasPotentialAvailabilityViolations = true;\n  else if (getCurBlock() || getCurLambda())\n    getCurFunction()->HasPotentialAvailabilityViolations = true;\n\n  return new (Context)\n      ObjCAvailabilityCheckExpr(Version, AtLoc, RParen, Context.BoolTy);\n}\n\nExprResult Sema::CreateRecoveryExpr(SourceLocation Begin, SourceLocation End,\n                                    ArrayRef<Expr *> SubExprs, QualType T) {\n  if (!Context.getLangOpts().RecoveryAST)\n    return ExprError();\n\n  if (isSFINAEContext())\n    return ExprError();\n\n  if (T.isNull() || !Context.getLangOpts().RecoveryASTType)\n    // We don't know the concrete type, fallback to dependent type.\n    T = Context.DependentTy;\n  return RecoveryExpr::Create(Context, T, Begin, End, SubExprs);\n}\n"}}, "reports": [{"events": [{"location": {"col": 10, "file": 30, "line": 43}, "message": "'NullDiagnostic' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/PartialDiagnostic.h", "reportHash": "78ec1b591816a9dbe6e8aca44f889ac7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 43, "line": 50}, "message": "'AccessedEntity' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DelayedDiagnostic.h", "reportHash": "5c9a1341ded518c537cddb7d1a1469e0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 43, "line": 273}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 43, "line": 273}, "message": "'DelayedDiagnosticPool' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/DelayedDiagnostic.h", "reportHash": "c43f0dc1099db78bb2403c24813c40f7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 44, "line": 259}, "message": "'StandardConversionSequence' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Overload.h", "reportHash": "7d2db373ee9fc86e55f15aa03bed1539", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 45, "line": 16697}, "message": "'ParamIncompleteTypeDiagnoser' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaExpr.cpp", "reportHash": "8f5cd70122a16a008f7b3182ed133fc9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 45, "line": 18754}, "message": "'RebuildUnknownAnyFunction' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaExpr.cpp", "reportHash": "00992822f7276bc6daf0115873ab552d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
