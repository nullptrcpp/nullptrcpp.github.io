<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/ItaniumMangle.cpp", "content": "//===--- ItaniumMangle.cpp - Itanium C++ Name Mangling ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Implements C++ name mangling according to the Itanium C++ ABI,\n// which is used in GCC 3.2 and newer (and many compilers that are\n// ABI-compatible with GCC):\n//\n//   http://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/AST/Mangle.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclOpenMP.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprConcepts.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/Basic/ABI.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nusing namespace clang;\n\nnamespace {\n\n/// Retrieve the declaration context that should be used when mangling the given\n/// declaration.\nstatic const DeclContext *getEffectiveDeclContext(const Decl *D) {\n  // The ABI assumes that lambda closure types that occur within\n  // default arguments live in the context of the function. However, due to\n  // the way in which Clang parses and creates function declarations, this is\n  // not the case: the lambda closure type ends up living in the context\n  // where the function itself resides, because the function declaration itself\n  // had not yet been created. Fix the context here.\n  if (const CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(D)) {\n    if (RD->isLambda())\n      if (ParmVarDecl *ContextParam\n            = dyn_cast_or_null<ParmVarDecl>(RD->getLambdaContextDecl()))\n        return ContextParam->getDeclContext();\n  }\n\n  // Perform the same check for block literals.\n  if (const BlockDecl *BD = dyn_cast<BlockDecl>(D)) {\n    if (ParmVarDecl *ContextParam\n          = dyn_cast_or_null<ParmVarDecl>(BD->getBlockManglingContextDecl()))\n      return ContextParam->getDeclContext();\n  }\n\n  const DeclContext *DC = D->getDeclContext();\n  if (isa<CapturedDecl>(DC) || isa<OMPDeclareReductionDecl>(DC) ||\n      isa<OMPDeclareMapperDecl>(DC)) {\n    return getEffectiveDeclContext(cast<Decl>(DC));\n  }\n\n  if (const auto *VD = dyn_cast<VarDecl>(D))\n    if (VD->isExternC())\n      return VD->getASTContext().getTranslationUnitDecl();\n\n  if (const auto *FD = dyn_cast<FunctionDecl>(D))\n    if (FD->isExternC())\n      return FD->getASTContext().getTranslationUnitDecl();\n\n  return DC->getRedeclContext();\n}\n\nstatic const DeclContext *getEffectiveParentContext(const DeclContext *DC) {\n  return getEffectiveDeclContext(cast<Decl>(DC));\n}\n\nstatic bool isLocalContainerContext(const DeclContext *DC) {\n  return isa<FunctionDecl>(DC) || isa<ObjCMethodDecl>(DC) || isa<BlockDecl>(DC);\n}\n\nstatic const RecordDecl *GetLocalClassDecl(const Decl *D) {\n  const DeclContext *DC = getEffectiveDeclContext(D);\n  while (!DC->isNamespace() && !DC->isTranslationUnit()) {\n    if (isLocalContainerContext(DC))\n      return dyn_cast<RecordDecl>(D);\n    D = cast<Decl>(DC);\n    DC = getEffectiveDeclContext(D);\n  }\n  return nullptr;\n}\n\nstatic const FunctionDecl *getStructor(const FunctionDecl *fn) {\n  if (const FunctionTemplateDecl *ftd = fn->getPrimaryTemplate())\n    return ftd->getTemplatedDecl();\n\n  return fn;\n}\n\nstatic const NamedDecl *getStructor(const NamedDecl *decl) {\n  const FunctionDecl *fn = dyn_cast_or_null<FunctionDecl>(decl);\n  return (fn ? getStructor(fn) : decl);\n}\n\nstatic bool isLambda(const NamedDecl *ND) {\n  const CXXRecordDecl *Record = dyn_cast<CXXRecordDecl>(ND);\n  if (!Record)\n    return false;\n\n  return Record->isLambda();\n}\n\nstatic const unsigned UnknownArity = ~0U;\n\nclass ItaniumMangleContextImpl : public ItaniumMangleContext {\n  typedef std::pair<const DeclContext*, IdentifierInfo*> DiscriminatorKeyTy;\n  llvm::DenseMap<DiscriminatorKeyTy, unsigned> Discriminator;\n  llvm::DenseMap<const NamedDecl*, unsigned> Uniquifier;\n\n  bool IsDevCtx = false;\n  bool NeedsUniqueInternalLinkageNames = false;\n\npublic:\n  explicit ItaniumMangleContextImpl(ASTContext &Context,\n                                    DiagnosticsEngine &Diags)\n      : ItaniumMangleContext(Context, Diags) {}\n\n  /// @name Mangler Entry Points\n  /// @{\n\n  bool shouldMangleCXXName(const NamedDecl *D) override;\n  bool shouldMangleStringLiteral(const StringLiteral *) override {\n    return false;\n  }\n\n  bool isUniqueInternalLinkageDecl(const NamedDecl *ND) override;\n  void needsUniqueInternalLinkageNames() override {\n    NeedsUniqueInternalLinkageNames = true;\n  }\n\n  bool isDeviceMangleContext() const override { return IsDevCtx; }\n  void setDeviceMangleContext(bool IsDev) override { IsDevCtx = IsDev; }\n\n  void mangleCXXName(GlobalDecl GD, raw_ostream &) override;\n  void mangleThunk(const CXXMethodDecl *MD, const ThunkInfo &Thunk,\n                   raw_ostream &) override;\n  void mangleCXXDtorThunk(const CXXDestructorDecl *DD, CXXDtorType Type,\n                          const ThisAdjustment &ThisAdjustment,\n                          raw_ostream &) override;\n  void mangleReferenceTemporary(const VarDecl *D, unsigned ManglingNumber,\n                                raw_ostream &) override;\n  void mangleCXXVTable(const CXXRecordDecl *RD, raw_ostream &) override;\n  void mangleCXXVTT(const CXXRecordDecl *RD, raw_ostream &) override;\n  void mangleCXXCtorVTable(const CXXRecordDecl *RD, int64_t Offset,\n                           const CXXRecordDecl *Type, raw_ostream &) override;\n  void mangleCXXRTTI(QualType T, raw_ostream &) override;\n  void mangleCXXRTTIName(QualType T, raw_ostream &) override;\n  void mangleTypeName(QualType T, raw_ostream &) override;\n\n  void mangleCXXCtorComdat(const CXXConstructorDecl *D, raw_ostream &) override;\n  void mangleCXXDtorComdat(const CXXDestructorDecl *D, raw_ostream &) override;\n  void mangleStaticGuardVariable(const VarDecl *D, raw_ostream &) override;\n  void mangleDynamicInitializer(const VarDecl *D, raw_ostream &Out) override;\n  void mangleDynamicAtExitDestructor(const VarDecl *D,\n                                     raw_ostream &Out) override;\n  void mangleDynamicStermFinalizer(const VarDecl *D, raw_ostream &Out) override;\n  void mangleSEHFilterExpression(const NamedDecl *EnclosingDecl,\n                                 raw_ostream &Out) override;\n  void mangleSEHFinallyBlock(const NamedDecl *EnclosingDecl,\n                             raw_ostream &Out) override;\n  void mangleItaniumThreadLocalInit(const VarDecl *D, raw_ostream &) override;\n  void mangleItaniumThreadLocalWrapper(const VarDecl *D,\n                                       raw_ostream &) override;\n\n  void mangleStringLiteral(const StringLiteral *, raw_ostream &) override;\n\n  void mangleLambdaSig(const CXXRecordDecl *Lambda, raw_ostream &) override;\n\n  bool getNextDiscriminator(const NamedDecl *ND, unsigned &disc) {\n    // Lambda closure types are already numbered.\n    if (isLambda(ND))\n      return false;\n\n    // Anonymous tags are already numbered.\n    if (const TagDecl *Tag = dyn_cast<TagDecl>(ND)) {\n      if (Tag->getName().empty() && !Tag->getTypedefNameForAnonDecl())\n        return false;\n    }\n\n    // Use the canonical number for externally visible decls.\n    if (ND->isExternallyVisible()) {\n      unsigned discriminator = getASTContext().getManglingNumber(ND);\n      if (discriminator == 1)\n        return false;\n      disc = discriminator - 2;\n      return true;\n    }\n\n    // Make up a reasonable number for internal decls.\n    unsigned &discriminator = Uniquifier[ND];\n    if (!discriminator) {\n      const DeclContext *DC = getEffectiveDeclContext(ND);\n      discriminator = ++Discriminator[std::make_pair(DC, ND->getIdentifier())];\n    }\n    if (discriminator == 1)\n      return false;\n    disc = discriminator-2;\n    return true;\n  }\n\n  std::string getLambdaString(const CXXRecordDecl *Lambda) override {\n    // This function matches the one in MicrosoftMangle, which returns\n    // the string that is used in lambda mangled names.\n    assert(Lambda->isLambda() && \"RD must be a lambda!\");\n    std::string Name(\"<lambda\");\n    Decl *LambdaContextDecl = Lambda->getLambdaContextDecl();\n    unsigned LambdaManglingNumber = Lambda->getLambdaManglingNumber();\n    unsigned LambdaId;\n    const ParmVarDecl *Parm = dyn_cast_or_null<ParmVarDecl>(LambdaContextDecl);\n    const FunctionDecl *Func =\n        Parm ? dyn_cast<FunctionDecl>(Parm->getDeclContext()) : nullptr;\n\n    if (Func) {\n      unsigned DefaultArgNo =\n          Func->getNumParams() - Parm->getFunctionScopeIndex();\n      Name += llvm::utostr(DefaultArgNo);\n      Name += \"_\";\n    }\n\n    if (LambdaManglingNumber)\n      LambdaId = LambdaManglingNumber;\n    else\n      LambdaId = getAnonymousStructIdForDebugInfo(Lambda);\n\n    Name += llvm::utostr(LambdaId);\n    Name += '>';\n    return Name;\n  }\n\n  /// @}\n};\n\n/// Manage the mangling of a single name.\nclass CXXNameMangler {\n  ItaniumMangleContextImpl &Context;\n  raw_ostream &Out;\n  bool NullOut = false;\n  /// In the \"DisableDerivedAbiTags\" mode derived ABI tags are not calculated.\n  /// This mode is used when mangler creates another mangler recursively to\n  /// calculate ABI tags for the function return value or the variable type.\n  /// Also it is required to avoid infinite recursion in some cases.\n  bool DisableDerivedAbiTags = false;\n\n  /// The \"structor\" is the top-level declaration being mangled, if\n  /// that's not a template specialization; otherwise it's the pattern\n  /// for that specialization.\n  const NamedDecl *Structor;\n  unsigned StructorType;\n\n  /// The next substitution sequence number.\n  unsigned SeqID;\n\n  class FunctionTypeDepthState {\n    unsigned Bits;\n\n    enum { InResultTypeMask = 1 };\n\n  public:\n    FunctionTypeDepthState() : Bits(0) {}\n\n    /// The number of function types we're inside.\n    unsigned getDepth() const {\n      return Bits >> 1;\n    }\n\n    /// True if we're in the return type of the innermost function type.\n    bool isInResultType() const {\n      return Bits & InResultTypeMask;\n    }\n\n    FunctionTypeDepthState push() {\n      FunctionTypeDepthState tmp = *this;\n      Bits = (Bits & ~InResultTypeMask) + 2;\n      return tmp;\n    }\n\n    void enterResultType() {\n      Bits |= InResultTypeMask;\n    }\n\n    void leaveResultType() {\n      Bits &= ~InResultTypeMask;\n    }\n\n    void pop(FunctionTypeDepthState saved) {\n      assert(getDepth() == saved.getDepth() + 1);\n      Bits = saved.Bits;\n    }\n\n  } FunctionTypeDepth;\n\n  // abi_tag is a gcc attribute, taking one or more strings called \"tags\".\n  // The goal is to annotate against which version of a library an object was\n  // built and to be able to provide backwards compatibility (\"dual abi\").\n  // For more information see docs/ItaniumMangleAbiTags.rst.\n  typedef SmallVector<StringRef, 4> AbiTagList;\n\n  // State to gather all implicit and explicit tags used in a mangled name.\n  // Must always have an instance of this while emitting any name to keep\n  // track.\n  class AbiTagState final {\n  public:\n    explicit AbiTagState(AbiTagState *&Head) : LinkHead(Head) {\n      Parent = LinkHead;\n      LinkHead = this;\n    }\n\n    // No copy, no move.\n    AbiTagState(const AbiTagState &) = delete;\n    AbiTagState &operator=(const AbiTagState &) = delete;\n\n    ~AbiTagState() { pop(); }\n\n    void write(raw_ostream &Out, const NamedDecl *ND,\n               const AbiTagList *AdditionalAbiTags) {\n      ND = cast<NamedDecl>(ND->getCanonicalDecl());\n      if (!isa<FunctionDecl>(ND) && !isa<VarDecl>(ND)) {\n        assert(\n            !AdditionalAbiTags &&\n            \"only function and variables need a list of additional abi tags\");\n        if (const auto *NS = dyn_cast<NamespaceDecl>(ND)) {\n          if (const auto *AbiTag = NS->getAttr<AbiTagAttr>()) {\n            UsedAbiTags.insert(UsedAbiTags.end(), AbiTag->tags().begin(),\n                               AbiTag->tags().end());\n          }\n          // Don't emit abi tags for namespaces.\n          return;\n        }\n      }\n\n      AbiTagList TagList;\n      if (const auto *AbiTag = ND->getAttr<AbiTagAttr>()) {\n        UsedAbiTags.insert(UsedAbiTags.end(), AbiTag->tags().begin(),\n                           AbiTag->tags().end());\n        TagList.insert(TagList.end(), AbiTag->tags().begin(),\n                       AbiTag->tags().end());\n      }\n\n      if (AdditionalAbiTags) {\n        UsedAbiTags.insert(UsedAbiTags.end(), AdditionalAbiTags->begin(),\n                           AdditionalAbiTags->end());\n        TagList.insert(TagList.end(), AdditionalAbiTags->begin(),\n                       AdditionalAbiTags->end());\n      }\n\n      llvm::sort(TagList);\n      TagList.erase(std::unique(TagList.begin(), TagList.end()), TagList.end());\n\n      writeSortedUniqueAbiTags(Out, TagList);\n    }\n\n    const AbiTagList &getUsedAbiTags() const { return UsedAbiTags; }\n    void setUsedAbiTags(const AbiTagList &AbiTags) {\n      UsedAbiTags = AbiTags;\n    }\n\n    const AbiTagList &getEmittedAbiTags() const {\n      return EmittedAbiTags;\n    }\n\n    const AbiTagList &getSortedUniqueUsedAbiTags() {\n      llvm::sort(UsedAbiTags);\n      UsedAbiTags.erase(std::unique(UsedAbiTags.begin(), UsedAbiTags.end()),\n                        UsedAbiTags.end());\n      return UsedAbiTags;\n    }\n\n  private:\n    //! All abi tags used implicitly or explicitly.\n    AbiTagList UsedAbiTags;\n    //! All explicit abi tags (i.e. not from namespace).\n    AbiTagList EmittedAbiTags;\n\n    AbiTagState *&LinkHead;\n    AbiTagState *Parent = nullptr;\n\n    void pop() {\n      assert(LinkHead == this &&\n             \"abi tag link head must point to us on destruction\");\n      if (Parent) {\n        Parent->UsedAbiTags.insert(Parent->UsedAbiTags.end(),\n                                   UsedAbiTags.begin(), UsedAbiTags.end());\n        Parent->EmittedAbiTags.insert(Parent->EmittedAbiTags.end(),\n                                      EmittedAbiTags.begin(),\n                                      EmittedAbiTags.end());\n      }\n      LinkHead = Parent;\n    }\n\n    void writeSortedUniqueAbiTags(raw_ostream &Out, const AbiTagList &AbiTags) {\n      for (const auto &Tag : AbiTags) {\n        EmittedAbiTags.push_back(Tag);\n        Out << \"B\";\n        Out << Tag.size();\n        Out << Tag;\n      }\n    }\n  };\n\n  AbiTagState *AbiTags = nullptr;\n  AbiTagState AbiTagsRoot;\n\n  llvm::DenseMap<uintptr_t, unsigned> Substitutions;\n  llvm::DenseMap<StringRef, unsigned> ModuleSubstitutions;\n\n  ASTContext &getASTContext() const { return Context.getASTContext(); }\n\npublic:\n  CXXNameMangler(ItaniumMangleContextImpl &C, raw_ostream &Out_,\n                 const NamedDecl *D = nullptr, bool NullOut_ = false)\n    : Context(C), Out(Out_), NullOut(NullOut_),  Structor(getStructor(D)),\n      StructorType(0), SeqID(0), AbiTagsRoot(AbiTags) {\n    // These can't be mangled without a ctor type or dtor type.\n    assert(!D || (!isa<CXXDestructorDecl>(D) &&\n                  !isa<CXXConstructorDecl>(D)));\n  }\n  CXXNameMangler(ItaniumMangleContextImpl &C, raw_ostream &Out_,\n                 const CXXConstructorDecl *D, CXXCtorType Type)\n    : Context(C), Out(Out_), Structor(getStructor(D)), StructorType(Type),\n      SeqID(0), AbiTagsRoot(AbiTags) { }\n  CXXNameMangler(ItaniumMangleContextImpl &C, raw_ostream &Out_,\n                 const CXXDestructorDecl *D, CXXDtorType Type)\n    : Context(C), Out(Out_), Structor(getStructor(D)), StructorType(Type),\n      SeqID(0), AbiTagsRoot(AbiTags) { }\n\n  CXXNameMangler(CXXNameMangler &Outer, raw_ostream &Out_)\n      : Context(Outer.Context), Out(Out_), NullOut(false),\n        Structor(Outer.Structor), StructorType(Outer.StructorType),\n        SeqID(Outer.SeqID), FunctionTypeDepth(Outer.FunctionTypeDepth),\n        AbiTagsRoot(AbiTags), Substitutions(Outer.Substitutions) {}\n\n  CXXNameMangler(CXXNameMangler &Outer, llvm::raw_null_ostream &Out_)\n      : Context(Outer.Context), Out(Out_), NullOut(true),\n        Structor(Outer.Structor), StructorType(Outer.StructorType),\n        SeqID(Outer.SeqID), FunctionTypeDepth(Outer.FunctionTypeDepth),\n        AbiTagsRoot(AbiTags), Substitutions(Outer.Substitutions) {}\n\n  raw_ostream &getStream() { return Out; }\n\n  void disableDerivedAbiTags() { DisableDerivedAbiTags = true; }\n  static bool shouldHaveAbiTags(ItaniumMangleContextImpl &C, const VarDecl *VD);\n\n  void mangle(GlobalDecl GD);\n  void mangleCallOffset(int64_t NonVirtual, int64_t Virtual);\n  void mangleNumber(const llvm::APSInt &I);\n  void mangleNumber(int64_t Number);\n  void mangleFloat(const llvm::APFloat &F);\n  void mangleFunctionEncoding(GlobalDecl GD);\n  void mangleSeqID(unsigned SeqID);\n  void mangleName(GlobalDecl GD);\n  void mangleType(QualType T);\n  void mangleNameOrStandardSubstitution(const NamedDecl *ND);\n  void mangleLambdaSig(const CXXRecordDecl *Lambda);\n\nprivate:\n\n  bool mangleSubstitution(const NamedDecl *ND);\n  bool mangleSubstitution(QualType T);\n  bool mangleSubstitution(TemplateName Template);\n  bool mangleSubstitution(uintptr_t Ptr);\n\n  void mangleExistingSubstitution(TemplateName name);\n\n  bool mangleStandardSubstitution(const NamedDecl *ND);\n\n  void addSubstitution(const NamedDecl *ND) {\n    ND = cast<NamedDecl>(ND->getCanonicalDecl());\n\n    addSubstitution(reinterpret_cast<uintptr_t>(ND));\n  }\n  void addSubstitution(QualType T);\n  void addSubstitution(TemplateName Template);\n  void addSubstitution(uintptr_t Ptr);\n  // Destructive copy substitutions from other mangler.\n  void extendSubstitutions(CXXNameMangler* Other);\n\n  void mangleUnresolvedPrefix(NestedNameSpecifier *qualifier,\n                              bool recursive = false);\n  void mangleUnresolvedName(NestedNameSpecifier *qualifier,\n                            DeclarationName name,\n                            const TemplateArgumentLoc *TemplateArgs,\n                            unsigned NumTemplateArgs,\n                            unsigned KnownArity = UnknownArity);\n\n  void mangleFunctionEncodingBareType(const FunctionDecl *FD);\n\n  void mangleNameWithAbiTags(GlobalDecl GD,\n                             const AbiTagList *AdditionalAbiTags);\n  void mangleModuleName(const Module *M);\n  void mangleModuleNamePrefix(StringRef Name);\n  void mangleTemplateName(const TemplateDecl *TD,\n                          const TemplateArgument *TemplateArgs,\n                          unsigned NumTemplateArgs);\n  void mangleUnqualifiedName(GlobalDecl GD,\n                             const AbiTagList *AdditionalAbiTags) {\n    mangleUnqualifiedName(GD, cast<NamedDecl>(GD.getDecl())->getDeclName(), UnknownArity,\n                          AdditionalAbiTags);\n  }\n  void mangleUnqualifiedName(GlobalDecl GD, DeclarationName Name,\n                             unsigned KnownArity,\n                             const AbiTagList *AdditionalAbiTags);\n  void mangleUnscopedName(GlobalDecl GD,\n                          const AbiTagList *AdditionalAbiTags);\n  void mangleUnscopedTemplateName(GlobalDecl GD,\n                                  const AbiTagList *AdditionalAbiTags);\n  void mangleSourceName(const IdentifierInfo *II);\n  void mangleRegCallName(const IdentifierInfo *II);\n  void mangleDeviceStubName(const IdentifierInfo *II);\n  void mangleSourceNameWithAbiTags(\n      const NamedDecl *ND, const AbiTagList *AdditionalAbiTags = nullptr);\n  void mangleLocalName(GlobalDecl GD,\n                       const AbiTagList *AdditionalAbiTags);\n  void mangleBlockForPrefix(const BlockDecl *Block);\n  void mangleUnqualifiedBlock(const BlockDecl *Block);\n  void mangleTemplateParamDecl(const NamedDecl *Decl);\n  void mangleLambda(const CXXRecordDecl *Lambda);\n  void mangleNestedName(GlobalDecl GD, const DeclContext *DC,\n                        const AbiTagList *AdditionalAbiTags,\n                        bool NoFunction=false);\n  void mangleNestedName(const TemplateDecl *TD,\n                        const TemplateArgument *TemplateArgs,\n                        unsigned NumTemplateArgs);\n  void manglePrefix(NestedNameSpecifier *qualifier);\n  void manglePrefix(const DeclContext *DC, bool NoFunction=false);\n  void manglePrefix(QualType type);\n  void mangleTemplatePrefix(GlobalDecl GD, bool NoFunction=false);\n  void mangleTemplatePrefix(TemplateName Template);\n  bool mangleUnresolvedTypeOrSimpleId(QualType DestroyedType,\n                                      StringRef Prefix = \"\");\n  void mangleOperatorName(DeclarationName Name, unsigned Arity);\n  void mangleOperatorName(OverloadedOperatorKind OO, unsigned Arity);\n  void mangleVendorQualifier(StringRef qualifier);\n  void mangleQualifiers(Qualifiers Quals, const DependentAddressSpaceType *DAST = nullptr);\n  void mangleRefQualifier(RefQualifierKind RefQualifier);\n\n  void mangleObjCMethodName(const ObjCMethodDecl *MD);\n\n  // Declare manglers for every type class.\n#define ABSTRACT_TYPE(CLASS, PARENT)\n#define NON_CANONICAL_TYPE(CLASS, PARENT)\n#define TYPE(CLASS, PARENT) void mangleType(const CLASS##Type *T);\n#include \"clang/AST/TypeNodes.inc\"\n\n  void mangleType(const TagType*);\n  void mangleType(TemplateName);\n  static StringRef getCallingConvQualifierName(CallingConv CC);\n  void mangleExtParameterInfo(FunctionProtoType::ExtParameterInfo info);\n  void mangleExtFunctionInfo(const FunctionType *T);\n  void mangleBareFunctionType(const FunctionProtoType *T, bool MangleReturnType,\n                              const FunctionDecl *FD = nullptr);\n  void mangleNeonVectorType(const VectorType *T);\n  void mangleNeonVectorType(const DependentVectorType *T);\n  void mangleAArch64NeonVectorType(const VectorType *T);\n  void mangleAArch64NeonVectorType(const DependentVectorType *T);\n  void mangleAArch64FixedSveVectorType(const VectorType *T);\n  void mangleAArch64FixedSveVectorType(const DependentVectorType *T);\n\n  void mangleIntegerLiteral(QualType T, const llvm::APSInt &Value);\n  void mangleFloatLiteral(QualType T, const llvm::APFloat &V);\n  void mangleFixedPointLiteral();\n  void mangleNullPointer(QualType T);\n\n  void mangleMemberExprBase(const Expr *base, bool isArrow);\n  void mangleMemberExpr(const Expr *base, bool isArrow,\n                        NestedNameSpecifier *qualifier,\n                        NamedDecl *firstQualifierLookup,\n                        DeclarationName name,\n                        const TemplateArgumentLoc *TemplateArgs,\n                        unsigned NumTemplateArgs,\n                        unsigned knownArity);\n  void mangleCastExpression(const Expr *E, StringRef CastEncoding);\n  void mangleInitListElements(const InitListExpr *InitList);\n  void mangleExpression(const Expr *E, unsigned Arity = UnknownArity,\n                        bool AsTemplateArg = false);\n  void mangleCXXCtorType(CXXCtorType T, const CXXRecordDecl *InheritedFrom);\n  void mangleCXXDtorType(CXXDtorType T);\n\n  void mangleTemplateArgs(TemplateName TN,\n                          const TemplateArgumentLoc *TemplateArgs,\n                          unsigned NumTemplateArgs);\n  void mangleTemplateArgs(TemplateName TN, const TemplateArgument *TemplateArgs,\n                          unsigned NumTemplateArgs);\n  void mangleTemplateArgs(TemplateName TN, const TemplateArgumentList &AL);\n  void mangleTemplateArg(TemplateArgument A, bool NeedExactType);\n  void mangleTemplateArgExpr(const Expr *E);\n  void mangleValueInTemplateArg(QualType T, const APValue &V, bool TopLevel,\n                                bool NeedExactType = false);\n\n  void mangleTemplateParameter(unsigned Depth, unsigned Index);\n\n  void mangleFunctionParam(const ParmVarDecl *parm);\n\n  void writeAbiTags(const NamedDecl *ND,\n                    const AbiTagList *AdditionalAbiTags);\n\n  // Returns sorted unique list of ABI tags.\n  AbiTagList makeFunctionReturnTypeTags(const FunctionDecl *FD);\n  // Returns sorted unique list of ABI tags.\n  AbiTagList makeVariableTypeTags(const VarDecl *VD);\n};\n\n}\n\nstatic bool isInternalLinkageDecl(const NamedDecl *ND) {\n  if (ND && ND->getFormalLinkage() == InternalLinkage &&\n      !ND->isExternallyVisible() &&\n      getEffectiveDeclContext(ND)->isFileContext() &&\n      !ND->isInAnonymousNamespace())\n    return true;\n  return false;\n}\n\n// Check if this Decl needs a unique internal linkage name.\nbool ItaniumMangleContextImpl::isUniqueInternalLinkageDecl(\n    const NamedDecl *ND) {\n  if (!NeedsUniqueInternalLinkageNames || !ND)\n    return false;\n\n  // For C functions without prototypes, return false as their\n  // names should not be mangled.\n  if (auto *FD = dyn_cast<FunctionDecl>(ND)) {\n    if (!FD->getType()->getAs<FunctionProtoType>())\n      return false;\n  }\n\n  if (isInternalLinkageDecl(ND))\n    return true;\n  return false;\n}\n\nbool ItaniumMangleContextImpl::shouldMangleCXXName(const NamedDecl *D) {\n  const FunctionDecl *FD = dyn_cast<FunctionDecl>(D);\n  if (FD) {\n    LanguageLinkage L = FD->getLanguageLinkage();\n    // Overloadable functions need mangling.\n    if (FD->hasAttr<OverloadableAttr>())\n      return true;\n\n    // \"main\" is not mangled.\n    if (FD->isMain())\n      return false;\n\n    // The Windows ABI expects that we would never mangle \"typical\"\n    // user-defined entry points regardless of visibility or freestanding-ness.\n    //\n    // N.B. This is distinct from asking about \"main\".  \"main\" has a lot of\n    // special rules associated with it in the standard while these\n    // user-defined entry points are outside of the purview of the standard.\n    // For example, there can be only one definition for \"main\" in a standards\n    // compliant program; however nothing forbids the existence of wmain and\n    // WinMain in the same translation unit.\n    if (FD->isMSVCRTEntryPoint())\n      return false;\n\n    // C++ functions and those whose names are not a simple identifier need\n    // mangling.\n    if (!FD->getDeclName().isIdentifier() || L == CXXLanguageLinkage)\n      return true;\n\n    // C functions are not mangled.\n    if (L == CLanguageLinkage)\n      return false;\n  }\n\n  // Otherwise, no mangling is done outside C++ mode.\n  if (!getASTContext().getLangOpts().CPlusPlus)\n    return false;\n\n  const VarDecl *VD = dyn_cast<VarDecl>(D);\n  if (VD && !isa<DecompositionDecl>(D)) {\n    // C variables are not mangled.\n    if (VD->isExternC())\n      return false;\n\n    // Variables at global scope with non-internal linkage are not mangled\n    const DeclContext *DC = getEffectiveDeclContext(D);\n    // Check for extern variable declared locally.\n    if (DC->isFunctionOrMethod() && D->hasLinkage())\n      while (!DC->isNamespace() && !DC->isTranslationUnit())\n        DC = getEffectiveParentContext(DC);\n    if (DC->isTranslationUnit() && D->getFormalLinkage() != InternalLinkage &&\n        !CXXNameMangler::shouldHaveAbiTags(*this, VD) &&\n        !isa<VarTemplateSpecializationDecl>(D))\n      return false;\n  }\n\n  return true;\n}\n\nvoid CXXNameMangler::writeAbiTags(const NamedDecl *ND,\n                                  const AbiTagList *AdditionalAbiTags) {\n  assert(AbiTags && \"require AbiTagState\");\n  AbiTags->write(Out, ND, DisableDerivedAbiTags ? nullptr : AdditionalAbiTags);\n}\n\nvoid CXXNameMangler::mangleSourceNameWithAbiTags(\n    const NamedDecl *ND, const AbiTagList *AdditionalAbiTags) {\n  mangleSourceName(ND->getIdentifier());\n  writeAbiTags(ND, AdditionalAbiTags);\n}\n\nvoid CXXNameMangler::mangle(GlobalDecl GD) {\n  // <mangled-name> ::= _Z <encoding>\n  //            ::= <data name>\n  //            ::= <special-name>\n  Out << \"_Z\";\n  if (isa<FunctionDecl>(GD.getDecl()))\n    mangleFunctionEncoding(GD);\n  else if (isa<VarDecl, FieldDecl, MSGuidDecl, TemplateParamObjectDecl,\n               BindingDecl>(GD.getDecl()))\n    mangleName(GD);\n  else if (const IndirectFieldDecl *IFD =\n               dyn_cast<IndirectFieldDecl>(GD.getDecl()))\n    mangleName(IFD->getAnonField());\n  else\n    llvm_unreachable(\"unexpected kind of global decl\");\n}\n\nvoid CXXNameMangler::mangleFunctionEncoding(GlobalDecl GD) {\n  const FunctionDecl *FD = cast<FunctionDecl>(GD.getDecl());\n  // <encoding> ::= <function name> <bare-function-type>\n\n  // Don't mangle in the type if this isn't a decl we should typically mangle.\n  if (!Context.shouldMangleDeclName(FD)) {\n    mangleName(GD);\n    return;\n  }\n\n  AbiTagList ReturnTypeAbiTags = makeFunctionReturnTypeTags(FD);\n  if (ReturnTypeAbiTags.empty()) {\n    // There are no tags for return type, the simplest case.\n    mangleName(GD);\n    mangleFunctionEncodingBareType(FD);\n    return;\n  }\n\n  // Mangle function name and encoding to temporary buffer.\n  // We have to output name and encoding to the same mangler to get the same\n  // substitution as it will be in final mangling.\n  SmallString<256> FunctionEncodingBuf;\n  llvm::raw_svector_ostream FunctionEncodingStream(FunctionEncodingBuf);\n  CXXNameMangler FunctionEncodingMangler(*this, FunctionEncodingStream);\n  // Output name of the function.\n  FunctionEncodingMangler.disableDerivedAbiTags();\n  FunctionEncodingMangler.mangleNameWithAbiTags(FD, nullptr);\n\n  // Remember length of the function name in the buffer.\n  size_t EncodingPositionStart = FunctionEncodingStream.str().size();\n  FunctionEncodingMangler.mangleFunctionEncodingBareType(FD);\n\n  // Get tags from return type that are not present in function name or\n  // encoding.\n  const AbiTagList &UsedAbiTags =\n      FunctionEncodingMangler.AbiTagsRoot.getSortedUniqueUsedAbiTags();\n  AbiTagList AdditionalAbiTags(ReturnTypeAbiTags.size());\n  AdditionalAbiTags.erase(\n      std::set_difference(ReturnTypeAbiTags.begin(), ReturnTypeAbiTags.end(),\n                          UsedAbiTags.begin(), UsedAbiTags.end(),\n                          AdditionalAbiTags.begin()),\n      AdditionalAbiTags.end());\n\n  // Output name with implicit tags and function encoding from temporary buffer.\n  mangleNameWithAbiTags(FD, &AdditionalAbiTags);\n  Out << FunctionEncodingStream.str().substr(EncodingPositionStart);\n\n  // Function encoding could create new substitutions so we have to add\n  // temp mangled substitutions to main mangler.\n  extendSubstitutions(&FunctionEncodingMangler);\n}\n\nvoid CXXNameMangler::mangleFunctionEncodingBareType(const FunctionDecl *FD) {\n  if (FD->hasAttr<EnableIfAttr>()) {\n    FunctionTypeDepthState Saved = FunctionTypeDepth.push();\n    Out << \"Ua9enable_ifI\";\n    for (AttrVec::const_iterator I = FD->getAttrs().begin(),\n                                 E = FD->getAttrs().end();\n         I != E; ++I) {\n      EnableIfAttr *EIA = dyn_cast<EnableIfAttr>(*I);\n      if (!EIA)\n        continue;\n      if (Context.getASTContext().getLangOpts().getClangABICompat() >\n          LangOptions::ClangABI::Ver11) {\n        mangleTemplateArgExpr(EIA->getCond());\n      } else {\n        // Prior to Clang 12, we hardcoded the X/E around enable-if's argument,\n        // even though <template-arg> should not include an X/E around\n        // <expr-primary>.\n        Out << 'X';\n        mangleExpression(EIA->getCond());\n        Out << 'E';\n      }\n    }\n    Out << 'E';\n    FunctionTypeDepth.pop(Saved);\n  }\n\n  // When mangling an inheriting constructor, the bare function type used is\n  // that of the inherited constructor.\n  if (auto *CD = dyn_cast<CXXConstructorDecl>(FD))\n    if (auto Inherited = CD->getInheritedConstructor())\n      FD = Inherited.getConstructor();\n\n  // Whether the mangling of a function type includes the return type depends on\n  // the context and the nature of the function. The rules for deciding whether\n  // the return type is included are:\n  //\n  //   1. Template functions (names or types) have return types encoded, with\n  //   the exceptions listed below.\n  //   2. Function types not appearing as part of a function name mangling,\n  //   e.g. parameters, pointer types, etc., have return type encoded, with the\n  //   exceptions listed below.\n  //   3. Non-template function names do not have return types encoded.\n  //\n  // The exceptions mentioned in (1) and (2) above, for which the return type is\n  // never included, are\n  //   1. Constructors.\n  //   2. Destructors.\n  //   3. Conversion operator functions, e.g. operator int.\n  bool MangleReturnType = false;\n  if (FunctionTemplateDecl *PrimaryTemplate = FD->getPrimaryTemplate()) {\n    if (!(isa<CXXConstructorDecl>(FD) || isa<CXXDestructorDecl>(FD) ||\n          isa<CXXConversionDecl>(FD)))\n      MangleReturnType = true;\n\n    // Mangle the type of the primary template.\n    FD = PrimaryTemplate->getTemplatedDecl();\n  }\n\n  mangleBareFunctionType(FD->getType()->castAs<FunctionProtoType>(),\n                         MangleReturnType, FD);\n}\n\nstatic const DeclContext *IgnoreLinkageSpecDecls(const DeclContext *DC) {\n  while (isa<LinkageSpecDecl>(DC)) {\n    DC = getEffectiveParentContext(DC);\n  }\n\n  return DC;\n}\n\n/// Return whether a given namespace is the 'std' namespace.\nstatic bool isStd(const NamespaceDecl *NS) {\n  if (!IgnoreLinkageSpecDecls(getEffectiveParentContext(NS))\n                                ->isTranslationUnit())\n    return false;\n\n  const IdentifierInfo *II = NS->getOriginalNamespace()->getIdentifier();\n  return II && II->isStr(\"std\");\n}\n\n// isStdNamespace - Return whether a given decl context is a toplevel 'std'\n// namespace.\nstatic bool isStdNamespace(const DeclContext *DC) {\n  if (!DC->isNamespace())\n    return false;\n\n  return isStd(cast<NamespaceDecl>(DC));\n}\n\nstatic const GlobalDecl\nisTemplate(GlobalDecl GD, const TemplateArgumentList *&TemplateArgs) {\n  const NamedDecl *ND = cast<NamedDecl>(GD.getDecl());\n  // Check if we have a function template.\n  if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(ND)) {\n    if (const TemplateDecl *TD = FD->getPrimaryTemplate()) {\n      TemplateArgs = FD->getTemplateSpecializationArgs();\n      return GD.getWithDecl(TD);\n    }\n  }\n\n  // Check if we have a class template.\n  if (const ClassTemplateSpecializationDecl *Spec =\n        dyn_cast<ClassTemplateSpecializationDecl>(ND)) {\n    TemplateArgs = &Spec->getTemplateArgs();\n    return GD.getWithDecl(Spec->getSpecializedTemplate());\n  }\n\n  // Check if we have a variable template.\n  if (const VarTemplateSpecializationDecl *Spec =\n          dyn_cast<VarTemplateSpecializationDecl>(ND)) {\n    TemplateArgs = &Spec->getTemplateArgs();\n    return GD.getWithDecl(Spec->getSpecializedTemplate());\n  }\n\n  return GlobalDecl();\n}\n\nstatic TemplateName asTemplateName(GlobalDecl GD) {\n  const TemplateDecl *TD = dyn_cast_or_null<TemplateDecl>(GD.getDecl());\n  return TemplateName(const_cast<TemplateDecl*>(TD));\n}\n\nvoid CXXNameMangler::mangleName(GlobalDecl GD) {\n  const NamedDecl *ND = cast<NamedDecl>(GD.getDecl());\n  if (const VarDecl *VD = dyn_cast<VarDecl>(ND)) {\n    // Variables should have implicit tags from its type.\n    AbiTagList VariableTypeAbiTags = makeVariableTypeTags(VD);\n    if (VariableTypeAbiTags.empty()) {\n      // Simple case no variable type tags.\n      mangleNameWithAbiTags(VD, nullptr);\n      return;\n    }\n\n    // Mangle variable name to null stream to collect tags.\n    llvm::raw_null_ostream NullOutStream;\n    CXXNameMangler VariableNameMangler(*this, NullOutStream);\n    VariableNameMangler.disableDerivedAbiTags();\n    VariableNameMangler.mangleNameWithAbiTags(VD, nullptr);\n\n    // Get tags from variable type that are not present in its name.\n    const AbiTagList &UsedAbiTags =\n        VariableNameMangler.AbiTagsRoot.getSortedUniqueUsedAbiTags();\n    AbiTagList AdditionalAbiTags(VariableTypeAbiTags.size());\n    AdditionalAbiTags.erase(\n        std::set_difference(VariableTypeAbiTags.begin(),\n                            VariableTypeAbiTags.end(), UsedAbiTags.begin(),\n                            UsedAbiTags.end(), AdditionalAbiTags.begin()),\n        AdditionalAbiTags.end());\n\n    // Output name with implicit tags.\n    mangleNameWithAbiTags(VD, &AdditionalAbiTags);\n  } else {\n    mangleNameWithAbiTags(GD, nullptr);\n  }\n}\n\nvoid CXXNameMangler::mangleNameWithAbiTags(GlobalDecl GD,\n                                           const AbiTagList *AdditionalAbiTags) {\n  const NamedDecl *ND = cast<NamedDecl>(GD.getDecl());\n  //  <name> ::= [<module-name>] <nested-name>\n  //         ::= [<module-name>] <unscoped-name>\n  //         ::= [<module-name>] <unscoped-template-name> <template-args>\n  //         ::= <local-name>\n  //\n  const DeclContext *DC = getEffectiveDeclContext(ND);\n\n  // If this is an extern variable declared locally, the relevant DeclContext\n  // is that of the containing namespace, or the translation unit.\n  // FIXME: This is a hack; extern variables declared locally should have\n  // a proper semantic declaration context!\n  if (isLocalContainerContext(DC) && ND->hasLinkage() && !isLambda(ND))\n    while (!DC->isNamespace() && !DC->isTranslationUnit())\n      DC = getEffectiveParentContext(DC);\n  else if (GetLocalClassDecl(ND)) {\n    mangleLocalName(GD, AdditionalAbiTags);\n    return;\n  }\n\n  DC = IgnoreLinkageSpecDecls(DC);\n\n  if (isLocalContainerContext(DC)) {\n    mangleLocalName(GD, AdditionalAbiTags);\n    return;\n  }\n\n  // Do not mangle the owning module for an external linkage declaration.\n  // This enables backwards-compatibility with non-modular code, and is\n  // a valid choice since conflicts are not permitted by C++ Modules TS\n  // [basic.def.odr]/6.2.\n  if (!ND->hasExternalFormalLinkage())\n    if (Module *M = ND->getOwningModuleForLinkage())\n      mangleModuleName(M);\n\n  if (DC->isTranslationUnit() || isStdNamespace(DC)) {\n    // Check if we have a template.\n    const TemplateArgumentList *TemplateArgs = nullptr;\n    if (GlobalDecl TD = isTemplate(GD, TemplateArgs)) {\n      mangleUnscopedTemplateName(TD, AdditionalAbiTags);\n      mangleTemplateArgs(asTemplateName(TD), *TemplateArgs);\n      return;\n    }\n\n    mangleUnscopedName(GD, AdditionalAbiTags);\n    return;\n  }\n\n  mangleNestedName(GD, DC, AdditionalAbiTags);\n}\n\nvoid CXXNameMangler::mangleModuleName(const Module *M) {\n  // Implement the C++ Modules TS name mangling proposal; see\n  //     https://gcc.gnu.org/wiki/cxx-modules?action=AttachFile\n  //\n  //   <module-name> ::= W <unscoped-name>+ E\n  //                 ::= W <module-subst> <unscoped-name>* E\n  Out << 'W';\n  mangleModuleNamePrefix(M->Name);\n  Out << 'E';\n}\n\nvoid CXXNameMangler::mangleModuleNamePrefix(StringRef Name) {\n  //  <module-subst> ::= _ <seq-id>          # 0 < seq-id < 10\n  //                 ::= W <seq-id - 10> _   # otherwise\n  auto It = ModuleSubstitutions.find(Name);\n  if (It != ModuleSubstitutions.end()) {\n    if (It->second < 10)\n      Out << '_' << static_cast<char>('0' + It->second);\n    else\n      Out << 'W' << (It->second - 10) << '_';\n    return;\n  }\n\n  // FIXME: Preserve hierarchy in module names rather than flattening\n  // them to strings; use Module*s as substitution keys.\n  auto Parts = Name.rsplit('.');\n  if (Parts.second.empty())\n    Parts.second = Parts.first;\n  else\n    mangleModuleNamePrefix(Parts.first);\n\n  Out << Parts.second.size() << Parts.second;\n  ModuleSubstitutions.insert({Name, ModuleSubstitutions.size()});\n}\n\nvoid CXXNameMangler::mangleTemplateName(const TemplateDecl *TD,\n                                        const TemplateArgument *TemplateArgs,\n                                        unsigned NumTemplateArgs) {\n  const DeclContext *DC = IgnoreLinkageSpecDecls(getEffectiveDeclContext(TD));\n\n  if (DC->isTranslationUnit() || isStdNamespace(DC)) {\n    mangleUnscopedTemplateName(TD, nullptr);\n    mangleTemplateArgs(asTemplateName(TD), TemplateArgs, NumTemplateArgs);\n  } else {\n    mangleNestedName(TD, TemplateArgs, NumTemplateArgs);\n  }\n}\n\nvoid CXXNameMangler::mangleUnscopedName(GlobalDecl GD,\n                                        const AbiTagList *AdditionalAbiTags) {\n  const NamedDecl *ND = cast<NamedDecl>(GD.getDecl());\n  //  <unscoped-name> ::= <unqualified-name>\n  //                  ::= St <unqualified-name>   # ::std::\n\n  if (isStdNamespace(IgnoreLinkageSpecDecls(getEffectiveDeclContext(ND))))\n    Out << \"St\";\n\n  mangleUnqualifiedName(GD, AdditionalAbiTags);\n}\n\nvoid CXXNameMangler::mangleUnscopedTemplateName(\n    GlobalDecl GD, const AbiTagList *AdditionalAbiTags) {\n  const TemplateDecl *ND = cast<TemplateDecl>(GD.getDecl());\n  //     <unscoped-template-name> ::= <unscoped-name>\n  //                              ::= <substitution>\n  if (mangleSubstitution(ND))\n    return;\n\n  // <template-template-param> ::= <template-param>\n  if (const auto *TTP = dyn_cast<TemplateTemplateParmDecl>(ND)) {\n    assert(!AdditionalAbiTags &&\n           \"template template param cannot have abi tags\");\n    mangleTemplateParameter(TTP->getDepth(), TTP->getIndex());\n  } else if (isa<BuiltinTemplateDecl>(ND) || isa<ConceptDecl>(ND)) {\n    mangleUnscopedName(GD, AdditionalAbiTags);\n  } else {\n    mangleUnscopedName(GD.getWithDecl(ND->getTemplatedDecl()), AdditionalAbiTags);\n  }\n\n  addSubstitution(ND);\n}\n\nvoid CXXNameMangler::mangleFloat(const llvm::APFloat &f) {\n  // ABI:\n  //   Floating-point literals are encoded using a fixed-length\n  //   lowercase hexadecimal string corresponding to the internal\n  //   representation (IEEE on Itanium), high-order bytes first,\n  //   without leading zeroes. For example: \"Lf bf800000 E\" is -1.0f\n  //   on Itanium.\n  // The 'without leading zeroes' thing seems to be an editorial\n  // mistake; see the discussion on cxx-abi-dev beginning on\n  // 2012-01-16.\n\n  // Our requirements here are just barely weird enough to justify\n  // using a custom algorithm instead of post-processing APInt::toString().\n\n  llvm::APInt valueBits = f.bitcastToAPInt();\n  unsigned numCharacters = (valueBits.getBitWidth() + 3) / 4;\n  assert(numCharacters != 0);\n\n  // Allocate a buffer of the right number of characters.\n  SmallVector<char, 20> buffer(numCharacters);\n\n  // Fill the buffer left-to-right.\n  for (unsigned stringIndex = 0; stringIndex != numCharacters; ++stringIndex) {\n    // The bit-index of the next hex digit.\n    unsigned digitBitIndex = 4 * (numCharacters - stringIndex - 1);\n\n    // Project out 4 bits starting at 'digitIndex'.\n    uint64_t hexDigit = valueBits.getRawData()[digitBitIndex / 64];\n    hexDigit >>= (digitBitIndex % 64);\n    hexDigit &= 0xF;\n\n    // Map that over to a lowercase hex digit.\n    static const char charForHex[16] = {\n      '0', '1', '2', '3', '4', '5', '6', '7',\n      '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'\n    };\n    buffer[stringIndex] = charForHex[hexDigit];\n  }\n\n  Out.write(buffer.data(), numCharacters);\n}\n\nvoid CXXNameMangler::mangleFloatLiteral(QualType T, const llvm::APFloat &V) {\n  Out << 'L';\n  mangleType(T);\n  mangleFloat(V);\n  Out << 'E';\n}\n\nvoid CXXNameMangler::mangleFixedPointLiteral() {\n  DiagnosticsEngine &Diags = Context.getDiags();\n  unsigned DiagID = Diags.getCustomDiagID(\n      DiagnosticsEngine::Error, \"cannot mangle fixed point literals yet\");\n  Diags.Report(DiagID);\n}\n\nvoid CXXNameMangler::mangleNullPointer(QualType T) {\n  //  <expr-primary> ::= L <type> 0 E\n  Out << 'L';\n  mangleType(T);\n  Out << \"0E\";\n}\n\nvoid CXXNameMangler::mangleNumber(const llvm::APSInt &Value) {\n  if (Value.isSigned() && Value.isNegative()) {\n    Out << 'n';\n    Value.abs().print(Out, /*signed*/ false);\n  } else {\n    Value.print(Out, /*signed*/ false);\n  }\n}\n\nvoid CXXNameMangler::mangleNumber(int64_t Number) {\n  //  <number> ::= [n] <non-negative decimal integer>\n  if (Number < 0) {\n    Out << 'n';\n    Number = -Number;\n  }\n\n  Out << Number;\n}\n\nvoid CXXNameMangler::mangleCallOffset(int64_t NonVirtual, int64_t Virtual) {\n  //  <call-offset>  ::= h <nv-offset> _\n  //                 ::= v <v-offset> _\n  //  <nv-offset>    ::= <offset number>        # non-virtual base override\n  //  <v-offset>     ::= <offset number> _ <virtual offset number>\n  //                      # virtual base override, with vcall offset\n  if (!Virtual) {\n    Out << 'h';\n    mangleNumber(NonVirtual);\n    Out << '_';\n    return;\n  }\n\n  Out << 'v';\n  mangleNumber(NonVirtual);\n  Out << '_';\n  mangleNumber(Virtual);\n  Out << '_';\n}\n\nvoid CXXNameMangler::manglePrefix(QualType type) {\n  if (const auto *TST = type->getAs<TemplateSpecializationType>()) {\n    if (!mangleSubstitution(QualType(TST, 0))) {\n      mangleTemplatePrefix(TST->getTemplateName());\n\n      // FIXME: GCC does not appear to mangle the template arguments when\n      // the template in question is a dependent template name. Should we\n      // emulate that badness?\n      mangleTemplateArgs(TST->getTemplateName(), TST->getArgs(),\n                         TST->getNumArgs());\n      addSubstitution(QualType(TST, 0));\n    }\n  } else if (const auto *DTST =\n                 type->getAs<DependentTemplateSpecializationType>()) {\n    if (!mangleSubstitution(QualType(DTST, 0))) {\n      TemplateName Template = getASTContext().getDependentTemplateName(\n          DTST->getQualifier(), DTST->getIdentifier());\n      mangleTemplatePrefix(Template);\n\n      // FIXME: GCC does not appear to mangle the template arguments when\n      // the template in question is a dependent template name. Should we\n      // emulate that badness?\n      mangleTemplateArgs(Template, DTST->getArgs(), DTST->getNumArgs());\n      addSubstitution(QualType(DTST, 0));\n    }\n  } else {\n    // We use the QualType mangle type variant here because it handles\n    // substitutions.\n    mangleType(type);\n  }\n}\n\n/// Mangle everything prior to the base-unresolved-name in an unresolved-name.\n///\n/// \\param recursive - true if this is being called recursively,\n///   i.e. if there is more prefix \"to the right\".\nvoid CXXNameMangler::mangleUnresolvedPrefix(NestedNameSpecifier *qualifier,\n                                            bool recursive) {\n\n  // x, ::x\n  // <unresolved-name> ::= [gs] <base-unresolved-name>\n\n  // T::x / decltype(p)::x\n  // <unresolved-name> ::= sr <unresolved-type> <base-unresolved-name>\n\n  // T::N::x /decltype(p)::N::x\n  // <unresolved-name> ::= srN <unresolved-type> <unresolved-qualifier-level>+ E\n  //                       <base-unresolved-name>\n\n  // A::x, N::y, A<T>::z; \"gs\" means leading \"::\"\n  // <unresolved-name> ::= [gs] sr <unresolved-qualifier-level>+ E\n  //                       <base-unresolved-name>\n\n  switch (qualifier->getKind()) {\n  case NestedNameSpecifier::Global:\n    Out << \"gs\";\n\n    // We want an 'sr' unless this is the entire NNS.\n    if (recursive)\n      Out << \"sr\";\n\n    // We never want an 'E' here.\n    return;\n\n  case NestedNameSpecifier::Super:\n    llvm_unreachable(\"Can't mangle __super specifier\");\n\n  case NestedNameSpecifier::Namespace:\n    if (qualifier->getPrefix())\n      mangleUnresolvedPrefix(qualifier->getPrefix(),\n                             /*recursive*/ true);\n    else\n      Out << \"sr\";\n    mangleSourceNameWithAbiTags(qualifier->getAsNamespace());\n    break;\n  case NestedNameSpecifier::NamespaceAlias:\n    if (qualifier->getPrefix())\n      mangleUnresolvedPrefix(qualifier->getPrefix(),\n                             /*recursive*/ true);\n    else\n      Out << \"sr\";\n    mangleSourceNameWithAbiTags(qualifier->getAsNamespaceAlias());\n    break;\n\n  case NestedNameSpecifier::TypeSpec:\n  case NestedNameSpecifier::TypeSpecWithTemplate: {\n    const Type *type = qualifier->getAsType();\n\n    // We only want to use an unresolved-type encoding if this is one of:\n    //   - a decltype\n    //   - a template type parameter\n    //   - a template template parameter with arguments\n    // In all of these cases, we should have no prefix.\n    if (qualifier->getPrefix()) {\n      mangleUnresolvedPrefix(qualifier->getPrefix(),\n                             /*recursive*/ true);\n    } else {\n      // Otherwise, all the cases want this.\n      Out << \"sr\";\n    }\n\n    if (mangleUnresolvedTypeOrSimpleId(QualType(type, 0), recursive ? \"N\" : \"\"))\n      return;\n\n    break;\n  }\n\n  case NestedNameSpecifier::Identifier:\n    // Member expressions can have these without prefixes.\n    if (qualifier->getPrefix())\n      mangleUnresolvedPrefix(qualifier->getPrefix(),\n                             /*recursive*/ true);\n    else\n      Out << \"sr\";\n\n    mangleSourceName(qualifier->getAsIdentifier());\n    // An Identifier has no type information, so we can't emit abi tags for it.\n    break;\n  }\n\n  // If this was the innermost part of the NNS, and we fell out to\n  // here, append an 'E'.\n  if (!recursive)\n    Out << 'E';\n}\n\n/// Mangle an unresolved-name, which is generally used for names which\n/// weren't resolved to specific entities.\nvoid CXXNameMangler::mangleUnresolvedName(\n    NestedNameSpecifier *qualifier, DeclarationName name,\n    const TemplateArgumentLoc *TemplateArgs, unsigned NumTemplateArgs,\n    unsigned knownArity) {\n  if (qualifier) mangleUnresolvedPrefix(qualifier);\n  switch (name.getNameKind()) {\n    // <base-unresolved-name> ::= <simple-id>\n    case DeclarationName::Identifier:\n      mangleSourceName(name.getAsIdentifierInfo());\n      break;\n    // <base-unresolved-name> ::= dn <destructor-name>\n    case DeclarationName::CXXDestructorName:\n      Out << \"dn\";\n      mangleUnresolvedTypeOrSimpleId(name.getCXXNameType());\n      break;\n    // <base-unresolved-name> ::= on <operator-name>\n    case DeclarationName::CXXConversionFunctionName:\n    case DeclarationName::CXXLiteralOperatorName:\n    case DeclarationName::CXXOperatorName:\n      Out << \"on\";\n      mangleOperatorName(name, knownArity);\n      break;\n    case DeclarationName::CXXConstructorName:\n      llvm_unreachable(\"Can't mangle a constructor name!\");\n    case DeclarationName::CXXUsingDirective:\n      llvm_unreachable(\"Can't mangle a using directive name!\");\n    case DeclarationName::CXXDeductionGuideName:\n      llvm_unreachable(\"Can't mangle a deduction guide name!\");\n    case DeclarationName::ObjCMultiArgSelector:\n    case DeclarationName::ObjCOneArgSelector:\n    case DeclarationName::ObjCZeroArgSelector:\n      llvm_unreachable(\"Can't mangle Objective-C selector names here!\");\n  }\n\n  // The <simple-id> and on <operator-name> productions end in an optional\n  // <template-args>.\n  if (TemplateArgs)\n    mangleTemplateArgs(TemplateName(), TemplateArgs, NumTemplateArgs);\n}\n\nvoid CXXNameMangler::mangleUnqualifiedName(GlobalDecl GD,\n                                           DeclarationName Name,\n                                           unsigned KnownArity,\n                                           const AbiTagList *AdditionalAbiTags) {\n  const NamedDecl *ND = cast_or_null<NamedDecl>(GD.getDecl());\n  unsigned Arity = KnownArity;\n  //  <unqualified-name> ::= <operator-name>\n  //                     ::= <ctor-dtor-name>\n  //                     ::= <source-name>\n  switch (Name.getNameKind()) {\n  case DeclarationName::Identifier: {\n    const IdentifierInfo *II = Name.getAsIdentifierInfo();\n\n    // We mangle decomposition declarations as the names of their bindings.\n    if (auto *DD = dyn_cast<DecompositionDecl>(ND)) {\n      // FIXME: Non-standard mangling for decomposition declarations:\n      //\n      //  <unqualified-name> ::= DC <source-name>* E\n      //\n      // These can never be referenced across translation units, so we do\n      // not need a cross-vendor mangling for anything other than demanglers.\n      // Proposed on cxx-abi-dev on 2016-08-12\n      Out << \"DC\";\n      for (auto *BD : DD->bindings())\n        mangleSourceName(BD->getDeclName().getAsIdentifierInfo());\n      Out << 'E';\n      writeAbiTags(ND, AdditionalAbiTags);\n      break;\n    }\n\n    if (auto *GD = dyn_cast<MSGuidDecl>(ND)) {\n      // We follow MSVC in mangling GUID declarations as if they were variables\n      // with a particular reserved name. Continue the pretense here.\n      SmallString<sizeof(\"_GUID_12345678_1234_1234_1234_1234567890ab\")> GUID;\n      llvm::raw_svector_ostream GUIDOS(GUID);\n      Context.mangleMSGuidDecl(GD, GUIDOS);\n      Out << GUID.size() << GUID;\n      break;\n    }\n\n    if (auto *TPO = dyn_cast<TemplateParamObjectDecl>(ND)) {\n      // Proposed in https://github.com/itanium-cxx-abi/cxx-abi/issues/63.\n      Out << \"TA\";\n      mangleValueInTemplateArg(TPO->getType().getUnqualifiedType(),\n                               TPO->getValue(), /*TopLevel=*/true);\n      break;\n    }\n\n    if (II) {\n      // Match GCC's naming convention for internal linkage symbols, for\n      // symbols that are not actually visible outside of this TU. GCC\n      // distinguishes between internal and external linkage symbols in\n      // its mangling, to support cases like this that were valid C++ prior\n      // to DR426:\n      //\n      //   void test() { extern void foo(); }\n      //   static void foo();\n      //\n      // Don't bother with the L marker for names in anonymous namespaces; the\n      // 12_GLOBAL__N_1 mangling is quite sufficient there, and this better\n      // matches GCC anyway, because GCC does not treat anonymous namespaces as\n      // implying internal linkage.\n      if (isInternalLinkageDecl(ND))\n        Out << 'L';\n\n      auto *FD = dyn_cast<FunctionDecl>(ND);\n      bool IsRegCall = FD &&\n                       FD->getType()->castAs<FunctionType>()->getCallConv() ==\n                           clang::CC_X86RegCall;\n      bool IsDeviceStub =\n          FD && FD->hasAttr<CUDAGlobalAttr>() &&\n          GD.getKernelReferenceKind() == KernelReferenceKind::Stub;\n      if (IsDeviceStub)\n        mangleDeviceStubName(II);\n      else if (IsRegCall)\n        mangleRegCallName(II);\n      else\n        mangleSourceName(II);\n\n      writeAbiTags(ND, AdditionalAbiTags);\n      break;\n    }\n\n    // Otherwise, an anonymous entity.  We must have a declaration.\n    assert(ND && \"mangling empty name without declaration\");\n\n    if (const NamespaceDecl *NS = dyn_cast<NamespaceDecl>(ND)) {\n      if (NS->isAnonymousNamespace()) {\n        // This is how gcc mangles these names.\n        Out << \"12_GLOBAL__N_1\";\n        break;\n      }\n    }\n\n    if (const VarDecl *VD = dyn_cast<VarDecl>(ND)) {\n      // We must have an anonymous union or struct declaration.\n      const RecordDecl *RD = VD->getType()->castAs<RecordType>()->getDecl();\n\n      // Itanium C++ ABI 5.1.2:\n      //\n      //   For the purposes of mangling, the name of an anonymous union is\n      //   considered to be the name of the first named data member found by a\n      //   pre-order, depth-first, declaration-order walk of the data members of\n      //   the anonymous union. If there is no such data member (i.e., if all of\n      //   the data members in the union are unnamed), then there is no way for\n      //   a program to refer to the anonymous union, and there is therefore no\n      //   need to mangle its name.\n      assert(RD->isAnonymousStructOrUnion()\n             && \"Expected anonymous struct or union!\");\n      const FieldDecl *FD = RD->findFirstNamedDataMember();\n\n      // It's actually possible for various reasons for us to get here\n      // with an empty anonymous struct / union.  Fortunately, it\n      // doesn't really matter what name we generate.\n      if (!FD) break;\n      assert(FD->getIdentifier() && \"Data member name isn't an identifier!\");\n\n      mangleSourceName(FD->getIdentifier());\n      // Not emitting abi tags: internal name anyway.\n      break;\n    }\n\n    // Class extensions have no name as a category, and it's possible\n    // for them to be the semantic parent of certain declarations\n    // (primarily, tag decls defined within declarations).  Such\n    // declarations will always have internal linkage, so the name\n    // doesn't really matter, but we shouldn't crash on them.  For\n    // safety, just handle all ObjC containers here.\n    if (isa<ObjCContainerDecl>(ND))\n      break;\n\n    // We must have an anonymous struct.\n    const TagDecl *TD = cast<TagDecl>(ND);\n    if (const TypedefNameDecl *D = TD->getTypedefNameForAnonDecl()) {\n      assert(TD->getDeclContext() == D->getDeclContext() &&\n             \"Typedef should not be in another decl context!\");\n      assert(D->getDeclName().getAsIdentifierInfo() &&\n             \"Typedef was not named!\");\n      mangleSourceName(D->getDeclName().getAsIdentifierInfo());\n      assert(!AdditionalAbiTags && \"Type cannot have additional abi tags\");\n      // Explicit abi tags are still possible; take from underlying type, not\n      // from typedef.\n      writeAbiTags(TD, nullptr);\n      break;\n    }\n\n    // <unnamed-type-name> ::= <closure-type-name>\n    //\n    // <closure-type-name> ::= Ul <lambda-sig> E [ <nonnegative number> ] _\n    // <lambda-sig> ::= <template-param-decl>* <parameter-type>+\n    //     # Parameter types or 'v' for 'void'.\n    if (const CXXRecordDecl *Record = dyn_cast<CXXRecordDecl>(TD)) {\n      if (Record->isLambda() && Record->getLambdaManglingNumber()) {\n        assert(!AdditionalAbiTags &&\n               \"Lambda type cannot have additional abi tags\");\n        mangleLambda(Record);\n        break;\n      }\n    }\n\n    if (TD->isExternallyVisible()) {\n      unsigned UnnamedMangle = getASTContext().getManglingNumber(TD);\n      Out << \"Ut\";\n      if (UnnamedMangle > 1)\n        Out << UnnamedMangle - 2;\n      Out << '_';\n      writeAbiTags(TD, AdditionalAbiTags);\n      break;\n    }\n\n    // Get a unique id for the anonymous struct. If it is not a real output\n    // ID doesn't matter so use fake one.\n    unsigned AnonStructId = NullOut ? 0 : Context.getAnonymousStructId(TD);\n\n    // Mangle it as a source name in the form\n    // [n] $_<id>\n    // where n is the length of the string.\n    SmallString<8> Str;\n    Str += \"$_\";\n    Str += llvm::utostr(AnonStructId);\n\n    Out << Str.size();\n    Out << Str;\n    break;\n  }\n\n  case DeclarationName::ObjCZeroArgSelector:\n  case DeclarationName::ObjCOneArgSelector:\n  case DeclarationName::ObjCMultiArgSelector:\n    llvm_unreachable(\"Can't mangle Objective-C selector names here!\");\n\n  case DeclarationName::CXXConstructorName: {\n    const CXXRecordDecl *InheritedFrom = nullptr;\n    TemplateName InheritedTemplateName;\n    const TemplateArgumentList *InheritedTemplateArgs = nullptr;\n    if (auto Inherited =\n            cast<CXXConstructorDecl>(ND)->getInheritedConstructor()) {\n      InheritedFrom = Inherited.getConstructor()->getParent();\n      InheritedTemplateName =\n          TemplateName(Inherited.getConstructor()->getPrimaryTemplate());\n      InheritedTemplateArgs =\n          Inherited.getConstructor()->getTemplateSpecializationArgs();\n    }\n\n    if (ND == Structor)\n      // If the named decl is the C++ constructor we're mangling, use the type\n      // we were given.\n      mangleCXXCtorType(static_cast<CXXCtorType>(StructorType), InheritedFrom);\n    else\n      // Otherwise, use the complete constructor name. This is relevant if a\n      // class with a constructor is declared within a constructor.\n      mangleCXXCtorType(Ctor_Complete, InheritedFrom);\n\n    // FIXME: The template arguments are part of the enclosing prefix or\n    // nested-name, but it's more convenient to mangle them here.\n    if (InheritedTemplateArgs)\n      mangleTemplateArgs(InheritedTemplateName, *InheritedTemplateArgs);\n\n    writeAbiTags(ND, AdditionalAbiTags);\n    break;\n  }\n\n  case DeclarationName::CXXDestructorName:\n    if (ND == Structor)\n      // If the named decl is the C++ destructor we're mangling, use the type we\n      // were given.\n      mangleCXXDtorType(static_cast<CXXDtorType>(StructorType));\n    else\n      // Otherwise, use the complete destructor name. This is relevant if a\n      // class with a destructor is declared within a destructor.\n      mangleCXXDtorType(Dtor_Complete);\n    writeAbiTags(ND, AdditionalAbiTags);\n    break;\n\n  case DeclarationName::CXXOperatorName:\n    if (ND && Arity == UnknownArity) {\n      Arity = cast<FunctionDecl>(ND)->getNumParams();\n\n      // If we have a member function, we need to include the 'this' pointer.\n      if (const auto *MD = dyn_cast<CXXMethodDecl>(ND))\n        if (!MD->isStatic())\n          Arity++;\n    }\n    LLVM_FALLTHROUGH;\n  case DeclarationName::CXXConversionFunctionName:\n  case DeclarationName::CXXLiteralOperatorName:\n    mangleOperatorName(Name, Arity);\n    writeAbiTags(ND, AdditionalAbiTags);\n    break;\n\n  case DeclarationName::CXXDeductionGuideName:\n    llvm_unreachable(\"Can't mangle a deduction guide name!\");\n\n  case DeclarationName::CXXUsingDirective:\n    llvm_unreachable(\"Can't mangle a using directive name!\");\n  }\n}\n\nvoid CXXNameMangler::mangleRegCallName(const IdentifierInfo *II) {\n  // <source-name> ::= <positive length number> __regcall3__ <identifier>\n  // <number> ::= [n] <non-negative decimal integer>\n  // <identifier> ::= <unqualified source code identifier>\n  Out << II->getLength() + sizeof(\"__regcall3__\") - 1 << \"__regcall3__\"\n      << II->getName();\n}\n\nvoid CXXNameMangler::mangleDeviceStubName(const IdentifierInfo *II) {\n  // <source-name> ::= <positive length number> __device_stub__ <identifier>\n  // <number> ::= [n] <non-negative decimal integer>\n  // <identifier> ::= <unqualified source code identifier>\n  Out << II->getLength() + sizeof(\"__device_stub__\") - 1 << \"__device_stub__\"\n      << II->getName();\n}\n\nvoid CXXNameMangler::mangleSourceName(const IdentifierInfo *II) {\n  // <source-name> ::= <positive length number> <identifier>\n  // <number> ::= [n] <non-negative decimal integer>\n  // <identifier> ::= <unqualified source code identifier>\n  Out << II->getLength() << II->getName();\n}\n\nvoid CXXNameMangler::mangleNestedName(GlobalDecl GD,\n                                      const DeclContext *DC,\n                                      const AbiTagList *AdditionalAbiTags,\n                                      bool NoFunction) {\n  const NamedDecl *ND = cast<NamedDecl>(GD.getDecl());\n  // <nested-name>\n  //   ::= N [<CV-qualifiers>] [<ref-qualifier>] <prefix> <unqualified-name> E\n  //   ::= N [<CV-qualifiers>] [<ref-qualifier>] <template-prefix>\n  //       <template-args> E\n\n  Out << 'N';\n  if (const CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(ND)) {\n    Qualifiers MethodQuals = Method->getMethodQualifiers();\n    // We do not consider restrict a distinguishing attribute for overloading\n    // purposes so we must not mangle it.\n    MethodQuals.removeRestrict();\n    mangleQualifiers(MethodQuals);\n    mangleRefQualifier(Method->getRefQualifier());\n  }\n\n  // Check if we have a template.\n  const TemplateArgumentList *TemplateArgs = nullptr;\n  if (GlobalDecl TD = isTemplate(GD, TemplateArgs)) {\n    mangleTemplatePrefix(TD, NoFunction);\n    mangleTemplateArgs(asTemplateName(TD), *TemplateArgs);\n  }\n  else {\n    manglePrefix(DC, NoFunction);\n    mangleUnqualifiedName(GD, AdditionalAbiTags);\n  }\n\n  Out << 'E';\n}\nvoid CXXNameMangler::mangleNestedName(const TemplateDecl *TD,\n                                      const TemplateArgument *TemplateArgs,\n                                      unsigned NumTemplateArgs) {\n  // <nested-name> ::= N [<CV-qualifiers>] <template-prefix> <template-args> E\n\n  Out << 'N';\n\n  mangleTemplatePrefix(TD);\n  mangleTemplateArgs(asTemplateName(TD), TemplateArgs, NumTemplateArgs);\n\n  Out << 'E';\n}\n\nstatic GlobalDecl getParentOfLocalEntity(const DeclContext *DC) {\n  GlobalDecl GD;\n  // The Itanium spec says:\n  // For entities in constructors and destructors, the mangling of the\n  // complete object constructor or destructor is used as the base function\n  // name, i.e. the C1 or D1 version.\n  if (auto *CD = dyn_cast<CXXConstructorDecl>(DC))\n    GD = GlobalDecl(CD, Ctor_Complete);\n  else if (auto *DD = dyn_cast<CXXDestructorDecl>(DC))\n    GD = GlobalDecl(DD, Dtor_Complete);\n  else\n    GD = GlobalDecl(cast<FunctionDecl>(DC));\n  return GD;\n}\n\nvoid CXXNameMangler::mangleLocalName(GlobalDecl GD,\n                                     const AbiTagList *AdditionalAbiTags) {\n  const Decl *D = GD.getDecl();\n  // <local-name> := Z <function encoding> E <entity name> [<discriminator>]\n  //              := Z <function encoding> E s [<discriminator>]\n  // <local-name> := Z <function encoding> E d [ <parameter number> ]\n  //                 _ <entity name>\n  // <discriminator> := _ <non-negative number>\n  assert(isa<NamedDecl>(D) || isa<BlockDecl>(D));\n  const RecordDecl *RD = GetLocalClassDecl(D);\n  const DeclContext *DC = getEffectiveDeclContext(RD ? RD : D);\n\n  Out << 'Z';\n\n  {\n    AbiTagState LocalAbiTags(AbiTags);\n\n    if (const ObjCMethodDecl *MD = dyn_cast<ObjCMethodDecl>(DC))\n      mangleObjCMethodName(MD);\n    else if (const BlockDecl *BD = dyn_cast<BlockDecl>(DC))\n      mangleBlockForPrefix(BD);\n    else\n      mangleFunctionEncoding(getParentOfLocalEntity(DC));\n\n    // Implicit ABI tags (from namespace) are not available in the following\n    // entity; reset to actually emitted tags, which are available.\n    LocalAbiTags.setUsedAbiTags(LocalAbiTags.getEmittedAbiTags());\n  }\n\n  Out << 'E';\n\n  // GCC 5.3.0 doesn't emit derived ABI tags for local names but that seems to\n  // be a bug that is fixed in trunk.\n\n  if (RD) {\n    // The parameter number is omitted for the last parameter, 0 for the\n    // second-to-last parameter, 1 for the third-to-last parameter, etc. The\n    // <entity name> will of course contain a <closure-type-name>: Its\n    // numbering will be local to the particular argument in which it appears\n    // -- other default arguments do not affect its encoding.\n    const CXXRecordDecl *CXXRD = dyn_cast<CXXRecordDecl>(RD);\n    if (CXXRD && CXXRD->isLambda()) {\n      if (const ParmVarDecl *Parm\n              = dyn_cast_or_null<ParmVarDecl>(CXXRD->getLambdaContextDecl())) {\n        if (const FunctionDecl *Func\n              = dyn_cast<FunctionDecl>(Parm->getDeclContext())) {\n          Out << 'd';\n          unsigned Num = Func->getNumParams() - Parm->getFunctionScopeIndex();\n          if (Num > 1)\n            mangleNumber(Num - 2);\n          Out << '_';\n        }\n      }\n    }\n\n    // Mangle the name relative to the closest enclosing function.\n    // equality ok because RD derived from ND above\n    if (D == RD)  {\n      mangleUnqualifiedName(RD, AdditionalAbiTags);\n    } else if (const BlockDecl *BD = dyn_cast<BlockDecl>(D)) {\n      manglePrefix(getEffectiveDeclContext(BD), true /*NoFunction*/);\n      assert(!AdditionalAbiTags && \"Block cannot have additional abi tags\");\n      mangleUnqualifiedBlock(BD);\n    } else {\n      const NamedDecl *ND = cast<NamedDecl>(D);\n      mangleNestedName(GD, getEffectiveDeclContext(ND), AdditionalAbiTags,\n                       true /*NoFunction*/);\n    }\n  } else if (const BlockDecl *BD = dyn_cast<BlockDecl>(D)) {\n    // Mangle a block in a default parameter; see above explanation for\n    // lambdas.\n    if (const ParmVarDecl *Parm\n            = dyn_cast_or_null<ParmVarDecl>(BD->getBlockManglingContextDecl())) {\n      if (const FunctionDecl *Func\n            = dyn_cast<FunctionDecl>(Parm->getDeclContext())) {\n        Out << 'd';\n        unsigned Num = Func->getNumParams() - Parm->getFunctionScopeIndex();\n        if (Num > 1)\n          mangleNumber(Num - 2);\n        Out << '_';\n      }\n    }\n\n    assert(!AdditionalAbiTags && \"Block cannot have additional abi tags\");\n    mangleUnqualifiedBlock(BD);\n  } else {\n    mangleUnqualifiedName(GD, AdditionalAbiTags);\n  }\n\n  if (const NamedDecl *ND = dyn_cast<NamedDecl>(RD ? RD : D)) {\n    unsigned disc;\n    if (Context.getNextDiscriminator(ND, disc)) {\n      if (disc < 10)\n        Out << '_' << disc;\n      else\n        Out << \"__\" << disc << '_';\n    }\n  }\n}\n\nvoid CXXNameMangler::mangleBlockForPrefix(const BlockDecl *Block) {\n  if (GetLocalClassDecl(Block)) {\n    mangleLocalName(Block, /* AdditionalAbiTags */ nullptr);\n    return;\n  }\n  const DeclContext *DC = getEffectiveDeclContext(Block);\n  if (isLocalContainerContext(DC)) {\n    mangleLocalName(Block, /* AdditionalAbiTags */ nullptr);\n    return;\n  }\n  manglePrefix(getEffectiveDeclContext(Block));\n  mangleUnqualifiedBlock(Block);\n}\n\nvoid CXXNameMangler::mangleUnqualifiedBlock(const BlockDecl *Block) {\n  if (Decl *Context = Block->getBlockManglingContextDecl()) {\n    if ((isa<VarDecl>(Context) || isa<FieldDecl>(Context)) &&\n        Context->getDeclContext()->isRecord()) {\n      const auto *ND = cast<NamedDecl>(Context);\n      if (ND->getIdentifier()) {\n        mangleSourceNameWithAbiTags(ND);\n        Out << 'M';\n      }\n    }\n  }\n\n  // If we have a block mangling number, use it.\n  unsigned Number = Block->getBlockManglingNumber();\n  // Otherwise, just make up a number. It doesn't matter what it is because\n  // the symbol in question isn't externally visible.\n  if (!Number)\n    Number = Context.getBlockId(Block, false);\n  else {\n    // Stored mangling numbers are 1-based.\n    --Number;\n  }\n  Out << \"Ub\";\n  if (Number > 0)\n    Out << Number - 1;\n  Out << '_';\n}\n\n// <template-param-decl>\n//   ::= Ty                              # template type parameter\n//   ::= Tn <type>                       # template non-type parameter\n//   ::= Tt <template-param-decl>* E     # template template parameter\n//   ::= Tp <template-param-decl>        # template parameter pack\nvoid CXXNameMangler::mangleTemplateParamDecl(const NamedDecl *Decl) {\n  if (auto *Ty = dyn_cast<TemplateTypeParmDecl>(Decl)) {\n    if (Ty->isParameterPack())\n      Out << \"Tp\";\n    Out << \"Ty\";\n  } else if (auto *Tn = dyn_cast<NonTypeTemplateParmDecl>(Decl)) {\n    if (Tn->isExpandedParameterPack()) {\n      for (unsigned I = 0, N = Tn->getNumExpansionTypes(); I != N; ++I) {\n        Out << \"Tn\";\n        mangleType(Tn->getExpansionType(I));\n      }\n    } else {\n      QualType T = Tn->getType();\n      if (Tn->isParameterPack()) {\n        Out << \"Tp\";\n        if (auto *PackExpansion = T->getAs<PackExpansionType>())\n          T = PackExpansion->getPattern();\n      }\n      Out << \"Tn\";\n      mangleType(T);\n    }\n  } else if (auto *Tt = dyn_cast<TemplateTemplateParmDecl>(Decl)) {\n    if (Tt->isExpandedParameterPack()) {\n      for (unsigned I = 0, N = Tt->getNumExpansionTemplateParameters(); I != N;\n           ++I) {\n        Out << \"Tt\";\n        for (auto *Param : *Tt->getExpansionTemplateParameters(I))\n          mangleTemplateParamDecl(Param);\n        Out << \"E\";\n      }\n    } else {\n      if (Tt->isParameterPack())\n        Out << \"Tp\";\n      Out << \"Tt\";\n      for (auto *Param : *Tt->getTemplateParameters())\n        mangleTemplateParamDecl(Param);\n      Out << \"E\";\n    }\n  }\n}\n\nvoid CXXNameMangler::mangleLambda(const CXXRecordDecl *Lambda) {\n  // If the context of a closure type is an initializer for a class member\n  // (static or nonstatic), it is encoded in a qualified name with a final\n  // <prefix> of the form:\n  //\n  //   <data-member-prefix> := <member source-name> M\n  //\n  // Technically, the data-member-prefix is part of the <prefix>. However,\n  // since a closure type will always be mangled with a prefix, it's easier\n  // to emit that last part of the prefix here.\n  if (Decl *Context = Lambda->getLambdaContextDecl()) {\n    if ((isa<VarDecl>(Context) || isa<FieldDecl>(Context)) &&\n        !isa<ParmVarDecl>(Context)) {\n      // FIXME: 'inline auto [a, b] = []{ return ... };' does not get a\n      // reasonable mangling here.\n      if (const IdentifierInfo *Name\n            = cast<NamedDecl>(Context)->getIdentifier()) {\n        mangleSourceName(Name);\n        const TemplateArgumentList *TemplateArgs = nullptr;\n        if (GlobalDecl TD = isTemplate(cast<NamedDecl>(Context), TemplateArgs))\n          mangleTemplateArgs(asTemplateName(TD), *TemplateArgs);\n        Out << 'M';\n      }\n    }\n  }\n\n  Out << \"Ul\";\n  mangleLambdaSig(Lambda);\n  Out << \"E\";\n\n  // The number is omitted for the first closure type with a given\n  // <lambda-sig> in a given context; it is n-2 for the nth closure type\n  // (in lexical order) with that same <lambda-sig> and context.\n  //\n  // The AST keeps track of the number for us.\n  //\n  // In CUDA/HIP, to ensure the consistent lamba numbering between the device-\n  // and host-side compilations, an extra device mangle context may be created\n  // if the host-side CXX ABI has different numbering for lambda. In such case,\n  // if the mangle context is that device-side one, use the device-side lambda\n  // mangling number for this lambda.\n  unsigned Number = Context.isDeviceMangleContext()\n                        ? Lambda->getDeviceLambdaManglingNumber()\n                        : Lambda->getLambdaManglingNumber();\n  assert(Number > 0 && \"Lambda should be mangled as an unnamed class\");\n  if (Number > 1)\n    mangleNumber(Number - 2);\n  Out << '_';\n}\n\nvoid CXXNameMangler::mangleLambdaSig(const CXXRecordDecl *Lambda) {\n  for (auto *D : Lambda->getLambdaExplicitTemplateParameters())\n    mangleTemplateParamDecl(D);\n  auto *Proto =\n      Lambda->getLambdaTypeInfo()->getType()->castAs<FunctionProtoType>();\n  mangleBareFunctionType(Proto, /*MangleReturnType=*/false,\n                         Lambda->getLambdaStaticInvoker());\n}\n\nvoid CXXNameMangler::manglePrefix(NestedNameSpecifier *qualifier) {\n  switch (qualifier->getKind()) {\n  case NestedNameSpecifier::Global:\n    // nothing\n    return;\n\n  case NestedNameSpecifier::Super:\n    llvm_unreachable(\"Can't mangle __super specifier\");\n\n  case NestedNameSpecifier::Namespace:\n    mangleName(qualifier->getAsNamespace());\n    return;\n\n  case NestedNameSpecifier::NamespaceAlias:\n    mangleName(qualifier->getAsNamespaceAlias()->getNamespace());\n    return;\n\n  case NestedNameSpecifier::TypeSpec:\n  case NestedNameSpecifier::TypeSpecWithTemplate:\n    manglePrefix(QualType(qualifier->getAsType(), 0));\n    return;\n\n  case NestedNameSpecifier::Identifier:\n    // Member expressions can have these without prefixes, but that\n    // should end up in mangleUnresolvedPrefix instead.\n    assert(qualifier->getPrefix());\n    manglePrefix(qualifier->getPrefix());\n\n    mangleSourceName(qualifier->getAsIdentifier());\n    return;\n  }\n\n  llvm_unreachable(\"unexpected nested name specifier\");\n}\n\nvoid CXXNameMangler::manglePrefix(const DeclContext *DC, bool NoFunction) {\n  //  <prefix> ::= <prefix> <unqualified-name>\n  //           ::= <template-prefix> <template-args>\n  //           ::= <template-param>\n  //           ::= # empty\n  //           ::= <substitution>\n\n  DC = IgnoreLinkageSpecDecls(DC);\n\n  if (DC->isTranslationUnit())\n    return;\n\n  if (NoFunction && isLocalContainerContext(DC))\n    return;\n\n  assert(!isLocalContainerContext(DC));\n\n  const NamedDecl *ND = cast<NamedDecl>(DC);\n  if (mangleSubstitution(ND))\n    return;\n\n  // Check if we have a template.\n  const TemplateArgumentList *TemplateArgs = nullptr;\n  if (GlobalDecl TD = isTemplate(ND, TemplateArgs)) {\n    mangleTemplatePrefix(TD);\n    mangleTemplateArgs(asTemplateName(TD), *TemplateArgs);\n  } else {\n    manglePrefix(getEffectiveDeclContext(ND), NoFunction);\n    mangleUnqualifiedName(ND, nullptr);\n  }\n\n  addSubstitution(ND);\n}\n\nvoid CXXNameMangler::mangleTemplatePrefix(TemplateName Template) {\n  // <template-prefix> ::= <prefix> <template unqualified-name>\n  //                   ::= <template-param>\n  //                   ::= <substitution>\n  if (TemplateDecl *TD = Template.getAsTemplateDecl())\n    return mangleTemplatePrefix(TD);\n\n  DependentTemplateName *Dependent = Template.getAsDependentTemplateName();\n  assert(Dependent && \"unexpected template name kind\");\n\n  // Clang 11 and before mangled the substitution for a dependent template name\n  // after already having emitted (a substitution for) the prefix.\n  bool Clang11Compat = getASTContext().getLangOpts().getClangABICompat() <=\n                       LangOptions::ClangABI::Ver11;\n  if (!Clang11Compat && mangleSubstitution(Template))\n    return;\n\n  if (NestedNameSpecifier *Qualifier = Dependent->getQualifier())\n    manglePrefix(Qualifier);\n\n  if (Clang11Compat && mangleSubstitution(Template))\n    return;\n\n  if (const IdentifierInfo *Id = Dependent->getIdentifier())\n    mangleSourceName(Id);\n  else\n    mangleOperatorName(Dependent->getOperator(), UnknownArity);\n\n  addSubstitution(Template);\n}\n\nvoid CXXNameMangler::mangleTemplatePrefix(GlobalDecl GD,\n                                          bool NoFunction) {\n  const TemplateDecl *ND = cast<TemplateDecl>(GD.getDecl());\n  // <template-prefix> ::= <prefix> <template unqualified-name>\n  //                   ::= <template-param>\n  //                   ::= <substitution>\n  // <template-template-param> ::= <template-param>\n  //                               <substitution>\n\n  if (mangleSubstitution(ND))\n    return;\n\n  // <template-template-param> ::= <template-param>\n  if (const auto *TTP = dyn_cast<TemplateTemplateParmDecl>(ND)) {\n    mangleTemplateParameter(TTP->getDepth(), TTP->getIndex());\n  } else {\n    manglePrefix(getEffectiveDeclContext(ND), NoFunction);\n    if (isa<BuiltinTemplateDecl>(ND) || isa<ConceptDecl>(ND))\n      mangleUnqualifiedName(GD, nullptr);\n    else\n      mangleUnqualifiedName(GD.getWithDecl(ND->getTemplatedDecl()), nullptr);\n  }\n\n  addSubstitution(ND);\n}\n\n/// Mangles a template name under the production <type>.  Required for\n/// template template arguments.\n///   <type> ::= <class-enum-type>\n///          ::= <template-param>\n///          ::= <substitution>\nvoid CXXNameMangler::mangleType(TemplateName TN) {\n  if (mangleSubstitution(TN))\n    return;\n\n  TemplateDecl *TD = nullptr;\n\n  switch (TN.getKind()) {\n  case TemplateName::QualifiedTemplate:\n    TD = TN.getAsQualifiedTemplateName()->getTemplateDecl();\n    goto HaveDecl;\n\n  case TemplateName::Template:\n    TD = TN.getAsTemplateDecl();\n    goto HaveDecl;\n\n  HaveDecl:\n    if (auto *TTP = dyn_cast<TemplateTemplateParmDecl>(TD))\n      mangleTemplateParameter(TTP->getDepth(), TTP->getIndex());\n    else\n      mangleName(TD);\n    break;\n\n  case TemplateName::OverloadedTemplate:\n  case TemplateName::AssumedTemplate:\n    llvm_unreachable(\"can't mangle an overloaded template name as a <type>\");\n\n  case TemplateName::DependentTemplate: {\n    const DependentTemplateName *Dependent = TN.getAsDependentTemplateName();\n    assert(Dependent->isIdentifier());\n\n    // <class-enum-type> ::= <name>\n    // <name> ::= <nested-name>\n    mangleUnresolvedPrefix(Dependent->getQualifier());\n    mangleSourceName(Dependent->getIdentifier());\n    break;\n  }\n\n  case TemplateName::SubstTemplateTemplateParm: {\n    // Substituted template parameters are mangled as the substituted\n    // template.  This will check for the substitution twice, which is\n    // fine, but we have to return early so that we don't try to *add*\n    // the substitution twice.\n    SubstTemplateTemplateParmStorage *subst\n      = TN.getAsSubstTemplateTemplateParm();\n    mangleType(subst->getReplacement());\n    return;\n  }\n\n  case TemplateName::SubstTemplateTemplateParmPack: {\n    // FIXME: not clear how to mangle this!\n    // template <template <class> class T...> class A {\n    //   template <template <class> class U...> void foo(B<T,U> x...);\n    // };\n    Out << \"_SUBSTPACK_\";\n    break;\n  }\n  }\n\n  addSubstitution(TN);\n}\n\nbool CXXNameMangler::mangleUnresolvedTypeOrSimpleId(QualType Ty,\n                                                    StringRef Prefix) {\n  // Only certain other types are valid as prefixes;  enumerate them.\n  switch (Ty->getTypeClass()) {\n  case Type::Builtin:\n  case Type::Complex:\n  case Type::Adjusted:\n  case Type::Decayed:\n  case Type::Pointer:\n  case Type::BlockPointer:\n  case Type::LValueReference:\n  case Type::RValueReference:\n  case Type::MemberPointer:\n  case Type::ConstantArray:\n  case Type::IncompleteArray:\n  case Type::VariableArray:\n  case Type::DependentSizedArray:\n  case Type::DependentAddressSpace:\n  case Type::DependentVector:\n  case Type::DependentSizedExtVector:\n  case Type::Vector:\n  case Type::ExtVector:\n  case Type::ConstantMatrix:\n  case Type::DependentSizedMatrix:\n  case Type::FunctionProto:\n  case Type::FunctionNoProto:\n  case Type::Paren:\n  case Type::Attributed:\n  case Type::Auto:\n  case Type::DeducedTemplateSpecialization:\n  case Type::PackExpansion:\n  case Type::ObjCObject:\n  case Type::ObjCInterface:\n  case Type::ObjCObjectPointer:\n  case Type::ObjCTypeParam:\n  case Type::Atomic:\n  case Type::Pipe:\n  case Type::MacroQualified:\n  case Type::ExtInt:\n  case Type::DependentExtInt:\n    llvm_unreachable(\"type is illegal as a nested name specifier\");\n\n  case Type::SubstTemplateTypeParmPack:\n    // FIXME: not clear how to mangle this!\n    // template <class T...> class A {\n    //   template <class U...> void foo(decltype(T::foo(U())) x...);\n    // };\n    Out << \"_SUBSTPACK_\";\n    break;\n\n  // <unresolved-type> ::= <template-param>\n  //                   ::= <decltype>\n  //                   ::= <template-template-param> <template-args>\n  // (this last is not official yet)\n  case Type::TypeOfExpr:\n  case Type::TypeOf:\n  case Type::Decltype:\n  case Type::TemplateTypeParm:\n  case Type::UnaryTransform:\n  case Type::SubstTemplateTypeParm:\n  unresolvedType:\n    // Some callers want a prefix before the mangled type.\n    Out << Prefix;\n\n    // This seems to do everything we want.  It's not really\n    // sanctioned for a substituted template parameter, though.\n    mangleType(Ty);\n\n    // We never want to print 'E' directly after an unresolved-type,\n    // so we return directly.\n    return true;\n\n  case Type::Typedef:\n    mangleSourceNameWithAbiTags(cast<TypedefType>(Ty)->getDecl());\n    break;\n\n  case Type::UnresolvedUsing:\n    mangleSourceNameWithAbiTags(\n        cast<UnresolvedUsingType>(Ty)->getDecl());\n    break;\n\n  case Type::Enum:\n  case Type::Record:\n    mangleSourceNameWithAbiTags(cast<TagType>(Ty)->getDecl());\n    break;\n\n  case Type::TemplateSpecialization: {\n    const TemplateSpecializationType *TST =\n        cast<TemplateSpecializationType>(Ty);\n    TemplateName TN = TST->getTemplateName();\n    switch (TN.getKind()) {\n    case TemplateName::Template:\n    case TemplateName::QualifiedTemplate: {\n      TemplateDecl *TD = TN.getAsTemplateDecl();\n\n      // If the base is a template template parameter, this is an\n      // unresolved type.\n      assert(TD && \"no template for template specialization type\");\n      if (isa<TemplateTemplateParmDecl>(TD))\n        goto unresolvedType;\n\n      mangleSourceNameWithAbiTags(TD);\n      break;\n    }\n\n    case TemplateName::OverloadedTemplate:\n    case TemplateName::AssumedTemplate:\n    case TemplateName::DependentTemplate:\n      llvm_unreachable(\"invalid base for a template specialization type\");\n\n    case TemplateName::SubstTemplateTemplateParm: {\n      SubstTemplateTemplateParmStorage *subst =\n          TN.getAsSubstTemplateTemplateParm();\n      mangleExistingSubstitution(subst->getReplacement());\n      break;\n    }\n\n    case TemplateName::SubstTemplateTemplateParmPack: {\n      // FIXME: not clear how to mangle this!\n      // template <template <class U> class T...> class A {\n      //   template <class U...> void foo(decltype(T<U>::foo) x...);\n      // };\n      Out << \"_SUBSTPACK_\";\n      break;\n    }\n    }\n\n    // Note: we don't pass in the template name here. We are mangling the\n    // original source-level template arguments, so we shouldn't consider\n    // conversions to the corresponding template parameter.\n    // FIXME: Other compilers mangle partially-resolved template arguments in\n    // unresolved-qualifier-levels.\n    mangleTemplateArgs(TemplateName(), TST->getArgs(), TST->getNumArgs());\n    break;\n  }\n\n  case Type::InjectedClassName:\n    mangleSourceNameWithAbiTags(\n        cast<InjectedClassNameType>(Ty)->getDecl());\n    break;\n\n  case Type::DependentName:\n    mangleSourceName(cast<DependentNameType>(Ty)->getIdentifier());\n    break;\n\n  case Type::DependentTemplateSpecialization: {\n    const DependentTemplateSpecializationType *DTST =\n        cast<DependentTemplateSpecializationType>(Ty);\n    TemplateName Template = getASTContext().getDependentTemplateName(\n        DTST->getQualifier(), DTST->getIdentifier());\n    mangleSourceName(DTST->getIdentifier());\n    mangleTemplateArgs(Template, DTST->getArgs(), DTST->getNumArgs());\n    break;\n  }\n\n  case Type::Elaborated:\n    return mangleUnresolvedTypeOrSimpleId(\n        cast<ElaboratedType>(Ty)->getNamedType(), Prefix);\n  }\n\n  return false;\n}\n\nvoid CXXNameMangler::mangleOperatorName(DeclarationName Name, unsigned Arity) {\n  switch (Name.getNameKind()) {\n  case DeclarationName::CXXConstructorName:\n  case DeclarationName::CXXDestructorName:\n  case DeclarationName::CXXDeductionGuideName:\n  case DeclarationName::CXXUsingDirective:\n  case DeclarationName::Identifier:\n  case DeclarationName::ObjCMultiArgSelector:\n  case DeclarationName::ObjCOneArgSelector:\n  case DeclarationName::ObjCZeroArgSelector:\n    llvm_unreachable(\"Not an operator name\");\n\n  case DeclarationName::CXXConversionFunctionName:\n    // <operator-name> ::= cv <type>    # (cast)\n    Out << \"cv\";\n    mangleType(Name.getCXXNameType());\n    break;\n\n  case DeclarationName::CXXLiteralOperatorName:\n    Out << \"li\";\n    mangleSourceName(Name.getCXXLiteralIdentifier());\n    return;\n\n  case DeclarationName::CXXOperatorName:\n    mangleOperatorName(Name.getCXXOverloadedOperator(), Arity);\n    break;\n  }\n}\n\nvoid\nCXXNameMangler::mangleOperatorName(OverloadedOperatorKind OO, unsigned Arity) {\n  switch (OO) {\n  // <operator-name> ::= nw     # new\n  case OO_New: Out << \"nw\"; break;\n  //              ::= na        # new[]\n  case OO_Array_New: Out << \"na\"; break;\n  //              ::= dl        # delete\n  case OO_Delete: Out << \"dl\"; break;\n  //              ::= da        # delete[]\n  case OO_Array_Delete: Out << \"da\"; break;\n  //              ::= ps        # + (unary)\n  //              ::= pl        # + (binary or unknown)\n  case OO_Plus:\n    Out << (Arity == 1? \"ps\" : \"pl\"); break;\n  //              ::= ng        # - (unary)\n  //              ::= mi        # - (binary or unknown)\n  case OO_Minus:\n    Out << (Arity == 1? \"ng\" : \"mi\"); break;\n  //              ::= ad        # & (unary)\n  //              ::= an        # & (binary or unknown)\n  case OO_Amp:\n    Out << (Arity == 1? \"ad\" : \"an\"); break;\n  //              ::= de        # * (unary)\n  //              ::= ml        # * (binary or unknown)\n  case OO_Star:\n    // Use binary when unknown.\n    Out << (Arity == 1? \"de\" : \"ml\"); break;\n  //              ::= co        # ~\n  case OO_Tilde: Out << \"co\"; break;\n  //              ::= dv        # /\n  case OO_Slash: Out << \"dv\"; break;\n  //              ::= rm        # %\n  case OO_Percent: Out << \"rm\"; break;\n  //              ::= or        # |\n  case OO_Pipe: Out << \"or\"; break;\n  //              ::= eo        # ^\n  case OO_Caret: Out << \"eo\"; break;\n  //              ::= aS        # =\n  case OO_Equal: Out << \"aS\"; break;\n  //              ::= pL        # +=\n  case OO_PlusEqual: Out << \"pL\"; break;\n  //              ::= mI        # -=\n  case OO_MinusEqual: Out << \"mI\"; break;\n  //              ::= mL        # *=\n  case OO_StarEqual: Out << \"mL\"; break;\n  //              ::= dV        # /=\n  case OO_SlashEqual: Out << \"dV\"; break;\n  //              ::= rM        # %=\n  case OO_PercentEqual: Out << \"rM\"; break;\n  //              ::= aN        # &=\n  case OO_AmpEqual: Out << \"aN\"; break;\n  //              ::= oR        # |=\n  case OO_PipeEqual: Out << \"oR\"; break;\n  //              ::= eO        # ^=\n  case OO_CaretEqual: Out << \"eO\"; break;\n  //              ::= ls        # <<\n  case OO_LessLess: Out << \"ls\"; break;\n  //              ::= rs        # >>\n  case OO_GreaterGreater: Out << \"rs\"; break;\n  //              ::= lS        # <<=\n  case OO_LessLessEqual: Out << \"lS\"; break;\n  //              ::= rS        # >>=\n  case OO_GreaterGreaterEqual: Out << \"rS\"; break;\n  //              ::= eq        # ==\n  case OO_EqualEqual: Out << \"eq\"; break;\n  //              ::= ne        # !=\n  case OO_ExclaimEqual: Out << \"ne\"; break;\n  //              ::= lt        # <\n  case OO_Less: Out << \"lt\"; break;\n  //              ::= gt        # >\n  case OO_Greater: Out << \"gt\"; break;\n  //              ::= le        # <=\n  case OO_LessEqual: Out << \"le\"; break;\n  //              ::= ge        # >=\n  case OO_GreaterEqual: Out << \"ge\"; break;\n  //              ::= nt        # !\n  case OO_Exclaim: Out << \"nt\"; break;\n  //              ::= aa        # &&\n  case OO_AmpAmp: Out << \"aa\"; break;\n  //              ::= oo        # ||\n  case OO_PipePipe: Out << \"oo\"; break;\n  //              ::= pp        # ++\n  case OO_PlusPlus: Out << \"pp\"; break;\n  //              ::= mm        # --\n  case OO_MinusMinus: Out << \"mm\"; break;\n  //              ::= cm        # ,\n  case OO_Comma: Out << \"cm\"; break;\n  //              ::= pm        # ->*\n  case OO_ArrowStar: Out << \"pm\"; break;\n  //              ::= pt        # ->\n  case OO_Arrow: Out << \"pt\"; break;\n  //              ::= cl        # ()\n  case OO_Call: Out << \"cl\"; break;\n  //              ::= ix        # []\n  case OO_Subscript: Out << \"ix\"; break;\n\n  //              ::= qu        # ?\n  // The conditional operator can't be overloaded, but we still handle it when\n  // mangling expressions.\n  case OO_Conditional: Out << \"qu\"; break;\n  // Proposal on cxx-abi-dev, 2015-10-21.\n  //              ::= aw        # co_await\n  case OO_Coawait: Out << \"aw\"; break;\n  // Proposed in cxx-abi github issue 43.\n  //              ::= ss        # <=>\n  case OO_Spaceship: Out << \"ss\"; break;\n\n  case OO_None:\n  case NUM_OVERLOADED_OPERATORS:\n    llvm_unreachable(\"Not an overloaded operator\");\n  }\n}\n\nvoid CXXNameMangler::mangleQualifiers(Qualifiers Quals, const DependentAddressSpaceType *DAST) {\n  // Vendor qualifiers come first and if they are order-insensitive they must\n  // be emitted in reversed alphabetical order, see Itanium ABI 5.1.5.\n\n  // <type> ::= U <addrspace-expr>\n  if (DAST) {\n    Out << \"U2ASI\";\n    mangleExpression(DAST->getAddrSpaceExpr());\n    Out << \"E\";\n  }\n\n  // Address space qualifiers start with an ordinary letter.\n  if (Quals.hasAddressSpace()) {\n    // Address space extension:\n    //\n    //   <type> ::= U <target-addrspace>\n    //   <type> ::= U <OpenCL-addrspace>\n    //   <type> ::= U <CUDA-addrspace>\n\n    SmallString<64> ASString;\n    LangAS AS = Quals.getAddressSpace();\n\n    if (Context.getASTContext().addressSpaceMapManglingFor(AS)) {\n      //  <target-addrspace> ::= \"AS\" <address-space-number>\n      unsigned TargetAS = Context.getASTContext().getTargetAddressSpace(AS);\n      if (TargetAS != 0)\n        ASString = \"AS\" + llvm::utostr(TargetAS);\n    } else {\n      switch (AS) {\n      default: llvm_unreachable(\"Not a language specific address space\");\n      //  <OpenCL-addrspace> ::= \"CL\" [ \"global\" | \"local\" | \"constant\" |\n      //                                \"private\"| \"generic\" | \"device\" |\n      //                                \"host\" ]\n      case LangAS::opencl_global:\n        ASString = \"CLglobal\";\n        break;\n      case LangAS::opencl_global_device:\n        ASString = \"CLdevice\";\n        break;\n      case LangAS::opencl_global_host:\n        ASString = \"CLhost\";\n        break;\n      case LangAS::opencl_local:\n        ASString = \"CLlocal\";\n        break;\n      case LangAS::opencl_constant:\n        ASString = \"CLconstant\";\n        break;\n      case LangAS::opencl_private:\n        ASString = \"CLprivate\";\n        break;\n      case LangAS::opencl_generic:\n        ASString = \"CLgeneric\";\n        break;\n      //  <CUDA-addrspace> ::= \"CU\" [ \"device\" | \"constant\" | \"shared\" ]\n      case LangAS::cuda_device:\n        ASString = \"CUdevice\";\n        break;\n      case LangAS::cuda_constant:\n        ASString = \"CUconstant\";\n        break;\n      case LangAS::cuda_shared:\n        ASString = \"CUshared\";\n        break;\n      //  <ptrsize-addrspace> ::= [ \"ptr32_sptr\" | \"ptr32_uptr\" | \"ptr64\" ]\n      case LangAS::ptr32_sptr:\n        ASString = \"ptr32_sptr\";\n        break;\n      case LangAS::ptr32_uptr:\n        ASString = \"ptr32_uptr\";\n        break;\n      case LangAS::ptr64:\n        ASString = \"ptr64\";\n        break;\n      }\n    }\n    if (!ASString.empty())\n      mangleVendorQualifier(ASString);\n  }\n\n  // The ARC ownership qualifiers start with underscores.\n  // Objective-C ARC Extension:\n  //\n  //   <type> ::= U \"__strong\"\n  //   <type> ::= U \"__weak\"\n  //   <type> ::= U \"__autoreleasing\"\n  //\n  // Note: we emit __weak first to preserve the order as\n  // required by the Itanium ABI.\n  if (Quals.getObjCLifetime() == Qualifiers::OCL_Weak)\n    mangleVendorQualifier(\"__weak\");\n\n  // __unaligned (from -fms-extensions)\n  if (Quals.hasUnaligned())\n    mangleVendorQualifier(\"__unaligned\");\n\n  // Remaining ARC ownership qualifiers.\n  switch (Quals.getObjCLifetime()) {\n  case Qualifiers::OCL_None:\n    break;\n\n  case Qualifiers::OCL_Weak:\n    // Do nothing as we already handled this case above.\n    break;\n\n  case Qualifiers::OCL_Strong:\n    mangleVendorQualifier(\"__strong\");\n    break;\n\n  case Qualifiers::OCL_Autoreleasing:\n    mangleVendorQualifier(\"__autoreleasing\");\n    break;\n\n  case Qualifiers::OCL_ExplicitNone:\n    // The __unsafe_unretained qualifier is *not* mangled, so that\n    // __unsafe_unretained types in ARC produce the same manglings as the\n    // equivalent (but, naturally, unqualified) types in non-ARC, providing\n    // better ABI compatibility.\n    //\n    // It's safe to do this because unqualified 'id' won't show up\n    // in any type signatures that need to be mangled.\n    break;\n  }\n\n  // <CV-qualifiers> ::= [r] [V] [K]    # restrict (C99), volatile, const\n  if (Quals.hasRestrict())\n    Out << 'r';\n  if (Quals.hasVolatile())\n    Out << 'V';\n  if (Quals.hasConst())\n    Out << 'K';\n}\n\nvoid CXXNameMangler::mangleVendorQualifier(StringRef name) {\n  Out << 'U' << name.size() << name;\n}\n\nvoid CXXNameMangler::mangleRefQualifier(RefQualifierKind RefQualifier) {\n  // <ref-qualifier> ::= R                # lvalue reference\n  //                 ::= O                # rvalue-reference\n  switch (RefQualifier) {\n  case RQ_None:\n    break;\n\n  case RQ_LValue:\n    Out << 'R';\n    break;\n\n  case RQ_RValue:\n    Out << 'O';\n    break;\n  }\n}\n\nvoid CXXNameMangler::mangleObjCMethodName(const ObjCMethodDecl *MD) {\n  Context.mangleObjCMethodNameAsSourceName(MD, Out);\n}\n\nstatic bool isTypeSubstitutable(Qualifiers Quals, const Type *Ty,\n                                ASTContext &Ctx) {\n  if (Quals)\n    return true;\n  if (Ty->isSpecificBuiltinType(BuiltinType::ObjCSel))\n    return true;\n  if (Ty->isOpenCLSpecificType())\n    return true;\n  if (Ty->isBuiltinType())\n    return false;\n  // Through to Clang 6.0, we accidentally treated undeduced auto types as\n  // substitution candidates.\n  if (Ctx.getLangOpts().getClangABICompat() > LangOptions::ClangABI::Ver6 &&\n      isa<AutoType>(Ty))\n    return false;\n  // A placeholder type for class template deduction is substitutable with\n  // its corresponding template name; this is handled specially when mangling\n  // the type.\n  if (auto *DeducedTST = Ty->getAs<DeducedTemplateSpecializationType>())\n    if (DeducedTST->getDeducedType().isNull())\n      return false;\n  return true;\n}\n\nvoid CXXNameMangler::mangleType(QualType T) {\n  // If our type is instantiation-dependent but not dependent, we mangle\n  // it as it was written in the source, removing any top-level sugar.\n  // Otherwise, use the canonical type.\n  //\n  // FIXME: This is an approximation of the instantiation-dependent name\n  // mangling rules, since we should really be using the type as written and\n  // augmented via semantic analysis (i.e., with implicit conversions and\n  // default template arguments) for any instantiation-dependent type.\n  // Unfortunately, that requires several changes to our AST:\n  //   - Instantiation-dependent TemplateSpecializationTypes will need to be\n  //     uniqued, so that we can handle substitutions properly\n  //   - Default template arguments will need to be represented in the\n  //     TemplateSpecializationType, since they need to be mangled even though\n  //     they aren't written.\n  //   - Conversions on non-type template arguments need to be expressed, since\n  //     they can affect the mangling of sizeof/alignof.\n  //\n  // FIXME: This is wrong when mapping to the canonical type for a dependent\n  // type discards instantiation-dependent portions of the type, such as for:\n  //\n  //   template<typename T, int N> void f(T (&)[sizeof(N)]);\n  //   template<typename T> void f(T() throw(typename T::type)); (pre-C++17)\n  //\n  // It's also wrong in the opposite direction when instantiation-dependent,\n  // canonically-equivalent types differ in some irrelevant portion of inner\n  // type sugar. In such cases, we fail to form correct substitutions, eg:\n  //\n  //   template<int N> void f(A<sizeof(N)> *, A<sizeof(N)> (*));\n  //\n  // We should instead canonicalize the non-instantiation-dependent parts,\n  // regardless of whether the type as a whole is dependent or instantiation\n  // dependent.\n  if (!T->isInstantiationDependentType() || T->isDependentType())\n    T = T.getCanonicalType();\n  else {\n    // Desugar any types that are purely sugar.\n    do {\n      // Don't desugar through template specialization types that aren't\n      // type aliases. We need to mangle the template arguments as written.\n      if (const TemplateSpecializationType *TST\n                                      = dyn_cast<TemplateSpecializationType>(T))\n        if (!TST->isTypeAlias())\n          break;\n\n      // FIXME: We presumably shouldn't strip off ElaboratedTypes with\n      // instantation-dependent qualifiers. See\n      // https://github.com/itanium-cxx-abi/cxx-abi/issues/114.\n\n      QualType Desugared\n        = T.getSingleStepDesugaredType(Context.getASTContext());\n      if (Desugared == T)\n        break;\n\n      T = Desugared;\n    } while (true);\n  }\n  SplitQualType split = T.split();\n  Qualifiers quals = split.Quals;\n  const Type *ty = split.Ty;\n\n  bool isSubstitutable =\n    isTypeSubstitutable(quals, ty, Context.getASTContext());\n  if (isSubstitutable && mangleSubstitution(T))\n    return;\n\n  // If we're mangling a qualified array type, push the qualifiers to\n  // the element type.\n  if (quals && isa<ArrayType>(T)) {\n    ty = Context.getASTContext().getAsArrayType(T);\n    quals = Qualifiers();\n\n    // Note that we don't update T: we want to add the\n    // substitution at the original type.\n  }\n\n  if (quals || ty->isDependentAddressSpaceType()) {\n    if (const DependentAddressSpaceType *DAST =\n        dyn_cast<DependentAddressSpaceType>(ty)) {\n      SplitQualType splitDAST = DAST->getPointeeType().split();\n      mangleQualifiers(splitDAST.Quals, DAST);\n      mangleType(QualType(splitDAST.Ty, 0));\n    } else {\n      mangleQualifiers(quals);\n\n      // Recurse:  even if the qualified type isn't yet substitutable,\n      // the unqualified type might be.\n      mangleType(QualType(ty, 0));\n    }\n  } else {\n    switch (ty->getTypeClass()) {\n#define ABSTRACT_TYPE(CLASS, PARENT)\n#define NON_CANONICAL_TYPE(CLASS, PARENT) \\\n    case Type::CLASS: \\\n      llvm_unreachable(\"can't mangle non-canonical type \" #CLASS \"Type\"); \\\n      return;\n#define TYPE(CLASS, PARENT) \\\n    case Type::CLASS: \\\n      mangleType(static_cast<const CLASS##Type*>(ty)); \\\n      break;\n#include \"clang/AST/TypeNodes.inc\"\n    }\n  }\n\n  // Add the substitution.\n  if (isSubstitutable)\n    addSubstitution(T);\n}\n\nvoid CXXNameMangler::mangleNameOrStandardSubstitution(const NamedDecl *ND) {\n  if (!mangleStandardSubstitution(ND))\n    mangleName(ND);\n}\n\nvoid CXXNameMangler::mangleType(const BuiltinType *T) {\n  //  <type>         ::= <builtin-type>\n  //  <builtin-type> ::= v  # void\n  //                 ::= w  # wchar_t\n  //                 ::= b  # bool\n  //                 ::= c  # char\n  //                 ::= a  # signed char\n  //                 ::= h  # unsigned char\n  //                 ::= s  # short\n  //                 ::= t  # unsigned short\n  //                 ::= i  # int\n  //                 ::= j  # unsigned int\n  //                 ::= l  # long\n  //                 ::= m  # unsigned long\n  //                 ::= x  # long long, __int64\n  //                 ::= y  # unsigned long long, __int64\n  //                 ::= n  # __int128\n  //                 ::= o  # unsigned __int128\n  //                 ::= f  # float\n  //                 ::= d  # double\n  //                 ::= e  # long double, __float80\n  //                 ::= g  # __float128\n  // UNSUPPORTED:    ::= Dd # IEEE 754r decimal floating point (64 bits)\n  // UNSUPPORTED:    ::= De # IEEE 754r decimal floating point (128 bits)\n  // UNSUPPORTED:    ::= Df # IEEE 754r decimal floating point (32 bits)\n  //                 ::= Dh # IEEE 754r half-precision floating point (16 bits)\n  //                 ::= DF <number> _ # ISO/IEC TS 18661 binary floating point type _FloatN (N bits);\n  //                 ::= Di # char32_t\n  //                 ::= Ds # char16_t\n  //                 ::= Dn # std::nullptr_t (i.e., decltype(nullptr))\n  //                 ::= u <source-name>    # vendor extended type\n  std::string type_name;\n  switch (T->getKind()) {\n  case BuiltinType::Void:\n    Out << 'v';\n    break;\n  case BuiltinType::Bool:\n    Out << 'b';\n    break;\n  case BuiltinType::Char_U:\n  case BuiltinType::Char_S:\n    Out << 'c';\n    break;\n  case BuiltinType::UChar:\n    Out << 'h';\n    break;\n  case BuiltinType::UShort:\n    Out << 't';\n    break;\n  case BuiltinType::UInt:\n    Out << 'j';\n    break;\n  case BuiltinType::ULong:\n    Out << 'm';\n    break;\n  case BuiltinType::ULongLong:\n    Out << 'y';\n    break;\n  case BuiltinType::UInt128:\n    Out << 'o';\n    break;\n  case BuiltinType::SChar:\n    Out << 'a';\n    break;\n  case BuiltinType::WChar_S:\n  case BuiltinType::WChar_U:\n    Out << 'w';\n    break;\n  case BuiltinType::Char8:\n    Out << \"Du\";\n    break;\n  case BuiltinType::Char16:\n    Out << \"Ds\";\n    break;\n  case BuiltinType::Char32:\n    Out << \"Di\";\n    break;\n  case BuiltinType::Short:\n    Out << 's';\n    break;\n  case BuiltinType::Int:\n    Out << 'i';\n    break;\n  case BuiltinType::Long:\n    Out << 'l';\n    break;\n  case BuiltinType::LongLong:\n    Out << 'x';\n    break;\n  case BuiltinType::Int128:\n    Out << 'n';\n    break;\n  case BuiltinType::Float16:\n    Out << \"DF16_\";\n    break;\n  case BuiltinType::ShortAccum:\n  case BuiltinType::Accum:\n  case BuiltinType::LongAccum:\n  case BuiltinType::UShortAccum:\n  case BuiltinType::UAccum:\n  case BuiltinType::ULongAccum:\n  case BuiltinType::ShortFract:\n  case BuiltinType::Fract:\n  case BuiltinType::LongFract:\n  case BuiltinType::UShortFract:\n  case BuiltinType::UFract:\n  case BuiltinType::ULongFract:\n  case BuiltinType::SatShortAccum:\n  case BuiltinType::SatAccum:\n  case BuiltinType::SatLongAccum:\n  case BuiltinType::SatUShortAccum:\n  case BuiltinType::SatUAccum:\n  case BuiltinType::SatULongAccum:\n  case BuiltinType::SatShortFract:\n  case BuiltinType::SatFract:\n  case BuiltinType::SatLongFract:\n  case BuiltinType::SatUShortFract:\n  case BuiltinType::SatUFract:\n  case BuiltinType::SatULongFract:\n    llvm_unreachable(\"Fixed point types are disabled for c++\");\n  case BuiltinType::Half:\n    Out << \"Dh\";\n    break;\n  case BuiltinType::Float:\n    Out << 'f';\n    break;\n  case BuiltinType::Double:\n    Out << 'd';\n    break;\n  case BuiltinType::LongDouble: {\n    const TargetInfo *TI = getASTContext().getLangOpts().OpenMP &&\n                                   getASTContext().getLangOpts().OpenMPIsDevice\n                               ? getASTContext().getAuxTargetInfo()\n                               : &getASTContext().getTargetInfo();\n    Out << TI->getLongDoubleMangling();\n    break;\n  }\n  case BuiltinType::Float128: {\n    const TargetInfo *TI = getASTContext().getLangOpts().OpenMP &&\n                                   getASTContext().getLangOpts().OpenMPIsDevice\n                               ? getASTContext().getAuxTargetInfo()\n                               : &getASTContext().getTargetInfo();\n    Out << TI->getFloat128Mangling();\n    break;\n  }\n  case BuiltinType::BFloat16: {\n    const TargetInfo *TI = &getASTContext().getTargetInfo();\n    Out << TI->getBFloat16Mangling();\n    break;\n  }\n  case BuiltinType::NullPtr:\n    Out << \"Dn\";\n    break;\n\n#define BUILTIN_TYPE(Id, SingletonId)\n#define PLACEHOLDER_TYPE(Id, SingletonId) \\\n  case BuiltinType::Id:\n#include \"clang/AST/BuiltinTypes.def\"\n  case BuiltinType::Dependent:\n    if (!NullOut)\n      llvm_unreachable(\"mangling a placeholder type\");\n    break;\n  case BuiltinType::ObjCId:\n    Out << \"11objc_object\";\n    break;\n  case BuiltinType::ObjCClass:\n    Out << \"10objc_class\";\n    break;\n  case BuiltinType::ObjCSel:\n    Out << \"13objc_selector\";\n    break;\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n  case BuiltinType::Id: \\\n    type_name = \"ocl_\" #ImgType \"_\" #Suffix; \\\n    Out << type_name.size() << type_name; \\\n    break;\n#include \"clang/Basic/OpenCLImageTypes.def\"\n  case BuiltinType::OCLSampler:\n    Out << \"11ocl_sampler\";\n    break;\n  case BuiltinType::OCLEvent:\n    Out << \"9ocl_event\";\n    break;\n  case BuiltinType::OCLClkEvent:\n    Out << \"12ocl_clkevent\";\n    break;\n  case BuiltinType::OCLQueue:\n    Out << \"9ocl_queue\";\n    break;\n  case BuiltinType::OCLReserveID:\n    Out << \"13ocl_reserveid\";\n    break;\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n  case BuiltinType::Id: \\\n    type_name = \"ocl_\" #ExtType; \\\n    Out << type_name.size() << type_name; \\\n    break;\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n  // The SVE types are effectively target-specific.  The mangling scheme\n  // is defined in the appendices to the Procedure Call Standard for the\n  // Arm Architecture.\n#define SVE_VECTOR_TYPE(InternalName, MangledName, Id, SingletonId, NumEls,    \\\n                        ElBits, IsSigned, IsFP, IsBF)                          \\\n  case BuiltinType::Id:                                                        \\\n    type_name = MangledName;                                                   \\\n    Out << (type_name == InternalName ? \"u\" : \"\") << type_name.size()          \\\n        << type_name;                                                          \\\n    break;\n#define SVE_PREDICATE_TYPE(InternalName, MangledName, Id, SingletonId, NumEls) \\\n  case BuiltinType::Id:                                                        \\\n    type_name = MangledName;                                                   \\\n    Out << (type_name == InternalName ? \"u\" : \"\") << type_name.size()          \\\n        << type_name;                                                          \\\n    break;\n#include \"clang/Basic/AArch64SVEACLETypes.def\"\n#define PPC_VECTOR_TYPE(Name, Id, Size) \\\n  case BuiltinType::Id: \\\n    type_name = #Name; \\\n    Out << 'u' << type_name.size() << type_name; \\\n    break;\n#include \"clang/Basic/PPCTypes.def\"\n    // TODO: Check the mangling scheme for RISC-V V.\n#define RVV_TYPE(Name, Id, SingletonId)                                        \\\n  case BuiltinType::Id:                                                        \\\n    type_name = Name;                                                          \\\n    Out << 'u' << type_name.size() << type_name;                               \\\n    break;\n#include \"clang/Basic/RISCVVTypes.def\"\n  }\n}\n\nStringRef CXXNameMangler::getCallingConvQualifierName(CallingConv CC) {\n  switch (CC) {\n  case CC_C:\n    return \"\";\n\n  case CC_X86VectorCall:\n  case CC_X86Pascal:\n  case CC_X86RegCall:\n  case CC_AAPCS:\n  case CC_AAPCS_VFP:\n  case CC_AArch64VectorCall:\n  case CC_IntelOclBicc:\n  case CC_SpirFunction:\n  case CC_OpenCLKernel:\n  case CC_PreserveMost:\n  case CC_PreserveAll:\n    // FIXME: we should be mangling all of the above.\n    return \"\";\n\n  case CC_X86ThisCall:\n    // FIXME: To match mingw GCC, thiscall should only be mangled in when it is\n    // used explicitly. At this point, we don't have that much information in\n    // the AST, since clang tends to bake the convention into the canonical\n    // function type. thiscall only rarely used explicitly, so don't mangle it\n    // for now.\n    return \"\";\n\n  case CC_X86StdCall:\n    return \"stdcall\";\n  case CC_X86FastCall:\n    return \"fastcall\";\n  case CC_X86_64SysV:\n    return \"sysv_abi\";\n  case CC_Win64:\n    return \"ms_abi\";\n  case CC_Swift:\n    return \"swiftcall\";\n  }\n  llvm_unreachable(\"bad calling convention\");\n}\n\nvoid CXXNameMangler::mangleExtFunctionInfo(const FunctionType *T) {\n  // Fast path.\n  if (T->getExtInfo() == FunctionType::ExtInfo())\n    return;\n\n  // Vendor-specific qualifiers are emitted in reverse alphabetical order.\n  // This will get more complicated in the future if we mangle other\n  // things here; but for now, since we mangle ns_returns_retained as\n  // a qualifier on the result type, we can get away with this:\n  StringRef CCQualifier = getCallingConvQualifierName(T->getExtInfo().getCC());\n  if (!CCQualifier.empty())\n    mangleVendorQualifier(CCQualifier);\n\n  // FIXME: regparm\n  // FIXME: noreturn\n}\n\nvoid\nCXXNameMangler::mangleExtParameterInfo(FunctionProtoType::ExtParameterInfo PI) {\n  // Vendor-specific qualifiers are emitted in reverse alphabetical order.\n\n  // Note that these are *not* substitution candidates.  Demanglers might\n  // have trouble with this if the parameter type is fully substituted.\n\n  switch (PI.getABI()) {\n  case ParameterABI::Ordinary:\n    break;\n\n  // All of these start with \"swift\", so they come before \"ns_consumed\".\n  case ParameterABI::SwiftContext:\n  case ParameterABI::SwiftErrorResult:\n  case ParameterABI::SwiftIndirectResult:\n    mangleVendorQualifier(getParameterABISpelling(PI.getABI()));\n    break;\n  }\n\n  if (PI.isConsumed())\n    mangleVendorQualifier(\"ns_consumed\");\n\n  if (PI.isNoEscape())\n    mangleVendorQualifier(\"noescape\");\n}\n\n// <type>          ::= <function-type>\n// <function-type> ::= [<CV-qualifiers>] F [Y]\n//                      <bare-function-type> [<ref-qualifier>] E\nvoid CXXNameMangler::mangleType(const FunctionProtoType *T) {\n  mangleExtFunctionInfo(T);\n\n  // Mangle CV-qualifiers, if present.  These are 'this' qualifiers,\n  // e.g. \"const\" in \"int (A::*)() const\".\n  mangleQualifiers(T->getMethodQuals());\n\n  // Mangle instantiation-dependent exception-specification, if present,\n  // per cxx-abi-dev proposal on 2016-10-11.\n  if (T->hasInstantiationDependentExceptionSpec()) {\n    if (isComputedNoexcept(T->getExceptionSpecType())) {\n      Out << \"DO\";\n      mangleExpression(T->getNoexceptExpr());\n      Out << \"E\";\n    } else {\n      assert(T->getExceptionSpecType() == EST_Dynamic);\n      Out << \"Dw\";\n      for (auto ExceptTy : T->exceptions())\n        mangleType(ExceptTy);\n      Out << \"E\";\n    }\n  } else if (T->isNothrow()) {\n    Out << \"Do\";\n  }\n\n  Out << 'F';\n\n  // FIXME: We don't have enough information in the AST to produce the 'Y'\n  // encoding for extern \"C\" function types.\n  mangleBareFunctionType(T, /*MangleReturnType=*/true);\n\n  // Mangle the ref-qualifier, if present.\n  mangleRefQualifier(T->getRefQualifier());\n\n  Out << 'E';\n}\n\nvoid CXXNameMangler::mangleType(const FunctionNoProtoType *T) {\n  // Function types without prototypes can arise when mangling a function type\n  // within an overloadable function in C. We mangle these as the absence of any\n  // parameter types (not even an empty parameter list).\n  Out << 'F';\n\n  FunctionTypeDepthState saved = FunctionTypeDepth.push();\n\n  FunctionTypeDepth.enterResultType();\n  mangleType(T->getReturnType());\n  FunctionTypeDepth.leaveResultType();\n\n  FunctionTypeDepth.pop(saved);\n  Out << 'E';\n}\n\nvoid CXXNameMangler::mangleBareFunctionType(const FunctionProtoType *Proto,\n                                            bool MangleReturnType,\n                                            const FunctionDecl *FD) {\n  // Record that we're in a function type.  See mangleFunctionParam\n  // for details on what we're trying to achieve here.\n  FunctionTypeDepthState saved = FunctionTypeDepth.push();\n\n  // <bare-function-type> ::= <signature type>+\n  if (MangleReturnType) {\n    FunctionTypeDepth.enterResultType();\n\n    // Mangle ns_returns_retained as an order-sensitive qualifier here.\n    if (Proto->getExtInfo().getProducesResult() && FD == nullptr)\n      mangleVendorQualifier(\"ns_returns_retained\");\n\n    // Mangle the return type without any direct ARC ownership qualifiers.\n    QualType ReturnTy = Proto->getReturnType();\n    if (ReturnTy.getObjCLifetime()) {\n      auto SplitReturnTy = ReturnTy.split();\n      SplitReturnTy.Quals.removeObjCLifetime();\n      ReturnTy = getASTContext().getQualifiedType(SplitReturnTy);\n    }\n    mangleType(ReturnTy);\n\n    FunctionTypeDepth.leaveResultType();\n  }\n\n  if (Proto->getNumParams() == 0 && !Proto->isVariadic()) {\n    //   <builtin-type> ::= v   # void\n    Out << 'v';\n\n    FunctionTypeDepth.pop(saved);\n    return;\n  }\n\n  assert(!FD || FD->getNumParams() == Proto->getNumParams());\n  for (unsigned I = 0, E = Proto->getNumParams(); I != E; ++I) {\n    // Mangle extended parameter info as order-sensitive qualifiers here.\n    if (Proto->hasExtParameterInfos() && FD == nullptr) {\n      mangleExtParameterInfo(Proto->getExtParameterInfo(I));\n    }\n\n    // Mangle the type.\n    QualType ParamTy = Proto->getParamType(I);\n    mangleType(Context.getASTContext().getSignatureParameterType(ParamTy));\n\n    if (FD) {\n      if (auto *Attr = FD->getParamDecl(I)->getAttr<PassObjectSizeAttr>()) {\n        // Attr can only take 1 character, so we can hardcode the length below.\n        assert(Attr->getType() <= 9 && Attr->getType() >= 0);\n        if (Attr->isDynamic())\n          Out << \"U25pass_dynamic_object_size\" << Attr->getType();\n        else\n          Out << \"U17pass_object_size\" << Attr->getType();\n      }\n    }\n  }\n\n  FunctionTypeDepth.pop(saved);\n\n  // <builtin-type>      ::= z  # ellipsis\n  if (Proto->isVariadic())\n    Out << 'z';\n}\n\n// <type>            ::= <class-enum-type>\n// <class-enum-type> ::= <name>\nvoid CXXNameMangler::mangleType(const UnresolvedUsingType *T) {\n  mangleName(T->getDecl());\n}\n\n// <type>            ::= <class-enum-type>\n// <class-enum-type> ::= <name>\nvoid CXXNameMangler::mangleType(const EnumType *T) {\n  mangleType(static_cast<const TagType*>(T));\n}\nvoid CXXNameMangler::mangleType(const RecordType *T) {\n  mangleType(static_cast<const TagType*>(T));\n}\nvoid CXXNameMangler::mangleType(const TagType *T) {\n  mangleName(T->getDecl());\n}\n\n// <type>       ::= <array-type>\n// <array-type> ::= A <positive dimension number> _ <element type>\n//              ::= A [<dimension expression>] _ <element type>\nvoid CXXNameMangler::mangleType(const ConstantArrayType *T) {\n  Out << 'A' << T->getSize() << '_';\n  mangleType(T->getElementType());\n}\nvoid CXXNameMangler::mangleType(const VariableArrayType *T) {\n  Out << 'A';\n  // decayed vla types (size 0) will just be skipped.\n  if (T->getSizeExpr())\n    mangleExpression(T->getSizeExpr());\n  Out << '_';\n  mangleType(T->getElementType());\n}\nvoid CXXNameMangler::mangleType(const DependentSizedArrayType *T) {\n  Out << 'A';\n  mangleExpression(T->getSizeExpr());\n  Out << '_';\n  mangleType(T->getElementType());\n}\nvoid CXXNameMangler::mangleType(const IncompleteArrayType *T) {\n  Out << \"A_\";\n  mangleType(T->getElementType());\n}\n\n// <type>                   ::= <pointer-to-member-type>\n// <pointer-to-member-type> ::= M <class type> <member type>\nvoid CXXNameMangler::mangleType(const MemberPointerType *T) {\n  Out << 'M';\n  mangleType(QualType(T->getClass(), 0));\n  QualType PointeeType = T->getPointeeType();\n  if (const FunctionProtoType *FPT = dyn_cast<FunctionProtoType>(PointeeType)) {\n    mangleType(FPT);\n\n    // Itanium C++ ABI 5.1.8:\n    //\n    //   The type of a non-static member function is considered to be different,\n    //   for the purposes of substitution, from the type of a namespace-scope or\n    //   static member function whose type appears similar. The types of two\n    //   non-static member functions are considered to be different, for the\n    //   purposes of substitution, if the functions are members of different\n    //   classes. In other words, for the purposes of substitution, the class of\n    //   which the function is a member is considered part of the type of\n    //   function.\n\n    // Given that we already substitute member function pointers as a\n    // whole, the net effect of this rule is just to unconditionally\n    // suppress substitution on the function type in a member pointer.\n    // We increment the SeqID here to emulate adding an entry to the\n    // substitution table.\n    ++SeqID;\n  } else\n    mangleType(PointeeType);\n}\n\n// <type>           ::= <template-param>\nvoid CXXNameMangler::mangleType(const TemplateTypeParmType *T) {\n  mangleTemplateParameter(T->getDepth(), T->getIndex());\n}\n\n// <type>           ::= <template-param>\nvoid CXXNameMangler::mangleType(const SubstTemplateTypeParmPackType *T) {\n  // FIXME: not clear how to mangle this!\n  // template <class T...> class A {\n  //   template <class U...> void foo(T(*)(U) x...);\n  // };\n  Out << \"_SUBSTPACK_\";\n}\n\n// <type> ::= P <type>   # pointer-to\nvoid CXXNameMangler::mangleType(const PointerType *T) {\n  Out << 'P';\n  mangleType(T->getPointeeType());\n}\nvoid CXXNameMangler::mangleType(const ObjCObjectPointerType *T) {\n  Out << 'P';\n  mangleType(T->getPointeeType());\n}\n\n// <type> ::= R <type>   # reference-to\nvoid CXXNameMangler::mangleType(const LValueReferenceType *T) {\n  Out << 'R';\n  mangleType(T->getPointeeType());\n}\n\n// <type> ::= O <type>   # rvalue reference-to (C++0x)\nvoid CXXNameMangler::mangleType(const RValueReferenceType *T) {\n  Out << 'O';\n  mangleType(T->getPointeeType());\n}\n\n// <type> ::= C <type>   # complex pair (C 2000)\nvoid CXXNameMangler::mangleType(const ComplexType *T) {\n  Out << 'C';\n  mangleType(T->getElementType());\n}\n\n// ARM's ABI for Neon vector types specifies that they should be mangled as\n// if they are structs (to match ARM's initial implementation).  The\n// vector type must be one of the special types predefined by ARM.\nvoid CXXNameMangler::mangleNeonVectorType(const VectorType *T) {\n  QualType EltType = T->getElementType();\n  assert(EltType->isBuiltinType() && \"Neon vector element not a BuiltinType\");\n  const char *EltName = nullptr;\n  if (T->getVectorKind() == VectorType::NeonPolyVector) {\n    switch (cast<BuiltinType>(EltType)->getKind()) {\n    case BuiltinType::SChar:\n    case BuiltinType::UChar:\n      EltName = \"poly8_t\";\n      break;\n    case BuiltinType::Short:\n    case BuiltinType::UShort:\n      EltName = \"poly16_t\";\n      break;\n    case BuiltinType::LongLong:\n    case BuiltinType::ULongLong:\n      EltName = \"poly64_t\";\n      break;\n    default: llvm_unreachable(\"unexpected Neon polynomial vector element type\");\n    }\n  } else {\n    switch (cast<BuiltinType>(EltType)->getKind()) {\n    case BuiltinType::SChar:     EltName = \"int8_t\"; break;\n    case BuiltinType::UChar:     EltName = \"uint8_t\"; break;\n    case BuiltinType::Short:     EltName = \"int16_t\"; break;\n    case BuiltinType::UShort:    EltName = \"uint16_t\"; break;\n    case BuiltinType::Int:       EltName = \"int32_t\"; break;\n    case BuiltinType::UInt:      EltName = \"uint32_t\"; break;\n    case BuiltinType::LongLong:  EltName = \"int64_t\"; break;\n    case BuiltinType::ULongLong: EltName = \"uint64_t\"; break;\n    case BuiltinType::Double:    EltName = \"float64_t\"; break;\n    case BuiltinType::Float:     EltName = \"float32_t\"; break;\n    case BuiltinType::Half:      EltName = \"float16_t\"; break;\n    case BuiltinType::BFloat16:  EltName = \"bfloat16_t\"; break;\n    default:\n      llvm_unreachable(\"unexpected Neon vector element type\");\n    }\n  }\n  const char *BaseName = nullptr;\n  unsigned BitSize = (T->getNumElements() *\n                      getASTContext().getTypeSize(EltType));\n  if (BitSize == 64)\n    BaseName = \"__simd64_\";\n  else {\n    assert(BitSize == 128 && \"Neon vector type not 64 or 128 bits\");\n    BaseName = \"__simd128_\";\n  }\n  Out << strlen(BaseName) + strlen(EltName);\n  Out << BaseName << EltName;\n}\n\nvoid CXXNameMangler::mangleNeonVectorType(const DependentVectorType *T) {\n  DiagnosticsEngine &Diags = Context.getDiags();\n  unsigned DiagID = Diags.getCustomDiagID(\n      DiagnosticsEngine::Error,\n      \"cannot mangle this dependent neon vector type yet\");\n  Diags.Report(T->getAttributeLoc(), DiagID);\n}\n\nstatic StringRef mangleAArch64VectorBase(const BuiltinType *EltType) {\n  switch (EltType->getKind()) {\n  case BuiltinType::SChar:\n    return \"Int8\";\n  case BuiltinType::Short:\n    return \"Int16\";\n  case BuiltinType::Int:\n    return \"Int32\";\n  case BuiltinType::Long:\n  case BuiltinType::LongLong:\n    return \"Int64\";\n  case BuiltinType::UChar:\n    return \"Uint8\";\n  case BuiltinType::UShort:\n    return \"Uint16\";\n  case BuiltinType::UInt:\n    return \"Uint32\";\n  case BuiltinType::ULong:\n  case BuiltinType::ULongLong:\n    return \"Uint64\";\n  case BuiltinType::Half:\n    return \"Float16\";\n  case BuiltinType::Float:\n    return \"Float32\";\n  case BuiltinType::Double:\n    return \"Float64\";\n  case BuiltinType::BFloat16:\n    return \"Bfloat16\";\n  default:\n    llvm_unreachable(\"Unexpected vector element base type\");\n  }\n}\n\n// AArch64's ABI for Neon vector types specifies that they should be mangled as\n// the equivalent internal name. The vector type must be one of the special\n// types predefined by ARM.\nvoid CXXNameMangler::mangleAArch64NeonVectorType(const VectorType *T) {\n  QualType EltType = T->getElementType();\n  assert(EltType->isBuiltinType() && \"Neon vector element not a BuiltinType\");\n  unsigned BitSize =\n      (T->getNumElements() * getASTContext().getTypeSize(EltType));\n  (void)BitSize; // Silence warning.\n\n  assert((BitSize == 64 || BitSize == 128) &&\n         \"Neon vector type not 64 or 128 bits\");\n\n  StringRef EltName;\n  if (T->getVectorKind() == VectorType::NeonPolyVector) {\n    switch (cast<BuiltinType>(EltType)->getKind()) {\n    case BuiltinType::UChar:\n      EltName = \"Poly8\";\n      break;\n    case BuiltinType::UShort:\n      EltName = \"Poly16\";\n      break;\n    case BuiltinType::ULong:\n    case BuiltinType::ULongLong:\n      EltName = \"Poly64\";\n      break;\n    default:\n      llvm_unreachable(\"unexpected Neon polynomial vector element type\");\n    }\n  } else\n    EltName = mangleAArch64VectorBase(cast<BuiltinType>(EltType));\n\n  std::string TypeName =\n      (\"__\" + EltName + \"x\" + Twine(T->getNumElements()) + \"_t\").str();\n  Out << TypeName.length() << TypeName;\n}\nvoid CXXNameMangler::mangleAArch64NeonVectorType(const DependentVectorType *T) {\n  DiagnosticsEngine &Diags = Context.getDiags();\n  unsigned DiagID = Diags.getCustomDiagID(\n      DiagnosticsEngine::Error,\n      \"cannot mangle this dependent neon vector type yet\");\n  Diags.Report(T->getAttributeLoc(), DiagID);\n}\n\n// The AArch64 ACLE specifies that fixed-length SVE vector and predicate types\n// defined with the 'arm_sve_vector_bits' attribute map to the same AAPCS64\n// type as the sizeless variants.\n//\n// The mangling scheme for VLS types is implemented as a \"pseudo\" template:\n//\n//   '__SVE_VLS<<type>, <vector length>>'\n//\n// Combining the existing SVE type and a specific vector length (in bits).\n// For example:\n//\n//   typedef __SVInt32_t foo __attribute__((arm_sve_vector_bits(512)));\n//\n// is described as '__SVE_VLS<__SVInt32_t, 512u>' and mangled as:\n//\n//   \"9__SVE_VLSI\" + base type mangling + \"Lj\" + __ARM_FEATURE_SVE_BITS + \"EE\"\n//\n//   i.e. 9__SVE_VLSIu11__SVInt32_tLj512EE\n//\n// The latest ACLE specification (00bet5) does not contain details of this\n// mangling scheme, it will be specified in the next revision. The mangling\n// scheme is otherwise defined in the appendices to the Procedure Call Standard\n// for the Arm Architecture, see\n// https://github.com/ARM-software/abi-aa/blob/master/aapcs64/aapcs64.rst#appendix-c-mangling\nvoid CXXNameMangler::mangleAArch64FixedSveVectorType(const VectorType *T) {\n  assert((T->getVectorKind() == VectorType::SveFixedLengthDataVector ||\n          T->getVectorKind() == VectorType::SveFixedLengthPredicateVector) &&\n         \"expected fixed-length SVE vector!\");\n\n  QualType EltType = T->getElementType();\n  assert(EltType->isBuiltinType() &&\n         \"expected builtin type for fixed-length SVE vector!\");\n\n  StringRef TypeName;\n  switch (cast<BuiltinType>(EltType)->getKind()) {\n  case BuiltinType::SChar:\n    TypeName = \"__SVInt8_t\";\n    break;\n  case BuiltinType::UChar: {\n    if (T->getVectorKind() == VectorType::SveFixedLengthDataVector)\n      TypeName = \"__SVUint8_t\";\n    else\n      TypeName = \"__SVBool_t\";\n    break;\n  }\n  case BuiltinType::Short:\n    TypeName = \"__SVInt16_t\";\n    break;\n  case BuiltinType::UShort:\n    TypeName = \"__SVUint16_t\";\n    break;\n  case BuiltinType::Int:\n    TypeName = \"__SVInt32_t\";\n    break;\n  case BuiltinType::UInt:\n    TypeName = \"__SVUint32_t\";\n    break;\n  case BuiltinType::Long:\n    TypeName = \"__SVInt64_t\";\n    break;\n  case BuiltinType::ULong:\n    TypeName = \"__SVUint64_t\";\n    break;\n  case BuiltinType::Half:\n    TypeName = \"__SVFloat16_t\";\n    break;\n  case BuiltinType::Float:\n    TypeName = \"__SVFloat32_t\";\n    break;\n  case BuiltinType::Double:\n    TypeName = \"__SVFloat64_t\";\n    break;\n  case BuiltinType::BFloat16:\n    TypeName = \"__SVBfloat16_t\";\n    break;\n  default:\n    llvm_unreachable(\"unexpected element type for fixed-length SVE vector!\");\n  }\n\n  unsigned VecSizeInBits = getASTContext().getTypeInfo(T).Width;\n\n  if (T->getVectorKind() == VectorType::SveFixedLengthPredicateVector)\n    VecSizeInBits *= 8;\n\n  Out << \"9__SVE_VLSI\" << 'u' << TypeName.size() << TypeName << \"Lj\"\n      << VecSizeInBits << \"EE\";\n}\n\nvoid CXXNameMangler::mangleAArch64FixedSveVectorType(\n    const DependentVectorType *T) {\n  DiagnosticsEngine &Diags = Context.getDiags();\n  unsigned DiagID = Diags.getCustomDiagID(\n      DiagnosticsEngine::Error,\n      \"cannot mangle this dependent fixed-length SVE vector type yet\");\n  Diags.Report(T->getAttributeLoc(), DiagID);\n}\n\n// GNU extension: vector types\n// <type>                  ::= <vector-type>\n// <vector-type>           ::= Dv <positive dimension number> _\n//                                    <extended element type>\n//                         ::= Dv [<dimension expression>] _ <element type>\n// <extended element type> ::= <element type>\n//                         ::= p # AltiVec vector pixel\n//                         ::= b # Altivec vector bool\nvoid CXXNameMangler::mangleType(const VectorType *T) {\n  if ((T->getVectorKind() == VectorType::NeonVector ||\n       T->getVectorKind() == VectorType::NeonPolyVector)) {\n    llvm::Triple Target = getASTContext().getTargetInfo().getTriple();\n    llvm::Triple::ArchType Arch =\n        getASTContext().getTargetInfo().getTriple().getArch();\n    if ((Arch == llvm::Triple::aarch64 ||\n         Arch == llvm::Triple::aarch64_be) && !Target.isOSDarwin())\n      mangleAArch64NeonVectorType(T);\n    else\n      mangleNeonVectorType(T);\n    return;\n  } else if (T->getVectorKind() == VectorType::SveFixedLengthDataVector ||\n             T->getVectorKind() == VectorType::SveFixedLengthPredicateVector) {\n    mangleAArch64FixedSveVectorType(T);\n    return;\n  }\n  Out << \"Dv\" << T->getNumElements() << '_';\n  if (T->getVectorKind() == VectorType::AltiVecPixel)\n    Out << 'p';\n  else if (T->getVectorKind() == VectorType::AltiVecBool)\n    Out << 'b';\n  else\n    mangleType(T->getElementType());\n}\n\nvoid CXXNameMangler::mangleType(const DependentVectorType *T) {\n  if ((T->getVectorKind() == VectorType::NeonVector ||\n       T->getVectorKind() == VectorType::NeonPolyVector)) {\n    llvm::Triple Target = getASTContext().getTargetInfo().getTriple();\n    llvm::Triple::ArchType Arch =\n        getASTContext().getTargetInfo().getTriple().getArch();\n    if ((Arch == llvm::Triple::aarch64 || Arch == llvm::Triple::aarch64_be) &&\n        !Target.isOSDarwin())\n      mangleAArch64NeonVectorType(T);\n    else\n      mangleNeonVectorType(T);\n    return;\n  } else if (T->getVectorKind() == VectorType::SveFixedLengthDataVector ||\n             T->getVectorKind() == VectorType::SveFixedLengthPredicateVector) {\n    mangleAArch64FixedSveVectorType(T);\n    return;\n  }\n\n  Out << \"Dv\";\n  mangleExpression(T->getSizeExpr());\n  Out << '_';\n  if (T->getVectorKind() == VectorType::AltiVecPixel)\n    Out << 'p';\n  else if (T->getVectorKind() == VectorType::AltiVecBool)\n    Out << 'b';\n  else\n    mangleType(T->getElementType());\n}\n\nvoid CXXNameMangler::mangleType(const ExtVectorType *T) {\n  mangleType(static_cast<const VectorType*>(T));\n}\nvoid CXXNameMangler::mangleType(const DependentSizedExtVectorType *T) {\n  Out << \"Dv\";\n  mangleExpression(T->getSizeExpr());\n  Out << '_';\n  mangleType(T->getElementType());\n}\n\nvoid CXXNameMangler::mangleType(const ConstantMatrixType *T) {\n  // Mangle matrix types as a vendor extended type:\n  // u<Len>matrix_typeI<Rows><Columns><element type>E\n\n  StringRef VendorQualifier = \"matrix_type\";\n  Out << \"u\" << VendorQualifier.size() << VendorQualifier;\n\n  Out << \"I\";\n  auto &ASTCtx = getASTContext();\n  unsigned BitWidth = ASTCtx.getTypeSize(ASTCtx.getSizeType());\n  llvm::APSInt Rows(BitWidth);\n  Rows = T->getNumRows();\n  mangleIntegerLiteral(ASTCtx.getSizeType(), Rows);\n  llvm::APSInt Columns(BitWidth);\n  Columns = T->getNumColumns();\n  mangleIntegerLiteral(ASTCtx.getSizeType(), Columns);\n  mangleType(T->getElementType());\n  Out << \"E\";\n}\n\nvoid CXXNameMangler::mangleType(const DependentSizedMatrixType *T) {\n  // Mangle matrix types as a vendor extended type:\n  // u<Len>matrix_typeI<row expr><column expr><element type>E\n  StringRef VendorQualifier = \"matrix_type\";\n  Out << \"u\" << VendorQualifier.size() << VendorQualifier;\n\n  Out << \"I\";\n  mangleTemplateArgExpr(T->getRowExpr());\n  mangleTemplateArgExpr(T->getColumnExpr());\n  mangleType(T->getElementType());\n  Out << \"E\";\n}\n\nvoid CXXNameMangler::mangleType(const DependentAddressSpaceType *T) {\n  SplitQualType split = T->getPointeeType().split();\n  mangleQualifiers(split.Quals, T);\n  mangleType(QualType(split.Ty, 0));\n}\n\nvoid CXXNameMangler::mangleType(const PackExpansionType *T) {\n  // <type>  ::= Dp <type>          # pack expansion (C++0x)\n  Out << \"Dp\";\n  mangleType(T->getPattern());\n}\n\nvoid CXXNameMangler::mangleType(const ObjCInterfaceType *T) {\n  mangleSourceName(T->getDecl()->getIdentifier());\n}\n\nvoid CXXNameMangler::mangleType(const ObjCObjectType *T) {\n  // Treat __kindof as a vendor extended type qualifier.\n  if (T->isKindOfType())\n    Out << \"U8__kindof\";\n\n  if (!T->qual_empty()) {\n    // Mangle protocol qualifiers.\n    SmallString<64> QualStr;\n    llvm::raw_svector_ostream QualOS(QualStr);\n    QualOS << \"objcproto\";\n    for (const auto *I : T->quals()) {\n      StringRef name = I->getName();\n      QualOS << name.size() << name;\n    }\n    Out << 'U' << QualStr.size() << QualStr;\n  }\n\n  mangleType(T->getBaseType());\n\n  if (T->isSpecialized()) {\n    // Mangle type arguments as I <type>+ E\n    Out << 'I';\n    for (auto typeArg : T->getTypeArgs())\n      mangleType(typeArg);\n    Out << 'E';\n  }\n}\n\nvoid CXXNameMangler::mangleType(const BlockPointerType *T) {\n  Out << \"U13block_pointer\";\n  mangleType(T->getPointeeType());\n}\n\nvoid CXXNameMangler::mangleType(const InjectedClassNameType *T) {\n  // Mangle injected class name types as if the user had written the\n  // specialization out fully.  It may not actually be possible to see\n  // this mangling, though.\n  mangleType(T->getInjectedSpecializationType());\n}\n\nvoid CXXNameMangler::mangleType(const TemplateSpecializationType *T) {\n  if (TemplateDecl *TD = T->getTemplateName().getAsTemplateDecl()) {\n    mangleTemplateName(TD, T->getArgs(), T->getNumArgs());\n  } else {\n    if (mangleSubstitution(QualType(T, 0)))\n      return;\n\n    mangleTemplatePrefix(T->getTemplateName());\n\n    // FIXME: GCC does not appear to mangle the template arguments when\n    // the template in question is a dependent template name. Should we\n    // emulate that badness?\n    mangleTemplateArgs(T->getTemplateName(), T->getArgs(), T->getNumArgs());\n    addSubstitution(QualType(T, 0));\n  }\n}\n\nvoid CXXNameMangler::mangleType(const DependentNameType *T) {\n  // Proposal by cxx-abi-dev, 2014-03-26\n  // <class-enum-type> ::= <name>    # non-dependent or dependent type name or\n  //                                 # dependent elaborated type specifier using\n  //                                 # 'typename'\n  //                   ::= Ts <name> # dependent elaborated type specifier using\n  //                                 # 'struct' or 'class'\n  //                   ::= Tu <name> # dependent elaborated type specifier using\n  //                                 # 'union'\n  //                   ::= Te <name> # dependent elaborated type specifier using\n  //                                 # 'enum'\n  switch (T->getKeyword()) {\n    case ETK_None:\n    case ETK_Typename:\n      break;\n    case ETK_Struct:\n    case ETK_Class:\n    case ETK_Interface:\n      Out << \"Ts\";\n      break;\n    case ETK_Union:\n      Out << \"Tu\";\n      break;\n    case ETK_Enum:\n      Out << \"Te\";\n      break;\n  }\n  // Typename types are always nested\n  Out << 'N';\n  manglePrefix(T->getQualifier());\n  mangleSourceName(T->getIdentifier());\n  Out << 'E';\n}\n\nvoid CXXNameMangler::mangleType(const DependentTemplateSpecializationType *T) {\n  // Dependently-scoped template types are nested if they have a prefix.\n  Out << 'N';\n\n  // TODO: avoid making this TemplateName.\n  TemplateName Prefix =\n    getASTContext().getDependentTemplateName(T->getQualifier(),\n                                             T->getIdentifier());\n  mangleTemplatePrefix(Prefix);\n\n  // FIXME: GCC does not appear to mangle the template arguments when\n  // the template in question is a dependent template name. Should we\n  // emulate that badness?\n  mangleTemplateArgs(Prefix, T->getArgs(), T->getNumArgs());\n  Out << 'E';\n}\n\nvoid CXXNameMangler::mangleType(const TypeOfType *T) {\n  // FIXME: this is pretty unsatisfactory, but there isn't an obvious\n  // \"extension with parameters\" mangling.\n  Out << \"u6typeof\";\n}\n\nvoid CXXNameMangler::mangleType(const TypeOfExprType *T) {\n  // FIXME: this is pretty unsatisfactory, but there isn't an obvious\n  // \"extension with parameters\" mangling.\n  Out << \"u6typeof\";\n}\n\nvoid CXXNameMangler::mangleType(const DecltypeType *T) {\n  Expr *E = T->getUnderlyingExpr();\n\n  // type ::= Dt <expression> E  # decltype of an id-expression\n  //                             #   or class member access\n  //      ::= DT <expression> E  # decltype of an expression\n\n  // This purports to be an exhaustive list of id-expressions and\n  // class member accesses.  Note that we do not ignore parentheses;\n  // parentheses change the semantics of decltype for these\n  // expressions (and cause the mangler to use the other form).\n  if (isa<DeclRefExpr>(E) ||\n      isa<MemberExpr>(E) ||\n      isa<UnresolvedLookupExpr>(E) ||\n      isa<DependentScopeDeclRefExpr>(E) ||\n      isa<CXXDependentScopeMemberExpr>(E) ||\n      isa<UnresolvedMemberExpr>(E))\n    Out << \"Dt\";\n  else\n    Out << \"DT\";\n  mangleExpression(E);\n  Out << 'E';\n}\n\nvoid CXXNameMangler::mangleType(const UnaryTransformType *T) {\n  // If this is dependent, we need to record that. If not, we simply\n  // mangle it as the underlying type since they are equivalent.\n  if (T->isDependentType()) {\n    Out << 'U';\n\n    switch (T->getUTTKind()) {\n      case UnaryTransformType::EnumUnderlyingType:\n        Out << \"3eut\";\n        break;\n    }\n  }\n\n  mangleType(T->getBaseType());\n}\n\nvoid CXXNameMangler::mangleType(const AutoType *T) {\n  assert(T->getDeducedType().isNull() &&\n         \"Deduced AutoType shouldn't be handled here!\");\n  assert(T->getKeyword() != AutoTypeKeyword::GNUAutoType &&\n         \"shouldn't need to mangle __auto_type!\");\n  // <builtin-type> ::= Da # auto\n  //                ::= Dc # decltype(auto)\n  Out << (T->isDecltypeAuto() ? \"Dc\" : \"Da\");\n}\n\nvoid CXXNameMangler::mangleType(const DeducedTemplateSpecializationType *T) {\n  QualType Deduced = T->getDeducedType();\n  if (!Deduced.isNull())\n    return mangleType(Deduced);\n\n  TemplateDecl *TD = T->getTemplateName().getAsTemplateDecl();\n  assert(TD && \"shouldn't form deduced TST unless we know we have a template\");\n\n  if (mangleSubstitution(TD))\n    return;\n\n  mangleName(GlobalDecl(TD));\n  addSubstitution(TD);\n}\n\nvoid CXXNameMangler::mangleType(const AtomicType *T) {\n  // <type> ::= U <source-name> <type>  # vendor extended type qualifier\n  // (Until there's a standardized mangling...)\n  Out << \"U7_Atomic\";\n  mangleType(T->getValueType());\n}\n\nvoid CXXNameMangler::mangleType(const PipeType *T) {\n  // Pipe type mangling rules are described in SPIR 2.0 specification\n  // A.1 Data types and A.3 Summary of changes\n  // <type> ::= 8ocl_pipe\n  Out << \"8ocl_pipe\";\n}\n\nvoid CXXNameMangler::mangleType(const ExtIntType *T) {\n  Out << \"U7_ExtInt\";\n  llvm::APSInt BW(32, true);\n  BW = T->getNumBits();\n  TemplateArgument TA(Context.getASTContext(), BW, getASTContext().IntTy);\n  mangleTemplateArgs(TemplateName(), &TA, 1);\n  if (T->isUnsigned())\n    Out << \"j\";\n  else\n    Out << \"i\";\n}\n\nvoid CXXNameMangler::mangleType(const DependentExtIntType *T) {\n  Out << \"U7_ExtInt\";\n  TemplateArgument TA(T->getNumBitsExpr());\n  mangleTemplateArgs(TemplateName(), &TA, 1);\n  if (T->isUnsigned())\n    Out << \"j\";\n  else\n    Out << \"i\";\n}\n\nvoid CXXNameMangler::mangleIntegerLiteral(QualType T,\n                                          const llvm::APSInt &Value) {\n  //  <expr-primary> ::= L <type> <value number> E # integer literal\n  Out << 'L';\n\n  mangleType(T);\n  if (T->isBooleanType()) {\n    // Boolean values are encoded as 0/1.\n    Out << (Value.getBoolValue() ? '1' : '0');\n  } else {\n    mangleNumber(Value);\n  }\n  Out << 'E';\n\n}\n\nvoid CXXNameMangler::mangleMemberExprBase(const Expr *Base, bool IsArrow) {\n  // Ignore member expressions involving anonymous unions.\n  while (const auto *RT = Base->getType()->getAs<RecordType>()) {\n    if (!RT->getDecl()->isAnonymousStructOrUnion())\n      break;\n    const auto *ME = dyn_cast<MemberExpr>(Base);\n    if (!ME)\n      break;\n    Base = ME->getBase();\n    IsArrow = ME->isArrow();\n  }\n\n  if (Base->isImplicitCXXThis()) {\n    // Note: GCC mangles member expressions to the implicit 'this' as\n    // *this., whereas we represent them as this->. The Itanium C++ ABI\n    // does not specify anything here, so we follow GCC.\n    Out << \"dtdefpT\";\n  } else {\n    Out << (IsArrow ? \"pt\" : \"dt\");\n    mangleExpression(Base);\n  }\n}\n\n/// Mangles a member expression.\nvoid CXXNameMangler::mangleMemberExpr(const Expr *base,\n                                      bool isArrow,\n                                      NestedNameSpecifier *qualifier,\n                                      NamedDecl *firstQualifierLookup,\n                                      DeclarationName member,\n                                      const TemplateArgumentLoc *TemplateArgs,\n                                      unsigned NumTemplateArgs,\n                                      unsigned arity) {\n  // <expression> ::= dt <expression> <unresolved-name>\n  //              ::= pt <expression> <unresolved-name>\n  if (base)\n    mangleMemberExprBase(base, isArrow);\n  mangleUnresolvedName(qualifier, member, TemplateArgs, NumTemplateArgs, arity);\n}\n\n/// Look at the callee of the given call expression and determine if\n/// it's a parenthesized id-expression which would have triggered ADL\n/// otherwise.\nstatic bool isParenthesizedADLCallee(const CallExpr *call) {\n  const Expr *callee = call->getCallee();\n  const Expr *fn = callee->IgnoreParens();\n\n  // Must be parenthesized.  IgnoreParens() skips __extension__ nodes,\n  // too, but for those to appear in the callee, it would have to be\n  // parenthesized.\n  if (callee == fn) return false;\n\n  // Must be an unresolved lookup.\n  const UnresolvedLookupExpr *lookup = dyn_cast<UnresolvedLookupExpr>(fn);\n  if (!lookup) return false;\n\n  assert(!lookup->requiresADL());\n\n  // Must be an unqualified lookup.\n  if (lookup->getQualifier()) return false;\n\n  // Must not have found a class member.  Note that if one is a class\n  // member, they're all class members.\n  if (lookup->getNumDecls() > 0 &&\n      (*lookup->decls_begin())->isCXXClassMember())\n    return false;\n\n  // Otherwise, ADL would have been triggered.\n  return true;\n}\n\nvoid CXXNameMangler::mangleCastExpression(const Expr *E, StringRef CastEncoding) {\n  const ExplicitCastExpr *ECE = cast<ExplicitCastExpr>(E);\n  Out << CastEncoding;\n  mangleType(ECE->getType());\n  mangleExpression(ECE->getSubExpr());\n}\n\nvoid CXXNameMangler::mangleInitListElements(const InitListExpr *InitList) {\n  if (auto *Syntactic = InitList->getSyntacticForm())\n    InitList = Syntactic;\n  for (unsigned i = 0, e = InitList->getNumInits(); i != e; ++i)\n    mangleExpression(InitList->getInit(i));\n}\n\nvoid CXXNameMangler::mangleExpression(const Expr *E, unsigned Arity,\n                                      bool AsTemplateArg) {\n  // <expression> ::= <unary operator-name> <expression>\n  //              ::= <binary operator-name> <expression> <expression>\n  //              ::= <trinary operator-name> <expression> <expression> <expression>\n  //              ::= cv <type> expression           # conversion with one argument\n  //              ::= cv <type> _ <expression>* E # conversion with a different number of arguments\n  //              ::= dc <type> <expression>         # dynamic_cast<type> (expression)\n  //              ::= sc <type> <expression>         # static_cast<type> (expression)\n  //              ::= cc <type> <expression>         # const_cast<type> (expression)\n  //              ::= rc <type> <expression>         # reinterpret_cast<type> (expression)\n  //              ::= st <type>                      # sizeof (a type)\n  //              ::= at <type>                      # alignof (a type)\n  //              ::= <template-param>\n  //              ::= <function-param>\n  //              ::= fpT                            # 'this' expression (part of <function-param>)\n  //              ::= sr <type> <unqualified-name>                   # dependent name\n  //              ::= sr <type> <unqualified-name> <template-args>   # dependent template-id\n  //              ::= ds <expression> <expression>                   # expr.*expr\n  //              ::= sZ <template-param>                            # size of a parameter pack\n  //              ::= sZ <function-param>    # size of a function parameter pack\n  //              ::= u <source-name> <template-arg>* E # vendor extended expression\n  //              ::= <expr-primary>\n  // <expr-primary> ::= L <type> <value number> E    # integer literal\n  //                ::= L <type> <value float> E     # floating literal\n  //                ::= L <type> <string type> E     # string literal\n  //                ::= L <nullptr type> E           # nullptr literal \"LDnE\"\n  //                ::= L <pointer type> 0 E         # null pointer template argument\n  //                ::= L <type> <real-part float> _ <imag-part float> E    # complex floating point literal (C99); not used by clang\n  //                ::= L <mangled-name> E           # external name\n  QualType ImplicitlyConvertedToType;\n\n  // A top-level expression that's not <expr-primary> needs to be wrapped in\n  // X...E in a template arg.\n  bool IsPrimaryExpr = true;\n  auto NotPrimaryExpr = [&] {\n    if (AsTemplateArg && IsPrimaryExpr)\n      Out << 'X';\n    IsPrimaryExpr = false;\n  };\n\n  auto MangleDeclRefExpr = [&](const NamedDecl *D) {\n    switch (D->getKind()) {\n    default:\n      //  <expr-primary> ::= L <mangled-name> E # external name\n      Out << 'L';\n      mangle(D);\n      Out << 'E';\n      break;\n\n    case Decl::ParmVar:\n      NotPrimaryExpr();\n      mangleFunctionParam(cast<ParmVarDecl>(D));\n      break;\n\n    case Decl::EnumConstant: {\n      // <expr-primary>\n      const EnumConstantDecl *ED = cast<EnumConstantDecl>(D);\n      mangleIntegerLiteral(ED->getType(), ED->getInitVal());\n      break;\n    }\n\n    case Decl::NonTypeTemplateParm:\n      NotPrimaryExpr();\n      const NonTypeTemplateParmDecl *PD = cast<NonTypeTemplateParmDecl>(D);\n      mangleTemplateParameter(PD->getDepth(), PD->getIndex());\n      break;\n    }\n  };\n\n  // 'goto recurse' is used when handling a simple \"unwrapping\" node which\n  // produces no output, where ImplicitlyConvertedToType and AsTemplateArg need\n  // to be preserved.\nrecurse:\n  switch (E->getStmtClass()) {\n  case Expr::NoStmtClass:\n#define ABSTRACT_STMT(Type)\n#define EXPR(Type, Base)\n#define STMT(Type, Base) \\\n  case Expr::Type##Class:\n#include \"clang/AST/StmtNodes.inc\"\n    // fallthrough\n\n  // These all can only appear in local or variable-initialization\n  // contexts and so should never appear in a mangling.\n  case Expr::AddrLabelExprClass:\n  case Expr::DesignatedInitUpdateExprClass:\n  case Expr::ImplicitValueInitExprClass:\n  case Expr::ArrayInitLoopExprClass:\n  case Expr::ArrayInitIndexExprClass:\n  case Expr::NoInitExprClass:\n  case Expr::ParenListExprClass:\n  case Expr::LambdaExprClass:\n  case Expr::MSPropertyRefExprClass:\n  case Expr::MSPropertySubscriptExprClass:\n  case Expr::TypoExprClass: // This should no longer exist in the AST by now.\n  case Expr::RecoveryExprClass:\n  case Expr::OMPArraySectionExprClass:\n  case Expr::OMPArrayShapingExprClass:\n  case Expr::OMPIteratorExprClass:\n  case Expr::CXXInheritedCtorInitExprClass:\n    llvm_unreachable(\"unexpected statement kind\");\n\n  case Expr::ConstantExprClass:\n    E = cast<ConstantExpr>(E)->getSubExpr();\n    goto recurse;\n\n  // FIXME: invent manglings for all these.\n  case Expr::BlockExprClass:\n  case Expr::ChooseExprClass:\n  case Expr::CompoundLiteralExprClass:\n  case Expr::ExtVectorElementExprClass:\n  case Expr::GenericSelectionExprClass:\n  case Expr::ObjCEncodeExprClass:\n  case Expr::ObjCIsaExprClass:\n  case Expr::ObjCIvarRefExprClass:\n  case Expr::ObjCMessageExprClass:\n  case Expr::ObjCPropertyRefExprClass:\n  case Expr::ObjCProtocolExprClass:\n  case Expr::ObjCSelectorExprClass:\n  case Expr::ObjCStringLiteralClass:\n  case Expr::ObjCBoxedExprClass:\n  case Expr::ObjCArrayLiteralClass:\n  case Expr::ObjCDictionaryLiteralClass:\n  case Expr::ObjCSubscriptRefExprClass:\n  case Expr::ObjCIndirectCopyRestoreExprClass:\n  case Expr::ObjCAvailabilityCheckExprClass:\n  case Expr::OffsetOfExprClass:\n  case Expr::PredefinedExprClass:\n  case Expr::ShuffleVectorExprClass:\n  case Expr::ConvertVectorExprClass:\n  case Expr::StmtExprClass:\n  case Expr::TypeTraitExprClass:\n  case Expr::RequiresExprClass:\n  case Expr::ArrayTypeTraitExprClass:\n  case Expr::ExpressionTraitExprClass:\n  case Expr::VAArgExprClass:\n  case Expr::CUDAKernelCallExprClass:\n  case Expr::AsTypeExprClass:\n  case Expr::PseudoObjectExprClass:\n  case Expr::AtomicExprClass:\n  case Expr::SourceLocExprClass:\n  case Expr::BuiltinBitCastExprClass:\n  {\n    NotPrimaryExpr();\n    if (!NullOut) {\n      // As bad as this diagnostic is, it's better than crashing.\n      DiagnosticsEngine &Diags = Context.getDiags();\n      unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,\n                                       \"cannot yet mangle expression type %0\");\n      Diags.Report(E->getExprLoc(), DiagID)\n        << E->getStmtClassName() << E->getSourceRange();\n      return;\n    }\n    break;\n  }\n\n  case Expr::CXXUuidofExprClass: {\n    NotPrimaryExpr();\n    const CXXUuidofExpr *UE = cast<CXXUuidofExpr>(E);\n    // As of clang 12, uuidof uses the vendor extended expression\n    // mangling. Previously, it used a special-cased nonstandard extension.\n    if (Context.getASTContext().getLangOpts().getClangABICompat() >\n        LangOptions::ClangABI::Ver11) {\n      Out << \"u8__uuidof\";\n      if (UE->isTypeOperand())\n        mangleType(UE->getTypeOperand(Context.getASTContext()));\n      else\n        mangleTemplateArgExpr(UE->getExprOperand());\n      Out << 'E';\n    } else {\n      if (UE->isTypeOperand()) {\n        QualType UuidT = UE->getTypeOperand(Context.getASTContext());\n        Out << \"u8__uuidoft\";\n        mangleType(UuidT);\n      } else {\n        Expr *UuidExp = UE->getExprOperand();\n        Out << \"u8__uuidofz\";\n        mangleExpression(UuidExp);\n      }\n    }\n    break;\n  }\n\n  // Even gcc-4.5 doesn't mangle this.\n  case Expr::BinaryConditionalOperatorClass: {\n    NotPrimaryExpr();\n    DiagnosticsEngine &Diags = Context.getDiags();\n    unsigned DiagID =\n      Diags.getCustomDiagID(DiagnosticsEngine::Error,\n                \"?: operator with omitted middle operand cannot be mangled\");\n    Diags.Report(E->getExprLoc(), DiagID)\n      << E->getStmtClassName() << E->getSourceRange();\n    return;\n  }\n\n  // These are used for internal purposes and cannot be meaningfully mangled.\n  case Expr::OpaqueValueExprClass:\n    llvm_unreachable(\"cannot mangle opaque value; mangling wrong thing?\");\n\n  case Expr::InitListExprClass: {\n    NotPrimaryExpr();\n    Out << \"il\";\n    mangleInitListElements(cast<InitListExpr>(E));\n    Out << \"E\";\n    break;\n  }\n\n  case Expr::DesignatedInitExprClass: {\n    NotPrimaryExpr();\n    auto *DIE = cast<DesignatedInitExpr>(E);\n    for (const auto &Designator : DIE->designators()) {\n      if (Designator.isFieldDesignator()) {\n        Out << \"di\";\n        mangleSourceName(Designator.getFieldName());\n      } else if (Designator.isArrayDesignator()) {\n        Out << \"dx\";\n        mangleExpression(DIE->getArrayIndex(Designator));\n      } else {\n        assert(Designator.isArrayRangeDesignator() &&\n               \"unknown designator kind\");\n        Out << \"dX\";\n        mangleExpression(DIE->getArrayRangeStart(Designator));\n        mangleExpression(DIE->getArrayRangeEnd(Designator));\n      }\n    }\n    mangleExpression(DIE->getInit());\n    break;\n  }\n\n  case Expr::CXXDefaultArgExprClass:\n    E = cast<CXXDefaultArgExpr>(E)->getExpr();\n    goto recurse;\n\n  case Expr::CXXDefaultInitExprClass:\n    E = cast<CXXDefaultInitExpr>(E)->getExpr();\n    goto recurse;\n\n  case Expr::CXXStdInitializerListExprClass:\n    E = cast<CXXStdInitializerListExpr>(E)->getSubExpr();\n    goto recurse;\n\n  case Expr::SubstNonTypeTemplateParmExprClass:\n    E = cast<SubstNonTypeTemplateParmExpr>(E)->getReplacement();\n    goto recurse;\n\n  case Expr::UserDefinedLiteralClass:\n    // We follow g++'s approach of mangling a UDL as a call to the literal\n    // operator.\n  case Expr::CXXMemberCallExprClass: // fallthrough\n  case Expr::CallExprClass: {\n    NotPrimaryExpr();\n    const CallExpr *CE = cast<CallExpr>(E);\n\n    // <expression> ::= cp <simple-id> <expression>* E\n    // We use this mangling only when the call would use ADL except\n    // for being parenthesized.  Per discussion with David\n    // Vandervoorde, 2011.04.25.\n    if (isParenthesizedADLCallee(CE)) {\n      Out << \"cp\";\n      // The callee here is a parenthesized UnresolvedLookupExpr with\n      // no qualifier and should always get mangled as a <simple-id>\n      // anyway.\n\n    // <expression> ::= cl <expression>* E\n    } else {\n      Out << \"cl\";\n    }\n\n    unsigned CallArity = CE->getNumArgs();\n    for (const Expr *Arg : CE->arguments())\n      if (isa<PackExpansionExpr>(Arg))\n        CallArity = UnknownArity;\n\n    mangleExpression(CE->getCallee(), CallArity);\n    for (const Expr *Arg : CE->arguments())\n      mangleExpression(Arg);\n    Out << 'E';\n    break;\n  }\n\n  case Expr::CXXNewExprClass: {\n    NotPrimaryExpr();\n    const CXXNewExpr *New = cast<CXXNewExpr>(E);\n    if (New->isGlobalNew()) Out << \"gs\";\n    Out << (New->isArray() ? \"na\" : \"nw\");\n    for (CXXNewExpr::const_arg_iterator I = New->placement_arg_begin(),\n           E = New->placement_arg_end(); I != E; ++I)\n      mangleExpression(*I);\n    Out << '_';\n    mangleType(New->getAllocatedType());\n    if (New->hasInitializer()) {\n      if (New->getInitializationStyle() == CXXNewExpr::ListInit)\n        Out << \"il\";\n      else\n        Out << \"pi\";\n      const Expr *Init = New->getInitializer();\n      if (const CXXConstructExpr *CCE = dyn_cast<CXXConstructExpr>(Init)) {\n        // Directly inline the initializers.\n        for (CXXConstructExpr::const_arg_iterator I = CCE->arg_begin(),\n                                                  E = CCE->arg_end();\n             I != E; ++I)\n          mangleExpression(*I);\n      } else if (const ParenListExpr *PLE = dyn_cast<ParenListExpr>(Init)) {\n        for (unsigned i = 0, e = PLE->getNumExprs(); i != e; ++i)\n          mangleExpression(PLE->getExpr(i));\n      } else if (New->getInitializationStyle() == CXXNewExpr::ListInit &&\n                 isa<InitListExpr>(Init)) {\n        // Only take InitListExprs apart for list-initialization.\n        mangleInitListElements(cast<InitListExpr>(Init));\n      } else\n        mangleExpression(Init);\n    }\n    Out << 'E';\n    break;\n  }\n\n  case Expr::CXXPseudoDestructorExprClass: {\n    NotPrimaryExpr();\n    const auto *PDE = cast<CXXPseudoDestructorExpr>(E);\n    if (const Expr *Base = PDE->getBase())\n      mangleMemberExprBase(Base, PDE->isArrow());\n    NestedNameSpecifier *Qualifier = PDE->getQualifier();\n    if (TypeSourceInfo *ScopeInfo = PDE->getScopeTypeInfo()) {\n      if (Qualifier) {\n        mangleUnresolvedPrefix(Qualifier,\n                               /*recursive=*/true);\n        mangleUnresolvedTypeOrSimpleId(ScopeInfo->getType());\n        Out << 'E';\n      } else {\n        Out << \"sr\";\n        if (!mangleUnresolvedTypeOrSimpleId(ScopeInfo->getType()))\n          Out << 'E';\n      }\n    } else if (Qualifier) {\n      mangleUnresolvedPrefix(Qualifier);\n    }\n    // <base-unresolved-name> ::= dn <destructor-name>\n    Out << \"dn\";\n    QualType DestroyedType = PDE->getDestroyedType();\n    mangleUnresolvedTypeOrSimpleId(DestroyedType);\n    break;\n  }\n\n  case Expr::MemberExprClass: {\n    NotPrimaryExpr();\n    const MemberExpr *ME = cast<MemberExpr>(E);\n    mangleMemberExpr(ME->getBase(), ME->isArrow(),\n                     ME->getQualifier(), nullptr,\n                     ME->getMemberDecl()->getDeclName(),\n                     ME->getTemplateArgs(), ME->getNumTemplateArgs(),\n                     Arity);\n    break;\n  }\n\n  case Expr::UnresolvedMemberExprClass: {\n    NotPrimaryExpr();\n    const UnresolvedMemberExpr *ME = cast<UnresolvedMemberExpr>(E);\n    mangleMemberExpr(ME->isImplicitAccess() ? nullptr : ME->getBase(),\n                     ME->isArrow(), ME->getQualifier(), nullptr,\n                     ME->getMemberName(),\n                     ME->getTemplateArgs(), ME->getNumTemplateArgs(),\n                     Arity);\n    break;\n  }\n\n  case Expr::CXXDependentScopeMemberExprClass: {\n    NotPrimaryExpr();\n    const CXXDependentScopeMemberExpr *ME\n      = cast<CXXDependentScopeMemberExpr>(E);\n    mangleMemberExpr(ME->isImplicitAccess() ? nullptr : ME->getBase(),\n                     ME->isArrow(), ME->getQualifier(),\n                     ME->getFirstQualifierFoundInScope(),\n                     ME->getMember(),\n                     ME->getTemplateArgs(), ME->getNumTemplateArgs(),\n                     Arity);\n    break;\n  }\n\n  case Expr::UnresolvedLookupExprClass: {\n    NotPrimaryExpr();\n    const UnresolvedLookupExpr *ULE = cast<UnresolvedLookupExpr>(E);\n    mangleUnresolvedName(ULE->getQualifier(), ULE->getName(),\n                         ULE->getTemplateArgs(), ULE->getNumTemplateArgs(),\n                         Arity);\n    break;\n  }\n\n  case Expr::CXXUnresolvedConstructExprClass: {\n    NotPrimaryExpr();\n    const CXXUnresolvedConstructExpr *CE = cast<CXXUnresolvedConstructExpr>(E);\n    unsigned N = CE->getNumArgs();\n\n    if (CE->isListInitialization()) {\n      assert(N == 1 && \"unexpected form for list initialization\");\n      auto *IL = cast<InitListExpr>(CE->getArg(0));\n      Out << \"tl\";\n      mangleType(CE->getType());\n      mangleInitListElements(IL);\n      Out << \"E\";\n      break;\n    }\n\n    Out << \"cv\";\n    mangleType(CE->getType());\n    if (N != 1) Out << '_';\n    for (unsigned I = 0; I != N; ++I) mangleExpression(CE->getArg(I));\n    if (N != 1) Out << 'E';\n    break;\n  }\n\n  case Expr::CXXConstructExprClass: {\n    // An implicit cast is silent, thus may contain <expr-primary>.\n    const auto *CE = cast<CXXConstructExpr>(E);\n    if (!CE->isListInitialization() || CE->isStdInitListInitialization()) {\n      assert(\n          CE->getNumArgs() >= 1 &&\n          (CE->getNumArgs() == 1 || isa<CXXDefaultArgExpr>(CE->getArg(1))) &&\n          \"implicit CXXConstructExpr must have one argument\");\n      E = cast<CXXConstructExpr>(E)->getArg(0);\n      goto recurse;\n    }\n    NotPrimaryExpr();\n    Out << \"il\";\n    for (auto *E : CE->arguments())\n      mangleExpression(E);\n    Out << \"E\";\n    break;\n  }\n\n  case Expr::CXXTemporaryObjectExprClass: {\n    NotPrimaryExpr();\n    const auto *CE = cast<CXXTemporaryObjectExpr>(E);\n    unsigned N = CE->getNumArgs();\n    bool List = CE->isListInitialization();\n\n    if (List)\n      Out << \"tl\";\n    else\n      Out << \"cv\";\n    mangleType(CE->getType());\n    if (!List && N != 1)\n      Out << '_';\n    if (CE->isStdInitListInitialization()) {\n      // We implicitly created a std::initializer_list<T> for the first argument\n      // of a constructor of type U in an expression of the form U{a, b, c}.\n      // Strip all the semantic gunk off the initializer list.\n      auto *SILE =\n          cast<CXXStdInitializerListExpr>(CE->getArg(0)->IgnoreImplicit());\n      auto *ILE = cast<InitListExpr>(SILE->getSubExpr()->IgnoreImplicit());\n      mangleInitListElements(ILE);\n    } else {\n      for (auto *E : CE->arguments())\n        mangleExpression(E);\n    }\n    if (List || N != 1)\n      Out << 'E';\n    break;\n  }\n\n  case Expr::CXXScalarValueInitExprClass:\n    NotPrimaryExpr();\n    Out << \"cv\";\n    mangleType(E->getType());\n    Out << \"_E\";\n    break;\n\n  case Expr::CXXNoexceptExprClass:\n    NotPrimaryExpr();\n    Out << \"nx\";\n    mangleExpression(cast<CXXNoexceptExpr>(E)->getOperand());\n    break;\n\n  case Expr::UnaryExprOrTypeTraitExprClass: {\n    // Non-instantiation-dependent traits are an <expr-primary> integer literal.\n    const UnaryExprOrTypeTraitExpr *SAE = cast<UnaryExprOrTypeTraitExpr>(E);\n\n    if (!SAE->isInstantiationDependent()) {\n      // Itanium C++ ABI:\n      //   If the operand of a sizeof or alignof operator is not\n      //   instantiation-dependent it is encoded as an integer literal\n      //   reflecting the result of the operator.\n      //\n      //   If the result of the operator is implicitly converted to a known\n      //   integer type, that type is used for the literal; otherwise, the type\n      //   of std::size_t or std::ptrdiff_t is used.\n      QualType T = (ImplicitlyConvertedToType.isNull() ||\n                    !ImplicitlyConvertedToType->isIntegerType())? SAE->getType()\n                                                    : ImplicitlyConvertedToType;\n      llvm::APSInt V = SAE->EvaluateKnownConstInt(Context.getASTContext());\n      mangleIntegerLiteral(T, V);\n      break;\n    }\n\n    NotPrimaryExpr(); // But otherwise, they are not.\n\n    auto MangleAlignofSizeofArg = [&] {\n      if (SAE->isArgumentType()) {\n        Out << 't';\n        mangleType(SAE->getArgumentType());\n      } else {\n        Out << 'z';\n        mangleExpression(SAE->getArgumentExpr());\n      }\n    };\n\n    switch(SAE->getKind()) {\n    case UETT_SizeOf:\n      Out << 's';\n      MangleAlignofSizeofArg();\n      break;\n    case UETT_PreferredAlignOf:\n      // As of clang 12, we mangle __alignof__ differently than alignof. (They\n      // have acted differently since Clang 8, but were previously mangled the\n      // same.)\n      if (Context.getASTContext().getLangOpts().getClangABICompat() >\n          LangOptions::ClangABI::Ver11) {\n        Out << \"u11__alignof__\";\n        if (SAE->isArgumentType())\n          mangleType(SAE->getArgumentType());\n        else\n          mangleTemplateArgExpr(SAE->getArgumentExpr());\n        Out << 'E';\n        break;\n      }\n      LLVM_FALLTHROUGH;\n    case UETT_AlignOf:\n      Out << 'a';\n      MangleAlignofSizeofArg();\n      break;\n    case UETT_VecStep: {\n      DiagnosticsEngine &Diags = Context.getDiags();\n      unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,\n                                     \"cannot yet mangle vec_step expression\");\n      Diags.Report(DiagID);\n      return;\n    }\n    case UETT_OpenMPRequiredSimdAlign: {\n      DiagnosticsEngine &Diags = Context.getDiags();\n      unsigned DiagID = Diags.getCustomDiagID(\n          DiagnosticsEngine::Error,\n          \"cannot yet mangle __builtin_omp_required_simd_align expression\");\n      Diags.Report(DiagID);\n      return;\n    }\n    }\n    break;\n  }\n\n  case Expr::CXXThrowExprClass: {\n    NotPrimaryExpr();\n    const CXXThrowExpr *TE = cast<CXXThrowExpr>(E);\n    //  <expression> ::= tw <expression>  # throw expression\n    //               ::= tr               # rethrow\n    if (TE->getSubExpr()) {\n      Out << \"tw\";\n      mangleExpression(TE->getSubExpr());\n    } else {\n      Out << \"tr\";\n    }\n    break;\n  }\n\n  case Expr::CXXTypeidExprClass: {\n    NotPrimaryExpr();\n    const CXXTypeidExpr *TIE = cast<CXXTypeidExpr>(E);\n    //  <expression> ::= ti <type>        # typeid (type)\n    //               ::= te <expression>  # typeid (expression)\n    if (TIE->isTypeOperand()) {\n      Out << \"ti\";\n      mangleType(TIE->getTypeOperand(Context.getASTContext()));\n    } else {\n      Out << \"te\";\n      mangleExpression(TIE->getExprOperand());\n    }\n    break;\n  }\n\n  case Expr::CXXDeleteExprClass: {\n    NotPrimaryExpr();\n    const CXXDeleteExpr *DE = cast<CXXDeleteExpr>(E);\n    //  <expression> ::= [gs] dl <expression>  # [::] delete expr\n    //               ::= [gs] da <expression>  # [::] delete [] expr\n    if (DE->isGlobalDelete()) Out << \"gs\";\n    Out << (DE->isArrayForm() ? \"da\" : \"dl\");\n    mangleExpression(DE->getArgument());\n    break;\n  }\n\n  case Expr::UnaryOperatorClass: {\n    NotPrimaryExpr();\n    const UnaryOperator *UO = cast<UnaryOperator>(E);\n    mangleOperatorName(UnaryOperator::getOverloadedOperator(UO->getOpcode()),\n                       /*Arity=*/1);\n    mangleExpression(UO->getSubExpr());\n    break;\n  }\n\n  case Expr::ArraySubscriptExprClass: {\n    NotPrimaryExpr();\n    const ArraySubscriptExpr *AE = cast<ArraySubscriptExpr>(E);\n\n    // Array subscript is treated as a syntactically weird form of\n    // binary operator.\n    Out << \"ix\";\n    mangleExpression(AE->getLHS());\n    mangleExpression(AE->getRHS());\n    break;\n  }\n\n  case Expr::MatrixSubscriptExprClass: {\n    NotPrimaryExpr();\n    const MatrixSubscriptExpr *ME = cast<MatrixSubscriptExpr>(E);\n    Out << \"ixix\";\n    mangleExpression(ME->getBase());\n    mangleExpression(ME->getRowIdx());\n    mangleExpression(ME->getColumnIdx());\n    break;\n  }\n\n  case Expr::CompoundAssignOperatorClass: // fallthrough\n  case Expr::BinaryOperatorClass: {\n    NotPrimaryExpr();\n    const BinaryOperator *BO = cast<BinaryOperator>(E);\n    if (BO->getOpcode() == BO_PtrMemD)\n      Out << \"ds\";\n    else\n      mangleOperatorName(BinaryOperator::getOverloadedOperator(BO->getOpcode()),\n                         /*Arity=*/2);\n    mangleExpression(BO->getLHS());\n    mangleExpression(BO->getRHS());\n    break;\n  }\n\n  case Expr::CXXRewrittenBinaryOperatorClass: {\n    NotPrimaryExpr();\n    // The mangled form represents the original syntax.\n    CXXRewrittenBinaryOperator::DecomposedForm Decomposed =\n        cast<CXXRewrittenBinaryOperator>(E)->getDecomposedForm();\n    mangleOperatorName(BinaryOperator::getOverloadedOperator(Decomposed.Opcode),\n                       /*Arity=*/2);\n    mangleExpression(Decomposed.LHS);\n    mangleExpression(Decomposed.RHS);\n    break;\n  }\n\n  case Expr::ConditionalOperatorClass: {\n    NotPrimaryExpr();\n    const ConditionalOperator *CO = cast<ConditionalOperator>(E);\n    mangleOperatorName(OO_Conditional, /*Arity=*/3);\n    mangleExpression(CO->getCond());\n    mangleExpression(CO->getLHS(), Arity);\n    mangleExpression(CO->getRHS(), Arity);\n    break;\n  }\n\n  case Expr::ImplicitCastExprClass: {\n    ImplicitlyConvertedToType = E->getType();\n    E = cast<ImplicitCastExpr>(E)->getSubExpr();\n    goto recurse;\n  }\n\n  case Expr::ObjCBridgedCastExprClass: {\n    NotPrimaryExpr();\n    // Mangle ownership casts as a vendor extended operator __bridge,\n    // __bridge_transfer, or __bridge_retain.\n    StringRef Kind = cast<ObjCBridgedCastExpr>(E)->getBridgeKindName();\n    Out << \"v1U\" << Kind.size() << Kind;\n    mangleCastExpression(E, \"cv\");\n    break;\n  }\n\n  case Expr::CStyleCastExprClass:\n    NotPrimaryExpr();\n    mangleCastExpression(E, \"cv\");\n    break;\n\n  case Expr::CXXFunctionalCastExprClass: {\n    NotPrimaryExpr();\n    auto *Sub = cast<ExplicitCastExpr>(E)->getSubExpr()->IgnoreImplicit();\n    // FIXME: Add isImplicit to CXXConstructExpr.\n    if (auto *CCE = dyn_cast<CXXConstructExpr>(Sub))\n      if (CCE->getParenOrBraceRange().isInvalid())\n        Sub = CCE->getArg(0)->IgnoreImplicit();\n    if (auto *StdInitList = dyn_cast<CXXStdInitializerListExpr>(Sub))\n      Sub = StdInitList->getSubExpr()->IgnoreImplicit();\n    if (auto *IL = dyn_cast<InitListExpr>(Sub)) {\n      Out << \"tl\";\n      mangleType(E->getType());\n      mangleInitListElements(IL);\n      Out << \"E\";\n    } else {\n      mangleCastExpression(E, \"cv\");\n    }\n    break;\n  }\n\n  case Expr::CXXStaticCastExprClass:\n    NotPrimaryExpr();\n    mangleCastExpression(E, \"sc\");\n    break;\n  case Expr::CXXDynamicCastExprClass:\n    NotPrimaryExpr();\n    mangleCastExpression(E, \"dc\");\n    break;\n  case Expr::CXXReinterpretCastExprClass:\n    NotPrimaryExpr();\n    mangleCastExpression(E, \"rc\");\n    break;\n  case Expr::CXXConstCastExprClass:\n    NotPrimaryExpr();\n    mangleCastExpression(E, \"cc\");\n    break;\n  case Expr::CXXAddrspaceCastExprClass:\n    NotPrimaryExpr();\n    mangleCastExpression(E, \"ac\");\n    break;\n\n  case Expr::CXXOperatorCallExprClass: {\n    NotPrimaryExpr();\n    const CXXOperatorCallExpr *CE = cast<CXXOperatorCallExpr>(E);\n    unsigned NumArgs = CE->getNumArgs();\n    // A CXXOperatorCallExpr for OO_Arrow models only semantics, not syntax\n    // (the enclosing MemberExpr covers the syntactic portion).\n    if (CE->getOperator() != OO_Arrow)\n      mangleOperatorName(CE->getOperator(), /*Arity=*/NumArgs);\n    // Mangle the arguments.\n    for (unsigned i = 0; i != NumArgs; ++i)\n      mangleExpression(CE->getArg(i));\n    break;\n  }\n\n  case Expr::ParenExprClass:\n    E = cast<ParenExpr>(E)->getSubExpr();\n    goto recurse;\n\n  case Expr::ConceptSpecializationExprClass: {\n    //  <expr-primary> ::= L <mangled-name> E # external name\n    Out << \"L_Z\";\n    auto *CSE = cast<ConceptSpecializationExpr>(E);\n    mangleTemplateName(CSE->getNamedConcept(),\n                       CSE->getTemplateArguments().data(),\n                       CSE->getTemplateArguments().size());\n    Out << 'E';\n    break;\n  }\n\n  case Expr::DeclRefExprClass:\n    // MangleDeclRefExpr helper handles primary-vs-nonprimary\n    MangleDeclRefExpr(cast<DeclRefExpr>(E)->getDecl());\n    break;\n\n  case Expr::SubstNonTypeTemplateParmPackExprClass:\n    NotPrimaryExpr();\n    // FIXME: not clear how to mangle this!\n    // template <unsigned N...> class A {\n    //   template <class U...> void foo(U (&x)[N]...);\n    // };\n    Out << \"_SUBSTPACK_\";\n    break;\n\n  case Expr::FunctionParmPackExprClass: {\n    NotPrimaryExpr();\n    // FIXME: not clear how to mangle this!\n    const FunctionParmPackExpr *FPPE = cast<FunctionParmPackExpr>(E);\n    Out << \"v110_SUBSTPACK\";\n    MangleDeclRefExpr(FPPE->getParameterPack());\n    break;\n  }\n\n  case Expr::DependentScopeDeclRefExprClass: {\n    NotPrimaryExpr();\n    const DependentScopeDeclRefExpr *DRE = cast<DependentScopeDeclRefExpr>(E);\n    mangleUnresolvedName(DRE->getQualifier(), DRE->getDeclName(),\n                         DRE->getTemplateArgs(), DRE->getNumTemplateArgs(),\n                         Arity);\n    break;\n  }\n\n  case Expr::CXXBindTemporaryExprClass:\n    E = cast<CXXBindTemporaryExpr>(E)->getSubExpr();\n    goto recurse;\n\n  case Expr::ExprWithCleanupsClass:\n    E = cast<ExprWithCleanups>(E)->getSubExpr();\n    goto recurse;\n\n  case Expr::FloatingLiteralClass: {\n    // <expr-primary>\n    const FloatingLiteral *FL = cast<FloatingLiteral>(E);\n    mangleFloatLiteral(FL->getType(), FL->getValue());\n    break;\n  }\n\n  case Expr::FixedPointLiteralClass:\n    // Currently unimplemented -- might be <expr-primary> in future?\n    mangleFixedPointLiteral();\n    break;\n\n  case Expr::CharacterLiteralClass:\n    // <expr-primary>\n    Out << 'L';\n    mangleType(E->getType());\n    Out << cast<CharacterLiteral>(E)->getValue();\n    Out << 'E';\n    break;\n\n  // FIXME. __objc_yes/__objc_no are mangled same as true/false\n  case Expr::ObjCBoolLiteralExprClass:\n    // <expr-primary>\n    Out << \"Lb\";\n    Out << (cast<ObjCBoolLiteralExpr>(E)->getValue() ? '1' : '0');\n    Out << 'E';\n    break;\n\n  case Expr::CXXBoolLiteralExprClass:\n    // <expr-primary>\n    Out << \"Lb\";\n    Out << (cast<CXXBoolLiteralExpr>(E)->getValue() ? '1' : '0');\n    Out << 'E';\n    break;\n\n  case Expr::IntegerLiteralClass: {\n    // <expr-primary>\n    llvm::APSInt Value(cast<IntegerLiteral>(E)->getValue());\n    if (E->getType()->isSignedIntegerType())\n      Value.setIsSigned(true);\n    mangleIntegerLiteral(E->getType(), Value);\n    break;\n  }\n\n  case Expr::ImaginaryLiteralClass: {\n    // <expr-primary>\n    const ImaginaryLiteral *IE = cast<ImaginaryLiteral>(E);\n    // Mangle as if a complex literal.\n    // Proposal from David Vandevoorde, 2010.06.30.\n    Out << 'L';\n    mangleType(E->getType());\n    if (const FloatingLiteral *Imag =\n          dyn_cast<FloatingLiteral>(IE->getSubExpr())) {\n      // Mangle a floating-point zero of the appropriate type.\n      mangleFloat(llvm::APFloat(Imag->getValue().getSemantics()));\n      Out << '_';\n      mangleFloat(Imag->getValue());\n    } else {\n      Out << \"0_\";\n      llvm::APSInt Value(cast<IntegerLiteral>(IE->getSubExpr())->getValue());\n      if (IE->getSubExpr()->getType()->isSignedIntegerType())\n        Value.setIsSigned(true);\n      mangleNumber(Value);\n    }\n    Out << 'E';\n    break;\n  }\n\n  case Expr::StringLiteralClass: {\n    // <expr-primary>\n    // Revised proposal from David Vandervoorde, 2010.07.15.\n    Out << 'L';\n    assert(isa<ConstantArrayType>(E->getType()));\n    mangleType(E->getType());\n    Out << 'E';\n    break;\n  }\n\n  case Expr::GNUNullExprClass:\n    // <expr-primary>\n    // Mangle as if an integer literal 0.\n    mangleIntegerLiteral(E->getType(), llvm::APSInt(32));\n    break;\n\n  case Expr::CXXNullPtrLiteralExprClass: {\n    // <expr-primary>\n    Out << \"LDnE\";\n    break;\n  }\n\n  case Expr::PackExpansionExprClass:\n    NotPrimaryExpr();\n    Out << \"sp\";\n    mangleExpression(cast<PackExpansionExpr>(E)->getPattern());\n    break;\n\n  case Expr::SizeOfPackExprClass: {\n    NotPrimaryExpr();\n    auto *SPE = cast<SizeOfPackExpr>(E);\n    if (SPE->isPartiallySubstituted()) {\n      Out << \"sP\";\n      for (const auto &A : SPE->getPartialArguments())\n        mangleTemplateArg(A, false);\n      Out << \"E\";\n      break;\n    }\n\n    Out << \"sZ\";\n    const NamedDecl *Pack = SPE->getPack();\n    if (const TemplateTypeParmDecl *TTP = dyn_cast<TemplateTypeParmDecl>(Pack))\n      mangleTemplateParameter(TTP->getDepth(), TTP->getIndex());\n    else if (const NonTypeTemplateParmDecl *NTTP\n                = dyn_cast<NonTypeTemplateParmDecl>(Pack))\n      mangleTemplateParameter(NTTP->getDepth(), NTTP->getIndex());\n    else if (const TemplateTemplateParmDecl *TempTP\n                                    = dyn_cast<TemplateTemplateParmDecl>(Pack))\n      mangleTemplateParameter(TempTP->getDepth(), TempTP->getIndex());\n    else\n      mangleFunctionParam(cast<ParmVarDecl>(Pack));\n    break;\n  }\n\n  case Expr::MaterializeTemporaryExprClass:\n    E = cast<MaterializeTemporaryExpr>(E)->getSubExpr();\n    goto recurse;\n\n  case Expr::CXXFoldExprClass: {\n    NotPrimaryExpr();\n    auto *FE = cast<CXXFoldExpr>(E);\n    if (FE->isLeftFold())\n      Out << (FE->getInit() ? \"fL\" : \"fl\");\n    else\n      Out << (FE->getInit() ? \"fR\" : \"fr\");\n\n    if (FE->getOperator() == BO_PtrMemD)\n      Out << \"ds\";\n    else\n      mangleOperatorName(\n          BinaryOperator::getOverloadedOperator(FE->getOperator()),\n          /*Arity=*/2);\n\n    if (FE->getLHS())\n      mangleExpression(FE->getLHS());\n    if (FE->getRHS())\n      mangleExpression(FE->getRHS());\n    break;\n  }\n\n  case Expr::CXXThisExprClass:\n    NotPrimaryExpr();\n    Out << \"fpT\";\n    break;\n\n  case Expr::CoawaitExprClass:\n    // FIXME: Propose a non-vendor mangling.\n    NotPrimaryExpr();\n    Out << \"v18co_await\";\n    mangleExpression(cast<CoawaitExpr>(E)->getOperand());\n    break;\n\n  case Expr::DependentCoawaitExprClass:\n    // FIXME: Propose a non-vendor mangling.\n    NotPrimaryExpr();\n    Out << \"v18co_await\";\n    mangleExpression(cast<DependentCoawaitExpr>(E)->getOperand());\n    break;\n\n  case Expr::CoyieldExprClass:\n    // FIXME: Propose a non-vendor mangling.\n    NotPrimaryExpr();\n    Out << \"v18co_yield\";\n    mangleExpression(cast<CoawaitExpr>(E)->getOperand());\n    break;\n  }\n\n  if (AsTemplateArg && !IsPrimaryExpr)\n    Out << 'E';\n}\n\n/// Mangle an expression which refers to a parameter variable.\n///\n/// <expression>     ::= <function-param>\n/// <function-param> ::= fp <top-level CV-qualifiers> _      # L == 0, I == 0\n/// <function-param> ::= fp <top-level CV-qualifiers>\n///                      <parameter-2 non-negative number> _ # L == 0, I > 0\n/// <function-param> ::= fL <L-1 non-negative number>\n///                      p <top-level CV-qualifiers> _       # L > 0, I == 0\n/// <function-param> ::= fL <L-1 non-negative number>\n///                      p <top-level CV-qualifiers>\n///                      <I-1 non-negative number> _         # L > 0, I > 0\n///\n/// L is the nesting depth of the parameter, defined as 1 if the\n/// parameter comes from the innermost function prototype scope\n/// enclosing the current context, 2 if from the next enclosing\n/// function prototype scope, and so on, with one special case: if\n/// we've processed the full parameter clause for the innermost\n/// function type, then L is one less.  This definition conveniently\n/// makes it irrelevant whether a function's result type was written\n/// trailing or leading, but is otherwise overly complicated; the\n/// numbering was first designed without considering references to\n/// parameter in locations other than return types, and then the\n/// mangling had to be generalized without changing the existing\n/// manglings.\n///\n/// I is the zero-based index of the parameter within its parameter\n/// declaration clause.  Note that the original ABI document describes\n/// this using 1-based ordinals.\nvoid CXXNameMangler::mangleFunctionParam(const ParmVarDecl *parm) {\n  unsigned parmDepth = parm->getFunctionScopeDepth();\n  unsigned parmIndex = parm->getFunctionScopeIndex();\n\n  // Compute 'L'.\n  // parmDepth does not include the declaring function prototype.\n  // FunctionTypeDepth does account for that.\n  assert(parmDepth < FunctionTypeDepth.getDepth());\n  unsigned nestingDepth = FunctionTypeDepth.getDepth() - parmDepth;\n  if (FunctionTypeDepth.isInResultType())\n    nestingDepth--;\n\n  if (nestingDepth == 0) {\n    Out << \"fp\";\n  } else {\n    Out << \"fL\" << (nestingDepth - 1) << 'p';\n  }\n\n  // Top-level qualifiers.  We don't have to worry about arrays here,\n  // because parameters declared as arrays should already have been\n  // transformed to have pointer type. FIXME: apparently these don't\n  // get mangled if used as an rvalue of a known non-class type?\n  assert(!parm->getType()->isArrayType()\n         && \"parameter's type is still an array type?\");\n\n  if (const DependentAddressSpaceType *DAST =\n      dyn_cast<DependentAddressSpaceType>(parm->getType())) {\n    mangleQualifiers(DAST->getPointeeType().getQualifiers(), DAST);\n  } else {\n    mangleQualifiers(parm->getType().getQualifiers());\n  }\n\n  // Parameter index.\n  if (parmIndex != 0) {\n    Out << (parmIndex - 1);\n  }\n  Out << '_';\n}\n\nvoid CXXNameMangler::mangleCXXCtorType(CXXCtorType T,\n                                       const CXXRecordDecl *InheritedFrom) {\n  // <ctor-dtor-name> ::= C1  # complete object constructor\n  //                  ::= C2  # base object constructor\n  //                  ::= CI1 <type> # complete inheriting constructor\n  //                  ::= CI2 <type> # base inheriting constructor\n  //\n  // In addition, C5 is a comdat name with C1 and C2 in it.\n  Out << 'C';\n  if (InheritedFrom)\n    Out << 'I';\n  switch (T) {\n  case Ctor_Complete:\n    Out << '1';\n    break;\n  case Ctor_Base:\n    Out << '2';\n    break;\n  case Ctor_Comdat:\n    Out << '5';\n    break;\n  case Ctor_DefaultClosure:\n  case Ctor_CopyingClosure:\n    llvm_unreachable(\"closure constructors don't exist for the Itanium ABI!\");\n  }\n  if (InheritedFrom)\n    mangleName(InheritedFrom);\n}\n\nvoid CXXNameMangler::mangleCXXDtorType(CXXDtorType T) {\n  // <ctor-dtor-name> ::= D0  # deleting destructor\n  //                  ::= D1  # complete object destructor\n  //                  ::= D2  # base object destructor\n  //\n  // In addition, D5 is a comdat name with D1, D2 and, if virtual, D0 in it.\n  switch (T) {\n  case Dtor_Deleting:\n    Out << \"D0\";\n    break;\n  case Dtor_Complete:\n    Out << \"D1\";\n    break;\n  case Dtor_Base:\n    Out << \"D2\";\n    break;\n  case Dtor_Comdat:\n    Out << \"D5\";\n    break;\n  }\n}\n\nnamespace {\n// Helper to provide ancillary information on a template used to mangle its\n// arguments.\nstruct TemplateArgManglingInfo {\n  TemplateDecl *ResolvedTemplate = nullptr;\n  bool SeenPackExpansionIntoNonPack = false;\n  const NamedDecl *UnresolvedExpandedPack = nullptr;\n\n  TemplateArgManglingInfo(TemplateName TN) {\n    if (TemplateDecl *TD = TN.getAsTemplateDecl())\n      ResolvedTemplate = TD;\n  }\n\n  /// Do we need to mangle template arguments with exactly correct types?\n  ///\n  /// This should be called exactly once for each parameter / argument pair, in\n  /// order.\n  bool needExactType(unsigned ParamIdx, const TemplateArgument &Arg) {\n    // We need correct types when the template-name is unresolved or when it\n    // names a template that is able to be overloaded.\n    if (!ResolvedTemplate || SeenPackExpansionIntoNonPack)\n      return true;\n\n    // Move to the next parameter.\n    const NamedDecl *Param = UnresolvedExpandedPack;\n    if (!Param) {\n      assert(ParamIdx < ResolvedTemplate->getTemplateParameters()->size() &&\n             \"no parameter for argument\");\n      Param = ResolvedTemplate->getTemplateParameters()->getParam(ParamIdx);\n\n      // If we reach an expanded parameter pack whose argument isn't in pack\n      // form, that means Sema couldn't figure out which arguments belonged to\n      // it, because it contains a pack expansion. Track the expanded pack for\n      // all further template arguments until we hit that pack expansion.\n      if (Param->isParameterPack() && Arg.getKind() != TemplateArgument::Pack) {\n        assert(getExpandedPackSize(Param) &&\n               \"failed to form pack argument for parameter pack\");\n        UnresolvedExpandedPack = Param;\n      }\n    }\n\n    // If we encounter a pack argument that is expanded into a non-pack\n    // parameter, we can no longer track parameter / argument correspondence,\n    // and need to use exact types from this point onwards.\n    if (Arg.isPackExpansion() &&\n        (!Param->isParameterPack() || UnresolvedExpandedPack)) {\n      SeenPackExpansionIntoNonPack = true;\n      return true;\n    }\n\n    // We need exact types for function template arguments because they might be\n    // overloaded on template parameter type. As a special case, a member\n    // function template of a generic lambda is not overloadable.\n    if (auto *FTD = dyn_cast<FunctionTemplateDecl>(ResolvedTemplate)) {\n      auto *RD = dyn_cast<CXXRecordDecl>(FTD->getDeclContext());\n      if (!RD || !RD->isGenericLambda())\n        return true;\n    }\n\n    // Otherwise, we only need a correct type if the parameter has a deduced\n    // type.\n    //\n    // Note: for an expanded parameter pack, getType() returns the type prior\n    // to expansion. We could ask for the expanded type with getExpansionType(),\n    // but it doesn't matter because substitution and expansion don't affect\n    // whether a deduced type appears in the type.\n    auto *NTTP = dyn_cast<NonTypeTemplateParmDecl>(Param);\n    return NTTP && NTTP->getType()->getContainedDeducedType();\n  }\n};\n}\n\nvoid CXXNameMangler::mangleTemplateArgs(TemplateName TN,\n                                        const TemplateArgumentLoc *TemplateArgs,\n                                        unsigned NumTemplateArgs) {\n  // <template-args> ::= I <template-arg>+ E\n  Out << 'I';\n  TemplateArgManglingInfo Info(TN);\n  for (unsigned i = 0; i != NumTemplateArgs; ++i)\n    mangleTemplateArg(TemplateArgs[i].getArgument(),\n                      Info.needExactType(i, TemplateArgs[i].getArgument()));\n  Out << 'E';\n}\n\nvoid CXXNameMangler::mangleTemplateArgs(TemplateName TN,\n                                        const TemplateArgumentList &AL) {\n  // <template-args> ::= I <template-arg>+ E\n  Out << 'I';\n  TemplateArgManglingInfo Info(TN);\n  for (unsigned i = 0, e = AL.size(); i != e; ++i)\n    mangleTemplateArg(AL[i], Info.needExactType(i, AL[i]));\n  Out << 'E';\n}\n\nvoid CXXNameMangler::mangleTemplateArgs(TemplateName TN,\n                                        const TemplateArgument *TemplateArgs,\n                                        unsigned NumTemplateArgs) {\n  // <template-args> ::= I <template-arg>+ E\n  Out << 'I';\n  TemplateArgManglingInfo Info(TN);\n  for (unsigned i = 0; i != NumTemplateArgs; ++i)\n    mangleTemplateArg(TemplateArgs[i], Info.needExactType(i, TemplateArgs[i]));\n  Out << 'E';\n}\n\nvoid CXXNameMangler::mangleTemplateArg(TemplateArgument A, bool NeedExactType) {\n  // <template-arg> ::= <type>              # type or template\n  //                ::= X <expression> E    # expression\n  //                ::= <expr-primary>      # simple expressions\n  //                ::= J <template-arg>* E # argument pack\n  if (!A.isInstantiationDependent() || A.isDependent())\n    A = Context.getASTContext().getCanonicalTemplateArgument(A);\n\n  switch (A.getKind()) {\n  case TemplateArgument::Null:\n    llvm_unreachable(\"Cannot mangle NULL template argument\");\n\n  case TemplateArgument::Type:\n    mangleType(A.getAsType());\n    break;\n  case TemplateArgument::Template:\n    // This is mangled as <type>.\n    mangleType(A.getAsTemplate());\n    break;\n  case TemplateArgument::TemplateExpansion:\n    // <type>  ::= Dp <type>          # pack expansion (C++0x)\n    Out << \"Dp\";\n    mangleType(A.getAsTemplateOrTemplatePattern());\n    break;\n  case TemplateArgument::Expression:\n    mangleTemplateArgExpr(A.getAsExpr());\n    break;\n  case TemplateArgument::Integral:\n    mangleIntegerLiteral(A.getIntegralType(), A.getAsIntegral());\n    break;\n  case TemplateArgument::Declaration: {\n    //  <expr-primary> ::= L <mangled-name> E # external name\n    ValueDecl *D = A.getAsDecl();\n\n    // Template parameter objects are modeled by reproducing a source form\n    // produced as if by aggregate initialization.\n    if (A.getParamTypeForDecl()->isRecordType()) {\n      auto *TPO = cast<TemplateParamObjectDecl>(D);\n      mangleValueInTemplateArg(TPO->getType().getUnqualifiedType(),\n                               TPO->getValue(), /*TopLevel=*/true,\n                               NeedExactType);\n      break;\n    }\n\n    ASTContext &Ctx = Context.getASTContext();\n    APValue Value;\n    if (D->isCXXInstanceMember())\n      // Simple pointer-to-member with no conversion.\n      Value = APValue(D, /*IsDerivedMember=*/false, /*Path=*/{});\n    else if (D->getType()->isArrayType() &&\n             Ctx.hasSimilarType(Ctx.getDecayedType(D->getType()),\n                                A.getParamTypeForDecl()) &&\n             Ctx.getLangOpts().getClangABICompat() >\n                 LangOptions::ClangABI::Ver11)\n      // Build a value corresponding to this implicit array-to-pointer decay.\n      Value = APValue(APValue::LValueBase(D), CharUnits::Zero(),\n                      {APValue::LValuePathEntry::ArrayIndex(0)},\n                      /*OnePastTheEnd=*/false);\n    else\n      // Regular pointer or reference to a declaration.\n      Value = APValue(APValue::LValueBase(D), CharUnits::Zero(),\n                      ArrayRef<APValue::LValuePathEntry>(),\n                      /*OnePastTheEnd=*/false);\n    mangleValueInTemplateArg(A.getParamTypeForDecl(), Value, /*TopLevel=*/true,\n                             NeedExactType);\n    break;\n  }\n  case TemplateArgument::NullPtr: {\n    mangleNullPointer(A.getNullPtrType());\n    break;\n  }\n  case TemplateArgument::Pack: {\n    //  <template-arg> ::= J <template-arg>* E\n    Out << 'J';\n    for (const auto &P : A.pack_elements())\n      mangleTemplateArg(P, NeedExactType);\n    Out << 'E';\n  }\n  }\n}\n\nvoid CXXNameMangler::mangleTemplateArgExpr(const Expr *E) {\n  ASTContext &Ctx = Context.getASTContext();\n  if (Ctx.getLangOpts().getClangABICompat() > LangOptions::ClangABI::Ver11) {\n    mangleExpression(E, UnknownArity, /*AsTemplateArg=*/true);\n    return;\n  }\n\n  // Prior to Clang 12, we didn't omit the X .. E around <expr-primary>\n  // correctly in cases where the template argument was\n  // constructed from an expression rather than an already-evaluated\n  // literal. In such a case, we would then e.g. emit 'XLi0EE' instead of\n  // 'Li0E'.\n  //\n  // We did special-case DeclRefExpr to attempt to DTRT for that one\n  // expression-kind, but while doing so, unfortunately handled ParmVarDecl\n  // (subtype of VarDecl) _incorrectly_, and emitted 'L_Z .. E' instead of\n  // the proper 'Xfp_E'.\n  E = E->IgnoreParenImpCasts();\n  if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E)) {\n    const ValueDecl *D = DRE->getDecl();\n    if (isa<VarDecl>(D) || isa<FunctionDecl>(D)) {\n      Out << 'L';\n      mangle(D);\n      Out << 'E';\n      return;\n    }\n  }\n  Out << 'X';\n  mangleExpression(E);\n  Out << 'E';\n}\n\n/// Determine whether a given value is equivalent to zero-initialization for\n/// the purpose of discarding a trailing portion of a 'tl' mangling.\n///\n/// Note that this is not in general equivalent to determining whether the\n/// value has an all-zeroes bit pattern.\nstatic bool isZeroInitialized(QualType T, const APValue &V) {\n  // FIXME: mangleValueInTemplateArg has quadratic time complexity in\n  // pathological cases due to using this, but it's a little awkward\n  // to do this in linear time in general.\n  switch (V.getKind()) {\n  case APValue::None:\n  case APValue::Indeterminate:\n  case APValue::AddrLabelDiff:\n    return false;\n\n  case APValue::Struct: {\n    const CXXRecordDecl *RD = T->getAsCXXRecordDecl();\n    assert(RD && \"unexpected type for record value\");\n    unsigned I = 0;\n    for (const CXXBaseSpecifier &BS : RD->bases()) {\n      if (!isZeroInitialized(BS.getType(), V.getStructBase(I)))\n        return false;\n      ++I;\n    }\n    I = 0;\n    for (const FieldDecl *FD : RD->fields()) {\n      if (!FD->isUnnamedBitfield() &&\n          !isZeroInitialized(FD->getType(), V.getStructField(I)))\n        return false;\n      ++I;\n    }\n    return true;\n  }\n\n  case APValue::Union: {\n    const CXXRecordDecl *RD = T->getAsCXXRecordDecl();\n    assert(RD && \"unexpected type for union value\");\n    // Zero-initialization zeroes the first non-unnamed-bitfield field, if any.\n    for (const FieldDecl *FD : RD->fields()) {\n      if (!FD->isUnnamedBitfield())\n        return V.getUnionField() && declaresSameEntity(FD, V.getUnionField()) &&\n               isZeroInitialized(FD->getType(), V.getUnionValue());\n    }\n    // If there are no fields (other than unnamed bitfields), the value is\n    // necessarily zero-initialized.\n    return true;\n  }\n\n  case APValue::Array: {\n    QualType ElemT(T->getArrayElementTypeNoTypeQual(), 0);\n    for (unsigned I = 0, N = V.getArrayInitializedElts(); I != N; ++I)\n      if (!isZeroInitialized(ElemT, V.getArrayInitializedElt(I)))\n        return false;\n    return !V.hasArrayFiller() || isZeroInitialized(ElemT, V.getArrayFiller());\n  }\n\n  case APValue::Vector: {\n    const VectorType *VT = T->castAs<VectorType>();\n    for (unsigned I = 0, N = V.getVectorLength(); I != N; ++I)\n      if (!isZeroInitialized(VT->getElementType(), V.getVectorElt(I)))\n        return false;\n    return true;\n  }\n\n  case APValue::Int:\n    return !V.getInt();\n\n  case APValue::Float:\n    return V.getFloat().isPosZero();\n\n  case APValue::FixedPoint:\n    return !V.getFixedPoint().getValue();\n\n  case APValue::ComplexFloat:\n    return V.getComplexFloatReal().isPosZero() &&\n           V.getComplexFloatImag().isPosZero();\n\n  case APValue::ComplexInt:\n    return !V.getComplexIntReal() && !V.getComplexIntImag();\n\n  case APValue::LValue:\n    return V.isNullPointer();\n\n  case APValue::MemberPointer:\n    return !V.getMemberPointerDecl();\n  }\n\n  llvm_unreachable(\"Unhandled APValue::ValueKind enum\");\n}\n\nstatic QualType getLValueType(ASTContext &Ctx, const APValue &LV) {\n  QualType T = LV.getLValueBase().getType();\n  for (APValue::LValuePathEntry E : LV.getLValuePath()) {\n    if (const ArrayType *AT = Ctx.getAsArrayType(T))\n      T = AT->getElementType();\n    else if (const FieldDecl *FD =\n                 dyn_cast<FieldDecl>(E.getAsBaseOrMember().getPointer()))\n      T = FD->getType();\n    else\n      T = Ctx.getRecordType(\n          cast<CXXRecordDecl>(E.getAsBaseOrMember().getPointer()));\n  }\n  return T;\n}\n\nvoid CXXNameMangler::mangleValueInTemplateArg(QualType T, const APValue &V,\n                                              bool TopLevel,\n                                              bool NeedExactType) {\n  // Ignore all top-level cv-qualifiers, to match GCC.\n  Qualifiers Quals;\n  T = getASTContext().getUnqualifiedArrayType(T, Quals);\n\n  // A top-level expression that's not a primary expression is wrapped in X...E.\n  bool IsPrimaryExpr = true;\n  auto NotPrimaryExpr = [&] {\n    if (TopLevel && IsPrimaryExpr)\n      Out << 'X';\n    IsPrimaryExpr = false;\n  };\n\n  // Proposed in https://github.com/itanium-cxx-abi/cxx-abi/issues/63.\n  switch (V.getKind()) {\n  case APValue::None:\n  case APValue::Indeterminate:\n    Out << 'L';\n    mangleType(T);\n    Out << 'E';\n    break;\n\n  case APValue::AddrLabelDiff:\n    llvm_unreachable(\"unexpected value kind in template argument\");\n\n  case APValue::Struct: {\n    const CXXRecordDecl *RD = T->getAsCXXRecordDecl();\n    assert(RD && \"unexpected type for record value\");\n\n    // Drop trailing zero-initialized elements.\n    llvm::SmallVector<const FieldDecl *, 16> Fields(RD->field_begin(),\n                                                    RD->field_end());\n    while (\n        !Fields.empty() &&\n        (Fields.back()->isUnnamedBitfield() ||\n         isZeroInitialized(Fields.back()->getType(),\n                           V.getStructField(Fields.back()->getFieldIndex())))) {\n      Fields.pop_back();\n    }\n    llvm::ArrayRef<CXXBaseSpecifier> Bases(RD->bases_begin(), RD->bases_end());\n    if (Fields.empty()) {\n      while (!Bases.empty() &&\n             isZeroInitialized(Bases.back().getType(),\n                               V.getStructBase(Bases.size() - 1)))\n        Bases = Bases.drop_back();\n    }\n\n    // <expression> ::= tl <type> <braced-expression>* E\n    NotPrimaryExpr();\n    Out << \"tl\";\n    mangleType(T);\n    for (unsigned I = 0, N = Bases.size(); I != N; ++I)\n      mangleValueInTemplateArg(Bases[I].getType(), V.getStructBase(I), false);\n    for (unsigned I = 0, N = Fields.size(); I != N; ++I) {\n      if (Fields[I]->isUnnamedBitfield())\n        continue;\n      mangleValueInTemplateArg(Fields[I]->getType(),\n                               V.getStructField(Fields[I]->getFieldIndex()),\n                               false);\n    }\n    Out << 'E';\n    break;\n  }\n\n  case APValue::Union: {\n    assert(T->getAsCXXRecordDecl() && \"unexpected type for union value\");\n    const FieldDecl *FD = V.getUnionField();\n\n    if (!FD) {\n      Out << 'L';\n      mangleType(T);\n      Out << 'E';\n      break;\n    }\n\n    // <braced-expression> ::= di <field source-name> <braced-expression>\n    NotPrimaryExpr();\n    Out << \"tl\";\n    mangleType(T);\n    if (!isZeroInitialized(T, V)) {\n      Out << \"di\";\n      mangleSourceName(FD->getIdentifier());\n      mangleValueInTemplateArg(FD->getType(), V.getUnionValue(), false);\n    }\n    Out << 'E';\n    break;\n  }\n\n  case APValue::Array: {\n    QualType ElemT(T->getArrayElementTypeNoTypeQual(), 0);\n\n    NotPrimaryExpr();\n    Out << \"tl\";\n    mangleType(T);\n\n    // Drop trailing zero-initialized elements.\n    unsigned N = V.getArraySize();\n    if (!V.hasArrayFiller() || isZeroInitialized(ElemT, V.getArrayFiller())) {\n      N = V.getArrayInitializedElts();\n      while (N && isZeroInitialized(ElemT, V.getArrayInitializedElt(N - 1)))\n        --N;\n    }\n\n    for (unsigned I = 0; I != N; ++I) {\n      const APValue &Elem = I < V.getArrayInitializedElts()\n                                ? V.getArrayInitializedElt(I)\n                                : V.getArrayFiller();\n      mangleValueInTemplateArg(ElemT, Elem, false);\n    }\n    Out << 'E';\n    break;\n  }\n\n  case APValue::Vector: {\n    const VectorType *VT = T->castAs<VectorType>();\n\n    NotPrimaryExpr();\n    Out << \"tl\";\n    mangleType(T);\n    unsigned N = V.getVectorLength();\n    while (N && isZeroInitialized(VT->getElementType(), V.getVectorElt(N - 1)))\n      --N;\n    for (unsigned I = 0; I != N; ++I)\n      mangleValueInTemplateArg(VT->getElementType(), V.getVectorElt(I), false);\n    Out << 'E';\n    break;\n  }\n\n  case APValue::Int:\n    mangleIntegerLiteral(T, V.getInt());\n    break;\n\n  case APValue::Float:\n    mangleFloatLiteral(T, V.getFloat());\n    break;\n\n  case APValue::FixedPoint:\n    mangleFixedPointLiteral();\n    break;\n\n  case APValue::ComplexFloat: {\n    const ComplexType *CT = T->castAs<ComplexType>();\n    NotPrimaryExpr();\n    Out << \"tl\";\n    mangleType(T);\n    if (!V.getComplexFloatReal().isPosZero() ||\n        !V.getComplexFloatImag().isPosZero())\n      mangleFloatLiteral(CT->getElementType(), V.getComplexFloatReal());\n    if (!V.getComplexFloatImag().isPosZero())\n      mangleFloatLiteral(CT->getElementType(), V.getComplexFloatImag());\n    Out << 'E';\n    break;\n  }\n\n  case APValue::ComplexInt: {\n    const ComplexType *CT = T->castAs<ComplexType>();\n    NotPrimaryExpr();\n    Out << \"tl\";\n    mangleType(T);\n    if (V.getComplexIntReal().getBoolValue() ||\n        V.getComplexIntImag().getBoolValue())\n      mangleIntegerLiteral(CT->getElementType(), V.getComplexIntReal());\n    if (V.getComplexIntImag().getBoolValue())\n      mangleIntegerLiteral(CT->getElementType(), V.getComplexIntImag());\n    Out << 'E';\n    break;\n  }\n\n  case APValue::LValue: {\n    // Proposed in https://github.com/itanium-cxx-abi/cxx-abi/issues/47.\n    assert((T->isPointerType() || T->isReferenceType()) &&\n           \"unexpected type for LValue template arg\");\n\n    if (V.isNullPointer()) {\n      mangleNullPointer(T);\n      break;\n    }\n\n    APValue::LValueBase B = V.getLValueBase();\n    if (!B) {\n      // Non-standard mangling for integer cast to a pointer; this can only\n      // occur as an extension.\n      CharUnits Offset = V.getLValueOffset();\n      if (Offset.isZero()) {\n        // This is reinterpret_cast<T*>(0), not a null pointer. Mangle this as\n        // a cast, because L <type> 0 E means something else.\n        NotPrimaryExpr();\n        Out << \"rc\";\n        mangleType(T);\n        Out << \"Li0E\";\n        if (TopLevel)\n          Out << 'E';\n      } else {\n        Out << \"L\";\n        mangleType(T);\n        Out << Offset.getQuantity() << 'E';\n      }\n      break;\n    }\n\n    ASTContext &Ctx = Context.getASTContext();\n\n    enum { Base, Offset, Path } Kind;\n    if (!V.hasLValuePath()) {\n      // Mangle as (T*)((char*)&base + N).\n      if (T->isReferenceType()) {\n        NotPrimaryExpr();\n        Out << \"decvP\";\n        mangleType(T->getPointeeType());\n      } else {\n        NotPrimaryExpr();\n        Out << \"cv\";\n        mangleType(T);\n      }\n      Out << \"plcvPcad\";\n      Kind = Offset;\n    } else {\n      if (!V.getLValuePath().empty() || V.isLValueOnePastTheEnd()) {\n        NotPrimaryExpr();\n        // A final conversion to the template parameter's type is usually\n        // folded into the 'so' mangling, but we can't do that for 'void*'\n        // parameters without introducing collisions.\n        if (NeedExactType && T->isVoidPointerType()) {\n          Out << \"cv\";\n          mangleType(T);\n        }\n        if (T->isPointerType())\n          Out << \"ad\";\n        Out << \"so\";\n        mangleType(T->isVoidPointerType()\n                       ? getLValueType(Ctx, V).getUnqualifiedType()\n                       : T->getPointeeType());\n        Kind = Path;\n      } else {\n        if (NeedExactType &&\n            !Ctx.hasSameType(T->getPointeeType(), getLValueType(Ctx, V)) &&\n            Ctx.getLangOpts().getClangABICompat() >\n                LangOptions::ClangABI::Ver11) {\n          NotPrimaryExpr();\n          Out << \"cv\";\n          mangleType(T);\n        }\n        if (T->isPointerType()) {\n          NotPrimaryExpr();\n          Out << \"ad\";\n        }\n        Kind = Base;\n      }\n    }\n\n    QualType TypeSoFar = B.getType();\n    if (auto *VD = B.dyn_cast<const ValueDecl*>()) {\n      Out << 'L';\n      mangle(VD);\n      Out << 'E';\n    } else if (auto *E = B.dyn_cast<const Expr*>()) {\n      NotPrimaryExpr();\n      mangleExpression(E);\n    } else if (auto TI = B.dyn_cast<TypeInfoLValue>()) {\n      NotPrimaryExpr();\n      Out << \"ti\";\n      mangleType(QualType(TI.getType(), 0));\n    } else {\n      // We should never see dynamic allocations here.\n      llvm_unreachable(\"unexpected lvalue base kind in template argument\");\n    }\n\n    switch (Kind) {\n    case Base:\n      break;\n\n    case Offset:\n      Out << 'L';\n      mangleType(Ctx.getPointerDiffType());\n      mangleNumber(V.getLValueOffset().getQuantity());\n      Out << 'E';\n      break;\n\n    case Path:\n      // <expression> ::= so <referent type> <expr> [<offset number>]\n      //                  <union-selector>* [p] E\n      if (!V.getLValueOffset().isZero())\n        mangleNumber(V.getLValueOffset().getQuantity());\n\n      // We model a past-the-end array pointer as array indexing with index N,\n      // not with the \"past the end\" flag. Compensate for that.\n      bool OnePastTheEnd = V.isLValueOnePastTheEnd();\n\n      for (APValue::LValuePathEntry E : V.getLValuePath()) {\n        if (auto *AT = TypeSoFar->getAsArrayTypeUnsafe()) {\n          if (auto *CAT = dyn_cast<ConstantArrayType>(AT))\n            OnePastTheEnd |= CAT->getSize() == E.getAsArrayIndex();\n          TypeSoFar = AT->getElementType();\n        } else {\n          const Decl *D = E.getAsBaseOrMember().getPointer();\n          if (auto *FD = dyn_cast<FieldDecl>(D)) {\n            // <union-selector> ::= _ <number>\n            if (FD->getParent()->isUnion()) {\n              Out << '_';\n              if (FD->getFieldIndex())\n                Out << (FD->getFieldIndex() - 1);\n            }\n            TypeSoFar = FD->getType();\n          } else {\n            TypeSoFar = Ctx.getRecordType(cast<CXXRecordDecl>(D));\n          }\n        }\n      }\n\n      if (OnePastTheEnd)\n        Out << 'p';\n      Out << 'E';\n      break;\n    }\n\n    break;\n  }\n\n  case APValue::MemberPointer:\n    // Proposed in https://github.com/itanium-cxx-abi/cxx-abi/issues/47.\n    if (!V.getMemberPointerDecl()) {\n      mangleNullPointer(T);\n      break;\n    }\n\n    ASTContext &Ctx = Context.getASTContext();\n\n    NotPrimaryExpr();\n    if (!V.getMemberPointerPath().empty()) {\n      Out << \"mc\";\n      mangleType(T);\n    } else if (NeedExactType &&\n               !Ctx.hasSameType(\n                   T->castAs<MemberPointerType>()->getPointeeType(),\n                   V.getMemberPointerDecl()->getType()) &&\n               Ctx.getLangOpts().getClangABICompat() >\n                   LangOptions::ClangABI::Ver11) {\n      Out << \"cv\";\n      mangleType(T);\n    }\n    Out << \"adL\";\n    mangle(V.getMemberPointerDecl());\n    Out << 'E';\n    if (!V.getMemberPointerPath().empty()) {\n      CharUnits Offset =\n          Context.getASTContext().getMemberPointerPathAdjustment(V);\n      if (!Offset.isZero())\n        mangleNumber(Offset.getQuantity());\n      Out << 'E';\n    }\n    break;\n  }\n\n  if (TopLevel && !IsPrimaryExpr)\n    Out << 'E';\n}\n\nvoid CXXNameMangler::mangleTemplateParameter(unsigned Depth, unsigned Index) {\n  // <template-param> ::= T_    # first template parameter\n  //                  ::= T <parameter-2 non-negative number> _\n  //                  ::= TL <L-1 non-negative number> __\n  //                  ::= TL <L-1 non-negative number> _\n  //                         <parameter-2 non-negative number> _\n  //\n  // The latter two manglings are from a proposal here:\n  // https://github.com/itanium-cxx-abi/cxx-abi/issues/31#issuecomment-528122117\n  Out << 'T';\n  if (Depth != 0)\n    Out << 'L' << (Depth - 1) << '_';\n  if (Index != 0)\n    Out << (Index - 1);\n  Out << '_';\n}\n\nvoid CXXNameMangler::mangleSeqID(unsigned SeqID) {\n  if (SeqID == 1)\n    Out << '0';\n  else if (SeqID > 1) {\n    SeqID--;\n\n    // <seq-id> is encoded in base-36, using digits and upper case letters.\n    char Buffer[7]; // log(2**32) / log(36) ~= 7\n    MutableArrayRef<char> BufferRef(Buffer);\n    MutableArrayRef<char>::reverse_iterator I = BufferRef.rbegin();\n\n    for (; SeqID != 0; SeqID /= 36) {\n      unsigned C = SeqID % 36;\n      *I++ = (C < 10 ? '0' + C : 'A' + C - 10);\n    }\n\n    Out.write(I.base(), I - BufferRef.rbegin());\n  }\n  Out << '_';\n}\n\nvoid CXXNameMangler::mangleExistingSubstitution(TemplateName tname) {\n  bool result = mangleSubstitution(tname);\n  assert(result && \"no existing substitution for template name\");\n  (void) result;\n}\n\n// <substitution> ::= S <seq-id> _\n//                ::= S_\nbool CXXNameMangler::mangleSubstitution(const NamedDecl *ND) {\n  // Try one of the standard substitutions first.\n  if (mangleStandardSubstitution(ND))\n    return true;\n\n  ND = cast<NamedDecl>(ND->getCanonicalDecl());\n  return mangleSubstitution(reinterpret_cast<uintptr_t>(ND));\n}\n\n/// Determine whether the given type has any qualifiers that are relevant for\n/// substitutions.\nstatic bool hasMangledSubstitutionQualifiers(QualType T) {\n  Qualifiers Qs = T.getQualifiers();\n  return Qs.getCVRQualifiers() || Qs.hasAddressSpace() || Qs.hasUnaligned();\n}\n\nbool CXXNameMangler::mangleSubstitution(QualType T) {\n  if (!hasMangledSubstitutionQualifiers(T)) {\n    if (const RecordType *RT = T->getAs<RecordType>())\n      return mangleSubstitution(RT->getDecl());\n  }\n\n  uintptr_t TypePtr = reinterpret_cast<uintptr_t>(T.getAsOpaquePtr());\n\n  return mangleSubstitution(TypePtr);\n}\n\nbool CXXNameMangler::mangleSubstitution(TemplateName Template) {\n  if (TemplateDecl *TD = Template.getAsTemplateDecl())\n    return mangleSubstitution(TD);\n\n  Template = Context.getASTContext().getCanonicalTemplateName(Template);\n  return mangleSubstitution(\n                      reinterpret_cast<uintptr_t>(Template.getAsVoidPointer()));\n}\n\nbool CXXNameMangler::mangleSubstitution(uintptr_t Ptr) {\n  llvm::DenseMap<uintptr_t, unsigned>::iterator I = Substitutions.find(Ptr);\n  if (I == Substitutions.end())\n    return false;\n\n  unsigned SeqID = I->second;\n  Out << 'S';\n  mangleSeqID(SeqID);\n\n  return true;\n}\n\nstatic bool isCharType(QualType T) {\n  if (T.isNull())\n    return false;\n\n  return T->isSpecificBuiltinType(BuiltinType::Char_S) ||\n    T->isSpecificBuiltinType(BuiltinType::Char_U);\n}\n\n/// Returns whether a given type is a template specialization of a given name\n/// with a single argument of type char.\nstatic bool isCharSpecialization(QualType T, const char *Name) {\n  if (T.isNull())\n    return false;\n\n  const RecordType *RT = T->getAs<RecordType>();\n  if (!RT)\n    return false;\n\n  const ClassTemplateSpecializationDecl *SD =\n    dyn_cast<ClassTemplateSpecializationDecl>(RT->getDecl());\n  if (!SD)\n    return false;\n\n  if (!isStdNamespace(getEffectiveDeclContext(SD)))\n    return false;\n\n  const TemplateArgumentList &TemplateArgs = SD->getTemplateArgs();\n  if (TemplateArgs.size() != 1)\n    return false;\n\n  if (!isCharType(TemplateArgs[0].getAsType()))\n    return false;\n\n  return SD->getIdentifier()->getName() == Name;\n}\n\ntemplate <std::size_t StrLen>\nstatic bool isStreamCharSpecialization(const ClassTemplateSpecializationDecl*SD,\n                                       const char (&Str)[StrLen]) {\n  if (!SD->getIdentifier()->isStr(Str))\n    return false;\n\n  const TemplateArgumentList &TemplateArgs = SD->getTemplateArgs();\n  if (TemplateArgs.size() != 2)\n    return false;\n\n  if (!isCharType(TemplateArgs[0].getAsType()))\n    return false;\n\n  if (!isCharSpecialization(TemplateArgs[1].getAsType(), \"char_traits\"))\n    return false;\n\n  return true;\n}\n\nbool CXXNameMangler::mangleStandardSubstitution(const NamedDecl *ND) {\n  // <substitution> ::= St # ::std::\n  if (const NamespaceDecl *NS = dyn_cast<NamespaceDecl>(ND)) {\n    if (isStd(NS)) {\n      Out << \"St\";\n      return true;\n    }\n  }\n\n  if (const ClassTemplateDecl *TD = dyn_cast<ClassTemplateDecl>(ND)) {\n    if (!isStdNamespace(getEffectiveDeclContext(TD)))\n      return false;\n\n    // <substitution> ::= Sa # ::std::allocator\n    if (TD->getIdentifier()->isStr(\"allocator\")) {\n      Out << \"Sa\";\n      return true;\n    }\n\n    // <<substitution> ::= Sb # ::std::basic_string\n    if (TD->getIdentifier()->isStr(\"basic_string\")) {\n      Out << \"Sb\";\n      return true;\n    }\n  }\n\n  if (const ClassTemplateSpecializationDecl *SD =\n        dyn_cast<ClassTemplateSpecializationDecl>(ND)) {\n    if (!isStdNamespace(getEffectiveDeclContext(SD)))\n      return false;\n\n    //    <substitution> ::= Ss # ::std::basic_string<char,\n    //                            ::std::char_traits<char>,\n    //                            ::std::allocator<char> >\n    if (SD->getIdentifier()->isStr(\"basic_string\")) {\n      const TemplateArgumentList &TemplateArgs = SD->getTemplateArgs();\n\n      if (TemplateArgs.size() != 3)\n        return false;\n\n      if (!isCharType(TemplateArgs[0].getAsType()))\n        return false;\n\n      if (!isCharSpecialization(TemplateArgs[1].getAsType(), \"char_traits\"))\n        return false;\n\n      if (!isCharSpecialization(TemplateArgs[2].getAsType(), \"allocator\"))\n        return false;\n\n      Out << \"Ss\";\n      return true;\n    }\n\n    //    <substitution> ::= Si # ::std::basic_istream<char,\n    //                            ::std::char_traits<char> >\n    if (isStreamCharSpecialization(SD, \"basic_istream\")) {\n      Out << \"Si\";\n      return true;\n    }\n\n    //    <substitution> ::= So # ::std::basic_ostream<char,\n    //                            ::std::char_traits<char> >\n    if (isStreamCharSpecialization(SD, \"basic_ostream\")) {\n      Out << \"So\";\n      return true;\n    }\n\n    //    <substitution> ::= Sd # ::std::basic_iostream<char,\n    //                            ::std::char_traits<char> >\n    if (isStreamCharSpecialization(SD, \"basic_iostream\")) {\n      Out << \"Sd\";\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid CXXNameMangler::addSubstitution(QualType T) {\n  if (!hasMangledSubstitutionQualifiers(T)) {\n    if (const RecordType *RT = T->getAs<RecordType>()) {\n      addSubstitution(RT->getDecl());\n      return;\n    }\n  }\n\n  uintptr_t TypePtr = reinterpret_cast<uintptr_t>(T.getAsOpaquePtr());\n  addSubstitution(TypePtr);\n}\n\nvoid CXXNameMangler::addSubstitution(TemplateName Template) {\n  if (TemplateDecl *TD = Template.getAsTemplateDecl())\n    return addSubstitution(TD);\n\n  Template = Context.getASTContext().getCanonicalTemplateName(Template);\n  addSubstitution(reinterpret_cast<uintptr_t>(Template.getAsVoidPointer()));\n}\n\nvoid CXXNameMangler::addSubstitution(uintptr_t Ptr) {\n  assert(!Substitutions.count(Ptr) && \"Substitution already exists!\");\n  Substitutions[Ptr] = SeqID++;\n}\n\nvoid CXXNameMangler::extendSubstitutions(CXXNameMangler* Other) {\n  assert(Other->SeqID >= SeqID && \"Must be superset of substitutions!\");\n  if (Other->SeqID > SeqID) {\n    Substitutions.swap(Other->Substitutions);\n    SeqID = Other->SeqID;\n  }\n}\n\nCXXNameMangler::AbiTagList\nCXXNameMangler::makeFunctionReturnTypeTags(const FunctionDecl *FD) {\n  // When derived abi tags are disabled there is no need to make any list.\n  if (DisableDerivedAbiTags)\n    return AbiTagList();\n\n  llvm::raw_null_ostream NullOutStream;\n  CXXNameMangler TrackReturnTypeTags(*this, NullOutStream);\n  TrackReturnTypeTags.disableDerivedAbiTags();\n\n  const FunctionProtoType *Proto =\n      cast<FunctionProtoType>(FD->getType()->getAs<FunctionType>());\n  FunctionTypeDepthState saved = TrackReturnTypeTags.FunctionTypeDepth.push();\n  TrackReturnTypeTags.FunctionTypeDepth.enterResultType();\n  TrackReturnTypeTags.mangleType(Proto->getReturnType());\n  TrackReturnTypeTags.FunctionTypeDepth.leaveResultType();\n  TrackReturnTypeTags.FunctionTypeDepth.pop(saved);\n\n  return TrackReturnTypeTags.AbiTagsRoot.getSortedUniqueUsedAbiTags();\n}\n\nCXXNameMangler::AbiTagList\nCXXNameMangler::makeVariableTypeTags(const VarDecl *VD) {\n  // When derived abi tags are disabled there is no need to make any list.\n  if (DisableDerivedAbiTags)\n    return AbiTagList();\n\n  llvm::raw_null_ostream NullOutStream;\n  CXXNameMangler TrackVariableType(*this, NullOutStream);\n  TrackVariableType.disableDerivedAbiTags();\n\n  TrackVariableType.mangleType(VD->getType());\n\n  return TrackVariableType.AbiTagsRoot.getSortedUniqueUsedAbiTags();\n}\n\nbool CXXNameMangler::shouldHaveAbiTags(ItaniumMangleContextImpl &C,\n                                       const VarDecl *VD) {\n  llvm::raw_null_ostream NullOutStream;\n  CXXNameMangler TrackAbiTags(C, NullOutStream, nullptr, true);\n  TrackAbiTags.mangle(VD);\n  return TrackAbiTags.AbiTagsRoot.getUsedAbiTags().size();\n}\n\n//\n\n/// Mangles the name of the declaration D and emits that name to the given\n/// output stream.\n///\n/// If the declaration D requires a mangled name, this routine will emit that\n/// mangled name to \\p os and return true. Otherwise, \\p os will be unchanged\n/// and this routine will return false. In this case, the caller should just\n/// emit the identifier of the declaration (\\c D->getIdentifier()) as its\n/// name.\nvoid ItaniumMangleContextImpl::mangleCXXName(GlobalDecl GD,\n                                             raw_ostream &Out) {\n  const NamedDecl *D = cast<NamedDecl>(GD.getDecl());\n  assert((isa<FunctionDecl, VarDecl, TemplateParamObjectDecl>(D)) &&\n         \"Invalid mangleName() call, argument is not a variable or function!\");\n\n  PrettyStackTraceDecl CrashInfo(D, SourceLocation(),\n                                 getASTContext().getSourceManager(),\n                                 \"Mangling declaration\");\n\n  if (auto *CD = dyn_cast<CXXConstructorDecl>(D)) {\n    auto Type = GD.getCtorType();\n    CXXNameMangler Mangler(*this, Out, CD, Type);\n    return Mangler.mangle(GlobalDecl(CD, Type));\n  }\n\n  if (auto *DD = dyn_cast<CXXDestructorDecl>(D)) {\n    auto Type = GD.getDtorType();\n    CXXNameMangler Mangler(*this, Out, DD, Type);\n    return Mangler.mangle(GlobalDecl(DD, Type));\n  }\n\n  CXXNameMangler Mangler(*this, Out, D);\n  Mangler.mangle(GD);\n}\n\nvoid ItaniumMangleContextImpl::mangleCXXCtorComdat(const CXXConstructorDecl *D,\n                                                   raw_ostream &Out) {\n  CXXNameMangler Mangler(*this, Out, D, Ctor_Comdat);\n  Mangler.mangle(GlobalDecl(D, Ctor_Comdat));\n}\n\nvoid ItaniumMangleContextImpl::mangleCXXDtorComdat(const CXXDestructorDecl *D,\n                                                   raw_ostream &Out) {\n  CXXNameMangler Mangler(*this, Out, D, Dtor_Comdat);\n  Mangler.mangle(GlobalDecl(D, Dtor_Comdat));\n}\n\nvoid ItaniumMangleContextImpl::mangleThunk(const CXXMethodDecl *MD,\n                                           const ThunkInfo &Thunk,\n                                           raw_ostream &Out) {\n  //  <special-name> ::= T <call-offset> <base encoding>\n  //                      # base is the nominal target function of thunk\n  //  <special-name> ::= Tc <call-offset> <call-offset> <base encoding>\n  //                      # base is the nominal target function of thunk\n  //                      # first call-offset is 'this' adjustment\n  //                      # second call-offset is result adjustment\n\n  assert(!isa<CXXDestructorDecl>(MD) &&\n         \"Use mangleCXXDtor for destructor decls!\");\n  CXXNameMangler Mangler(*this, Out);\n  Mangler.getStream() << \"_ZT\";\n  if (!Thunk.Return.isEmpty())\n    Mangler.getStream() << 'c';\n\n  // Mangle the 'this' pointer adjustment.\n  Mangler.mangleCallOffset(Thunk.This.NonVirtual,\n                           Thunk.This.Virtual.Itanium.VCallOffsetOffset);\n\n  // Mangle the return pointer adjustment if there is one.\n  if (!Thunk.Return.isEmpty())\n    Mangler.mangleCallOffset(Thunk.Return.NonVirtual,\n                             Thunk.Return.Virtual.Itanium.VBaseOffsetOffset);\n\n  Mangler.mangleFunctionEncoding(MD);\n}\n\nvoid ItaniumMangleContextImpl::mangleCXXDtorThunk(\n    const CXXDestructorDecl *DD, CXXDtorType Type,\n    const ThisAdjustment &ThisAdjustment, raw_ostream &Out) {\n  //  <special-name> ::= T <call-offset> <base encoding>\n  //                      # base is the nominal target function of thunk\n  CXXNameMangler Mangler(*this, Out, DD, Type);\n  Mangler.getStream() << \"_ZT\";\n\n  // Mangle the 'this' pointer adjustment.\n  Mangler.mangleCallOffset(ThisAdjustment.NonVirtual,\n                           ThisAdjustment.Virtual.Itanium.VCallOffsetOffset);\n\n  Mangler.mangleFunctionEncoding(GlobalDecl(DD, Type));\n}\n\n/// Returns the mangled name for a guard variable for the passed in VarDecl.\nvoid ItaniumMangleContextImpl::mangleStaticGuardVariable(const VarDecl *D,\n                                                         raw_ostream &Out) {\n  //  <special-name> ::= GV <object name>       # Guard variable for one-time\n  //                                            # initialization\n  CXXNameMangler Mangler(*this, Out);\n  // GCC 5.3.0 doesn't emit derived ABI tags for local names but that seems to\n  // be a bug that is fixed in trunk.\n  Mangler.getStream() << \"_ZGV\";\n  Mangler.mangleName(D);\n}\n\nvoid ItaniumMangleContextImpl::mangleDynamicInitializer(const VarDecl *MD,\n                                                        raw_ostream &Out) {\n  // These symbols are internal in the Itanium ABI, so the names don't matter.\n  // Clang has traditionally used this symbol and allowed LLVM to adjust it to\n  // avoid duplicate symbols.\n  Out << \"__cxx_global_var_init\";\n}\n\nvoid ItaniumMangleContextImpl::mangleDynamicAtExitDestructor(const VarDecl *D,\n                                                             raw_ostream &Out) {\n  // Prefix the mangling of D with __dtor_.\n  CXXNameMangler Mangler(*this, Out);\n  Mangler.getStream() << \"__dtor_\";\n  if (shouldMangleDeclName(D))\n    Mangler.mangle(D);\n  else\n    Mangler.getStream() << D->getName();\n}\n\nvoid ItaniumMangleContextImpl::mangleDynamicStermFinalizer(const VarDecl *D,\n                                                           raw_ostream &Out) {\n  // Clang generates these internal-linkage functions as part of its\n  // implementation of the XL ABI.\n  CXXNameMangler Mangler(*this, Out);\n  Mangler.getStream() << \"__finalize_\";\n  if (shouldMangleDeclName(D))\n    Mangler.mangle(D);\n  else\n    Mangler.getStream() << D->getName();\n}\n\nvoid ItaniumMangleContextImpl::mangleSEHFilterExpression(\n    const NamedDecl *EnclosingDecl, raw_ostream &Out) {\n  CXXNameMangler Mangler(*this, Out);\n  Mangler.getStream() << \"__filt_\";\n  if (shouldMangleDeclName(EnclosingDecl))\n    Mangler.mangle(EnclosingDecl);\n  else\n    Mangler.getStream() << EnclosingDecl->getName();\n}\n\nvoid ItaniumMangleContextImpl::mangleSEHFinallyBlock(\n    const NamedDecl *EnclosingDecl, raw_ostream &Out) {\n  CXXNameMangler Mangler(*this, Out);\n  Mangler.getStream() << \"__fin_\";\n  if (shouldMangleDeclName(EnclosingDecl))\n    Mangler.mangle(EnclosingDecl);\n  else\n    Mangler.getStream() << EnclosingDecl->getName();\n}\n\nvoid ItaniumMangleContextImpl::mangleItaniumThreadLocalInit(const VarDecl *D,\n                                                            raw_ostream &Out) {\n  //  <special-name> ::= TH <object name>\n  CXXNameMangler Mangler(*this, Out);\n  Mangler.getStream() << \"_ZTH\";\n  Mangler.mangleName(D);\n}\n\nvoid\nItaniumMangleContextImpl::mangleItaniumThreadLocalWrapper(const VarDecl *D,\n                                                          raw_ostream &Out) {\n  //  <special-name> ::= TW <object name>\n  CXXNameMangler Mangler(*this, Out);\n  Mangler.getStream() << \"_ZTW\";\n  Mangler.mangleName(D);\n}\n\nvoid ItaniumMangleContextImpl::mangleReferenceTemporary(const VarDecl *D,\n                                                        unsigned ManglingNumber,\n                                                        raw_ostream &Out) {\n  // We match the GCC mangling here.\n  //  <special-name> ::= GR <object name>\n  CXXNameMangler Mangler(*this, Out);\n  Mangler.getStream() << \"_ZGR\";\n  Mangler.mangleName(D);\n  assert(ManglingNumber > 0 && \"Reference temporary mangling number is zero!\");\n  Mangler.mangleSeqID(ManglingNumber - 1);\n}\n\nvoid ItaniumMangleContextImpl::mangleCXXVTable(const CXXRecordDecl *RD,\n                                               raw_ostream &Out) {\n  // <special-name> ::= TV <type>  # virtual table\n  CXXNameMangler Mangler(*this, Out);\n  Mangler.getStream() << \"_ZTV\";\n  Mangler.mangleNameOrStandardSubstitution(RD);\n}\n\nvoid ItaniumMangleContextImpl::mangleCXXVTT(const CXXRecordDecl *RD,\n                                            raw_ostream &Out) {\n  // <special-name> ::= TT <type>  # VTT structure\n  CXXNameMangler Mangler(*this, Out);\n  Mangler.getStream() << \"_ZTT\";\n  Mangler.mangleNameOrStandardSubstitution(RD);\n}\n\nvoid ItaniumMangleContextImpl::mangleCXXCtorVTable(const CXXRecordDecl *RD,\n                                                   int64_t Offset,\n                                                   const CXXRecordDecl *Type,\n                                                   raw_ostream &Out) {\n  // <special-name> ::= TC <type> <offset number> _ <base type>\n  CXXNameMangler Mangler(*this, Out);\n  Mangler.getStream() << \"_ZTC\";\n  Mangler.mangleNameOrStandardSubstitution(RD);\n  Mangler.getStream() << Offset;\n  Mangler.getStream() << '_';\n  Mangler.mangleNameOrStandardSubstitution(Type);\n}\n\nvoid ItaniumMangleContextImpl::mangleCXXRTTI(QualType Ty, raw_ostream &Out) {\n  // <special-name> ::= TI <type>  # typeinfo structure\n  assert(!Ty.hasQualifiers() && \"RTTI info cannot have top-level qualifiers\");\n  CXXNameMangler Mangler(*this, Out);\n  Mangler.getStream() << \"_ZTI\";\n  Mangler.mangleType(Ty);\n}\n\nvoid ItaniumMangleContextImpl::mangleCXXRTTIName(QualType Ty,\n                                                 raw_ostream &Out) {\n  // <special-name> ::= TS <type>  # typeinfo name (null terminated byte string)\n  CXXNameMangler Mangler(*this, Out);\n  Mangler.getStream() << \"_ZTS\";\n  Mangler.mangleType(Ty);\n}\n\nvoid ItaniumMangleContextImpl::mangleTypeName(QualType Ty, raw_ostream &Out) {\n  mangleCXXRTTIName(Ty, Out);\n}\n\nvoid ItaniumMangleContextImpl::mangleStringLiteral(const StringLiteral *, raw_ostream &) {\n  llvm_unreachable(\"Can't mangle string literals\");\n}\n\nvoid ItaniumMangleContextImpl::mangleLambdaSig(const CXXRecordDecl *Lambda,\n                                               raw_ostream &Out) {\n  CXXNameMangler Mangler(*this, Out);\n  Mangler.mangleLambdaSig(Lambda);\n}\n\nItaniumMangleContext *\nItaniumMangleContext::create(ASTContext &Context, DiagnosticsEngine &Diags) {\n  return new ItaniumMangleContextImpl(Context, Diags);\n}\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 26, "line": 252}, "message": "'CXXNameMangler' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/ItaniumMangle.cpp", "reportHash": "1ad9a4a1c6a875487d4ad47ffc32b85d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
