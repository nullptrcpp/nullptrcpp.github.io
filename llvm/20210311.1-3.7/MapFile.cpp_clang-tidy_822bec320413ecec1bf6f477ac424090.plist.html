<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/lld/ELF/Config.h", "content": "//===- Config.h -------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLD_ELF_CONFIG_H\n#define LLD_ELF_CONFIG_H\n\n#include \"lld/Common/ErrorHandler.h\"\n#include \"llvm/ADT/CachedHashString.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/BinaryFormat/ELF.h\"\n#include \"llvm/Support/CachePruning.h\"\n#include \"llvm/Support/CodeGen.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/GlobPattern.h\"\n#include <atomic>\n#include <vector>\n\nnamespace lld {\nnamespace elf {\n\nclass InputFile;\nclass InputSectionBase;\n\nenum ELFKind {\n  ELFNoneKind,\n  ELF32LEKind,\n  ELF32BEKind,\n  ELF64LEKind,\n  ELF64BEKind\n};\n\n// For --build-id.\nenum class BuildIdKind { None, Fast, Md5, Sha1, Hexstring, Uuid };\n\n// For --discard-{all,locals,none}.\nenum class DiscardPolicy { Default, All, Locals, None };\n\n// For --icf={none,safe,all}.\nenum class ICFLevel { None, Safe, All };\n\n// For --strip-{all,debug}.\nenum class StripPolicy { None, All, Debug };\n\n// For --unresolved-symbols.\nenum class UnresolvedPolicy { ReportError, Warn, Ignore };\n\n// For --orphan-handling.\nenum class OrphanHandlingPolicy { Place, Warn, Error };\n\n// For --sort-section and linkerscript sorting rules.\nenum class SortSectionPolicy { Default, None, Alignment, Name, Priority };\n\n// For --target2\nenum class Target2Policy { Abs, Rel, GotRel };\n\n// For tracking ARM Float Argument PCS\nenum class ARMVFPArgKind { Default, Base, VFP, ToolChain };\n\n// For -z noseparate-code, -z separate-code and -z separate-loadable-segments.\nenum class SeparateSegmentKind { None, Code, Loadable };\n\n// For -z *stack\nenum class GnuStackKind { None, Exec, NoExec };\n\nstruct SymbolVersion {\n  llvm::StringRef name;\n  bool isExternCpp;\n  bool hasWildcard;\n};\n\n// This struct contains symbols version definition that\n// can be found in version script if it is used for link.\nstruct VersionDefinition {\n  llvm::StringRef name;\n  uint16_t id;\n  std::vector<SymbolVersion> patterns;\n};\n\n// This struct contains the global configuration for the linker.\n// Most fields are direct mapping from the command line options\n// and such fields have the same name as the corresponding options.\n// Most fields are initialized by the driver.\nstruct Configuration {\n  uint8_t osabi = 0;\n  uint32_t andFeatures = 0;\n  llvm::CachePruningPolicy thinLTOCachePolicy;\n  llvm::SetVector<llvm::CachedHashString> dependencyFiles; // for --dependency-file\n  llvm::StringMap<uint64_t> sectionStartMap;\n  llvm::StringRef bfdname;\n  llvm::StringRef chroot;\n  llvm::StringRef dependencyFile;\n  llvm::StringRef dwoDir;\n  llvm::StringRef dynamicLinker;\n  llvm::StringRef entry;\n  llvm::StringRef emulation;\n  llvm::StringRef fini;\n  llvm::StringRef init;\n  llvm::StringRef ltoAAPipeline;\n  llvm::StringRef ltoCSProfileFile;\n  llvm::StringRef ltoNewPmPasses;\n  llvm::StringRef ltoObjPath;\n  llvm::StringRef ltoSampleProfile;\n  llvm::StringRef mapFile;\n  llvm::StringRef outputFile;\n  llvm::StringRef optRemarksFilename;\n  llvm::Optional<uint64_t> optRemarksHotnessThreshold = 0;\n  llvm::StringRef optRemarksPasses;\n  llvm::StringRef optRemarksFormat;\n  llvm::StringRef progName;\n  llvm::StringRef printArchiveStats;\n  llvm::StringRef printSymbolOrder;\n  llvm::StringRef soName;\n  llvm::StringRef sysroot;\n  llvm::StringRef thinLTOCacheDir;\n  llvm::StringRef thinLTOIndexOnlyArg;\n  llvm::StringRef ltoBasicBlockSections;\n  std::pair<llvm::StringRef, llvm::StringRef> thinLTOObjectSuffixReplace;\n  std::pair<llvm::StringRef, llvm::StringRef> thinLTOPrefixReplace;\n  std::string rpath;\n  std::vector<VersionDefinition> versionDefinitions;\n  std::vector<llvm::StringRef> auxiliaryList;\n  std::vector<llvm::StringRef> filterList;\n  std::vector<llvm::StringRef> searchPaths;\n  std::vector<llvm::StringRef> symbolOrderingFile;\n  std::vector<llvm::StringRef> thinLTOModulesToCompile;\n  std::vector<llvm::StringRef> undefined;\n  std::vector<SymbolVersion> dynamicList;\n  std::vector<uint8_t> buildIdVector;\n  llvm::MapVector<std::pair<const InputSectionBase *, const InputSectionBase *>,\n                  uint64_t>\n      callGraphProfile;\n  bool allowMultipleDefinition;\n  bool androidPackDynRelocs;\n  bool armHasBlx = false;\n  bool armHasMovtMovw = false;\n  bool armJ1J2BranchEncoding = false;\n  bool asNeeded = false;\n  bool bsymbolic;\n  bool bsymbolicFunctions;\n  bool callGraphProfileSort;\n  bool checkSections;\n  bool compressDebugSections;\n  bool cref;\n  std::vector<std::pair<llvm::GlobPattern, uint64_t>> deadRelocInNonAlloc;\n  bool defineCommon;\n  bool demangle = true;\n  bool dependentLibraries;\n  bool disableVerify;\n  bool ehFrameHdr;\n  bool emitLLVM;\n  bool emitRelocs;\n  bool enableNewDtags;\n  bool executeOnly;\n  bool exportDynamic;\n  bool fixCortexA53Errata843419;\n  bool fixCortexA8;\n  bool formatBinary = false;\n  bool fortranCommon;\n  bool gcSections;\n  bool gdbIndex;\n  bool gnuHash = false;\n  bool gnuUnique;\n  bool hasDynSymTab;\n  bool ignoreDataAddressEquality;\n  bool ignoreFunctionAddressEquality;\n  bool ltoCSProfileGenerate;\n  bool ltoDebugPassManager;\n  bool ltoEmitAsm;\n  bool ltoNewPassManager;\n  bool ltoPseudoProbeForProfiling;\n  bool ltoUniqueBasicBlockSectionNames;\n  bool ltoWholeProgramVisibility;\n  bool mergeArmExidx;\n  bool mipsN32Abi = false;\n  bool mmapOutputFile;\n  bool nmagic;\n  bool noDynamicLinker = false;\n  bool noinhibitExec;\n  bool nostdlib;\n  bool oFormatBinary;\n  bool omagic;\n  bool optEB = false;\n  bool optEL = false;\n  bool optimizeBBJumps;\n  bool optRemarksWithHotness;\n  bool picThunk;\n  bool pie;\n  bool printGcSections;\n  bool printIcfSections;\n  bool relocatable;\n  bool relrPackDynRelocs;\n  bool saveTemps;\n  llvm::Optional<uint32_t> shuffleSectionSeed;\n  bool singleRoRx;\n  bool shared;\n  bool symbolic;\n  bool isStatic = false;\n  bool sysvHash = false;\n  bool target1Rel;\n  bool trace;\n  bool thinLTOEmitImportsFiles;\n  bool thinLTOIndexOnly;\n  bool timeTraceEnabled;\n  bool tocOptimize;\n  bool pcRelOptimize;\n  bool undefinedVersion;\n  bool unique;\n  bool useAndroidRelrTags = false;\n  bool warnBackrefs;\n  std::vector<llvm::GlobPattern> warnBackrefsExclude;\n  bool warnCommon;\n  bool warnMissingEntry;\n  bool warnSymbolOrdering;\n  bool writeAddends;\n  bool zCombreloc;\n  bool zCopyreloc;\n  bool zForceBti;\n  bool zForceIbt;\n  bool zGlobal;\n  bool zHazardplt;\n  bool zIfuncNoplt;\n  bool zInitfirst;\n  bool zInterpose;\n  bool zKeepTextSectionPrefix;\n  bool zNodefaultlib;\n  bool zNodelete;\n  bool zNodlopen;\n  bool zNow;\n  bool zOrigin;\n  bool zPacPlt;\n  bool zRelro;\n  bool zRodynamic;\n  bool zShstk;\n  bool zStartStopGC;\n  uint8_t zStartStopVisibility;\n  bool zText;\n  bool zRetpolineplt;\n  bool zWxneeded;\n  DiscardPolicy discard;\n  GnuStackKind zGnustack;\n  ICFLevel icf;\n  OrphanHandlingPolicy orphanHandling;\n  SortSectionPolicy sortSection;\n  StripPolicy strip;\n  UnresolvedPolicy unresolvedSymbols;\n  UnresolvedPolicy unresolvedSymbolsInShlib;\n  Target2Policy target2;\n  bool Power10Stub;\n  ARMVFPArgKind armVFPArgs = ARMVFPArgKind::Default;\n  BuildIdKind buildId = BuildIdKind::None;\n  SeparateSegmentKind zSeparate;\n  ELFKind ekind = ELFNoneKind;\n  uint16_t emachine = llvm::ELF::EM_NONE;\n  llvm::Optional<uint64_t> imageBase;\n  uint64_t commonPageSize;\n  uint64_t maxPageSize;\n  uint64_t mipsGotSize;\n  uint64_t zStackSize;\n  unsigned ltoPartitions;\n  unsigned ltoo;\n  unsigned optimize;\n  StringRef thinLTOJobs;\n  unsigned timeTraceGranularity;\n  int32_t splitStackAdjustSize;\n\n  // The following config options do not directly correspond to any\n  // particular command line options.\n\n  // True if we need to pass through relocations in input files to the\n  // output file. Usually false because we consume relocations.\n  bool copyRelocs;\n\n  // True if the target is ELF64. False if ELF32.\n  bool is64;\n\n  // True if the target is little-endian. False if big-endian.\n  bool isLE;\n\n  // endianness::little if isLE is true. endianness::big otherwise.\n  llvm::support::endianness endianness;\n\n  // True if the target is the little-endian MIPS64.\n  //\n  // The reason why we have this variable only for the MIPS is because\n  // we use this often.  Some ELF headers for MIPS64EL are in a\n  // mixed-endian (which is horrible and I'd say that's a serious spec\n  // bug), and we need to know whether we are reading MIPS ELF files or\n  // not in various places.\n  //\n  // (Note that MIPS64EL is not a typo for MIPS64LE. This is the official\n  // name whatever that means. A fun hypothesis is that \"EL\" is short for\n  // little-endian written in the little-endian order, but I don't know\n  // if that's true.)\n  bool isMips64EL;\n\n  // True if we need to set the DF_STATIC_TLS flag to an output file,\n  // which works as a hint to the dynamic loader that the file contains\n  // code compiled with the static TLS model. The thread-local variable\n  // compiled with the static TLS model is faster but less flexible, and\n  // it may not be loaded using dlopen().\n  //\n  // We set this flag to true when we see a relocation for the static TLS\n  // model. Once this becomes true, it will never become false.\n  //\n  // Since the flag is updated by multi-threaded code, we use std::atomic.\n  // (Writing to a variable is not considered thread-safe even if the\n  // variable is boolean and we always set the same value from all threads.)\n  std::atomic<bool> hasStaticTlsModel{false};\n\n  // Holds set of ELF header flags for the target.\n  uint32_t eflags = 0;\n\n  // The ELF spec defines two types of relocation table entries, RELA and\n  // REL. RELA is a triplet of (offset, info, addend) while REL is a\n  // tuple of (offset, info). Addends for REL are implicit and read from\n  // the location where the relocations are applied. So, REL is more\n  // compact than RELA but requires a bit of more work to process.\n  //\n  // (From the linker writer's view, this distinction is not necessary.\n  // If the ELF had chosen whichever and sticked with it, it would have\n  // been easier to write code to process relocations, but it's too late\n  // to change the spec.)\n  //\n  // Each ABI defines its relocation type. IsRela is true if target\n  // uses RELA. As far as we know, all 64-bit ABIs are using RELA. A\n  // few 32-bit ABIs are using RELA too.\n  bool isRela;\n\n  // True if we are creating position-independent code.\n  bool isPic;\n\n  // 4 for ELF32, 8 for ELF64.\n  int wordsize;\n};\n\n// The only instance of Configuration struct.\nextern Configuration *config;\n\n// The first two elements of versionDefinitions represent VER_NDX_LOCAL and\n// VER_NDX_GLOBAL. This helper returns other elements.\nstatic inline ArrayRef<VersionDefinition> namedVersionDefs() {\n  return llvm::makeArrayRef(config->versionDefinitions).slice(2);\n}\n\nstatic inline void errorOrWarn(const Twine &msg) {\n  if (!config->noinhibitExec)\n    error(msg);\n  else\n    warn(msg);\n}\n} // namespace elf\n} // namespace lld\n\n#endif\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/lld/ELF/InputFiles.h", "content": "//===- InputFiles.h ---------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLD_ELF_INPUT_FILES_H\n#define LLD_ELF_INPUT_FILES_H\n\n#include \"Config.h\"\n#include \"lld/Common/ErrorHandler.h\"\n#include \"lld/Common/LLVM.h\"\n#include \"lld/Common/Reproduce.h\"\n#include \"llvm/ADT/CachedHashString.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/IR/Comdat.h\"\n#include \"llvm/Object/Archive.h\"\n#include \"llvm/Object/ELF.h\"\n#include \"llvm/Object/IRObjectFile.h\"\n#include \"llvm/Support/Threading.h\"\n#include <map>\n\nnamespace llvm {\nstruct DILineInfo;\nclass TarWriter;\nnamespace lto {\nclass InputFile;\n}\n} // namespace llvm\n\nnamespace lld {\nclass DWARFCache;\n\n// Returns \"<internal>\", \"foo.a(bar.o)\" or \"baz.o\".\nstd::string toString(const elf::InputFile *f);\n\nnamespace elf {\n\nusing llvm::object::Archive;\n\nclass Symbol;\n\n// If -reproduce option is given, all input files are written\n// to this tar archive.\nextern std::unique_ptr<llvm::TarWriter> tar;\n\n// Opens a given file.\nllvm::Optional<MemoryBufferRef> readFile(StringRef path);\n\n// Add symbols in File to the symbol table.\nvoid parseFile(InputFile *file);\n\n// The root class of input files.\nclass InputFile {\npublic:\n  enum Kind {\n    ObjKind,\n    SharedKind,\n    LazyObjKind,\n    ArchiveKind,\n    BitcodeKind,\n    BinaryKind,\n  };\n\n  Kind kind() const { return fileKind; }\n\n  bool isElf() const {\n    Kind k = kind();\n    return k == ObjKind || k == SharedKind;\n  }\n\n  StringRef getName() const { return mb.getBufferIdentifier(); }\n  MemoryBufferRef mb;\n\n  // Returns sections. It is a runtime error to call this function\n  // on files that don't have the notion of sections.\n  ArrayRef<InputSectionBase *> getSections() const {\n    assert(fileKind == ObjKind || fileKind == BinaryKind);\n    return sections;\n  }\n\n  // Returns object file symbols. It is a runtime error to call this\n  // function on files of other types.\n  ArrayRef<Symbol *> getSymbols() { return getMutableSymbols(); }\n\n  MutableArrayRef<Symbol *> getMutableSymbols() {\n    assert(fileKind == BinaryKind || fileKind == ObjKind ||\n           fileKind == BitcodeKind);\n    return symbols;\n  }\n\n  // Get filename to use for linker script processing.\n  StringRef getNameForScript() const;\n\n  // If not empty, this stores the name of the archive containing this file.\n  // We use this string for creating error messages.\n  std::string archiveName;\n\n  // If this is an architecture-specific file, the following members\n  // have ELF type (i.e. ELF{32,64}{LE,BE}) and target machine type.\n  ELFKind ekind = ELFNoneKind;\n  uint16_t emachine = llvm::ELF::EM_NONE;\n  uint8_t osabi = 0;\n  uint8_t abiVersion = 0;\n\n  // Cache for toString(). Only toString() should use this member.\n  mutable std::string toStringCache;\n\n  std::string getSrcMsg(const Symbol &sym, InputSectionBase &sec,\n                        uint64_t offset);\n\n  // True if this is an argument for --just-symbols. Usually false.\n  bool justSymbols = false;\n\n  // outSecOff of .got2 in the current file. This is used by PPC32 -fPIC/-fPIE\n  // to compute offsets in PLT call stubs.\n  uint32_t ppc32Got2OutSecOff = 0;\n\n  // On PPC64 we need to keep track of which files contain small code model\n  // relocations that access the .toc section. To minimize the chance of a\n  // relocation overflow, files that do contain said relocations should have\n  // their .toc sections sorted closer to the .got section than files that do\n  // not contain any small code model relocations. Thats because the toc-pointer\n  // is defined to point at .got + 0x8000 and the instructions used with small\n  // code model relocations support immediates in the range [-0x8000, 0x7FFC],\n  // making the addressable range relative to the toc pointer\n  // [.got, .got + 0xFFFC].\n  bool ppc64SmallCodeModelTocRelocs = false;\n\n  // True if the file has TLSGD/TLSLD GOT relocations without R_PPC64_TLSGD or\n  // R_PPC64_TLSLD. Disable TLS relaxation to avoid bad code generation.\n  bool ppc64DisableTLSRelax = false;\n\n  // groupId is used for --warn-backrefs which is an optional error\n  // checking feature. All files within the same --{start,end}-group or\n  // --{start,end}-lib get the same group ID. Otherwise, each file gets a new\n  // group ID. For more info, see checkDependency() in SymbolTable.cpp.\n  uint32_t groupId;\n  static bool isInGroup;\n  static uint32_t nextGroupId;\n\n  // Index of MIPS GOT built for this file.\n  llvm::Optional<size_t> mipsGotIndex;\n\n  std::vector<Symbol *> symbols;\n\nprotected:\n  InputFile(Kind k, MemoryBufferRef m);\n  std::vector<InputSectionBase *> sections;\n\nprivate:\n  const Kind fileKind;\n\n  // Cache for getNameForScript().\n  mutable std::string nameForScriptCache;\n};\n\nclass ELFFileBase : public InputFile {\npublic:\n  ELFFileBase(Kind k, MemoryBufferRef m);\n  static bool classof(const InputFile *f) { return f->isElf(); }\n\n  template <typename ELFT> llvm::object::ELFFile<ELFT> getObj() const {\n    return check(llvm::object::ELFFile<ELFT>::create(mb.getBuffer()));\n  }\n\n  StringRef getStringTable() const { return stringTable; }\n\n  template <typename ELFT> typename ELFT::SymRange getELFSyms() const {\n    return typename ELFT::SymRange(\n        reinterpret_cast<const typename ELFT::Sym *>(elfSyms), numELFSyms);\n  }\n  template <typename ELFT> typename ELFT::SymRange getGlobalELFSyms() const {\n    return getELFSyms<ELFT>().slice(firstGlobal);\n  }\n\nprotected:\n  // Initializes this class's member variables.\n  template <typename ELFT> void init();\n\n  const void *elfSyms = nullptr;\n  size_t numELFSyms = 0;\n  uint32_t firstGlobal = 0;\n  StringRef stringTable;\n};\n\n// .o file.\ntemplate <class ELFT> class ObjFile : public ELFFileBase {\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n\npublic:\n  static bool classof(const InputFile *f) { return f->kind() == ObjKind; }\n\n  llvm::object::ELFFile<ELFT> getObj() const {\n    return this->ELFFileBase::getObj<ELFT>();\n  }\n\n  ArrayRef<Symbol *> getLocalSymbols();\n  ArrayRef<Symbol *> getGlobalSymbols();\n\n  ObjFile(MemoryBufferRef m, StringRef archiveName) : ELFFileBase(ObjKind, m) {\n    this->archiveName = std::string(archiveName);\n  }\n\n  void parse(bool ignoreComdats = false);\n\n  StringRef getShtGroupSignature(ArrayRef<Elf_Shdr> sections,\n                                 const Elf_Shdr &sec);\n\n  Symbol &getSymbol(uint32_t symbolIndex) const {\n    if (symbolIndex >= this->symbols.size())\n      fatal(toString(this) + \": invalid symbol index\");\n    return *this->symbols[symbolIndex];\n  }\n\n  uint32_t getSectionIndex(const Elf_Sym &sym) const;\n\n  template <typename RelT> Symbol &getRelocTargetSym(const RelT &rel) const {\n    uint32_t symIndex = rel.getSymbol(config->isMips64EL);\n    return getSymbol(symIndex);\n  }\n\n  llvm::Optional<llvm::DILineInfo> getDILineInfo(InputSectionBase *, uint64_t);\n  llvm::Optional<std::pair<std::string, unsigned>> getVariableLoc(StringRef name);\n\n  // MIPS GP0 value defined by this file. This value represents the gp value\n  // used to create the relocatable object and required to support\n  // R_MIPS_GPREL16 / R_MIPS_GPREL32 relocations.\n  uint32_t mipsGp0 = 0;\n\n  uint32_t andFeatures = 0;\n\n  // Name of source file obtained from STT_FILE symbol value,\n  // or empty string if there is no such symbol in object file\n  // symbol table.\n  StringRef sourceFile;\n\n  // True if the file defines functions compiled with\n  // -fsplit-stack. Usually false.\n  bool splitStack = false;\n\n  // True if the file defines functions compiled with -fsplit-stack,\n  // but had one or more functions with the no_split_stack attribute.\n  bool someNoSplitStack = false;\n\n  // Pointer to this input file's .llvm_addrsig section, if it has one.\n  const Elf_Shdr *addrsigSec = nullptr;\n\n  // SHT_LLVM_CALL_GRAPH_PROFILE table\n  ArrayRef<Elf_CGProfile> cgProfile;\n\n  // Get cached DWARF information.\n  DWARFCache *getDwarf();\n\nprivate:\n  void initializeSections(bool ignoreComdats);\n  void initializeSymbols();\n  void initializeJustSymbols();\n\n  InputSectionBase *getRelocTarget(const Elf_Shdr &sec);\n  InputSectionBase *createInputSection(const Elf_Shdr &sec);\n  StringRef getSectionName(const Elf_Shdr &sec);\n\n  bool shouldMerge(const Elf_Shdr &sec, StringRef name);\n\n  // Each ELF symbol contains a section index which the symbol belongs to.\n  // However, because the number of bits dedicated for that is limited, a\n  // symbol can directly point to a section only when the section index is\n  // equal to or smaller than 65280.\n  //\n  // If an object file contains more than 65280 sections, the file must\n  // contain .symtab_shndx section. The section contains an array of\n  // 32-bit integers whose size is the same as the number of symbols.\n  // Nth symbol's section index is in the Nth entry of .symtab_shndx.\n  //\n  // The following variable contains the contents of .symtab_shndx.\n  // If the section does not exist (which is common), the array is empty.\n  ArrayRef<Elf_Word> shndxTable;\n\n  // .shstrtab contents.\n  StringRef sectionStringTable;\n\n  // Debugging information to retrieve source file and line for error\n  // reporting. Linker may find reasonable number of errors in a\n  // single object file, so we cache debugging information in order to\n  // parse it only once for each object file we link.\n  std::unique_ptr<DWARFCache> dwarf;\n  llvm::once_flag initDwarf;\n};\n\n// LazyObjFile is analogous to ArchiveFile in the sense that\n// the file contains lazy symbols. The difference is that\n// LazyObjFile wraps a single file instead of multiple files.\n//\n// This class is used for --start-lib and --end-lib options which\n// instruct the linker to link object files between them with the\n// archive file semantics.\nclass LazyObjFile : public InputFile {\npublic:\n  LazyObjFile(MemoryBufferRef m, StringRef archiveName,\n              uint64_t offsetInArchive)\n      : InputFile(LazyObjKind, m), offsetInArchive(offsetInArchive) {\n    this->archiveName = std::string(archiveName);\n  }\n\n  static bool classof(const InputFile *f) { return f->kind() == LazyObjKind; }\n\n  template <class ELFT> void parse();\n  void fetch();\n\n  // Check if a non-common symbol should be fetched to override a common\n  // definition.\n  bool shouldFetchForCommon(const StringRef &name);\n\n  bool fetched = false;\n\nprivate:\n  uint64_t offsetInArchive;\n};\n\n// An ArchiveFile object represents a .a file.\nclass ArchiveFile : public InputFile {\npublic:\n  explicit ArchiveFile(std::unique_ptr<Archive> &&file);\n  static bool classof(const InputFile *f) { return f->kind() == ArchiveKind; }\n  void parse();\n\n  // Pulls out an object file that contains a definition for Sym and\n  // returns it. If the same file was instantiated before, this\n  // function does nothing (so we don't instantiate the same file\n  // more than once.)\n  void fetch(const Archive::Symbol &sym);\n\n  // Check if a non-common symbol should be fetched to override a common\n  // definition.\n  bool shouldFetchForCommon(const Archive::Symbol &sym);\n\n  size_t getMemberCount() const;\n  size_t getFetchedMemberCount() const { return seen.size(); }\n\n  bool parsed = false;\n\nprivate:\n  std::unique_ptr<Archive> file;\n  llvm::DenseSet<uint64_t> seen;\n};\n\nclass BitcodeFile : public InputFile {\npublic:\n  BitcodeFile(MemoryBufferRef m, StringRef archiveName,\n              uint64_t offsetInArchive);\n  static bool classof(const InputFile *f) { return f->kind() == BitcodeKind; }\n  template <class ELFT> void parse();\n  std::unique_ptr<llvm::lto::InputFile> obj;\n};\n\n// .so file.\nclass SharedFile : public ELFFileBase {\npublic:\n  SharedFile(MemoryBufferRef m, StringRef defaultSoName)\n      : ELFFileBase(SharedKind, m), soName(std::string(defaultSoName)),\n        isNeeded(!config->asNeeded) {}\n\n  // This is actually a vector of Elf_Verdef pointers.\n  std::vector<const void *> verdefs;\n\n  // If the output file needs Elf_Verneed data structures for this file, this is\n  // a vector of Elf_Vernaux version identifiers that map onto the entries in\n  // Verdefs, otherwise it is empty.\n  std::vector<unsigned> vernauxs;\n\n  static unsigned vernauxNum;\n\n  std::vector<StringRef> dtNeeded;\n  std::string soName;\n\n  static bool classof(const InputFile *f) { return f->kind() == SharedKind; }\n\n  template <typename ELFT> void parse();\n\n  // Used for --no-allow-shlib-undefined.\n  bool allNeededIsKnown;\n\n  // Used for --as-needed\n  bool isNeeded;\n\nprivate:\n  template <typename ELFT>\n  std::vector<uint32_t> parseVerneed(const llvm::object::ELFFile<ELFT> &obj,\n                                     const typename ELFT::Shdr *sec);\n};\n\nclass BinaryFile : public InputFile {\npublic:\n  explicit BinaryFile(MemoryBufferRef m) : InputFile(BinaryKind, m) {}\n  static bool classof(const InputFile *f) { return f->kind() == BinaryKind; }\n  void parse();\n};\n\nInputFile *createObjectFile(MemoryBufferRef mb, StringRef archiveName = \"\",\n                            uint64_t offsetInArchive = 0);\n\ninline bool isBitcode(MemoryBufferRef mb) {\n  return identify_magic(mb.getBuffer()) == llvm::file_magic::bitcode;\n}\n\nstd::string replaceThinLTOSuffix(StringRef path);\n\nextern std::vector<ArchiveFile *> archiveFiles;\nextern std::vector<BinaryFile *> binaryFiles;\nextern std::vector<BitcodeFile *> bitcodeFiles;\nextern std::vector<LazyObjFile *> lazyObjFiles;\nextern std::vector<InputFile *> objectFiles;\nextern std::vector<SharedFile *> sharedFiles;\n\n} // namespace elf\n} // namespace lld\n\n#endif\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/lld/ELF/InputSection.h", "content": "//===- InputSection.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLD_ELF_INPUT_SECTION_H\n#define LLD_ELF_INPUT_SECTION_H\n\n#include \"Config.h\"\n#include \"Relocations.h\"\n#include \"Thunks.h\"\n#include \"lld/Common/LLVM.h\"\n#include \"llvm/ADT/CachedHashString.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/Object/ELF.h\"\n\nnamespace lld {\nnamespace elf {\n\nclass Symbol;\nstruct SectionPiece;\n\nclass Defined;\nstruct Partition;\nclass SyntheticSection;\nclass MergeSyntheticSection;\ntemplate <class ELFT> class ObjFile;\nclass OutputSection;\n\nextern std::vector<Partition> partitions;\n\n// This is the base class of all sections that lld handles. Some are sections in\n// input files, some are sections in the produced output file and some exist\n// just as a convenience for implementing special ways of combining some\n// sections.\nclass SectionBase {\npublic:\n  enum Kind { Regular, EHFrame, Merge, Synthetic, Output };\n\n  Kind kind() const { return (Kind)sectionKind; }\n\n  StringRef name;\n\n  // This pointer points to the \"real\" instance of this instance.\n  // Usually Repl == this. However, if ICF merges two sections,\n  // Repl pointer of one section points to another section. So,\n  // if you need to get a pointer to this instance, do not use\n  // this but instead this->Repl.\n  SectionBase *repl;\n\n  uint8_t sectionKind : 3;\n\n  // The next two bit fields are only used by InputSectionBase, but we\n  // put them here so the struct packs better.\n\n  uint8_t bss : 1;\n\n  // Set for sections that should not be folded by ICF.\n  uint8_t keepUnique : 1;\n\n  // The 1-indexed partition that this section is assigned to by the garbage\n  // collector, or 0 if this section is dead. Normally there is only one\n  // partition, so this will either be 0 or 1.\n  uint8_t partition;\n  elf::Partition &getPartition() const;\n\n  // These corresponds to the fields in Elf_Shdr.\n  uint32_t alignment;\n  uint64_t flags;\n  uint64_t entsize;\n  uint32_t type;\n  uint32_t link;\n  uint32_t info;\n\n  OutputSection *getOutputSection();\n  const OutputSection *getOutputSection() const {\n    return const_cast<SectionBase *>(this)->getOutputSection();\n  }\n\n  // Translate an offset in the input section to an offset in the output\n  // section.\n  uint64_t getOffset(uint64_t offset) const;\n\n  uint64_t getVA(uint64_t offset = 0) const;\n\n  bool isLive() const { return partition != 0; }\n  void markLive() { partition = 1; }\n  void markDead() { partition = 0; }\n\nprotected:\n  SectionBase(Kind sectionKind, StringRef name, uint64_t flags,\n              uint64_t entsize, uint64_t alignment, uint32_t type,\n              uint32_t info, uint32_t link)\n      : name(name), repl(this), sectionKind(sectionKind), bss(false),\n        keepUnique(false), partition(0), alignment(alignment), flags(flags),\n        entsize(entsize), type(type), link(link), info(info) {}\n};\n\n// This corresponds to a section of an input file.\nclass InputSectionBase : public SectionBase {\npublic:\n  template <class ELFT>\n  InputSectionBase(ObjFile<ELFT> &file, const typename ELFT::Shdr &header,\n                   StringRef name, Kind sectionKind);\n\n  InputSectionBase(InputFile *file, uint64_t flags, uint32_t type,\n                   uint64_t entsize, uint32_t link, uint32_t info,\n                   uint32_t alignment, ArrayRef<uint8_t> data, StringRef name,\n                   Kind sectionKind);\n\n  static bool classof(const SectionBase *s) { return s->kind() != Output; }\n\n  // Relocations that refer to this section.\n  unsigned numRelocations : 31;\n  unsigned areRelocsRela : 1;\n  const void *firstRelocation = nullptr;\n\n  // The file which contains this section. Its dynamic type is always\n  // ObjFile<ELFT>, but in order to avoid ELFT, we use InputFile as\n  // its static type.\n  InputFile *file;\n\n  template <class ELFT> ObjFile<ELFT> *getFile() const {\n    return cast_or_null<ObjFile<ELFT>>(file);\n  }\n\n  // If basic block sections are enabled, many code sections could end up with\n  // one or two jump instructions at the end that could be relaxed to a smaller\n  // instruction. The members below help trimming the trailing jump instruction\n  // and shrinking a section.\n  unsigned bytesDropped = 0;\n\n  // Whether the section needs to be padded with a NOP filler due to\n  // deleteFallThruJmpInsn.\n  bool nopFiller = false;\n\n  void drop_back(uint64_t num) { bytesDropped += num; }\n\n  void push_back(uint64_t num) {\n    assert(bytesDropped >= num);\n    bytesDropped -= num;\n  }\n\n  void trim() {\n    if (bytesDropped) {\n      rawData = rawData.drop_back(bytesDropped);\n      bytesDropped = 0;\n    }\n  }\n\n  ArrayRef<uint8_t> data() const {\n    if (uncompressedSize >= 0)\n      uncompress();\n    return rawData;\n  }\n\n  uint64_t getOffsetInFile() const;\n\n  // Input sections are part of an output section. Special sections\n  // like .eh_frame and merge sections are first combined into a\n  // synthetic section that is then added to an output section. In all\n  // cases this points one level up.\n  SectionBase *parent = nullptr;\n\n  // The next member in the section group if this section is in a group. This is\n  // used by --gc-sections.\n  InputSectionBase *nextInSectionGroup = nullptr;\n\n  template <class ELFT> ArrayRef<typename ELFT::Rel> rels() const {\n    assert(!areRelocsRela);\n    return llvm::makeArrayRef(\n        static_cast<const typename ELFT::Rel *>(firstRelocation),\n        numRelocations);\n  }\n\n  template <class ELFT> ArrayRef<typename ELFT::Rela> relas() const {\n    assert(areRelocsRela);\n    return llvm::makeArrayRef(\n        static_cast<const typename ELFT::Rela *>(firstRelocation),\n        numRelocations);\n  }\n\n  // InputSections that are dependent on us (reverse dependency for GC)\n  llvm::TinyPtrVector<InputSection *> dependentSections;\n\n  // Returns the size of this section (even if this is a common or BSS.)\n  size_t getSize() const;\n\n  InputSection *getLinkOrderDep() const;\n\n  // Get the function symbol that encloses this offset from within the\n  // section.\n  template <class ELFT>\n  Defined *getEnclosingFunction(uint64_t offset);\n\n  // Returns a source location string. Used to construct an error message.\n  template <class ELFT> std::string getLocation(uint64_t offset);\n  std::string getSrcMsg(const Symbol &sym, uint64_t offset);\n  std::string getObjMsg(uint64_t offset);\n\n  // Each section knows how to relocate itself. These functions apply\n  // relocations, assuming that Buf points to this section's copy in\n  // the mmap'ed output buffer.\n  template <class ELFT> void relocate(uint8_t *buf, uint8_t *bufEnd);\n  void relocateAlloc(uint8_t *buf, uint8_t *bufEnd);\n  static uint64_t getRelocTargetVA(const InputFile *File, RelType Type,\n                                   int64_t A, uint64_t P, const Symbol &Sym,\n                                   RelExpr Expr);\n\n  // The native ELF reloc data type is not very convenient to handle.\n  // So we convert ELF reloc records to our own records in Relocations.cpp.\n  // This vector contains such \"cooked\" relocations.\n  SmallVector<Relocation, 0> relocations;\n\n  // These are modifiers to jump instructions that are necessary when basic\n  // block sections are enabled.  Basic block sections creates opportunities to\n  // relax jump instructions at basic block boundaries after reordering the\n  // basic blocks.\n  SmallVector<JumpInstrMod, 0> jumpInstrMods;\n\n  // A function compiled with -fsplit-stack calling a function\n  // compiled without -fsplit-stack needs its prologue adjusted. Find\n  // such functions and adjust their prologues.  This is very similar\n  // to relocation. See https://gcc.gnu.org/wiki/SplitStacks for more\n  // information.\n  template <typename ELFT>\n  void adjustSplitStackFunctionPrologues(uint8_t *buf, uint8_t *end);\n\n\n  template <typename T> llvm::ArrayRef<T> getDataAs() const {\n    size_t s = data().size();\n    assert(s % sizeof(T) == 0);\n    return llvm::makeArrayRef<T>((const T *)data().data(), s / sizeof(T));\n  }\n\nprotected:\n  void parseCompressedHeader();\n  void uncompress() const;\n\n  mutable ArrayRef<uint8_t> rawData;\n\n  // This field stores the uncompressed size of the compressed data in rawData,\n  // or -1 if rawData is not compressed (either because the section wasn't\n  // compressed in the first place, or because we ended up uncompressing it).\n  // Since the feature is not used often, this is usually -1.\n  mutable int64_t uncompressedSize = -1;\n};\n\n// SectionPiece represents a piece of splittable section contents.\n// We allocate a lot of these and binary search on them. This means that they\n// have to be as compact as possible, which is why we don't store the size (can\n// be found by looking at the next one).\nstruct SectionPiece {\n  SectionPiece(size_t off, uint32_t hash, bool live)\n      : inputOff(off), live(live || !config->gcSections), hash(hash >> 1) {}\n\n  uint32_t inputOff;\n  uint32_t live : 1;\n  uint32_t hash : 31;\n  uint64_t outputOff = 0;\n};\n\nstatic_assert(sizeof(SectionPiece) == 16, \"SectionPiece is too big\");\n\n// This corresponds to a SHF_MERGE section of an input file.\nclass MergeInputSection : public InputSectionBase {\npublic:\n  template <class ELFT>\n  MergeInputSection(ObjFile<ELFT> &f, const typename ELFT::Shdr &header,\n                    StringRef name);\n  MergeInputSection(uint64_t flags, uint32_t type, uint64_t entsize,\n                    ArrayRef<uint8_t> data, StringRef name);\n\n  static bool classof(const SectionBase *s) { return s->kind() == Merge; }\n  void splitIntoPieces();\n\n  // Translate an offset in the input section to an offset in the parent\n  // MergeSyntheticSection.\n  uint64_t getParentOffset(uint64_t offset) const;\n\n  // Splittable sections are handled as a sequence of data\n  // rather than a single large blob of data.\n  std::vector<SectionPiece> pieces;\n\n  // Returns I'th piece's data. This function is very hot when\n  // string merging is enabled, so we want to inline.\n  LLVM_ATTRIBUTE_ALWAYS_INLINE\n  llvm::CachedHashStringRef getData(size_t i) const {\n    size_t begin = pieces[i].inputOff;\n    size_t end =\n        (pieces.size() - 1 == i) ? data().size() : pieces[i + 1].inputOff;\n    return {toStringRef(data().slice(begin, end - begin)), pieces[i].hash};\n  }\n\n  // Returns the SectionPiece at a given input section offset.\n  SectionPiece *getSectionPiece(uint64_t offset);\n  const SectionPiece *getSectionPiece(uint64_t offset) const {\n    return const_cast<MergeInputSection *>(this)->getSectionPiece(offset);\n  }\n\n  SyntheticSection *getParent() const;\n\nprivate:\n  void splitStrings(ArrayRef<uint8_t> a, size_t size);\n  void splitNonStrings(ArrayRef<uint8_t> a, size_t size);\n};\n\nstruct EhSectionPiece {\n  EhSectionPiece(size_t off, InputSectionBase *sec, uint32_t size,\n                 unsigned firstRelocation)\n      : inputOff(off), sec(sec), size(size), firstRelocation(firstRelocation) {}\n\n  ArrayRef<uint8_t> data() const {\n    return {sec->data().data() + this->inputOff, size};\n  }\n\n  size_t inputOff;\n  ssize_t outputOff = -1;\n  InputSectionBase *sec;\n  uint32_t size;\n  unsigned firstRelocation;\n};\n\n// This corresponds to a .eh_frame section of an input file.\nclass EhInputSection : public InputSectionBase {\npublic:\n  template <class ELFT>\n  EhInputSection(ObjFile<ELFT> &f, const typename ELFT::Shdr &header,\n                 StringRef name);\n  static bool classof(const SectionBase *s) { return s->kind() == EHFrame; }\n  template <class ELFT> void split();\n  template <class ELFT, class RelTy> void split(ArrayRef<RelTy> rels);\n\n  // Splittable sections are handled as a sequence of data\n  // rather than a single large blob of data.\n  std::vector<EhSectionPiece> pieces;\n\n  SyntheticSection *getParent() const;\n};\n\n// This is a section that is added directly to an output section\n// instead of needing special combination via a synthetic section. This\n// includes all input sections with the exceptions of SHF_MERGE and\n// .eh_frame. It also includes the synthetic sections themselves.\nclass InputSection : public InputSectionBase {\npublic:\n  InputSection(InputFile *f, uint64_t flags, uint32_t type, uint32_t alignment,\n               ArrayRef<uint8_t> data, StringRef name, Kind k = Regular);\n  template <class ELFT>\n  InputSection(ObjFile<ELFT> &f, const typename ELFT::Shdr &header,\n               StringRef name);\n\n  // Write this section to a mmap'ed file, assuming Buf is pointing to\n  // beginning of the output section.\n  template <class ELFT> void writeTo(uint8_t *buf);\n\n  uint64_t getOffset(uint64_t offset) const { return outSecOff + offset; }\n\n  OutputSection *getParent() const;\n\n  // This variable has two usages. Initially, it represents an index in the\n  // OutputSection's InputSection list, and is used when ordering SHF_LINK_ORDER\n  // sections. After assignAddresses is called, it represents the offset from\n  // the beginning of the output section this section was assigned to.\n  uint64_t outSecOff = 0;\n\n  static bool classof(const SectionBase *s);\n\n  InputSectionBase *getRelocatedSection() const;\n\n  template <class ELFT, class RelTy>\n  void relocateNonAlloc(uint8_t *buf, llvm::ArrayRef<RelTy> rels);\n\n  // Used by ICF.\n  uint32_t eqClass[2] = {0, 0};\n\n  // Called by ICF to merge two input sections.\n  void replace(InputSection *other);\n\n  static InputSection discarded;\n\nprivate:\n  template <class ELFT, class RelTy>\n  void copyRelocations(uint8_t *buf, llvm::ArrayRef<RelTy> rels);\n\n  template <class ELFT> void copyShtGroup(uint8_t *buf);\n};\n\n#ifdef _WIN32\nstatic_assert(sizeof(InputSection) <= 192, \"InputSection is too big\");\n#else\nstatic_assert(sizeof(InputSection) <= 184, \"InputSection is too big\");\n#endif\n\ninline bool isDebugSection(const InputSectionBase &sec) {\n  return (sec.flags & llvm::ELF::SHF_ALLOC) == 0 &&\n         (sec.name.startswith(\".debug\") || sec.name.startswith(\".zdebug\"));\n}\n\n// The list of all input sections.\nextern std::vector<InputSectionBase *> inputSections;\n\n// The set of TOC entries (.toc + addend) for which we should not apply\n// toc-indirect to toc-relative relaxation. const Symbol * refers to the\n// STT_SECTION symbol associated to the .toc input section.\nextern llvm::DenseSet<std::pair<const Symbol *, uint64_t>> ppc64noTocRelax;\n\n} // namespace elf\n\nstd::string toString(const elf::InputSectionBase *);\n} // namespace lld\n\n#endif\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/lld/ELF/LinkerScript.h", "content": "//===- LinkerScript.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLD_ELF_LINKER_SCRIPT_H\n#define LLD_ELF_LINKER_SCRIPT_H\n\n#include \"Config.h\"\n#include \"Writer.h\"\n#include \"lld/Common/LLVM.h\"\n#include \"lld/Common/Strings.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include <cstddef>\n#include <cstdint>\n#include <functional>\n#include <memory>\n#include <vector>\n\nnamespace lld {\nnamespace elf {\n\nclass Defined;\nclass InputFile;\nclass InputSection;\nclass InputSectionBase;\nclass OutputSection;\nclass SectionBase;\nclass Symbol;\nclass ThunkSection;\n\n// This represents an r-value in the linker script.\nstruct ExprValue {\n  ExprValue(SectionBase *sec, bool forceAbsolute, uint64_t val,\n            const Twine &loc)\n      : sec(sec), forceAbsolute(forceAbsolute), val(val), loc(loc.str()) {}\n\n  ExprValue(uint64_t val) : ExprValue(nullptr, false, val, \"\") {}\n\n  bool isAbsolute() const { return forceAbsolute || sec == nullptr; }\n  uint64_t getValue() const;\n  uint64_t getSecAddr() const;\n  uint64_t getSectionOffset() const;\n\n  // If a value is relative to a section, it has a non-null Sec.\n  SectionBase *sec;\n\n  // True if this expression is enclosed in ABSOLUTE().\n  // This flag affects the return value of getValue().\n  bool forceAbsolute;\n\n  uint64_t val;\n  uint64_t alignment = 1;\n\n  // The original st_type if the expression represents a symbol. Any operation\n  // resets type to STT_NOTYPE.\n  uint8_t type = llvm::ELF::STT_NOTYPE;\n\n  // Original source location. Used for error messages.\n  std::string loc;\n};\n\n// This represents an expression in the linker script.\n// ScriptParser::readExpr reads an expression and returns an Expr.\n// Later, we evaluate the expression by calling the function.\nusing Expr = std::function<ExprValue()>;\n\n// This enum is used to implement linker script SECTIONS command.\n// https://sourceware.org/binutils/docs/ld/SECTIONS.html#SECTIONS\nenum SectionsCommandKind {\n  AssignmentKind, // . = expr or <sym> = expr\n  OutputSectionKind,\n  InputSectionKind,\n  ByteKind    // BYTE(expr), SHORT(expr), LONG(expr) or QUAD(expr)\n};\n\nstruct BaseCommand {\n  BaseCommand(int k) : kind(k) {}\n  int kind;\n};\n\n// This represents \". = <expr>\" or \"<symbol> = <expr>\".\nstruct SymbolAssignment : BaseCommand {\n  SymbolAssignment(StringRef name, Expr e, std::string loc)\n      : BaseCommand(AssignmentKind), name(name), expression(e), location(loc) {}\n\n  static bool classof(const BaseCommand *c) {\n    return c->kind == AssignmentKind;\n  }\n\n  // The LHS of an expression. Name is either a symbol name or \".\".\n  StringRef name;\n  Defined *sym = nullptr;\n\n  // The RHS of an expression.\n  Expr expression;\n\n  // Command attributes for PROVIDE, HIDDEN and PROVIDE_HIDDEN.\n  bool provide = false;\n  bool hidden = false;\n\n  // Holds file name and line number for error reporting.\n  std::string location;\n\n  // A string representation of this command. We use this for -Map.\n  std::string commandString;\n\n  // Address of this assignment command.\n  uint64_t addr;\n\n  // Size of this assignment command. This is usually 0, but if\n  // you move '.' this may be greater than 0.\n  uint64_t size;\n};\n\n// Linker scripts allow additional constraints to be put on output sections.\n// If an output section is marked as ONLY_IF_RO, the section is created\n// only if its input sections are read-only. Likewise, an output section\n// with ONLY_IF_RW is created if all input sections are RW.\nenum class ConstraintKind { NoConstraint, ReadOnly, ReadWrite };\n\n// This struct is used to represent the location and size of regions of\n// target memory. Instances of the struct are created by parsing the\n// MEMORY command.\nstruct MemoryRegion {\n  MemoryRegion(StringRef name, Expr origin, Expr length, uint32_t flags,\n               uint32_t negFlags)\n      : name(std::string(name)), origin(origin), length(length), flags(flags),\n        negFlags(negFlags) {}\n\n  std::string name;\n  Expr origin;\n  Expr length;\n  uint32_t flags;\n  uint32_t negFlags;\n  uint64_t curPos = 0;\n};\n\n// This struct represents one section match pattern in SECTIONS() command.\n// It can optionally have negative match pattern for EXCLUDED_FILE command.\n// Also it may be surrounded with SORT() command, so contains sorting rules.\nclass SectionPattern {\n  StringMatcher excludedFilePat;\n\n  // Cache of the most recent input argument and result of excludesFile().\n  mutable llvm::Optional<std::pair<const InputFile *, bool>> excludesFileCache;\n\npublic:\n  SectionPattern(StringMatcher &&pat1, StringMatcher &&pat2)\n      : excludedFilePat(pat1), sectionPat(pat2),\n        sortOuter(SortSectionPolicy::Default),\n        sortInner(SortSectionPolicy::Default) {}\n\n  bool excludesFile(const InputFile *file) const;\n\n  StringMatcher sectionPat;\n  SortSectionPolicy sortOuter;\n  SortSectionPolicy sortInner;\n};\n\nclass InputSectionDescription : public BaseCommand {\n  SingleStringMatcher filePat;\n\n  // Cache of the most recent input argument and result of matchesFile().\n  mutable llvm::Optional<std::pair<const InputFile *, bool>> matchesFileCache;\n\npublic:\n  InputSectionDescription(StringRef filePattern, uint64_t withFlags = 0,\n                          uint64_t withoutFlags = 0)\n      : BaseCommand(InputSectionKind), filePat(filePattern),\n        withFlags(withFlags), withoutFlags(withoutFlags) {}\n\n  static bool classof(const BaseCommand *c) {\n    return c->kind == InputSectionKind;\n  }\n\n  bool matchesFile(const InputFile *file) const;\n\n  // Input sections that matches at least one of SectionPatterns\n  // will be associated with this InputSectionDescription.\n  std::vector<SectionPattern> sectionPatterns;\n\n  // Includes InputSections and MergeInputSections. Used temporarily during\n  // assignment of input sections to output sections.\n  std::vector<InputSectionBase *> sectionBases;\n\n  // Used after the finalizeInputSections() pass. MergeInputSections have been\n  // merged into MergeSyntheticSections.\n  std::vector<InputSection *> sections;\n\n  // Temporary record of synthetic ThunkSection instances and the pass that\n  // they were created in. This is used to insert newly created ThunkSections\n  // into Sections at the end of a createThunks() pass.\n  std::vector<std::pair<ThunkSection *, uint32_t>> thunkSections;\n\n  // SectionPatterns can be filtered with the INPUT_SECTION_FLAGS command.\n  uint64_t withFlags;\n  uint64_t withoutFlags;\n};\n\n// Represents BYTE(), SHORT(), LONG(), or QUAD().\nstruct ByteCommand : BaseCommand {\n  ByteCommand(Expr e, unsigned size, std::string commandString)\n      : BaseCommand(ByteKind), commandString(commandString), expression(e),\n        size(size) {}\n\n  static bool classof(const BaseCommand *c) { return c->kind == ByteKind; }\n\n  // Keeps string representing the command. Used for -Map\" is perhaps better.\n  std::string commandString;\n\n  Expr expression;\n\n  // This is just an offset of this assignment command in the output section.\n  unsigned offset;\n\n  // Size of this data command.\n  unsigned size;\n};\n\nstruct InsertCommand {\n  OutputSection *os;\n  bool isAfter;\n  StringRef where;\n};\n\nstruct PhdrsCommand {\n  StringRef name;\n  unsigned type = llvm::ELF::PT_NULL;\n  bool hasFilehdr = false;\n  bool hasPhdrs = false;\n  llvm::Optional<unsigned> flags;\n  Expr lmaExpr = nullptr;\n};\n\nclass LinkerScript final {\n  // Temporary state used in processSectionCommands() and assignAddresses()\n  // that must be reinitialized for each call to the above functions, and must\n  // not be used outside of the scope of a call to the above functions.\n  struct AddressState {\n    AddressState();\n    uint64_t threadBssOffset = 0;\n    OutputSection *outSec = nullptr;\n    MemoryRegion *memRegion = nullptr;\n    MemoryRegion *lmaRegion = nullptr;\n    uint64_t lmaOffset = 0;\n  };\n\n  llvm::DenseMap<StringRef, OutputSection *> nameToOutputSection;\n\n  void addSymbol(SymbolAssignment *cmd);\n  void assignSymbol(SymbolAssignment *cmd, bool inSec);\n  void setDot(Expr e, const Twine &loc, bool inSec);\n  void expandOutputSection(uint64_t size);\n  void expandMemoryRegions(uint64_t size);\n\n  std::vector<InputSectionBase *>\n  computeInputSections(const InputSectionDescription *,\n                       ArrayRef<InputSectionBase *>);\n\n  std::vector<InputSectionBase *> createInputSectionList(OutputSection &cmd);\n\n  void discardSynthetic(OutputSection &);\n\n  std::vector<size_t> getPhdrIndices(OutputSection *sec);\n\n  MemoryRegion *findMemoryRegion(OutputSection *sec);\n\n  void switchTo(OutputSection *sec);\n  uint64_t advance(uint64_t size, unsigned align);\n  void output(InputSection *sec);\n\n  void assignOffsets(OutputSection *sec);\n\n  // Ctx captures the local AddressState and makes it accessible\n  // deliberately. This is needed as there are some cases where we cannot just\n  // thread the current state through to a lambda function created by the\n  // script parser.\n  // This should remain a plain pointer as its lifetime is smaller than\n  // LinkerScript.\n  AddressState *ctx = nullptr;\n\n  OutputSection *aether;\n\n  uint64_t dot;\n\npublic:\n  OutputSection *createOutputSection(StringRef name, StringRef location);\n  OutputSection *getOrCreateOutputSection(StringRef name);\n\n  bool hasPhdrsCommands() { return !phdrsCommands.empty(); }\n  uint64_t getDot() { return dot; }\n  void discard(InputSectionBase *s);\n\n  ExprValue getSymbolValue(StringRef name, const Twine &loc);\n\n  void addOrphanSections();\n  void diagnoseOrphanHandling() const;\n  void adjustSectionsBeforeSorting();\n  void adjustSectionsAfterSorting();\n\n  std::vector<PhdrEntry *> createPhdrs();\n  bool needsInterpSection();\n\n  bool shouldKeep(InputSectionBase *s);\n  const Defined *assignAddresses();\n  void allocateHeaders(std::vector<PhdrEntry *> &phdrs);\n  void processSectionCommands();\n  void processSymbolAssignments();\n  void declareSymbols();\n\n  // Used to handle INSERT AFTER statements.\n  void processInsertCommands();\n\n  // SECTIONS command list.\n  std::vector<BaseCommand *> sectionCommands;\n\n  // PHDRS command list.\n  std::vector<PhdrsCommand> phdrsCommands;\n\n  bool hasSectionsCommand = false;\n  bool errorOnMissingSection = false;\n\n  // List of section patterns specified with KEEP commands. They will\n  // be kept even if they are unused and --gc-sections is specified.\n  std::vector<InputSectionDescription *> keptSections;\n\n  // A map from memory region name to a memory region descriptor.\n  llvm::MapVector<llvm::StringRef, MemoryRegion *> memoryRegions;\n\n  // A list of symbols referenced by the script.\n  std::vector<llvm::StringRef> referencedSymbols;\n\n  // Used to implement INSERT [AFTER|BEFORE]. Contains output sections that need\n  // to be reordered.\n  std::vector<InsertCommand> insertCommands;\n\n  // Sections that will be warned/errored by --orphan-handling.\n  std::vector<const InputSectionBase *> orphanSections;\n};\n\nextern LinkerScript *script;\n\n} // end namespace elf\n} // end namespace lld\n\n#endif // LLD_ELF_LINKER_SCRIPT_H\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/lld/ELF/OutputSections.h", "content": "//===- OutputSections.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLD_ELF_OUTPUT_SECTIONS_H\n#define LLD_ELF_OUTPUT_SECTIONS_H\n\n#include \"Config.h\"\n#include \"InputSection.h\"\n#include \"LinkerScript.h\"\n#include \"Relocations.h\"\n#include \"lld/Common/LLVM.h\"\n#include \"llvm/MC/StringTableBuilder.h\"\n#include \"llvm/Object/ELF.h\"\n#include <array>\n\nnamespace lld {\nnamespace elf {\n\nstruct PhdrEntry;\nclass InputSection;\nclass InputSectionBase;\n\n// This represents a section in an output file.\n// It is composed of multiple InputSections.\n// The writer creates multiple OutputSections and assign them unique,\n// non-overlapping file offsets and VAs.\nclass OutputSection final : public BaseCommand, public SectionBase {\npublic:\n  OutputSection(StringRef name, uint32_t type, uint64_t flags);\n\n  static bool classof(const SectionBase *s) {\n    return s->kind() == SectionBase::Output;\n  }\n\n  static bool classof(const BaseCommand *c);\n\n  uint64_t getLMA() const { return ptLoad ? addr + ptLoad->lmaOffset : addr; }\n  template <typename ELFT> void writeHeaderTo(typename ELFT::Shdr *sHdr);\n\n  uint32_t sectionIndex = UINT32_MAX;\n  unsigned sortRank;\n\n  uint32_t getPhdrFlags() const;\n\n  // Pointer to the PT_LOAD segment, which this section resides in. This field\n  // is used to correctly compute file offset of a section. When two sections\n  // share the same load segment, difference between their file offsets should\n  // be equal to difference between their virtual addresses. To compute some\n  // section offset we use the following formula: Off = Off_first + VA -\n  // VA_first, where Off_first and VA_first is file offset and VA of first\n  // section in PT_LOAD.\n  PhdrEntry *ptLoad = nullptr;\n\n  // Pointer to a relocation section for this section. Usually nullptr because\n  // we consume relocations, but if --emit-relocs is specified (which is rare),\n  // it may have a non-null value.\n  OutputSection *relocationSection = nullptr;\n\n  // Initially this field is the number of InputSections that have been added to\n  // the OutputSection so far. Later on, after a call to assignAddresses, it\n  // corresponds to the Elf_Shdr member.\n  uint64_t size = 0;\n\n  // The following fields correspond to Elf_Shdr members.\n  uint64_t offset = 0;\n  uint64_t addr = 0;\n  uint32_t shName = 0;\n\n  void recordSection(InputSectionBase *isec);\n  void commitSection(InputSection *isec);\n  void finalizeInputSections();\n\n  // The following members are normally only used in linker scripts.\n  MemoryRegion *memRegion = nullptr;\n  MemoryRegion *lmaRegion = nullptr;\n  Expr addrExpr;\n  Expr alignExpr;\n  Expr lmaExpr;\n  Expr subalignExpr;\n  std::vector<BaseCommand *> sectionCommands;\n  std::vector<StringRef> phdrs;\n  llvm::Optional<std::array<uint8_t, 4>> filler;\n  ConstraintKind constraint = ConstraintKind::NoConstraint;\n  std::string location;\n  std::string memoryRegionName;\n  std::string lmaRegionName;\n  bool nonAlloc = false;\n  bool noload = false;\n  bool expressionsUseSymbols = false;\n  bool usedInExpression = false;\n  bool inOverlay = false;\n\n  // Tracks whether the section has ever had an input section added to it, even\n  // if the section was later removed (e.g. because it is a synthetic section\n  // that wasn't needed). This is needed for orphan placement.\n  bool hasInputSections = false;\n\n  void finalize();\n  template <class ELFT> void writeTo(uint8_t *buf);\n  template <class ELFT> void maybeCompress();\n\n  void sort(llvm::function_ref<int(InputSectionBase *s)> order);\n  void sortInitFini();\n  void sortCtorsDtors();\n\nprivate:\n  // Used for implementation of --compress-debug-sections option.\n  std::vector<uint8_t> zDebugHeader;\n  llvm::SmallVector<char, 0> compressedData;\n\n  std::array<uint8_t, 4> getFiller();\n};\n\nint getPriority(StringRef s);\n\nInputSection *getFirstInputSection(const OutputSection *os);\nstd::vector<InputSection *> getInputSections(const OutputSection *os);\n\n// All output sections that are handled by the linker specially are\n// globally accessible. Writer initializes them, so don't use them\n// until Writer is initialized.\nstruct Out {\n  static uint8_t *bufferStart;\n  static uint8_t first;\n  static PhdrEntry *tlsPhdr;\n  static OutputSection *elfHeader;\n  static OutputSection *programHeaders;\n  static OutputSection *preinitArray;\n  static OutputSection *initArray;\n  static OutputSection *finiArray;\n};\n\nuint64_t getHeaderSize();\n\nextern std::vector<OutputSection *> outputSections;\n} // namespace elf\n} // namespace lld\n\n#endif\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/lld/ELF/Relocations.h", "content": "//===- Relocations.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLD_ELF_RELOCATIONS_H\n#define LLD_ELF_RELOCATIONS_H\n\n#include \"lld/Common/LLVM.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include <map>\n#include <vector>\n\nnamespace lld {\nnamespace elf {\nclass Symbol;\nclass InputSection;\nclass InputSectionBase;\nclass OutputSection;\nclass SectionBase;\n\n// Represents a relocation type, such as R_X86_64_PC32 or R_ARM_THM_CALL.\nusing RelType = uint32_t;\nusing JumpModType = uint32_t;\n\n// List of target-independent relocation types. Relocations read\n// from files are converted to these types so that the main code\n// doesn't have to know about architecture-specific details.\nenum RelExpr {\n  R_ABS,\n  R_ADDEND,\n  R_DTPREL,\n  R_GOT,\n  R_GOT_OFF,\n  R_GOT_PC,\n  R_GOTONLY_PC,\n  R_GOTPLTONLY_PC,\n  R_GOTPLT,\n  R_GOTPLTREL,\n  R_GOTREL,\n  R_NONE,\n  R_PC,\n  R_PLT,\n  R_PLT_PC,\n  R_RELAX_GOT_PC,\n  R_RELAX_GOT_PC_NOPIC,\n  R_RELAX_TLS_GD_TO_IE,\n  R_RELAX_TLS_GD_TO_IE_ABS,\n  R_RELAX_TLS_GD_TO_IE_GOT_OFF,\n  R_RELAX_TLS_GD_TO_IE_GOTPLT,\n  R_RELAX_TLS_GD_TO_LE,\n  R_RELAX_TLS_GD_TO_LE_NEG,\n  R_RELAX_TLS_IE_TO_LE,\n  R_RELAX_TLS_LD_TO_LE,\n  R_RELAX_TLS_LD_TO_LE_ABS,\n  R_SIZE,\n  R_TPREL,\n  R_TPREL_NEG,\n  R_TLSDESC,\n  R_TLSDESC_CALL,\n  R_TLSDESC_PC,\n  R_TLSGD_GOT,\n  R_TLSGD_GOTPLT,\n  R_TLSGD_PC,\n  R_TLSIE_HINT,\n  R_TLSLD_GOT,\n  R_TLSLD_GOTPLT,\n  R_TLSLD_GOT_OFF,\n  R_TLSLD_HINT,\n  R_TLSLD_PC,\n\n  // The following is abstract relocation types used for only one target.\n  //\n  // Even though RelExpr is intended to be a target-neutral representation\n  // of a relocation type, there are some relocations whose semantics are\n  // unique to a target. Such relocation are marked with R_<TARGET_NAME>.\n  R_AARCH64_GOT_PAGE_PC,\n  R_AARCH64_GOT_PAGE,\n  R_AARCH64_PAGE_PC,\n  R_AARCH64_RELAX_TLS_GD_TO_IE_PAGE_PC,\n  R_AARCH64_TLSDESC_PAGE,\n  R_ARM_PCA,\n  R_ARM_SBREL,\n  R_MIPS_GOTREL,\n  R_MIPS_GOT_GP,\n  R_MIPS_GOT_GP_PC,\n  R_MIPS_GOT_LOCAL_PAGE,\n  R_MIPS_GOT_OFF,\n  R_MIPS_GOT_OFF32,\n  R_MIPS_TLSGD,\n  R_MIPS_TLSLD,\n  R_PPC32_PLTREL,\n  R_PPC64_CALL,\n  R_PPC64_CALL_PLT,\n  R_PPC64_RELAX_TOC,\n  R_PPC64_TOCBASE,\n  R_PPC64_RELAX_GOT_PC,\n  R_RISCV_ADD,\n  R_RISCV_PC_INDIRECT,\n};\n\n// Architecture-neutral representation of relocation.\nstruct Relocation {\n  RelExpr expr;\n  RelType type;\n  uint64_t offset;\n  int64_t addend;\n  Symbol *sym;\n};\n\n// Manipulate jump instructions with these modifiers.  These are used to relax\n// jump instruction opcodes at basic block boundaries and are particularly\n// useful when basic block sections are enabled.\nstruct JumpInstrMod {\n  JumpModType original;\n  uint64_t offset;\n  unsigned size;\n};\n\n// This function writes undefined symbol diagnostics to an internal buffer.\n// Call reportUndefinedSymbols() after calling scanRelocations() to emit\n// the diagnostics.\ntemplate <class ELFT> void scanRelocations(InputSectionBase &);\n\ntemplate <class ELFT> void reportUndefinedSymbols();\n\nvoid hexagonTLSSymbolUpdate(ArrayRef<OutputSection *> outputSections);\nbool hexagonNeedsTLSSymbol(ArrayRef<OutputSection *> outputSections);\n\nclass ThunkSection;\nclass Thunk;\nclass InputSectionDescription;\n\nclass ThunkCreator {\npublic:\n  // Return true if Thunks have been added to OutputSections\n  bool createThunks(ArrayRef<OutputSection *> outputSections);\n\n  // The number of completed passes of createThunks this permits us\n  // to do one time initialization on Pass 0 and put a limit on the\n  // number of times it can be called to prevent infinite loops.\n  uint32_t pass = 0;\n\nprivate:\n  void mergeThunks(ArrayRef<OutputSection *> outputSections);\n\n  ThunkSection *getISDThunkSec(OutputSection *os, InputSection *isec,\n                               InputSectionDescription *isd,\n                               const Relocation &rel, uint64_t src);\n\n  ThunkSection *getISThunkSec(InputSection *isec);\n\n  void createInitialThunkSections(ArrayRef<OutputSection *> outputSections);\n\n  std::pair<Thunk *, bool> getThunk(InputSection *isec, Relocation &rel,\n                                    uint64_t src);\n\n  ThunkSection *addThunkSection(OutputSection *os, InputSectionDescription *,\n                                uint64_t off);\n\n  bool normalizeExistingThunk(Relocation &rel, uint64_t src);\n\n  // Record all the available Thunks for a (Symbol, addend) pair, where Symbol\n  // is represented as a (section, offset) pair. There may be multiple\n  // relocations sharing the same (section, offset + addend) pair. We may revert\n  // a relocation back to its original non-Thunk target, and restore the\n  // original addend, so we cannot fold offset + addend. A nested pair is used\n  // because DenseMapInfo is not specialized for std::tuple.\n  llvm::DenseMap<std::pair<std::pair<SectionBase *, uint64_t>, int64_t>,\n                 std::vector<Thunk *>>\n      thunkedSymbolsBySectionAndAddend;\n  llvm::DenseMap<std::pair<Symbol *, int64_t>, std::vector<Thunk *>>\n      thunkedSymbols;\n\n  // Find a Thunk from the Thunks symbol definition, we can use this to find\n  // the Thunk from a relocation to the Thunks symbol definition.\n  llvm::DenseMap<Symbol *, Thunk *> thunks;\n\n  // Track InputSections that have an inline ThunkSection placed in front\n  // an inline ThunkSection may have control fall through to the section below\n  // so we need to make sure that there is only one of them.\n  // The Mips LA25 Thunk is an example of an inline ThunkSection.\n  llvm::DenseMap<InputSection *, ThunkSection *> thunkedSections;\n};\n\n// Return a int64_t to make sure we get the sign extension out of the way as\n// early as possible.\ntemplate <class ELFT>\nstatic inline int64_t getAddend(const typename ELFT::Rel &rel) {\n  return 0;\n}\ntemplate <class ELFT>\nstatic inline int64_t getAddend(const typename ELFT::Rela &rel) {\n  return rel.r_addend;\n}\n} // namespace elf\n} // namespace lld\n\n#endif\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/lld/ELF/SymbolTable.h", "content": "//===- SymbolTable.h --------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLD_ELF_SYMBOL_TABLE_H\n#define LLD_ELF_SYMBOL_TABLE_H\n\n#include \"InputFiles.h\"\n#include \"Symbols.h\"\n#include \"lld/Common/Strings.h\"\n#include \"llvm/ADT/CachedHashString.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/STLExtras.h\"\n\nnamespace lld {\nnamespace elf {\n\n// SymbolTable is a bucket of all known symbols, including defined,\n// undefined, or lazy symbols (the last one is symbols in archive\n// files whose archive members are not yet loaded).\n//\n// We put all symbols of all files to a SymbolTable, and the\n// SymbolTable selects the \"best\" symbols if there are name\n// conflicts. For example, obviously, a defined symbol is better than\n// an undefined symbol. Or, if there's a conflict between a lazy and a\n// undefined, it'll read an archive member to read a real definition\n// to replace the lazy symbol. The logic is implemented in the\n// add*() functions, which are called by input files as they are parsed. There\n// is one add* function per symbol type.\nclass SymbolTable {\n  struct FilterOutPlaceholder {\n    bool operator()(Symbol *S) const { return !S->isPlaceholder(); }\n  };\n  using iterator = llvm::filter_iterator<std::vector<Symbol *>::const_iterator,\n                                         FilterOutPlaceholder>;\n\npublic:\n  llvm::iterator_range<iterator> symbols() const {\n    return llvm::make_filter_range(symVector, FilterOutPlaceholder());\n  }\n\n  void wrap(Symbol *sym, Symbol *real, Symbol *wrap);\n\n  Symbol *insert(StringRef name);\n\n  Symbol *addSymbol(const Symbol &newSym);\n\n  void scanVersionScript();\n\n  Symbol *find(StringRef name);\n\n  void handleDynamicList();\n\n  // Set of .so files to not link the same shared object file more than once.\n  llvm::DenseMap<StringRef, SharedFile *> soNames;\n\n  // Comdat groups define \"link once\" sections. If two comdat groups have the\n  // same name, only one of them is linked, and the other is ignored. This map\n  // is used to uniquify them.\n  llvm::DenseMap<llvm::CachedHashStringRef, const InputFile *> comdatGroups;\n\nprivate:\n  std::vector<Symbol *> findByVersion(SymbolVersion ver);\n  std::vector<Symbol *> findAllByVersion(SymbolVersion ver);\n\n  llvm::StringMap<std::vector<Symbol *>> &getDemangledSyms();\n  void assignExactVersion(SymbolVersion ver, uint16_t versionId,\n                          StringRef versionName);\n  void assignWildcardVersion(SymbolVersion ver, uint16_t versionId);\n\n  // The order the global symbols are in is not defined. We can use an arbitrary\n  // order, but it has to be reproducible. That is true even when cross linking.\n  // The default hashing of StringRef produces different results on 32 and 64\n  // bit systems so we use a map to a vector. That is arbitrary, deterministic\n  // but a bit inefficient.\n  // FIXME: Experiment with passing in a custom hashing or sorting the symbols\n  // once symbol resolution is finished.\n  llvm::DenseMap<llvm::CachedHashStringRef, int> symMap;\n  std::vector<Symbol *> symVector;\n\n  // A map from demangled symbol names to their symbol objects.\n  // This mapping is 1:N because two symbols with different versions\n  // can have the same name. We use this map to handle \"extern C++ {}\"\n  // directive in version scripts.\n  llvm::Optional<llvm::StringMap<std::vector<Symbol *>>> demangledSyms;\n};\n\nextern SymbolTable *symtab;\n\n} // namespace elf\n} // namespace lld\n\n#endif\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/lld/ELF/Symbols.h", "content": "//===- Symbols.h ------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines various types of Symbols.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLD_ELF_SYMBOLS_H\n#define LLD_ELF_SYMBOLS_H\n\n#include \"InputFiles.h\"\n#include \"InputSection.h\"\n#include \"lld/Common/LLVM.h\"\n#include \"lld/Common/Strings.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/Object/Archive.h\"\n#include \"llvm/Object/ELF.h\"\n\nnamespace lld {\n// Returns a string representation for a symbol for diagnostics.\nstd::string toString(const elf::Symbol &);\n\n// There are two different ways to convert an Archive::Symbol to a string:\n// One for Microsoft name mangling and one for Itanium name mangling.\n// Call the functions toCOFFString and toELFString, not just toString.\nstd::string toELFString(const llvm::object::Archive::Symbol &);\n\nnamespace elf {\nclass CommonSymbol;\nclass Defined;\nclass InputFile;\nclass LazyArchive;\nclass LazyObject;\nclass SharedSymbol;\nclass Symbol;\nclass Undefined;\n\n// This is a StringRef-like container that doesn't run strlen().\n//\n// ELF string tables contain a lot of null-terminated strings. Most of them\n// are not necessary for the linker because they are names of local symbols,\n// and the linker doesn't use local symbol names for name resolution. So, we\n// use this class to represents strings read from string tables.\nstruct StringRefZ {\n  StringRefZ(const char *s) : data(s), size(-1) {}\n  StringRefZ(StringRef s) : data(s.data()), size(s.size()) {}\n\n  const char *data;\n  const uint32_t size;\n};\n\n// The base class for real symbol classes.\nclass Symbol {\npublic:\n  enum Kind {\n    PlaceholderKind,\n    DefinedKind,\n    CommonKind,\n    SharedKind,\n    UndefinedKind,\n    LazyArchiveKind,\n    LazyObjectKind,\n  };\n\n  Kind kind() const { return static_cast<Kind>(symbolKind); }\n\n  // The file from which this symbol was created.\n  InputFile *file;\n\nprotected:\n  const char *nameData;\n  mutable uint32_t nameSize;\n\npublic:\n  uint32_t dynsymIndex = 0;\n  uint32_t gotIndex = -1;\n  uint32_t pltIndex = -1;\n\n  uint32_t globalDynIndex = -1;\n\n  // This field is a index to the symbol's version definition.\n  uint32_t verdefIndex = -1;\n\n  // Version definition index.\n  uint16_t versionId;\n\n  // Symbol binding. This is not overwritten by replace() to track\n  // changes during resolution. In particular:\n  //  - An undefined weak is still weak when it resolves to a shared library.\n  //  - An undefined weak will not fetch archive members, but we have to\n  //    remember it is weak.\n  uint8_t binding;\n\n  // The following fields have the same meaning as the ELF symbol attributes.\n  uint8_t type;    // symbol type\n  uint8_t stOther; // st_other field value\n\n  uint8_t symbolKind;\n\n  // Symbol visibility. This is the computed minimum visibility of all\n  // observed non-DSO symbols.\n  uint8_t visibility : 2;\n\n  // True if the symbol was used for linking and thus need to be added to the\n  // output file's symbol table. This is true for all symbols except for\n  // unreferenced DSO symbols, lazy (archive) symbols, and bitcode symbols that\n  // are unreferenced except by other bitcode objects.\n  uint8_t isUsedInRegularObj : 1;\n\n  // Used by a Defined symbol with protected or default visibility, to record\n  // whether it is required to be exported into .dynsym. This is set when any of\n  // the following conditions hold:\n  //\n  // - If there is an interposable symbol from a DSO.\n  // - If -shared or --export-dynamic is specified, any symbol in an object\n  //   file/bitcode sets this property, unless suppressed by LTO\n  //   canBeOmittedFromSymbolTable().\n  uint8_t exportDynamic : 1;\n\n  // True if the symbol is in the --dynamic-list file. A Defined symbol with\n  // protected or default visibility with this property is required to be\n  // exported into .dynsym.\n  uint8_t inDynamicList : 1;\n\n  // False if LTO shouldn't inline whatever this symbol points to. If a symbol\n  // is overwritten after LTO, LTO shouldn't inline the symbol because it\n  // doesn't know the final contents of the symbol.\n  uint8_t canInline : 1;\n\n  // Used to track if there has been at least one undefined reference to the\n  // symbol. For Undefined and SharedSymbol, the binding may change to STB_WEAK\n  // if the first undefined reference from a non-shared object is weak.\n  //\n  // This is also used to retain __wrap_foo when foo is referenced.\n  uint8_t referenced : 1;\n\n  // True if this symbol is specified by --trace-symbol option.\n  uint8_t traced : 1;\n\n  inline void replace(const Symbol &newSym);\n\n  bool includeInDynsym() const;\n  uint8_t computeBinding() const;\n  bool isWeak() const { return binding == llvm::ELF::STB_WEAK; }\n\n  bool isUndefined() const { return symbolKind == UndefinedKind; }\n  bool isCommon() const { return symbolKind == CommonKind; }\n  bool isDefined() const { return symbolKind == DefinedKind; }\n  bool isShared() const { return symbolKind == SharedKind; }\n  bool isPlaceholder() const { return symbolKind == PlaceholderKind; }\n\n  bool isLocal() const { return binding == llvm::ELF::STB_LOCAL; }\n\n  bool isLazy() const {\n    return symbolKind == LazyArchiveKind || symbolKind == LazyObjectKind;\n  }\n\n  // True if this is an undefined weak symbol. This only works once\n  // all input files have been added.\n  bool isUndefWeak() const {\n    // See comment on lazy symbols for details.\n    return isWeak() && (isUndefined() || isLazy());\n  }\n\n  StringRef getName() const {\n    if (nameSize == (uint32_t)-1)\n      nameSize = strlen(nameData);\n    return {nameData, nameSize};\n  }\n\n  void setName(StringRef s) {\n    nameData = s.data();\n    nameSize = s.size();\n  }\n\n  void parseSymbolVersion();\n\n  // Get the NUL-terminated version suffix (\"\", \"@...\", or \"@@...\").\n  //\n  // For @@, the name has been truncated by insert(). For @, the name has been\n  // truncated by Symbol::parseSymbolVersion().\n  const char *getVersionSuffix() const {\n    (void)getName();\n    return nameData + nameSize;\n  }\n\n  bool isInGot() const { return gotIndex != -1U; }\n  bool isInPlt() const { return pltIndex != -1U; }\n\n  uint64_t getVA(int64_t addend = 0) const;\n\n  uint64_t getGotOffset() const;\n  uint64_t getGotVA() const;\n  uint64_t getGotPltOffset() const;\n  uint64_t getGotPltVA() const;\n  uint64_t getPltVA() const;\n  uint64_t getSize() const;\n  OutputSection *getOutputSection() const;\n\n  // The following two functions are used for symbol resolution.\n  //\n  // You are expected to call mergeProperties for all symbols in input\n  // files so that attributes that are attached to names rather than\n  // indivisual symbol (such as visibility) are merged together.\n  //\n  // Every time you read a new symbol from an input, you are supposed\n  // to call resolve() with the new symbol. That function replaces\n  // \"this\" object as a result of name resolution if the new symbol is\n  // more appropriate to be included in the output.\n  //\n  // For example, if \"this\" is an undefined symbol and a new symbol is\n  // a defined symbol, \"this\" is replaced with the new symbol.\n  void mergeProperties(const Symbol &other);\n  void resolve(const Symbol &other);\n\n  // If this is a lazy symbol, fetch an input file and add the symbol\n  // in the file to the symbol table. Calling this function on\n  // non-lazy object causes a runtime error.\n  void fetch() const;\n\n  static bool isExportDynamic(Kind k, uint8_t visibility) {\n    if (k == SharedKind)\n      return visibility == llvm::ELF::STV_DEFAULT;\n    return config->shared || config->exportDynamic;\n  }\n\nprivate:\n  void resolveUndefined(const Undefined &other);\n  void resolveCommon(const CommonSymbol &other);\n  void resolveDefined(const Defined &other);\n  template <class LazyT> void resolveLazy(const LazyT &other);\n  void resolveShared(const SharedSymbol &other);\n\n  int compare(const Symbol *other) const;\n\n  inline size_t getSymbolSize() const;\n\nprotected:\n  Symbol(Kind k, InputFile *file, StringRefZ name, uint8_t binding,\n         uint8_t stOther, uint8_t type)\n      : file(file), nameData(name.data), nameSize(name.size), binding(binding),\n        type(type), stOther(stOther), symbolKind(k), visibility(stOther & 3),\n        isUsedInRegularObj(!file || file->kind() == InputFile::ObjKind),\n        exportDynamic(isExportDynamic(k, visibility)), inDynamicList(false),\n        canInline(false), referenced(false), traced(false), needsPltAddr(false),\n        isInIplt(false), gotInIgot(false), isPreemptible(false),\n        used(!config->gcSections), needsTocRestore(false),\n        scriptDefined(false) {}\n\npublic:\n  // True the symbol should point to its PLT entry.\n  // For SharedSymbol only.\n  uint8_t needsPltAddr : 1;\n\n  // True if this symbol is in the Iplt sub-section of the Plt and the Igot\n  // sub-section of the .got.plt or .got.\n  uint8_t isInIplt : 1;\n\n  // True if this symbol needs a GOT entry and its GOT entry is actually in\n  // Igot. This will be true only for certain non-preemptible ifuncs.\n  uint8_t gotInIgot : 1;\n\n  // True if this symbol is preemptible at load time.\n  uint8_t isPreemptible : 1;\n\n  // True if an undefined or shared symbol is used from a live section.\n  //\n  // NOTE: In Writer.cpp the field is used to mark local defined symbols\n  // which are referenced by relocations when -r or --emit-relocs is given.\n  uint8_t used : 1;\n\n  // True if a call to this symbol needs to be followed by a restore of the\n  // PPC64 toc pointer.\n  uint8_t needsTocRestore : 1;\n\n  // True if this symbol is defined by a linker script.\n  uint8_t scriptDefined : 1;\n\n  // The partition whose dynamic symbol table contains this symbol's definition.\n  uint8_t partition = 1;\n\n  bool isSection() const { return type == llvm::ELF::STT_SECTION; }\n  bool isTls() const { return type == llvm::ELF::STT_TLS; }\n  bool isFunc() const { return type == llvm::ELF::STT_FUNC; }\n  bool isGnuIFunc() const { return type == llvm::ELF::STT_GNU_IFUNC; }\n  bool isObject() const { return type == llvm::ELF::STT_OBJECT; }\n  bool isFile() const { return type == llvm::ELF::STT_FILE; }\n};\n\n// Represents a symbol that is defined in the current output file.\nclass Defined : public Symbol {\npublic:\n  Defined(InputFile *file, StringRefZ name, uint8_t binding, uint8_t stOther,\n          uint8_t type, uint64_t value, uint64_t size, SectionBase *section)\n      : Symbol(DefinedKind, file, name, binding, stOther, type), value(value),\n        size(size), section(section) {}\n\n  static bool classof(const Symbol *s) { return s->isDefined(); }\n\n  uint64_t value;\n  uint64_t size;\n  SectionBase *section;\n};\n\n// Represents a common symbol.\n//\n// On Unix, it is traditionally allowed to write variable definitions\n// without initialization expressions (such as \"int foo;\") to header\n// files. Such definition is called \"tentative definition\".\n//\n// Using tentative definition is usually considered a bad practice\n// because you should write only declarations (such as \"extern int\n// foo;\") to header files. Nevertheless, the linker and the compiler\n// have to do something to support bad code by allowing duplicate\n// definitions for this particular case.\n//\n// Common symbols represent variable definitions without initializations.\n// The compiler creates common symbols when it sees variable definitions\n// without initialization (you can suppress this behavior and let the\n// compiler create a regular defined symbol by -fno-common).\n//\n// The linker allows common symbols to be replaced by regular defined\n// symbols. If there are remaining common symbols after name resolution is\n// complete, they are converted to regular defined symbols in a .bss\n// section. (Therefore, the later passes don't see any CommonSymbols.)\nclass CommonSymbol : public Symbol {\npublic:\n  CommonSymbol(InputFile *file, StringRefZ name, uint8_t binding,\n               uint8_t stOther, uint8_t type, uint64_t alignment, uint64_t size)\n      : Symbol(CommonKind, file, name, binding, stOther, type),\n        alignment(alignment), size(size) {}\n\n  static bool classof(const Symbol *s) { return s->isCommon(); }\n\n  uint32_t alignment;\n  uint64_t size;\n};\n\nclass Undefined : public Symbol {\npublic:\n  Undefined(InputFile *file, StringRefZ name, uint8_t binding, uint8_t stOther,\n            uint8_t type, uint32_t discardedSecIdx = 0)\n      : Symbol(UndefinedKind, file, name, binding, stOther, type),\n        discardedSecIdx(discardedSecIdx) {}\n\n  static bool classof(const Symbol *s) { return s->kind() == UndefinedKind; }\n\n  // The section index if in a discarded section, 0 otherwise.\n  uint32_t discardedSecIdx;\n};\n\nclass SharedSymbol : public Symbol {\npublic:\n  static bool classof(const Symbol *s) { return s->kind() == SharedKind; }\n\n  SharedSymbol(InputFile &file, StringRef name, uint8_t binding,\n               uint8_t stOther, uint8_t type, uint64_t value, uint64_t size,\n               uint32_t alignment, uint32_t verdefIndex)\n      : Symbol(SharedKind, &file, name, binding, stOther, type), value(value),\n        size(size), alignment(alignment) {\n    this->verdefIndex = verdefIndex;\n    // GNU ifunc is a mechanism to allow user-supplied functions to\n    // resolve PLT slot values at load-time. This is contrary to the\n    // regular symbol resolution scheme in which symbols are resolved just\n    // by name. Using this hook, you can program how symbols are solved\n    // for you program. For example, you can make \"memcpy\" to be resolved\n    // to a SSE-enabled version of memcpy only when a machine running the\n    // program supports the SSE instruction set.\n    //\n    // Naturally, such symbols should always be called through their PLT\n    // slots. What GNU ifunc symbols point to are resolver functions, and\n    // calling them directly doesn't make sense (unless you are writing a\n    // loader).\n    //\n    // For DSO symbols, we always call them through PLT slots anyway.\n    // So there's no difference between GNU ifunc and regular function\n    // symbols if they are in DSOs. So we can handle GNU_IFUNC as FUNC.\n    if (this->type == llvm::ELF::STT_GNU_IFUNC)\n      this->type = llvm::ELF::STT_FUNC;\n  }\n\n  SharedFile &getFile() const { return *cast<SharedFile>(file); }\n\n  uint64_t value; // st_value\n  uint64_t size;  // st_size\n  uint32_t alignment;\n};\n\n// LazyArchive and LazyObject represent a symbols that is not yet in the link,\n// but we know where to find it if needed. If the resolver finds both Undefined\n// and Lazy for the same name, it will ask the Lazy to load a file.\n//\n// A special complication is the handling of weak undefined symbols. They should\n// not load a file, but we have to remember we have seen both the weak undefined\n// and the lazy. We represent that with a lazy symbol with a weak binding. This\n// means that code looking for undefined symbols normally also has to take lazy\n// symbols into consideration.\n\n// This class represents a symbol defined in an archive file. It is\n// created from an archive file header, and it knows how to load an\n// object file from an archive to replace itself with a defined\n// symbol.\nclass LazyArchive : public Symbol {\npublic:\n  LazyArchive(InputFile &file, const llvm::object::Archive::Symbol s)\n      : Symbol(LazyArchiveKind, &file, s.getName(), llvm::ELF::STB_GLOBAL,\n               llvm::ELF::STV_DEFAULT, llvm::ELF::STT_NOTYPE),\n        sym(s) {}\n\n  static bool classof(const Symbol *s) { return s->kind() == LazyArchiveKind; }\n\n  MemoryBufferRef getMemberBuffer();\n\n  const llvm::object::Archive::Symbol sym;\n};\n\n// LazyObject symbols represents symbols in object files between\n// --start-lib and --end-lib options.\nclass LazyObject : public Symbol {\npublic:\n  LazyObject(InputFile &file, StringRef name)\n      : Symbol(LazyObjectKind, &file, name, llvm::ELF::STB_GLOBAL,\n               llvm::ELF::STV_DEFAULT, llvm::ELF::STT_NOTYPE) {}\n\n  static bool classof(const Symbol *s) { return s->kind() == LazyObjectKind; }\n};\n\n// Some linker-generated symbols need to be created as\n// Defined symbols.\nstruct ElfSym {\n  // __bss_start\n  static Defined *bss;\n\n  // etext and _etext\n  static Defined *etext1;\n  static Defined *etext2;\n\n  // edata and _edata\n  static Defined *edata1;\n  static Defined *edata2;\n\n  // end and _end\n  static Defined *end1;\n  static Defined *end2;\n\n  // The _GLOBAL_OFFSET_TABLE_ symbol is defined by target convention to\n  // be at some offset from the base of the .got section, usually 0 or\n  // the end of the .got.\n  static Defined *globalOffsetTable;\n\n  // _gp, _gp_disp and __gnu_local_gp symbols. Only for MIPS.\n  static Defined *mipsGp;\n  static Defined *mipsGpDisp;\n  static Defined *mipsLocalGp;\n\n  // __rel{,a}_iplt_{start,end} symbols.\n  static Defined *relaIpltStart;\n  static Defined *relaIpltEnd;\n\n  // __global_pointer$ for RISC-V.\n  static Defined *riscvGlobalPointer;\n\n  // _TLS_MODULE_BASE_ on targets that support TLSDESC.\n  static Defined *tlsModuleBase;\n};\n\n// A buffer class that is large enough to hold any Symbol-derived\n// object. We allocate memory using this class and instantiate a symbol\n// using the placement new.\nunion SymbolUnion {\n  alignas(Defined) char a[sizeof(Defined)];\n  alignas(CommonSymbol) char b[sizeof(CommonSymbol)];\n  alignas(Undefined) char c[sizeof(Undefined)];\n  alignas(SharedSymbol) char d[sizeof(SharedSymbol)];\n  alignas(LazyArchive) char e[sizeof(LazyArchive)];\n  alignas(LazyObject) char f[sizeof(LazyObject)];\n};\n\n// It is important to keep the size of SymbolUnion small for performance and\n// memory usage reasons. 80 bytes is a soft limit based on the size of Defined\n// on a 64-bit system.\nstatic_assert(sizeof(SymbolUnion) <= 80, \"SymbolUnion too large\");\n\ntemplate <typename T> struct AssertSymbol {\n  static_assert(std::is_trivially_destructible<T>(),\n                \"Symbol types must be trivially destructible\");\n  static_assert(sizeof(T) <= sizeof(SymbolUnion), \"SymbolUnion too small\");\n  static_assert(alignof(T) <= alignof(SymbolUnion),\n                \"SymbolUnion not aligned enough\");\n};\n\nstatic inline void assertSymbols() {\n  AssertSymbol<Defined>();\n  AssertSymbol<CommonSymbol>();\n  AssertSymbol<Undefined>();\n  AssertSymbol<SharedSymbol>();\n  AssertSymbol<LazyArchive>();\n  AssertSymbol<LazyObject>();\n}\n\nvoid printTraceSymbol(const Symbol *sym);\n\nsize_t Symbol::getSymbolSize() const {\n  switch (kind()) {\n  case CommonKind:\n    return sizeof(CommonSymbol);\n  case DefinedKind:\n    return sizeof(Defined);\n  case LazyArchiveKind:\n    return sizeof(LazyArchive);\n  case LazyObjectKind:\n    return sizeof(LazyObject);\n  case SharedKind:\n    return sizeof(SharedSymbol);\n  case UndefinedKind:\n    return sizeof(Undefined);\n  case PlaceholderKind:\n    return sizeof(Symbol);\n  }\n  llvm_unreachable(\"unknown symbol kind\");\n}\n\n// replace() replaces \"this\" object with a given symbol by memcpy'ing\n// it over to \"this\". This function is called as a result of name\n// resolution, e.g. to replace an undefind symbol with a defined symbol.\nvoid Symbol::replace(const Symbol &newSym) {\n  using llvm::ELF::STT_TLS;\n\n  // st_value of STT_TLS represents the assigned offset, not the actual address\n  // which is used by STT_FUNC and STT_OBJECT. STT_TLS symbols can only be\n  // referenced by special TLS relocations. It is usually an error if a STT_TLS\n  // symbol is replaced by a non-STT_TLS symbol, vice versa. There are two\n  // exceptions: (a) a STT_NOTYPE lazy/undefined symbol can be replaced by a\n  // STT_TLS symbol, (b) a STT_TLS undefined symbol can be replaced by a\n  // STT_NOTYPE lazy symbol.\n  if (symbolKind != PlaceholderKind && !newSym.isLazy() &&\n      (type == STT_TLS) != (newSym.type == STT_TLS) &&\n      type != llvm::ELF::STT_NOTYPE)\n    error(\"TLS attribute mismatch: \" + toString(*this) + \"\\n>>> defined in \" +\n          toString(newSym.file) + \"\\n>>> defined in \" + toString(file));\n\n  Symbol old = *this;\n  memcpy(this, &newSym, newSym.getSymbolSize());\n\n  // old may be a placeholder. The referenced fields must be initialized in\n  // SymbolTable::insert.\n  versionId = old.versionId;\n  visibility = old.visibility;\n  isUsedInRegularObj = old.isUsedInRegularObj;\n  exportDynamic = old.exportDynamic;\n  inDynamicList = old.inDynamicList;\n  canInline = old.canInline;\n  referenced = old.referenced;\n  traced = old.traced;\n  isPreemptible = old.isPreemptible;\n  scriptDefined = old.scriptDefined;\n  partition = old.partition;\n\n  // Symbol length is computed lazily. If we already know a symbol length,\n  // propagate it.\n  if (nameData == old.nameData && nameSize == 0 && old.nameSize != 0)\n    nameSize = old.nameSize;\n\n  // Print out a log message if --trace-symbol was specified.\n  // This is for debugging.\n  if (traced)\n    printTraceSymbol(this);\n}\n\nvoid maybeWarnUnorderableSymbol(const Symbol *sym);\nbool computeIsPreemptible(const Symbol &sym);\nvoid reportBackrefs();\n\n// A mapping from a symbol to an InputFile referencing it backward. Used by\n// --warn-backrefs.\nextern llvm::DenseMap<const Symbol *,\n                      std::pair<const InputFile *, const InputFile *>>\n    backwardReferences;\n\n} // namespace elf\n} // namespace lld\n\n#endif\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "content": "//===- SyntheticSection.h ---------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Synthetic sections represent chunks of linker-created data. If you\n// need to create a chunk of data that to be included in some section\n// in the result, you probably want to create that as a synthetic section.\n//\n// Synthetic sections are designed as input sections as opposed to\n// output sections because we want to allow them to be manipulated\n// using linker scripts just like other input sections from regular\n// files.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLD_ELF_SYNTHETIC_SECTIONS_H\n#define LLD_ELF_SYNTHETIC_SECTIONS_H\n\n#include \"DWARF.h\"\n#include \"EhFrame.h\"\n#include \"InputSection.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/MC/StringTableBuilder.h\"\n#include \"llvm/Support/Endian.h\"\n#include <functional>\n\nnamespace lld {\nnamespace elf {\nclass Defined;\nstruct PhdrEntry;\nclass SymbolTableBaseSection;\nclass VersionNeedBaseSection;\n\nclass SyntheticSection : public InputSection {\npublic:\n  SyntheticSection(uint64_t flags, uint32_t type, uint32_t alignment,\n                   StringRef name)\n      : InputSection(nullptr, flags, type, alignment, {}, name,\n                     InputSectionBase::Synthetic) {\n    markLive();\n  }\n\n  virtual ~SyntheticSection() = default;\n  virtual void writeTo(uint8_t *buf) = 0;\n  virtual size_t getSize() const = 0;\n  virtual void finalizeContents() {}\n  // If the section has the SHF_ALLOC flag and the size may be changed if\n  // thunks are added, update the section size.\n  virtual bool updateAllocSize() { return false; }\n  virtual bool isNeeded() const { return true; }\n\n  static bool classof(const SectionBase *d) {\n    return d->kind() == InputSectionBase::Synthetic;\n  }\n};\n\nstruct CieRecord {\n  EhSectionPiece *cie = nullptr;\n  std::vector<EhSectionPiece *> fdes;\n};\n\n// Section for .eh_frame.\nclass EhFrameSection final : public SyntheticSection {\npublic:\n  EhFrameSection();\n  void writeTo(uint8_t *buf) override;\n  void finalizeContents() override;\n  bool isNeeded() const override { return !sections.empty(); }\n  size_t getSize() const override { return size; }\n\n  static bool classof(const SectionBase *d) {\n    return SyntheticSection::classof(d) && d->name == \".eh_frame\";\n  }\n\n  void addSection(EhInputSection *sec);\n\n  std::vector<EhInputSection *> sections;\n  size_t numFdes = 0;\n\n  struct FdeData {\n    uint32_t pcRel;\n    uint32_t fdeVARel;\n  };\n\n  std::vector<FdeData> getFdeData() const;\n  ArrayRef<CieRecord *> getCieRecords() const { return cieRecords; }\n  template <class ELFT>\n  void iterateFDEWithLSDA(llvm::function_ref<void(InputSection &)> fn);\n\nprivate:\n  // This is used only when parsing EhInputSection. We keep it here to avoid\n  // allocating one for each EhInputSection.\n  llvm::DenseMap<size_t, CieRecord *> offsetToCie;\n\n  uint64_t size = 0;\n\n  template <class ELFT, class RelTy>\n  void addRecords(EhInputSection *s, llvm::ArrayRef<RelTy> rels);\n  template <class ELFT> void addSectionAux(EhInputSection *s);\n  template <class ELFT, class RelTy>\n  void iterateFDEWithLSDAAux(EhInputSection &sec, ArrayRef<RelTy> rels,\n                             llvm::DenseSet<size_t> &ciesWithLSDA,\n                             llvm::function_ref<void(InputSection &)> fn);\n\n  template <class ELFT, class RelTy>\n  CieRecord *addCie(EhSectionPiece &piece, ArrayRef<RelTy> rels);\n\n  template <class ELFT, class RelTy>\n  Defined *isFdeLive(EhSectionPiece &piece, ArrayRef<RelTy> rels);\n\n  uint64_t getFdePc(uint8_t *buf, size_t off, uint8_t enc) const;\n\n  std::vector<CieRecord *> cieRecords;\n\n  // CIE records are uniquified by their contents and personality functions.\n  llvm::DenseMap<std::pair<ArrayRef<uint8_t>, Symbol *>, CieRecord *> cieMap;\n};\n\nclass GotSection : public SyntheticSection {\npublic:\n  GotSection();\n  size_t getSize() const override { return size; }\n  void finalizeContents() override;\n  bool isNeeded() const override;\n  void writeTo(uint8_t *buf) override;\n\n  void addEntry(Symbol &sym);\n  bool addDynTlsEntry(Symbol &sym);\n  bool addTlsIndex();\n  uint64_t getGlobalDynAddr(const Symbol &b) const;\n  uint64_t getGlobalDynOffset(const Symbol &b) const;\n\n  uint64_t getTlsIndexVA() { return this->getVA() + tlsIndexOff; }\n  uint32_t getTlsIndexOff() const { return tlsIndexOff; }\n\n  // Flag to force GOT to be in output if we have relocations\n  // that relies on its address.\n  bool hasGotOffRel = false;\n\nprotected:\n  size_t numEntries = 0;\n  uint32_t tlsIndexOff = -1;\n  uint64_t size = 0;\n};\n\n// .note.GNU-stack section.\nclass GnuStackSection : public SyntheticSection {\npublic:\n  GnuStackSection()\n      : SyntheticSection(0, llvm::ELF::SHT_PROGBITS, 1, \".note.GNU-stack\") {}\n  void writeTo(uint8_t *buf) override {}\n  size_t getSize() const override { return 0; }\n};\n\nclass GnuPropertySection : public SyntheticSection {\npublic:\n  GnuPropertySection();\n  void writeTo(uint8_t *buf) override;\n  size_t getSize() const override;\n};\n\n// .note.gnu.build-id section.\nclass BuildIdSection : public SyntheticSection {\n  // First 16 bytes are a header.\n  static const unsigned headerSize = 16;\n\npublic:\n  const size_t hashSize;\n  BuildIdSection();\n  void writeTo(uint8_t *buf) override;\n  size_t getSize() const override { return headerSize + hashSize; }\n  void writeBuildId(llvm::ArrayRef<uint8_t> buf);\n\nprivate:\n  uint8_t *hashBuf;\n};\n\n// BssSection is used to reserve space for copy relocations and common symbols.\n// We create three instances of this class for .bss, .bss.rel.ro and \"COMMON\",\n// that are used for writable symbols, read-only symbols and common symbols,\n// respectively.\nclass BssSection final : public SyntheticSection {\npublic:\n  BssSection(StringRef name, uint64_t size, uint32_t alignment);\n  void writeTo(uint8_t *) override {\n    llvm_unreachable(\"unexpected writeTo() call for SHT_NOBITS section\");\n  }\n  bool isNeeded() const override { return size != 0; }\n  size_t getSize() const override { return size; }\n\n  static bool classof(const SectionBase *s) { return s->bss; }\n  uint64_t size;\n};\n\nclass MipsGotSection final : public SyntheticSection {\npublic:\n  MipsGotSection();\n  void writeTo(uint8_t *buf) override;\n  size_t getSize() const override { return size; }\n  bool updateAllocSize() override;\n  void finalizeContents() override;\n  bool isNeeded() const override;\n\n  // Join separate GOTs built for each input file to generate\n  // primary and optional multiple secondary GOTs.\n  void build();\n\n  void addEntry(InputFile &file, Symbol &sym, int64_t addend, RelExpr expr);\n  void addDynTlsEntry(InputFile &file, Symbol &sym);\n  void addTlsIndex(InputFile &file);\n\n  uint64_t getPageEntryOffset(const InputFile *f, const Symbol &s,\n                              int64_t addend) const;\n  uint64_t getSymEntryOffset(const InputFile *f, const Symbol &s,\n                             int64_t addend) const;\n  uint64_t getGlobalDynOffset(const InputFile *f, const Symbol &s) const;\n  uint64_t getTlsIndexOffset(const InputFile *f) const;\n\n  // Returns the symbol which corresponds to the first entry of the global part\n  // of GOT on MIPS platform. It is required to fill up MIPS-specific dynamic\n  // table properties.\n  // Returns nullptr if the global part is empty.\n  const Symbol *getFirstGlobalEntry() const;\n\n  // Returns the number of entries in the local part of GOT including\n  // the number of reserved entries.\n  unsigned getLocalEntriesNum() const;\n\n  // Return _gp value for primary GOT (nullptr) or particular input file.\n  uint64_t getGp(const InputFile *f = nullptr) const;\n\nprivate:\n  // MIPS GOT consists of three parts: local, global and tls. Each part\n  // contains different types of entries. Here is a layout of GOT:\n  // - Header entries                |\n  // - Page entries                  |   Local part\n  // - Local entries (16-bit access) |\n  // - Local entries (32-bit access) |\n  // - Normal global entries         ||  Global part\n  // - Reloc-only global entries     ||\n  // - TLS entries                   ||| TLS part\n  //\n  // Header:\n  //   Two entries hold predefined value 0x0 and 0x80000000.\n  // Page entries:\n  //   These entries created by R_MIPS_GOT_PAGE relocation and R_MIPS_GOT16\n  //   relocation against local symbols. They are initialized by higher 16-bit\n  //   of the corresponding symbol's value. So each 64kb of address space\n  //   requires a single GOT entry.\n  // Local entries (16-bit access):\n  //   These entries created by GOT relocations against global non-preemptible\n  //   symbols so dynamic linker is not necessary to resolve the symbol's\n  //   values. \"16-bit access\" means that corresponding relocations address\n  //   GOT using 16-bit index. Each unique Symbol-Addend pair has its own\n  //   GOT entry.\n  // Local entries (32-bit access):\n  //   These entries are the same as above but created by relocations which\n  //   address GOT using 32-bit index (R_MIPS_GOT_HI16/LO16 etc).\n  // Normal global entries:\n  //   These entries created by GOT relocations against preemptible global\n  //   symbols. They need to be initialized by dynamic linker and they ordered\n  //   exactly as the corresponding entries in the dynamic symbols table.\n  // Reloc-only global entries:\n  //   These entries created for symbols that are referenced by dynamic\n  //   relocations R_MIPS_REL32. These entries are not accessed with gp-relative\n  //   addressing, but MIPS ABI requires that these entries be present in GOT.\n  // TLS entries:\n  //   Entries created by TLS relocations.\n  //\n  // If the sum of local, global and tls entries is less than 64K only single\n  // got is enough. Otherwise, multi-got is created. Series of primary and\n  // multiple secondary GOTs have the following layout:\n  // - Primary GOT\n  //     Header\n  //     Local entries\n  //     Global entries\n  //     Relocation only entries\n  //     TLS entries\n  //\n  // - Secondary GOT\n  //     Local entries\n  //     Global entries\n  //     TLS entries\n  // ...\n  //\n  // All GOT entries required by relocations from a single input file entirely\n  // belong to either primary or one of secondary GOTs. To reference GOT entries\n  // each GOT has its own _gp value points to the \"middle\" of the GOT.\n  // In the code this value loaded to the register which is used for GOT access.\n  //\n  // MIPS 32 function's prologue:\n  //   lui     v0,0x0\n  //   0: R_MIPS_HI16  _gp_disp\n  //   addiu   v0,v0,0\n  //   4: R_MIPS_LO16  _gp_disp\n  //\n  // MIPS 64:\n  //   lui     at,0x0\n  //   14: R_MIPS_GPREL16  main\n  //\n  // Dynamic linker does not know anything about secondary GOTs and cannot\n  // use a regular MIPS mechanism for GOT entries initialization. So we have\n  // to use an approach accepted by other architectures and create dynamic\n  // relocations R_MIPS_REL32 to initialize global entries (and local in case\n  // of PIC code) in secondary GOTs. But ironically MIPS dynamic linker\n  // requires GOT entries and correspondingly ordered dynamic symbol table\n  // entries to deal with dynamic relocations. To handle this problem\n  // relocation-only section in the primary GOT contains entries for all\n  // symbols referenced in global parts of secondary GOTs. Although the sum\n  // of local and normal global entries of the primary got should be less\n  // than 64K, the size of the primary got (including relocation-only entries\n  // can be greater than 64K, because parts of the primary got that overflow\n  // the 64K limit are used only by the dynamic linker at dynamic link-time\n  // and not by 16-bit gp-relative addressing at run-time.\n  //\n  // For complete multi-GOT description see the following link\n  // https://dmz-portal.mips.com/wiki/MIPS_Multi_GOT\n\n  // Number of \"Header\" entries.\n  static const unsigned headerEntriesNum = 2;\n\n  uint64_t size = 0;\n\n  // Symbol and addend.\n  using GotEntry = std::pair<Symbol *, int64_t>;\n\n  struct FileGot {\n    InputFile *file = nullptr;\n    size_t startIndex = 0;\n\n    struct PageBlock {\n      size_t firstIndex;\n      size_t count;\n      PageBlock() : firstIndex(0), count(0) {}\n    };\n\n    // Map output sections referenced by MIPS GOT relocations\n    // to the description (index/count) \"page\" entries allocated\n    // for this section.\n    llvm::SmallMapVector<const OutputSection *, PageBlock, 16> pagesMap;\n    // Maps from Symbol+Addend pair or just Symbol to the GOT entry index.\n    llvm::MapVector<GotEntry, size_t> local16;\n    llvm::MapVector<GotEntry, size_t> local32;\n    llvm::MapVector<Symbol *, size_t> global;\n    llvm::MapVector<Symbol *, size_t> relocs;\n    llvm::MapVector<Symbol *, size_t> tls;\n    // Set of symbols referenced by dynamic TLS relocations.\n    llvm::MapVector<Symbol *, size_t> dynTlsSymbols;\n\n    // Total number of all entries.\n    size_t getEntriesNum() const;\n    // Number of \"page\" entries.\n    size_t getPageEntriesNum() const;\n    // Number of entries require 16-bit index to access.\n    size_t getIndexedEntriesNum() const;\n  };\n\n  // Container of GOT created for each input file.\n  // After building a final series of GOTs this container\n  // holds primary and secondary GOT's.\n  std::vector<FileGot> gots;\n\n  // Return (and create if necessary) `FileGot`.\n  FileGot &getGot(InputFile &f);\n\n  // Try to merge two GOTs. In case of success the `Dst` contains\n  // result of merging and the function returns true. In case of\n  // overflow the `Dst` is unchanged and the function returns false.\n  bool tryMergeGots(FileGot & dst, FileGot & src, bool isPrimary);\n};\n\nclass GotPltSection final : public SyntheticSection {\npublic:\n  GotPltSection();\n  void addEntry(Symbol &sym);\n  size_t getSize() const override;\n  void writeTo(uint8_t *buf) override;\n  bool isNeeded() const override;\n\n  // Flag to force GotPlt to be in output if we have relocations\n  // that relies on its address.\n  bool hasGotPltOffRel = false;\n\nprivate:\n  std::vector<const Symbol *> entries;\n};\n\n// The IgotPltSection is a Got associated with the PltSection for GNU Ifunc\n// Symbols that will be relocated by Target->IRelativeRel.\n// On most Targets the IgotPltSection will immediately follow the GotPltSection\n// on ARM the IgotPltSection will immediately follow the GotSection.\nclass IgotPltSection final : public SyntheticSection {\npublic:\n  IgotPltSection();\n  void addEntry(Symbol &sym);\n  size_t getSize() const override;\n  void writeTo(uint8_t *buf) override;\n  bool isNeeded() const override { return !entries.empty(); }\n\nprivate:\n  std::vector<const Symbol *> entries;\n};\n\nclass StringTableSection final : public SyntheticSection {\npublic:\n  StringTableSection(StringRef name, bool dynamic);\n  unsigned addString(StringRef s, bool hashIt = true);\n  void writeTo(uint8_t *buf) override;\n  size_t getSize() const override { return size; }\n  bool isDynamic() const { return dynamic; }\n\nprivate:\n  const bool dynamic;\n\n  uint64_t size = 0;\n\n  llvm::DenseMap<StringRef, unsigned> stringMap;\n  std::vector<StringRef> strings;\n};\n\nclass DynamicReloc {\npublic:\n  DynamicReloc(RelType type, const InputSectionBase *inputSec,\n               uint64_t offsetInSec, bool useSymVA, Symbol *sym, int64_t addend)\n      : type(type), sym(sym), inputSec(inputSec), offsetInSec(offsetInSec),\n        useSymVA(useSymVA), addend(addend), outputSec(nullptr) {}\n  // This constructor records dynamic relocation settings used by MIPS\n  // multi-GOT implementation. It's to relocate addresses of 64kb pages\n  // lie inside the output section.\n  DynamicReloc(RelType type, const InputSectionBase *inputSec,\n               uint64_t offsetInSec, const OutputSection *outputSec,\n               int64_t addend)\n      : type(type), sym(nullptr), inputSec(inputSec), offsetInSec(offsetInSec),\n        useSymVA(false), addend(addend), outputSec(outputSec) {}\n\n  uint64_t getOffset() const;\n  uint32_t getSymIndex(SymbolTableBaseSection *symTab) const;\n\n  // Computes the addend of the dynamic relocation. Note that this is not the\n  // same as the addend member variable as it also includes the symbol address\n  // if useSymVA is true.\n  int64_t computeAddend() const;\n\n  RelType type;\n\n  Symbol *sym;\n  const InputSectionBase *inputSec = nullptr;\n  uint64_t offsetInSec;\n  // If this member is true, the dynamic relocation will not be against the\n  // symbol but will instead be a relative relocation that simply adds the\n  // load address. This means we need to write the symbol virtual address\n  // plus the original addend as the final relocation addend.\n  bool useSymVA;\n  int64_t addend;\n  const OutputSection *outputSec;\n};\n\ntemplate <class ELFT> class DynamicSection final : public SyntheticSection {\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n\n  // finalizeContents() fills this vector with the section contents.\n  std::vector<std::pair<int32_t, std::function<uint64_t()>>> entries;\n\npublic:\n  DynamicSection();\n  void finalizeContents() override;\n  void writeTo(uint8_t *buf) override;\n  size_t getSize() const override { return size; }\n\nprivate:\n  void add(int32_t tag, std::function<uint64_t()> fn);\n  void addInt(int32_t tag, uint64_t val);\n  void addInSec(int32_t tag, InputSection *sec);\n  void addInSecRelative(int32_t tag, InputSection *sec);\n  void addOutSec(int32_t tag, OutputSection *sec);\n  void addSize(int32_t tag, OutputSection *sec);\n  void addSym(int32_t tag, Symbol *sym);\n\n  uint64_t size = 0;\n};\n\nclass RelocationBaseSection : public SyntheticSection {\npublic:\n  RelocationBaseSection(StringRef name, uint32_t type, int32_t dynamicTag,\n                        int32_t sizeDynamicTag);\n  void addReloc(RelType dynType, InputSectionBase *isec, uint64_t offsetInSec,\n                Symbol *sym);\n  // Add a dynamic relocation that might need an addend. This takes care of\n  // writing the addend to the output section if needed.\n  void addReloc(RelType dynType, InputSectionBase *inputSec,\n                uint64_t offsetInSec, Symbol *sym, int64_t addend, RelExpr expr,\n                RelType type);\n  void addReloc(const DynamicReloc &reloc);\n  bool isNeeded() const override { return !relocs.empty(); }\n  size_t getSize() const override { return relocs.size() * this->entsize; }\n  size_t getRelativeRelocCount() const { return numRelativeRelocs; }\n  void finalizeContents() override;\n  int32_t dynamicTag, sizeDynamicTag;\n  std::vector<DynamicReloc> relocs;\n\nprotected:\n  size_t numRelativeRelocs = 0;\n};\n\ntemplate <class ELFT>\nclass RelocationSection final : public RelocationBaseSection {\n  using Elf_Rel = typename ELFT::Rel;\n  using Elf_Rela = typename ELFT::Rela;\n\npublic:\n  RelocationSection(StringRef name, bool sort);\n  void writeTo(uint8_t *buf) override;\n\nprivate:\n  bool sort;\n};\n\ntemplate <class ELFT>\nclass AndroidPackedRelocationSection final : public RelocationBaseSection {\n  using Elf_Rel = typename ELFT::Rel;\n  using Elf_Rela = typename ELFT::Rela;\n\npublic:\n  AndroidPackedRelocationSection(StringRef name);\n\n  bool updateAllocSize() override;\n  size_t getSize() const override { return relocData.size(); }\n  void writeTo(uint8_t *buf) override {\n    memcpy(buf, relocData.data(), relocData.size());\n  }\n\nprivate:\n  SmallVector<char, 0> relocData;\n};\n\nstruct RelativeReloc {\n  uint64_t getOffset() const { return inputSec->getVA(offsetInSec); }\n\n  const InputSectionBase *inputSec;\n  uint64_t offsetInSec;\n};\n\nclass RelrBaseSection : public SyntheticSection {\npublic:\n  RelrBaseSection();\n  bool isNeeded() const override { return !relocs.empty(); }\n  std::vector<RelativeReloc> relocs;\n};\n\n// RelrSection is used to encode offsets for relative relocations.\n// Proposal for adding SHT_RELR sections to generic-abi is here:\n//   https://groups.google.com/forum/#!topic/generic-abi/bX460iggiKg\n// For more details, see the comment in RelrSection::updateAllocSize().\ntemplate <class ELFT> class RelrSection final : public RelrBaseSection {\n  using Elf_Relr = typename ELFT::Relr;\n\npublic:\n  RelrSection();\n\n  bool updateAllocSize() override;\n  size_t getSize() const override { return relrRelocs.size() * this->entsize; }\n  void writeTo(uint8_t *buf) override {\n    memcpy(buf, relrRelocs.data(), getSize());\n  }\n\nprivate:\n  std::vector<Elf_Relr> relrRelocs;\n};\n\nstruct SymbolTableEntry {\n  Symbol *sym;\n  size_t strTabOffset;\n};\n\nclass SymbolTableBaseSection : public SyntheticSection {\npublic:\n  SymbolTableBaseSection(StringTableSection &strTabSec);\n  void finalizeContents() override;\n  size_t getSize() const override { return getNumSymbols() * entsize; }\n  void addSymbol(Symbol *sym);\n  unsigned getNumSymbols() const { return symbols.size() + 1; }\n  size_t getSymbolIndex(Symbol *sym);\n  ArrayRef<SymbolTableEntry> getSymbols() const { return symbols; }\n\nprotected:\n  void sortSymTabSymbols();\n\n  // A vector of symbols and their string table offsets.\n  std::vector<SymbolTableEntry> symbols;\n\n  StringTableSection &strTabSec;\n\n  llvm::once_flag onceFlag;\n  llvm::DenseMap<Symbol *, size_t> symbolIndexMap;\n  llvm::DenseMap<OutputSection *, size_t> sectionIndexMap;\n};\n\ntemplate <class ELFT>\nclass SymbolTableSection final : public SymbolTableBaseSection {\n  using Elf_Sym = typename ELFT::Sym;\n\npublic:\n  SymbolTableSection(StringTableSection &strTabSec);\n  void writeTo(uint8_t *buf) override;\n};\n\nclass SymtabShndxSection final : public SyntheticSection {\npublic:\n  SymtabShndxSection();\n\n  void writeTo(uint8_t *buf) override;\n  size_t getSize() const override;\n  bool isNeeded() const override;\n  void finalizeContents() override;\n};\n\n// Outputs GNU Hash section. For detailed explanation see:\n// https://blogs.oracle.com/ali/entry/gnu_hash_elf_sections\nclass GnuHashTableSection final : public SyntheticSection {\npublic:\n  GnuHashTableSection();\n  void finalizeContents() override;\n  void writeTo(uint8_t *buf) override;\n  size_t getSize() const override { return size; }\n\n  // Adds symbols to the hash table.\n  // Sorts the input to satisfy GNU hash section requirements.\n  void addSymbols(std::vector<SymbolTableEntry> &symbols);\n\nprivate:\n  // See the comment in writeBloomFilter.\n  enum { Shift2 = 26 };\n\n  void writeBloomFilter(uint8_t *buf);\n  void writeHashTable(uint8_t *buf);\n\n  struct Entry {\n    Symbol *sym;\n    size_t strTabOffset;\n    uint32_t hash;\n    uint32_t bucketIdx;\n  };\n\n  std::vector<Entry> symbols;\n  size_t maskWords;\n  size_t nBuckets = 0;\n  size_t size = 0;\n};\n\nclass HashTableSection final : public SyntheticSection {\npublic:\n  HashTableSection();\n  void finalizeContents() override;\n  void writeTo(uint8_t *buf) override;\n  size_t getSize() const override { return size; }\n\nprivate:\n  size_t size = 0;\n};\n\n// Used for PLT entries. It usually has a PLT header for lazy binding. Each PLT\n// entry is associated with a JUMP_SLOT relocation, which may be resolved lazily\n// at runtime.\n//\n// On PowerPC, this section contains lazy symbol resolvers. A branch instruction\n// jumps to a PLT call stub, which will then jump to the target (BIND_NOW) or a\n// lazy symbol resolver.\n//\n// On x86 when IBT is enabled, this section (.plt.sec) contains PLT call stubs.\n// A call instruction jumps to a .plt.sec entry, which will then jump to the\n// target (BIND_NOW) or a .plt entry.\nclass PltSection : public SyntheticSection {\npublic:\n  PltSection();\n  void writeTo(uint8_t *buf) override;\n  size_t getSize() const override;\n  bool isNeeded() const override;\n  void addSymbols();\n  void addEntry(Symbol &sym);\n  size_t getNumEntries() const { return entries.size(); }\n\n  size_t headerSize;\n\n  std::vector<const Symbol *> entries;\n};\n\n// Used for non-preemptible ifuncs. It does not have a header. Each entry is\n// associated with an IRELATIVE relocation, which will be resolved eagerly at\n// runtime. PltSection can only contain entries associated with JUMP_SLOT\n// relocations, so IPLT entries are in a separate section.\nclass IpltSection final : public SyntheticSection {\n  std::vector<const Symbol *> entries;\n\npublic:\n  IpltSection();\n  void writeTo(uint8_t *buf) override;\n  size_t getSize() const override;\n  bool isNeeded() const override { return !entries.empty(); }\n  void addSymbols();\n  void addEntry(Symbol &sym);\n};\n\nclass PPC32GlinkSection : public PltSection {\npublic:\n  PPC32GlinkSection();\n  void writeTo(uint8_t *buf) override;\n  size_t getSize() const override;\n\n  std::vector<const Symbol *> canonical_plts;\n  static constexpr size_t footerSize = 64;\n};\n\n// This is x86-only.\nclass IBTPltSection : public SyntheticSection {\npublic:\n  IBTPltSection();\n  void writeTo(uint8_t *Buf) override;\n  size_t getSize() const override;\n};\n\nclass GdbIndexSection final : public SyntheticSection {\npublic:\n  struct AddressEntry {\n    InputSection *section;\n    uint64_t lowAddress;\n    uint64_t highAddress;\n    uint32_t cuIndex;\n  };\n\n  struct CuEntry {\n    uint64_t cuOffset;\n    uint64_t cuLength;\n  };\n\n  struct NameAttrEntry {\n    llvm::CachedHashStringRef name;\n    uint32_t cuIndexAndAttrs;\n  };\n\n  struct GdbChunk {\n    InputSection *sec;\n    std::vector<AddressEntry> addressAreas;\n    std::vector<CuEntry> compilationUnits;\n  };\n\n  struct GdbSymbol {\n    llvm::CachedHashStringRef name;\n    std::vector<uint32_t> cuVector;\n    uint32_t nameOff;\n    uint32_t cuVectorOff;\n  };\n\n  GdbIndexSection();\n  template <typename ELFT> static GdbIndexSection *create();\n  void writeTo(uint8_t *buf) override;\n  size_t getSize() const override { return size; }\n  bool isNeeded() const override;\n\nprivate:\n  struct GdbIndexHeader {\n    llvm::support::ulittle32_t version;\n    llvm::support::ulittle32_t cuListOff;\n    llvm::support::ulittle32_t cuTypesOff;\n    llvm::support::ulittle32_t addressAreaOff;\n    llvm::support::ulittle32_t symtabOff;\n    llvm::support::ulittle32_t constantPoolOff;\n  };\n\n  void initOutputSize();\n  size_t computeSymtabSize() const;\n\n  // Each chunk contains information gathered from debug sections of a\n  // single object file.\n  std::vector<GdbChunk> chunks;\n\n  // A symbol table for this .gdb_index section.\n  std::vector<GdbSymbol> symbols;\n\n  size_t size;\n};\n\n// --eh-frame-hdr option tells linker to construct a header for all the\n// .eh_frame sections. This header is placed to a section named .eh_frame_hdr\n// and also to a PT_GNU_EH_FRAME segment.\n// At runtime the unwinder then can find all the PT_GNU_EH_FRAME segments by\n// calling dl_iterate_phdr.\n// This section contains a lookup table for quick binary search of FDEs.\n// Detailed info about internals can be found in Ian Lance Taylor's blog:\n// http://www.airs.com/blog/archives/460 (\".eh_frame\")\n// http://www.airs.com/blog/archives/462 (\".eh_frame_hdr\")\nclass EhFrameHeader final : public SyntheticSection {\npublic:\n  EhFrameHeader();\n  void write();\n  void writeTo(uint8_t *buf) override;\n  size_t getSize() const override;\n  bool isNeeded() const override;\n};\n\n// For more information about .gnu.version and .gnu.version_r see:\n// https://www.akkadia.org/drepper/symbol-versioning\n\n// The .gnu.version_d section which has a section type of SHT_GNU_verdef shall\n// contain symbol version definitions. The number of entries in this section\n// shall be contained in the DT_VERDEFNUM entry of the .dynamic section.\n// The section shall contain an array of Elf_Verdef structures, optionally\n// followed by an array of Elf_Verdaux structures.\nclass VersionDefinitionSection final : public SyntheticSection {\npublic:\n  VersionDefinitionSection();\n  void finalizeContents() override;\n  size_t getSize() const override;\n  void writeTo(uint8_t *buf) override;\n\nprivate:\n  enum { EntrySize = 28 };\n  void writeOne(uint8_t *buf, uint32_t index, StringRef name, size_t nameOff);\n  StringRef getFileDefName();\n\n  unsigned fileDefNameOff;\n  std::vector<unsigned> verDefNameOffs;\n};\n\n// The .gnu.version section specifies the required version of each symbol in the\n// dynamic symbol table. It contains one Elf_Versym for each dynamic symbol\n// table entry. An Elf_Versym is just a 16-bit integer that refers to a version\n// identifier defined in the either .gnu.version_r or .gnu.version_d section.\n// The values 0 and 1 are reserved. All other values are used for versions in\n// the own object or in any of the dependencies.\nclass VersionTableSection final : public SyntheticSection {\npublic:\n  VersionTableSection();\n  void finalizeContents() override;\n  size_t getSize() const override;\n  void writeTo(uint8_t *buf) override;\n  bool isNeeded() const override;\n};\n\n// The .gnu.version_r section defines the version identifiers used by\n// .gnu.version. It contains a linked list of Elf_Verneed data structures. Each\n// Elf_Verneed specifies the version requirements for a single DSO, and contains\n// a reference to a linked list of Elf_Vernaux data structures which define the\n// mapping from version identifiers to version names.\ntemplate <class ELFT>\nclass VersionNeedSection final : public SyntheticSection {\n  using Elf_Verneed = typename ELFT::Verneed;\n  using Elf_Vernaux = typename ELFT::Vernaux;\n\n  struct Vernaux {\n    uint64_t hash;\n    uint32_t verneedIndex;\n    uint64_t nameStrTab;\n  };\n\n  struct Verneed {\n    uint64_t nameStrTab;\n    std::vector<Vernaux> vernauxs;\n  };\n\n  std::vector<Verneed> verneeds;\n\npublic:\n  VersionNeedSection();\n  void finalizeContents() override;\n  void writeTo(uint8_t *buf) override;\n  size_t getSize() const override;\n  bool isNeeded() const override;\n};\n\n// MergeSyntheticSection is a class that allows us to put mergeable sections\n// with different attributes in a single output sections. To do that\n// we put them into MergeSyntheticSection synthetic input sections which are\n// attached to regular output sections.\nclass MergeSyntheticSection : public SyntheticSection {\npublic:\n  void addSection(MergeInputSection *ms);\n  std::vector<MergeInputSection *> sections;\n\nprotected:\n  MergeSyntheticSection(StringRef name, uint32_t type, uint64_t flags,\n                        uint32_t alignment)\n      : SyntheticSection(flags, type, alignment, name) {}\n};\n\nclass MergeTailSection final : public MergeSyntheticSection {\npublic:\n  MergeTailSection(StringRef name, uint32_t type, uint64_t flags,\n                   uint32_t alignment);\n\n  size_t getSize() const override;\n  void writeTo(uint8_t *buf) override;\n  void finalizeContents() override;\n\nprivate:\n  llvm::StringTableBuilder builder;\n};\n\nclass MergeNoTailSection final : public MergeSyntheticSection {\npublic:\n  MergeNoTailSection(StringRef name, uint32_t type, uint64_t flags,\n                     uint32_t alignment)\n      : MergeSyntheticSection(name, type, flags, alignment) {}\n\n  size_t getSize() const override { return size; }\n  void writeTo(uint8_t *buf) override;\n  void finalizeContents() override;\n\nprivate:\n  // We use the most significant bits of a hash as a shard ID.\n  // The reason why we don't want to use the least significant bits is\n  // because DenseMap also uses lower bits to determine a bucket ID.\n  // If we use lower bits, it significantly increases the probability of\n  // hash collisons.\n  size_t getShardId(uint32_t hash) {\n    assert((hash >> 31) == 0);\n    return hash >> (31 - llvm::countTrailingZeros(numShards));\n  }\n\n  // Section size\n  size_t size;\n\n  // String table contents\n  constexpr static size_t numShards = 32;\n  std::vector<llvm::StringTableBuilder> shards;\n  size_t shardOffsets[numShards];\n};\n\n// .MIPS.abiflags section.\ntemplate <class ELFT>\nclass MipsAbiFlagsSection final : public SyntheticSection {\n  using Elf_Mips_ABIFlags = llvm::object::Elf_Mips_ABIFlags<ELFT>;\n\npublic:\n  static MipsAbiFlagsSection *create();\n\n  MipsAbiFlagsSection(Elf_Mips_ABIFlags flags);\n  size_t getSize() const override { return sizeof(Elf_Mips_ABIFlags); }\n  void writeTo(uint8_t *buf) override;\n\nprivate:\n  Elf_Mips_ABIFlags flags;\n};\n\n// .MIPS.options section.\ntemplate <class ELFT> class MipsOptionsSection final : public SyntheticSection {\n  using Elf_Mips_Options = llvm::object::Elf_Mips_Options<ELFT>;\n  using Elf_Mips_RegInfo = llvm::object::Elf_Mips_RegInfo<ELFT>;\n\npublic:\n  static MipsOptionsSection *create();\n\n  MipsOptionsSection(Elf_Mips_RegInfo reginfo);\n  void writeTo(uint8_t *buf) override;\n\n  size_t getSize() const override {\n    return sizeof(Elf_Mips_Options) + sizeof(Elf_Mips_RegInfo);\n  }\n\nprivate:\n  Elf_Mips_RegInfo reginfo;\n};\n\n// MIPS .reginfo section.\ntemplate <class ELFT> class MipsReginfoSection final : public SyntheticSection {\n  using Elf_Mips_RegInfo = llvm::object::Elf_Mips_RegInfo<ELFT>;\n\npublic:\n  static MipsReginfoSection *create();\n\n  MipsReginfoSection(Elf_Mips_RegInfo reginfo);\n  size_t getSize() const override { return sizeof(Elf_Mips_RegInfo); }\n  void writeTo(uint8_t *buf) override;\n\nprivate:\n  Elf_Mips_RegInfo reginfo;\n};\n\n// This is a MIPS specific section to hold a space within the data segment\n// of executable file which is pointed to by the DT_MIPS_RLD_MAP entry.\n// See \"Dynamic section\" in Chapter 5 in the following document:\n// ftp://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf\nclass MipsRldMapSection : public SyntheticSection {\npublic:\n  MipsRldMapSection();\n  size_t getSize() const override { return config->wordsize; }\n  void writeTo(uint8_t *buf) override {}\n};\n\n// Representation of the combined .ARM.Exidx input sections. We process these\n// as a SyntheticSection like .eh_frame as we need to merge duplicate entries\n// and add terminating sentinel entries.\n//\n// The .ARM.exidx input sections after SHF_LINK_ORDER processing is done form\n// a table that the unwinder can derive (Addresses are encoded as offsets from\n// table):\n// | Address of function | Unwind instructions for function |\n// where the unwind instructions are either a small number of unwind or the\n// special EXIDX_CANTUNWIND entry representing no unwinding information.\n// When an exception is thrown from an address A, the unwinder searches the\n// table for the closest table entry with Address of function <= A. This means\n// that for two consecutive table entries:\n// | A1 | U1 |\n// | A2 | U2 |\n// The range of addresses described by U1 is [A1, A2)\n//\n// There are two cases where we need a linker generated table entry to fixup\n// the address ranges in the table\n// Case 1:\n// - A sentinel entry added with an address higher than all\n// executable sections. This was needed to work around libunwind bug pr31091.\n// - After address assignment we need to find the highest addressed executable\n// section and use the limit of that section so that the unwinder never\n// matches it.\n// Case 2:\n// - InputSections without a .ARM.exidx section (usually from Assembly)\n// need a table entry so that they terminate the range of the previously\n// function. This is pr40277.\n//\n// Instead of storing pointers to the .ARM.exidx InputSections from\n// InputObjects, we store pointers to the executable sections that need\n// .ARM.exidx sections. We can then use the dependentSections of these to\n// either find the .ARM.exidx section or know that we need to generate one.\nclass ARMExidxSyntheticSection : public SyntheticSection {\npublic:\n  ARMExidxSyntheticSection();\n\n  // Add an input section to the ARMExidxSyntheticSection. Returns whether the\n  // section needs to be removed from the main input section list.\n  bool addSection(InputSection *isec);\n\n  size_t getSize() const override { return size; }\n  void writeTo(uint8_t *buf) override;\n  bool isNeeded() const override;\n  // Sort and remove duplicate entries.\n  void finalizeContents() override;\n  InputSection *getLinkOrderDep() const;\n\n  static bool classof(const SectionBase *d);\n\n  // Links to the ARMExidxSections so we can transfer the relocations once the\n  // layout is known.\n  std::vector<InputSection *> exidxSections;\n\nprivate:\n  size_t size = 0;\n\n  // Instead of storing pointers to the .ARM.exidx InputSections from\n  // InputObjects, we store pointers to the executable sections that need\n  // .ARM.exidx sections. We can then use the dependentSections of these to\n  // either find the .ARM.exidx section or know that we need to generate one.\n  std::vector<InputSection *> executableSections;\n\n  // The executable InputSection with the highest address to use for the\n  // sentinel. We store separately from ExecutableSections as merging of\n  // duplicate entries may mean this InputSection is removed from\n  // ExecutableSections.\n  InputSection *sentinel = nullptr;\n};\n\n// A container for one or more linker generated thunks. Instances of these\n// thunks including ARM interworking and Mips LA25 PI to non-PI thunks.\nclass ThunkSection : public SyntheticSection {\npublic:\n  // ThunkSection in OS, with desired outSecOff of Off\n  ThunkSection(OutputSection *os, uint64_t off);\n\n  // Add a newly created Thunk to this container:\n  // Thunk is given offset from start of this InputSection\n  // Thunk defines a symbol in this InputSection that can be used as target\n  // of a relocation\n  void addThunk(Thunk *t);\n  size_t getSize() const override;\n  void writeTo(uint8_t *buf) override;\n  InputSection *getTargetInputSection() const;\n  bool assignOffsets();\n\n  // When true, round up reported size of section to 4 KiB. See comment\n  // in addThunkSection() for more details.\n  bool roundUpSizeForErrata = false;\n\nprivate:\n  std::vector<Thunk *> thunks;\n  size_t size = 0;\n};\n\n// Used to compute outSecOff of .got2 in each object file. This is needed to\n// synthesize PLT entries for PPC32 Secure PLT ABI.\nclass PPC32Got2Section final : public SyntheticSection {\npublic:\n  PPC32Got2Section();\n  size_t getSize() const override { return 0; }\n  bool isNeeded() const override;\n  void finalizeContents() override;\n  void writeTo(uint8_t *buf) override {}\n};\n\n// This section is used to store the addresses of functions that are called\n// in range-extending thunks on PowerPC64. When producing position dependent\n// code the addresses are link-time constants and the table is written out to\n// the binary. When producing position-dependent code the table is allocated and\n// filled in by the dynamic linker.\nclass PPC64LongBranchTargetSection final : public SyntheticSection {\npublic:\n  PPC64LongBranchTargetSection();\n  uint64_t getEntryVA(const Symbol *sym, int64_t addend);\n  llvm::Optional<uint32_t> addEntry(const Symbol *sym, int64_t addend);\n  size_t getSize() const override;\n  void writeTo(uint8_t *buf) override;\n  bool isNeeded() const override;\n  void finalizeContents() override { finalized = true; }\n\nprivate:\n  std::vector<std::pair<const Symbol *, int64_t>> entries;\n  llvm::DenseMap<std::pair<const Symbol *, int64_t>, uint32_t> entry_index;\n  bool finalized = false;\n};\n\ntemplate <typename ELFT>\nclass PartitionElfHeaderSection : public SyntheticSection {\npublic:\n  PartitionElfHeaderSection();\n  size_t getSize() const override;\n  void writeTo(uint8_t *buf) override;\n};\n\ntemplate <typename ELFT>\nclass PartitionProgramHeadersSection : public SyntheticSection {\npublic:\n  PartitionProgramHeadersSection();\n  size_t getSize() const override;\n  void writeTo(uint8_t *buf) override;\n};\n\nclass PartitionIndexSection : public SyntheticSection {\npublic:\n  PartitionIndexSection();\n  size_t getSize() const override;\n  void finalizeContents() override;\n  void writeTo(uint8_t *buf) override;\n};\n\nInputSection *createInterpSection();\nMergeInputSection *createCommentSection();\nMergeSyntheticSection *createMergeSynthetic(StringRef name, uint32_t type,\n                                            uint64_t flags, uint32_t alignment);\ntemplate <class ELFT> void splitSections();\n\ntemplate <typename ELFT> void writeEhdr(uint8_t *buf, Partition &part);\ntemplate <typename ELFT> void writePhdrs(uint8_t *buf, Partition &part);\n\nDefined *addSyntheticLocal(StringRef name, uint8_t type, uint64_t value,\n                           uint64_t size, InputSectionBase &section);\n\nvoid addVerneed(Symbol *ss);\n\n// Linker generated per-partition sections.\nstruct Partition {\n  StringRef name;\n  uint64_t nameStrTab;\n\n  SyntheticSection *elfHeader;\n  SyntheticSection *programHeaders;\n  std::vector<PhdrEntry *> phdrs;\n\n  ARMExidxSyntheticSection *armExidx;\n  BuildIdSection *buildId;\n  SyntheticSection *dynamic;\n  StringTableSection *dynStrTab;\n  SymbolTableBaseSection *dynSymTab;\n  EhFrameHeader *ehFrameHdr;\n  EhFrameSection *ehFrame;\n  GnuHashTableSection *gnuHashTab;\n  HashTableSection *hashTab;\n  RelocationBaseSection *relaDyn;\n  RelrBaseSection *relrDyn;\n  VersionDefinitionSection *verDef;\n  SyntheticSection *verNeed;\n  VersionTableSection *verSym;\n\n  unsigned getNumber() const { return this - &partitions[0] + 1; }\n};\n\nextern Partition *mainPart;\n\ninline Partition &SectionBase::getPartition() const {\n  assert(isLive());\n  return partitions[partition - 1];\n}\n\n// Linker generated sections which can be used as inputs and are not specific to\n// a partition.\nstruct InStruct {\n  InputSection *attributes;\n  BssSection *bss;\n  BssSection *bssRelRo;\n  GotSection *got;\n  GotPltSection *gotPlt;\n  IgotPltSection *igotPlt;\n  PPC64LongBranchTargetSection *ppc64LongBranchTarget;\n  MipsGotSection *mipsGot;\n  MipsRldMapSection *mipsRldMap;\n  SyntheticSection *partEnd;\n  SyntheticSection *partIndex;\n  PltSection *plt;\n  IpltSection *iplt;\n  PPC32Got2Section *ppc32Got2;\n  IBTPltSection *ibtPlt;\n  RelocationBaseSection *relaPlt;\n  RelocationBaseSection *relaIplt;\n  StringTableSection *shStrTab;\n  StringTableSection *strTab;\n  SymbolTableBaseSection *symTab;\n  SymtabShndxSection *symTabShndx;\n};\n\nextern InStruct in;\n\n} // namespace elf\n} // namespace lld\n\n#endif\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h", "content": "//===- llvm/ADT/TinyPtrVector.h - 'Normally tiny' vectors -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_TINYPTRVECTOR_H\n#define LLVM_ADT_TINYPTRVECTOR_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <type_traits>\n\nnamespace llvm {\n\n/// TinyPtrVector - This class is specialized for cases where there are\n/// normally 0 or 1 element in a vector, but is general enough to go beyond that\n/// when required.\n///\n/// NOTE: This container doesn't allow you to store a null pointer into it.\n///\ntemplate <typename EltTy>\nclass TinyPtrVector {\npublic:\n  using VecTy = SmallVector<EltTy, 4>;\n  using value_type = typename VecTy::value_type;\n  // EltTy must be the first pointer type so that is<EltTy> is true for the\n  // default-constructed PtrUnion. This allows an empty TinyPtrVector to\n  // naturally vend a begin/end iterator of type EltTy* without an additional\n  // check for the empty state.\n  using PtrUnion = PointerUnion<EltTy, VecTy *>;\n\nprivate:\n  PtrUnion Val;\n\npublic:\n  TinyPtrVector() = default;\n\n  ~TinyPtrVector() {\n    if (VecTy *V = Val.template dyn_cast<VecTy*>())\n      delete V;\n  }\n\n  TinyPtrVector(const TinyPtrVector &RHS) : Val(RHS.Val) {\n    if (VecTy *V = Val.template dyn_cast<VecTy*>())\n      Val = new VecTy(*V);\n  }\n\n  TinyPtrVector &operator=(const TinyPtrVector &RHS) {\n    if (this == &RHS)\n      return *this;\n    if (RHS.empty()) {\n      this->clear();\n      return *this;\n    }\n\n    // Try to squeeze into the single slot. If it won't fit, allocate a copied\n    // vector.\n    if (Val.template is<EltTy>()) {\n      if (RHS.size() == 1)\n        Val = RHS.front();\n      else\n        Val = new VecTy(*RHS.Val.template get<VecTy*>());\n      return *this;\n    }\n\n    // If we have a full vector allocated, try to re-use it.\n    if (RHS.Val.template is<EltTy>()) {\n      Val.template get<VecTy*>()->clear();\n      Val.template get<VecTy*>()->push_back(RHS.front());\n    } else {\n      *Val.template get<VecTy*>() = *RHS.Val.template get<VecTy*>();\n    }\n    return *this;\n  }\n\n  TinyPtrVector(TinyPtrVector &&RHS) : Val(RHS.Val) {\n    RHS.Val = (EltTy)nullptr;\n  }\n\n  TinyPtrVector &operator=(TinyPtrVector &&RHS) {\n    if (this == &RHS)\n      return *this;\n    if (RHS.empty()) {\n      this->clear();\n      return *this;\n    }\n\n    // If this vector has been allocated on the heap, re-use it if cheap. If it\n    // would require more copying, just delete it and we'll steal the other\n    // side.\n    if (VecTy *V = Val.template dyn_cast<VecTy*>()) {\n      if (RHS.Val.template is<EltTy>()) {\n        V->clear();\n        V->push_back(RHS.front());\n        RHS.Val = EltTy();\n        return *this;\n      }\n      delete V;\n    }\n\n    Val = RHS.Val;\n    RHS.Val = EltTy();\n    return *this;\n  }\n\n  TinyPtrVector(std::initializer_list<EltTy> IL)\n      : Val(IL.size() == 0\n                ? PtrUnion()\n                : IL.size() == 1 ? PtrUnion(*IL.begin())\n                                 : PtrUnion(new VecTy(IL.begin(), IL.end()))) {}\n\n  /// Constructor from an ArrayRef.\n  ///\n  /// This also is a constructor for individual array elements due to the single\n  /// element constructor for ArrayRef.\n  explicit TinyPtrVector(ArrayRef<EltTy> Elts)\n      : Val(Elts.empty()\n                ? PtrUnion()\n                : Elts.size() == 1\n                      ? PtrUnion(Elts[0])\n                      : PtrUnion(new VecTy(Elts.begin(), Elts.end()))) {}\n\n  TinyPtrVector(size_t Count, EltTy Value)\n      : Val(Count == 0 ? PtrUnion()\n                       : Count == 1 ? PtrUnion(Value)\n                                    : PtrUnion(new VecTy(Count, Value))) {}\n\n  // implicit conversion operator to ArrayRef.\n  operator ArrayRef<EltTy>() const {\n    if (Val.isNull())\n      return None;\n    if (Val.template is<EltTy>())\n      return *Val.getAddrOfPtr1();\n    return *Val.template get<VecTy*>();\n  }\n\n  // implicit conversion operator to MutableArrayRef.\n  operator MutableArrayRef<EltTy>() {\n    if (Val.isNull())\n      return None;\n    if (Val.template is<EltTy>())\n      return *Val.getAddrOfPtr1();\n    return *Val.template get<VecTy*>();\n  }\n\n  // Implicit conversion to ArrayRef<U> if EltTy* implicitly converts to U*.\n  template <\n      typename U,\n      std::enable_if_t<std::is_convertible<ArrayRef<EltTy>, ArrayRef<U>>::value,\n                       bool> = false>\n  operator ArrayRef<U>() const {\n    return operator ArrayRef<EltTy>();\n  }\n\n  bool empty() const {\n    // This vector can be empty if it contains no element, or if it\n    // contains a pointer to an empty vector.\n    if (Val.isNull()) return true;\n    if (VecTy *Vec = Val.template dyn_cast<VecTy*>())\n      return Vec->empty();\n    return false;\n  }\n\n  unsigned size() const {\n    if (empty())\n      return 0;\n    if (Val.template is<EltTy>())\n      return 1;\n    return Val.template get<VecTy*>()->size();\n  }\n\n  using iterator = EltTy *;\n  using const_iterator = const EltTy *;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\n  iterator begin() {\n    if (Val.template is<EltTy>())\n      return Val.getAddrOfPtr1();\n\n    return Val.template get<VecTy *>()->begin();\n  }\n\n  iterator end() {\n    if (Val.template is<EltTy>())\n      return begin() + (Val.isNull() ? 0 : 1);\n\n    return Val.template get<VecTy *>()->end();\n  }\n\n  const_iterator begin() const {\n    return (const_iterator)const_cast<TinyPtrVector*>(this)->begin();\n  }\n\n  const_iterator end() const {\n    return (const_iterator)const_cast<TinyPtrVector*>(this)->end();\n  }\n\n  reverse_iterator rbegin() { return reverse_iterator(end()); }\n  reverse_iterator rend() { return reverse_iterator(begin()); }\n\n  const_reverse_iterator rbegin() const {\n    return const_reverse_iterator(end());\n  }\n\n  const_reverse_iterator rend() const {\n    return const_reverse_iterator(begin());\n  }\n\n  EltTy operator[](unsigned i) const {\n    assert(!Val.isNull() && \"can't index into an empty vector\");\n    if (Val.template is<EltTy>()) {\n      assert(i == 0 && \"tinyvector index out of range\");\n      return Val.template get<EltTy>();\n    }\n\n    assert(i < Val.template get<VecTy*>()->size() &&\n           \"tinyvector index out of range\");\n    return (*Val.template get<VecTy*>())[i];\n  }\n\n  EltTy front() const {\n    assert(!empty() && \"vector empty\");\n    if (Val.template is<EltTy>())\n      return Val.template get<EltTy>();\n    return Val.template get<VecTy*>()->front();\n  }\n\n  EltTy back() const {\n    assert(!empty() && \"vector empty\");\n    if (Val.template is<EltTy>())\n      return Val.template get<EltTy>();\n    return Val.template get<VecTy*>()->back();\n  }\n\n  void push_back(EltTy NewVal) {\n    // If we have nothing, add something.\n    if (Val.isNull()) {\n      Val = NewVal;\n      assert(!Val.isNull() && \"Can't add a null value\");\n      return;\n    }\n\n    // If we have a single value, convert to a vector.\n    if (Val.template is<EltTy>()) {\n      EltTy V = Val.template get<EltTy>();\n      Val = new VecTy();\n      Val.template get<VecTy*>()->push_back(V);\n    }\n\n    // Add the new value, we know we have a vector.\n    Val.template get<VecTy*>()->push_back(NewVal);\n  }\n\n  void pop_back() {\n    // If we have a single value, convert to empty.\n    if (Val.template is<EltTy>())\n      Val = (EltTy)nullptr;\n    else if (VecTy *Vec = Val.template get<VecTy*>())\n      Vec->pop_back();\n  }\n\n  void clear() {\n    // If we have a single value, convert to empty.\n    if (Val.template is<EltTy>()) {\n      Val = EltTy();\n    } else if (VecTy *Vec = Val.template dyn_cast<VecTy*>()) {\n      // If we have a vector form, just clear it.\n      Vec->clear();\n    }\n    // Otherwise, we're already empty.\n  }\n\n  iterator erase(iterator I) {\n    assert(I >= begin() && \"Iterator to erase is out of bounds.\");\n    assert(I < end() && \"Erasing at past-the-end iterator.\");\n\n    // If we have a single value, convert to empty.\n    if (Val.template is<EltTy>()) {\n      if (I == begin())\n        Val = EltTy();\n    } else if (VecTy *Vec = Val.template dyn_cast<VecTy*>()) {\n      // multiple items in a vector; just do the erase, there is no\n      // benefit to collapsing back to a pointer\n      return Vec->erase(I);\n    }\n    return end();\n  }\n\n  iterator erase(iterator S, iterator E) {\n    assert(S >= begin() && \"Range to erase is out of bounds.\");\n    assert(S <= E && \"Trying to erase invalid range.\");\n    assert(E <= end() && \"Trying to erase past the end.\");\n\n    if (Val.template is<EltTy>()) {\n      if (S == begin() && S != E)\n        Val = EltTy();\n    } else if (VecTy *Vec = Val.template dyn_cast<VecTy*>()) {\n      return Vec->erase(S, E);\n    }\n    return end();\n  }\n\n  iterator insert(iterator I, const EltTy &Elt) {\n    assert(I >= this->begin() && \"Insertion iterator is out of bounds.\");\n    assert(I <= this->end() && \"Inserting past the end of the vector.\");\n    if (I == end()) {\n      push_back(Elt);\n      return std::prev(end());\n    }\n    assert(!Val.isNull() && \"Null value with non-end insert iterator.\");\n    if (Val.template is<EltTy>()) {\n      EltTy V = Val.template get<EltTy>();\n      assert(I == begin());\n      Val = Elt;\n      push_back(V);\n      return begin();\n    }\n\n    return Val.template get<VecTy*>()->insert(I, Elt);\n  }\n\n  template<typename ItTy>\n  iterator insert(iterator I, ItTy From, ItTy To) {\n    assert(I >= this->begin() && \"Insertion iterator is out of bounds.\");\n    assert(I <= this->end() && \"Inserting past the end of the vector.\");\n    if (From == To)\n      return I;\n\n    // If we have a single value, convert to a vector.\n    ptrdiff_t Offset = I - begin();\n    if (Val.isNull()) {\n      if (std::next(From) == To) {\n        Val = *From;\n        return begin();\n      }\n\n      Val = new VecTy();\n    } else if (Val.template is<EltTy>()) {\n      EltTy V = Val.template get<EltTy>();\n      Val = new VecTy();\n      Val.template get<VecTy*>()->push_back(V);\n    }\n    return Val.template get<VecTy*>()->insert(begin() + Offset, From, To);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_TINYPTRVECTOR_H\n"}, "66": {"id": 66, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "content": "//===- llvm/Value.h - Definition of the Value class -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the Value class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_VALUE_H\n#define LLVM_IR_VALUE_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <iterator>\n#include <memory>\n\nnamespace llvm {\n\nclass APInt;\nclass Argument;\nclass BasicBlock;\nclass Constant;\nclass ConstantData;\nclass ConstantAggregate;\nclass DataLayout;\nclass Function;\nclass GlobalAlias;\nclass GlobalIFunc;\nclass GlobalIndirectSymbol;\nclass GlobalObject;\nclass GlobalValue;\nclass GlobalVariable;\nclass InlineAsm;\nclass Instruction;\nclass LLVMContext;\nclass MDNode;\nclass Module;\nclass ModuleSlotTracker;\nclass raw_ostream;\ntemplate<typename ValueTy> class StringMapEntry;\nclass Twine;\nclass Type;\nclass User;\n\nusing ValueName = StringMapEntry<Value *>;\n\n//===----------------------------------------------------------------------===//\n//                                 Value Class\n//===----------------------------------------------------------------------===//\n\n/// LLVM Value Representation\n///\n/// This is a very important LLVM class. It is the base class of all values\n/// computed by a program that may be used as operands to other values. Value is\n/// the super class of other important classes such as Instruction and Function.\n/// All Values have a Type. Type is not a subclass of Value. Some values can\n/// have a name and they belong to some Module.  Setting the name on the Value\n/// automatically updates the module's symbol table.\n///\n/// Every value has a \"use list\" that keeps track of which other Values are\n/// using this Value.  A Value can also have an arbitrary number of ValueHandle\n/// objects that watch it and listen to RAUW and Destroy events.  See\n/// llvm/IR/ValueHandle.h for details.\nclass Value {\n  Type *VTy;\n  Use *UseList;\n\n  friend class ValueAsMetadata; // Allow access to IsUsedByMD.\n  friend class ValueHandleBase;\n\n  const unsigned char SubclassID;   // Subclass identifier (for isa/dyn_cast)\n  unsigned char HasValueHandle : 1; // Has a ValueHandle pointing to this?\n\nprotected:\n  /// Hold subclass data that can be dropped.\n  ///\n  /// This member is similar to SubclassData, however it is for holding\n  /// information which may be used to aid optimization, but which may be\n  /// cleared to zero without affecting conservative interpretation.\n  unsigned char SubclassOptionalData : 7;\n\nprivate:\n  /// Hold arbitrary subclass data.\n  ///\n  /// This member is defined by this class, but is not used for anything.\n  /// Subclasses can use it to hold whatever state they find useful.  This\n  /// field is initialized to zero by the ctor.\n  unsigned short SubclassData;\n\nprotected:\n  /// The number of operands in the subclass.\n  ///\n  /// This member is defined by this class, but not used for anything.\n  /// Subclasses can use it to store their number of operands, if they have\n  /// any.\n  ///\n  /// This is stored here to save space in User on 64-bit hosts.  Since most\n  /// instances of Value have operands, 32-bit hosts aren't significantly\n  /// affected.\n  ///\n  /// Note, this should *NOT* be used directly by any class other than User.\n  /// User uses this value to find the Use list.\n  enum : unsigned { NumUserOperandsBits = 27 };\n  unsigned NumUserOperands : NumUserOperandsBits;\n\n  // Use the same type as the bitfield above so that MSVC will pack them.\n  unsigned IsUsedByMD : 1;\n  unsigned HasName : 1;\n  unsigned HasMetadata : 1; // Has metadata attached to this?\n  unsigned HasHungOffUses : 1;\n  unsigned HasDescriptor : 1;\n\nprivate:\n  template <typename UseT> // UseT == 'Use' or 'const Use'\n  class use_iterator_impl\n      : public std::iterator<std::forward_iterator_tag, UseT *> {\n    friend class Value;\n\n    UseT *U;\n\n    explicit use_iterator_impl(UseT *u) : U(u) {}\n\n  public:\n    use_iterator_impl() : U() {}\n\n    bool operator==(const use_iterator_impl &x) const { return U == x.U; }\n    bool operator!=(const use_iterator_impl &x) const { return !operator==(x); }\n\n    use_iterator_impl &operator++() { // Preincrement\n      assert(U && \"Cannot increment end iterator!\");\n      U = U->getNext();\n      return *this;\n    }\n\n    use_iterator_impl operator++(int) { // Postincrement\n      auto tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    UseT &operator*() const {\n      assert(U && \"Cannot dereference end iterator!\");\n      return *U;\n    }\n\n    UseT *operator->() const { return &operator*(); }\n\n    operator use_iterator_impl<const UseT>() const {\n      return use_iterator_impl<const UseT>(U);\n    }\n  };\n\n  template <typename UserTy> // UserTy == 'User' or 'const User'\n  class user_iterator_impl\n      : public std::iterator<std::forward_iterator_tag, UserTy *> {\n    use_iterator_impl<Use> UI;\n    explicit user_iterator_impl(Use *U) : UI(U) {}\n    friend class Value;\n\n  public:\n    user_iterator_impl() = default;\n\n    bool operator==(const user_iterator_impl &x) const { return UI == x.UI; }\n    bool operator!=(const user_iterator_impl &x) const { return !operator==(x); }\n\n    /// Returns true if this iterator is equal to user_end() on the value.\n    bool atEnd() const { return *this == user_iterator_impl(); }\n\n    user_iterator_impl &operator++() { // Preincrement\n      ++UI;\n      return *this;\n    }\n\n    user_iterator_impl operator++(int) { // Postincrement\n      auto tmp = *this;\n      ++*this;\n      return tmp;\n    }\n\n    // Retrieve a pointer to the current User.\n    UserTy *operator*() const {\n      return UI->getUser();\n    }\n\n    UserTy *operator->() const { return operator*(); }\n\n    operator user_iterator_impl<const UserTy>() const {\n      return user_iterator_impl<const UserTy>(*UI);\n    }\n\n    Use &getUse() const { return *UI; }\n  };\n\nprotected:\n  Value(Type *Ty, unsigned scid);\n\n  /// Value's destructor should be virtual by design, but that would require\n  /// that Value and all of its subclasses have a vtable that effectively\n  /// duplicates the information in the value ID. As a size optimization, the\n  /// destructor has been protected, and the caller should manually call\n  /// deleteValue.\n  ~Value(); // Use deleteValue() to delete a generic Value.\n\npublic:\n  Value(const Value &) = delete;\n  Value &operator=(const Value &) = delete;\n\n  /// Delete a pointer to a generic Value.\n  void deleteValue();\n\n  /// Support for debugging, callable in GDB: V->dump()\n  void dump() const;\n\n  /// Implement operator<< on Value.\n  /// @{\n  void print(raw_ostream &O, bool IsForDebug = false) const;\n  void print(raw_ostream &O, ModuleSlotTracker &MST,\n             bool IsForDebug = false) const;\n  /// @}\n\n  /// Print the name of this Value out to the specified raw_ostream.\n  ///\n  /// This is useful when you just want to print 'int %reg126', not the\n  /// instruction that generated it. If you specify a Module for context, then\n  /// even constanst get pretty-printed; for example, the type of a null\n  /// pointer is printed symbolically.\n  /// @{\n  void printAsOperand(raw_ostream &O, bool PrintType = true,\n                      const Module *M = nullptr) const;\n  void printAsOperand(raw_ostream &O, bool PrintType,\n                      ModuleSlotTracker &MST) const;\n  /// @}\n\n  /// All values are typed, get the type of this value.\n  Type *getType() const { return VTy; }\n\n  /// All values hold a context through their type.\n  LLVMContext &getContext() const;\n\n  // All values can potentially be named.\n  bool hasName() const { return HasName; }\n  ValueName *getValueName() const;\n  void setValueName(ValueName *VN);\n\nprivate:\n  void destroyValueName();\n  enum class ReplaceMetadataUses { No, Yes };\n  void doRAUW(Value *New, ReplaceMetadataUses);\n  void setNameImpl(const Twine &Name);\n\npublic:\n  /// Return a constant reference to the value's name.\n  ///\n  /// This guaranteed to return the same reference as long as the value is not\n  /// modified.  If the value has a name, this does a hashtable lookup, so it's\n  /// not free.\n  StringRef getName() const;\n\n  /// Change the name of the value.\n  ///\n  /// Choose a new unique name if the provided name is taken.\n  ///\n  /// \\param Name The new name; or \"\" if the value's name should be removed.\n  void setName(const Twine &Name);\n\n  /// Transfer the name from V to this value.\n  ///\n  /// After taking V's name, sets V's name to empty.\n  ///\n  /// \\note It is an error to call V->takeName(V).\n  void takeName(Value *V);\n\n#ifndef NDEBUG\n  std::string getNameOrAsOperand() const;\n#endif\n\n  /// Change all uses of this to point to a new Value.\n  ///\n  /// Go through the uses list for this definition and make each use point to\n  /// \"V\" instead of \"this\".  After this completes, 'this's use list is\n  /// guaranteed to be empty.\n  void replaceAllUsesWith(Value *V);\n\n  /// Change non-metadata uses of this to point to a new Value.\n  ///\n  /// Go through the uses list for this definition and make each use point to\n  /// \"V\" instead of \"this\". This function skips metadata entries in the list.\n  void replaceNonMetadataUsesWith(Value *V);\n\n  /// Go through the uses list for this definition and make each use point\n  /// to \"V\" if the callback ShouldReplace returns true for the given Use.\n  /// Unlike replaceAllUsesWith() this function does not support basic block\n  /// values or constant users.\n  void replaceUsesWithIf(Value *New,\n                         llvm::function_ref<bool(Use &U)> ShouldReplace) {\n    assert(New && \"Value::replaceUsesWithIf(<null>) is invalid!\");\n    assert(New->getType() == getType() &&\n           \"replaceUses of value with new value of different type!\");\n\n    for (use_iterator UI = use_begin(), E = use_end(); UI != E;) {\n      Use &U = *UI;\n      ++UI;\n      if (!ShouldReplace(U))\n        continue;\n      U.set(New);\n    }\n  }\n\n  /// replaceUsesOutsideBlock - Go through the uses list for this definition and\n  /// make each use point to \"V\" instead of \"this\" when the use is outside the\n  /// block. 'This's use list is expected to have at least one element.\n  /// Unlike replaceAllUsesWith() this function does not support basic block\n  /// values or constant users.\n  void replaceUsesOutsideBlock(Value *V, BasicBlock *BB);\n\n  //----------------------------------------------------------------------\n  // Methods for handling the chain of uses of this Value.\n  //\n  // Materializing a function can introduce new uses, so these methods come in\n  // two variants:\n  // The methods that start with materialized_ check the uses that are\n  // currently known given which functions are materialized. Be very careful\n  // when using them since you might not get all uses.\n  // The methods that don't start with materialized_ assert that modules is\n  // fully materialized.\n  void assertModuleIsMaterializedImpl() const;\n  // This indirection exists so we can keep assertModuleIsMaterializedImpl()\n  // around in release builds of Value.cpp to be linked with other code built\n  // in debug mode. But this avoids calling it in any of the release built code.\n  void assertModuleIsMaterialized() const {\n#ifndef NDEBUG\n    assertModuleIsMaterializedImpl();\n#endif\n  }\n\n  bool use_empty() const {\n    assertModuleIsMaterialized();\n    return UseList == nullptr;\n  }\n\n  bool materialized_use_empty() const {\n    return UseList == nullptr;\n  }\n\n  using use_iterator = use_iterator_impl<Use>;\n  using const_use_iterator = use_iterator_impl<const Use>;\n\n  use_iterator materialized_use_begin() { return use_iterator(UseList); }\n  const_use_iterator materialized_use_begin() const {\n    return const_use_iterator(UseList);\n  }\n  use_iterator use_begin() {\n    assertModuleIsMaterialized();\n    return materialized_use_begin();\n  }\n  const_use_iterator use_begin() const {\n    assertModuleIsMaterialized();\n    return materialized_use_begin();\n  }\n  use_iterator use_end() { return use_iterator(); }\n  const_use_iterator use_end() const { return const_use_iterator(); }\n  iterator_range<use_iterator> materialized_uses() {\n    return make_range(materialized_use_begin(), use_end());\n  }\n  iterator_range<const_use_iterator> materialized_uses() const {\n    return make_range(materialized_use_begin(), use_end());\n  }\n  iterator_range<use_iterator> uses() {\n    assertModuleIsMaterialized();\n    return materialized_uses();\n  }\n  iterator_range<const_use_iterator> uses() const {\n    assertModuleIsMaterialized();\n    return materialized_uses();\n  }\n\n  bool user_empty() const {\n    assertModuleIsMaterialized();\n    return UseList == nullptr;\n  }\n\n  using user_iterator = user_iterator_impl<User>;\n  using const_user_iterator = user_iterator_impl<const User>;\n\n  user_iterator materialized_user_begin() { return user_iterator(UseList); }\n  const_user_iterator materialized_user_begin() const {\n    return const_user_iterator(UseList);\n  }\n  user_iterator user_begin() {\n    assertModuleIsMaterialized();\n    return materialized_user_begin();\n  }\n  const_user_iterator user_begin() const {\n    assertModuleIsMaterialized();\n    return materialized_user_begin();\n  }\n  user_iterator user_end() { return user_iterator(); }\n  const_user_iterator user_end() const { return const_user_iterator(); }\n  User *user_back() {\n    assertModuleIsMaterialized();\n    return *materialized_user_begin();\n  }\n  const User *user_back() const {\n    assertModuleIsMaterialized();\n    return *materialized_user_begin();\n  }\n  iterator_range<user_iterator> materialized_users() {\n    return make_range(materialized_user_begin(), user_end());\n  }\n  iterator_range<const_user_iterator> materialized_users() const {\n    return make_range(materialized_user_begin(), user_end());\n  }\n  iterator_range<user_iterator> users() {\n    assertModuleIsMaterialized();\n    return materialized_users();\n  }\n  iterator_range<const_user_iterator> users() const {\n    assertModuleIsMaterialized();\n    return materialized_users();\n  }\n\n  /// Return true if there is exactly one use of this value.\n  ///\n  /// This is specialized because it is a common request and does not require\n  /// traversing the whole use list.\n  bool hasOneUse() const { return hasSingleElement(uses()); }\n\n  /// Return true if this Value has exactly N uses.\n  bool hasNUses(unsigned N) const;\n\n  /// Return true if this value has N uses or more.\n  ///\n  /// This is logically equivalent to getNumUses() >= N.\n  bool hasNUsesOrMore(unsigned N) const;\n\n  /// Return true if there is exactly one user of this value.\n  ///\n  /// Note that this is not the same as \"has one use\". If a value has one use,\n  /// then there certainly is a single user. But if value has several uses,\n  /// it is possible that all uses are in a single user, or not.\n  ///\n  /// This check is potentially costly, since it requires traversing,\n  /// in the worst case, the whole use list of a value.\n  bool hasOneUser() const;\n\n  /// Return true if there is exactly one use of this value that cannot be\n  /// dropped.\n  ///\n  /// This is specialized because it is a common request and does not require\n  /// traversing the whole use list.\n  Use *getSingleUndroppableUse();\n  const Use *getSingleUndroppableUse() const {\n    return const_cast<Value *>(this)->getSingleUndroppableUse();\n  }\n\n  /// Return true if there this value.\n  ///\n  /// This is specialized because it is a common request and does not require\n  /// traversing the whole use list.\n  bool hasNUndroppableUses(unsigned N) const;\n\n  /// Return true if this value has N uses or more.\n  ///\n  /// This is logically equivalent to getNumUses() >= N.\n  bool hasNUndroppableUsesOrMore(unsigned N) const;\n\n  /// Remove every uses that can safely be removed.\n  ///\n  /// This will remove for example uses in llvm.assume.\n  /// This should be used when performing want to perform a tranformation but\n  /// some Droppable uses pervent it.\n  /// This function optionally takes a filter to only remove some droppable\n  /// uses.\n  void dropDroppableUses(llvm::function_ref<bool(const Use *)> ShouldDrop =\n                             [](const Use *) { return true; });\n\n  /// Remove every use of this value in \\p User that can safely be removed.\n  void dropDroppableUsesIn(User &Usr);\n\n  /// Remove the droppable use \\p U.\n  static void dropDroppableUse(Use &U);\n\n  /// Check if this value is used in the specified basic block.\n  bool isUsedInBasicBlock(const BasicBlock *BB) const;\n\n  /// This method computes the number of uses of this Value.\n  ///\n  /// This is a linear time operation.  Use hasOneUse, hasNUses, or\n  /// hasNUsesOrMore to check for specific values.\n  unsigned getNumUses() const;\n\n  /// This method should only be used by the Use class.\n  void addUse(Use &U) { U.addToList(&UseList); }\n\n  /// Concrete subclass of this.\n  ///\n  /// An enumeration for keeping track of the concrete subclass of Value that\n  /// is actually instantiated. Values of this enumeration are kept in the\n  /// Value classes SubclassID field. They are used for concrete type\n  /// identification.\n  enum ValueTy {\n#define HANDLE_VALUE(Name) Name##Val,\n#include \"llvm/IR/Value.def\"\n\n    // Markers:\n#define HANDLE_CONSTANT_MARKER(Marker, Constant) Marker = Constant##Val,\n#include \"llvm/IR/Value.def\"\n  };\n\n  /// Return an ID for the concrete type of this object.\n  ///\n  /// This is used to implement the classof checks.  This should not be used\n  /// for any other purpose, as the values may change as LLVM evolves.  Also,\n  /// note that for instructions, the Instruction's opcode is added to\n  /// InstructionVal. So this means three things:\n  /// # there is no value with code InstructionVal (no opcode==0).\n  /// # there are more possible values for the value type than in ValueTy enum.\n  /// # the InstructionVal enumerator must be the highest valued enumerator in\n  ///   the ValueTy enum.\n  unsigned getValueID() const {\n    return SubclassID;\n  }\n\n  /// Return the raw optional flags value contained in this value.\n  ///\n  /// This should only be used when testing two Values for equivalence.\n  unsigned getRawSubclassOptionalData() const {\n    return SubclassOptionalData;\n  }\n\n  /// Clear the optional flags contained in this value.\n  void clearSubclassOptionalData() {\n    SubclassOptionalData = 0;\n  }\n\n  /// Check the optional flags for equality.\n  bool hasSameSubclassOptionalData(const Value *V) const {\n    return SubclassOptionalData == V->SubclassOptionalData;\n  }\n\n  /// Return true if there is a value handle associated with this value.\n  bool hasValueHandle() const { return HasValueHandle; }\n\n  /// Return true if there is metadata referencing this value.\n  bool isUsedByMetadata() const { return IsUsedByMD; }\n\nprotected:\n  /// Get the current metadata attachments for the given kind, if any.\n  ///\n  /// These functions require that the value have at most a single attachment\n  /// of the given kind, and return \\c nullptr if such an attachment is missing.\n  /// @{\n  MDNode *getMetadata(unsigned KindID) const;\n  MDNode *getMetadata(StringRef Kind) const;\n  /// @}\n\n  /// Appends all attachments with the given ID to \\c MDs in insertion order.\n  /// If the Value has no attachments with the given ID, or if ID is invalid,\n  /// leaves MDs unchanged.\n  /// @{\n  void getMetadata(unsigned KindID, SmallVectorImpl<MDNode *> &MDs) const;\n  void getMetadata(StringRef Kind, SmallVectorImpl<MDNode *> &MDs) const;\n  /// @}\n\n  /// Appends all metadata attached to this value to \\c MDs, sorting by\n  /// KindID. The first element of each pair returned is the KindID, the second\n  /// element is the metadata value. Attachments with the same ID appear in\n  /// insertion order.\n  void\n  getAllMetadata(SmallVectorImpl<std::pair<unsigned, MDNode *>> &MDs) const;\n\n  /// Return true if this value has any metadata attached to it.\n  bool hasMetadata() const { return (bool)HasMetadata; }\n\n  /// Return true if this value has the given type of metadata attached.\n  /// @{\n  bool hasMetadata(unsigned KindID) const {\n    return getMetadata(KindID) != nullptr;\n  }\n  bool hasMetadata(StringRef Kind) const {\n    return getMetadata(Kind) != nullptr;\n  }\n  /// @}\n\n  /// Set a particular kind of metadata attachment.\n  ///\n  /// Sets the given attachment to \\c MD, erasing it if \\c MD is \\c nullptr or\n  /// replacing it if it already exists.\n  /// @{\n  void setMetadata(unsigned KindID, MDNode *Node);\n  void setMetadata(StringRef Kind, MDNode *Node);\n  /// @}\n\n  /// Add a metadata attachment.\n  /// @{\n  void addMetadata(unsigned KindID, MDNode &MD);\n  void addMetadata(StringRef Kind, MDNode &MD);\n  /// @}\n\n  /// Erase all metadata attachments with the given kind.\n  ///\n  /// \\returns true if any metadata was removed.\n  bool eraseMetadata(unsigned KindID);\n\n  /// Erase all metadata attached to this Value.\n  void clearMetadata();\n\npublic:\n  /// Return true if this value is a swifterror value.\n  ///\n  /// swifterror values can be either a function argument or an alloca with a\n  /// swifterror attribute.\n  bool isSwiftError() const;\n\n  /// Strip off pointer casts, all-zero GEPs and address space casts.\n  ///\n  /// Returns the original uncasted value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripPointerCasts() const;\n  Value *stripPointerCasts() {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripPointerCasts());\n  }\n\n  /// Strip off pointer casts, all-zero GEPs, address space casts, and aliases.\n  ///\n  /// Returns the original uncasted value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripPointerCastsAndAliases() const;\n  Value *stripPointerCastsAndAliases() {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripPointerCastsAndAliases());\n  }\n\n  /// Strip off pointer casts, all-zero GEPs and address space casts\n  /// but ensures the representation of the result stays the same.\n  ///\n  /// Returns the original uncasted value with the same representation. If this\n  /// is called on a non-pointer value, it returns 'this'.\n  const Value *stripPointerCastsSameRepresentation() const;\n  Value *stripPointerCastsSameRepresentation() {\n    return const_cast<Value *>(static_cast<const Value *>(this)\n                                   ->stripPointerCastsSameRepresentation());\n  }\n\n  /// Strip off pointer casts, all-zero GEPs, single-argument phi nodes and\n  /// invariant group info.\n  ///\n  /// Returns the original uncasted value.  If this is called on a non-pointer\n  /// value, it returns 'this'. This function should be used only in\n  /// Alias analysis.\n  const Value *stripPointerCastsForAliasAnalysis() const;\n  Value *stripPointerCastsForAliasAnalysis() {\n    return const_cast<Value *>(static_cast<const Value *>(this)\n                                   ->stripPointerCastsForAliasAnalysis());\n  }\n\n  /// Strip off pointer casts and all-constant inbounds GEPs.\n  ///\n  /// Returns the original pointer value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripInBoundsConstantOffsets() const;\n  Value *stripInBoundsConstantOffsets() {\n    return const_cast<Value *>(\n              static_cast<const Value *>(this)->stripInBoundsConstantOffsets());\n  }\n\n  /// Accumulate the constant offset this value has compared to a base pointer.\n  /// Only 'getelementptr' instructions (GEPs) are accumulated but other\n  /// instructions, e.g., casts, are stripped away as well.\n  /// The accumulated constant offset is added to \\p Offset and the base\n  /// pointer is returned.\n  ///\n  /// The APInt \\p Offset has to have a bit-width equal to the IntPtr type for\n  /// the address space of 'this' pointer value, e.g., use\n  /// DataLayout::getIndexTypeSizeInBits(Ty).\n  ///\n  /// If \\p AllowNonInbounds is true, offsets in GEPs are stripped and\n  /// accumulated even if the GEP is not \"inbounds\".\n  ///\n  /// If \\p ExternalAnalysis is provided it will be used to calculate a offset\n  /// when a operand of GEP is not constant.\n  /// For example, for a value \\p ExternalAnalysis might try to calculate a\n  /// lower bound. If \\p ExternalAnalysis is successful, it should return true.\n  ///\n  /// If this is called on a non-pointer value, it returns 'this' and the\n  /// \\p Offset is not modified.\n  ///\n  /// Note that this function will never return a nullptr. It will also never\n  /// manipulate the \\p Offset in a way that would not match the difference\n  /// between the underlying value and the returned one. Thus, if no constant\n  /// offset was found, the returned value is the underlying one and \\p Offset\n  /// is unchanged.\n  const Value *stripAndAccumulateConstantOffsets(\n      const DataLayout &DL, APInt &Offset, bool AllowNonInbounds,\n      function_ref<bool(Value &Value, APInt &Offset)> ExternalAnalysis =\n          nullptr) const;\n  Value *stripAndAccumulateConstantOffsets(const DataLayout &DL, APInt &Offset,\n                                           bool AllowNonInbounds) {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripAndAccumulateConstantOffsets(\n            DL, Offset, AllowNonInbounds));\n  }\n\n  /// This is a wrapper around stripAndAccumulateConstantOffsets with the\n  /// in-bounds requirement set to false.\n  const Value *stripAndAccumulateInBoundsConstantOffsets(const DataLayout &DL,\n                                                         APInt &Offset) const {\n    return stripAndAccumulateConstantOffsets(DL, Offset,\n                                             /* AllowNonInbounds */ false);\n  }\n  Value *stripAndAccumulateInBoundsConstantOffsets(const DataLayout &DL,\n                                                   APInt &Offset) {\n    return stripAndAccumulateConstantOffsets(DL, Offset,\n                                             /* AllowNonInbounds */ false);\n  }\n\n  /// Strip off pointer casts and inbounds GEPs.\n  ///\n  /// Returns the original pointer value.  If this is called on a non-pointer\n  /// value, it returns 'this'.\n  const Value *stripInBoundsOffsets(function_ref<void(const Value *)> Func =\n                                        [](const Value *) {}) const;\n  inline Value *stripInBoundsOffsets(function_ref<void(const Value *)> Func =\n                                  [](const Value *) {}) {\n    return const_cast<Value *>(\n        static_cast<const Value *>(this)->stripInBoundsOffsets(Func));\n  }\n\n  /// Returns the number of bytes known to be dereferenceable for the\n  /// pointer value.\n  ///\n  /// If CanBeNull is set by this function the pointer can either be null or be\n  /// dereferenceable up to the returned number of bytes.\n  uint64_t getPointerDereferenceableBytes(const DataLayout &DL,\n                                          bool &CanBeNull) const;\n\n  /// Returns an alignment of the pointer value.\n  ///\n  /// Returns an alignment which is either specified explicitly, e.g. via\n  /// align attribute of a function argument, or guaranteed by DataLayout.\n  Align getPointerAlignment(const DataLayout &DL) const;\n\n  /// Translate PHI node to its predecessor from the given basic block.\n  ///\n  /// If this value is a PHI node with CurBB as its parent, return the value in\n  /// the PHI node corresponding to PredBB.  If not, return ourself.  This is\n  /// useful if you want to know the value something has in a predecessor\n  /// block.\n  const Value *DoPHITranslation(const BasicBlock *CurBB,\n                                const BasicBlock *PredBB) const;\n  Value *DoPHITranslation(const BasicBlock *CurBB, const BasicBlock *PredBB) {\n    return const_cast<Value *>(\n             static_cast<const Value *>(this)->DoPHITranslation(CurBB, PredBB));\n  }\n\n  /// The maximum alignment for instructions.\n  ///\n  /// This is the greatest alignment value supported by load, store, and alloca\n  /// instructions, and global values.\n  static const unsigned MaxAlignmentExponent = 29;\n  static const unsigned MaximumAlignment = 1u << MaxAlignmentExponent;\n\n  /// Mutate the type of this Value to be of the specified type.\n  ///\n  /// Note that this is an extremely dangerous operation which can create\n  /// completely invalid IR very easily.  It is strongly recommended that you\n  /// recreate IR objects with the right types instead of mutating them in\n  /// place.\n  void mutateType(Type *Ty) {\n    VTy = Ty;\n  }\n\n  /// Sort the use-list.\n  ///\n  /// Sorts the Value's use-list by Cmp using a stable mergesort.  Cmp is\n  /// expected to compare two \\a Use references.\n  template <class Compare> void sortUseList(Compare Cmp);\n\n  /// Reverse the use-list.\n  void reverseUseList();\n\nprivate:\n  /// Merge two lists together.\n  ///\n  /// Merges \\c L and \\c R using \\c Cmp.  To enable stable sorts, always pushes\n  /// \"equal\" items from L before items from R.\n  ///\n  /// \\return the first element in the list.\n  ///\n  /// \\note Completely ignores \\a Use::Prev (doesn't read, doesn't update).\n  template <class Compare>\n  static Use *mergeUseLists(Use *L, Use *R, Compare Cmp) {\n    Use *Merged;\n    Use **Next = &Merged;\n\n    while (true) {\n      if (!L) {\n        *Next = R;\n        break;\n      }\n      if (!R) {\n        *Next = L;\n        break;\n      }\n      if (Cmp(*R, *L)) {\n        *Next = R;\n        Next = &R->Next;\n        R = R->Next;\n      } else {\n        *Next = L;\n        Next = &L->Next;\n        L = L->Next;\n      }\n    }\n\n    return Merged;\n  }\n\nprotected:\n  unsigned short getSubclassDataFromValue() const { return SubclassData; }\n  void setValueSubclassData(unsigned short D) { SubclassData = D; }\n};\n\nstruct ValueDeleter { void operator()(Value *V) { V->deleteValue(); } };\n\n/// Use this instead of std::unique_ptr<Value> or std::unique_ptr<Instruction>.\n/// Those don't work because Value and Instruction's destructors are protected,\n/// aren't virtual, and won't destroy the complete object.\nusing unique_value = std::unique_ptr<Value, ValueDeleter>;\n\ninline raw_ostream &operator<<(raw_ostream &OS, const Value &V) {\n  V.print(OS);\n  return OS;\n}\n\nvoid Use::set(Value *V) {\n  if (Val) removeFromList();\n  Val = V;\n  if (V) V->addUse(*this);\n}\n\nValue *Use::operator=(Value *RHS) {\n  set(RHS);\n  return RHS;\n}\n\nconst Use &Use::operator=(const Use &RHS) {\n  set(RHS.Val);\n  return *this;\n}\n\ntemplate <class Compare> void Value::sortUseList(Compare Cmp) {\n  if (!UseList || !UseList->Next)\n    // No need to sort 0 or 1 uses.\n    return;\n\n  // Note: this function completely ignores Prev pointers until the end when\n  // they're fixed en masse.\n\n  // Create a binomial vector of sorted lists, visiting uses one at a time and\n  // merging lists as necessary.\n  const unsigned MaxSlots = 32;\n  Use *Slots[MaxSlots];\n\n  // Collect the first use, turning it into a single-item list.\n  Use *Next = UseList->Next;\n  UseList->Next = nullptr;\n  unsigned NumSlots = 1;\n  Slots[0] = UseList;\n\n  // Collect all but the last use.\n  while (Next->Next) {\n    Use *Current = Next;\n    Next = Current->Next;\n\n    // Turn Current into a single-item list.\n    Current->Next = nullptr;\n\n    // Save Current in the first available slot, merging on collisions.\n    unsigned I;\n    for (I = 0; I < NumSlots; ++I) {\n      if (!Slots[I])\n        break;\n\n      // Merge two lists, doubling the size of Current and emptying slot I.\n      //\n      // Since the uses in Slots[I] originally preceded those in Current, send\n      // Slots[I] in as the left parameter to maintain a stable sort.\n      Current = mergeUseLists(Slots[I], Current, Cmp);\n      Slots[I] = nullptr;\n    }\n    // Check if this is a new slot.\n    if (I == NumSlots) {\n      ++NumSlots;\n      assert(NumSlots <= MaxSlots && \"Use list bigger than 2^32\");\n    }\n\n    // Found an open slot.\n    Slots[I] = Current;\n  }\n\n  // Merge all the lists together.\n  assert(Next && \"Expected one more Use\");\n  assert(!Next->Next && \"Expected only one Use\");\n  UseList = Next;\n  for (unsigned I = 0; I < NumSlots; ++I)\n    if (Slots[I])\n      // Since the uses in Slots[I] originally preceded those in UseList, send\n      // Slots[I] in as the left parameter to maintain a stable sort.\n      UseList = mergeUseLists(Slots[I], UseList, Cmp);\n\n  // Fix the Prev pointers.\n  for (Use *I = UseList, **Prev = &UseList; I; I = I->Next) {\n    I->Prev = Prev;\n    Prev = &I->Next;\n  }\n}\n\n// isa - Provide some specializations of isa so that we don't have to include\n// the subtype header files to test to see if the value is a subclass...\n//\ntemplate <> struct isa_impl<Constant, Value> {\n  static inline bool doit(const Value &Val) {\n    static_assert(Value::ConstantFirstVal == 0, \"Val.getValueID() >= Value::ConstantFirstVal\");\n    return Val.getValueID() <= Value::ConstantLastVal;\n  }\n};\n\ntemplate <> struct isa_impl<ConstantData, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() >= Value::ConstantDataFirstVal &&\n           Val.getValueID() <= Value::ConstantDataLastVal;\n  }\n};\n\ntemplate <> struct isa_impl<ConstantAggregate, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() >= Value::ConstantAggregateFirstVal &&\n           Val.getValueID() <= Value::ConstantAggregateLastVal;\n  }\n};\n\ntemplate <> struct isa_impl<Argument, Value> {\n  static inline bool doit (const Value &Val) {\n    return Val.getValueID() == Value::ArgumentVal;\n  }\n};\n\ntemplate <> struct isa_impl<InlineAsm, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::InlineAsmVal;\n  }\n};\n\ntemplate <> struct isa_impl<Instruction, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() >= Value::InstructionVal;\n  }\n};\n\ntemplate <> struct isa_impl<BasicBlock, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::BasicBlockVal;\n  }\n};\n\ntemplate <> struct isa_impl<Function, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::FunctionVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalVariable, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::GlobalVariableVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalAlias, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::GlobalAliasVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalIFunc, Value> {\n  static inline bool doit(const Value &Val) {\n    return Val.getValueID() == Value::GlobalIFuncVal;\n  }\n};\n\ntemplate <> struct isa_impl<GlobalIndirectSymbol, Value> {\n  static inline bool doit(const Value &Val) {\n    return isa<GlobalAlias>(Val) || isa<GlobalIFunc>(Val);\n  }\n};\n\ntemplate <> struct isa_impl<GlobalValue, Value> {\n  static inline bool doit(const Value &Val) {\n    return isa<GlobalObject>(Val) || isa<GlobalIndirectSymbol>(Val);\n  }\n};\n\ntemplate <> struct isa_impl<GlobalObject, Value> {\n  static inline bool doit(const Value &Val) {\n    return isa<GlobalVariable>(Val) || isa<Function>(Val);\n  }\n};\n\n// Create wrappers for C Binding types (see CBindingWrapping.h).\nDEFINE_ISA_CONVERSION_FUNCTIONS(Value, LLVMValueRef)\n\n// Specialized opaque value conversions.\ninline Value **unwrap(LLVMValueRef *Vals) {\n  return reinterpret_cast<Value**>(Vals);\n}\n\ntemplate<typename T>\ninline T **unwrap(LLVMValueRef *Vals, unsigned Length) {\n#ifndef NDEBUG\n  for (LLVMValueRef *I = Vals, *E = Vals + Length; I != E; ++I)\n    unwrap<T>(*I); // For side effect of calling assert on invalid usage.\n#endif\n  (void)Length;\n  return reinterpret_cast<T**>(Vals);\n}\n\ninline LLVMValueRef *wrap(const Value **Vals) {\n  return reinterpret_cast<LLVMValueRef*>(const_cast<Value**>(Vals));\n}\n\n} // end namespace llvm\n\n#endif // LLVM_IR_VALUE_H\n"}, "89": {"id": 89, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CachePruning.h", "content": "//=- CachePruning.h - Helper to manage the pruning of a cache dir -*- C++ -*-=//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements pruning of a directory intended for cache storage, using\n// various policies.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_CACHEPRUNING_H\n#define LLVM_SUPPORT_CACHEPRUNING_H\n\n#include \"llvm/ADT/Optional.h\"\n#include <chrono>\n\nnamespace llvm {\n\ntemplate <typename T> class Expected;\nclass StringRef;\n\n/// Policy for the pruneCache() function. A default constructed\n/// CachePruningPolicy provides a reasonable default policy.\nstruct CachePruningPolicy {\n  /// The pruning interval. This is intended to be used to avoid scanning the\n  /// directory too often. It does not impact the decision of which file to\n  /// prune. A value of 0 forces the scan to occur. A value of None disables\n  /// pruning.\n  llvm::Optional<std::chrono::seconds> Interval = std::chrono::seconds(1200);\n\n  /// The expiration for a file. When a file hasn't been accessed for Expiration\n  /// seconds, it is removed from the cache. A value of 0 disables the\n  /// expiration-based pruning.\n  std::chrono::seconds Expiration = std::chrono::hours(7 * 24); // 1w\n\n  /// The maximum size for the cache directory, in terms of percentage of the\n  /// available space on the disk. Set to 100 to indicate no limit, 50 to\n  /// indicate that the cache size will not be left over half the available disk\n  /// space. A value over 100 will be reduced to 100. A value of 0 disables the\n  /// percentage size-based pruning.\n  unsigned MaxSizePercentageOfAvailableSpace = 75;\n\n  /// The maximum size for the cache directory in bytes. A value over the amount\n  /// of available space on the disk will be reduced to the amount of available\n  /// space. A value of 0 disables the absolute size-based pruning.\n  uint64_t MaxSizeBytes = 0;\n\n  /// The maximum number of files in the cache directory. A value of 0 disables\n  /// the number of files based pruning.\n  ///\n  /// This defaults to 1000000 because with that many files there are\n  /// diminishing returns on the effectiveness of the cache. Some systems have a\n  /// limit on total number of files, and some also limit the number of files\n  /// per directory, such as Linux ext4, with the default setting (block size is\n  /// 4096 and large_dir disabled), there is a per-directory entry limit of\n  /// 508*510*floor(4096/(40+8))~=20M for average filename length of 40.\n  uint64_t MaxSizeFiles = 1000000;\n};\n\n/// Parse the given string as a cache pruning policy. Defaults are taken from a\n/// default constructed CachePruningPolicy object.\n/// For example: \"prune_interval=30s:prune_after=24h:cache_size=50%\"\n/// which means a pruning interval of 30 seconds, expiration time of 24 hours\n/// and maximum cache size of 50% of available disk space.\nExpected<CachePruningPolicy> parseCachePruningPolicy(StringRef PolicyStr);\n\n/// Peform pruning using the supplied policy, returns true if pruning\n/// occurred, i.e. if Policy.Interval was expired.\n///\n/// As a safeguard against data loss if the user specifies the wrong directory\n/// as their cache directory, this function will ignore files not matching the\n/// pattern \"llvmcache-*\".\nbool pruneCache(StringRef Path, CachePruningPolicy Policy);\n\n} // namespace llvm\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 0, "line": 81}, "message": "'VersionDefinition' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/Config.h", "reportHash": "3446178efe7eb22429e7f33db86504e4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 91}, "message": "'Configuration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/Config.h", "reportHash": "288d1bebe3870d95aa8cb197e84bb1f0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 1, "line": 57}, "message": "'InputFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/InputFiles.h", "reportHash": "8b37694a9508d0c8551f85c8c6a4cdbf", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 1, "line": 161}, "message": "'ELFFileBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/InputFiles.h", "reportHash": "2d059e5f644db70eab3f30fcc56bd587", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 1, "line": 325}, "message": "'ArchiveFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/InputFiles.h", "reportHash": "ff4b2880f8f151ef4c200ef6aab9cc73", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 1, "line": 351}, "message": "'BitcodeFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/InputFiles.h", "reportHash": "961d7eda143cb71b4178a8c66e06751f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 1, "line": 361}, "message": "'SharedFile' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/InputFiles.h", "reportHash": "abd52fa96b5d16ea9ff151bbaf193e88", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 2, "line": 40}, "message": "'SectionBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/InputSection.h", "reportHash": "edf15d3f2a59b2a83f7036056289a5b8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 2, "line": 104}, "message": "'InputSectionBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/InputSection.h", "reportHash": "bd49e54ac018552f9e0e4251b5ccb1af", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 2, "line": 270}, "message": "'MergeInputSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/InputSection.h", "reportHash": "10c3c946d2a18fada517fc0ae038faf6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 2, "line": 329}, "message": "'EhInputSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/InputSection.h", "reportHash": "e0cc8cddbdd150440a49892877ed729b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 2, "line": 349}, "message": "'InputSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/InputSection.h", "reportHash": "b5104de2525997aa4ba9050cf3e5d6a9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 41}, "message": "'ExprValue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/LinkerScript.h", "reportHash": "893c063dbb8eb0cfab845d9c10e33cb1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 85}, "message": "'BaseCommand' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/LinkerScript.h", "reportHash": "283e7f4ebf3d69f64e53486097f6aeee", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 91}, "message": "'SymbolAssignment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/LinkerScript.h", "reportHash": "c30a4ad91d793afb962d033c4740f50b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 133}, "message": "'MemoryRegion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/LinkerScript.h", "reportHash": "b68ce74b0b2214c25564f3b4a78a1150", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 150}, "message": "'SectionPattern' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/LinkerScript.h", "reportHash": "c1bb3c825f2eae712b572c0266a06ecb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 169}, "message": "'InputSectionDescription' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/LinkerScript.h", "reportHash": "633a11b38b97089fad9ed27b971d6210", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 210}, "message": "'ByteCommand' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/LinkerScript.h", "reportHash": "3d74cf435f5965d5fb30d3d40764fada", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 235}, "message": "'PhdrsCommand' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/LinkerScript.h", "reportHash": "83b4ed47411c0d4787b211d2a1d82fcb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 3, "line": 244}, "message": "'LinkerScript' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/LinkerScript.h", "reportHash": "65f5efe4cd80c5fee809b78d6b1d4569", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 4, "line": 32}, "message": "'OutputSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/OutputSections.h", "reportHash": "19736b071abff6fa23878562a0d05613", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 5, "line": 137}, "message": "'ThunkCreator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/Relocations.h", "reportHash": "22ae4f91e6f832d1f1f29bd213072a90", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 6, "line": 34}, "message": "'SymbolTable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SymbolTable.h", "reportHash": "c9ca2567d780ec9ca94f50f5dc652bd5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 7, "line": 58}, "message": "'Symbol' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/Symbols.h", "reportHash": "6206d7447ef369a3472aec38e61575fb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 7, "line": 408}, "message": "'LazyArchive' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/Symbols.h", "reportHash": "20034c5a31f67f8e99813968a88b05f3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 30, "file": 7, "line": 489}, "message": "'AssertSymbol' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/Symbols.h", "reportHash": "68536ac94508e5ad0f5085d24ae5760c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 8, "line": 62}, "message": "'CieRecord' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "b82c7116f9df04638d214c82ed289d72", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 68}, "message": "'EhFrameSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "d0e9f4b45a6ba1ed9f0c22bb92777291", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 124}, "message": "'GotSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "2e6fc6335b2a7d4c14ed572390f4ca56", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 152}, "message": "'GnuStackSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "48f64886b2bd44c309f646732a2e0c71", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 160}, "message": "'GnuPropertySection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "3fb48967fc0a76fd86f0b26d2defc687", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 168}, "message": "'BuildIdSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "e5589e6ab53aee591d438be7c7d21f21", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 187}, "message": "'BssSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "0b0eaf8257ad8c27cf0e95f9a767309b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 200}, "message": "'MipsGotSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "011ff88cbe9f1bd993e8ff43febf8bce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 377}, "message": "'GotPltSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "2c9fa4fe9409d11a91dcb341135e0c57", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 397}, "message": "'IgotPltSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "1bb1b9d8c9419b34afd594847fe2661c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 409}, "message": "'StringTableSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "e1900e75c12919a945e906921ce4e503", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 487}, "message": "'RelocationBaseSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "25bfba99494d20d9f367c8e254ebbcb8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 548}, "message": "'RelrBaseSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "1d07043fc804b58ccc41ae3e8975b5f6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 580}, "message": "'SymbolTableBaseSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "8c3b72abe2431810cea8984f7b42929c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 612}, "message": "'SymtabShndxSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "2e2ad1925c6bb178b545feae71bf85be", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 624}, "message": "'GnuHashTableSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "7d4cfb667bbd3be55da7e7c90ffac19e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 655}, "message": "'HashTableSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "a301af5fd3330addd8abf6fecd1da983", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 677}, "message": "'PltSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "28c9ba8368da075b7651d9026a880296", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 696}, "message": "'IpltSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "b6c9a5ec65ce07c5f37cfa57742f5317", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 708}, "message": "'PPC32GlinkSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "ff6b9731fab4b9d73454e3868b3910da", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 719}, "message": "'IBTPltSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "ab7f0248eb3ffb49d16598f3c1661233", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 726}, "message": "'GdbIndexSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "d8bf31c232901a6ac0f5de110eecef98", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 8, "line": 745}, "message": "'GdbChunk' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "7240c4fa507f0e723ae05b1512a022f2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 8, "line": 751}, "message": "'GdbSymbol' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "d585e1d5ac10c0b90e97f8ef128338d1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 796}, "message": "'EhFrameHeader' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "389d7a672a4bb3bec49ed7b49d02821c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 813}, "message": "'VersionDefinitionSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "97bc1b581aedca4fc25e03c068d73627", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 835}, "message": "'VersionTableSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "2fd39673b5e68b892da6a893d09616a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 879}, "message": "'MergeSyntheticSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "dba953720114515259fe58107e911d21", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 890}, "message": "'MergeTailSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "59ca7a9600f16b260100bda2b91c9421", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 903}, "message": "'MergeNoTailSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "a50673ee901e94ba40e91dd286fbca67", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 987}, "message": "'MipsRldMapSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "3d35b20686a33a31b76d69ea29ff5bd9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 1028}, "message": "'ARMExidxSyntheticSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "5318298d707059c6c5dc6ab7bec9c210", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 1067}, "message": "'ThunkSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "002a9d08ee1821f96645b8a4c77d9a4f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 1093}, "message": "'PPC32Got2Section' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "e1a2fe68a58c89fbae37f8c7f3e44c57", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 1107}, "message": "'PPC64LongBranchTargetSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "91b21a0003d80910670074d29c334eea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 1139}, "message": "'PartitionIndexSection' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "91d788dbf64bb18504cc645f4b052a23", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 8, "line": 1162}, "message": "'Partition' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lld/ELF/SyntheticSections.h", "reportHash": "e8d960c911524fd1059afd43425c8105", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 34, "line": 84}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 34, "line": 84}, "message": "'TinyPtrVector' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/TinyPtrVector.h", "reportHash": "babac0b054b333d5192af8ce3b9cff3b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 34, "file": 66, "line": 51}, "message": "'StringMapEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Value.h", "reportHash": "df854fe6f67f8f8c6397c09ebc74acf8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 89, "line": 27}, "message": "'CachePruningPolicy' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CachePruning.h", "reportHash": "9659bacf6cf126ff3e46e9673ddc19b1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
