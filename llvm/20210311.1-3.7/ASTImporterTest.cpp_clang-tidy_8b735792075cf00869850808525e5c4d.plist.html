<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTImporter.h", "content": "//===- ASTImporter.h - Importing ASTs from other Contexts -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the ASTImporter class which imports AST nodes from one\n//  context into another context.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_ASTIMPORTER_H\n#define LLVM_CLANG_AST_ASTIMPORTER_H\n\n#include \"clang/AST/APValue.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/TemplateName.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Error.h\"\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass ASTImporterSharedState;\nclass Attr;\nclass CXXBaseSpecifier;\nclass CXXCtorInitializer;\nclass Decl;\nclass DeclContext;\nclass Expr;\nclass FileManager;\nclass NamedDecl;\nclass Stmt;\nclass TagDecl;\nclass TranslationUnitDecl;\nclass TypeSourceInfo;\n\n  class ImportError : public llvm::ErrorInfo<ImportError> {\n  public:\n    /// \\brief Kind of error when importing an AST component.\n    enum ErrorKind {\n        NameConflict, /// Naming ambiguity (likely ODR violation).\n        UnsupportedConstruct, /// Not supported node or case.\n        Unknown /// Other error.\n    };\n\n    ErrorKind Error;\n\n    static char ID;\n\n    ImportError() : Error(Unknown) {}\n    ImportError(const ImportError &Other) : Error(Other.Error) {}\n    ImportError &operator=(const ImportError &Other) {\n      Error = Other.Error;\n      return *this;\n    }\n    ImportError(ErrorKind Error) : Error(Error) { }\n\n    std::string toString() const;\n\n    void log(raw_ostream &OS) const override;\n    std::error_code convertToErrorCode() const override;\n  };\n\n  // \\brief Returns with a list of declarations started from the canonical decl\n  // then followed by subsequent decls in the translation unit.\n  // This gives a canonical list for each entry in the redecl chain.\n  // `Decl::redecls()` gives a list of decls which always start from the\n  // previous decl and the next item is actually the previous item in the order\n  // of source locations.  Thus, `Decl::redecls()` gives different lists for\n  // the different entries in a given redecl chain.\n  llvm::SmallVector<Decl*, 2> getCanonicalForwardRedeclChain(Decl* D);\n\n  /// Imports selected nodes from one AST context into another context,\n  /// merging AST nodes where appropriate.\n  class ASTImporter {\n    friend class ASTNodeImporter;\n  public:\n    using NonEquivalentDeclSet = llvm::DenseSet<std::pair<Decl *, Decl *>>;\n    using ImportedCXXBaseSpecifierMap =\n        llvm::DenseMap<const CXXBaseSpecifier *, CXXBaseSpecifier *>;\n\n    enum class ODRHandlingType { Conservative, Liberal };\n\n    // An ImportPath is the list of the AST nodes which we visit during an\n    // Import call.\n    // If node `A` depends on node `B` then the path contains an `A`->`B` edge.\n    // From the call stack of the import functions we can read the very same\n    // path.\n    //\n    // Now imagine the following AST, where the `->` represents dependency in\n    // therms of the import.\n    // ```\n    // A->B->C->D\n    //    `->E\n    // ```\n    // We would like to import A.\n    // The import behaves like a DFS, so we will visit the nodes in this order:\n    // ABCDE.\n    // During the visitation we will have the following ImportPaths:\n    // ```\n    // A\n    // AB\n    // ABC\n    // ABCD\n    // ABC\n    // AB\n    // ABE\n    // AB\n    // A\n    // ```\n    // If during the visit of E there is an error then we set an error for E,\n    // then as the call stack shrinks for B, then for A:\n    // ```\n    // A\n    // AB\n    // ABC\n    // ABCD\n    // ABC\n    // AB\n    // ABE // Error! Set an error to E\n    // AB  // Set an error to B\n    // A   // Set an error to A\n    // ```\n    // However, during the import we could import C and D without any error and\n    // they are independent from A,B and E.\n    // We must not set up an error for C and D.\n    // So, at the end of the import we have an entry in `ImportDeclErrors` for\n    // A,B,E but not for C,D.\n    //\n    // Now what happens if there is a cycle in the import path?\n    // Let's consider this AST:\n    // ```\n    // A->B->C->A\n    //    `->E\n    // ```\n    // During the visitation we will have the below ImportPaths and if during\n    // the visit of E there is an error then we will set up an error for E,B,A.\n    // But what's up with C?\n    // ```\n    // A\n    // AB\n    // ABC\n    // ABCA\n    // ABC\n    // AB\n    // ABE // Error! Set an error to E\n    // AB  // Set an error to B\n    // A   // Set an error to A\n    // ```\n    // This time we know that both B and C are dependent on A.\n    // This means we must set up an error for C too.\n    // As the call stack reverses back we get to A and we must set up an error\n    // to all nodes which depend on A (this includes C).\n    // But C is no longer on the import path, it just had been previously.\n    // Such situation can happen only if during the visitation we had a cycle.\n    // If we didn't have any cycle, then the normal way of passing an Error\n    // object through the call stack could handle the situation.\n    // This is why we must track cycles during the import process for each\n    // visited declaration.\n    class ImportPathTy {\n    public:\n      using VecTy = llvm::SmallVector<Decl *, 32>;\n\n      void push(Decl *D) {\n        Nodes.push_back(D);\n        ++Aux[D];\n      }\n\n      void pop() {\n        if (Nodes.empty())\n          return;\n        --Aux[Nodes.back()];\n        Nodes.pop_back();\n      }\n\n      /// Returns true if the last element can be found earlier in the path.\n      bool hasCycleAtBack() const {\n        auto Pos = Aux.find(Nodes.back());\n        return Pos != Aux.end() && Pos->second > 1;\n      }\n\n      using Cycle = llvm::iterator_range<VecTy::const_reverse_iterator>;\n      Cycle getCycleAtBack() const {\n        assert(Nodes.size() >= 2);\n        return Cycle(Nodes.rbegin(),\n                     std::find(Nodes.rbegin() + 1, Nodes.rend(), Nodes.back()) +\n                         1);\n      }\n\n      /// Returns the copy of the cycle.\n      VecTy copyCycleAtBack() const {\n        auto R = getCycleAtBack();\n        return VecTy(R.begin(), R.end());\n      }\n\n    private:\n      // All nodes of the path.\n      VecTy Nodes;\n      // Auxiliary container to be able to answer \"Do we have a cycle ending\n      // at last element?\" as fast as possible.\n      // We count each Decl's occurrence over the path.\n      llvm::SmallDenseMap<Decl *, int, 32> Aux;\n    };\n\n  private:\n    std::shared_ptr<ASTImporterSharedState> SharedState = nullptr;\n\n    /// The path which we go through during the import of a given AST node.\n    ImportPathTy ImportPath;\n    /// Sometimes we have to save some part of an import path, so later we can\n    /// set up properties to the saved nodes.\n    /// We may have several of these import paths associated to one Decl.\n    using SavedImportPathsForOneDecl =\n        llvm::SmallVector<ImportPathTy::VecTy, 32>;\n    using SavedImportPathsTy =\n        llvm::SmallDenseMap<Decl *, SavedImportPathsForOneDecl, 32>;\n    SavedImportPathsTy SavedImportPaths;\n\n    /// The contexts we're importing to and from.\n    ASTContext &ToContext, &FromContext;\n\n    /// The file managers we're importing to and from.\n    FileManager &ToFileManager, &FromFileManager;\n\n    /// Whether to perform a minimal import.\n    bool Minimal;\n\n    ODRHandlingType ODRHandling;\n\n    /// Whether the last diagnostic came from the \"from\" context.\n    bool LastDiagFromFrom = false;\n\n    /// Mapping from the already-imported types in the \"from\" context\n    /// to the corresponding types in the \"to\" context.\n    llvm::DenseMap<const Type *, const Type *> ImportedTypes;\n\n    /// Mapping from the already-imported declarations in the \"from\"\n    /// context to the corresponding declarations in the \"to\" context.\n    llvm::DenseMap<Decl *, Decl *> ImportedDecls;\n\n    /// Mapping from the already-imported declarations in the \"from\"\n    /// context to the error status of the import of that declaration.\n    /// This map contains only the declarations that were not correctly\n    /// imported. The same declaration may or may not be included in\n    /// ImportedDecls. This map is updated continuously during imports and never\n    /// cleared (like ImportedDecls).\n    llvm::DenseMap<Decl *, ImportError> ImportDeclErrors;\n\n    /// Mapping from the already-imported declarations in the \"to\"\n    /// context to the corresponding declarations in the \"from\" context.\n    llvm::DenseMap<Decl *, Decl *> ImportedFromDecls;\n\n    /// Mapping from the already-imported statements in the \"from\"\n    /// context to the corresponding statements in the \"to\" context.\n    llvm::DenseMap<Stmt *, Stmt *> ImportedStmts;\n\n    /// Mapping from the already-imported FileIDs in the \"from\" source\n    /// manager to the corresponding FileIDs in the \"to\" source manager.\n    llvm::DenseMap<FileID, FileID> ImportedFileIDs;\n\n    /// Mapping from the already-imported CXXBasesSpecifier in\n    ///  the \"from\" source manager to the corresponding CXXBasesSpecifier\n    ///  in the \"to\" source manager.\n    ImportedCXXBaseSpecifierMap ImportedCXXBaseSpecifiers;\n\n    /// Declaration (from, to) pairs that are known not to be equivalent\n    /// (which we have already complained about).\n    NonEquivalentDeclSet NonEquivalentDecls;\n\n    using FoundDeclsTy = SmallVector<NamedDecl *, 2>;\n    FoundDeclsTy findDeclsInToCtx(DeclContext *DC, DeclarationName Name);\n\n    void AddToLookupTable(Decl *ToD);\n\n  protected:\n    /// Can be overwritten by subclasses to implement their own import logic.\n    /// The overwritten method should call this method if it didn't import the\n    /// decl on its own.\n    virtual Expected<Decl *> ImportImpl(Decl *From);\n\n    /// Used only in unittests to verify the behaviour of the error handling.\n    virtual bool returnWithErrorInTest() { return false; };\n\n  public:\n\n    /// \\param ToContext The context we'll be importing into.\n    ///\n    /// \\param ToFileManager The file manager we'll be importing into.\n    ///\n    /// \\param FromContext The context we'll be importing from.\n    ///\n    /// \\param FromFileManager The file manager we'll be importing into.\n    ///\n    /// \\param MinimalImport If true, the importer will attempt to import\n    /// as little as it can, e.g., by importing declarations as forward\n    /// declarations that can be completed at a later point.\n    ///\n    /// \\param SharedState The importer specific lookup table which may be\n    /// shared amongst several ASTImporter objects.\n    /// If not set then the original C/C++ lookup is used.\n    ASTImporter(ASTContext &ToContext, FileManager &ToFileManager,\n                ASTContext &FromContext, FileManager &FromFileManager,\n                bool MinimalImport,\n                std::shared_ptr<ASTImporterSharedState> SharedState = nullptr);\n\n    virtual ~ASTImporter();\n\n    /// Whether the importer will perform a minimal import, creating\n    /// to-be-completed forward declarations when possible.\n    bool isMinimalImport() const { return Minimal; }\n\n    void setODRHandling(ODRHandlingType T) { ODRHandling = T; }\n\n    /// \\brief Import the given object, returns the result.\n    ///\n    /// \\param To Import the object into this variable.\n    /// \\param From Object to import.\n    /// \\return Error information (success or error).\n    template <typename ImportT>\n    LLVM_NODISCARD llvm::Error importInto(ImportT &To, const ImportT &From) {\n      auto ToOrErr = Import(From);\n      if (ToOrErr)\n        To = *ToOrErr;\n      return ToOrErr.takeError();\n    }\n\n    /// Import cleanup objects owned by ExprWithCleanup.\n    llvm::Expected<ExprWithCleanups::CleanupObject>\n    Import(ExprWithCleanups::CleanupObject From);\n\n    /// Import the given type from the \"from\" context into the \"to\"\n    /// context. A null type is imported as a null type (no error).\n    ///\n    /// \\returns The equivalent type in the \"to\" context, or the import error.\n    llvm::Expected<QualType> Import(QualType FromT);\n\n    /// Import the given type source information from the\n    /// \"from\" context into the \"to\" context.\n    ///\n    /// \\returns The equivalent type source information in the \"to\"\n    /// context, or the import error.\n    llvm::Expected<TypeSourceInfo *> Import(TypeSourceInfo *FromTSI);\n\n    /// Import the given attribute from the \"from\" context into the\n    /// \"to\" context.\n    ///\n    /// \\returns The equivalent attribute in the \"to\" context, or the import\n    /// error.\n    llvm::Expected<Attr *> Import(const Attr *FromAttr);\n\n    /// Import the given declaration from the \"from\" context into the\n    /// \"to\" context.\n    ///\n    /// \\returns The equivalent declaration in the \"to\" context, or the import\n    /// error.\n    llvm::Expected<Decl *> Import(Decl *FromD);\n    llvm::Expected<const Decl *> Import(const Decl *FromD) {\n      return Import(const_cast<Decl *>(FromD));\n    }\n\n    /// Return the copy of the given declaration in the \"to\" context if\n    /// it has already been imported from the \"from\" context.  Otherwise return\n    /// nullptr.\n    Decl *GetAlreadyImportedOrNull(const Decl *FromD) const;\n\n    /// Return the translation unit from where the declaration was\n    /// imported. If it does not exist nullptr is returned.\n    TranslationUnitDecl *GetFromTU(Decl *ToD);\n\n    /// Return the declaration in the \"from\" context from which the declaration\n    /// in the \"to\" context was imported. If it was not imported or of the wrong\n    /// type a null value is returned.\n    template <typename DeclT>\n    llvm::Optional<DeclT *> getImportedFromDecl(const DeclT *ToD) const {\n      auto FromI = ImportedFromDecls.find(ToD);\n      if (FromI == ImportedFromDecls.end())\n        return {};\n      auto *FromD = dyn_cast<DeclT>(FromI->second);\n      if (!FromD)\n        return {};\n      return FromD;\n    }\n\n    /// Import the given declaration context from the \"from\"\n    /// AST context into the \"to\" AST context.\n    ///\n    /// \\returns the equivalent declaration context in the \"to\"\n    /// context, or error value.\n    llvm::Expected<DeclContext *> ImportContext(DeclContext *FromDC);\n\n    /// Import the given expression from the \"from\" context into the\n    /// \"to\" context.\n    ///\n    /// \\returns The equivalent expression in the \"to\" context, or the import\n    /// error.\n    llvm::Expected<Expr *> Import(Expr *FromE);\n\n    /// Import the given statement from the \"from\" context into the\n    /// \"to\" context.\n    ///\n    /// \\returns The equivalent statement in the \"to\" context, or the import\n    /// error.\n    llvm::Expected<Stmt *> Import(Stmt *FromS);\n\n    /// Import the given nested-name-specifier from the \"from\"\n    /// context into the \"to\" context.\n    ///\n    /// \\returns The equivalent nested-name-specifier in the \"to\"\n    /// context, or the import error.\n    llvm::Expected<NestedNameSpecifier *> Import(NestedNameSpecifier *FromNNS);\n\n    /// Import the given nested-name-specifier-loc from the \"from\"\n    /// context into the \"to\" context.\n    ///\n    /// \\returns The equivalent nested-name-specifier-loc in the \"to\"\n    /// context, or the import error.\n    llvm::Expected<NestedNameSpecifierLoc>\n    Import(NestedNameSpecifierLoc FromNNS);\n\n    /// Import the given template name from the \"from\" context into the\n    /// \"to\" context, or the import error.\n    llvm::Expected<TemplateName> Import(TemplateName From);\n\n    /// Import the given source location from the \"from\" context into\n    /// the \"to\" context.\n    ///\n    /// \\returns The equivalent source location in the \"to\" context, or the\n    /// import error.\n    llvm::Expected<SourceLocation> Import(SourceLocation FromLoc);\n\n    /// Import the given source range from the \"from\" context into\n    /// the \"to\" context.\n    ///\n    /// \\returns The equivalent source range in the \"to\" context, or the import\n    /// error.\n    llvm::Expected<SourceRange> Import(SourceRange FromRange);\n\n    /// Import the given declaration name from the \"from\"\n    /// context into the \"to\" context.\n    ///\n    /// \\returns The equivalent declaration name in the \"to\" context, or the\n    /// import error.\n    llvm::Expected<DeclarationName> Import(DeclarationName FromName);\n\n    /// Import the given identifier from the \"from\" context\n    /// into the \"to\" context.\n    ///\n    /// \\returns The equivalent identifier in the \"to\" context. Note: It\n    /// returns nullptr only if the FromId was nullptr.\n    IdentifierInfo *Import(const IdentifierInfo *FromId);\n\n    /// Import the given Objective-C selector from the \"from\"\n    /// context into the \"to\" context.\n    ///\n    /// \\returns The equivalent selector in the \"to\" context, or the import\n    /// error.\n    llvm::Expected<Selector> Import(Selector FromSel);\n\n    /// Import the given file ID from the \"from\" context into the\n    /// \"to\" context.\n    ///\n    /// \\returns The equivalent file ID in the source manager of the \"to\"\n    /// context, or the import error.\n    llvm::Expected<FileID> Import(FileID, bool IsBuiltin = false);\n\n    /// Import the given C++ constructor initializer from the \"from\"\n    /// context into the \"to\" context.\n    ///\n    /// \\returns The equivalent initializer in the \"to\" context, or the import\n    /// error.\n    llvm::Expected<CXXCtorInitializer *> Import(CXXCtorInitializer *FromInit);\n\n    /// Import the given CXXBaseSpecifier from the \"from\" context into\n    /// the \"to\" context.\n    ///\n    /// \\returns The equivalent CXXBaseSpecifier in the source manager of the\n    /// \"to\" context, or the import error.\n    llvm::Expected<CXXBaseSpecifier *> Import(const CXXBaseSpecifier *FromSpec);\n\n    /// Import the given APValue from the \"from\" context into\n    /// the \"to\" context.\n    ///\n    /// \\return the equivalent APValue in the \"to\" context or the import\n    /// error.\n    llvm::Expected<APValue> Import(const APValue &FromValue);\n\n    /// Import the definition of the given declaration, including all of\n    /// the declarations it contains.\n    LLVM_NODISCARD llvm::Error ImportDefinition(Decl *From);\n\n    /// Cope with a name conflict when importing a declaration into the\n    /// given context.\n    ///\n    /// This routine is invoked whenever there is a name conflict while\n    /// importing a declaration. The returned name will become the name of the\n    /// imported declaration. By default, the returned name is the same as the\n    /// original name, leaving the conflict unresolve such that name lookup\n    /// for this name is likely to find an ambiguity later.\n    ///\n    /// Subclasses may override this routine to resolve the conflict, e.g., by\n    /// renaming the declaration being imported.\n    ///\n    /// \\param Name the name of the declaration being imported, which conflicts\n    /// with other declarations.\n    ///\n    /// \\param DC the declaration context (in the \"to\" AST context) in which\n    /// the name is being imported.\n    ///\n    /// \\param IDNS the identifier namespace in which the name will be found.\n    ///\n    /// \\param Decls the set of declarations with the same name as the\n    /// declaration being imported.\n    ///\n    /// \\param NumDecls the number of conflicting declarations in \\p Decls.\n    ///\n    /// \\returns the name that the newly-imported declaration should have. Or\n    /// an error if we can't handle the name conflict.\n    virtual Expected<DeclarationName>\n    HandleNameConflict(DeclarationName Name, DeclContext *DC, unsigned IDNS,\n                       NamedDecl **Decls, unsigned NumDecls);\n\n    /// Retrieve the context that AST nodes are being imported into.\n    ASTContext &getToContext() const { return ToContext; }\n\n    /// Retrieve the context that AST nodes are being imported from.\n    ASTContext &getFromContext() const { return FromContext; }\n\n    /// Retrieve the file manager that AST nodes are being imported into.\n    FileManager &getToFileManager() const { return ToFileManager; }\n\n    /// Retrieve the file manager that AST nodes are being imported from.\n    FileManager &getFromFileManager() const { return FromFileManager; }\n\n    /// Report a diagnostic in the \"to\" context.\n    DiagnosticBuilder ToDiag(SourceLocation Loc, unsigned DiagID);\n\n    /// Report a diagnostic in the \"from\" context.\n    DiagnosticBuilder FromDiag(SourceLocation Loc, unsigned DiagID);\n\n    /// Return the set of declarations that we know are not equivalent.\n    NonEquivalentDeclSet &getNonEquivalentDecls() { return NonEquivalentDecls; }\n\n    /// Called for ObjCInterfaceDecl, ObjCProtocolDecl, and TagDecl.\n    /// Mark the Decl as complete, filling it in as much as possible.\n    ///\n    /// \\param D A declaration in the \"to\" context.\n    virtual void CompleteDecl(Decl* D);\n\n    /// Subclasses can override this function to observe all of the \\c From ->\n    /// \\c To declaration mappings as they are imported.\n    virtual void Imported(Decl *From, Decl *To) {}\n\n    void RegisterImportedDecl(Decl *FromD, Decl *ToD);\n\n    /// Store and assign the imported declaration to its counterpart.\n    /// It may happen that several decls from the 'from' context are mapped to\n    /// the same decl in the 'to' context.\n    Decl *MapImported(Decl *From, Decl *To);\n\n    /// Called by StructuralEquivalenceContext.  If a RecordDecl is\n    /// being compared to another RecordDecl as part of import, completing the\n    /// other RecordDecl may trigger importation of the first RecordDecl. This\n    /// happens especially for anonymous structs.  If the original of the second\n    /// RecordDecl can be found, we can complete it without the need for\n    /// importation, eliminating this loop.\n    virtual Decl *GetOriginalDecl(Decl *To) { return nullptr; }\n\n    /// Return if import of the given declaration has failed and if yes\n    /// the kind of the problem. This gives the first error encountered with\n    /// the node.\n    llvm::Optional<ImportError> getImportDeclErrorIfAny(Decl *FromD) const;\n\n    /// Mark (newly) imported declaration with error.\n    void setImportDeclError(Decl *From, ImportError Error);\n\n    /// Determine whether the given types are structurally\n    /// equivalent.\n    bool IsStructurallyEquivalent(QualType From, QualType To,\n                                  bool Complain = true);\n\n    /// Determine the index of a field in its parent record.\n    /// F should be a field (or indirect field) declaration.\n    /// \\returns The index of the field in its parent context (starting from 0).\n    /// On error `None` is returned (parent context is non-record).\n    static llvm::Optional<unsigned> getFieldIndex(Decl *F);\n  };\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_ASTIMPORTER_H\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTImporterLookupTable.h", "content": "//===- ASTImporterLookupTable.h - ASTImporter specific lookup--*- C++ -*---===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the ASTImporterLookupTable class which implements a\n//  lookup procedure for the import mechanism.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_ASTIMPORTERLOOKUPTABLE_H\n#define LLVM_CLANG_AST_ASTIMPORTERLOOKUPTABLE_H\n\n#include \"clang/AST/DeclBase.h\" // lookup_result\n#include \"clang/AST/DeclarationName.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SetVector.h\"\n\nnamespace clang {\n\nclass ASTContext;\nclass NamedDecl;\nclass DeclContext;\n\n// There are certain cases when normal C/C++ lookup (localUncachedLookup)\n// does not find AST nodes. E.g.:\n// Example 1:\n//   template <class T>\n//   struct X {\n//     friend void foo(); // this is never found in the DC of the TU.\n//   };\n// Example 2:\n//   // The fwd decl to Foo is not found in the lookupPtr of the DC of the\n//   // translation unit decl.\n//   // Here we could find the node by doing a traverse throught the list of\n//   // the Decls in the DC, but that would not scale.\n//   struct A { struct Foo *p; };\n// This is a severe problem because the importer decides if it has to create a\n// new Decl or not based on the lookup results.\n// To overcome these cases we need an importer specific lookup table which\n// holds every node and we are not interested in any C/C++ specific visibility\n// considerations. Simply, we must know if there is an existing Decl in a\n// given DC. Once we found it then we can handle any visibility related tasks.\nclass ASTImporterLookupTable {\n\n  // We store a list of declarations for each name.\n  // And we collect these lists for each DeclContext.\n  // We could have a flat map with (DeclContext, Name) tuple as key, but a two\n  // level map seems easier to handle.\n  using DeclList = llvm::SmallSetVector<NamedDecl *, 2>;\n  using NameMap = llvm::SmallDenseMap<DeclarationName, DeclList, 4>;\n  using DCMap = llvm::DenseMap<DeclContext *, NameMap>;\n\n  void add(DeclContext *DC, NamedDecl *ND);\n  void remove(DeclContext *DC, NamedDecl *ND);\n\n  DCMap LookupTable;\n\npublic:\n  ASTImporterLookupTable(TranslationUnitDecl &TU);\n  void add(NamedDecl *ND);\n  void remove(NamedDecl *ND);\n  using LookupResult = DeclList;\n  LookupResult lookup(DeclContext *DC, DeclarationName Name) const;\n  void dump(DeclContext *DC) const;\n  void dump() const;\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_ASTIMPORTERLOOKUPTABLE_H\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "content": "//===- unittest/AST/ASTImporterTest.cpp - AST node import test ------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Tests for the correct import of AST nodes from one AST context to another.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/ASTMatchers/ASTMatchers.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/Support/SmallVectorMemoryBuffer.h\"\n\n#include \"clang/AST/DeclContextInternals.h\"\n#include \"gtest/gtest.h\"\n\n#include \"ASTImporterFixtures.h\"\n\nnamespace clang {\nnamespace ast_matchers {\n\nusing internal::Matcher;\nusing internal::BindableMatcher;\nusing llvm::StringMap;\n\nstatic const RecordDecl *getRecordDeclOfFriend(FriendDecl *FD) {\n  QualType Ty = FD->getFriendType()->getType().getCanonicalType();\n  return cast<RecordType>(Ty)->getDecl();\n}\n\nstruct ImportExpr : TestImportBase {};\nstruct ImportType : TestImportBase {};\nstruct ImportDecl : TestImportBase {};\nstruct ImportFixedPointExpr : ImportExpr {};\n\nstruct CanonicalRedeclChain : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(CanonicalRedeclChain, ShouldBeConsequentWithMatchers) {\n  Decl *FromTU = getTuDecl(\"void f();\", Lang_CXX03);\n  auto Pattern = functionDecl(hasName(\"f\"));\n  auto *D0 = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n\n  auto Redecls = getCanonicalForwardRedeclChain(D0);\n  ASSERT_EQ(Redecls.size(), 1u);\n  EXPECT_EQ(D0, Redecls[0]);\n}\n\nTEST_P(CanonicalRedeclChain, ShouldBeConsequentWithMatchers2) {\n  Decl *FromTU = getTuDecl(\"void f(); void f(); void f();\", Lang_CXX03);\n  auto Pattern = functionDecl(hasName(\"f\"));\n  auto *D0 = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n  auto *D2 = LastDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n  FunctionDecl *D1 = D2->getPreviousDecl();\n\n  auto Redecls = getCanonicalForwardRedeclChain(D0);\n  ASSERT_EQ(Redecls.size(), 3u);\n  EXPECT_EQ(D0, Redecls[0]);\n  EXPECT_EQ(D1, Redecls[1]);\n  EXPECT_EQ(D2, Redecls[2]);\n}\n\nTEST_P(CanonicalRedeclChain, ShouldBeSameForAllDeclInTheChain) {\n  Decl *FromTU = getTuDecl(\"void f(); void f(); void f();\", Lang_CXX03);\n  auto Pattern = functionDecl(hasName(\"f\"));\n  auto *D0 = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n  auto *D2 = LastDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n  FunctionDecl *D1 = D2->getPreviousDecl();\n\n  auto RedeclsD0 = getCanonicalForwardRedeclChain(D0);\n  auto RedeclsD1 = getCanonicalForwardRedeclChain(D1);\n  auto RedeclsD2 = getCanonicalForwardRedeclChain(D2);\n\n  EXPECT_THAT(RedeclsD0, ::testing::ContainerEq(RedeclsD1));\n  EXPECT_THAT(RedeclsD1, ::testing::ContainerEq(RedeclsD2));\n}\n\nnamespace {\nstruct RedirectingImporter : public ASTImporter {\n  using ASTImporter::ASTImporter;\n\nprotected:\n  llvm::Expected<Decl *> ImportImpl(Decl *FromD) override {\n    auto *ND = dyn_cast<NamedDecl>(FromD);\n    if (!ND || ND->getName() != \"shouldNotBeImported\")\n      return ASTImporter::ImportImpl(FromD);\n    for (Decl *D : getToContext().getTranslationUnitDecl()->decls()) {\n      if (auto *ND = dyn_cast<NamedDecl>(D))\n        if (ND->getName() == \"realDecl\") {\n          RegisterImportedDecl(FromD, ND);\n          return ND;\n        }\n    }\n    return ASTImporter::ImportImpl(FromD);\n  }\n};\n\n} // namespace\n\nstruct RedirectingImporterTest : ASTImporterOptionSpecificTestBase {\n  RedirectingImporterTest() {\n    Creator = [](ASTContext &ToContext, FileManager &ToFileManager,\n                 ASTContext &FromContext, FileManager &FromFileManager,\n                 bool MinimalImport,\n                 const std::shared_ptr<ASTImporterSharedState> &SharedState) {\n      return new RedirectingImporter(ToContext, ToFileManager, FromContext,\n                                     FromFileManager, MinimalImport,\n                                     SharedState);\n    };\n  }\n};\n\n// Test that an ASTImporter subclass can intercept an import call.\nTEST_P(RedirectingImporterTest, InterceptImport) {\n  Decl *From, *To;\n  std::tie(From, To) =\n      getImportedDecl(\"class shouldNotBeImported {};\", Lang_CXX03,\n                      \"class realDecl {};\", Lang_CXX03, \"shouldNotBeImported\");\n  auto *Imported = cast<CXXRecordDecl>(To);\n  EXPECT_EQ(Imported->getQualifiedNameAsString(), \"realDecl\");\n\n  // Make sure our importer prevented the importing of the decl.\n  auto *ToTU = Imported->getTranslationUnitDecl();\n  auto Pattern = functionDecl(hasName(\"shouldNotBeImported\"));\n  unsigned count =\n      DeclCounterWithPredicate<CXXRecordDecl>().match(ToTU, Pattern);\n  EXPECT_EQ(0U, count);\n}\n\n// Test that when we indirectly import a declaration the custom ASTImporter\n// is still intercepting the import.\nTEST_P(RedirectingImporterTest, InterceptIndirectImport) {\n  Decl *From, *To;\n  std::tie(From, To) =\n      getImportedDecl(\"class shouldNotBeImported {};\"\n                      \"class F { shouldNotBeImported f; };\",\n                      Lang_CXX03, \"class realDecl {};\", Lang_CXX03, \"F\");\n\n  // Make sure our ASTImporter prevented the importing of the decl.\n  auto *ToTU = To->getTranslationUnitDecl();\n  auto Pattern = functionDecl(hasName(\"shouldNotBeImported\"));\n  unsigned count =\n      DeclCounterWithPredicate<CXXRecordDecl>().match(ToTU, Pattern);\n  EXPECT_EQ(0U, count);\n}\n\nstruct ImportPath : ASTImporterOptionSpecificTestBase {\n  Decl *FromTU;\n  FunctionDecl *D0, *D1, *D2;\n  ImportPath() {\n    FromTU = getTuDecl(\"void f(); void f(); void f();\", Lang_CXX03);\n    auto Pattern = functionDecl(hasName(\"f\"));\n    D0 = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n    D2 = LastDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n    D1 = D2->getPreviousDecl();\n  }\n};\n\nTEST_P(ImportPath, Push) {\n  ASTImporter::ImportPathTy path;\n  path.push(D0);\n  EXPECT_FALSE(path.hasCycleAtBack());\n}\n\nTEST_P(ImportPath, SmallCycle) {\n  ASTImporter::ImportPathTy path;\n  path.push(D0);\n  path.push(D0);\n  EXPECT_TRUE(path.hasCycleAtBack());\n  path.pop();\n  EXPECT_FALSE(path.hasCycleAtBack());\n  path.push(D0);\n  EXPECT_TRUE(path.hasCycleAtBack());\n}\n\nTEST_P(ImportPath, GetSmallCycle) {\n  ASTImporter::ImportPathTy path;\n  path.push(D0);\n  path.push(D0);\n  EXPECT_TRUE(path.hasCycleAtBack());\n  std::array<Decl* ,2> Res;\n  int i = 0;\n  for (Decl *Di : path.getCycleAtBack()) {\n    Res[i++] = Di;\n  }\n  ASSERT_EQ(i, 2);\n  EXPECT_EQ(Res[0], D0);\n  EXPECT_EQ(Res[1], D0);\n}\n\nTEST_P(ImportPath, GetCycle) {\n  ASTImporter::ImportPathTy path;\n  path.push(D0);\n  path.push(D1);\n  path.push(D2);\n  path.push(D0);\n  EXPECT_TRUE(path.hasCycleAtBack());\n  std::array<Decl* ,4> Res;\n  int i = 0;\n  for (Decl *Di : path.getCycleAtBack()) {\n    Res[i++] = Di;\n  }\n  ASSERT_EQ(i, 4);\n  EXPECT_EQ(Res[0], D0);\n  EXPECT_EQ(Res[1], D2);\n  EXPECT_EQ(Res[2], D1);\n  EXPECT_EQ(Res[3], D0);\n}\n\nTEST_P(ImportPath, CycleAfterCycle) {\n  ASTImporter::ImportPathTy path;\n  path.push(D0);\n  path.push(D1);\n  path.push(D0);\n  path.push(D1);\n  path.push(D2);\n  path.push(D0);\n  EXPECT_TRUE(path.hasCycleAtBack());\n  std::array<Decl* ,4> Res;\n  int i = 0;\n  for (Decl *Di : path.getCycleAtBack()) {\n    Res[i++] = Di;\n  }\n  ASSERT_EQ(i, 4);\n  EXPECT_EQ(Res[0], D0);\n  EXPECT_EQ(Res[1], D2);\n  EXPECT_EQ(Res[2], D1);\n  EXPECT_EQ(Res[3], D0);\n\n  path.pop();\n  path.pop();\n  path.pop();\n  EXPECT_TRUE(path.hasCycleAtBack());\n  i = 0;\n  for (Decl *Di : path.getCycleAtBack()) {\n    Res[i++] = Di;\n  }\n  ASSERT_EQ(i, 3);\n  EXPECT_EQ(Res[0], D0);\n  EXPECT_EQ(Res[1], D1);\n  EXPECT_EQ(Res[2], D0);\n\n  path.pop();\n  EXPECT_FALSE(path.hasCycleAtBack());\n}\n\nTEST_P(ImportExpr, ImportStringLiteral) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() { (void)\\\"foo\\\"; }\", Lang_CXX03, \"\",\n             Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(\n                 stringLiteral(hasType(asString(\"const char [4]\"))))));\n  testImport(\"void declToImport() { (void)L\\\"foo\\\"; }\", Lang_CXX03, \"\",\n             Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(\n                 stringLiteral(hasType(asString(\"const wchar_t [4]\"))))));\n  testImport(\"void declToImport() { (void) \\\"foo\\\" \\\"bar\\\"; }\", Lang_CXX03, \"\",\n             Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(\n                 stringLiteral(hasType(asString(\"const char [7]\"))))));\n}\n\nTEST_P(ImportExpr, ImportChooseExpr) {\n  MatchVerifier<Decl> Verifier;\n\n  // This case tests C code that is not condition-dependent and has a true\n  // condition.\n  testImport(\"void declToImport() { (void)__builtin_choose_expr(1, 2, 3); }\",\n             Lang_C99, \"\", Lang_C99, Verifier,\n             functionDecl(hasDescendant(chooseExpr())));\n}\n\nTEST_P(ImportExpr, ImportGNUNullExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() { (void)__null; }\", Lang_CXX03, \"\",\n             Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(gnuNullExpr(hasType(isInteger())))));\n}\n\nTEST_P(ImportExpr, ImportGenericSelectionExpr) {\n  MatchVerifier<Decl> Verifier;\n\n  testImport(\n      \"void declToImport() { int x; (void)_Generic(x, int: 0, float: 1); }\",\n      Lang_C99, \"\", Lang_C99, Verifier,\n      functionDecl(hasDescendant(genericSelectionExpr())));\n}\n\nTEST_P(ImportExpr, ImportCXXNullPtrLiteralExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"void declToImport() { (void)nullptr; }\",\n      Lang_CXX11, \"\", Lang_CXX11, Verifier,\n      functionDecl(hasDescendant(cxxNullPtrLiteralExpr())));\n}\n\n\nTEST_P(ImportExpr, ImportFloatinglLiteralExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() { (void)1.0; }\", Lang_C99, \"\", Lang_C99,\n             Verifier,\n             functionDecl(hasDescendant(\n                 floatLiteral(equals(1.0), hasType(asString(\"double\"))))));\n  testImport(\"void declToImport() { (void)1.0e-5f; }\", Lang_C99, \"\", Lang_C99,\n             Verifier,\n             functionDecl(hasDescendant(\n                 floatLiteral(equals(1.0e-5f), hasType(asString(\"float\"))))));\n}\n\nTEST_P(ImportFixedPointExpr, ImportFixedPointerLiteralExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() { (void)1.0k; }\", Lang_C99, \"\", Lang_C99,\n             Verifier, functionDecl(hasDescendant(fixedPointLiteral())));\n  testImport(\"void declToImport() { (void)0.75r; }\", Lang_C99, \"\", Lang_C99,\n             Verifier, functionDecl(hasDescendant(fixedPointLiteral())));\n}\n\nTEST_P(ImportExpr, ImportImaginaryLiteralExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"void declToImport() { (void)1.0i; }\",\n      Lang_CXX14, \"\", Lang_CXX14, Verifier,\n      functionDecl(hasDescendant(imaginaryLiteral())));\n}\n\nTEST_P(ImportExpr, ImportCompoundLiteralExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() {\"\n             \"  struct s { int x; long y; unsigned z; }; \"\n             \"  (void)(struct s){ 42, 0L, 1U }; }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(compoundLiteralExpr(\n                 hasType(asString(\"struct s\")),\n                 has(initListExpr(\n                     hasType(asString(\"struct s\")),\n                     has(integerLiteral(equals(42), hasType(asString(\"int\")))),\n                     has(integerLiteral(equals(0), hasType(asString(\"long\")))),\n                     has(integerLiteral(\n                         equals(1), hasType(asString(\"unsigned int\"))))))))));\n}\n\nTEST_P(ImportExpr, ImportCXXThisExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"class declToImport { void f() { (void)this; } };\", Lang_CXX03, \"\",\n             Lang_CXX03, Verifier,\n             cxxRecordDecl(hasMethod(hasDescendant(\n                 cxxThisExpr(hasType(asString(\"class declToImport *\")))))));\n}\n\nTEST_P(ImportExpr, ImportAtomicExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() { int *ptr; __atomic_load_n(ptr, 1); }\",\n             Lang_C99, \"\", Lang_C99, Verifier,\n             functionDecl(hasDescendant(atomicExpr(\n                 has(ignoringParenImpCasts(\n                     declRefExpr(hasDeclaration(varDecl(hasName(\"ptr\"))),\n                                 hasType(asString(\"int *\"))))),\n                 has(integerLiteral(equals(1), hasType(asString(\"int\"))))))));\n}\n\nTEST_P(ImportExpr, ImportLabelDeclAndAddrLabelExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() { loop: goto loop; (void)&&loop; }\", Lang_C99,\n             \"\", Lang_C99, Verifier,\n             functionDecl(hasDescendant(labelStmt(\n                              hasDeclaration(labelDecl(hasName(\"loop\"))))),\n                          hasDescendant(addrLabelExpr(\n                              hasDeclaration(labelDecl(hasName(\"loop\")))))));\n}\n\nAST_MATCHER_P(TemplateDecl, hasTemplateDecl,\n              internal::Matcher<NamedDecl>, InnerMatcher) {\n  const NamedDecl *Template = Node.getTemplatedDecl();\n  return Template && InnerMatcher.matches(*Template, Finder, Builder);\n}\n\nTEST_P(ImportExpr, ImportParenListExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"template<typename T> class dummy { void f() { dummy X(*this); } };\"\n      \"typedef dummy<int> declToImport;\"\n      \"template class dummy<int>;\",\n      Lang_CXX03, \"\", Lang_CXX03, Verifier,\n      typedefDecl(hasType(templateSpecializationType(\n          hasDeclaration(classTemplateSpecializationDecl(hasSpecializedTemplate(\n              classTemplateDecl(hasTemplateDecl(cxxRecordDecl(hasMethod(allOf(\n                  hasName(\"f\"),\n                  hasBody(compoundStmt(has(declStmt(hasSingleDecl(\n                      varDecl(hasInitializer(parenListExpr(has(unaryOperator(\n                          hasOperatorName(\"*\"),\n                          hasUnaryOperand(cxxThisExpr())))))))))))))))))))))));\n}\n\nTEST_P(ImportExpr, ImportSwitch) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() { int b; switch (b) { case 1: break; } }\",\n             Lang_C99, \"\", Lang_C99, Verifier,\n             functionDecl(hasDescendant(\n                 switchStmt(has(compoundStmt(has(caseStmt())))))));\n}\n\nTEST_P(ImportExpr, ImportStmtExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"void declToImport() { int b; int a = b ?: 1; int C = ({int X=4; X;}); }\",\n      Lang_C99, \"\", Lang_C99, Verifier,\n      traverse(TK_AsIs,\n               functionDecl(hasDescendant(varDecl(\n                   hasName(\"C\"), hasType(asString(\"int\")),\n                   hasInitializer(stmtExpr(\n                       hasAnySubstatement(declStmt(hasSingleDecl(varDecl(\n                           hasName(\"X\"), hasType(asString(\"int\")),\n                           hasInitializer(integerLiteral(equals(4))))))),\n                       hasDescendant(implicitCastExpr()))))))));\n}\n\nTEST_P(ImportExpr, ImportConditionalOperator) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport() { (void)(true ? 1 : -5); }\", Lang_CXX03, \"\",\n             Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(conditionalOperator(\n                 hasCondition(cxxBoolLiteral(equals(true))),\n                 hasTrueExpression(integerLiteral(equals(1))),\n                 hasFalseExpression(unaryOperator(\n                     hasUnaryOperand(integerLiteral(equals(5)))))))));\n}\n\nTEST_P(ImportExpr, ImportBinaryConditionalOperator) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"void declToImport() { (void)(1 ?: -5); }\", Lang_CXX03, \"\", Lang_CXX03,\n      Verifier,\n      traverse(TK_AsIs,\n               functionDecl(hasDescendant(binaryConditionalOperator(\n                   hasCondition(implicitCastExpr(\n                       hasSourceExpression(opaqueValueExpr(\n                           hasSourceExpression(integerLiteral(equals(1))))),\n                       hasType(booleanType()))),\n                   hasTrueExpression(opaqueValueExpr(\n                       hasSourceExpression(integerLiteral(equals(1))))),\n                   hasFalseExpression(unaryOperator(\n                       hasOperatorName(\"-\"),\n                       hasUnaryOperand(integerLiteral(equals(5))))))))));\n}\n\nTEST_P(ImportExpr, ImportDesignatedInitExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"void declToImport() {\"\n      \"  struct point { double x; double y; };\"\n      \"  struct point ptarray[10] = \"\n      \"{ [2].y = 1.0, [2].x = 2.0, [0].x = 1.0 }; }\",\n      Lang_C99, \"\", Lang_C99, Verifier,\n      functionDecl(hasDescendant(initListExpr(\n          has(designatedInitExpr(designatorCountIs(2),\n                                 hasDescendant(floatLiteral(equals(1.0))),\n                                 hasDescendant(integerLiteral(equals(2))))),\n          has(designatedInitExpr(designatorCountIs(2),\n                                 hasDescendant(floatLiteral(equals(2.0))),\n                                 hasDescendant(integerLiteral(equals(2))))),\n          has(designatedInitExpr(designatorCountIs(2),\n                                 hasDescendant(floatLiteral(equals(1.0))),\n                                 hasDescendant(integerLiteral(equals(0)))))))));\n}\n\nTEST_P(ImportExpr, ImportPredefinedExpr) {\n  MatchVerifier<Decl> Verifier;\n  // __func__ expands as StringLiteral(\"declToImport\")\n  testImport(\"void declToImport() { (void)__func__; }\", Lang_CXX03, \"\",\n             Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(predefinedExpr(\n                 hasType(asString(\"const char [13]\")),\n                 has(stringLiteral(hasType(asString(\"const char [13]\"))))))));\n}\n\nTEST_P(ImportExpr, ImportInitListExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"void declToImport() {\"\n      \"  struct point { double x; double y; };\"\n      \"  point ptarray[10] = { [2].y = 1.0, [2].x = 2.0,\"\n      \"                        [0].x = 1.0 }; }\",\n      Lang_CXX03, \"\", Lang_CXX03, Verifier,\n      functionDecl(hasDescendant(initListExpr(\n          has(cxxConstructExpr(requiresZeroInitialization())),\n          has(initListExpr(\n              hasType(asString(\"struct point\")), has(floatLiteral(equals(1.0))),\n              has(implicitValueInitExpr(hasType(asString(\"double\")))))),\n          has(initListExpr(hasType(asString(\"struct point\")),\n                           has(floatLiteral(equals(2.0))),\n                           has(floatLiteral(equals(1.0)))))))));\n}\n\n\nconst internal::VariadicDynCastAllOfMatcher<Expr, VAArgExpr> vaArgExpr;\n\nTEST_P(ImportExpr, ImportVAArgExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"void declToImport(__builtin_va_list list, ...) {\"\n             \"  (void)__builtin_va_arg(list, int); }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(\n                 cStyleCastExpr(hasSourceExpression(vaArgExpr())))));\n}\n\nTEST_P(ImportExpr, CXXTemporaryObjectExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"struct C {};\"\n      \"void declToImport() { C c = C(); }\",\n      Lang_CXX03, \"\", Lang_CXX03, Verifier,\n      traverse(TK_AsIs,\n               functionDecl(hasDescendant(exprWithCleanups(has(cxxConstructExpr(\n                   has(materializeTemporaryExpr(has(implicitCastExpr(\n                       has(cxxTemporaryObjectExpr()))))))))))));\n}\n\nTEST_P(ImportType, ImportAtomicType) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"void declToImport() { typedef _Atomic(int) a_int; }\",\n      Lang_CXX11, \"\", Lang_CXX11, Verifier,\n      functionDecl(hasDescendant(typedefDecl(has(atomicType())))));\n}\n\nTEST_P(ImportDecl, ImportFunctionTemplateDecl) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template <typename T> void declToImport() { };\", Lang_CXX03, \"\",\n             Lang_CXX03, Verifier, functionTemplateDecl());\n}\n\nTEST_P(ImportExpr, ImportCXXDependentScopeMemberExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template <typename T> struct C { T t; };\"\n             \"template <typename T> void declToImport() {\"\n             \"  C<T> d;\"\n             \"  (void)d.t;\"\n             \"}\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionTemplateDecl(hasDescendant(\n                 cStyleCastExpr(has(cxxDependentScopeMemberExpr())))));\n  testImport(\"template <typename T> struct C { T t; };\"\n             \"template <typename T> void declToImport() {\"\n             \"  C<T> d;\"\n             \"  (void)(&d)->t;\"\n             \"}\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionTemplateDecl(hasDescendant(\n                 cStyleCastExpr(has(cxxDependentScopeMemberExpr())))));\n}\n\nTEST_P(ImportType, ImportTypeAliasTemplate) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"template <int K>\"\n      \"struct dummy { static const int i = K; };\"\n      \"template <int K> using dummy2 = dummy<K>;\"\n      \"int declToImport() { return dummy2<3>::i; }\",\n      Lang_CXX11, \"\", Lang_CXX11, Verifier,\n      traverse(TK_AsIs,\n               functionDecl(hasDescendant(implicitCastExpr(has(declRefExpr()))),\n                            unless(hasAncestor(\n                                translationUnitDecl(has(typeAliasDecl())))))));\n}\n\nconst internal::VariadicDynCastAllOfMatcher<Decl, VarTemplateSpecializationDecl>\n    varTemplateSpecializationDecl;\n\nTEST_P(ImportDecl, ImportVarTemplate) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"template <typename T>\"\n      \"T pi = T(3.1415926535897932385L);\"\n      \"void declToImport() { (void)pi<int>; }\",\n      Lang_CXX14, \"\", Lang_CXX14, Verifier,\n      functionDecl(\n          hasDescendant(declRefExpr(to(varTemplateSpecializationDecl()))),\n          unless(hasAncestor(translationUnitDecl(has(varDecl(\n              hasName(\"pi\"), unless(varTemplateSpecializationDecl()))))))));\n}\n\nTEST_P(ImportType, ImportPackExpansion) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template <typename... Args>\"\n             \"struct dummy {\"\n             \"  dummy(Args... args) {}\"\n             \"  static const int i = 4;\"\n             \"};\"\n             \"int declToImport() { return dummy<int>::i; }\",\n             Lang_CXX11, \"\", Lang_CXX11, Verifier,\n             traverse(TK_AsIs, functionDecl(hasDescendant(returnStmt(has(\n                                   implicitCastExpr(has(declRefExpr()))))))));\n}\n\nconst internal::VariadicDynCastAllOfMatcher<Type,\n                                            DependentTemplateSpecializationType>\n    dependentTemplateSpecializationType;\n\nTEST_P(ImportType, ImportDependentTemplateSpecialization) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template<typename T>\"\n             \"struct A;\"\n             \"template<typename T>\"\n             \"struct declToImport {\"\n             \"  typename A<T>::template B<T> a;\"\n             \"};\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             classTemplateDecl(has(cxxRecordDecl(has(\n                 fieldDecl(hasType(dependentTemplateSpecializationType())))))));\n}\n\nconst internal::VariadicDynCastAllOfMatcher<Stmt, SizeOfPackExpr>\n    sizeOfPackExpr;\n\nTEST_P(ImportExpr, ImportSizeOfPackExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"template <typename... Ts>\"\n      \"void declToImport() {\"\n      \"  const int i = sizeof...(Ts);\"\n      \"};\"\n      \"void g() { declToImport<int>(); }\",\n      Lang_CXX11, \"\", Lang_CXX11, Verifier,\n          functionTemplateDecl(hasDescendant(sizeOfPackExpr())));\n  testImport(\n      \"template <typename... Ts>\"\n      \"using X = int[sizeof...(Ts)];\"\n      \"template <typename... Us>\"\n      \"struct Y {\"\n      \"  X<Us..., int, double, int, Us...> f;\"\n      \"};\"\n      \"Y<float, int> declToImport;\",\n      Lang_CXX11, \"\", Lang_CXX11, Verifier,\n      varDecl(hasType(classTemplateSpecializationDecl(has(fieldDecl(hasType(\n          hasUnqualifiedDesugaredType(constantArrayType(hasSize(7))))))))));\n}\n\nconst internal::VariadicDynCastAllOfMatcher<Stmt, CXXFoldExpr> cxxFoldExpr;\n\nAST_MATCHER_P(CXXFoldExpr, hasOperator, BinaryOperatorKind, Op) {\n  return Node.getOperator() == Op;\n}\nAST_MATCHER(CXXFoldExpr, hasInit) { return Node.getInit(); }\nAST_MATCHER(CXXFoldExpr, isRightFold) { return Node.isRightFold(); }\nAST_MATCHER(CXXFoldExpr, isLeftFold) { return Node.isLeftFold(); }\n\nTEST_P(ImportExpr, ImportCXXFoldExpr) {\n  auto Match1 =\n      cxxFoldExpr(hasOperator(BO_Add), isLeftFold(), unless(hasInit()));\n  auto Match2 = cxxFoldExpr(hasOperator(BO_Sub), isLeftFold(), hasInit());\n  auto Match3 =\n      cxxFoldExpr(hasOperator(BO_Mul), isRightFold(), unless(hasInit()));\n  auto Match4 = cxxFoldExpr(hasOperator(BO_Div), isRightFold(), hasInit());\n\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template <typename... Ts>\"\n             \"void declToImport(Ts... args) {\"\n             \"  const int i1 = (... + args);\"\n             \"  const int i2 = (1 - ... - args);\"\n             \"  const int i3 = (args * ...);\"\n             \"  const int i4 = (args / ... / 1);\"\n             \"};\"\n             \"void g() { declToImport(1, 2, 3, 4, 5); }\",\n             Lang_CXX17, \"\", Lang_CXX17, Verifier,\n             functionTemplateDecl(hasDescendant(Match1), hasDescendant(Match2),\n                                  hasDescendant(Match3),\n                                  hasDescendant(Match4)));\n}\n\n/// \\brief Matches __builtin_types_compatible_p:\n/// GNU extension to check equivalent types\n/// Given\n/// \\code\n///   __builtin_types_compatible_p(int, int)\n/// \\endcode\n//  will generate TypeTraitExpr <...> 'int'\nconst internal::VariadicDynCastAllOfMatcher<Stmt, TypeTraitExpr> typeTraitExpr;\n\nTEST_P(ImportExpr, ImportTypeTraitExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"void declToImport() { \"\n      \"  (void)__builtin_types_compatible_p(int, int);\"\n      \"}\",\n      Lang_C99, \"\", Lang_C99, Verifier,\n      functionDecl(hasDescendant(typeTraitExpr(hasType(asString(\"int\"))))));\n}\n\nconst internal::VariadicDynCastAllOfMatcher<Stmt, CXXTypeidExpr> cxxTypeidExpr;\n\nTEST_P(ImportExpr, ImportCXXTypeidExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"namespace std { class type_info {}; }\"\n      \"void declToImport() {\"\n      \"  int x;\"\n      \"  auto a = typeid(int); auto b = typeid(x);\"\n      \"}\",\n      Lang_CXX11, \"\", Lang_CXX11, Verifier,\n      traverse(\n          TK_AsIs,\n          functionDecl(\n              hasDescendant(varDecl(hasName(\"a\"), hasInitializer(hasDescendant(\n                                                      cxxTypeidExpr())))),\n              hasDescendant(varDecl(hasName(\"b\"), hasInitializer(hasDescendant(\n                                                      cxxTypeidExpr())))))));\n}\n\nTEST_P(ImportExpr, ImportTypeTraitExprValDep) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"template<typename T> struct declToImport {\"\n      \"  void m() { (void)__is_pod(T); }\"\n      \"};\"\n      \"void f() { declToImport<int>().m(); }\",\n      Lang_CXX11, \"\", Lang_CXX11, Verifier,\n      classTemplateDecl(has(cxxRecordDecl(has(\n          functionDecl(hasDescendant(\n              typeTraitExpr(hasType(booleanType())))))))));\n}\n\nTEST_P(ImportDecl, ImportRecordDeclInFunc) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"int declToImport() { \"\n             \"  struct data_t {int a;int b;};\"\n             \"  struct data_t d;\"\n             \"  return 0;\"\n             \"}\",\n             Lang_C99, \"\", Lang_C99, Verifier,\n             functionDecl(hasBody(compoundStmt(\n                 has(declStmt(hasSingleDecl(varDecl(hasName(\"d\")))))))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportRecordTypeInFunc) {\n  Decl *FromTU = getTuDecl(\"int declToImport() { \"\n                           \"  struct data_t {int a;int b;};\"\n                           \"  struct data_t d;\"\n                           \"  return 0;\"\n                           \"}\",\n                           Lang_C99, \"input.c\");\n  auto *FromVar =\n      FirstDeclMatcher<VarDecl>().match(FromTU, varDecl(hasName(\"d\")));\n  ASSERT_TRUE(FromVar);\n  auto ToType =\n      ImportType(FromVar->getType().getCanonicalType(), FromVar, Lang_C99);\n  EXPECT_FALSE(ToType.isNull());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportRecordDeclInFuncParams) {\n  // This construct is not supported by ASTImporter.\n  Decl *FromTU = getTuDecl(\n      \"int declToImport(struct data_t{int a;int b;} ***d){ return 0; }\",\n      Lang_C99, \"input.c\");\n  auto *From = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"declToImport\")));\n  ASSERT_TRUE(From);\n  auto *To = Import(From, Lang_C99);\n  EXPECT_EQ(To, nullptr);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportRecordDeclInFuncFromMacro) {\n  Decl *FromTU =\n      getTuDecl(\"#define NONAME_SIZEOF(type) sizeof(struct{type *dummy;}) \\n\"\n                \"int declToImport(){ return NONAME_SIZEOF(int); }\",\n                Lang_C99, \"input.c\");\n  auto *From = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"declToImport\")));\n  ASSERT_TRUE(From);\n  auto *To = Import(From, Lang_C99);\n  ASSERT_TRUE(To);\n  EXPECT_TRUE(MatchVerifier<FunctionDecl>().match(\n      To, functionDecl(hasName(\"declToImport\"),\n                       hasDescendant(unaryExprOrTypeTraitExpr()))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportRecordDeclInFuncParamsFromMacro) {\n  // This construct is not supported by ASTImporter.\n  Decl *FromTU =\n      getTuDecl(\"#define PAIR_STRUCT(type) struct data_t{type a;type b;} \\n\"\n                \"int declToImport(PAIR_STRUCT(int) ***d){ return 0; }\",\n                Lang_C99, \"input.c\");\n  auto *From = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"declToImport\")));\n  ASSERT_TRUE(From);\n  auto *To = Import(From, Lang_C99);\n  EXPECT_EQ(To, nullptr);\n}\n\nconst internal::VariadicDynCastAllOfMatcher<Expr, CXXPseudoDestructorExpr>\n    cxxPseudoDestructorExpr;\n\nTEST_P(ImportExpr, ImportCXXPseudoDestructorExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"typedef int T;\"\n      \"void declToImport(int *p) {\"\n      \"  T t;\"\n      \"  p->T::~T();\"\n      \"}\",\n      Lang_CXX03, \"\", Lang_CXX03, Verifier,\n      functionDecl(hasDescendant(callExpr(has(cxxPseudoDestructorExpr())))));\n}\n\nTEST_P(ImportDecl, ImportUsingDecl) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"namespace foo { int bar; }\"\n             \"void declToImport() { using foo::bar; }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionDecl(hasDescendant(usingDecl())));\n}\n\n/// \\brief Matches shadow declarations introduced into a scope by a\n///        (resolved) using declaration.\n///\n/// Given\n/// \\code\n///   namespace n { int f; }\n///   namespace declToImport { using n::f; }\n/// \\endcode\n/// usingShadowDecl()\n///   matches \\code f \\endcode\nconst internal::VariadicDynCastAllOfMatcher<Decl,\n                                            UsingShadowDecl> usingShadowDecl;\n\nTEST_P(ImportDecl, ImportUsingShadowDecl) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"namespace foo { int bar; }\"\n             \"namespace declToImport { using foo::bar; }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             namespaceDecl(has(usingShadowDecl())));\n}\n\nTEST_P(ImportExpr, ImportUnresolvedLookupExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template<typename T> int foo();\"\n             \"template <typename T> void declToImport() {\"\n             \"  (void)::foo<T>;\"\n             \"  (void)::template foo<T>;\"\n             \"}\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionTemplateDecl(hasDescendant(unresolvedLookupExpr())));\n}\n\nTEST_P(ImportExpr, ImportCXXUnresolvedConstructExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template <typename T> struct C { T t; };\"\n             \"template <typename T> void declToImport() {\"\n             \"  C<T> d;\"\n             \"  d.t = T();\"\n             \"}\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionTemplateDecl(hasDescendant(\n                 binaryOperator(has(cxxUnresolvedConstructExpr())))));\n  testImport(\"template <typename T> struct C { T t; };\"\n             \"template <typename T> void declToImport() {\"\n             \"  C<T> d;\"\n             \"  (&d)->t = T();\"\n             \"}\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionTemplateDecl(hasDescendant(\n                 binaryOperator(has(cxxUnresolvedConstructExpr())))));\n}\n\n/// Check that function \"declToImport()\" (which is the templated function\n/// for corresponding FunctionTemplateDecl) is not added into DeclContext.\n/// Same for class template declarations.\nTEST_P(ImportDecl, ImportTemplatedDeclForTemplate) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template <typename T> void declToImport() { T a = 1; }\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             functionTemplateDecl(hasAncestor(translationUnitDecl(\n                 unless(has(functionDecl(hasName(\"declToImport\"))))))));\n  testImport(\"template <typename T> struct declToImport { T t; };\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             classTemplateDecl(hasAncestor(translationUnitDecl(\n                 unless(has(cxxRecordDecl(hasName(\"declToImport\"))))))));\n}\n\nTEST_P(ImportDecl, ImportClassTemplatePartialSpecialization) {\n  MatchVerifier<Decl> Verifier;\n  auto Code =\n      R\"s(\n      struct declToImport {\n        template <typename T0> struct X;\n        template <typename T0> struct X<T0 *> {};\n      };\n      )s\";\n  testImport(Code, Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             recordDecl(has(classTemplateDecl()),\n                        has(classTemplateSpecializationDecl())));\n}\n\nTEST_P(ImportExpr, CXXOperatorCallExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\n      \"class declToImport {\"\n      \"  void f() { *this = declToImport(); }\"\n      \"};\",\n      Lang_CXX03, \"\", Lang_CXX03, Verifier,\n      cxxRecordDecl(has(cxxMethodDecl(hasDescendant(cxxOperatorCallExpr())))));\n}\n\nTEST_P(ImportExpr, DependentSizedArrayType) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template<typename T, int Size> class declToImport {\"\n             \"  T data[Size];\"\n             \"};\",\n             Lang_CXX03, \"\", Lang_CXX03, Verifier,\n             classTemplateDecl(has(cxxRecordDecl(\n                 has(fieldDecl(hasType(dependentSizedArrayType())))))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, TemplateTypeParmDeclNoDefaultArg) {\n  Decl *FromTU = getTuDecl(\"template<typename T> struct X {};\", Lang_CXX03);\n  auto From = FirstDeclMatcher<TemplateTypeParmDecl>().match(\n      FromTU, templateTypeParmDecl(hasName(\"T\")));\n  TemplateTypeParmDecl *To = Import(From, Lang_CXX03);\n  ASSERT_FALSE(To->hasDefaultArgument());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, TemplateTypeParmDeclDefaultArg) {\n  Decl *FromTU =\n      getTuDecl(\"template<typename T = int> struct X {};\", Lang_CXX03);\n  auto From = FirstDeclMatcher<TemplateTypeParmDecl>().match(\n      FromTU, templateTypeParmDecl(hasName(\"T\")));\n  TemplateTypeParmDecl *To = Import(From, Lang_CXX03);\n  ASSERT_TRUE(To->hasDefaultArgument());\n  QualType ToArg = To->getDefaultArgument();\n  ASSERT_EQ(ToArg, QualType(To->getASTContext().IntTy));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportBeginLocOfDeclRefExpr) {\n  Decl *FromTU =\n      getTuDecl(\"class A { public: static int X; }; void f() { (void)A::X; }\",\n                Lang_CXX03);\n  auto From = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n  ASSERT_TRUE(From);\n  ASSERT_TRUE(\n      cast<CStyleCastExpr>(cast<CompoundStmt>(From->getBody())->body_front())\n          ->getSubExpr()\n          ->getBeginLoc()\n          .isValid());\n  FunctionDecl *To = Import(From, Lang_CXX03);\n  ASSERT_TRUE(To);\n  ASSERT_TRUE(\n      cast<CStyleCastExpr>(cast<CompoundStmt>(To->getBody())->body_front())\n          ->getSubExpr()\n          ->getBeginLoc()\n          .isValid());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       TemplateTemplateParmDeclNoDefaultArg) {\n  Decl *FromTU = getTuDecl(R\"(\n                           template<template<typename> typename TT> struct Y {};\n                           )\",\n                           Lang_CXX17);\n  auto From = FirstDeclMatcher<TemplateTemplateParmDecl>().match(\n      FromTU, templateTemplateParmDecl(hasName(\"TT\")));\n  TemplateTemplateParmDecl *To = Import(From, Lang_CXX17);\n  ASSERT_FALSE(To->hasDefaultArgument());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, TemplateTemplateParmDeclDefaultArg) {\n  Decl *FromTU = getTuDecl(R\"(\n                           template<typename T> struct X {};\n                           template<template<typename> typename TT = X> struct Y {};\n                           )\",\n                           Lang_CXX17);\n  auto From = FirstDeclMatcher<TemplateTemplateParmDecl>().match(\n      FromTU, templateTemplateParmDecl(hasName(\"TT\")));\n  TemplateTemplateParmDecl *To = Import(From, Lang_CXX17);\n  ASSERT_TRUE(To->hasDefaultArgument());\n  const TemplateArgument &ToDefaultArg = To->getDefaultArgument().getArgument();\n  ASSERT_TRUE(To->isTemplateDecl());\n  TemplateDecl *ToTemplate = ToDefaultArg.getAsTemplate().getAsTemplateDecl();\n\n  // Find the default argument template 'X' in the AST and compare it against\n  // the default argument we got.\n  auto ToExpectedDecl = FirstDeclMatcher<ClassTemplateDecl>().match(\n      To->getTranslationUnitDecl(), classTemplateDecl(hasName(\"X\")));\n  ASSERT_EQ(ToTemplate, ToExpectedDecl);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, NonTypeTemplateParmDeclNoDefaultArg) {\n  Decl *FromTU = getTuDecl(\"template<int N> struct X {};\", Lang_CXX03);\n  auto From = FirstDeclMatcher<NonTypeTemplateParmDecl>().match(\n      FromTU, nonTypeTemplateParmDecl(hasName(\"N\")));\n  NonTypeTemplateParmDecl *To = Import(From, Lang_CXX03);\n  ASSERT_FALSE(To->hasDefaultArgument());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, NonTypeTemplateParmDeclDefaultArg) {\n  Decl *FromTU = getTuDecl(\"template<int S = 1> struct X {};\", Lang_CXX03);\n  auto From = FirstDeclMatcher<NonTypeTemplateParmDecl>().match(\n      FromTU, nonTypeTemplateParmDecl(hasName(\"S\")));\n  NonTypeTemplateParmDecl *To = Import(From, Lang_CXX03);\n  ASSERT_TRUE(To->hasDefaultArgument());\n  Stmt *ToArg = To->getDefaultArgument();\n  ASSERT_TRUE(isa<ConstantExpr>(ToArg));\n  ToArg = *ToArg->child_begin();\n  ASSERT_TRUE(isa<IntegerLiteral>(ToArg));\n  ASSERT_EQ(cast<IntegerLiteral>(ToArg)->getValue().getLimitedValue(), 1U);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportOfTemplatedDeclOfClassTemplateDecl) {\n  Decl *FromTU = getTuDecl(\"template<class X> struct S{};\", Lang_CXX03);\n  auto From =\n      FirstDeclMatcher<ClassTemplateDecl>().match(FromTU, classTemplateDecl());\n  ASSERT_TRUE(From);\n  auto To = cast<ClassTemplateDecl>(Import(From, Lang_CXX03));\n  ASSERT_TRUE(To);\n  Decl *ToTemplated = To->getTemplatedDecl();\n  Decl *ToTemplated1 = Import(From->getTemplatedDecl(), Lang_CXX03);\n  EXPECT_TRUE(ToTemplated1);\n  EXPECT_EQ(ToTemplated1, ToTemplated);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportOfTemplatedDeclOfFunctionTemplateDecl) {\n  Decl *FromTU = getTuDecl(\"template<class X> void f(){}\", Lang_CXX03);\n  auto From = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      FromTU, functionTemplateDecl());\n  ASSERT_TRUE(From);\n  auto To = cast<FunctionTemplateDecl>(Import(From, Lang_CXX03));\n  ASSERT_TRUE(To);\n  Decl *ToTemplated = To->getTemplatedDecl();\n  Decl *ToTemplated1 = Import(From->getTemplatedDecl(), Lang_CXX03);\n  EXPECT_TRUE(ToTemplated1);\n  EXPECT_EQ(ToTemplated1, ToTemplated);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportOfTemplatedDeclShouldImportTheClassTemplateDecl) {\n  Decl *FromTU = getTuDecl(\"template<class X> struct S{};\", Lang_CXX03);\n  auto FromFT =\n      FirstDeclMatcher<ClassTemplateDecl>().match(FromTU, classTemplateDecl());\n  ASSERT_TRUE(FromFT);\n\n  auto ToTemplated =\n      cast<CXXRecordDecl>(Import(FromFT->getTemplatedDecl(), Lang_CXX03));\n  EXPECT_TRUE(ToTemplated);\n  auto ToTU = ToTemplated->getTranslationUnitDecl();\n  auto ToFT =\n      FirstDeclMatcher<ClassTemplateDecl>().match(ToTU, classTemplateDecl());\n  EXPECT_TRUE(ToFT);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportOfTemplatedDeclShouldImportTheFunctionTemplateDecl) {\n  Decl *FromTU = getTuDecl(\"template<class X> void f(){}\", Lang_CXX03);\n  auto FromFT = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      FromTU, functionTemplateDecl());\n  ASSERT_TRUE(FromFT);\n\n  auto ToTemplated =\n      cast<FunctionDecl>(Import(FromFT->getTemplatedDecl(), Lang_CXX03));\n  EXPECT_TRUE(ToTemplated);\n  auto ToTU = ToTemplated->getTranslationUnitDecl();\n  auto ToFT = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      ToTU, functionTemplateDecl());\n  EXPECT_TRUE(ToFT);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportCorrectTemplatedDecl) {\n  auto Code =\n        R\"(\n        namespace x {\n          template<class X> struct S1{};\n          template<class X> struct S2{};\n          template<class X> struct S3{};\n        }\n        )\";\n  Decl *FromTU = getTuDecl(Code, Lang_CXX03);\n  auto FromNs =\n      FirstDeclMatcher<NamespaceDecl>().match(FromTU, namespaceDecl());\n  auto ToNs = cast<NamespaceDecl>(Import(FromNs, Lang_CXX03));\n  ASSERT_TRUE(ToNs);\n  auto From =\n      FirstDeclMatcher<ClassTemplateDecl>().match(FromTU,\n                                                  classTemplateDecl(\n                                                      hasName(\"S2\")));\n  auto To =\n      FirstDeclMatcher<ClassTemplateDecl>().match(ToNs,\n                                                  classTemplateDecl(\n                                                      hasName(\"S2\")));\n  ASSERT_TRUE(From);\n  ASSERT_TRUE(To);\n  auto ToTemplated = To->getTemplatedDecl();\n  auto ToTemplated1 =\n      cast<CXXRecordDecl>(Import(From->getTemplatedDecl(), Lang_CXX03));\n  EXPECT_TRUE(ToTemplated1);\n  ASSERT_EQ(ToTemplated1, ToTemplated);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportChooseExpr) {\n  // This tests the import of isConditionTrue directly to make sure the importer\n  // gets it right.\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      \"void declToImport() { (void)__builtin_choose_expr(1, 0, 1); }\", Lang_C99,\n      \"\", Lang_C99);\n\n  auto ToResults = match(chooseExpr().bind(\"choose\"), To->getASTContext());\n  auto FromResults = match(chooseExpr().bind(\"choose\"), From->getASTContext());\n\n  const ChooseExpr *FromChooseExpr =\n      selectFirst<ChooseExpr>(\"choose\", FromResults);\n  ASSERT_TRUE(FromChooseExpr);\n\n  const ChooseExpr *ToChooseExpr = selectFirst<ChooseExpr>(\"choose\", ToResults);\n  ASSERT_TRUE(ToChooseExpr);\n\n  EXPECT_EQ(FromChooseExpr->isConditionTrue(), ToChooseExpr->isConditionTrue());\n  EXPECT_EQ(FromChooseExpr->isConditionDependent(),\n            ToChooseExpr->isConditionDependent());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportGenericSelectionExpr) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      R\"(\n      int declToImport() {\n        int x;\n        return _Generic(x, int: 0, default: 1);\n      }\n      )\",\n      Lang_C99, \"\", Lang_C99);\n\n  auto ToResults =\n      match(genericSelectionExpr().bind(\"expr\"), To->getASTContext());\n  auto FromResults =\n      match(genericSelectionExpr().bind(\"expr\"), From->getASTContext());\n\n  const GenericSelectionExpr *FromGenericSelectionExpr =\n      selectFirst<GenericSelectionExpr>(\"expr\", FromResults);\n  ASSERT_TRUE(FromGenericSelectionExpr);\n\n  const GenericSelectionExpr *ToGenericSelectionExpr =\n      selectFirst<GenericSelectionExpr>(\"expr\", ToResults);\n  ASSERT_TRUE(ToGenericSelectionExpr);\n\n  EXPECT_EQ(FromGenericSelectionExpr->isResultDependent(),\n            ToGenericSelectionExpr->isResultDependent());\n  EXPECT_EQ(FromGenericSelectionExpr->getResultIndex(),\n            ToGenericSelectionExpr->getResultIndex());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportFunctionWithBackReferringParameter) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      R\"(\n      template <typename T> struct X {};\n\n      void declToImport(int y, X<int> &x) {}\n\n      template <> struct X<int> {\n        void g() {\n          X<int> x;\n          declToImport(0, x);\n        }\n      };\n      )\",\n      Lang_CXX03, \"\", Lang_CXX03);\n\n  MatchVerifier<Decl> Verifier;\n  auto Matcher = functionDecl(hasName(\"declToImport\"),\n                              parameterCountIs(2),\n                              hasParameter(0, hasName(\"y\")),\n                              hasParameter(1, hasName(\"x\")),\n                              hasParameter(1, hasType(asString(\"X<int> &\"))));\n  ASSERT_TRUE(Verifier.match(From, Matcher));\n  EXPECT_TRUE(Verifier.match(To, Matcher));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       TUshouldNotContainTemplatedDeclOfFunctionTemplates) {\n  Decl *From, *To;\n  std::tie(From, To) =\n      getImportedDecl(\"template <typename T> void declToImport() { T a = 1; }\"\n                      \"void instantiate() { declToImport<int>(); }\",\n                      Lang_CXX03, \"\", Lang_CXX03);\n\n  auto Check = [](Decl *D) -> bool {\n    auto TU = D->getTranslationUnitDecl();\n    for (auto Child : TU->decls()) {\n      if (auto *FD = dyn_cast<FunctionDecl>(Child)) {\n        if (FD->getNameAsString() == \"declToImport\") {\n          GTEST_NONFATAL_FAILURE_(\n              \"TU should not contain any FunctionDecl with name declToImport\");\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  ASSERT_TRUE(Check(From));\n  EXPECT_TRUE(Check(To));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       TUshouldNotContainTemplatedDeclOfClassTemplates) {\n  Decl *From, *To;\n  std::tie(From, To) =\n      getImportedDecl(\"template <typename T> struct declToImport { T t; };\"\n                      \"void instantiate() { declToImport<int>(); }\",\n                      Lang_CXX03, \"\", Lang_CXX03);\n\n  auto Check = [](Decl *D) -> bool {\n    auto TU = D->getTranslationUnitDecl();\n    for (auto Child : TU->decls()) {\n      if (auto *RD = dyn_cast<CXXRecordDecl>(Child)) {\n        if (RD->getNameAsString() == \"declToImport\") {\n          GTEST_NONFATAL_FAILURE_(\n              \"TU should not contain any CXXRecordDecl with name declToImport\");\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  ASSERT_TRUE(Check(From));\n  EXPECT_TRUE(Check(To));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       TUshouldNotContainTemplatedDeclOfTypeAlias) {\n  Decl *From, *To;\n  std::tie(From, To) =\n      getImportedDecl(\n          \"template <typename T> struct X {};\"\n          \"template <typename T> using declToImport = X<T>;\"\n          \"void instantiate() { declToImport<int> a; }\",\n                      Lang_CXX11, \"\", Lang_CXX11);\n\n  auto Check = [](Decl *D) -> bool {\n    auto TU = D->getTranslationUnitDecl();\n    for (auto Child : TU->decls()) {\n      if (auto *AD = dyn_cast<TypeAliasDecl>(Child)) {\n        if (AD->getNameAsString() == \"declToImport\") {\n          GTEST_NONFATAL_FAILURE_(\n              \"TU should not contain any TypeAliasDecl with name declToImport\");\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  ASSERT_TRUE(Check(From));\n  EXPECT_TRUE(Check(To));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       TUshouldNotContainClassTemplateSpecializationOfImplicitInstantiation) {\n\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      R\"(\n      template<class T>\n      class Base {};\n      class declToImport : public Base<declToImport> {};\n      )\",\n      Lang_CXX03, \"\", Lang_CXX03);\n\n  // Check that the ClassTemplateSpecializationDecl is NOT the child of the TU.\n  auto Pattern =\n      translationUnitDecl(unless(has(classTemplateSpecializationDecl())));\n  ASSERT_TRUE(\n      MatchVerifier<Decl>{}.match(From->getTranslationUnitDecl(), Pattern));\n  EXPECT_TRUE(\n      MatchVerifier<Decl>{}.match(To->getTranslationUnitDecl(), Pattern));\n\n  // Check that the ClassTemplateSpecializationDecl is the child of the\n  // ClassTemplateDecl.\n  Pattern = translationUnitDecl(has(classTemplateDecl(\n      hasName(\"Base\"), has(classTemplateSpecializationDecl()))));\n  ASSERT_TRUE(\n      MatchVerifier<Decl>{}.match(From->getTranslationUnitDecl(), Pattern));\n  EXPECT_TRUE(\n      MatchVerifier<Decl>{}.match(To->getTranslationUnitDecl(), Pattern));\n}\n\nAST_MATCHER_P(RecordDecl, hasFieldOrder, std::vector<StringRef>, Order) {\n  size_t Index = 0;\n  for (Decl *D : Node.decls()) {\n    if (isa<FieldDecl>(D) || isa<IndirectFieldDecl>(D)) {\n      auto *ND = cast<NamedDecl>(D);\n      if (Index == Order.size())\n        return false;\n      if (ND->getName() != Order[Index])\n        return false;\n      ++Index;\n    }\n  }\n  return Index == Order.size();\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       TUshouldContainClassTemplateSpecializationOfExplicitInstantiation) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      R\"(\n      namespace NS {\n        template<class T>\n        class X {};\n        template class X<int>;\n      }\n      )\",\n      Lang_CXX03, \"\", Lang_CXX03, \"NS\");\n\n  // Check that the ClassTemplateSpecializationDecl is NOT the child of the\n  // ClassTemplateDecl.\n  auto Pattern = namespaceDecl(has(classTemplateDecl(\n      hasName(\"X\"), unless(has(classTemplateSpecializationDecl())))));\n  ASSERT_TRUE(MatchVerifier<Decl>{}.match(From, Pattern));\n  EXPECT_TRUE(MatchVerifier<Decl>{}.match(To, Pattern));\n\n  // Check that the ClassTemplateSpecializationDecl is the child of the\n  // NamespaceDecl.\n  Pattern = namespaceDecl(has(classTemplateSpecializationDecl(hasName(\"X\"))));\n  ASSERT_TRUE(MatchVerifier<Decl>{}.match(From, Pattern));\n  EXPECT_TRUE(MatchVerifier<Decl>{}.match(To, Pattern));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       CXXRecordDeclFieldsShouldBeInCorrectOrder) {\n  Decl *From, *To;\n  std::tie(From, To) =\n      getImportedDecl(\n          \"struct declToImport { int a; int b; };\",\n                      Lang_CXX11, \"\", Lang_CXX11);\n\n  MatchVerifier<Decl> Verifier;\n  ASSERT_TRUE(Verifier.match(From, cxxRecordDecl(hasFieldOrder({\"a\", \"b\"}))));\n  EXPECT_TRUE(Verifier.match(To, cxxRecordDecl(hasFieldOrder({\"a\", \"b\"}))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       CXXRecordDeclFieldOrderShouldNotDependOnImportOrder) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      // The original recursive algorithm of ASTImporter first imports 'c' then\n      // 'b' and lastly 'a'.  Therefore we must restore the order somehow.\n      R\"s(\n      struct declToImport {\n          int a = c + b;\n          int b = 1;\n          int c = 2;\n      };\n      )s\",\n      Lang_CXX11, \"\", Lang_CXX11);\n\n  MatchVerifier<Decl> Verifier;\n  ASSERT_TRUE(\n      Verifier.match(From, cxxRecordDecl(hasFieldOrder({\"a\", \"b\", \"c\"}))));\n  EXPECT_TRUE(\n      Verifier.match(To, cxxRecordDecl(hasFieldOrder({\"a\", \"b\", \"c\"}))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       CXXRecordDeclFieldAndIndirectFieldOrder) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      // First field is \"a\", then the field for unnamed union, then \"b\" and \"c\"\n      // from it (indirect fields), then \"d\".\n      R\"s(\n      struct declToImport {\n        int a = d;\n        union { \n          int b;\n          int c;\n        };\n        int d;\n      };\n      )s\",\n      Lang_CXX11, \"\", Lang_CXX11);\n\n  MatchVerifier<Decl> Verifier;\n  ASSERT_TRUE(Verifier.match(\n      From, cxxRecordDecl(hasFieldOrder({\"a\", \"\", \"b\", \"c\", \"d\"}))));\n  EXPECT_TRUE(Verifier.match(\n      To, cxxRecordDecl(hasFieldOrder({\"a\", \"\", \"b\", \"c\", \"d\"}))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ShouldImportImplicitCXXRecordDecl) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      R\"(\n      struct declToImport {\n      };\n      )\",\n      Lang_CXX03, \"\", Lang_CXX03);\n\n  MatchVerifier<Decl> Verifier;\n  // Match the implicit Decl.\n  auto Matcher = cxxRecordDecl(has(cxxRecordDecl()));\n  ASSERT_TRUE(Verifier.match(From, Matcher));\n  EXPECT_TRUE(Verifier.match(To, Matcher));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ShouldImportImplicitCXXRecordDeclOfClassTemplate) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      R\"(\n      template <typename U>\n      struct declToImport {\n      };\n      )\",\n      Lang_CXX03, \"\", Lang_CXX03);\n\n  MatchVerifier<Decl> Verifier;\n  // Match the implicit Decl.\n  auto Matcher = classTemplateDecl(has(cxxRecordDecl(has(cxxRecordDecl()))));\n  ASSERT_TRUE(Verifier.match(From, Matcher));\n  EXPECT_TRUE(Verifier.match(To, Matcher));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ShouldImportImplicitCXXRecordDeclOfClassTemplateSpecializationDecl) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      R\"(\n      template<class T>\n      class Base {};\n      class declToImport : public Base<declToImport> {};\n      )\",\n      Lang_CXX03, \"\", Lang_CXX03);\n\n  auto hasImplicitClass = has(cxxRecordDecl());\n  auto Pattern = translationUnitDecl(has(classTemplateDecl(\n      hasName(\"Base\"),\n      has(classTemplateSpecializationDecl(hasImplicitClass)))));\n  ASSERT_TRUE(\n      MatchVerifier<Decl>{}.match(From->getTranslationUnitDecl(), Pattern));\n  EXPECT_TRUE(\n      MatchVerifier<Decl>{}.match(To->getTranslationUnitDecl(), Pattern));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, IDNSOrdinary) {\n  Decl *From, *To;\n  std::tie(From, To) =\n      getImportedDecl(\"void declToImport() {}\", Lang_CXX03, \"\", Lang_CXX03);\n\n  MatchVerifier<Decl> Verifier;\n  auto Matcher = functionDecl();\n  ASSERT_TRUE(Verifier.match(From, Matcher));\n  EXPECT_TRUE(Verifier.match(To, Matcher));\n  EXPECT_EQ(From->getIdentifierNamespace(), To->getIdentifierNamespace());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, IDNSOfNonmemberOperator) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct X {};\n      void operator<<(int, X);\n      )\",\n      Lang_CXX03);\n  Decl *From = LastDeclMatcher<Decl>{}.match(FromTU, functionDecl());\n  const Decl *To = Import(From, Lang_CXX03);\n  EXPECT_EQ(From->getIdentifierNamespace(), To->getIdentifierNamespace());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ShouldImportMembersOfClassTemplateSpecializationDecl) {\n  Decl *From, *To;\n  std::tie(From, To) = getImportedDecl(\n      R\"(\n      template<class T>\n      class Base { int a; };\n      class declToImport : Base<declToImport> {};\n      )\",\n      Lang_CXX03, \"\", Lang_CXX03);\n\n  auto Pattern = translationUnitDecl(has(classTemplateDecl(\n      hasName(\"Base\"),\n      has(classTemplateSpecializationDecl(has(fieldDecl(hasName(\"a\"))))))));\n  ASSERT_TRUE(\n      MatchVerifier<Decl>{}.match(From->getTranslationUnitDecl(), Pattern));\n  EXPECT_TRUE(\n      MatchVerifier<Decl>{}.match(To->getTranslationUnitDecl(), Pattern));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportDefinitionOfClassTemplateAfterFwdDecl) {\n  {\n    Decl *FromTU = getTuDecl(\n        R\"(\n            template <typename T>\n            struct B;\n            )\",\n        Lang_CXX03, \"input0.cc\");\n    auto *FromD = FirstDeclMatcher<ClassTemplateDecl>().match(\n        FromTU, classTemplateDecl(hasName(\"B\")));\n\n    Import(FromD, Lang_CXX03);\n  }\n\n  {\n    Decl *FromTU = getTuDecl(\n        R\"(\n            template <typename T>\n            struct B {\n              void f();\n            };\n            )\",\n        Lang_CXX03, \"input1.cc\");\n    FunctionDecl *FromD = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"f\")));\n    Import(FromD, Lang_CXX03);\n    auto *FromCTD = FirstDeclMatcher<ClassTemplateDecl>().match(\n        FromTU, classTemplateDecl(hasName(\"B\")));\n    auto *ToCTD = cast<ClassTemplateDecl>(Import(FromCTD, Lang_CXX03));\n    EXPECT_TRUE(ToCTD->isThisDeclarationADefinition());\n  }\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportDefinitionOfClassTemplateIfThereIsAnExistingFwdDeclAndDefinition) {\n  Decl *ToTU = getToTuDecl(\n      R\"(\n      template <typename T>\n      struct B {\n        void f();\n      };\n\n      template <typename T>\n      struct B;\n      )\",\n      Lang_CXX03);\n  ASSERT_EQ(1u, DeclCounterWithPredicate<ClassTemplateDecl>(\n                    [](const ClassTemplateDecl *T) {\n                      return T->isThisDeclarationADefinition();\n                    })\n                    .match(ToTU, classTemplateDecl()));\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename T>\n      struct B {\n        void f();\n      };\n      )\",\n      Lang_CXX03, \"input1.cc\");\n  ClassTemplateDecl *FromD = FirstDeclMatcher<ClassTemplateDecl>().match(\n      FromTU, classTemplateDecl(hasName(\"B\")));\n\n  Import(FromD, Lang_CXX03);\n\n  // We should have only one definition.\n  EXPECT_EQ(1u, DeclCounterWithPredicate<ClassTemplateDecl>(\n                    [](const ClassTemplateDecl *T) {\n                      return T->isThisDeclarationADefinition();\n                    })\n                    .match(ToTU, classTemplateDecl()));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportDefinitionOfClassIfThereIsAnExistingFwdDeclAndDefinition) {\n  Decl *ToTU = getToTuDecl(\n      R\"(\n      struct B {\n        void f();\n      };\n\n      struct B;\n      )\",\n      Lang_CXX03);\n  ASSERT_EQ(2u, DeclCounter<CXXRecordDecl>().match(\n                    ToTU, cxxRecordDecl(unless(isImplicit()))));\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct B {\n        void f();\n      };\n      )\",\n      Lang_CXX03, \"input1.cc\");\n  auto *FromD = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"B\")));\n\n  Import(FromD, Lang_CXX03);\n\n  EXPECT_EQ(2u, DeclCounter<CXXRecordDecl>().match(\n                    ToTU, cxxRecordDecl(unless(isImplicit()))));\n}\n\nstatic void CompareSourceLocs(FullSourceLoc Loc1, FullSourceLoc Loc2) {\n  EXPECT_EQ(Loc1.getExpansionLineNumber(), Loc2.getExpansionLineNumber());\n  EXPECT_EQ(Loc1.getExpansionColumnNumber(), Loc2.getExpansionColumnNumber());\n  EXPECT_EQ(Loc1.getSpellingLineNumber(), Loc2.getSpellingLineNumber());\n  EXPECT_EQ(Loc1.getSpellingColumnNumber(), Loc2.getSpellingColumnNumber());\n}\nstatic void CompareSourceRanges(SourceRange Range1, SourceRange Range2,\n                                SourceManager &SM1, SourceManager &SM2) {\n  CompareSourceLocs(FullSourceLoc{ Range1.getBegin(), SM1 },\n                    FullSourceLoc{ Range2.getBegin(), SM2 });\n  CompareSourceLocs(FullSourceLoc{ Range1.getEnd(), SM1 },\n                    FullSourceLoc{ Range2.getEnd(), SM2 });\n}\nTEST_P(ASTImporterOptionSpecificTestBase, ImportSourceLocs) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      #define MFOO(arg) arg = arg + 1\n\n      void foo() {\n        int a = 5;\n        MFOO(a);\n      }\n      )\",\n      Lang_CXX03);\n  auto FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, functionDecl());\n  auto ToD = Import(FromD, Lang_CXX03);\n\n  auto ToLHS = LastDeclMatcher<DeclRefExpr>().match(ToD, declRefExpr());\n  auto FromLHS = LastDeclMatcher<DeclRefExpr>().match(FromTU, declRefExpr());\n  auto ToRHS = LastDeclMatcher<IntegerLiteral>().match(ToD, integerLiteral());\n  auto FromRHS =\n      LastDeclMatcher<IntegerLiteral>().match(FromTU, integerLiteral());\n\n  SourceManager &ToSM = ToAST->getASTContext().getSourceManager();\n  SourceManager &FromSM = FromD->getASTContext().getSourceManager();\n  CompareSourceRanges(ToD->getSourceRange(), FromD->getSourceRange(), ToSM,\n                      FromSM);\n  CompareSourceRanges(ToLHS->getSourceRange(), FromLHS->getSourceRange(), ToSM,\n                      FromSM);\n  CompareSourceRanges(ToRHS->getSourceRange(), FromRHS->getSourceRange(), ToSM,\n                      FromSM);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportNestedMacro) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      #define FUNC_INT void declToImport\n      #define FUNC FUNC_INT\n      FUNC(int a);\n      )\",\n      Lang_CXX03);\n  auto FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, functionDecl());\n  auto ToD = Import(FromD, Lang_CXX03);\n\n  SourceManager &ToSM = ToAST->getASTContext().getSourceManager();\n  SourceManager &FromSM = FromD->getASTContext().getSourceManager();\n  CompareSourceRanges(ToD->getSourceRange(), FromD->getSourceRange(), ToSM,\n                      FromSM);\n}\n\nTEST_P(\n    ASTImporterOptionSpecificTestBase,\n    ImportDefinitionOfClassTemplateSpecIfThereIsAnExistingFwdDeclAndDefinition) {\n  Decl *ToTU = getToTuDecl(\n      R\"(\n      template <typename T>\n      struct B;\n\n      template <>\n      struct B<int> {};\n\n      template <>\n      struct B<int>;\n      )\",\n      Lang_CXX03);\n  // We should have only one definition.\n  ASSERT_EQ(1u, DeclCounterWithPredicate<ClassTemplateSpecializationDecl>(\n                    [](const ClassTemplateSpecializationDecl *T) {\n                      return T->isThisDeclarationADefinition();\n                    })\n                    .match(ToTU, classTemplateSpecializationDecl()));\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename T>\n      struct B;\n\n      template <>\n      struct B<int> {};\n      )\",\n      Lang_CXX03, \"input1.cc\");\n  auto *FromD = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl(hasName(\"B\")));\n\n  Import(FromD, Lang_CXX03);\n\n  // We should have only one definition.\n  EXPECT_EQ(1u, DeclCounterWithPredicate<ClassTemplateSpecializationDecl>(\n                    [](const ClassTemplateSpecializationDecl *T) {\n                      return T->isThisDeclarationADefinition();\n                    })\n                    .match(ToTU, classTemplateSpecializationDecl()));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ObjectsWithUnnamedStructType) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct { int a; int b; } object0 = { 2, 3 };\n      struct { int x; int y; int z; } object1;\n      )\",\n      Lang_CXX03, \"input0.cc\");\n\n  auto *Obj0 =\n      FirstDeclMatcher<VarDecl>().match(FromTU, varDecl(hasName(\"object0\")));\n  auto *From0 = getRecordDecl(Obj0);\n  auto *Obj1 =\n      FirstDeclMatcher<VarDecl>().match(FromTU, varDecl(hasName(\"object1\")));\n  auto *From1 = getRecordDecl(Obj1);\n\n  auto *To0 = Import(From0, Lang_CXX03);\n  auto *To1 = Import(From1, Lang_CXX03);\n\n  EXPECT_TRUE(To0);\n  EXPECT_TRUE(To1);\n  EXPECT_NE(To0, To1);\n  EXPECT_NE(To0->getCanonicalDecl(), To1->getCanonicalDecl());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, AnonymousRecords) {\n  auto *Code =\n      R\"(\n      struct X {\n        struct { int a; };\n        struct { int b; };\n      };\n      )\";\n  Decl *FromTU0 = getTuDecl(Code, Lang_C99, \"input0.c\");\n\n  Decl *FromTU1 = getTuDecl(Code, Lang_C99, \"input1.c\");\n\n  auto *X0 =\n      FirstDeclMatcher<RecordDecl>().match(FromTU0, recordDecl(hasName(\"X\")));\n  auto *X1 =\n      FirstDeclMatcher<RecordDecl>().match(FromTU1, recordDecl(hasName(\"X\")));\n  Import(X0, Lang_C99);\n  Import(X1, Lang_C99);\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  // We expect no (ODR) warning during the import.\n  EXPECT_EQ(0u, ToTU->getASTContext().getDiagnostics().getNumWarnings());\n  EXPECT_EQ(1u,\n            DeclCounter<RecordDecl>().match(ToTU, recordDecl(hasName(\"X\"))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, AnonymousRecordsReversed) {\n  Decl *FromTU0 = getTuDecl(\n      R\"(\n      struct X {\n        struct { int a; };\n        struct { int b; };\n      };\n      )\",\n      Lang_C99, \"input0.c\");\n\n  Decl *FromTU1 = getTuDecl(\n      R\"(\n      struct X { // reversed order\n        struct { int b; };\n        struct { int a; };\n      };\n      )\",\n      Lang_C99, \"input1.c\");\n\n  auto *X0 =\n      FirstDeclMatcher<RecordDecl>().match(FromTU0, recordDecl(hasName(\"X\")));\n  auto *X1 =\n      FirstDeclMatcher<RecordDecl>().match(FromTU1, recordDecl(hasName(\"X\")));\n  Import(X0, Lang_C99);\n  Import(X1, Lang_C99);\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  // We expect one (ODR) warning during the import.\n  EXPECT_EQ(1u, ToTU->getASTContext().getDiagnostics().getNumWarnings());\n  EXPECT_EQ(1u,\n            DeclCounter<RecordDecl>().match(ToTU, recordDecl(hasName(\"X\"))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportDoesUpdateUsedFlag) {\n  auto Pattern = varDecl(hasName(\"x\"));\n  VarDecl *Imported1;\n  {\n    Decl *FromTU = getTuDecl(\"extern int x;\", Lang_CXX03, \"input0.cc\");\n    auto *FromD = FirstDeclMatcher<VarDecl>().match(FromTU, Pattern);\n    Imported1 = cast<VarDecl>(Import(FromD, Lang_CXX03));\n  }\n  VarDecl *Imported2;\n  {\n    Decl *FromTU = getTuDecl(\"int x;\", Lang_CXX03, \"input1.cc\");\n    auto *FromD = FirstDeclMatcher<VarDecl>().match(FromTU, Pattern);\n    Imported2 = cast<VarDecl>(Import(FromD, Lang_CXX03));\n  }\n  EXPECT_EQ(Imported1->getCanonicalDecl(), Imported2->getCanonicalDecl());\n  EXPECT_FALSE(Imported2->isUsed(false));\n  {\n    Decl *FromTU = getTuDecl(\"extern int x; int f() { return x; }\", Lang_CXX03,\n                             \"input2.cc\");\n    auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"f\")));\n    Import(FromD, Lang_CXX03);\n  }\n  EXPECT_TRUE(Imported2->isUsed(false));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportDoesUpdateUsedFlag2) {\n  auto Pattern = varDecl(hasName(\"x\"));\n  VarDecl *ExistingD;\n  {\n    Decl *ToTU = getToTuDecl(\"int x = 1;\", Lang_CXX03);\n    ExistingD = FirstDeclMatcher<VarDecl>().match(ToTU, Pattern);\n  }\n  EXPECT_FALSE(ExistingD->isUsed(false));\n  {\n    Decl *FromTU =\n        getTuDecl(\"int x = 1; int f() { return x; }\", Lang_CXX03, \"input1.cc\");\n    auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"f\")));\n    Import(FromD, Lang_CXX03);\n  }\n  EXPECT_TRUE(ExistingD->isUsed(false));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportDoesUpdateUsedFlag3) {\n  auto Pattern = varDecl(hasName(\"a\"));\n  VarDecl *ExistingD;\n  {\n    Decl *ToTU = getToTuDecl(\n        R\"(\n        struct A {\n          static const int a = 1;\n        };\n        )\",\n        Lang_CXX03);\n    ExistingD = FirstDeclMatcher<VarDecl>().match(ToTU, Pattern);\n  }\n  EXPECT_FALSE(ExistingD->isUsed(false));\n  {\n    Decl *FromTU = getTuDecl(\n        R\"(\n        struct A {\n          static const int a = 1;\n        };\n        const int *f() { return &A::a; } // requires storage,\n                                         // thus used flag will be set\n        )\",\n        Lang_CXX03, \"input1.cc\");\n    auto *FromFunD = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"f\")));\n    auto *FromD = FirstDeclMatcher<VarDecl>().match(FromTU, Pattern);\n    ASSERT_TRUE(FromD->isUsed(false));\n    Import(FromFunD, Lang_CXX03);\n  }\n  EXPECT_TRUE(ExistingD->isUsed(false));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ReimportWithUsedFlag) {\n  auto Pattern = varDecl(hasName(\"x\"));\n\n  Decl *FromTU = getTuDecl(\"int x;\", Lang_CXX03, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<VarDecl>().match(FromTU, Pattern);\n\n  auto *Imported1 = cast<VarDecl>(Import(FromD, Lang_CXX03));\n\n  ASSERT_FALSE(Imported1->isUsed(false));\n\n  FromD->setIsUsed();\n  auto *Imported2 = cast<VarDecl>(Import(FromD, Lang_CXX03));\n\n  EXPECT_EQ(Imported1, Imported2);\n  EXPECT_TRUE(Imported2->isUsed(false));\n}\n\nstruct ImportFunctions : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportFunctions, ImportPrototypeOfRecursiveFunction) {\n  Decl *FromTU = getTuDecl(\"void f(); void f() { f(); }\", Lang_CXX03);\n  auto Pattern = functionDecl(hasName(\"f\"));\n  auto *From =\n      FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern); // Proto\n\n  Decl *ImportedD = Import(From, Lang_CXX03);\n  Decl *ToTU = ImportedD->getTranslationUnitDecl();\n\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  auto *To0 = FirstDeclMatcher<FunctionDecl>().match(ToTU, Pattern);\n  auto *To1 = LastDeclMatcher<FunctionDecl>().match(ToTU, Pattern);\n  EXPECT_TRUE(ImportedD == To0);\n  EXPECT_FALSE(To0->doesThisDeclarationHaveABody());\n  EXPECT_TRUE(To1->doesThisDeclarationHaveABody());\n  EXPECT_EQ(To1->getPreviousDecl(), To0);\n}\n\nTEST_P(ImportFunctions, ImportDefinitionOfRecursiveFunction) {\n  Decl *FromTU = getTuDecl(\"void f(); void f() { f(); }\", Lang_CXX03);\n  auto Pattern = functionDecl(hasName(\"f\"));\n  auto *From =\n      LastDeclMatcher<FunctionDecl>().match(FromTU, Pattern); // Def\n\n  Decl *ImportedD = Import(From, Lang_CXX03);\n  Decl *ToTU = ImportedD->getTranslationUnitDecl();\n\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  auto *To0 = FirstDeclMatcher<FunctionDecl>().match(ToTU, Pattern);\n  auto *To1 = LastDeclMatcher<FunctionDecl>().match(ToTU, Pattern);\n  EXPECT_TRUE(ImportedD == To1);\n  EXPECT_FALSE(To0->doesThisDeclarationHaveABody());\n  EXPECT_TRUE(To1->doesThisDeclarationHaveABody());\n  EXPECT_EQ(To1->getPreviousDecl(), To0);\n}\n\nTEST_P(ImportFunctions, OverriddenMethodsShouldBeImported) {\n  auto Code =\n      R\"(\n      struct B { virtual void f(); };\n      void B::f() {}\n      struct D : B { void f(); };\n      )\";\n  auto Pattern =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"D\"))));\n  Decl *FromTU = getTuDecl(Code, Lang_CXX03);\n  CXXMethodDecl *Proto =\n      FirstDeclMatcher<CXXMethodDecl>().match(FromTU, Pattern);\n\n  ASSERT_EQ(Proto->size_overridden_methods(), 1u);\n  CXXMethodDecl *To = cast<CXXMethodDecl>(Import(Proto, Lang_CXX03));\n  EXPECT_EQ(To->size_overridden_methods(), 1u);\n}\n\nTEST_P(ImportFunctions, VirtualFlagShouldBePreservedWhenImportingPrototype) {\n  auto Code =\n      R\"(\n      struct B { virtual void f(); };\n      void B::f() {}\n      )\";\n  auto Pattern =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"B\"))));\n  Decl *FromTU = getTuDecl(Code, Lang_CXX03);\n  CXXMethodDecl *Proto =\n      FirstDeclMatcher<CXXMethodDecl>().match(FromTU, Pattern);\n  CXXMethodDecl *Def = LastDeclMatcher<CXXMethodDecl>().match(FromTU, Pattern);\n\n  ASSERT_TRUE(Proto->isVirtual());\n  ASSERT_TRUE(Def->isVirtual());\n  CXXMethodDecl *To = cast<CXXMethodDecl>(Import(Proto, Lang_CXX03));\n  EXPECT_TRUE(To->isVirtual());\n}\n\nTEST_P(ImportFunctions,\n       ImportDefinitionIfThereIsAnExistingDefinitionAndFwdDecl) {\n  Decl *ToTU = getToTuDecl(\n      R\"(\n      void f() {}\n      void f();\n      )\",\n      Lang_CXX03);\n  ASSERT_EQ(1u,\n            DeclCounterWithPredicate<FunctionDecl>([](const FunctionDecl *FD) {\n              return FD->doesThisDeclarationHaveABody();\n            }).match(ToTU, functionDecl()));\n\n  Decl *FromTU = getTuDecl(\"void f() {}\", Lang_CXX03, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, functionDecl());\n\n  Import(FromD, Lang_CXX03);\n\n  EXPECT_EQ(1u,\n            DeclCounterWithPredicate<FunctionDecl>([](const FunctionDecl *FD) {\n              return FD->doesThisDeclarationHaveABody();\n            }).match(ToTU, functionDecl()));\n}\n\nTEST_P(ImportFunctions, ImportOverriddenMethodTwice) {\n  auto Code =\n      R\"(\n      struct B { virtual void f(); };\n      struct D:B { void f(); };\n      )\";\n  auto BFP =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"B\"))));\n  auto DFP =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"D\"))));\n\n  Decl *FromTU0 = getTuDecl(Code, Lang_CXX03);\n  auto *DF = FirstDeclMatcher<CXXMethodDecl>().match(FromTU0, DFP);\n  Import(DF, Lang_CXX03);\n\n  Decl *FromTU1 = getTuDecl(Code, Lang_CXX03, \"input1.cc\");\n  auto *BF = FirstDeclMatcher<CXXMethodDecl>().match(FromTU1, BFP);\n  Import(BF, Lang_CXX03);\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, BFP), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, DFP), 1u);\n}\n\nTEST_P(ImportFunctions, ImportOverriddenMethodTwiceDefinitionFirst) {\n  auto CodeWithoutDef =\n      R\"(\n      struct B { virtual void f(); };\n      struct D:B { void f(); };\n      )\";\n  auto CodeWithDef =\n      R\"(\n    struct B { virtual void f(){}; };\n    struct D:B { void f(){}; };\n  )\";\n  auto BFP =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"B\"))));\n  auto DFP =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"D\"))));\n  auto BFDefP = cxxMethodDecl(\n      hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"B\"))), isDefinition());\n  auto DFDefP = cxxMethodDecl(\n      hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"D\"))), isDefinition());\n  auto FDefAllP = cxxMethodDecl(hasName(\"f\"), isDefinition());\n\n  {\n    Decl *FromTU = getTuDecl(CodeWithDef, Lang_CXX03, \"input0.cc\");\n    auto *FromD = FirstDeclMatcher<CXXMethodDecl>().match(FromTU, DFP);\n    Import(FromD, Lang_CXX03);\n  }\n  {\n    Decl *FromTU = getTuDecl(CodeWithoutDef, Lang_CXX03, \"input1.cc\");\n    auto *FromB = FirstDeclMatcher<CXXMethodDecl>().match(FromTU, BFP);\n    Import(FromB, Lang_CXX03);\n  }\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, BFP), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, DFP), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, BFDefP), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, DFDefP), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, FDefAllP), 2u);\n}\n\nTEST_P(ImportFunctions, ImportOverriddenMethodTwiceOutOfClassDef) {\n  auto Code =\n      R\"(\n      struct B { virtual void f(); };\n      struct D:B { void f(); };\n      void B::f(){};\n      )\";\n\n  auto BFP =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"B\"))));\n  auto BFDefP = cxxMethodDecl(\n      hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"B\"))), isDefinition());\n  auto DFP = cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"D\"))),\n                           unless(isDefinition()));\n\n  Decl *FromTU0 = getTuDecl(Code, Lang_CXX03);\n  auto *D = FirstDeclMatcher<CXXMethodDecl>().match(FromTU0, DFP);\n  Import(D, Lang_CXX03);\n\n  Decl *FromTU1 = getTuDecl(Code, Lang_CXX03, \"input1.cc\");\n  auto *B = FirstDeclMatcher<CXXMethodDecl>().match(FromTU1, BFP);\n  Import(B, Lang_CXX03);\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, BFP), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, BFDefP), 0u);\n\n  auto *ToB = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"B\")));\n  auto *ToBFInClass = FirstDeclMatcher<CXXMethodDecl>().match(ToTU, BFP);\n  auto *ToBFOutOfClass = FirstDeclMatcher<CXXMethodDecl>().match(\n      ToTU, cxxMethodDecl(hasName(\"f\"), isDefinition()));\n\n  // The definition should be out-of-class.\n  EXPECT_NE(ToBFInClass, ToBFOutOfClass);\n  EXPECT_NE(ToBFInClass->getLexicalDeclContext(),\n            ToBFOutOfClass->getLexicalDeclContext());\n  EXPECT_EQ(ToBFOutOfClass->getDeclContext(), ToB);\n  EXPECT_EQ(ToBFOutOfClass->getLexicalDeclContext(), ToTU);\n\n  // Check that the redecl chain is intact.\n  EXPECT_EQ(ToBFOutOfClass->getPreviousDecl(), ToBFInClass);\n}\n\nTEST_P(ImportFunctions,\n       ImportOverriddenMethodTwiceOutOfClassDefInSeparateCode) {\n  auto CodeTU0 =\n      R\"(\n      struct B { virtual void f(); };\n      struct D:B { void f(); };\n      )\";\n  auto CodeTU1 =\n      R\"(\n      struct B { virtual void f(); };\n      struct D:B { void f(); };\n      void B::f(){}\n      void D::f(){}\n      void foo(B &b, D &d) { b.f(); d.f(); }\n      )\";\n\n  auto BFP =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"B\"))));\n  auto BFDefP = cxxMethodDecl(\n      hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"B\"))), isDefinition());\n  auto DFP =\n      cxxMethodDecl(hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"D\"))));\n  auto DFDefP = cxxMethodDecl(\n      hasName(\"f\"), hasParent(cxxRecordDecl(hasName(\"D\"))), isDefinition());\n  auto FooDef = functionDecl(hasName(\"foo\"));\n\n  {\n    Decl *FromTU0 = getTuDecl(CodeTU0, Lang_CXX03, \"input0.cc\");\n    auto *D = FirstDeclMatcher<CXXMethodDecl>().match(FromTU0, DFP);\n    Import(D, Lang_CXX03);\n  }\n\n  {\n    Decl *FromTU1 = getTuDecl(CodeTU1, Lang_CXX03, \"input1.cc\");\n    auto *Foo = FirstDeclMatcher<FunctionDecl>().match(FromTU1, FooDef);\n    Import(Foo, Lang_CXX03);\n  }\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, BFP), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, DFP), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, BFDefP), 0u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, DFDefP), 0u);\n\n  auto *ToB = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"B\")));\n  auto *ToD = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"D\")));\n  auto *ToBFInClass = FirstDeclMatcher<CXXMethodDecl>().match(ToTU, BFP);\n  auto *ToBFOutOfClass = FirstDeclMatcher<CXXMethodDecl>().match(\n      ToTU, cxxMethodDecl(hasName(\"f\"), isDefinition()));\n  auto *ToDFInClass = FirstDeclMatcher<CXXMethodDecl>().match(ToTU, DFP);\n  auto *ToDFOutOfClass = LastDeclMatcher<CXXMethodDecl>().match(\n      ToTU, cxxMethodDecl(hasName(\"f\"), isDefinition()));\n\n  // The definition should be out-of-class.\n  EXPECT_NE(ToBFInClass, ToBFOutOfClass);\n  EXPECT_NE(ToBFInClass->getLexicalDeclContext(),\n            ToBFOutOfClass->getLexicalDeclContext());\n  EXPECT_EQ(ToBFOutOfClass->getDeclContext(), ToB);\n  EXPECT_EQ(ToBFOutOfClass->getLexicalDeclContext(), ToTU);\n\n  EXPECT_NE(ToDFInClass, ToDFOutOfClass);\n  EXPECT_NE(ToDFInClass->getLexicalDeclContext(),\n            ToDFOutOfClass->getLexicalDeclContext());\n  EXPECT_EQ(ToDFOutOfClass->getDeclContext(), ToD);\n  EXPECT_EQ(ToDFOutOfClass->getLexicalDeclContext(), ToTU);\n\n  // Check that the redecl chain is intact.\n  EXPECT_EQ(ToBFOutOfClass->getPreviousDecl(), ToBFInClass);\n  EXPECT_EQ(ToDFOutOfClass->getPreviousDecl(), ToDFInClass);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportVariableChainInC) {\n    std::string Code = \"static int v; static int v = 0;\";\n    auto Pattern = varDecl(hasName(\"v\"));\n\n    TranslationUnitDecl *FromTu = getTuDecl(Code, Lang_C99, \"input0.c\");\n\n    auto *From0 = FirstDeclMatcher<VarDecl>().match(FromTu, Pattern);\n    auto *From1 = LastDeclMatcher<VarDecl>().match(FromTu, Pattern);\n\n    auto *To0 = Import(From0, Lang_C99);\n    auto *To1 = Import(From1, Lang_C99);\n\n    EXPECT_TRUE(To0);\n    ASSERT_TRUE(To1);\n    EXPECT_NE(To0, To1);\n    EXPECT_EQ(To1->getPreviousDecl(), To0);\n}\n\nTEST_P(ImportFunctions, ImportFromDifferentScopedAnonNamespace) {\n  TranslationUnitDecl *FromTu =\n      getTuDecl(\"namespace NS0 { namespace { void f(); } }\"\n                \"namespace NS1 { namespace { void f(); } }\",\n                Lang_CXX03, \"input0.cc\");\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  auto *FromF0 = FirstDeclMatcher<FunctionDecl>().match(FromTu, Pattern);\n  auto *FromF1 = LastDeclMatcher<FunctionDecl>().match(FromTu, Pattern);\n\n  auto *ToF0 = Import(FromF0, Lang_CXX03);\n  auto *ToF1 = Import(FromF1, Lang_CXX03);\n\n  EXPECT_TRUE(ToF0);\n  ASSERT_TRUE(ToF1);\n  EXPECT_NE(ToF0, ToF1);\n  EXPECT_FALSE(ToF1->getPreviousDecl());\n}\n\nTEST_P(ImportFunctions, ImportFunctionFromUnnamedNamespace) {\n  {\n    Decl *FromTU = getTuDecl(\"namespace { void f() {} } void g0() { f(); }\",\n                             Lang_CXX03, \"input0.cc\");\n    auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"g0\")));\n\n    Import(FromD, Lang_CXX03);\n  }\n  {\n    Decl *FromTU =\n        getTuDecl(\"namespace { void f() { int a; } } void g1() { f(); }\",\n                  Lang_CXX03, \"input1.cc\");\n    auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"g1\")));\n    Import(FromD, Lang_CXX03);\n  }\n\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, functionDecl(hasName(\"f\"))),\n            2u);\n}\n\nTEST_P(ImportFunctions, ImportImplicitFunctionsInLambda) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      void foo() {\n        (void)[]() { ; };\n      }\n      )\",\n      Lang_CXX11);\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"foo\")));\n  auto *ToD = Import(FromD, Lang_CXX03);\n  EXPECT_TRUE(ToD);\n  CXXRecordDecl *LambdaRec =\n      cast<LambdaExpr>(cast<CStyleCastExpr>(\n                           *cast<CompoundStmt>(ToD->getBody())->body_begin())\n                           ->getSubExpr())\n          ->getLambdaClass();\n  EXPECT_TRUE(LambdaRec->getDestructor());\n}\n\nTEST_P(ImportFunctions,\n       CallExprOfMemberFunctionTemplateWithExplicitTemplateArgs) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct X {\n        template <typename T>\n        void foo(){}\n      };\n      void f() {\n        X x;\n        x.foo<int>();\n      }\n      )\",\n      Lang_CXX03);\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n  auto *ToD = Import(FromD, Lang_CXX03);\n  EXPECT_TRUE(ToD);\n  EXPECT_TRUE(MatchVerifier<FunctionDecl>().match(\n      ToD, functionDecl(hasName(\"f\"), hasDescendant(declRefExpr()))));\n}\n\nTEST_P(ImportFunctions,\n       DependentCallExprOfMemberFunctionTemplateWithExplicitTemplateArgs) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct X {\n        template <typename T>\n        void foo(){}\n      };\n      template <typename T>\n      void f() {\n        X x;\n        x.foo<T>();\n      }\n      void g() {\n        f<int>();\n      }\n      )\",\n      Lang_CXX03);\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"g\")));\n  auto *ToD = Import(FromD, Lang_CXX03);\n  EXPECT_TRUE(ToD);\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  EXPECT_TRUE(MatchVerifier<TranslationUnitDecl>().match(\n      ToTU, translationUnitDecl(hasDescendant(\n                functionDecl(hasName(\"f\"), hasDescendant(declRefExpr()))))));\n}\n\nstruct ImportFunctionTemplates : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportFunctionTemplates, ImportFunctionTemplateInRecordDeclTwice) {\n  auto Code =\n      R\"(\n      class X {\n        template <class T>\n        void f(T t);\n      };\n      )\";\n  Decl *FromTU1 = getTuDecl(Code, Lang_CXX03, \"input1.cc\");\n  auto *FromD1 = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      FromTU1, functionTemplateDecl(hasName(\"f\")));\n  auto *ToD1 = Import(FromD1, Lang_CXX03);\n  Decl *FromTU2 = getTuDecl(Code, Lang_CXX03, \"input2.cc\");\n  auto *FromD2 = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      FromTU2, functionTemplateDecl(hasName(\"f\")));\n  auto *ToD2 = Import(FromD2, Lang_CXX03);\n  EXPECT_EQ(ToD1, ToD2);\n}\n\nTEST_P(ImportFunctionTemplates,\n       ImportFunctionTemplateWithDefInRecordDeclTwice) {\n  auto Code =\n      R\"(\n      class X {\n        template <class T>\n        void f(T t);\n      };\n      template <class T>\n      void X::f(T t) {};\n      )\";\n  Decl *FromTU1 = getTuDecl(Code, Lang_CXX03, \"input1.cc\");\n  auto *FromD1 = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      FromTU1, functionTemplateDecl(hasName(\"f\")));\n  auto *ToD1 = Import(FromD1, Lang_CXX03);\n  Decl *FromTU2 = getTuDecl(Code, Lang_CXX03, \"input2.cc\");\n  auto *FromD2 = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      FromTU2, functionTemplateDecl(hasName(\"f\")));\n  auto *ToD2 = Import(FromD2, Lang_CXX03);\n  EXPECT_EQ(ToD1, ToD2);\n}\n\nTEST_P(ImportFunctionTemplates,\n       ImportFunctionWhenThereIsAFunTemplateWithSameName) {\n  getToTuDecl(\n      R\"(\n      template <typename T>\n      void foo(T) {}\n      void foo();\n      )\",\n      Lang_CXX03);\n  Decl *FromTU = getTuDecl(\"void foo();\", Lang_CXX03);\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"foo\")));\n  auto *ImportedD = Import(FromD, Lang_CXX03);\n  EXPECT_TRUE(ImportedD);\n}\n\nTEST_P(ImportFunctionTemplates,\n       ImportConstructorWhenThereIsAFunTemplateWithSameName) {\n  auto Code =\n      R\"(\n      struct Foo {\n        template <typename T>\n        Foo(T) {}\n        Foo();\n      };\n      )\";\n  getToTuDecl(Code, Lang_CXX03);\n  Decl *FromTU = getTuDecl(Code, Lang_CXX03);\n  auto *FromD =\n      LastDeclMatcher<CXXConstructorDecl>().match(FromTU, cxxConstructorDecl());\n  auto *ImportedD = Import(FromD, Lang_CXX03);\n  EXPECT_TRUE(ImportedD);\n}\n\nTEST_P(ImportFunctionTemplates,\n       ImportOperatorWhenThereIsAFunTemplateWithSameName) {\n  getToTuDecl(\n      R\"(\n      template <typename T>\n      void operator<(T,T) {}\n      struct X{};\n      void operator<(X, X);\n      )\",\n      Lang_CXX03);\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct X{};\n      void operator<(X, X);\n      )\",\n      Lang_CXX03);\n  auto *FromD = LastDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasOverloadedOperatorName(\"<\")));\n  auto *ImportedD = Import(FromD, Lang_CXX03);\n  EXPECT_TRUE(ImportedD);\n}\n\nstruct ImportFriendFunctions : ImportFunctions {};\n\nTEST_P(ImportFriendFunctions, ImportFriendFunctionRedeclChainProto) {\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  Decl *FromTU = getTuDecl(\"struct X { friend void f(); };\"\n                           \"void f();\",\n                           Lang_CXX03, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n\n  auto *ImportedD = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  EXPECT_FALSE(ImportedD->doesThisDeclarationHaveABody());\n  auto *ToFD = LastDeclMatcher<FunctionDecl>().match(ToTU, Pattern);\n  EXPECT_FALSE(ToFD->doesThisDeclarationHaveABody());\n  EXPECT_EQ(ToFD->getPreviousDecl(), ImportedD);\n}\n\nTEST_P(ImportFriendFunctions,\n       ImportFriendFunctionRedeclChainProto_OutOfClassProtoFirst) {\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  Decl *FromTU = getTuDecl(\"void f();\"\n                           \"struct X { friend void f(); };\",\n                           Lang_CXX03, \"input0.cc\");\n  auto FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n\n  auto *ImportedD = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  EXPECT_FALSE(ImportedD->doesThisDeclarationHaveABody());\n  auto *ToFD = LastDeclMatcher<FunctionDecl>().match(ToTU, Pattern);\n  EXPECT_FALSE(ToFD->doesThisDeclarationHaveABody());\n  EXPECT_EQ(ToFD->getPreviousDecl(), ImportedD);\n}\n\nTEST_P(ImportFriendFunctions, ImportFriendFunctionRedeclChainDef) {\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  Decl *FromTU = getTuDecl(\"struct X { friend void f(){} };\"\n                           \"void f();\",\n                           Lang_CXX03, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n\n  auto *ImportedD = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  EXPECT_TRUE(ImportedD->doesThisDeclarationHaveABody());\n  auto *ToFD = LastDeclMatcher<FunctionDecl>().match(ToTU, Pattern);\n  EXPECT_FALSE(ToFD->doesThisDeclarationHaveABody());\n  EXPECT_EQ(ToFD->getPreviousDecl(), ImportedD);\n}\n\nTEST_P(ImportFriendFunctions,\n       ImportFriendFunctionRedeclChainDef_OutOfClassDef) {\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  Decl *FromTU = getTuDecl(\"struct X { friend void f(); };\"\n                           \"void f(){}\",\n                           Lang_CXX03, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n\n  auto *ImportedD = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  EXPECT_FALSE(ImportedD->doesThisDeclarationHaveABody());\n  auto *ToFD = LastDeclMatcher<FunctionDecl>().match(ToTU, Pattern);\n  EXPECT_TRUE(ToFD->doesThisDeclarationHaveABody());\n  EXPECT_EQ(ToFD->getPreviousDecl(), ImportedD);\n}\n\nTEST_P(ImportFriendFunctions, ImportFriendFunctionRedeclChainDefWithClass) {\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n        class X;\n        void f(X *x){}\n        class X{\n        friend void f(X *x);\n        };\n      )\",\n      Lang_CXX03, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n\n  auto *ImportedD = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  EXPECT_TRUE(ImportedD->doesThisDeclarationHaveABody());\n  auto *InClassFD = cast<FunctionDecl>(FirstDeclMatcher<FriendDecl>()\n                                              .match(ToTU, friendDecl())\n                                              ->getFriendDecl());\n  EXPECT_FALSE(InClassFD->doesThisDeclarationHaveABody());\n  EXPECT_EQ(InClassFD->getPreviousDecl(), ImportedD);\n  // The parameters must refer the same type\n  EXPECT_EQ((*InClassFD->param_begin())->getOriginalType(),\n            (*ImportedD->param_begin())->getOriginalType());\n}\n\nTEST_P(ImportFriendFunctions,\n       ImportFriendFunctionRedeclChainDefWithClass_ImportTheProto) {\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n        class X;\n        void f(X *x){}\n        class X{\n        friend void f(X *x);\n        };\n      )\",\n      Lang_CXX03, \"input0.cc\");\n  auto *FromD = LastDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n\n  auto *ImportedD = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  EXPECT_FALSE(ImportedD->doesThisDeclarationHaveABody());\n  auto *OutOfClassFD = FirstDeclMatcher<FunctionDecl>().match(\n      ToTU, functionDecl(unless(hasParent(friendDecl()))));\n\n  EXPECT_TRUE(OutOfClassFD->doesThisDeclarationHaveABody());\n  EXPECT_EQ(ImportedD->getPreviousDecl(), OutOfClassFD);\n  // The parameters must refer the same type\n  EXPECT_EQ((*OutOfClassFD->param_begin())->getOriginalType(),\n            (*ImportedD->param_begin())->getOriginalType());\n}\n\nTEST_P(ImportFriendFunctions, ImportFriendFunctionFromMultipleTU) {\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  FunctionDecl *ImportedD;\n  {\n    Decl *FromTU =\n        getTuDecl(\"struct X { friend void f(){} };\", Lang_CXX03, \"input0.cc\");\n    auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n    ImportedD = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  }\n  FunctionDecl *ImportedD1;\n  {\n    Decl *FromTU = getTuDecl(\"void f();\", Lang_CXX03, \"input1.cc\");\n    auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, Pattern);\n    ImportedD1 = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  }\n\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n  EXPECT_TRUE(ImportedD->doesThisDeclarationHaveABody());\n  EXPECT_FALSE(ImportedD1->doesThisDeclarationHaveABody());\n  EXPECT_EQ(ImportedD1->getPreviousDecl(), ImportedD);\n}\n\nTEST_P(ImportFriendFunctions, Lookup) {\n  auto FunctionPattern = functionDecl(hasName(\"f\"));\n  auto ClassPattern = cxxRecordDecl(hasName(\"X\"));\n\n  TranslationUnitDecl *FromTU =\n      getTuDecl(\"struct X { friend void f(); };\", Lang_CXX03, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU, FunctionPattern);\n  ASSERT_TRUE(FromD->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  ASSERT_FALSE(FromD->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  {\n    auto FromName = FromD->getDeclName();\n    auto *Class = FirstDeclMatcher<CXXRecordDecl>().match(FromTU, ClassPattern);\n    auto LookupRes = Class->noload_lookup(FromName);\n    ASSERT_EQ(LookupRes.size(), 0u);\n    LookupRes = FromTU->noload_lookup(FromName);\n    ASSERT_EQ(LookupRes.size(), 1u);\n  }\n\n  auto *ToD = cast<FunctionDecl>(Import(FromD, Lang_CXX03));\n  auto ToName = ToD->getDeclName();\n\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  auto *Class = FirstDeclMatcher<CXXRecordDecl>().match(ToTU, ClassPattern);\n  auto LookupRes = Class->noload_lookup(ToName);\n  EXPECT_EQ(LookupRes.size(), 0u);\n  LookupRes = ToTU->noload_lookup(ToName);\n  EXPECT_EQ(LookupRes.size(), 1u);\n\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, FunctionPattern), 1u);\n  auto *To0 = FirstDeclMatcher<FunctionDecl>().match(ToTU, FunctionPattern);\n  EXPECT_TRUE(To0->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  EXPECT_FALSE(To0->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n}\n\nTEST_P(ImportFriendFunctions, LookupWithProtoAfter) {\n  auto FunctionPattern = functionDecl(hasName(\"f\"));\n  auto ClassPattern = cxxRecordDecl(hasName(\"X\"));\n\n  TranslationUnitDecl *FromTU =\n      getTuDecl(\"struct X { friend void f(); };\"\n                // This proto decl makes f available to normal\n                // lookup, otherwise it is hidden.\n                // Normal C++ lookup (implemented in\n                // `clang::Sema::CppLookupName()` and in `LookupDirect()`)\n                // returns the found `NamedDecl` only if the set IDNS is matched\n                \"void f();\",\n                Lang_CXX03, \"input0.cc\");\n  auto *FromFriend =\n      FirstDeclMatcher<FunctionDecl>().match(FromTU, FunctionPattern);\n  auto *FromNormal =\n      LastDeclMatcher<FunctionDecl>().match(FromTU, FunctionPattern);\n  ASSERT_TRUE(FromFriend->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  ASSERT_FALSE(FromFriend->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  ASSERT_FALSE(FromNormal->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  ASSERT_TRUE(FromNormal->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n\n  auto FromName = FromFriend->getDeclName();\n  auto *FromClass =\n      FirstDeclMatcher<CXXRecordDecl>().match(FromTU, ClassPattern);\n  auto LookupRes = FromClass->noload_lookup(FromName);\n  ASSERT_EQ(LookupRes.size(), 0u);\n  LookupRes = FromTU->noload_lookup(FromName);\n  ASSERT_EQ(LookupRes.size(), 1u);\n\n  auto *ToFriend = cast<FunctionDecl>(Import(FromFriend, Lang_CXX03));\n  auto ToName = ToFriend->getDeclName();\n\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  auto *ToClass = FirstDeclMatcher<CXXRecordDecl>().match(ToTU, ClassPattern);\n  LookupRes = ToClass->noload_lookup(ToName);\n  EXPECT_EQ(LookupRes.size(), 0u);\n  LookupRes = ToTU->noload_lookup(ToName);\n  // Test is disabled because this result is 2.\n  EXPECT_EQ(LookupRes.size(), 1u);\n\n  ASSERT_EQ(DeclCounter<FunctionDecl>().match(ToTU, FunctionPattern), 2u);\n  ToFriend = FirstDeclMatcher<FunctionDecl>().match(ToTU, FunctionPattern);\n  auto *ToNormal = LastDeclMatcher<FunctionDecl>().match(ToTU, FunctionPattern);\n  EXPECT_TRUE(ToFriend->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  EXPECT_FALSE(ToFriend->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  EXPECT_FALSE(ToNormal->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  EXPECT_TRUE(ToNormal->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n}\n\nTEST_P(ImportFriendFunctions, LookupWithProtoBefore) {\n  auto FunctionPattern = functionDecl(hasName(\"f\"));\n  auto ClassPattern = cxxRecordDecl(hasName(\"X\"));\n\n  TranslationUnitDecl *FromTU = getTuDecl(\"void f();\"\n                                          \"struct X { friend void f(); };\",\n                                          Lang_CXX03, \"input0.cc\");\n  auto *FromNormal =\n      FirstDeclMatcher<FunctionDecl>().match(FromTU, FunctionPattern);\n  auto *FromFriend =\n      LastDeclMatcher<FunctionDecl>().match(FromTU, FunctionPattern);\n  ASSERT_FALSE(FromNormal->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  ASSERT_TRUE(FromNormal->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  ASSERT_TRUE(FromFriend->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  ASSERT_TRUE(FromFriend->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n\n  auto FromName = FromNormal->getDeclName();\n  auto *FromClass =\n      FirstDeclMatcher<CXXRecordDecl>().match(FromTU, ClassPattern);\n  auto LookupRes = FromClass->noload_lookup(FromName);\n  ASSERT_EQ(LookupRes.size(), 0u);\n  LookupRes = FromTU->noload_lookup(FromName);\n  ASSERT_EQ(LookupRes.size(), 1u);\n\n  auto *ToNormal = cast<FunctionDecl>(Import(FromNormal, Lang_CXX03));\n  auto ToName = ToNormal->getDeclName();\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n\n  auto *ToClass = FirstDeclMatcher<CXXRecordDecl>().match(ToTU, ClassPattern);\n  LookupRes = ToClass->noload_lookup(ToName);\n  EXPECT_EQ(LookupRes.size(), 0u);\n  LookupRes = ToTU->noload_lookup(ToName);\n  EXPECT_EQ(LookupRes.size(), 1u);\n\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, FunctionPattern), 2u);\n  ToNormal = FirstDeclMatcher<FunctionDecl>().match(ToTU, FunctionPattern);\n  auto *ToFriend = LastDeclMatcher<FunctionDecl>().match(ToTU, FunctionPattern);\n  EXPECT_FALSE(ToNormal->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  EXPECT_TRUE(ToNormal->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  EXPECT_TRUE(ToFriend->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  EXPECT_TRUE(ToFriend->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n}\n\nTEST_P(ImportFriendFunctions, ImportFriendChangesLookup) {\n  auto Pattern = functionDecl(hasName(\"f\"));\n\n  TranslationUnitDecl *FromNormalTU =\n      getTuDecl(\"void f();\", Lang_CXX03, \"input0.cc\");\n  auto *FromNormalF =\n      FirstDeclMatcher<FunctionDecl>().match(FromNormalTU, Pattern);\n  TranslationUnitDecl *FromFriendTU =\n      getTuDecl(\"class X { friend void f(); };\", Lang_CXX03, \"input1.cc\");\n  auto *FromFriendF =\n      FirstDeclMatcher<FunctionDecl>().match(FromFriendTU, Pattern);\n  auto FromNormalName = FromNormalF->getDeclName();\n  auto FromFriendName = FromFriendF->getDeclName();\n\n  ASSERT_TRUE(FromNormalF->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  ASSERT_FALSE(FromNormalF->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  ASSERT_FALSE(FromFriendF->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  ASSERT_TRUE(FromFriendF->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  auto LookupRes = FromNormalTU->noload_lookup(FromNormalName);\n  ASSERT_EQ(LookupRes.size(), 1u);\n  LookupRes = FromFriendTU->noload_lookup(FromFriendName);\n  ASSERT_EQ(LookupRes.size(), 1u);\n\n  auto *ToNormalF = cast<FunctionDecl>(Import(FromNormalF, Lang_CXX03));\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  auto ToName = ToNormalF->getDeclName();\n  EXPECT_TRUE(ToNormalF->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  EXPECT_FALSE(ToNormalF->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n  LookupRes = ToTU->noload_lookup(ToName);\n  EXPECT_EQ(LookupRes.size(), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 1u);\n\n  auto *ToFriendF = cast<FunctionDecl>(Import(FromFriendF, Lang_CXX03));\n  LookupRes = ToTU->noload_lookup(ToName);\n  EXPECT_EQ(LookupRes.size(), 1u);\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, Pattern), 2u);\n\n  EXPECT_TRUE(ToNormalF->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  EXPECT_FALSE(ToNormalF->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n\n  EXPECT_TRUE(ToFriendF->isInIdentifierNamespace(Decl::IDNS_Ordinary));\n  EXPECT_TRUE(ToFriendF->isInIdentifierNamespace(Decl::IDNS_OrdinaryFriend));\n}\n\nTEST_P(ImportFriendFunctions, ImportFriendList) {\n  TranslationUnitDecl *FromTU = getTuDecl(\"struct X { friend void f(); };\"\n                                          \"void f();\",\n                                          Lang_CXX03, \"input0.cc\");\n  auto *FromFriendF = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n\n  auto *FromClass = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"X\")));\n  auto *FromFriend = FirstDeclMatcher<FriendDecl>().match(FromTU, friendDecl());\n  auto FromFriends = FromClass->friends();\n  unsigned int FrN = 0;\n  for (auto Fr : FromFriends) {\n    ASSERT_EQ(Fr, FromFriend);\n    ++FrN;\n  }\n  ASSERT_EQ(FrN, 1u);\n\n  Import(FromFriendF, Lang_CXX03);\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  auto *ToClass = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"X\")));\n  auto *ToFriend = FirstDeclMatcher<FriendDecl>().match(ToTU, friendDecl());\n  auto ToFriends = ToClass->friends();\n  FrN = 0;\n  for (auto Fr : ToFriends) {\n    EXPECT_EQ(Fr, ToFriend);\n    ++FrN;\n  }\n  EXPECT_EQ(FrN, 1u);\n}\n\nAST_MATCHER_P(TagDecl, hasTypedefForAnonDecl, Matcher<TypedefNameDecl>,\n              InnerMatcher) {\n  if (auto *Typedef = Node.getTypedefNameForAnonDecl())\n    return InnerMatcher.matches(*Typedef, Finder, Builder);\n  return false;\n}\n\nTEST_P(ImportDecl, ImportEnumSequential) {\n  CodeFiles Samples{{\"main.c\",\n                     {\"void foo();\"\n                      \"void moo();\"\n                      \"int main() { foo(); moo(); }\",\n                      Lang_C99}},\n\n                    {\"foo.c\",\n                     {\"typedef enum { THING_VALUE } thing_t;\"\n                      \"void conflict(thing_t type);\"\n                      \"void foo() { (void)THING_VALUE; }\"\n                      \"void conflict(thing_t type) {}\",\n                      Lang_C99}},\n\n                    {\"moo.c\",\n                     {\"typedef enum { THING_VALUE } thing_t;\"\n                      \"void conflict(thing_t type);\"\n                      \"void moo() { conflict(THING_VALUE); }\",\n                      Lang_C99}}};\n\n  auto VerificationMatcher =\n      enumDecl(has(enumConstantDecl(hasName(\"THING_VALUE\"))),\n               hasTypedefForAnonDecl(hasName(\"thing_t\")));\n\n  ImportAction ImportFoo{\"foo.c\", \"main.c\", functionDecl(hasName(\"foo\"))},\n      ImportMoo{\"moo.c\", \"main.c\", functionDecl(hasName(\"moo\"))};\n\n  testImportSequence(\n      Samples, {ImportFoo, ImportMoo}, // \"foo\", them \"moo\".\n      // Just check that there is only one enum decl in the result AST.\n      \"main.c\", enumDecl(), VerificationMatcher);\n\n  // For different import order, result should be the same.\n  testImportSequence(\n      Samples, {ImportMoo, ImportFoo}, // \"moo\", them \"foo\".\n      // Check that there is only one enum decl in the result AST.\n      \"main.c\", enumDecl(), VerificationMatcher);\n}\n\nTEST_P(ImportDecl, ImportFieldOrder) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"struct declToImport {\"\n             \"  int b = a + 2;\"\n             \"  int a = 5;\"\n             \"};\",\n             Lang_CXX11, \"\", Lang_CXX11, Verifier,\n             recordDecl(hasFieldOrder({\"b\", \"a\"})));\n}\n\nconst internal::VariadicDynCastAllOfMatcher<Expr, DependentScopeDeclRefExpr>\n    dependentScopeDeclRefExpr;\n\nTEST_P(ImportExpr, DependentScopeDeclRefExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template <typename T> struct S { static T foo; };\"\n             \"template <typename T> void declToImport() {\"\n             \"  (void) S<T>::foo;\"\n             \"}\"\n             \"void instantiate() { declToImport<int>(); }\"\n             \"template <typename T> T S<T>::foo;\",\n             Lang_CXX11, \"\", Lang_CXX11, Verifier,\n             functionTemplateDecl(has(functionDecl(has(compoundStmt(\n                 has(cStyleCastExpr(has(dependentScopeDeclRefExpr())))))))));\n\n  testImport(\"template <typename T> struct S {\"\n             \"template<typename S> static void foo(){};\"\n             \"};\"\n             \"template <typename T> void declToImport() {\"\n             \"  S<T>::template foo<T>();\"\n             \"}\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX11, \"\", Lang_CXX11, Verifier,\n             functionTemplateDecl(has(functionDecl(has(compoundStmt(\n                 has(callExpr(has(dependentScopeDeclRefExpr())))))))));\n}\n\nconst internal::VariadicDynCastAllOfMatcher<Type, DependentNameType>\n    dependentNameType;\n\nTEST_P(ImportExpr, DependentNameType) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"template <typename T> struct declToImport {\"\n             \"  typedef typename T::type dependent_name;\"\n             \"};\",\n             Lang_CXX11, \"\", Lang_CXX11, Verifier,\n             classTemplateDecl(has(\n                 cxxRecordDecl(has(typedefDecl(has(dependentNameType())))))));\n}\n\nTEST_P(ImportExpr, UnresolvedMemberExpr) {\n  MatchVerifier<Decl> Verifier;\n  testImport(\"struct S { template <typename T> void mem(); };\"\n             \"template <typename U> void declToImport() {\"\n             \"  S s;\"\n             \"  s.mem<U>();\"\n             \"}\"\n             \"void instantiate() { declToImport<int>(); }\",\n             Lang_CXX11, \"\", Lang_CXX11, Verifier,\n             functionTemplateDecl(has(functionDecl(has(\n                 compoundStmt(has(callExpr(has(unresolvedMemberExpr())))))))));\n}\n\nclass ImportImplicitMethods : public ASTImporterOptionSpecificTestBase {\npublic:\n  static constexpr auto DefaultCode = R\"(\n      struct A { int x; };\n      void f() {\n        A a;\n        A a1(a);\n        A a2(A{});\n        a = a1;\n        a = A{};\n        a.~A();\n      })\";\n\n  template <typename MatcherType>\n  void testImportOf(\n      const MatcherType &MethodMatcher, const char *Code = DefaultCode) {\n    test(MethodMatcher, Code, /*ExpectedCount=*/1u);\n  }\n\n  template <typename MatcherType>\n  void testNoImportOf(\n      const MatcherType &MethodMatcher, const char *Code = DefaultCode) {\n    test(MethodMatcher, Code, /*ExpectedCount=*/0u);\n  }\n\nprivate:\n  template <typename MatcherType>\n  void test(const MatcherType &MethodMatcher,\n      const char *Code, unsigned int ExpectedCount) {\n    auto ClassMatcher = cxxRecordDecl(unless(isImplicit()));\n\n    Decl *ToTU = getToTuDecl(Code, Lang_CXX11);\n    auto *ToClass = FirstDeclMatcher<CXXRecordDecl>().match(\n        ToTU, ClassMatcher);\n\n    ASSERT_EQ(DeclCounter<CXXMethodDecl>().match(ToClass, MethodMatcher), 1u);\n\n    {\n      CXXMethodDecl *Method =\n          FirstDeclMatcher<CXXMethodDecl>().match(ToClass, MethodMatcher);\n      ToClass->removeDecl(Method);\n      SharedStatePtr->getLookupTable()->remove(Method);\n    }\n\n    ASSERT_EQ(DeclCounter<CXXMethodDecl>().match(ToClass, MethodMatcher), 0u);\n\n    Decl *ImportedClass = nullptr;\n    {\n      Decl *FromTU = getTuDecl(Code, Lang_CXX11, \"input1.cc\");\n      auto *FromClass = FirstDeclMatcher<CXXRecordDecl>().match(\n          FromTU, ClassMatcher);\n      ImportedClass = Import(FromClass, Lang_CXX11);\n    }\n\n    EXPECT_EQ(ToClass, ImportedClass);\n    EXPECT_EQ(DeclCounter<CXXMethodDecl>().match(ToClass, MethodMatcher),\n        ExpectedCount);\n  }\n};\n\nTEST_P(ImportImplicitMethods, DefaultConstructor) {\n  testImportOf(cxxConstructorDecl(isDefaultConstructor()));\n}\n\nTEST_P(ImportImplicitMethods, CopyConstructor) {\n  testImportOf(cxxConstructorDecl(isCopyConstructor()));\n}\n\nTEST_P(ImportImplicitMethods, MoveConstructor) {\n  testImportOf(cxxConstructorDecl(isMoveConstructor()));\n}\n\nTEST_P(ImportImplicitMethods, Destructor) {\n  testImportOf(cxxDestructorDecl());\n}\n\nTEST_P(ImportImplicitMethods, CopyAssignment) {\n  testImportOf(cxxMethodDecl(isCopyAssignmentOperator()));\n}\n\nTEST_P(ImportImplicitMethods, MoveAssignment) {\n  testImportOf(cxxMethodDecl(isMoveAssignmentOperator()));\n}\n\nTEST_P(ImportImplicitMethods, DoNotImportUserProvided) {\n  auto Code = R\"(\n      struct A { A() { int x; } };\n      )\";\n  testNoImportOf(cxxConstructorDecl(isDefaultConstructor()), Code);\n}\n\nTEST_P(ImportImplicitMethods, DoNotImportDefault) {\n  auto Code = R\"(\n      struct A { A() = default; };\n      )\";\n  testNoImportOf(cxxConstructorDecl(isDefaultConstructor()), Code);\n}\n\nTEST_P(ImportImplicitMethods, DoNotImportDeleted) {\n  auto Code = R\"(\n      struct A { A() = delete; };\n      )\";\n  testNoImportOf(cxxConstructorDecl(isDefaultConstructor()), Code);\n}\n\nTEST_P(ImportImplicitMethods, DoNotImportOtherMethod) {\n  auto Code = R\"(\n      struct A { void f() { } };\n      )\";\n  testNoImportOf(cxxMethodDecl(hasName(\"f\")), Code);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportOfEquivalentRecord) {\n  Decl *ToR1;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { };\", Lang_CXX03, \"input0.cc\");\n    auto *FromR = FirstDeclMatcher<CXXRecordDecl>().match(\n        FromTU, cxxRecordDecl(hasName(\"A\")));\n\n    ToR1 = Import(FromR, Lang_CXX03);\n  }\n\n  Decl *ToR2;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { };\", Lang_CXX03, \"input1.cc\");\n    auto *FromR = FirstDeclMatcher<CXXRecordDecl>().match(\n        FromTU, cxxRecordDecl(hasName(\"A\")));\n\n    ToR2 = Import(FromR, Lang_CXX03);\n  }\n\n  EXPECT_EQ(ToR1, ToR2);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportOfNonEquivalentRecord) {\n  Decl *ToR1;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { int x; };\", Lang_CXX03, \"input0.cc\");\n    auto *FromR = FirstDeclMatcher<CXXRecordDecl>().match(\n        FromTU, cxxRecordDecl(hasName(\"A\")));\n    ToR1 = Import(FromR, Lang_CXX03);\n  }\n  Decl *ToR2;\n  {\n    Decl *FromTU =\n        getTuDecl(\"struct A { unsigned x; };\", Lang_CXX03, \"input1.cc\");\n    auto *FromR = FirstDeclMatcher<CXXRecordDecl>().match(\n        FromTU, cxxRecordDecl(hasName(\"A\")));\n    ToR2 = Import(FromR, Lang_CXX03);\n  }\n  EXPECT_NE(ToR1, ToR2);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportOfEquivalentField) {\n  Decl *ToF1;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { int x; };\", Lang_CXX03, \"input0.cc\");\n    auto *FromF = FirstDeclMatcher<FieldDecl>().match(\n        FromTU, fieldDecl(hasName(\"x\")));\n    ToF1 = Import(FromF, Lang_CXX03);\n  }\n  Decl *ToF2;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { int x; };\", Lang_CXX03, \"input1.cc\");\n    auto *FromF = FirstDeclMatcher<FieldDecl>().match(\n        FromTU, fieldDecl(hasName(\"x\")));\n    ToF2 = Import(FromF, Lang_CXX03);\n  }\n  EXPECT_EQ(ToF1, ToF2);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportOfNonEquivalentField) {\n  Decl *ToF1;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { int x; };\", Lang_CXX03, \"input0.cc\");\n    auto *FromF = FirstDeclMatcher<FieldDecl>().match(\n        FromTU, fieldDecl(hasName(\"x\")));\n    ToF1 = Import(FromF, Lang_CXX03);\n  }\n  Decl *ToF2;\n  {\n    Decl *FromTU =\n        getTuDecl(\"struct A { unsigned x; };\", Lang_CXX03, \"input1.cc\");\n    auto *FromF = FirstDeclMatcher<FieldDecl>().match(\n        FromTU, fieldDecl(hasName(\"x\")));\n    ToF2 = Import(FromF, Lang_CXX03);\n  }\n  EXPECT_NE(ToF1, ToF2);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportOfEquivalentMethod) {\n  Decl *ToM1;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { void x(); }; void A::x() { }\",\n                             Lang_CXX03, \"input0.cc\");\n    auto *FromM = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"x\"), isDefinition()));\n    ToM1 = Import(FromM, Lang_CXX03);\n  }\n  Decl *ToM2;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { void x(); }; void A::x() { }\",\n                             Lang_CXX03, \"input1.cc\");\n    auto *FromM = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"x\"), isDefinition()));\n    ToM2 = Import(FromM, Lang_CXX03);\n  }\n  EXPECT_EQ(ToM1, ToM2);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportOfNonEquivalentMethod) {\n  Decl *ToM1;\n  {\n    Decl *FromTU = getTuDecl(\"struct A { void x(); }; void A::x() { }\",\n                             Lang_CXX03, \"input0.cc\");\n    auto *FromM = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"x\"), isDefinition()));\n    ToM1 = Import(FromM, Lang_CXX03);\n  }\n  Decl *ToM2;\n  {\n    Decl *FromTU =\n        getTuDecl(\"struct A { void x() const; }; void A::x() const { }\",\n                  Lang_CXX03, \"input1.cc\");\n    auto *FromM = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"x\"), isDefinition()));\n    ToM2 = Import(FromM, Lang_CXX03);\n  }\n  EXPECT_NE(ToM1, ToM2);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportUnnamedStructsWithRecursingField) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct A {\n        struct {\n          struct A *next;\n        } entry0;\n        struct {\n          struct A *next;\n        } entry1;\n      };\n      )\",\n      Lang_C99, \"input0.cc\");\n  auto *From =\n      FirstDeclMatcher<RecordDecl>().match(FromTU, recordDecl(hasName(\"A\")));\n\n  Import(From, Lang_C99);\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  auto *Entry0 =\n      FirstDeclMatcher<FieldDecl>().match(ToTU, fieldDecl(hasName(\"entry0\")));\n  auto *Entry1 =\n      FirstDeclMatcher<FieldDecl>().match(ToTU, fieldDecl(hasName(\"entry1\")));\n  auto *R0 = getRecordDecl(Entry0);\n  auto *R1 = getRecordDecl(Entry1);\n  EXPECT_NE(R0, R1);\n  EXPECT_TRUE(MatchVerifier<RecordDecl>().match(\n      R0, recordDecl(has(fieldDecl(hasName(\"next\"))))));\n  EXPECT_TRUE(MatchVerifier<RecordDecl>().match(\n      R1, recordDecl(has(fieldDecl(hasName(\"next\"))))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportUnnamedFieldsInCorrectOrder) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      void f(int X, int Y, bool Z) {\n        (void)[X, Y, Z] { (void)Z; };\n      }\n      )\",\n      Lang_CXX11, \"input0.cc\");\n  auto *FromF = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n  auto *ToF = cast_or_null<FunctionDecl>(Import(FromF, Lang_CXX11));\n  EXPECT_TRUE(ToF);\n\n  CXXRecordDecl *FromLambda =\n      cast<LambdaExpr>(cast<CStyleCastExpr>(cast<CompoundStmt>(\n          FromF->getBody())->body_front())->getSubExpr())->getLambdaClass();\n\n  auto *ToLambda = cast_or_null<CXXRecordDecl>(Import(FromLambda, Lang_CXX11));\n  EXPECT_TRUE(ToLambda);\n\n  // Check if the fields of the lambda class are imported in correct order.\n  unsigned FromIndex = 0u;\n  for (auto *FromField : FromLambda->fields()) {\n    ASSERT_FALSE(FromField->getDeclName());\n    auto *ToField = cast_or_null<FieldDecl>(Import(FromField, Lang_CXX11));\n    EXPECT_TRUE(ToField);\n    Optional<unsigned> ToIndex = ASTImporter::getFieldIndex(ToField);\n    EXPECT_TRUE(ToIndex);\n    EXPECT_EQ(*ToIndex, FromIndex);\n    ++FromIndex;\n  }\n\n  EXPECT_EQ(FromIndex, 3u);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       MergeFieldDeclsOfClassTemplateSpecialization) {\n  std::string ClassTemplate =\n      R\"(\n      template <typename T>\n      struct X {\n          int a{0}; // FieldDecl with InitListExpr\n          X(char) : a(3) {}     // (1)\n          X(int) {}             // (2)\n      };\n      )\";\n  Decl *ToTU = getToTuDecl(ClassTemplate +\n      R\"(\n      void foo() {\n          // ClassTemplateSpec with ctor (1): FieldDecl without InitlistExpr\n          X<char> xc('c');\n      }\n      )\", Lang_CXX11);\n  auto *ToSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      ToTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  // FieldDecl without InitlistExpr:\n  auto *ToField = *ToSpec->field_begin();\n  ASSERT_TRUE(ToField);\n  ASSERT_FALSE(ToField->getInClassInitializer());\n  Decl *FromTU = getTuDecl(ClassTemplate +\n      R\"(\n      void bar() {\n          // ClassTemplateSpec with ctor (2): FieldDecl WITH InitlistExpr\n          X<char> xc(1);\n      }\n      )\", Lang_CXX11);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  // FieldDecl with InitlistExpr:\n  auto *FromField = *FromSpec->field_begin();\n  ASSERT_TRUE(FromField);\n  ASSERT_TRUE(FromField->getInClassInitializer());\n\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n  ASSERT_TRUE(ImportedSpec);\n  EXPECT_EQ(ImportedSpec, ToSpec);\n  // After the import, the FieldDecl has to be merged, thus it should have the\n  // InitListExpr.\n  EXPECT_TRUE(ToField->getInClassInitializer());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       MergeFunctionOfClassTemplateSpecialization) {\n  std::string ClassTemplate =\n      R\"(\n      template <typename T>\n      struct X {\n        void f() {}\n        void g() {}\n      };\n      )\";\n  Decl *ToTU = getToTuDecl(ClassTemplate +\n      R\"(\n      void foo() {\n          X<char> x;\n          x.f();\n      }\n      )\", Lang_CXX11);\n  Decl *FromTU = getTuDecl(ClassTemplate +\n      R\"(\n      void bar() {\n          X<char> x;\n          x.g();\n      }\n      )\", Lang_CXX11);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  auto FunPattern = functionDecl(hasName(\"g\"),\n                         hasParent(classTemplateSpecializationDecl()));\n  auto *FromFun =\n      FirstDeclMatcher<FunctionDecl>().match(FromTU, FunPattern);\n  auto *ToFun =\n      FirstDeclMatcher<FunctionDecl>().match(ToTU, FunPattern);\n  ASSERT_TRUE(FromFun->hasBody());\n  ASSERT_FALSE(ToFun->hasBody());\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n  ASSERT_TRUE(ImportedSpec);\n  auto *ToSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      ToTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  EXPECT_EQ(ImportedSpec, ToSpec);\n  EXPECT_TRUE(ToFun->hasBody());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, MergeTemplateSpecWithForwardDecl) {\n  std::string ClassTemplate =\n      R\"(\n      template<typename T>\n      struct X { int m; };\n      template<>\n      struct X<int> { int m; };\n      )\";\n  // Append a forward decl for our template specialization.\n  getToTuDecl(ClassTemplate + \"template<> struct X<int>;\", Lang_CXX11);\n  Decl *FromTU = getTuDecl(ClassTemplate, Lang_CXX11);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl(hasName(\"X\"), isDefinition()));\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n  // Check that our definition got merged with the existing definition.\n  EXPECT_TRUE(FromSpec->isThisDeclarationADefinition());\n  EXPECT_TRUE(ImportedSpec->isThisDeclarationADefinition());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ODRViolationOfClassTemplateSpecializationsShouldBeReported) {\n  std::string ClassTemplate =\n      R\"(\n      template <typename T>\n      struct X {};\n      )\";\n  Decl *ToTU = getToTuDecl(ClassTemplate +\n                               R\"(\n      template <>\n      struct X<char> {\n          int a;\n      };\n      void foo() {\n          X<char> x;\n      }\n      )\",\n                           Lang_CXX11);\n  Decl *FromTU = getTuDecl(ClassTemplate +\n                               R\"(\n      template <>\n      struct X<char> {\n          int b;\n      };\n      void foo() {\n          X<char> x;\n      }\n      )\",\n                           Lang_CXX11);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n\n  // We expect one (ODR) warning during the import.\n  EXPECT_EQ(1u, ToTU->getASTContext().getDiagnostics().getNumWarnings());\n\n  // The second specialization is different from the first, thus it violates\n  // ODR, consequently we expect to keep the first specialization only, which is\n  // already in the \"To\" context.\n  EXPECT_FALSE(ImportedSpec);\n  EXPECT_EQ(1u,\n            DeclCounter<ClassTemplateSpecializationDecl>().match(\n                ToTU, classTemplateSpecializationDecl(hasName(\"X\"))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       MergeCtorOfClassTemplateSpecialization) {\n  std::string ClassTemplate =\n      R\"(\n      template <typename T>\n      struct X {\n          X(char) {}\n          X(int) {}\n      };\n      )\";\n  Decl *ToTU = getToTuDecl(ClassTemplate +\n      R\"(\n      void foo() {\n          X<char> x('c');\n      }\n      )\", Lang_CXX11);\n  Decl *FromTU = getTuDecl(ClassTemplate +\n      R\"(\n      void bar() {\n          X<char> x(1);\n      }\n      )\", Lang_CXX11);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  // Match the void(int) ctor.\n  auto CtorPattern =\n      cxxConstructorDecl(hasParameter(0, varDecl(hasType(asString(\"int\")))),\n                         hasParent(classTemplateSpecializationDecl()));\n  auto *FromCtor =\n      FirstDeclMatcher<CXXConstructorDecl>().match(FromTU, CtorPattern);\n  auto *ToCtor =\n      FirstDeclMatcher<CXXConstructorDecl>().match(ToTU, CtorPattern);\n  ASSERT_TRUE(FromCtor->hasBody());\n  ASSERT_FALSE(ToCtor->hasBody());\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n  ASSERT_TRUE(ImportedSpec);\n  auto *ToSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      ToTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  EXPECT_EQ(ImportedSpec, ToSpec);\n  EXPECT_TRUE(ToCtor->hasBody());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ClassTemplateFriendDecl) {\n  const auto *Code =\n      R\"(\n      template <class T> class X {  friend T; };\n      struct Y {};\n      template class X<Y>;\n    )\";\n  Decl *ToTU = getToTuDecl(Code, Lang_CXX11);\n  Decl *FromTU = getTuDecl(Code, Lang_CXX11);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl());\n  auto *ToSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      ToTU, classTemplateSpecializationDecl());\n\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n  EXPECT_EQ(ImportedSpec, ToSpec);\n  EXPECT_EQ(1u, DeclCounter<ClassTemplateSpecializationDecl>().match(\n                    ToTU, classTemplateSpecializationDecl()));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ClassTemplatePartialSpecializationsShouldNotBeDuplicated) {\n  auto Code =\n      R\"(\n    // primary template\n    template<class T1, class T2, int I>\n    class A {};\n\n    // partial specialization\n    template<class T, int I>\n    class A<T, T*, I> {};\n    )\";\n  Decl *ToTU = getToTuDecl(Code, Lang_CXX11);\n  Decl *FromTU = getTuDecl(Code, Lang_CXX11);\n  auto *FromSpec =\n      FirstDeclMatcher<ClassTemplatePartialSpecializationDecl>().match(\n          FromTU, classTemplatePartialSpecializationDecl());\n  auto *ToSpec =\n      FirstDeclMatcher<ClassTemplatePartialSpecializationDecl>().match(\n          ToTU, classTemplatePartialSpecializationDecl());\n\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n  EXPECT_EQ(ImportedSpec, ToSpec);\n  EXPECT_EQ(1u, DeclCounter<ClassTemplatePartialSpecializationDecl>().match(\n                    ToTU, classTemplatePartialSpecializationDecl()));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ClassTemplateSpecializationsShouldNotBeDuplicated) {\n  auto Code =\n      R\"(\n    // primary template\n    template<class T1, class T2, int I>\n    class A {};\n\n    // full specialization\n    template<>\n    class A<int, int, 1> {};\n    )\";\n  Decl *ToTU = getToTuDecl(Code, Lang_CXX11);\n  Decl *FromTU = getTuDecl(Code, Lang_CXX11);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl());\n  auto *ToSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      ToTU, classTemplateSpecializationDecl());\n\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n  EXPECT_EQ(ImportedSpec, ToSpec);\n  EXPECT_EQ(1u, DeclCounter<ClassTemplateSpecializationDecl>().match(\n                   ToTU, classTemplateSpecializationDecl()));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ClassTemplateFullAndPartialSpecsShouldNotBeMixed) {\n  std::string PrimaryTemplate =\n      R\"(\n    template<class T1, class T2, int I>\n    class A {};\n    )\";\n  auto PartialSpec =\n      R\"(\n    template<class T, int I>\n    class A<T, T*, I> {};\n    )\";\n  auto FullSpec =\n      R\"(\n    template<>\n    class A<int, int, 1> {};\n    )\";\n  Decl *ToTU = getToTuDecl(PrimaryTemplate + FullSpec, Lang_CXX11);\n  Decl *FromTU = getTuDecl(PrimaryTemplate + PartialSpec, Lang_CXX11);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl());\n\n  auto *ImportedSpec = Import(FromSpec, Lang_CXX11);\n  EXPECT_TRUE(ImportedSpec);\n  // Check the number of partial specializations.\n  EXPECT_EQ(1u, DeclCounter<ClassTemplatePartialSpecializationDecl>().match(\n                    ToTU, classTemplatePartialSpecializationDecl()));\n  // Check the number of full specializations.\n  EXPECT_EQ(1u, DeclCounter<ClassTemplateSpecializationDecl>().match(\n                    ToTU, classTemplateSpecializationDecl(\n                              unless(classTemplatePartialSpecializationDecl()))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       InitListExprValueKindShouldBeImported) {\n  Decl *TU = getTuDecl(\n      R\"(\n      const int &init();\n      void foo() { const int &a{init()}; }\n      )\", Lang_CXX11, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<VarDecl>().match(TU, varDecl(hasName(\"a\")));\n  ASSERT_TRUE(FromD->getAnyInitializer());\n  auto *InitExpr = FromD->getAnyInitializer();\n  ASSERT_TRUE(InitExpr);\n  ASSERT_TRUE(InitExpr->isGLValue());\n\n  auto *ToD = Import(FromD, Lang_CXX11);\n  EXPECT_TRUE(ToD);\n  auto *ToInitExpr = cast<VarDecl>(ToD)->getAnyInitializer();\n  EXPECT_TRUE(ToInitExpr);\n  EXPECT_TRUE(ToInitExpr->isGLValue());\n}\n\nstruct ImportVariables : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportVariables, ImportOfOneDeclBringsInTheWholeChain) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct A {\n        static const int a = 1 + 2;\n      };\n      const int A::a;\n      )\",\n      Lang_CXX03, \"input1.cc\");\n\n  auto *FromDWithInit = FirstDeclMatcher<VarDecl>().match(\n      FromTU, varDecl(hasName(\"a\"))); // Decl with init\n  auto *FromDWithDef = LastDeclMatcher<VarDecl>().match(\n      FromTU, varDecl(hasName(\"a\"))); // Decl with definition\n  ASSERT_NE(FromDWithInit, FromDWithDef);\n  ASSERT_EQ(FromDWithDef->getPreviousDecl(), FromDWithInit);\n\n  auto *ToD0 = cast<VarDecl>(Import(FromDWithInit, Lang_CXX11));\n  auto *ToD1 = cast<VarDecl>(Import(FromDWithDef, Lang_CXX11));\n  ASSERT_TRUE(ToD0);\n  ASSERT_TRUE(ToD1);\n  EXPECT_NE(ToD0, ToD1);\n  EXPECT_EQ(ToD1->getPreviousDecl(), ToD0);\n}\n\nTEST_P(ImportVariables, InitAndDefinitionAreInDifferentTUs) {\n  auto StructA =\n      R\"(\n      struct A {\n        static const int a = 1 + 2;\n      };\n      )\";\n  Decl *ToTU = getToTuDecl(StructA, Lang_CXX03);\n  Decl *FromTU = getTuDecl(std::string(StructA) + \"const int A::a;\", Lang_CXX03,\n                           \"input1.cc\");\n\n  auto *FromDWithInit = FirstDeclMatcher<VarDecl>().match(\n      FromTU, varDecl(hasName(\"a\"))); // Decl with init\n  auto *FromDWithDef = LastDeclMatcher<VarDecl>().match(\n      FromTU, varDecl(hasName(\"a\"))); // Decl with definition\n  ASSERT_EQ(FromDWithInit, FromDWithDef->getPreviousDecl());\n  ASSERT_TRUE(FromDWithInit->getInit());\n  ASSERT_FALSE(FromDWithInit->isThisDeclarationADefinition());\n  ASSERT_TRUE(FromDWithDef->isThisDeclarationADefinition());\n  ASSERT_FALSE(FromDWithDef->getInit());\n\n  auto *ToD = FirstDeclMatcher<VarDecl>().match(\n      ToTU, varDecl(hasName(\"a\"))); // Decl with init\n  ASSERT_TRUE(ToD->getInit());\n  ASSERT_FALSE(ToD->getDefinition());\n\n  auto *ImportedD = cast<VarDecl>(Import(FromDWithDef, Lang_CXX11));\n  EXPECT_TRUE(ImportedD->getAnyInitializer());\n  EXPECT_TRUE(ImportedD->getDefinition());\n}\n\nTEST_P(ImportVariables, InitAndDefinitionAreInTheFromContext) {\n  auto StructA =\n      R\"(\n      struct A {\n        static const int a;\n      };\n      )\";\n  Decl *ToTU = getToTuDecl(StructA, Lang_CXX03);\n  Decl *FromTU = getTuDecl(std::string(StructA) + \"const int A::a = 1 + 2;\",\n                           Lang_CXX03, \"input1.cc\");\n\n  auto *FromDDeclarationOnly = FirstDeclMatcher<VarDecl>().match(\n      FromTU, varDecl(hasName(\"a\")));\n  auto *FromDWithDef = LastDeclMatcher<VarDecl>().match(\n      FromTU, varDecl(hasName(\"a\"))); // Decl with definition and with init.\n  ASSERT_EQ(FromDDeclarationOnly, FromDWithDef->getPreviousDecl());\n  ASSERT_FALSE(FromDDeclarationOnly->getInit());\n  ASSERT_FALSE(FromDDeclarationOnly->isThisDeclarationADefinition());\n  ASSERT_TRUE(FromDWithDef->isThisDeclarationADefinition());\n  ASSERT_TRUE(FromDWithDef->getInit());\n\n  auto *ToD = FirstDeclMatcher<VarDecl>().match(\n      ToTU, varDecl(hasName(\"a\")));\n  ASSERT_FALSE(ToD->getInit());\n  ASSERT_FALSE(ToD->getDefinition());\n\n  auto *ImportedD = cast<VarDecl>(Import(FromDWithDef, Lang_CXX11));\n  EXPECT_TRUE(ImportedD->getAnyInitializer());\n  EXPECT_TRUE(ImportedD->getDefinition());\n}\n\nstruct ImportClasses : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportClasses, ImportDefinitionWhenProtoIsInNestedToContext) {\n  Decl *ToTU = getToTuDecl(\"struct A { struct X *Xp; };\", Lang_C99);\n  Decl *FromTU1 = getTuDecl(\"struct X {};\", Lang_C99, \"input1.cc\");\n  auto Pattern = recordDecl(hasName(\"X\"), unless(isImplicit()));\n  auto ToProto = FirstDeclMatcher<RecordDecl>().match(ToTU, Pattern);\n  auto FromDef = FirstDeclMatcher<RecordDecl>().match(FromTU1, Pattern);\n\n  Decl *ImportedDef = Import(FromDef, Lang_C99);\n\n  EXPECT_NE(ImportedDef, ToProto);\n  EXPECT_EQ(DeclCounter<RecordDecl>().match(ToTU, Pattern), 2u);\n  auto ToDef = LastDeclMatcher<RecordDecl>().match(ToTU, Pattern);\n  EXPECT_TRUE(ImportedDef == ToDef);\n  EXPECT_TRUE(ToDef->isThisDeclarationADefinition());\n  EXPECT_FALSE(ToProto->isThisDeclarationADefinition());\n  EXPECT_EQ(ToDef->getPreviousDecl(), ToProto);\n}\n\nTEST_P(ImportClasses, ImportDefinitionWhenProtoIsInNestedToContextCXX) {\n  Decl *ToTU = getToTuDecl(\"struct A { struct X *Xp; };\", Lang_CXX03);\n  Decl *FromTU1 = getTuDecl(\"struct X {};\", Lang_CXX03, \"input1.cc\");\n  auto Pattern = recordDecl(hasName(\"X\"), unless(isImplicit()));\n  auto ToProto = FirstDeclMatcher<RecordDecl>().match(ToTU, Pattern);\n  auto FromDef = FirstDeclMatcher<RecordDecl>().match(FromTU1, Pattern);\n\n  Decl *ImportedDef = Import(FromDef, Lang_CXX03);\n\n  EXPECT_NE(ImportedDef, ToProto);\n  EXPECT_EQ(DeclCounter<RecordDecl>().match(ToTU, Pattern), 2u);\n  auto ToDef = LastDeclMatcher<RecordDecl>().match(ToTU, Pattern);\n  EXPECT_TRUE(ImportedDef == ToDef);\n  EXPECT_TRUE(ToDef->isThisDeclarationADefinition());\n  EXPECT_FALSE(ToProto->isThisDeclarationADefinition());\n  EXPECT_EQ(ToDef->getPreviousDecl(), ToProto);\n}\n\nTEST_P(ImportClasses, ImportNestedPrototypeThenDefinition) {\n  Decl *FromTU0 =\n      getTuDecl(\"struct A { struct X *Xp; };\", Lang_C99, \"input0.cc\");\n  Decl *FromTU1 = getTuDecl(\"struct X {};\", Lang_C99, \"input1.cc\");\n  auto Pattern = recordDecl(hasName(\"X\"), unless(isImplicit()));\n  auto FromProto = FirstDeclMatcher<RecordDecl>().match(FromTU0, Pattern);\n  auto FromDef = FirstDeclMatcher<RecordDecl>().match(FromTU1, Pattern);\n\n  Decl *ImportedProto = Import(FromProto, Lang_C99);\n  Decl *ImportedDef = Import(FromDef, Lang_C99);\n  Decl *ToTU = ImportedDef->getTranslationUnitDecl();\n\n  EXPECT_NE(ImportedDef, ImportedProto);\n  EXPECT_EQ(DeclCounter<RecordDecl>().match(ToTU, Pattern), 2u);\n  auto ToProto = FirstDeclMatcher<RecordDecl>().match(ToTU, Pattern);\n  auto ToDef = LastDeclMatcher<RecordDecl>().match(ToTU, Pattern);\n  EXPECT_TRUE(ImportedDef == ToDef);\n  EXPECT_TRUE(ImportedProto == ToProto);\n  EXPECT_TRUE(ToDef->isThisDeclarationADefinition());\n  EXPECT_FALSE(ToProto->isThisDeclarationADefinition());\n  EXPECT_EQ(ToDef->getPreviousDecl(), ToProto);\n}\n\n\nstruct ImportFriendClasses : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportFriendClasses, ImportOfFriendRecordDoesNotMergeDefinition) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      class A {\n        template <int I> class F {};\n        class X {\n          template <int I> friend class F;\n        };\n      };\n      )\",\n      Lang_CXX03, \"input0.cc\");\n\n  auto *FromClass = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"F\"), isDefinition()));\n  auto *FromFriendClass = LastDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"F\")));\n\n  ASSERT_TRUE(FromClass);\n  ASSERT_TRUE(FromFriendClass);\n  ASSERT_NE(FromClass, FromFriendClass);\n  ASSERT_EQ(FromFriendClass->getDefinition(), FromClass);\n  ASSERT_EQ(FromFriendClass->getPreviousDecl(), FromClass);\n  ASSERT_EQ(FromFriendClass->getDescribedClassTemplate()->getPreviousDecl(),\n            FromClass->getDescribedClassTemplate());\n\n  auto *ToClass = cast<CXXRecordDecl>(Import(FromClass, Lang_CXX03));\n  auto *ToFriendClass =\n      cast<CXXRecordDecl>(Import(FromFriendClass, Lang_CXX03));\n\n  EXPECT_TRUE(ToClass);\n  EXPECT_TRUE(ToFriendClass);\n  EXPECT_NE(ToClass, ToFriendClass);\n  EXPECT_EQ(ToFriendClass->getDefinition(), ToClass);\n  EXPECT_EQ(ToFriendClass->getPreviousDecl(), ToClass);\n  EXPECT_EQ(ToFriendClass->getDescribedClassTemplate()->getPreviousDecl(),\n            ToClass->getDescribedClassTemplate());\n}\n\nTEST_P(ImportFriendClasses, ImportOfRecursiveFriendClass) {\n  Decl *FromTu = getTuDecl(\n      R\"(\n      class declToImport {\n        friend class declToImport;\n      };\n      )\",\n      Lang_CXX03, \"input.cc\");\n\n  auto *FromD = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTu, cxxRecordDecl(hasName(\"declToImport\")));\n  auto *ToD = Import(FromD, Lang_CXX03);\n  auto Pattern = cxxRecordDecl(has(friendDecl()));\n  ASSERT_TRUE(MatchVerifier<Decl>{}.match(FromD, Pattern));\n  EXPECT_TRUE(MatchVerifier<Decl>{}.match(ToD, Pattern));\n}\n\nTEST_P(ImportFriendClasses, UndeclaredFriendClassShouldNotBeVisible) {\n  Decl *FromTu =\n      getTuDecl(\"class X { friend class Y; };\", Lang_CXX03, \"from.cc\");\n  auto *FromX = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTu, cxxRecordDecl(hasName(\"X\")));\n  auto *FromFriend = FirstDeclMatcher<FriendDecl>().match(FromTu, friendDecl());\n  RecordDecl *FromRecordOfFriend =\n      const_cast<RecordDecl *>(getRecordDeclOfFriend(FromFriend));\n\n  ASSERT_EQ(FromRecordOfFriend->getDeclContext(), cast<DeclContext>(FromTu));\n  ASSERT_EQ(FromRecordOfFriend->getLexicalDeclContext(),\n            cast<DeclContext>(FromX));\n  ASSERT_FALSE(\n      FromRecordOfFriend->getDeclContext()->containsDecl(FromRecordOfFriend));\n  ASSERT_FALSE(FromRecordOfFriend->getLexicalDeclContext()->containsDecl(\n      FromRecordOfFriend));\n  ASSERT_FALSE(FromRecordOfFriend->getLookupParent()\n                   ->lookup(FromRecordOfFriend->getDeclName())\n                   .empty());\n\n  auto *ToX = Import(FromX, Lang_CXX03);\n  ASSERT_TRUE(ToX);\n\n  Decl *ToTu = ToX->getTranslationUnitDecl();\n  auto *ToFriend = FirstDeclMatcher<FriendDecl>().match(ToTu, friendDecl());\n  RecordDecl *ToRecordOfFriend =\n      const_cast<RecordDecl *>(getRecordDeclOfFriend(ToFriend));\n\n  ASSERT_EQ(ToRecordOfFriend->getDeclContext(), cast<DeclContext>(ToTu));\n  ASSERT_EQ(ToRecordOfFriend->getLexicalDeclContext(), cast<DeclContext>(ToX));\n  EXPECT_FALSE(\n      ToRecordOfFriend->getDeclContext()->containsDecl(ToRecordOfFriend));\n  EXPECT_FALSE(ToRecordOfFriend->getLexicalDeclContext()->containsDecl(\n      ToRecordOfFriend));\n  EXPECT_FALSE(ToRecordOfFriend->getLookupParent()\n                   ->lookup(ToRecordOfFriend->getDeclName())\n                   .empty());\n}\n\nTEST_P(ImportFriendClasses, ImportOfRecursiveFriendClassTemplate) {\n  Decl *FromTu = getTuDecl(\n      R\"(\n      template<class A> class declToImport {\n        template<class A1> friend class declToImport;\n      };\n      )\",\n      Lang_CXX03, \"input.cc\");\n\n  auto *FromD =\n      FirstDeclMatcher<ClassTemplateDecl>().match(FromTu, classTemplateDecl());\n  auto *ToD = Import(FromD, Lang_CXX03);\n\n  auto Pattern = classTemplateDecl(\n      has(cxxRecordDecl(has(friendDecl(has(classTemplateDecl()))))));\n  ASSERT_TRUE(MatchVerifier<Decl>{}.match(FromD, Pattern));\n  EXPECT_TRUE(MatchVerifier<Decl>{}.match(ToD, Pattern));\n\n  auto *Class =\n      FirstDeclMatcher<ClassTemplateDecl>().match(ToD, classTemplateDecl());\n  auto *Friend = FirstDeclMatcher<FriendDecl>().match(ToD, friendDecl());\n  EXPECT_NE(Friend->getFriendDecl(), Class);\n  EXPECT_EQ(Friend->getFriendDecl()->getPreviousDecl(), Class);\n}\n\nTEST_P(ImportFriendClasses, ProperPrevDeclForClassTemplateDecls) {\n  auto Pattern = classTemplateSpecializationDecl(hasName(\"X\"));\n\n  ClassTemplateSpecializationDecl *Imported1;\n  {\n    Decl *FromTU = getTuDecl(\"template<class T> class X;\"\n                             \"struct Y { friend class X<int>; };\",\n                             Lang_CXX03, \"input0.cc\");\n    auto *FromD = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n        FromTU, Pattern);\n\n    Imported1 =\n        cast<ClassTemplateSpecializationDecl>(Import(FromD, Lang_CXX03));\n  }\n  ClassTemplateSpecializationDecl *Imported2;\n  {\n    Decl *FromTU = getTuDecl(\"template<class T> class X;\"\n                             \"template<> class X<int>{};\"\n                             \"struct Z { friend class X<int>; };\",\n                             Lang_CXX03, \"input1.cc\");\n    auto *FromD = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n        FromTU, Pattern);\n\n    Imported2 =\n        cast<ClassTemplateSpecializationDecl>(Import(FromD, Lang_CXX03));\n  }\n\n  Decl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  EXPECT_EQ(DeclCounter<ClassTemplateSpecializationDecl>().match(ToTU, Pattern),\n            2u);\n  ASSERT_TRUE(Imported2->getPreviousDecl());\n  EXPECT_EQ(Imported2->getPreviousDecl(), Imported1);\n}\n\nTEST_P(ImportFriendClasses, TypeForDeclShouldBeSetInTemplated) {\n  Decl *FromTU0 = getTuDecl(\n      R\"(\n      class X {\n        class Y;\n      };\n      class X::Y {\n        template <typename T>\n        friend class F; // The decl context of F is the global namespace.\n      };\n      )\",\n      Lang_CXX03, \"input0.cc\");\n  auto *Fwd = FirstDeclMatcher<ClassTemplateDecl>().match(\n      FromTU0, classTemplateDecl(hasName(\"F\")));\n  auto *Imported0 = cast<ClassTemplateDecl>(Import(Fwd, Lang_CXX03));\n  Decl *FromTU1 = getTuDecl(\n      R\"(\n      template <typename T>\n      class F {};\n      )\",\n      Lang_CXX03, \"input1.cc\");\n  auto *Definition = FirstDeclMatcher<ClassTemplateDecl>().match(\n      FromTU1, classTemplateDecl(hasName(\"F\")));\n  auto *Imported1 = cast<ClassTemplateDecl>(Import(Definition, Lang_CXX03));\n  EXPECT_EQ(Imported0->getTemplatedDecl()->getTypeForDecl(),\n            Imported1->getTemplatedDecl()->getTypeForDecl());\n}\n\nTEST_P(ImportFriendClasses, DeclsFromFriendsShouldBeInRedeclChains) {\n  Decl *From, *To;\n  std::tie(From, To) =\n      getImportedDecl(\"class declToImport {};\", Lang_CXX03,\n                      \"class Y { friend class declToImport; };\", Lang_CXX03);\n  auto *Imported = cast<CXXRecordDecl>(To);\n\n  EXPECT_TRUE(Imported->getPreviousDecl());\n}\n\nTEST_P(ImportFriendClasses,\n       ImportOfClassTemplateDefinitionShouldConnectToFwdFriend) {\n  Decl *ToTU = getToTuDecl(\n      R\"(\n      class X {\n        class Y;\n      };\n      class X::Y {\n        template <typename T>\n        friend class F; // The decl context of F is the global namespace.\n      };\n      )\",\n      Lang_CXX03);\n  auto *ToDecl = FirstDeclMatcher<ClassTemplateDecl>().match(\n      ToTU, classTemplateDecl(hasName(\"F\")));\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename T>\n      class F {};\n      )\",\n      Lang_CXX03, \"input0.cc\");\n  auto *Definition = FirstDeclMatcher<ClassTemplateDecl>().match(\n      FromTU, classTemplateDecl(hasName(\"F\")));\n  auto *ImportedDef = cast<ClassTemplateDecl>(Import(Definition, Lang_CXX03));\n  EXPECT_TRUE(ImportedDef->getPreviousDecl());\n  EXPECT_EQ(ToDecl, ImportedDef->getPreviousDecl());\n  EXPECT_EQ(ToDecl->getTemplatedDecl(),\n            ImportedDef->getTemplatedDecl()->getPreviousDecl());\n}\n\nTEST_P(ImportFriendClasses,\n       ImportOfClassTemplateDefinitionAndFwdFriendShouldBeLinked) {\n  Decl *FromTU0 = getTuDecl(\n      R\"(\n      class X {\n        class Y;\n      };\n      class X::Y {\n        template <typename T>\n        friend class F; // The decl context of F is the global namespace.\n      };\n      )\",\n      Lang_CXX03, \"input0.cc\");\n  auto *Fwd = FirstDeclMatcher<ClassTemplateDecl>().match(\n      FromTU0, classTemplateDecl(hasName(\"F\")));\n  auto *ImportedFwd = cast<ClassTemplateDecl>(Import(Fwd, Lang_CXX03));\n  Decl *FromTU1 = getTuDecl(\n      R\"(\n      template <typename T>\n      class F {};\n      )\",\n      Lang_CXX03, \"input1.cc\");\n  auto *Definition = FirstDeclMatcher<ClassTemplateDecl>().match(\n      FromTU1, classTemplateDecl(hasName(\"F\")));\n  auto *ImportedDef = cast<ClassTemplateDecl>(Import(Definition, Lang_CXX03));\n  EXPECT_TRUE(ImportedDef->getPreviousDecl());\n  EXPECT_EQ(ImportedFwd, ImportedDef->getPreviousDecl());\n  EXPECT_EQ(ImportedFwd->getTemplatedDecl(),\n            ImportedDef->getTemplatedDecl()->getPreviousDecl());\n}\n\nTEST_P(ImportFriendClasses, ImportOfClassDefinitionAndFwdFriendShouldBeLinked) {\n  Decl *FromTU0 = getTuDecl(\n      R\"(\n      class X {\n        class Y;\n      };\n      class X::Y {\n        friend class F; // The decl context of F is the global namespace.\n      };\n      )\",\n      Lang_CXX03, \"input0.cc\");\n  auto *Friend = FirstDeclMatcher<FriendDecl>().match(FromTU0, friendDecl());\n  QualType FT = Friend->getFriendType()->getType();\n  FT = FromTU0->getASTContext().getCanonicalType(FT);\n  auto *Fwd = cast<TagType>(FT)->getDecl();\n  auto *ImportedFwd = Import(Fwd, Lang_CXX03);\n  Decl *FromTU1 = getTuDecl(\n      R\"(\n      class F {};\n      )\",\n      Lang_CXX03, \"input1.cc\");\n  auto *Definition = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU1, cxxRecordDecl(hasName(\"F\")));\n  auto *ImportedDef = Import(Definition, Lang_CXX03);\n  EXPECT_TRUE(ImportedDef->getPreviousDecl());\n  EXPECT_EQ(ImportedFwd, ImportedDef->getPreviousDecl());\n}\n\nTEST_P(ImportFriendClasses, ImportOfRepeatedFriendType) {\n  const char *Code =\n      R\"(\n      class Container {\n        friend class X;\n        friend class X;\n      };\n      )\";\n  Decl *ToTu = getToTuDecl(Code, Lang_CXX03);\n  Decl *FromTu = getTuDecl(Code, Lang_CXX03, \"from.cc\");\n\n  auto *ToFriend1 = FirstDeclMatcher<FriendDecl>().match(ToTu, friendDecl());\n  auto *ToFriend2 = LastDeclMatcher<FriendDecl>().match(ToTu, friendDecl());\n  auto *FromFriend1 =\n      FirstDeclMatcher<FriendDecl>().match(FromTu, friendDecl());\n  auto *FromFriend2 = LastDeclMatcher<FriendDecl>().match(FromTu, friendDecl());\n\n  FriendDecl *ToImportedFriend1 = Import(FromFriend1, Lang_CXX03);\n  FriendDecl *ToImportedFriend2 = Import(FromFriend2, Lang_CXX03);\n\n  EXPECT_NE(ToImportedFriend1, ToImportedFriend2);\n  EXPECT_EQ(ToFriend1, ToImportedFriend1);\n  EXPECT_EQ(ToFriend2, ToImportedFriend2);\n}\n\nTEST_P(ImportFriendClasses, ImportOfRepeatedFriendDecl) {\n  const char *Code =\n      R\"(\n      class Container {\n        friend void f();\n        friend void f();\n      };\n      )\";\n  Decl *ToTu = getToTuDecl(Code, Lang_CXX03);\n  Decl *FromTu = getTuDecl(Code, Lang_CXX03, \"from.cc\");\n\n  auto *ToFriend1 = FirstDeclMatcher<FriendDecl>().match(ToTu, friendDecl());\n  auto *ToFriend2 = LastDeclMatcher<FriendDecl>().match(ToTu, friendDecl());\n  auto *FromFriend1 =\n      FirstDeclMatcher<FriendDecl>().match(FromTu, friendDecl());\n  auto *FromFriend2 = LastDeclMatcher<FriendDecl>().match(FromTu, friendDecl());\n\n  FriendDecl *ToImportedFriend1 = Import(FromFriend1, Lang_CXX03);\n  FriendDecl *ToImportedFriend2 = Import(FromFriend2, Lang_CXX03);\n\n  EXPECT_NE(ToImportedFriend1, ToImportedFriend2);\n  EXPECT_EQ(ToFriend1, ToImportedFriend1);\n  EXPECT_EQ(ToFriend2, ToImportedFriend2);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, FriendFunInClassTemplate) {\n  auto *Code = R\"(\n  template <class T>\n  struct X {\n    friend void foo(){}\n  };\n      )\";\n  TranslationUnitDecl *ToTU = getToTuDecl(Code, Lang_CXX03);\n  auto *ToFoo = FirstDeclMatcher<FunctionDecl>().match(\n      ToTU, functionDecl(hasName(\"foo\")));\n\n  TranslationUnitDecl *FromTU = getTuDecl(Code, Lang_CXX03, \"input.cc\");\n  auto *FromFoo = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"foo\")));\n  auto *ImportedFoo = Import(FromFoo, Lang_CXX03);\n  EXPECT_EQ(ImportedFoo, ToFoo);\n}\n\nstruct DeclContextTest : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(DeclContextTest, removeDeclOfClassTemplateSpecialization) {\n  Decl *TU = getTuDecl(\n      R\"(\n      namespace NS {\n\n      template <typename T>\n      struct S {};\n      template struct S<int>;\n\n      inline namespace INS {\n        template <typename T>\n        struct S {};\n        template struct S<int>;\n      }\n\n      }\n      )\", Lang_CXX11, \"input0.cc\");\n  auto *NS = FirstDeclMatcher<NamespaceDecl>().match(\n      TU, namespaceDecl());\n  auto *Spec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      TU, classTemplateSpecializationDecl());\n  ASSERT_TRUE(NS->containsDecl(Spec));\n\n  NS->removeDecl(Spec);\n  EXPECT_FALSE(NS->containsDecl(Spec));\n}\n\nTEST_P(DeclContextTest,\n       removeDeclShouldNotFailEvenIfWeHaveExternalVisibleStorage) {\n  Decl *TU = getTuDecl(\"extern int A; int A;\", Lang_CXX03);\n  auto *A0 = FirstDeclMatcher<VarDecl>().match(TU, varDecl(hasName(\"A\")));\n  auto *A1 = LastDeclMatcher<VarDecl>().match(TU, varDecl(hasName(\"A\")));\n\n  // Investigate the list.\n  auto *DC = A0->getDeclContext();\n  ASSERT_TRUE(DC->containsDecl(A0));\n  ASSERT_TRUE(DC->containsDecl(A1));\n\n  // Investigate the lookup table.\n  auto *Map = DC->getLookupPtr();\n  ASSERT_TRUE(Map);\n  auto I = Map->find(A0->getDeclName());\n  ASSERT_NE(I, Map->end());\n  StoredDeclsList &L = I->second;\n  // The lookup table contains the most recent decl of A.\n  ASSERT_NE(L.getAsDecl(), A0);\n  ASSERT_EQ(L.getAsDecl(), A1);\n\n  ASSERT_TRUE(L.getAsDecl());\n  // Simulate the private function DeclContext::reconcileExternalVisibleStorage.\n  // The point here is to have a Vec with only one element, which is not the\n  // one we are going to delete from the DC later.\n  L.setHasExternalDecls();\n  ASSERT_TRUE(L.getAsVector());\n  ASSERT_EQ(1u, L.getAsVector()->size());\n\n  // This asserts in the old implementation.\n  DC->removeDecl(A0);\n  EXPECT_FALSE(DC->containsDecl(A0));\n}\n\nstruct ImportFunctionTemplateSpecializations\n    : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportFunctionTemplateSpecializations,\n       TUshouldNotContainFunctionTemplateImplicitInstantiation) {\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template<class T>\n      int f() { return 0; }\n      void foo() { f<int>(); }\n      )\",\n      Lang_CXX03, \"input0.cc\");\n\n  // Check that the function template instantiation is NOT the child of the TU.\n  auto Pattern = translationUnitDecl(\n      unless(has(functionDecl(hasName(\"f\"), isTemplateInstantiation()))));\n  ASSERT_TRUE(MatchVerifier<Decl>{}.match(FromTU, Pattern));\n\n  auto *Foo = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"foo\")));\n  ASSERT_TRUE(Import(Foo, Lang_CXX03));\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  EXPECT_TRUE(MatchVerifier<Decl>{}.match(ToTU, Pattern));\n}\n\nTEST_P(ImportFunctionTemplateSpecializations,\n       TUshouldNotContainFunctionTemplateExplicitInstantiation) {\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template<class T>\n      int f() { return 0; }\n      template int f<int>();\n      )\",\n      Lang_CXX03, \"input0.cc\");\n\n  // Check that the function template instantiation is NOT the child of the TU.\n  auto Instantiation = functionDecl(hasName(\"f\"), isTemplateInstantiation());\n  auto Pattern = translationUnitDecl(unless(has(Instantiation)));\n  ASSERT_TRUE(MatchVerifier<Decl>{}.match(FromTU, Pattern));\n\n  ASSERT_TRUE(Import(FirstDeclMatcher<Decl>().match(FromTU, Instantiation),\n                     Lang_CXX03));\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  EXPECT_TRUE(MatchVerifier<Decl>{}.match(ToTU, Pattern));\n}\n\nTEST_P(ImportFunctionTemplateSpecializations,\n       TUshouldContainFunctionTemplateSpecialization) {\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template<class T>\n      int f() { return 0; }\n      template <> int f<int>() { return 4; }\n      )\",\n      Lang_CXX03, \"input0.cc\");\n\n  // Check that the function template specialization is the child of the TU.\n  auto Specialization =\n      functionDecl(hasName(\"f\"), isExplicitTemplateSpecialization());\n  auto Pattern = translationUnitDecl(has(Specialization));\n  ASSERT_TRUE(MatchVerifier<Decl>{}.match(FromTU, Pattern));\n\n  ASSERT_TRUE(Import(FirstDeclMatcher<Decl>().match(FromTU, Specialization),\n                     Lang_CXX03));\n\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  EXPECT_TRUE(MatchVerifier<Decl>{}.match(ToTU, Pattern));\n}\n\nTEST_P(ImportFunctionTemplateSpecializations,\n       FunctionTemplateSpecializationRedeclChain) {\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template<class T>\n      int f() { return 0; }\n      template <> int f<int>() { return 4; }\n      )\",\n      Lang_CXX03, \"input0.cc\");\n\n  auto Spec = functionDecl(hasName(\"f\"), isExplicitTemplateSpecialization(),\n                           hasParent(translationUnitDecl()));\n  auto *FromSpecD = FirstDeclMatcher<Decl>().match(FromTU, Spec);\n  {\n    auto *TU = FromTU;\n    auto *SpecD = FromSpecD;\n    auto *TemplateD = FirstDeclMatcher<FunctionTemplateDecl>().match(\n        TU, functionTemplateDecl());\n    auto *FirstSpecD = *(TemplateD->spec_begin());\n    ASSERT_EQ(SpecD, FirstSpecD);\n    ASSERT_TRUE(SpecD->getPreviousDecl());\n    ASSERT_FALSE(cast<FunctionDecl>(SpecD->getPreviousDecl())\n                     ->doesThisDeclarationHaveABody());\n  }\n\n  ASSERT_TRUE(Import(FromSpecD, Lang_CXX03));\n\n  {\n    auto *TU = ToAST->getASTContext().getTranslationUnitDecl();\n    auto *SpecD = FirstDeclMatcher<Decl>().match(TU, Spec);\n    auto *TemplateD = FirstDeclMatcher<FunctionTemplateDecl>().match(\n        TU, functionTemplateDecl());\n    auto *FirstSpecD = *(TemplateD->spec_begin());\n    EXPECT_EQ(SpecD, FirstSpecD);\n    ASSERT_TRUE(SpecD->getPreviousDecl());\n    EXPECT_FALSE(cast<FunctionDecl>(SpecD->getPreviousDecl())\n                     ->doesThisDeclarationHaveABody());\n  }\n}\n\nTEST_P(ImportFunctionTemplateSpecializations,\n       MatchNumberOfFunctionTemplateSpecializations) {\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename T> constexpr int f() { return 0; }\n      template <> constexpr int f<int>() { return 4; }\n      void foo() {\n        static_assert(f<char>() == 0, \"\");\n        static_assert(f<int>() == 4, \"\");\n      }\n      )\",\n      Lang_CXX11, \"input0.cc\");\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"foo\")));\n\n  Import(FromD, Lang_CXX11);\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  EXPECT_EQ(\n      DeclCounter<FunctionDecl>().match(FromTU, functionDecl(hasName(\"f\"))),\n      DeclCounter<FunctionDecl>().match(ToTU, functionDecl(hasName(\"f\"))));\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n    ImportShouldNotReportFalseODRErrorWhenRecordIsBeingDefined) {\n  {\n    Decl *FromTU = getTuDecl(\n        R\"(\n            template <typename T>\n            struct B;\n            )\",\n        Lang_CXX03, \"input0.cc\");\n    auto *FromD = FirstDeclMatcher<ClassTemplateDecl>().match(\n        FromTU, classTemplateDecl(hasName(\"B\")));\n\n    Import(FromD, Lang_CXX03);\n  }\n\n  {\n    Decl *FromTU = getTuDecl(\n        R\"(\n            template <typename T>\n            struct B {\n              void f();\n              B* b;\n            };\n            )\",\n        Lang_CXX03, \"input1.cc\");\n    FunctionDecl *FromD = FirstDeclMatcher<FunctionDecl>().match(\n        FromTU, functionDecl(hasName(\"f\")));\n    Import(FromD, Lang_CXX03);\n    auto *FromCTD = FirstDeclMatcher<ClassTemplateDecl>().match(\n        FromTU, classTemplateDecl(hasName(\"B\")));\n    auto *ToCTD = cast<ClassTemplateDecl>(Import(FromCTD, Lang_CXX03));\n    EXPECT_TRUE(ToCTD->isThisDeclarationADefinition());\n\n    // We expect no (ODR) warning during the import.\n    auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n    EXPECT_EQ(0u, ToTU->getASTContext().getDiagnostics().getNumWarnings());\n  }\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportingTypedefShouldImportTheCompleteType) {\n  // We already have an incomplete underlying type in the \"To\" context.\n  auto Code =\n      R\"(\n      template <typename T>\n      struct S {\n        void foo();\n      };\n      using U = S<int>;\n      )\";\n  Decl *ToTU = getToTuDecl(Code, Lang_CXX11);\n  auto *ToD = FirstDeclMatcher<TypedefNameDecl>().match(ToTU,\n      typedefNameDecl(hasName(\"U\")));\n  ASSERT_TRUE(ToD->getUnderlyingType()->isIncompleteType());\n\n  // The \"From\" context has the same typedef, but the underlying type is\n  // complete this time.\n  Decl *FromTU = getTuDecl(std::string(Code) +\n      R\"(\n      void foo(U* u) {\n        u->foo();\n      }\n      )\", Lang_CXX11);\n  auto *FromD = FirstDeclMatcher<TypedefNameDecl>().match(FromTU,\n      typedefNameDecl(hasName(\"U\")));\n  ASSERT_FALSE(FromD->getUnderlyingType()->isIncompleteType());\n\n  // The imported type should be complete.\n  auto *ImportedD = cast<TypedefNameDecl>(Import(FromD, Lang_CXX11));\n  EXPECT_FALSE(ImportedD->getUnderlyingType()->isIncompleteType());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportTemplateParameterLists) {\n  auto Code =\n      R\"(\n      template<class T>\n      int f() { return 0; }\n      template <> int f<int>() { return 4; }\n      )\";\n\n  Decl *FromTU = getTuDecl(Code, Lang_CXX03);\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(FromTU,\n      functionDecl(hasName(\"f\"), isExplicitTemplateSpecialization()));\n  ASSERT_EQ(FromD->getNumTemplateParameterLists(), 1u);\n\n  auto *ToD = Import(FromD, Lang_CXX03);\n  // The template parameter list should exist.\n  EXPECT_EQ(ToD->getNumTemplateParameterLists(), 1u);\n}\n\nstruct ASTImporterLookupTableTest : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ASTImporterLookupTableTest, OneDecl) {\n  auto *ToTU = getToTuDecl(\"int a;\", Lang_CXX03);\n  auto *D = FirstDeclMatcher<VarDecl>().match(ToTU, varDecl(hasName(\"a\")));\n  ASTImporterLookupTable LT(*ToTU);\n  auto Res = LT.lookup(ToTU, D->getDeclName());\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), D);\n}\n\nstatic Decl *findInDeclListOfDC(DeclContext *DC, DeclarationName Name) {\n  for (Decl *D : DC->decls()) {\n    if (auto *ND = dyn_cast<NamedDecl>(D))\n      if (ND->getDeclName() == Name)\n        return ND;\n  }\n  return nullptr;\n}\n\nTEST_P(ASTImporterLookupTableTest,\n    FriendWhichIsnotFoundByNormalLookupShouldBeFoundByImporterSpecificLookup) {\n  auto *Code = R\"(\n  template <class T>\n  struct X {\n    friend void foo(){}\n  };\n      )\";\n  TranslationUnitDecl *ToTU = getToTuDecl(Code, Lang_CXX03);\n  auto *X = FirstDeclMatcher<ClassTemplateDecl>().match(\n      ToTU, classTemplateDecl(hasName(\"X\")));\n  auto *Foo = FirstDeclMatcher<FunctionDecl>().match(\n      ToTU, functionDecl(hasName(\"foo\")));\n  DeclContext *FooDC = Foo->getDeclContext();\n  DeclContext *FooLexicalDC = Foo->getLexicalDeclContext();\n  ASSERT_EQ(cast<Decl>(FooLexicalDC), X->getTemplatedDecl());\n  ASSERT_EQ(cast<Decl>(FooDC), ToTU);\n  DeclarationName FooName = Foo->getDeclName();\n\n  // Cannot find in the LookupTable of its DC (TUDecl)\n  SmallVector<NamedDecl *, 2> FoundDecls;\n  FooDC->getRedeclContext()->localUncachedLookup(FooName, FoundDecls);\n  EXPECT_EQ(FoundDecls.size(), 0u);\n\n  // Cannot find in the LookupTable of its LexicalDC (X)\n  FooLexicalDC->getRedeclContext()->localUncachedLookup(FooName, FoundDecls);\n  EXPECT_EQ(FoundDecls.size(), 0u);\n\n  // Can't find in the list of Decls of the DC.\n  EXPECT_EQ(findInDeclListOfDC(FooDC, FooName), nullptr);\n\n  // Can't find in the list of Decls of the LexicalDC\n  EXPECT_EQ(findInDeclListOfDC(FooLexicalDC, FooName), nullptr);\n\n  // ASTImporter specific lookup finds it.\n  ASTImporterLookupTable LT(*ToTU);\n  auto Res = LT.lookup(FooDC, Foo->getDeclName());\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), Foo);\n}\n\nTEST_P(ASTImporterLookupTableTest,\n       FwdDeclStructShouldBeFoundByImporterSpecificLookup) {\n  TranslationUnitDecl *ToTU =\n      getToTuDecl(\"struct A { struct Foo *p; };\", Lang_C99);\n  auto *Foo =\n      FirstDeclMatcher<RecordDecl>().match(ToTU, recordDecl(hasName(\"Foo\")));\n  auto *A =\n      FirstDeclMatcher<RecordDecl>().match(ToTU, recordDecl(hasName(\"A\")));\n  DeclContext *FooDC = Foo->getDeclContext();\n  DeclContext *FooLexicalDC = Foo->getLexicalDeclContext();\n  ASSERT_EQ(cast<Decl>(FooLexicalDC), A);\n  ASSERT_EQ(cast<Decl>(FooDC), ToTU);\n  DeclarationName FooName = Foo->getDeclName();\n\n  // Cannot find in the LookupTable of its DC (TUDecl).\n  SmallVector<NamedDecl *, 2> FoundDecls;\n  FooDC->getRedeclContext()->localUncachedLookup(FooName, FoundDecls);\n  EXPECT_EQ(FoundDecls.size(), 0u);\n\n  // Cannot find in the LookupTable of its LexicalDC (A).\n  FooLexicalDC->getRedeclContext()->localUncachedLookup(FooName, FoundDecls);\n  EXPECT_EQ(FoundDecls.size(), 0u);\n\n  // Can't find in the list of Decls of the DC.\n  EXPECT_EQ(findInDeclListOfDC(FooDC, FooName), nullptr);\n\n  // Can find in the list of Decls of the LexicalDC.\n  EXPECT_EQ(findInDeclListOfDC(FooLexicalDC, FooName), Foo);\n\n  // ASTImporter specific lookup finds it.\n  ASTImporterLookupTable LT(*ToTU);\n  auto Res = LT.lookup(FooDC, Foo->getDeclName());\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), Foo);\n}\n\nTEST_P(ASTImporterLookupTableTest, LookupFindsNamesInDifferentDC) {\n  TranslationUnitDecl *ToTU =\n      getToTuDecl(\"int V; struct A { int V; }; struct B { int V; };\", Lang_C99);\n  DeclarationName VName = FirstDeclMatcher<VarDecl>()\n                              .match(ToTU, varDecl(hasName(\"V\")))\n                              ->getDeclName();\n  auto *A =\n      FirstDeclMatcher<RecordDecl>().match(ToTU, recordDecl(hasName(\"A\")));\n  auto *B =\n      FirstDeclMatcher<RecordDecl>().match(ToTU, recordDecl(hasName(\"B\")));\n\n  ASTImporterLookupTable LT(*ToTU);\n\n  auto Res = LT.lookup(cast<DeclContext>(A), VName);\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), FirstDeclMatcher<FieldDecl>().match(\n                        ToTU, fieldDecl(hasName(\"V\"),\n                                        hasParent(recordDecl(hasName(\"A\"))))));\n  Res = LT.lookup(cast<DeclContext>(B), VName);\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), FirstDeclMatcher<FieldDecl>().match(\n                        ToTU, fieldDecl(hasName(\"V\"),\n                                        hasParent(recordDecl(hasName(\"B\"))))));\n  Res = LT.lookup(ToTU, VName);\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), FirstDeclMatcher<VarDecl>().match(\n                        ToTU, varDecl(hasName(\"V\"),\n                                        hasParent(translationUnitDecl()))));\n}\n\nTEST_P(ASTImporterLookupTableTest, LookupFindsOverloadedNames) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      void foo();\n      void foo(int);\n      void foo(int, int);\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *F0 = FirstDeclMatcher<FunctionDecl>().match(ToTU, functionDecl());\n  auto *F2 = LastDeclMatcher<FunctionDecl>().match(ToTU, functionDecl());\n  DeclarationName Name = F0->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.size(), 3u);\n  EXPECT_EQ(Res.count(F0), 1u);\n  EXPECT_EQ(Res.count(F2), 1u);\n}\n\nTEST_P(ASTImporterLookupTableTest,\n       DifferentOperatorsShouldHaveDifferentResultSet) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      struct X{};\n      void operator+(X, X);\n      void operator-(X, X);\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *FPlus = FirstDeclMatcher<FunctionDecl>().match(\n      ToTU, functionDecl(hasOverloadedOperatorName(\"+\")));\n  auto *FMinus = FirstDeclMatcher<FunctionDecl>().match(\n      ToTU, functionDecl(hasOverloadedOperatorName(\"-\")));\n  DeclarationName NamePlus = FPlus->getDeclName();\n  auto ResPlus = LT.lookup(ToTU, NamePlus);\n  EXPECT_EQ(ResPlus.size(), 1u);\n  EXPECT_EQ(ResPlus.count(FPlus), 1u);\n  EXPECT_EQ(ResPlus.count(FMinus), 0u);\n  DeclarationName NameMinus = FMinus->getDeclName();\n  auto ResMinus = LT.lookup(ToTU, NameMinus);\n  EXPECT_EQ(ResMinus.size(), 1u);\n  EXPECT_EQ(ResMinus.count(FMinus), 1u);\n  EXPECT_EQ(ResMinus.count(FPlus), 0u);\n  EXPECT_NE(*ResMinus.begin(), *ResPlus.begin());\n}\n\nTEST_P(ASTImporterLookupTableTest, LookupDeclNamesFromDifferentTUs) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      struct X {};\n      void operator+(X, X);\n      )\",\n      Lang_CXX03);\n  auto *ToPlus = FirstDeclMatcher<FunctionDecl>().match(\n      ToTU, functionDecl(hasOverloadedOperatorName(\"+\")));\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct X {};\n      void operator+(X, X);\n      )\",\n      Lang_CXX03);\n  auto *FromPlus = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasOverloadedOperatorName(\"+\")));\n\n  // FromPlus have a different TU, thus its DeclarationName is different too.\n  ASSERT_NE(ToPlus->getDeclName(), FromPlus->getDeclName());\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto Res = LT.lookup(ToTU, ToPlus->getDeclName());\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), ToPlus);\n\n  // FromPlus have a different TU, thus its DeclarationName is different too.\n  Res = LT.lookup(ToTU, FromPlus->getDeclName());\n  ASSERT_EQ(Res.size(), 0u);\n}\n\nTEST_P(ASTImporterLookupTableTest,\n       LookupFindsFwdFriendClassDeclWithElaboratedType) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      class Y { friend class F; };\n      )\",\n      Lang_CXX03);\n\n  // In this case, the CXXRecordDecl is hidden, the FriendDecl is not a parent.\n  // So we must dig up the underlying CXXRecordDecl.\n  ASTImporterLookupTable LT(*ToTU);\n  auto *FriendD = FirstDeclMatcher<FriendDecl>().match(ToTU, friendDecl());\n  const RecordDecl *RD = getRecordDeclOfFriend(FriendD);\n  auto *Y = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"Y\")));\n\n  DeclarationName Name = RD->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), RD);\n\n  Res = LT.lookup(Y, Name);\n  EXPECT_EQ(Res.size(), 0u);\n}\n\nTEST_P(ASTImporterLookupTableTest,\n       LookupFindsFwdFriendClassDeclWithUnelaboratedType) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      class F;\n      class Y { friend F; };\n      )\",\n      Lang_CXX11);\n\n  // In this case, the CXXRecordDecl is hidden, the FriendDecl is not a parent.\n  // So we must dig up the underlying CXXRecordDecl.\n  ASTImporterLookupTable LT(*ToTU);\n  auto *FriendD = FirstDeclMatcher<FriendDecl>().match(ToTU, friendDecl());\n  const RecordDecl *RD = getRecordDeclOfFriend(FriendD);\n  auto *Y = FirstDeclMatcher<CXXRecordDecl>().match(ToTU, cxxRecordDecl(hasName(\"Y\")));\n\n  DeclarationName Name = RD->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), RD);\n\n  Res = LT.lookup(Y, Name);\n  EXPECT_EQ(Res.size(), 0u);\n}\n\nTEST_P(ASTImporterLookupTableTest,\n       LookupFindsFriendClassDeclWithTypeAliasDoesNotAssert) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      class F;\n      using alias_of_f = F;\n      class Y { friend alias_of_f; };\n      )\",\n      Lang_CXX11);\n\n  // ASTImporterLookupTable constructor handles using declarations correctly,\n  // no assert is expected.\n  ASTImporterLookupTable LT(*ToTU);\n\n  auto *Alias = FirstDeclMatcher<TypeAliasDecl>().match(\n      ToTU, typeAliasDecl(hasName(\"alias_of_f\")));\n  DeclarationName Name = Alias->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.count(Alias), 1u);\n}\n\nTEST_P(ASTImporterLookupTableTest, LookupFindsFwdFriendClassTemplateDecl) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      class Y { template <class T> friend class F; };\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *F = FirstDeclMatcher<ClassTemplateDecl>().match(\n      ToTU, classTemplateDecl(hasName(\"F\")));\n  DeclarationName Name = F->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.size(), 2u);\n  EXPECT_EQ(Res.count(F), 1u);\n  EXPECT_EQ(Res.count(F->getTemplatedDecl()), 1u);\n}\n\nTEST_P(ASTImporterLookupTableTest, DependentFriendClass) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      template <typename T>\n      class F;\n\n      template <typename T>\n      class Y {\n        friend class F<T>;\n      };\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *F = FirstDeclMatcher<ClassTemplateDecl>().match(\n      ToTU, classTemplateDecl(hasName(\"F\")));\n  DeclarationName Name = F->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.size(), 2u);\n  EXPECT_EQ(Res.count(F), 1u);\n  EXPECT_EQ(Res.count(F->getTemplatedDecl()), 1u);\n}\n\nTEST_P(ASTImporterLookupTableTest, FriendClassTemplateSpecialization) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      template <typename T>\n      class F;\n\n      class Y {\n        friend class F<int>;\n      };\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *F = FirstDeclMatcher<ClassTemplateDecl>().match(\n      ToTU, classTemplateDecl(hasName(\"F\")));\n  DeclarationName Name = F->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  ASSERT_EQ(Res.size(), 3u);\n  EXPECT_EQ(Res.count(F), 1u);\n  EXPECT_EQ(Res.count(F->getTemplatedDecl()), 1u);\n  EXPECT_EQ(Res.count(*F->spec_begin()), 1u);\n}\n\nTEST_P(ASTImporterLookupTableTest, LookupFindsFwdFriendFunctionDecl) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      class Y { friend void F(); };\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *F =\n      FirstDeclMatcher<FunctionDecl>().match(ToTU, functionDecl(hasName(\"F\")));\n  DeclarationName Name = F->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), F);\n}\n\nTEST_P(ASTImporterLookupTableTest,\n       LookupFindsDeclsInClassTemplateSpecialization) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      template <typename T>\n      struct X {\n        int F;\n      };\n      void foo() {\n        X<char> xc;\n      }\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n\n  auto *Template = FirstDeclMatcher<ClassTemplateDecl>().match(\n      ToTU, classTemplateDecl(hasName(\"X\")));\n  auto *FieldInTemplate = FirstDeclMatcher<FieldDecl>().match(\n      ToTU,\n      fieldDecl(hasParent(cxxRecordDecl(hasParent(classTemplateDecl())))));\n\n  auto *Spec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      ToTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  FieldDecl *FieldInSpec = *Spec->field_begin();\n  ASSERT_TRUE(FieldInSpec);\n\n  DeclarationName Name = FieldInSpec->getDeclName();\n  auto TemplateDC = cast<DeclContext>(Template->getTemplatedDecl());\n\n  SmallVector<NamedDecl *, 2> FoundDecls;\n  TemplateDC->getRedeclContext()->localUncachedLookup(Name, FoundDecls);\n  EXPECT_EQ(FoundDecls.size(), 1u);\n  EXPECT_EQ(FoundDecls[0], FieldInTemplate);\n\n  auto Res = LT.lookup(TemplateDC, Name);\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), FieldInTemplate);\n\n  cast<DeclContext>(Spec)->getRedeclContext()->localUncachedLookup(Name,\n                                                                   FoundDecls);\n  EXPECT_EQ(FoundDecls.size(), 1u);\n  EXPECT_EQ(FoundDecls[0], FieldInSpec);\n\n  Res = LT.lookup(cast<DeclContext>(Spec), Name);\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), FieldInSpec);\n}\n\nTEST_P(ASTImporterLookupTableTest, LookupFindsFwdFriendFunctionTemplateDecl) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      class Y { template <class T> friend void F(); };\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *F = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      ToTU, functionTemplateDecl(hasName(\"F\")));\n  DeclarationName Name = F->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.size(), 2u);\n  EXPECT_EQ(Res.count(F), 1u);\n  EXPECT_EQ(Res.count(F->getTemplatedDecl()), 1u);\n}\n\nTEST_P(ASTImporterLookupTableTest, MultipleBefriendingClasses) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      struct X;\n      struct A {\n        friend struct X;\n      };\n      struct B {\n        friend struct X;\n      };\n      )\",\n      Lang_CXX03);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *X = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"X\")));\n  auto *FriendD0 = FirstDeclMatcher<FriendDecl>().match(ToTU, friendDecl());\n  auto *FriendD1 = LastDeclMatcher<FriendDecl>().match(ToTU, friendDecl());\n  const RecordDecl *RD0 = getRecordDeclOfFriend(FriendD0);\n  const RecordDecl *RD1 = getRecordDeclOfFriend(FriendD1);\n  ASSERT_EQ(RD0, RD1);\n  ASSERT_EQ(RD1, X);\n\n  DeclarationName Name = X->getDeclName();\n  auto Res = LT.lookup(ToTU, Name);\n  EXPECT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), X);\n}\n\nTEST_P(ASTImporterLookupTableTest, EnumConstantDecl) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      enum E {\n        A,\n        B\n      };\n      )\",\n      Lang_C99);\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto *E = FirstDeclMatcher<EnumDecl>().match(ToTU, enumDecl(hasName(\"E\")));\n  auto *A = FirstDeclMatcher<EnumConstantDecl>().match(\n      ToTU, enumConstantDecl(hasName(\"A\")));\n\n  DeclarationName Name = A->getDeclName();\n  // Redecl context is the TU.\n  ASSERT_EQ(E->getRedeclContext(), ToTU);\n\n  SmallVector<NamedDecl *, 2> FoundDecls;\n  // Normal lookup finds in the DC.\n  E->localUncachedLookup(Name, FoundDecls);\n  EXPECT_EQ(FoundDecls.size(), 1u);\n\n  // Normal lookup finds in the Redecl context.\n  ToTU->localUncachedLookup(Name, FoundDecls);\n  EXPECT_EQ(FoundDecls.size(), 1u);\n\n  // Import specific lookup finds in the DC.\n  auto Res = LT.lookup(E, Name);\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), A);\n\n  // Import specific lookup finds in the Redecl context.\n  Res = LT.lookup(ToTU, Name);\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), A);\n}\n\nTEST_P(ASTImporterLookupTableTest, LookupSearchesInTheWholeRedeclChain) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      namespace N {\n        int A;\n      }\n      namespace N {\n      }\n      )\",\n      Lang_CXX03);\n  auto *N1 =\n      LastDeclMatcher<NamespaceDecl>().match(ToTU, namespaceDecl(hasName(\"N\")));\n  auto *A = FirstDeclMatcher<VarDecl>().match(ToTU, varDecl(hasName(\"A\")));\n  DeclarationName Name = A->getDeclName();\n\n  ASTImporterLookupTable LT(*ToTU);\n  auto Res = LT.lookup(N1, Name);\n  ASSERT_EQ(Res.size(), 1u);\n  EXPECT_EQ(*Res.begin(), A);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       RedeclChainShouldBeCorrectAmongstNamespaces) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      namespace NS {\n        struct X;\n        struct Y {\n          static const int I = 3;\n        };\n      }\n      namespace NS {\n        struct X {  // <--- To be imported\n          void method(int i = Y::I) {}\n          int f;\n        };\n      }\n      )\",\n      Lang_CXX03);\n  auto *FromFwd = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"X\"), unless(isImplicit())));\n  auto *FromDef = LastDeclMatcher<CXXRecordDecl>().match(\n      FromTU,\n      cxxRecordDecl(hasName(\"X\"), isDefinition(), unless(isImplicit())));\n  ASSERT_NE(FromFwd, FromDef);\n  ASSERT_FALSE(FromFwd->isThisDeclarationADefinition());\n  ASSERT_TRUE(FromDef->isThisDeclarationADefinition());\n  ASSERT_EQ(FromFwd->getCanonicalDecl(), FromDef->getCanonicalDecl());\n\n  auto *ToDef = cast_or_null<CXXRecordDecl>(Import(FromDef, Lang_CXX03));\n  auto *ToFwd = cast_or_null<CXXRecordDecl>(Import(FromFwd, Lang_CXX03));\n  EXPECT_NE(ToFwd, ToDef);\n  EXPECT_FALSE(ToFwd->isThisDeclarationADefinition());\n  EXPECT_TRUE(ToDef->isThisDeclarationADefinition());\n  EXPECT_EQ(ToFwd->getCanonicalDecl(), ToDef->getCanonicalDecl());\n  auto *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  // We expect no (ODR) warning during the import.\n  EXPECT_EQ(0u, ToTU->getASTContext().getDiagnostics().getNumWarnings());\n}\n\nstruct ImportFriendFunctionTemplates : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportFriendFunctionTemplates, LookupShouldFindPreviousFriend) {\n  Decl *ToTU = getToTuDecl(\n      R\"(\n      class X {\n        template <typename T> friend void foo();\n      };\n      )\",\n      Lang_CXX03);\n  auto *Friend = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      ToTU, functionTemplateDecl(hasName(\"foo\")));\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename T> void foo();\n      )\",\n      Lang_CXX03);\n  auto *FromFoo = FirstDeclMatcher<FunctionTemplateDecl>().match(\n      FromTU, functionTemplateDecl(hasName(\"foo\")));\n  auto *Imported = Import(FromFoo, Lang_CXX03);\n\n  EXPECT_EQ(Imported->getPreviousDecl(), Friend);\n}\n\nstruct ASTImporterWithFakeErrors : ASTImporter {\n  using ASTImporter::ASTImporter;\n  bool returnWithErrorInTest() override { return true; }\n};\n\nstruct ErrorHandlingTest : ASTImporterOptionSpecificTestBase {\n  ErrorHandlingTest() {\n    Creator = [](ASTContext &ToContext, FileManager &ToFileManager,\n                 ASTContext &FromContext, FileManager &FromFileManager,\n                 bool MinimalImport,\n                 const std::shared_ptr<ASTImporterSharedState> &SharedState) {\n      return new ASTImporterWithFakeErrors(ToContext, ToFileManager,\n                                           FromContext, FromFileManager,\n                                           MinimalImport, SharedState);\n    };\n  }\n  // In this test we purposely report an error (UnsupportedConstruct) when\n  // importing the below stmt.\n  static constexpr auto* ErroneousStmt = R\"( asm(\"\"); )\";\n};\n\n// Check a case when no new AST node is created in the AST before encountering\n// the error.\nTEST_P(ErrorHandlingTest, ErrorHappensBeforeCreatingANewNode) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      template <typename T>\n      class X {};\n      template <>\n      class X<int> { int a; };\n      )\",\n      Lang_CXX03);\n  TranslationUnitDecl *FromTU = getTuDecl(\n      R\"(\n      template <typename T>\n      class X {};\n      template <>\n      class X<int> { double b; };\n      )\",\n      Lang_CXX03);\n  auto *FromSpec = FirstDeclMatcher<ClassTemplateSpecializationDecl>().match(\n      FromTU, classTemplateSpecializationDecl(hasName(\"X\")));\n  ClassTemplateSpecializationDecl *ImportedSpec = Import(FromSpec, Lang_CXX03);\n  EXPECT_FALSE(ImportedSpec);\n\n  // The original Decl is kept, no new decl is created.\n  EXPECT_EQ(DeclCounter<ClassTemplateSpecializationDecl>().match(\n                ToTU, classTemplateSpecializationDecl(hasName(\"X\"))),\n            1u);\n\n  // But an error is set to the counterpart in the \"from\" context.\n  ASTImporter *Importer = findFromTU(FromSpec)->Importer.get();\n  Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromSpec);\n  ASSERT_TRUE(OptErr);\n  EXPECT_EQ(OptErr->Error, ImportError::NameConflict);\n}\n\n// Check a case when a new AST node is created but not linked to the AST before\n// encountering the error.\nTEST_P(ErrorHandlingTest,\n       ErrorHappensAfterCreatingTheNodeButBeforeLinkingThatToTheAST) {\n  TranslationUnitDecl *FromTU = getTuDecl(\n      std::string(\"void foo() { \") + ErroneousStmt + \" }\", Lang_CXX03);\n  auto *FromFoo = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"foo\")));\n\n  FunctionDecl *ImportedFoo = Import(FromFoo, Lang_CXX03);\n  EXPECT_FALSE(ImportedFoo);\n\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  // Created, but not linked.\n  EXPECT_EQ(\n      DeclCounter<FunctionDecl>().match(ToTU, functionDecl(hasName(\"foo\"))),\n      0u);\n\n  ASTImporter *Importer = findFromTU(FromFoo)->Importer.get();\n  Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromFoo);\n  ASSERT_TRUE(OptErr);\n  EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n}\n\n// Check a case when a new AST node is created and linked to the AST before\n// encountering the error. The error is set for the counterpart of the nodes in\n// the \"from\" context.\nTEST_P(ErrorHandlingTest, ErrorHappensAfterNodeIsCreatedAndLinked) {\n  TranslationUnitDecl *FromTU = getTuDecl(std::string(R\"(\n      void f();\n      void f() { )\") + ErroneousStmt + R\"( }\n      )\",\n                                          Lang_CXX03);\n  auto *FromProto = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n  auto *FromDef =\n      LastDeclMatcher<FunctionDecl>().match(FromTU, functionDecl(hasName(\"f\")));\n  FunctionDecl *ImportedProto = Import(FromProto, Lang_CXX03);\n  EXPECT_FALSE(ImportedProto); // Could not import.\n  // However, we created two nodes in the AST. 1) the fwd decl 2) the\n  // definition. The definition is not added to its DC, but the fwd decl is\n  // there.\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  EXPECT_EQ(DeclCounter<FunctionDecl>().match(ToTU, functionDecl(hasName(\"f\"))),\n            1u);\n  // Match the fwd decl.\n  auto *ToProto =\n      FirstDeclMatcher<FunctionDecl>().match(ToTU, functionDecl(hasName(\"f\")));\n  EXPECT_TRUE(ToProto);\n  // An error is set to the counterpart in the \"from\" context both for the fwd\n  // decl and the definition.\n  ASTImporter *Importer = findFromTU(FromProto)->Importer.get();\n  Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromProto);\n  ASSERT_TRUE(OptErr);\n  EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n  OptErr = Importer->getImportDeclErrorIfAny(FromDef);\n  ASSERT_TRUE(OptErr);\n  EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n}\n\n// An error should be set for a class if we cannot import one member.\nTEST_P(ErrorHandlingTest, ErrorIsPropagatedFromMemberToClass) {\n  TranslationUnitDecl *FromTU = getTuDecl(std::string(R\"(\n      class X {\n        void f() { )\") + ErroneousStmt + R\"( } // This member has the error\n                                               // during import.\n        void ok();        // The error should not prevent importing this.\n      };                  // An error will be set for X too.\n      )\",\n                                          Lang_CXX03);\n  auto *FromX = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"X\")));\n  CXXRecordDecl *ImportedX = Import(FromX, Lang_CXX03);\n\n  // An error is set for X.\n  EXPECT_FALSE(ImportedX);\n  ASTImporter *Importer = findFromTU(FromX)->Importer.get();\n  Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromX);\n  ASSERT_TRUE(OptErr);\n  EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n\n  // An error is set for f().\n  auto *FromF = FirstDeclMatcher<CXXMethodDecl>().match(\n      FromTU, cxxMethodDecl(hasName(\"f\")));\n  OptErr = Importer->getImportDeclErrorIfAny(FromF);\n  ASSERT_TRUE(OptErr);\n  EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n  // And any subsequent import should fail.\n  CXXMethodDecl *ImportedF = Import(FromF, Lang_CXX03);\n  EXPECT_FALSE(ImportedF);\n\n  // There is an error set for the other member too.\n  auto *FromOK = FirstDeclMatcher<CXXMethodDecl>().match(\n      FromTU, cxxMethodDecl(hasName(\"ok\")));\n  OptErr = Importer->getImportDeclErrorIfAny(FromOK);\n  EXPECT_TRUE(OptErr);\n  // Cannot import the other member.\n  CXXMethodDecl *ImportedOK = Import(FromOK, Lang_CXX03);\n  EXPECT_FALSE(ImportedOK);\n}\n\n// Check that an error propagates to the dependent AST nodes.\n// In the below code it means that an error in X should propagate to A.\n// And even to F since the containing A is erroneous.\n// And to all AST nodes which we visit during the import process which finally\n// ends up in a failure (in the error() function).\nTEST_P(ErrorHandlingTest, ErrorPropagatesThroughImportCycles) {\n  Decl *FromTU = getTuDecl(std::string(R\"(\n      namespace NS {\n        class A {\n          template <int I> class F {};\n          class X {\n            template <int I> friend class F;\n            void error() { )\") +\n                               ErroneousStmt + R\"( }\n          };\n        };\n\n        class B {};\n      } // NS\n      )\",\n                           Lang_CXX03, \"input0.cc\");\n\n  auto *FromFRD = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"F\"), isDefinition()));\n  auto *FromA = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"A\"), isDefinition()));\n  auto *FromB = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"B\"), isDefinition()));\n  auto *FromNS = FirstDeclMatcher<NamespaceDecl>().match(\n      FromTU, namespaceDecl(hasName(\"NS\")));\n\n  // Start by importing the templated CXXRecordDecl of F.\n  // Import fails for that.\n  EXPECT_FALSE(Import(FromFRD, Lang_CXX03));\n  // Import fails for A.\n  EXPECT_FALSE(Import(FromA, Lang_CXX03));\n  // But we should be able to import the independent B.\n  EXPECT_TRUE(Import(FromB, Lang_CXX03));\n  // And the namespace.\n  EXPECT_TRUE(Import(FromNS, Lang_CXX03));\n\n  // An error is set to the templated CXXRecordDecl of F.\n  ASTImporter *Importer = findFromTU(FromFRD)->Importer.get();\n  Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromFRD);\n  EXPECT_TRUE(OptErr);\n\n  // An error is set to A.\n  OptErr = Importer->getImportDeclErrorIfAny(FromA);\n  EXPECT_TRUE(OptErr);\n\n  // There is no error set to B.\n  OptErr = Importer->getImportDeclErrorIfAny(FromB);\n  EXPECT_FALSE(OptErr);\n\n  // There is no error set to NS.\n  OptErr = Importer->getImportDeclErrorIfAny(FromNS);\n  EXPECT_FALSE(OptErr);\n\n  // Check some of those decls whose ancestor is X, they all should have an\n  // error set if we visited them during an import process which finally failed.\n  // These decls are part of a cycle in an ImportPath.\n  // There would not be any error set for these decls if we hadn't follow the\n  // ImportPaths and the cycles.\n  OptErr = Importer->getImportDeclErrorIfAny(\n      FirstDeclMatcher<ClassTemplateDecl>().match(\n          FromTU, classTemplateDecl(hasName(\"F\"))));\n  // An error is set to the 'F' ClassTemplateDecl.\n  EXPECT_TRUE(OptErr);\n  // An error is set to the FriendDecl.\n  OptErr = Importer->getImportDeclErrorIfAny(\n      FirstDeclMatcher<FriendDecl>().match(\n          FromTU, friendDecl()));\n  EXPECT_TRUE(OptErr);\n  // An error is set to the implicit class of A.\n  OptErr =\n      Importer->getImportDeclErrorIfAny(FirstDeclMatcher<CXXRecordDecl>().match(\n          FromTU, cxxRecordDecl(hasName(\"A\"), isImplicit())));\n  EXPECT_TRUE(OptErr);\n  // An error is set to the implicit class of X.\n  OptErr =\n      Importer->getImportDeclErrorIfAny(FirstDeclMatcher<CXXRecordDecl>().match(\n          FromTU, cxxRecordDecl(hasName(\"X\"), isImplicit())));\n  EXPECT_TRUE(OptErr);\n}\n\nTEST_P(ErrorHandlingTest, ErrorIsNotPropagatedFromMemberToNamespace) {\n  TranslationUnitDecl *FromTU = getTuDecl(std::string(R\"(\n      namespace X {\n        void f() { )\") + ErroneousStmt + R\"( } // This member has the error\n                                               // during import.\n        void ok();        // The error should not prevent importing this.\n      };                  // An error will be set for X too.\n      )\",\n                                          Lang_CXX03);\n  auto *FromX = FirstDeclMatcher<NamespaceDecl>().match(\n      FromTU, namespaceDecl(hasName(\"X\")));\n  NamespaceDecl *ImportedX = Import(FromX, Lang_CXX03);\n\n  // There is no error set for X.\n  EXPECT_TRUE(ImportedX);\n  ASTImporter *Importer = findFromTU(FromX)->Importer.get();\n  Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromX);\n  ASSERT_FALSE(OptErr);\n\n  // An error is set for f().\n  auto *FromF = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n  OptErr = Importer->getImportDeclErrorIfAny(FromF);\n  ASSERT_TRUE(OptErr);\n  EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n  // And any subsequent import should fail.\n  FunctionDecl *ImportedF = Import(FromF, Lang_CXX03);\n  EXPECT_FALSE(ImportedF);\n\n  // There is no error set for ok().\n  auto *FromOK = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"ok\")));\n  OptErr = Importer->getImportDeclErrorIfAny(FromOK);\n  EXPECT_FALSE(OptErr);\n  // And we should be able to import.\n  FunctionDecl *ImportedOK = Import(FromOK, Lang_CXX03);\n  EXPECT_TRUE(ImportedOK);\n}\n\n// An error should be set for a class if it had a previous import with an error\n// from another TU.\nTEST_P(ErrorHandlingTest,\n       ImportedDeclWithErrorShouldFailTheImportOfDeclWhichMapToIt) {\n  // We already have a fwd decl.\n  TranslationUnitDecl *ToTU = getToTuDecl(\"class X;\", Lang_CXX03);\n  // Then we import a definition.\n  {\n    TranslationUnitDecl *FromTU = getTuDecl(std::string(R\"(\n        class X {\n          void f() { )\") + ErroneousStmt + R\"( }\n          void ok();\n        };\n        )\",\n                                            Lang_CXX03);\n    auto *FromX = FirstDeclMatcher<CXXRecordDecl>().match(\n        FromTU, cxxRecordDecl(hasName(\"X\")));\n    CXXRecordDecl *ImportedX = Import(FromX, Lang_CXX03);\n\n    // An error is set for X ...\n    EXPECT_FALSE(ImportedX);\n    ASTImporter *Importer = findFromTU(FromX)->Importer.get();\n    Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromX);\n    ASSERT_TRUE(OptErr);\n    EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n  }\n  // ... but the node had been created.\n  auto *ToXDef = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"X\"), isDefinition()));\n  // An error is set for \"ToXDef\" in the shared state.\n  Optional<ImportError> OptErr =\n      SharedStatePtr->getImportDeclErrorIfAny(ToXDef);\n  ASSERT_TRUE(OptErr);\n  EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n\n  auto *ToXFwd = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"X\"), unless(isDefinition())));\n  // An error is NOT set for the fwd Decl of X in the shared state.\n  OptErr = SharedStatePtr->getImportDeclErrorIfAny(ToXFwd);\n  ASSERT_FALSE(OptErr);\n\n  // Try to import  X again but from another TU.\n  {\n    TranslationUnitDecl *FromTU = getTuDecl(std::string(R\"(\n        class X {\n          void f() { )\") + ErroneousStmt + R\"( }\n          void ok();\n        };\n        )\",\n                                            Lang_CXX03, \"input1.cc\");\n\n    auto *FromX = FirstDeclMatcher<CXXRecordDecl>().match(\n        FromTU, cxxRecordDecl(hasName(\"X\")));\n    CXXRecordDecl *ImportedX = Import(FromX, Lang_CXX03);\n\n    // If we did not save the errors for the \"to\" context then the below checks\n    // would fail, because the lookup finds the fwd Decl of the existing\n    // definition in the \"to\" context. We can reach the existing definition via\n    // the found fwd Decl. That existing definition is structurally equivalent\n    // (we check only the fields) with this one we want to import, so we return\n    // with the existing definition, which is erroneous (one method is missing).\n\n    // The import should fail.\n    EXPECT_FALSE(ImportedX);\n    ASTImporter *Importer = findFromTU(FromX)->Importer.get();\n    Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromX);\n    // And an error is set for this new X in the \"from\" ctx.\n    ASSERT_TRUE(OptErr);\n    EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n  }\n}\n\nTEST_P(ErrorHandlingTest, ImportOfOverriddenMethods) {\n  auto MatchFooA =\n      functionDecl(hasName(\"foo\"), hasAncestor(cxxRecordDecl(hasName(\"A\"))));\n  auto MatchFooB =\n      functionDecl(hasName(\"foo\"), hasAncestor(cxxRecordDecl(hasName(\"B\"))));\n  auto MatchFooC =\n      functionDecl(hasName(\"foo\"), hasAncestor(cxxRecordDecl(hasName(\"C\"))));\n\n  // Provoke import of a method that has overridden methods with import error.\n  TranslationUnitDecl *FromTU = getTuDecl(std::string(R\"(\n        struct C;\n        struct A {\n          virtual void foo();\n          void f1(C *);\n        };\n        void A::foo() {\n          )\") + ErroneousStmt + R\"(\n        }\n        struct B : public A {\n          void foo() override;\n        };\n        struct C : public B {\n          void foo() override;\n        };\n        )\",\n                                          Lang_CXX11);\n  auto *FromFooA = FirstDeclMatcher<FunctionDecl>().match(FromTU, MatchFooA);\n  auto *FromFooB = FirstDeclMatcher<FunctionDecl>().match(FromTU, MatchFooB);\n  auto *FromFooC = FirstDeclMatcher<FunctionDecl>().match(FromTU, MatchFooC);\n\n  EXPECT_FALSE(Import(FromFooA, Lang_CXX11));\n  ASTImporter *Importer = findFromTU(FromFooA)->Importer.get();\n  auto CheckError = [&Importer](Decl *FromD) {\n    Optional<ImportError> OptErr = Importer->getImportDeclErrorIfAny(FromD);\n    ASSERT_TRUE(OptErr);\n    EXPECT_EQ(OptErr->Error, ImportError::UnsupportedConstruct);\n  };\n  CheckError(FromFooA);\n  EXPECT_FALSE(Import(FromFooB, Lang_CXX11));\n  CheckError(FromFooB);\n  EXPECT_FALSE(Import(FromFooC, Lang_CXX11));\n  CheckError(FromFooC);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, LambdaInFunctionBody) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      void f() {\n        auto L = [](){};\n      }\n      )\",\n      Lang_CXX11, \"input0.cc\");\n  auto Pattern = lambdaExpr();\n  CXXRecordDecl *FromL =\n      FirstDeclMatcher<LambdaExpr>().match(FromTU, Pattern)->getLambdaClass();\n\n  auto ToL = Import(FromL, Lang_CXX11);\n  unsigned ToLSize = std::distance(ToL->decls().begin(), ToL->decls().end());\n  unsigned FromLSize =\n      std::distance(FromL->decls().begin(), FromL->decls().end());\n  EXPECT_NE(ToLSize, 0u);\n  EXPECT_EQ(ToLSize, FromLSize);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, LambdaInFunctionParam) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename F>\n      void f(F L = [](){}) {}\n      )\",\n      Lang_CXX11, \"input0.cc\");\n  auto Pattern = lambdaExpr();\n  CXXRecordDecl *FromL =\n      FirstDeclMatcher<LambdaExpr>().match(FromTU, Pattern)->getLambdaClass();\n\n  auto ToL = Import(FromL, Lang_CXX11);\n  unsigned ToLSize = std::distance(ToL->decls().begin(), ToL->decls().end());\n  unsigned FromLSize =\n      std::distance(FromL->decls().begin(), FromL->decls().end());\n  EXPECT_NE(ToLSize, 0u);\n  EXPECT_EQ(ToLSize, FromLSize);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, LambdaInGlobalScope) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto l1 = [](unsigned lp) { return 1; };\n      auto l2 = [](int lp) { return 2; };\n      int f(int p) {\n        return l1(p) + l2(p);\n      }\n      )\",\n      Lang_CXX11, \"input0.cc\");\n  FunctionDecl *FromF = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n  FunctionDecl *ToF = Import(FromF, Lang_CXX11);\n  EXPECT_TRUE(ToF);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportExistingFriendClassTemplateDef) {\n  auto Code =\n      R\"(\n        template <class T1, class T2>\n        struct Base {\n          template <class U1, class U2>\n          friend struct Class;\n        };\n        template <class T1, class T2>\n        struct Class { };\n        )\";\n\n  TranslationUnitDecl *ToTU = getToTuDecl(Code, Lang_CXX03);\n  TranslationUnitDecl *FromTU = getTuDecl(Code, Lang_CXX03, \"input.cc\");\n\n  auto *ToClassProto = FirstDeclMatcher<ClassTemplateDecl>().match(\n      ToTU, classTemplateDecl(hasName(\"Class\")));\n  auto *ToClassDef = LastDeclMatcher<ClassTemplateDecl>().match(\n      ToTU, classTemplateDecl(hasName(\"Class\")));\n  ASSERT_FALSE(ToClassProto->isThisDeclarationADefinition());\n  ASSERT_TRUE(ToClassDef->isThisDeclarationADefinition());\n  // Previous friend decl is not linked to it!\n  ASSERT_FALSE(ToClassDef->getPreviousDecl());\n  ASSERT_EQ(ToClassDef->getMostRecentDecl(), ToClassDef);\n  ASSERT_EQ(ToClassProto->getMostRecentDecl(), ToClassProto);\n\n  auto *FromClassProto = FirstDeclMatcher<ClassTemplateDecl>().match(\n      FromTU, classTemplateDecl(hasName(\"Class\")));\n  auto *FromClassDef = LastDeclMatcher<ClassTemplateDecl>().match(\n      FromTU, classTemplateDecl(hasName(\"Class\")));\n  ASSERT_FALSE(FromClassProto->isThisDeclarationADefinition());\n  ASSERT_TRUE(FromClassDef->isThisDeclarationADefinition());\n  ASSERT_FALSE(FromClassDef->getPreviousDecl());\n  ASSERT_EQ(FromClassDef->getMostRecentDecl(), FromClassDef);\n  ASSERT_EQ(FromClassProto->getMostRecentDecl(), FromClassProto);\n\n  auto *ImportedDef = Import(FromClassDef, Lang_CXX03);\n  // At import we should find the definition for 'Class' even if the\n  // prototype (inside 'friend') for it comes first in the AST and is not\n  // linked to the definition.\n  EXPECT_EQ(ImportedDef, ToClassDef);\n}\n\nstruct LLDBLookupTest : ASTImporterOptionSpecificTestBase {\n  LLDBLookupTest() {\n    Creator = [](ASTContext &ToContext, FileManager &ToFileManager,\n                 ASTContext &FromContext, FileManager &FromFileManager,\n                 bool MinimalImport,\n                 const std::shared_ptr<ASTImporterSharedState> &SharedState) {\n      return new ASTImporter(ToContext, ToFileManager, FromContext,\n                             FromFileManager, MinimalImport,\n                             // We use the regular lookup.\n                             /*SharedState=*/nullptr);\n    };\n  }\n};\n\nTEST_P(LLDBLookupTest, ImporterShouldFindInTransparentContext) {\n  TranslationUnitDecl *ToTU = getToTuDecl(\n      R\"(\n      extern \"C\" {\n        class X{};\n      };\n      )\",\n      Lang_CXX03);\n  auto *ToX = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToTU, cxxRecordDecl(hasName(\"X\")));\n\n  // Set up a stub external storage.\n  ToTU->setHasExternalLexicalStorage(true);\n  // Set up DeclContextBits.HasLazyExternalLexicalLookups to true.\n  ToTU->setMustBuildLookupTable();\n  struct TestExternalASTSource : ExternalASTSource {};\n  ToTU->getASTContext().setExternalSource(new TestExternalASTSource());\n\n  Decl *FromTU = getTuDecl(\n      R\"(\n        class X;\n      )\",\n      Lang_CXX03);\n  auto *FromX = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"X\")));\n  auto *ImportedX = Import(FromX, Lang_CXX03);\n  // The lookup must find the existing class definition in the LinkageSpecDecl.\n  // Then the importer renders the existing and the new decl into one chain.\n  EXPECT_EQ(ImportedX->getCanonicalDecl(), ToX->getCanonicalDecl());\n}\n\nstruct SVEBuiltins : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(SVEBuiltins, ImportTypes) {\n  static const char *const TypeNames[] = {\n    \"__SVInt8_t\",\n    \"__SVInt16_t\",\n    \"__SVInt32_t\",\n    \"__SVInt64_t\",\n    \"__SVUint8_t\",\n    \"__SVUint16_t\",\n    \"__SVUint32_t\",\n    \"__SVUint64_t\",\n    \"__SVFloat16_t\",\n    \"__SVBFloat16_t\",\n    \"__SVFloat32_t\",\n    \"__SVFloat64_t\",\n    \"__SVBool_t\"\n  };\n\n  TranslationUnitDecl *ToTU = getToTuDecl(\"\", Lang_CXX03);\n  TranslationUnitDecl *FromTU = getTuDecl(\"\", Lang_CXX03, \"input.cc\");\n  for (auto *TypeName : TypeNames) {\n    auto *ToTypedef = FirstDeclMatcher<TypedefDecl>().match(\n      ToTU, typedefDecl(hasName(TypeName)));\n    QualType ToType = ToTypedef->getUnderlyingType();\n\n    auto *FromTypedef = FirstDeclMatcher<TypedefDecl>().match(\n      FromTU, typedefDecl(hasName(TypeName)));\n    QualType FromType = FromTypedef->getUnderlyingType();\n\n    QualType ImportedType = ImportType(FromType, FromTypedef, Lang_CXX03);\n    EXPECT_EQ(ImportedType, ToType);\n  }\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportOfDefaultImplicitFunctions) {\n  // Test that import of implicit functions works and the functions\n  // are merged into one chain.\n  auto GetDeclToImport = [this](StringRef File) {\n    Decl *FromTU = getTuDecl(\n        R\"(\n        struct X { };\n        // Force generating some implicit operator definitions for X.\n        void f() { X x1, x2; x1 = x2; X *x3 = new X; delete x3; }\n        )\",\n        Lang_CXX11, File);\n    auto *FromD = FirstDeclMatcher<CXXRecordDecl>().match(\n        FromTU, cxxRecordDecl(hasName(\"X\"), unless(isImplicit())));\n    // Destructor is picked as one example of implicit function.\n    return FromD->getDestructor();\n  };\n\n  auto *ToD1 = Import(GetDeclToImport(\"input1.cc\"), Lang_CXX11);\n  ASSERT_TRUE(ToD1);\n\n  auto *ToD2 = Import(GetDeclToImport(\"input2.cc\"), Lang_CXX11);\n  ASSERT_TRUE(ToD2);\n\n  EXPECT_EQ(ToD1->getCanonicalDecl(), ToD2->getCanonicalDecl());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportOfExplicitlyDefaultedOrDeleted) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n        struct X { X() = default; X(const X&) = delete; };\n      )\",\n      Lang_CXX11);\n  auto *FromX = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"X\")));\n  auto *ImportedX = Import(FromX, Lang_CXX11);\n  auto *Constr1 = FirstDeclMatcher<CXXConstructorDecl>().match(\n      ImportedX, cxxConstructorDecl(hasName(\"X\"), unless(isImplicit())));\n  auto *Constr2 = LastDeclMatcher<CXXConstructorDecl>().match(\n      ImportedX, cxxConstructorDecl(hasName(\"X\"), unless(isImplicit())));\n\n  ASSERT_TRUE(ImportedX);\n  EXPECT_TRUE(Constr1->isDefaulted());\n  EXPECT_TRUE(Constr1->isExplicitlyDefaulted());\n  EXPECT_TRUE(Constr2->isDeletedAsWritten());\n  EXPECT_EQ(ImportedX->isAggregate(), FromX->isAggregate());\n}\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, SVEBuiltins,\n                        ::testing::Values(std::vector<std::string>{\n                            \"-target\", \"aarch64-linux-gnu\"}), );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, DeclContextTest,\n                        ::testing::Values(std::vector<std::string>()), );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, CanonicalRedeclChain,\n                        ::testing::Values(std::vector<std::string>()), );\n\nTEST_P(ASTImporterOptionSpecificTestBase, LambdasAreDifferentiated) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      void f() {\n        auto L0 = [](){};\n        auto L1 = [](){};\n      }\n      )\",\n      Lang_CXX11, \"input0.cc\");\n  auto Pattern = lambdaExpr();\n  CXXRecordDecl *FromL0 =\n      FirstDeclMatcher<LambdaExpr>().match(FromTU, Pattern)->getLambdaClass();\n  CXXRecordDecl *FromL1 =\n      LastDeclMatcher<LambdaExpr>().match(FromTU, Pattern)->getLambdaClass();\n  ASSERT_NE(FromL0, FromL1);\n\n  CXXRecordDecl *ToL0 = Import(FromL0, Lang_CXX11);\n  CXXRecordDecl *ToL1 = Import(FromL1, Lang_CXX11);\n  EXPECT_NE(ToL0, ToL1);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       LambdasInFunctionParamsAreDifferentiated) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename F0, typename F1>\n      void f(F0 L0 = [](){}, F1 L1 = [](){}) {}\n      )\",\n      Lang_CXX11, \"input0.cc\");\n  auto Pattern = cxxRecordDecl(isLambda());\n  CXXRecordDecl *FromL0 =\n      FirstDeclMatcher<CXXRecordDecl>().match(FromTU, Pattern);\n  CXXRecordDecl *FromL1 =\n      LastDeclMatcher<CXXRecordDecl>().match(FromTU, Pattern);\n  ASSERT_NE(FromL0, FromL1);\n\n  CXXRecordDecl *ToL0 = Import(FromL0, Lang_CXX11);\n  CXXRecordDecl *ToL1 = Import(FromL1, Lang_CXX11);\n  ASSERT_NE(ToL0, ToL1);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       LambdasInFunctionParamsAreDifferentiatedWhenMacroIsUsed) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      #define LAMBDA [](){}\n      template <typename F0, typename F1>\n      void f(F0 L0 = LAMBDA, F1 L1 = LAMBDA) {}\n      )\",\n      Lang_CXX11, \"input0.cc\");\n  auto Pattern = cxxRecordDecl(isLambda());\n  CXXRecordDecl *FromL0 =\n      FirstDeclMatcher<CXXRecordDecl>().match(FromTU, Pattern);\n  CXXRecordDecl *FromL1 =\n      LastDeclMatcher<CXXRecordDecl>().match(FromTU, Pattern);\n  ASSERT_NE(FromL0, FromL1);\n\n  Import(FromL0, Lang_CXX11);\n  Import(FromL1, Lang_CXX11);\n  CXXRecordDecl *ToL0 = Import(FromL0, Lang_CXX11);\n  CXXRecordDecl *ToL1 = Import(FromL1, Lang_CXX11);\n  ASSERT_NE(ToL0, ToL1);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportAssignedLambda) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      void f() {\n        auto x = []{} = {}; auto x2 = x;\n      }\n      )\",\n      Lang_CXX20, \"input0.cc\");\n  auto FromF = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n  // We have only one lambda class.\n  ASSERT_EQ(\n      DeclCounter<CXXRecordDecl>().match(FromTU, cxxRecordDecl(isLambda())),\n      1u);\n\n  FunctionDecl *ToF = Import(FromF, Lang_CXX20);\n  EXPECT_TRUE(ToF);\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  // We have only one lambda class after the import.\n  EXPECT_EQ(DeclCounter<CXXRecordDecl>().match(ToTU, cxxRecordDecl(isLambda())),\n            1u);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportDefaultConstructibleLambdas) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      void f() {\n        auto x = []{} = {};\n        auto xb = []{} = {};\n      }\n      )\",\n      Lang_CXX20, \"input0.cc\");\n  auto FromF = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n  // We have two lambda classes.\n  ASSERT_EQ(\n      DeclCounter<CXXRecordDecl>().match(FromTU, cxxRecordDecl(isLambda())),\n      2u);\n\n  FunctionDecl *ToF = Import(FromF, Lang_CXX20);\n  EXPECT_TRUE(ToF);\n  TranslationUnitDecl *ToTU = ToAST->getASTContext().getTranslationUnitDecl();\n  // We have two lambda classes after the import.\n  EXPECT_EQ(DeclCounter<CXXRecordDecl>().match(ToTU, cxxRecordDecl(isLambda())),\n            2u);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImplicitlyDeclareSelf) {\n  Decl *FromTU = getTuDecl(R\"(\n                           __attribute__((objc_root_class))\n                           @interface Root\n                           @end\n                           @interface C : Root\n                             -(void)method;\n                           @end\n                           @implementation C\n                             -(void)method {}\n                           @end\n                           )\",\n                           Lang_OBJCXX, \"input.mm\");\n  auto *FromMethod = LastDeclMatcher<ObjCMethodDecl>().match(\n      FromTU, namedDecl(hasName(\"method\")));\n  ASSERT_TRUE(FromMethod);\n  auto ToMethod = Import(FromMethod, Lang_OBJCXX);\n  ASSERT_TRUE(ToMethod);\n\n  // Both methods should have their implicit parameters.\n  EXPECT_TRUE(FromMethod->getSelfDecl() != nullptr);\n  EXPECT_TRUE(ToMethod->getSelfDecl() != nullptr);\n}\n\nstruct ImportAutoFunctions : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportAutoFunctions, ReturnWithTypedefDeclaredInside) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto X = [](long l) {\n        using int_type = long;\n        auto dur = 13;\n        return static_cast<int_type>(dur);\n      };\n      )\",\n      Lang_CXX14, \"input0.cc\");\n  CXXMethodDecl *From =\n      FirstDeclMatcher<CXXMethodDecl>().match(FromTU, cxxMethodDecl());\n\n  // Explicitly set the return type of the lambda's operator() to the TypeAlias.\n  // Normally the return type would be the built-in 'long' type. However, there\n  // are cases when Clang does not use the canonical type and the TypeAlias is\n  // used. I could not create such an AST from regular source code, it requires\n  // some special state in the preprocessor. I've found such an AST when Clang\n  // parsed libcxx/src/filesystem/directory_iterator.cpp, but could not reduce\n  // that with creduce, because after preprocessing, the AST no longer\n  // contained the TypeAlias as a return type of the lambda.\n  ASTContext &Ctx = From->getASTContext();\n  TypeAliasDecl *FromTA =\n      FirstDeclMatcher<TypeAliasDecl>().match(FromTU, typeAliasDecl());\n  QualType TT = Ctx.getTypedefType(FromTA);\n  const FunctionProtoType *FPT = cast<FunctionProtoType>(From->getType());\n  QualType NewFunType =\n      Ctx.getFunctionType(TT, FPT->getParamTypes(), FPT->getExtProtoInfo());\n  From->setType(NewFunType);\n\n  CXXMethodDecl *To = Import(From, Lang_CXX14);\n  EXPECT_TRUE(To);\n  EXPECT_TRUE(isa<TypedefType>(To->getReturnType()));\n}\n\nTEST_P(ImportAutoFunctions, ReturnWithStructDeclaredInside) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto foo() {\n        struct X {};\n        return X();\n      }\n      )\",\n      Lang_CXX14, \"input0.cc\");\n  FunctionDecl *From =\n      FirstDeclMatcher<FunctionDecl>().match(FromTU, functionDecl());\n\n  FunctionDecl *To = Import(From, Lang_CXX14);\n  EXPECT_TRUE(To);\n  EXPECT_TRUE(isa<AutoType>(To->getReturnType()));\n}\n\nTEST_P(ImportAutoFunctions, ReturnWithStructDeclaredInside2) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto foo() {\n        struct X {};\n        return X();\n      }\n      )\",\n      Lang_CXX14, \"input0.cc\");\n  FunctionDecl *From =\n      FirstDeclMatcher<FunctionDecl>().match(FromTU, functionDecl());\n\n  // This time import the type directly.\n  QualType ToT = ImportType(From->getType(), From, Lang_CXX14);\n  const FunctionProtoType *FPT = cast<FunctionProtoType>(ToT);\n  EXPECT_TRUE(isa<AutoType>(FPT->getReturnType()));\n}\n\nTEST_P(ImportAutoFunctions, ReturnWithTypedefToStructDeclaredInside) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto foo() {\n        struct X {};\n        using Y = X;\n        return Y();\n      }\n      )\",\n      Lang_CXX14, \"input0.cc\");\n  FunctionDecl *From =\n      FirstDeclMatcher<FunctionDecl>().match(FromTU, functionDecl());\n\n  FunctionDecl *To = Import(From, Lang_CXX14);\n  EXPECT_TRUE(To);\n  EXPECT_TRUE(isa<AutoType>(To->getReturnType()));\n}\n\nTEST_P(ImportAutoFunctions, ReturnWithStructDeclaredNestedInside) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto foo() {\n        struct X { struct Y{}; };\n        return X::Y();\n      }\n      )\",\n      Lang_CXX14, \"input0.cc\");\n  FunctionDecl *From =\n      FirstDeclMatcher<FunctionDecl>().match(FromTU, functionDecl());\n\n  FunctionDecl *To = Import(From, Lang_CXX14);\n  EXPECT_TRUE(To);\n  EXPECT_TRUE(isa<AutoType>(To->getReturnType()));\n}\n\nTEST_P(ImportAutoFunctions, ReturnWithInternalLambdaType) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto f() {\n        auto l = []() {\n          struct X {};\n          return X();\n        };\n        return l();\n      }\n      )\",\n      Lang_CXX17, \"input0.cc\");\n  FunctionDecl *From = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n\n  FunctionDecl *To = Import(From, Lang_CXX17);\n  EXPECT_TRUE(To);\n  EXPECT_TRUE(isa<AutoType>(To->getReturnType()));\n}\n\nTEST_P(ImportAutoFunctions, ReturnWithTypeInIf) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto f() {\n        if (struct X {} x; true)\n          return X();\n        else\n          return X();\n      }\n      )\",\n      Lang_CXX17, \"input0.cc\");\n  FunctionDecl *From = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n\n  FunctionDecl *To = Import(From, Lang_CXX17);\n  EXPECT_TRUE(To);\n  EXPECT_TRUE(isa<AutoType>(To->getReturnType()));\n}\n\nTEST_P(ImportAutoFunctions, ReturnWithTypeInFor) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto f() {\n        for (struct X {} x;;)\n          return X();\n      }\n      )\",\n      Lang_CXX17, \"input0.cc\");\n  FunctionDecl *From = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n\n  FunctionDecl *To = Import(From, Lang_CXX17);\n  EXPECT_TRUE(To);\n  EXPECT_TRUE(isa<AutoType>(To->getReturnType()));\n}\n\nTEST_P(ImportAutoFunctions, ReturnWithTypeInSwitch) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      auto f() {\n        switch (struct X {} x; 10) {\n        case 10:\n          return X();\n        }\n      }\n      )\",\n      Lang_CXX17, \"input0.cc\");\n  FunctionDecl *From = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"f\")));\n\n  FunctionDecl *To = Import(From, Lang_CXX17);\n  EXPECT_TRUE(To);\n  EXPECT_TRUE(isa<AutoType>(To->getReturnType()));\n}\n\nstruct ImportSourceLocations : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(ImportSourceLocations, PreserveFileIDTreeStructure) {\n  // Tests that the FileID tree structure (with the links being the include\n  // chains) is preserved while importing other files (which need to be\n  // added to this structure with fake include locations.\n\n  SourceLocation Location1;\n  {\n    auto Pattern = varDecl(hasName(\"X\"));\n    Decl *FromTU = getTuDecl(\"int X;\", Lang_C99, \"input0.c\");\n    auto *FromD = FirstDeclMatcher<VarDecl>().match(FromTU, Pattern);\n\n    Location1 = Import(FromD, Lang_C99)->getLocation();\n  }\n  SourceLocation Location2;\n  {\n    auto Pattern = varDecl(hasName(\"Y\"));\n    Decl *FromTU = getTuDecl(\"int Y;\", Lang_C99, \"input1.c\");\n    auto *FromD = FirstDeclMatcher<VarDecl>().match(FromTU, Pattern);\n\n    Location2 = Import(FromD, Lang_C99)->getLocation();\n  }\n\n  SourceManager &ToSM = ToAST->getSourceManager();\n  FileID FileID1 = ToSM.getFileID(Location1);\n  FileID FileID2 = ToSM.getFileID(Location2);\n\n  // Check that the imported files look like as if they were included from the\n  // start of the main file.\n  SourceLocation FileStart = ToSM.getLocForStartOfFile(ToSM.getMainFileID());\n  EXPECT_NE(FileID1, ToSM.getMainFileID());\n  EXPECT_NE(FileID2, ToSM.getMainFileID());\n  EXPECT_EQ(ToSM.getIncludeLoc(FileID1), FileStart);\n  EXPECT_EQ(ToSM.getIncludeLoc(FileID2), FileStart);\n\n  // Let the SourceManager check the order of the locations. The order should\n  // be the order in which the declarations are imported.\n  EXPECT_TRUE(ToSM.isBeforeInTranslationUnit(Location1, Location2));\n  EXPECT_FALSE(ToSM.isBeforeInTranslationUnit(Location2, Location1));\n}\n\nTEST_P(ImportSourceLocations, NormalFileBuffer) {\n  // Test importing normal file buffers.\n\n  std::string Path = \"input0.c\";\n  std::string Source = \"int X;\";\n  TranslationUnitDecl *FromTU = getTuDecl(Source, Lang_C99, Path);\n\n  SourceLocation ImportedLoc;\n  {\n    // Import the VarDecl to trigger the importing of the FileID.\n    auto Pattern = varDecl(hasName(\"X\"));\n    VarDecl *FromD = FirstDeclMatcher<VarDecl>().match(FromTU, Pattern);\n    ImportedLoc = Import(FromD, Lang_C99)->getLocation();\n  }\n\n  // Make sure the imported buffer has the original contents.\n  SourceManager &ToSM = ToAST->getSourceManager();\n  FileID ImportedID = ToSM.getFileID(ImportedLoc);\n  EXPECT_EQ(Source,\n            ToSM.getBufferOrFake(ImportedID, SourceLocation()).getBuffer());\n}\n\nTEST_P(ImportSourceLocations, OverwrittenFileBuffer) {\n  // Test importing overwritten file buffers.\n\n  std::string Path = \"input0.c\";\n  TranslationUnitDecl *FromTU = getTuDecl(\"int X;\", Lang_C99, Path);\n\n  // Overwrite the file buffer for our input file with new content.\n  const std::string Contents = \"overwritten contents\";\n  SourceLocation ImportedLoc;\n  {\n    SourceManager &FromSM = FromTU->getASTContext().getSourceManager();\n    clang::FileManager &FM = FromSM.getFileManager();\n    const clang::FileEntry &FE =\n        *FM.getVirtualFile(Path, static_cast<off_t>(Contents.size()), 0);\n\n    llvm::SmallVector<char, 64> Buffer;\n    Buffer.append(Contents.begin(), Contents.end());\n    auto FileContents =\n        std::make_unique<llvm::SmallVectorMemoryBuffer>(std::move(Buffer), Path);\n    FromSM.overrideFileContents(&FE, std::move(FileContents));\n\n    // Import the VarDecl to trigger the importing of the FileID.\n    auto Pattern = varDecl(hasName(\"X\"));\n    VarDecl *FromD = FirstDeclMatcher<VarDecl>().match(FromTU, Pattern);\n    ImportedLoc = Import(FromD, Lang_C99)->getLocation();\n  }\n\n  // Make sure the imported buffer has the overwritten contents.\n  SourceManager &ToSM = ToAST->getSourceManager();\n  FileID ImportedID = ToSM.getFileID(ImportedLoc);\n  EXPECT_EQ(Contents,\n            ToSM.getBufferOrFake(ImportedID, SourceLocation()).getBuffer());\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportExprOfAlignmentAttr) {\n  // Test if import of these packed and aligned attributes does not trigger an\n  // error situation where source location from 'From' context is referenced in\n  // 'To' context through evaluation of the alignof attribute.\n  // This happens if the 'alignof(A)' expression is not imported correctly.\n  Decl *FromTU = getTuDecl(\n      R\"(\n      struct __attribute__((packed)) A { int __attribute__((aligned(8))) X; };\n      struct alignas(alignof(A)) S {};\n      )\",\n      Lang_CXX11, \"input.cc\");\n  auto *FromD = FirstDeclMatcher<CXXRecordDecl>().match(\n      FromTU, cxxRecordDecl(hasName(\"S\"), unless(isImplicit())));\n  ASSERT_TRUE(FromD);\n\n  auto *ToD = Import(FromD, Lang_CXX11);\n  ASSERT_TRUE(ToD);\n\n  auto *FromAttr = FromD->getAttr<AlignedAttr>();\n  auto *ToAttr = ToD->getAttr<AlignedAttr>();\n  EXPECT_EQ(FromAttr->isInherited(), ToAttr->isInherited());\n  EXPECT_EQ(FromAttr->isPackExpansion(), ToAttr->isPackExpansion());\n  EXPECT_EQ(FromAttr->isImplicit(), ToAttr->isImplicit());\n  EXPECT_EQ(FromAttr->getSyntax(), ToAttr->getSyntax());\n  EXPECT_EQ(FromAttr->getSemanticSpelling(), ToAttr->getSemanticSpelling());\n  EXPECT_TRUE(ToAttr->getAlignmentExpr());\n\n  auto *ToA = FirstDeclMatcher<CXXRecordDecl>().match(\n      ToD->getTranslationUnitDecl(),\n      cxxRecordDecl(hasName(\"A\"), unless(isImplicit())));\n  // Ensure that 'struct A' was imported (through reference from attribute of\n  // 'S').\n  EXPECT_TRUE(ToA);\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase, ImportFormatAttr) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      int foo(const char * fmt, ...)\n      __attribute__ ((__format__ (__scanf__, 1, 2)));\n      )\",\n      Lang_CXX03, \"input.cc\");\n  auto *FromD = FirstDeclMatcher<FunctionDecl>().match(\n      FromTU, functionDecl(hasName(\"foo\")));\n  ASSERT_TRUE(FromD);\n\n  auto *ToD = Import(FromD, Lang_CXX03);\n  ASSERT_TRUE(ToD);\n  ToD->dump(); // Should not crash!\n\n  auto *FromAttr = FromD->getAttr<FormatAttr>();\n  auto *ToAttr = ToD->getAttr<FormatAttr>();\n  EXPECT_EQ(FromAttr->isInherited(), ToAttr->isInherited());\n  EXPECT_EQ(FromAttr->isPackExpansion(), ToAttr->isPackExpansion());\n  EXPECT_EQ(FromAttr->isImplicit(), ToAttr->isImplicit());\n  EXPECT_EQ(FromAttr->getSyntax(), ToAttr->getSyntax());\n  EXPECT_EQ(FromAttr->getAttributeSpellingListIndex(),\n            ToAttr->getAttributeSpellingListIndex());\n  EXPECT_EQ(FromAttr->getType()->getName(), ToAttr->getType()->getName());\n}\ntemplate <typename T>\nauto ExtendWithOptions(const T &Values, const std::vector<std::string> &Args) {\n  auto Copy = Values;\n  for (std::vector<std::string> &ArgV : Copy) {\n    for (const std::string &Arg : Args) {\n      ArgV.push_back(Arg);\n    }\n  }\n  return ::testing::ValuesIn(Copy);\n}\n\nstruct ImportWithExternalSource : ASTImporterOptionSpecificTestBase {\n  ImportWithExternalSource() {\n    Creator = [](ASTContext &ToContext, FileManager &ToFileManager,\n                 ASTContext &FromContext, FileManager &FromFileManager,\n                 bool MinimalImport,\n                 const std::shared_ptr<ASTImporterSharedState> &SharedState) {\n      return new ASTImporter(ToContext, ToFileManager, FromContext,\n                             FromFileManager, MinimalImport,\n                             // We use the regular lookup.\n                             /*SharedState=*/nullptr);\n    };\n  }\n};\n\n/// An ExternalASTSource that keeps track of the tags is completed.\nstruct SourceWithCompletedTagList : clang::ExternalASTSource {\n  std::vector<clang::TagDecl *> &CompletedTags;\n  SourceWithCompletedTagList(std::vector<clang::TagDecl *> &CompletedTags)\n      : CompletedTags(CompletedTags) {}\n  void CompleteType(TagDecl *Tag) override {\n    auto *Record = cast<CXXRecordDecl>(Tag);\n    Record->startDefinition();\n    Record->completeDefinition();\n    CompletedTags.push_back(Tag);\n  }\n  using clang::ExternalASTSource::CompleteType;\n};\n\nTEST_P(ImportWithExternalSource, CompleteRecordBeforeImporting) {\n  // Create an empty TU.\n  TranslationUnitDecl *FromTU = getTuDecl(\"\", Lang_CXX03, \"input.cpp\");\n\n  // Create and add the test ExternalASTSource.\n  std::vector<clang::TagDecl *> CompletedTags;\n  IntrusiveRefCntPtr<ExternalASTSource> source =\n      new SourceWithCompletedTagList(CompletedTags);\n  clang::ASTContext &Context = FromTU->getASTContext();\n  Context.setExternalSource(std::move(source));\n\n  // Create a dummy class by hand with external lexical storage.\n  IdentifierInfo &Ident = Context.Idents.get(\"test_class\");\n  auto *Record = CXXRecordDecl::Create(\n      Context, TTK_Class, FromTU, SourceLocation(), SourceLocation(), &Ident);\n  Record->setHasExternalLexicalStorage();\n  FromTU->addDecl(Record);\n\n  // Do a minimal import of the created class.\n  EXPECT_EQ(0U, CompletedTags.size());\n  Import(Record, Lang_CXX03);\n  EXPECT_EQ(0U, CompletedTags.size());\n\n  // Import the definition of the created class.\n  llvm::Error Err = findFromTU(Record)->Importer->ImportDefinition(Record);\n  EXPECT_FALSE((bool)Err);\n  consumeError(std::move(Err));\n\n  // Make sure the class was completed once.\n  EXPECT_EQ(1U, CompletedTags.size());\n  EXPECT_EQ(Record, CompletedTags.front());\n}\n\nTEST_P(ImportFunctions, CTADImplicit) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename T> struct A {\n        A(T);\n      };\n      A a{(int)0};\n      )\",\n      Lang_CXX17, \"input.cc\");\n  auto *FromD = FirstDeclMatcher<CXXDeductionGuideDecl>().match(\n      FromTU,\n      cxxDeductionGuideDecl(hasParameter(0, hasType(asString(\"A<T>\")))));\n  auto *ToD = Import(FromD, Lang_CXX17);\n  ASSERT_TRUE(ToD);\n  EXPECT_TRUE(ToD->isCopyDeductionCandidate());\n  // Check that the deduced class template is also imported.\n  EXPECT_TRUE(findFromTU(FromD)->Importer->GetAlreadyImportedOrNull(\n      FromD->getDeducedTemplate()));\n}\n\nTEST_P(ImportFunctions, CTADUserDefinedExplicit) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n      template <typename T> struct A {\n        A(T);\n      };\n      template <typename T> explicit A(T) -> A<float>;\n      A a{(int)0}; // calls A<float>::A(float)\n      )\",\n      Lang_CXX17, \"input.cc\");\n  auto *FromD = FirstDeclMatcher<CXXDeductionGuideDecl>().match(\n      FromTU, cxxDeductionGuideDecl(unless(isImplicit())));\n  // Not-implicit: i.e. not compiler-generated, user defined.\n  ASSERT_FALSE(FromD->isImplicit());\n  ASSERT_TRUE(FromD->isExplicit()); // Has the explicit keyword.\n  auto *ToD = Import(FromD, Lang_CXX17);\n  ASSERT_TRUE(ToD);\n  EXPECT_FALSE(FromD->isImplicit());\n  EXPECT_TRUE(ToD->isExplicit());\n}\n\nTEST_P(ImportFunctions, CTADWithLocalTypedef) {\n  Decl *TU = getTuDecl(\n      R\"(\n      template <typename T> struct A {\n        typedef T U;\n        A(U);\n      };\n      A a{(int)0};\n      )\",\n      Lang_CXX17, \"input.cc\");\n  auto *FromD = FirstDeclMatcher<CXXDeductionGuideDecl>().match(\n      TU, cxxDeductionGuideDecl());\n  auto *ToD = Import(FromD, Lang_CXX17);\n  ASSERT_TRUE(ToD);\n}\n\n// FIXME Move these tests out of ASTImporterTest. For that we need to factor\n// out the ASTImporter specific pars from ASTImporterOptionSpecificTestBase\n// into a new test Fixture. Then we should lift up this Fixture to its own\n// implementation file and only then could we reuse the Fixture in other AST\n// unitttests.\nstruct CTAD : ASTImporterOptionSpecificTestBase {};\n\nTEST_P(CTAD, DeductionGuideShouldReferToANonLocalTypedef) {\n  Decl *TU = getTuDecl(\n      R\"(\n      typedef int U;\n      template <typename T> struct A {\n        A(U, T);\n      };\n      A a{(int)0, (int)0};\n      )\",\n      Lang_CXX17, \"input.cc\");\n  auto *Guide = FirstDeclMatcher<CXXDeductionGuideDecl>().match(\n      TU, cxxDeductionGuideDecl());\n  auto *Typedef = FirstDeclMatcher<TypedefNameDecl>().match(\n      TU, typedefNameDecl(hasName(\"U\")));\n  ParmVarDecl *Param = Guide->getParamDecl(0);\n  // The type of the first param (which is a typedef) should match the typedef\n  // in the global scope.\n  EXPECT_EQ(Param->getType()->getAs<TypedefType>()->getDecl(), Typedef);\n}\n\nTEST_P(CTAD, DeductionGuideShouldReferToANonLocalTypedefInParamPtr) {\n  Decl *TU = getTuDecl(\n      R\"(\n      typedef int U;\n      template <typename T> struct A {\n        A(U*, T);\n      };\n      A a{(int*)0, (int)0};\n      )\",\n      Lang_CXX17, \"input.cc\");\n  auto *Guide = FirstDeclMatcher<CXXDeductionGuideDecl>().match(\n      TU, cxxDeductionGuideDecl());\n  auto *Typedef = FirstDeclMatcher<TypedefNameDecl>().match(\n      TU, typedefNameDecl(hasName(\"U\")));\n  ParmVarDecl *Param = Guide->getParamDecl(0);\n  EXPECT_EQ(Param->getType()\n                ->getAs<PointerType>()\n                ->getPointeeType()\n                ->getAs<TypedefType>()\n                ->getDecl(),\n            Typedef);\n}\n\nTEST_P(CTAD, DeductionGuideShouldCopyALocalTypedef) {\n  Decl *TU = getTuDecl(\n      R\"(\n      template <typename T> struct A {\n        typedef T U;\n        A(U, T);\n      };\n      A a{(int)0, (int)0};\n      )\",\n      Lang_CXX17, \"input.cc\");\n  auto *Guide = FirstDeclMatcher<CXXDeductionGuideDecl>().match(\n      TU, cxxDeductionGuideDecl());\n  auto *Typedef = FirstDeclMatcher<TypedefNameDecl>().match(\n      TU, typedefNameDecl(hasName(\"U\")));\n  ParmVarDecl *Param = Guide->getParamDecl(0);\n  EXPECT_NE(Param->getType()->getAs<TypedefType>()->getDecl(), Typedef);\n}\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, CTAD,\n                        DefaultTestValuesForRunOptions, );\n\nTEST_P(ASTImporterOptionSpecificTestBase, TypedefWithAttribute) {\n  Decl *TU = getTuDecl(\n      R\"(\n      namespace N {\n        typedef int X __attribute__((annotate(\"A\")));\n      }\n      )\",\n      Lang_CXX17, \"input.cc\");\n  auto *FromD =\n      FirstDeclMatcher<TypedefDecl>().match(TU, typedefDecl(hasName(\"X\")));\n  auto *ToD = Import(FromD, Lang_CXX17);\n  ASSERT_TRUE(ToD);\n  ASSERT_EQ(ToD->getAttrs().size(), 1U);\n  auto *ToAttr = dyn_cast<AnnotateAttr>(ToD->getAttrs()[0]);\n  ASSERT_TRUE(ToAttr);\n  EXPECT_EQ(ToAttr->getAnnotation(), \"A\");\n}\n\nTEST_P(ASTImporterOptionSpecificTestBase,\n       ImportOfTemplatedDeclWhenPreviousDeclHasNoDescribedTemplateSet) {\n  Decl *FromTU = getTuDecl(\n      R\"(\n\n      namespace std {\n        template<typename T>\n        class basic_stringbuf;\n      }\n      namespace std {\n        class char_traits;\n        template<typename T = char_traits>\n        class basic_stringbuf;\n      }\n      namespace std {\n        template<typename T>\n        class basic_stringbuf {};\n      }\n\n      )\",\n      Lang_CXX11);\n\n  auto *From1 = FirstDeclMatcher<ClassTemplateDecl>().match(\n      FromTU,\n      classTemplateDecl(hasName(\"basic_stringbuf\"), unless(isImplicit())));\n  auto *To1 = cast_or_null<ClassTemplateDecl>(Import(From1, Lang_CXX11));\n  EXPECT_TRUE(To1);\n\n  auto *From2 = LastDeclMatcher<ClassTemplateDecl>().match(\n      FromTU,\n      classTemplateDecl(hasName(\"basic_stringbuf\"), unless(isImplicit())));\n  auto *To2 = cast_or_null<ClassTemplateDecl>(Import(From2, Lang_CXX11));\n  EXPECT_TRUE(To2);\n}\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ASTImporterLookupTableTest,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportPath,\n                        ::testing::Values(std::vector<std::string>()), );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportExpr,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportFixedPointExpr,\n                        ExtendWithOptions(DefaultTestArrayForRunOptions,\n                                          std::vector<std::string>{\n                                              \"-ffixed-point\"}), );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportType,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportDecl,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ASTImporterOptionSpecificTestBase,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ErrorHandlingTest,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, RedirectingImporterTest,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportFunctions,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportAutoFunctions,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportFunctionTemplates,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportFriendFunctionTemplates,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportClasses,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportFriendFunctions,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportFriendClasses,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests,\n                        ImportFunctionTemplateSpecializations,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportImplicitMethods,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportVariables,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, LLDBLookupTest,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportSourceLocations,\n                        DefaultTestValuesForRunOptions, );\n\nINSTANTIATE_TEST_CASE_P(ParameterizedTests, ImportWithExternalSource,\n                        DefaultTestValuesForRunOptions, );\n\n} // end namespace ast_matchers\n} // end namespace clang\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h", "content": "//===--- ASTMatchersMacros.h - Structural query framework -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  Defines macros that enable us to define new matchers in a single place.\n//  Since a matcher is a function which returns a Matcher<T> object, where\n//  T is the type of the actual implementation of the matcher, the macros allow\n//  us to write matchers like functions and take care of the definition of the\n//  class boilerplate.\n//\n//  Note that when you define a matcher with an AST_MATCHER* macro, only the\n//  function which creates the matcher goes into the current namespace - the\n//  class that implements the actual matcher, which gets returned by the\n//  generator function, is put into the 'internal' namespace. This allows us\n//  to only have the functions (which is all the user cares about) in the\n//  'ast_matchers' namespace and hide the boilerplate.\n//\n//  To define a matcher in user code, put it into your own namespace. This would\n//  help to prevent ODR violations in case a matcher with the same name is\n//  defined in multiple translation units:\n//\n//  namespace my_matchers {\n//  AST_MATCHER_P(clang::MemberExpr, Member,\n//                clang::ast_matchers::internal::Matcher<clang::ValueDecl>,\n//                InnerMatcher) {\n//    return InnerMatcher.matches(*Node.getMemberDecl(), Finder, Builder);\n//  }\n//  } // namespace my_matchers\n//\n//  Alternatively, an unnamed namespace may be used:\n//\n//  namespace clang {\n//  namespace ast_matchers {\n//  namespace {\n//  AST_MATCHER_P(MemberExpr, Member,\n//                internal::Matcher<ValueDecl>, InnerMatcher) {\n//    return InnerMatcher.matches(*Node.getMemberDecl(), Finder, Builder);\n//  }\n//  } // namespace\n//  } // namespace ast_matchers\n//  } // namespace clang\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_ASTMATCHERS_ASTMATCHERSMACROS_H\n#define LLVM_CLANG_ASTMATCHERS_ASTMATCHERSMACROS_H\n\n/// AST_MATCHER_FUNCTION(ReturnType, DefineMatcher) { ... }\n/// defines a zero parameter function named DefineMatcher() that returns a\n/// ReturnType object.\n#define AST_MATCHER_FUNCTION(ReturnType, DefineMatcher)                        \\\n  inline ReturnType DefineMatcher##_getInstance();                             \\\n  inline ReturnType DefineMatcher() {                                          \\\n    return ::clang::ast_matchers::internal::MemoizedMatcher<                   \\\n        ReturnType, DefineMatcher##_getInstance>::getInstance();               \\\n  }                                                                            \\\n  inline ReturnType DefineMatcher##_getInstance()\n\n/// AST_MATCHER_FUNCTION_P(ReturnType, DefineMatcher, ParamType, Param) {\n/// ... }\n/// defines a single-parameter function named DefineMatcher() that returns a\n/// ReturnType object.\n///\n/// The code between the curly braces has access to the following variables:\n///\n///   Param:                 the parameter passed to the function; its type\n///                          is ParamType.\n///\n/// The code should return an instance of ReturnType.\n#define AST_MATCHER_FUNCTION_P(ReturnType, DefineMatcher, ParamType, Param)    \\\n  AST_MATCHER_FUNCTION_P_OVERLOAD(ReturnType, DefineMatcher, ParamType, Param, \\\n                                  0)\n#define AST_MATCHER_FUNCTION_P_OVERLOAD(ReturnType, DefineMatcher, ParamType,  \\\n                                        Param, OverloadId)                     \\\n  inline ReturnType DefineMatcher(ParamType const &Param);                     \\\n  typedef ReturnType (&DefineMatcher##_Type##OverloadId)(ParamType const &);   \\\n  inline ReturnType DefineMatcher(ParamType const &Param)\n\n/// AST_MATCHER(Type, DefineMatcher) { ... }\n/// defines a zero parameter function named DefineMatcher() that returns a\n/// Matcher<Type> object.\n///\n/// The code between the curly braces has access to the following variables:\n///\n///   Node:                  the AST node being matched; its type is Type.\n///   Finder:                an ASTMatchFinder*.\n///   Builder:               a BoundNodesTreeBuilder*.\n///\n/// The code should return true if 'Node' matches.\n#define AST_MATCHER(Type, DefineMatcher)                                       \\\n  namespace internal {                                                         \\\n  class matcher_##DefineMatcher##Matcher                                       \\\n      : public ::clang::ast_matchers::internal::MatcherInterface<Type> {       \\\n  public:                                                                      \\\n    explicit matcher_##DefineMatcher##Matcher() = default;                     \\\n    bool matches(const Type &Node,                                             \\\n                 ::clang::ast_matchers::internal::ASTMatchFinder *Finder,      \\\n                 ::clang::ast_matchers::internal::BoundNodesTreeBuilder        \\\n                     *Builder) const override;                                 \\\n  };                                                                           \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::Matcher<Type> DefineMatcher() {      \\\n    return ::clang::ast_matchers::internal::makeMatcher(                       \\\n        new internal::matcher_##DefineMatcher##Matcher());                     \\\n  }                                                                            \\\n  inline bool internal::matcher_##DefineMatcher##Matcher::matches(             \\\n      const Type &Node,                                                        \\\n      ::clang::ast_matchers::internal::ASTMatchFinder *Finder,                 \\\n      ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const\n\n/// AST_MATCHER_P(Type, DefineMatcher, ParamType, Param) { ... }\n/// defines a single-parameter function named DefineMatcher() that returns a\n/// Matcher<Type> object.\n///\n/// The code between the curly braces has access to the following variables:\n///\n///   Node:                  the AST node being matched; its type is Type.\n///   Param:                 the parameter passed to the function; its type\n///                          is ParamType.\n///   Finder:                an ASTMatchFinder*.\n///   Builder:               a BoundNodesTreeBuilder*.\n///\n/// The code should return true if 'Node' matches.\n#define AST_MATCHER_P(Type, DefineMatcher, ParamType, Param)                   \\\n  AST_MATCHER_P_OVERLOAD(Type, DefineMatcher, ParamType, Param, 0)\n\n#define AST_MATCHER_P_OVERLOAD(Type, DefineMatcher, ParamType, Param,          \\\n                               OverloadId)                                     \\\n  namespace internal {                                                         \\\n  class matcher_##DefineMatcher##OverloadId##Matcher                           \\\n      : public ::clang::ast_matchers::internal::MatcherInterface<Type> {       \\\n  public:                                                                      \\\n    explicit matcher_##DefineMatcher##OverloadId##Matcher(                     \\\n        ParamType const &A##Param)                                             \\\n        : Param(A##Param) {}                                                   \\\n    bool matches(const Type &Node,                                             \\\n                 ::clang::ast_matchers::internal::ASTMatchFinder *Finder,      \\\n                 ::clang::ast_matchers::internal::BoundNodesTreeBuilder        \\\n                     *Builder) const override;                                 \\\n                                                                               \\\n  private:                                                                     \\\n    ParamType const Param;                                                     \\\n  };                                                                           \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::Matcher<Type> DefineMatcher(         \\\n      ParamType const &Param) {                                                \\\n    return ::clang::ast_matchers::internal::makeMatcher(                       \\\n        new internal::matcher_##DefineMatcher##OverloadId##Matcher(Param));    \\\n  }                                                                            \\\n  typedef ::clang::ast_matchers::internal::Matcher<Type>(                      \\\n      &DefineMatcher##_Type##OverloadId)(ParamType const &Param);              \\\n  inline bool internal::matcher_##DefineMatcher##OverloadId##Matcher::matches( \\\n      const Type &Node,                                                        \\\n      ::clang::ast_matchers::internal::ASTMatchFinder *Finder,                 \\\n      ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const\n\n/// AST_MATCHER_P2(\n///     Type, DefineMatcher, ParamType1, Param1, ParamType2, Param2) { ... }\n/// defines a two-parameter function named DefineMatcher() that returns a\n/// Matcher<Type> object.\n///\n/// The code between the curly braces has access to the following variables:\n///\n///   Node:                  the AST node being matched; its type is Type.\n///   Param1, Param2:        the parameters passed to the function; their types\n///                          are ParamType1 and ParamType2.\n///   Finder:                an ASTMatchFinder*.\n///   Builder:               a BoundNodesTreeBuilder*.\n///\n/// The code should return true if 'Node' matches.\n#define AST_MATCHER_P2(Type, DefineMatcher, ParamType1, Param1, ParamType2,    \\\n                       Param2)                                                 \\\n  AST_MATCHER_P2_OVERLOAD(Type, DefineMatcher, ParamType1, Param1, ParamType2, \\\n                          Param2, 0)\n\n#define AST_MATCHER_P2_OVERLOAD(Type, DefineMatcher, ParamType1, Param1,       \\\n                                ParamType2, Param2, OverloadId)                \\\n  namespace internal {                                                         \\\n  class matcher_##DefineMatcher##OverloadId##Matcher                           \\\n      : public ::clang::ast_matchers::internal::MatcherInterface<Type> {       \\\n  public:                                                                      \\\n    matcher_##DefineMatcher##OverloadId##Matcher(ParamType1 const &A##Param1,  \\\n                                                 ParamType2 const &A##Param2)  \\\n        : Param1(A##Param1), Param2(A##Param2) {}                              \\\n    bool matches(const Type &Node,                                             \\\n                 ::clang::ast_matchers::internal::ASTMatchFinder *Finder,      \\\n                 ::clang::ast_matchers::internal::BoundNodesTreeBuilder        \\\n                     *Builder) const override;                                 \\\n                                                                               \\\n  private:                                                                     \\\n    ParamType1 const Param1;                                                   \\\n    ParamType2 const Param2;                                                   \\\n  };                                                                           \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::Matcher<Type> DefineMatcher(         \\\n      ParamType1 const &Param1, ParamType2 const &Param2) {                    \\\n    return ::clang::ast_matchers::internal::makeMatcher(                       \\\n        new internal::matcher_##DefineMatcher##OverloadId##Matcher(Param1,     \\\n                                                                   Param2));   \\\n  }                                                                            \\\n  typedef ::clang::ast_matchers::internal::Matcher<Type>(                      \\\n      &DefineMatcher##_Type##OverloadId)(ParamType1 const &Param1,             \\\n                                         ParamType2 const &Param2);            \\\n  inline bool internal::matcher_##DefineMatcher##OverloadId##Matcher::matches( \\\n      const Type &Node,                                                        \\\n      ::clang::ast_matchers::internal::ASTMatchFinder *Finder,                 \\\n      ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const\n\n/// Construct a type-list to be passed to the AST_POLYMORPHIC_MATCHER*\n///   macros.\n///\n/// You can't pass something like \\c TypeList<Foo, Bar> to a macro, because it\n/// will look at that as two arguments. However, you can pass\n/// \\c void(TypeList<Foo, Bar>), which works thanks to the parenthesis.\n/// The \\c PolymorphicMatcherWithParam* classes will unpack the function type to\n/// extract the TypeList object.\n#define AST_POLYMORPHIC_SUPPORTED_TYPES(...)                                   \\\n  void(::clang::ast_matchers::internal::TypeList<__VA_ARGS__>)\n\n/// AST_POLYMORPHIC_MATCHER(DefineMatcher) { ... }\n/// defines a single-parameter function named DefineMatcher() that is\n/// polymorphic in the return type.\n///\n/// The variables are the same as for AST_MATCHER, but NodeType will be deduced\n/// from the calling context.\n#define AST_POLYMORPHIC_MATCHER(DefineMatcher, ReturnTypesF)                   \\\n  namespace internal {                                                         \\\n  template <typename NodeType>                                                 \\\n  class matcher_##DefineMatcher##Matcher                                       \\\n      : public ::clang::ast_matchers::internal::MatcherInterface<NodeType> {   \\\n  public:                                                                      \\\n    bool matches(const NodeType &Node,                                         \\\n                 ::clang::ast_matchers::internal::ASTMatchFinder *Finder,      \\\n                 ::clang::ast_matchers::internal::BoundNodesTreeBuilder        \\\n                     *Builder) const override;                                 \\\n  };                                                                           \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::PolymorphicMatcher<                  \\\n      internal::matcher_##DefineMatcher##Matcher, ReturnTypesF>                \\\n  DefineMatcher() {                                                            \\\n    return ::clang::ast_matchers::internal::PolymorphicMatcher<                \\\n        internal::matcher_##DefineMatcher##Matcher, ReturnTypesF>();           \\\n  }                                                                            \\\n  template <typename NodeType>                                                 \\\n  bool internal::matcher_##DefineMatcher##Matcher<NodeType>::matches(          \\\n      const NodeType &Node,                                                    \\\n      ::clang::ast_matchers::internal::ASTMatchFinder *Finder,                 \\\n      ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const\n\n/// AST_POLYMORPHIC_MATCHER_P(DefineMatcher, ParamType, Param) { ... }\n/// defines a single-parameter function named DefineMatcher() that is\n/// polymorphic in the return type.\n///\n/// The variables are the same as for\n/// AST_MATCHER_P, with the addition of NodeType, which specifies the node type\n/// of the matcher Matcher<NodeType> returned by the function matcher().\n///\n/// FIXME: Pull out common code with above macro?\n#define AST_POLYMORPHIC_MATCHER_P(DefineMatcher, ReturnTypesF, ParamType,      \\\n                                  Param)                                       \\\n  AST_POLYMORPHIC_MATCHER_P_OVERLOAD(DefineMatcher, ReturnTypesF, ParamType,   \\\n                                     Param, 0)\n\n#define AST_POLYMORPHIC_MATCHER_P_OVERLOAD(DefineMatcher, ReturnTypesF,        \\\n                                           ParamType, Param, OverloadId)       \\\n  namespace internal {                                                         \\\n  template <typename NodeType, typename ParamT>                                \\\n  class matcher_##DefineMatcher##OverloadId##Matcher                           \\\n      : public ::clang::ast_matchers::internal::MatcherInterface<NodeType> {   \\\n  public:                                                                      \\\n    explicit matcher_##DefineMatcher##OverloadId##Matcher(                     \\\n        ParamType const &A##Param)                                             \\\n        : Param(A##Param) {}                                                   \\\n    bool matches(const NodeType &Node,                                         \\\n                 ::clang::ast_matchers::internal::ASTMatchFinder *Finder,      \\\n                 ::clang::ast_matchers::internal::BoundNodesTreeBuilder        \\\n                     *Builder) const override;                                 \\\n                                                                               \\\n  private:                                                                     \\\n    ParamType const Param;                                                     \\\n  };                                                                           \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::PolymorphicMatcher<                  \\\n      internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,    \\\n      ParamType>                                                               \\\n  DefineMatcher(ParamType const &Param) {                                      \\\n    return ::clang::ast_matchers::internal::PolymorphicMatcher<                \\\n        internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,  \\\n        ParamType>(Param);                                                     \\\n  }                                                                            \\\n  typedef ::clang::ast_matchers::internal::PolymorphicMatcher<                 \\\n      internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,    \\\n      ParamType> (&DefineMatcher##_Type##OverloadId)(ParamType const &Param);  \\\n  template <typename NodeType, typename ParamT>                                \\\n  bool internal::                                                              \\\n      matcher_##DefineMatcher##OverloadId##Matcher<NodeType, ParamT>::matches( \\\n          const NodeType &Node,                                                \\\n          ::clang::ast_matchers::internal::ASTMatchFinder *Finder,             \\\n          ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder)     \\\n          const\n\n/// AST_POLYMORPHIC_MATCHER_P2(\n///     DefineMatcher, ParamType1, Param1, ParamType2, Param2) { ... }\n/// defines a two-parameter function named matcher() that is polymorphic in\n/// the return type.\n///\n/// The variables are the same as for AST_MATCHER_P2, with the\n/// addition of NodeType, which specifies the node type of the matcher\n/// Matcher<NodeType> returned by the function DefineMatcher().\n#define AST_POLYMORPHIC_MATCHER_P2(DefineMatcher, ReturnTypesF, ParamType1,    \\\n                                   Param1, ParamType2, Param2)                 \\\n  AST_POLYMORPHIC_MATCHER_P2_OVERLOAD(DefineMatcher, ReturnTypesF, ParamType1, \\\n                                      Param1, ParamType2, Param2, 0)\n\n#define AST_POLYMORPHIC_MATCHER_P2_OVERLOAD(DefineMatcher, ReturnTypesF,       \\\n                                            ParamType1, Param1, ParamType2,    \\\n                                            Param2, OverloadId)                \\\n  namespace internal {                                                         \\\n  template <typename NodeType, typename ParamT1, typename ParamT2>             \\\n  class matcher_##DefineMatcher##OverloadId##Matcher                           \\\n      : public ::clang::ast_matchers::internal::MatcherInterface<NodeType> {   \\\n  public:                                                                      \\\n    matcher_##DefineMatcher##OverloadId##Matcher(ParamType1 const &A##Param1,  \\\n                                                 ParamType2 const &A##Param2)  \\\n        : Param1(A##Param1), Param2(A##Param2) {}                              \\\n    bool matches(const NodeType &Node,                                         \\\n                 ::clang::ast_matchers::internal::ASTMatchFinder *Finder,      \\\n                 ::clang::ast_matchers::internal::BoundNodesTreeBuilder        \\\n                     *Builder) const override;                                 \\\n                                                                               \\\n  private:                                                                     \\\n    ParamType1 const Param1;                                                   \\\n    ParamType2 const Param2;                                                   \\\n  };                                                                           \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::PolymorphicMatcher<                  \\\n      internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,    \\\n      ParamType1, ParamType2>                                                  \\\n  DefineMatcher(ParamType1 const &Param1, ParamType2 const &Param2) {          \\\n    return ::clang::ast_matchers::internal::PolymorphicMatcher<                \\\n        internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,  \\\n        ParamType1, ParamType2>(Param1, Param2);                               \\\n  }                                                                            \\\n  typedef ::clang::ast_matchers::internal::PolymorphicMatcher<                 \\\n      internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,    \\\n      ParamType1, ParamType2> (&DefineMatcher##_Type##OverloadId)(             \\\n      ParamType1 const &Param1, ParamType2 const &Param2);                     \\\n  template <typename NodeType, typename ParamT1, typename ParamT2>             \\\n  bool internal::matcher_##DefineMatcher##OverloadId##Matcher<                 \\\n      NodeType, ParamT1, ParamT2>::                                            \\\n      matches(const NodeType &Node,                                            \\\n              ::clang::ast_matchers::internal::ASTMatchFinder *Finder,         \\\n              ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) \\\n          const\n\n// FIXME: add a matcher for TypeLoc derived classes using its custom casting\n// API (no longer dyn_cast) if/when we need such matching\n\n#define AST_TYPE_TRAVERSE_MATCHER_DECL(MatcherName, FunctionName,              \\\n                                       ReturnTypesF)                           \\\n  namespace internal {                                                         \\\n  template <typename T> struct TypeMatcher##MatcherName##Getter {              \\\n    static QualType (T::*value())() const { return &T::FunctionName; }         \\\n  };                                                                           \\\n  }                                                                            \\\n  extern const ::clang::ast_matchers::internal::                               \\\n      TypeTraversePolymorphicMatcher<                                          \\\n          QualType,                                                            \\\n          ::clang::ast_matchers::internal::TypeMatcher##MatcherName##Getter,   \\\n          ::clang::ast_matchers::internal::TypeTraverseMatcher,                \\\n          ReturnTypesF>::Func MatcherName\n\n#define AST_TYPE_TRAVERSE_MATCHER_DEF(MatcherName, ReturnTypesF)               \\\n  const ::clang::ast_matchers::internal::TypeTraversePolymorphicMatcher<       \\\n      QualType,                                                                \\\n      ::clang::ast_matchers::internal::TypeMatcher##MatcherName##Getter,       \\\n      ::clang::ast_matchers::internal::TypeTraverseMatcher,                    \\\n      ReturnTypesF>::Func MatcherName\n\n/// AST_TYPE_TRAVERSE_MATCHER(MatcherName, FunctionName) defines\n/// the matcher \\c MatcherName that can be used to traverse from one \\c Type\n/// to another.\n///\n/// For a specific \\c SpecificType, the traversal is done using\n/// \\c SpecificType::FunctionName. The existence of such a function determines\n/// whether a corresponding matcher can be used on \\c SpecificType.\n#define AST_TYPE_TRAVERSE_MATCHER(MatcherName, FunctionName, ReturnTypesF)     \\\n  namespace internal {                                                         \\\n  template <typename T> struct TypeMatcher##MatcherName##Getter {              \\\n    static QualType (T::*value())() const { return &T::FunctionName; }         \\\n  };                                                                           \\\n  }                                                                            \\\n  const ::clang::ast_matchers::internal::TypeTraversePolymorphicMatcher<       \\\n      QualType,                                                                \\\n      ::clang::ast_matchers::internal::TypeMatcher##MatcherName##Getter,       \\\n      ::clang::ast_matchers::internal::TypeTraverseMatcher,                    \\\n      ReturnTypesF>::Func MatcherName\n\n#define AST_TYPELOC_TRAVERSE_MATCHER_DECL(MatcherName, FunctionName,           \\\n                                          ReturnTypesF)                        \\\n  namespace internal {                                                         \\\n  template <typename T> struct TypeLocMatcher##MatcherName##Getter {           \\\n    static TypeLoc (T::*value())() const { return &T::FunctionName##Loc; }     \\\n  };                                                                           \\\n  }                                                                            \\\n  extern const ::clang::ast_matchers::internal::                               \\\n      TypeTraversePolymorphicMatcher<                                          \\\n          TypeLoc,                                                             \\\n          ::clang::ast_matchers::internal::                                    \\\n              TypeLocMatcher##MatcherName##Getter,                             \\\n          ::clang::ast_matchers::internal::TypeLocTraverseMatcher,             \\\n          ReturnTypesF>::Func MatcherName##Loc;                                \\\n  AST_TYPE_TRAVERSE_MATCHER_DECL(MatcherName, FunctionName##Type, ReturnTypesF)\n\n#define AST_TYPELOC_TRAVERSE_MATCHER_DEF(MatcherName, ReturnTypesF)            \\\n  const ::clang::ast_matchers::internal::TypeTraversePolymorphicMatcher<       \\\n      TypeLoc,                                                                 \\\n      ::clang::ast_matchers::internal::TypeLocMatcher##MatcherName##Getter,    \\\n      ::clang::ast_matchers::internal::TypeLocTraverseMatcher,                 \\\n      ReturnTypesF>::Func MatcherName##Loc;                                    \\\n  AST_TYPE_TRAVERSE_MATCHER_DEF(MatcherName, ReturnTypesF)\n\n/// AST_TYPELOC_TRAVERSE_MATCHER(MatcherName, FunctionName) works\n/// identical to \\c AST_TYPE_TRAVERSE_MATCHER but operates on \\c TypeLocs.\n#define AST_TYPELOC_TRAVERSE_MATCHER(MatcherName, FunctionName, ReturnTypesF)  \\\n  namespace internal {                                                         \\\n  template <typename T> struct TypeLocMatcher##MatcherName##Getter {           \\\n    static TypeLoc (T::*value())() const { return &T::FunctionName##Loc; }     \\\n  };                                                                           \\\n  }                                                                            \\\n  const ::clang::ast_matchers::internal::TypeTraversePolymorphicMatcher<       \\\n      TypeLoc,                                                                 \\\n      ::clang::ast_matchers::internal::TypeLocMatcher##MatcherName##Getter,    \\\n      ::clang::ast_matchers::internal::TypeLocTraverseMatcher,                 \\\n      ReturnTypesF>::Func MatcherName##Loc;                                    \\\n  AST_TYPE_TRAVERSE_MATCHER(MatcherName, FunctionName##Type, ReturnTypesF)\n\n/// AST_MATCHER_REGEX(Type, DefineMatcher, Param) { ... }\n/// defines a function named DefineMatcher() that takes a regular expression\n/// string paramater and an optional RegexFlags parameter and returns a\n/// Matcher<Type> object.\n///\n/// The code between the curly braces has access to the following variables:\n///\n///   Node:                  the AST node being matched; its type is Type.\n///   Param:                 a pointer to an \\ref llvm::Regex object\n///   Finder:                an ASTMatchFinder*.\n///   Builder:               a BoundNodesTreeBuilder*.\n///\n/// The code should return true if 'Node' matches.\n#define AST_MATCHER_REGEX(Type, DefineMatcher, Param)                          \\\n  AST_MATCHER_REGEX_OVERLOAD(Type, DefineMatcher, Param, 0)\n\n#define AST_MATCHER_REGEX_OVERLOAD(Type, DefineMatcher, Param, OverloadId)     \\\n  namespace internal {                                                         \\\n  class matcher_##DefineMatcher##OverloadId##Matcher                           \\\n      : public ::clang::ast_matchers::internal::MatcherInterface<Type> {       \\\n  public:                                                                      \\\n    explicit matcher_##DefineMatcher##OverloadId##Matcher(                     \\\n        std::shared_ptr<llvm::Regex> RE)                                       \\\n        : Param(std::move(RE)) {}                                              \\\n    bool matches(const Type &Node,                                             \\\n                 ::clang::ast_matchers::internal::ASTMatchFinder *Finder,      \\\n                 ::clang::ast_matchers::internal::BoundNodesTreeBuilder        \\\n                     *Builder) const override;                                 \\\n                                                                               \\\n  private:                                                                     \\\n    std::shared_ptr<llvm::Regex> const Param;                                  \\\n  };                                                                           \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::Matcher<Type> DefineMatcher(         \\\n      llvm::StringRef Param, llvm::Regex::RegexFlags RegexFlags) {             \\\n    return ::clang::ast_matchers::internal::makeMatcher(                       \\\n        new internal::matcher_##DefineMatcher##OverloadId##Matcher(            \\\n            ::clang::ast_matchers::internal::createAndVerifyRegex(             \\\n                Param, RegexFlags, #DefineMatcher)));                          \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::Matcher<Type> DefineMatcher(         \\\n      llvm::StringRef Param) {                                                 \\\n    return DefineMatcher(Param, llvm::Regex::NoFlags);                         \\\n  }                                                                            \\\n                                                                               \\\n  typedef ::clang::ast_matchers::internal::Matcher<Type> (                     \\\n      &DefineMatcher##_Type##OverloadId##Flags)(llvm::StringRef,               \\\n                                                llvm::Regex::RegexFlags);      \\\n  typedef ::clang::ast_matchers::internal::Matcher<Type> (                     \\\n      &DefineMatcher##_Type##OverloadId)(llvm::StringRef);                     \\\n  inline bool internal::matcher_##DefineMatcher##OverloadId##Matcher::matches( \\\n      const Type &Node,                                                        \\\n      ::clang::ast_matchers::internal::ASTMatchFinder *Finder,                 \\\n      ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const\n\n/// AST_POLYMORPHIC_MATCHER_REGEX(DefineMatcher, ReturnTypesF, Param) { ... }\n/// defines a function named DefineMatcher() that takes a regular expression\n/// string paramater and an optional RegexFlags parameter that is polymorphic in\n/// the return type.\n///\n/// The variables are the same as for\n/// AST_MATCHER_REGEX, with the addition of NodeType, which specifies the node\n/// type of the matcher Matcher<NodeType> returned by the function matcher().\n#define AST_POLYMORPHIC_MATCHER_REGEX(DefineMatcher, ReturnTypesF, Param)      \\\n  AST_POLYMORPHIC_MATCHER_REGEX_OVERLOAD(DefineMatcher, ReturnTypesF, Param, 0)\n\n#define AST_POLYMORPHIC_MATCHER_REGEX_OVERLOAD(DefineMatcher, ReturnTypesF,    \\\n                                               Param, OverloadId)              \\\n  namespace internal {                                                         \\\n  template <typename NodeType, typename ParamT>                                \\\n  class matcher_##DefineMatcher##OverloadId##Matcher                           \\\n      : public ::clang::ast_matchers::internal::MatcherInterface<NodeType> {   \\\n  public:                                                                      \\\n    explicit matcher_##DefineMatcher##OverloadId##Matcher(                     \\\n        std::shared_ptr<llvm::Regex> RE)                                       \\\n        : Param(std::move(RE)) {}                                              \\\n    bool matches(const NodeType &Node,                                         \\\n                 ::clang::ast_matchers::internal::ASTMatchFinder *Finder,      \\\n                 ::clang::ast_matchers::internal::BoundNodesTreeBuilder        \\\n                     *Builder) const override;                                 \\\n                                                                               \\\n  private:                                                                     \\\n    std::shared_ptr<llvm::Regex> const Param;                                  \\\n  };                                                                           \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::PolymorphicMatcher<                  \\\n      internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,    \\\n      std::shared_ptr<llvm::Regex>>                                            \\\n  DefineMatcher(llvm::StringRef Param, llvm::Regex::RegexFlags RegexFlags) {   \\\n    return ::clang::ast_matchers::internal::PolymorphicMatcher<                \\\n        internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,  \\\n        std::shared_ptr<llvm::Regex>>(                                         \\\n        ::clang::ast_matchers::internal::createAndVerifyRegex(                 \\\n            Param, RegexFlags, #DefineMatcher));                               \\\n  }                                                                            \\\n  inline ::clang::ast_matchers::internal::PolymorphicMatcher<                  \\\n      internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,    \\\n      std::shared_ptr<llvm::Regex>>                                            \\\n  DefineMatcher(llvm::StringRef Param) {                                       \\\n    return DefineMatcher(Param, llvm::Regex::NoFlags);                         \\\n  }                                                                            \\\n  typedef ::clang::ast_matchers::internal::PolymorphicMatcher<                 \\\n      internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,    \\\n      std::shared_ptr<llvm::Regex>> (                                          \\\n      &DefineMatcher##_Type##OverloadId##Flags)(                               \\\n      llvm::StringRef Param, llvm::Regex::RegexFlags RegexFlags);              \\\n  typedef ::clang::ast_matchers::internal::PolymorphicMatcher<                 \\\n      internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF,    \\\n      std::shared_ptr<llvm::Regex>> (&DefineMatcher##_Type##OverloadId)(       \\\n      llvm::StringRef Param);                                                  \\\n  template <typename NodeType, typename ParamT>                                \\\n  bool internal::                                                              \\\n      matcher_##DefineMatcher##OverloadId##Matcher<NodeType, ParamT>::matches( \\\n          const NodeType &Node,                                                \\\n          ::clang::ast_matchers::internal::ASTMatchFinder *Finder,             \\\n          ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder)     \\\n          const\n\n#endif // LLVM_CLANG_ASTMATCHERS_ASTMATCHERSMACROS_H\n"}}, "reports": [{"events": [{"location": {"col": 11, "file": 3, "line": 175}, "message": "'ImportPathTy' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTImporter.h", "reportHash": "730135538f484987b35587f258fd9b10", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 4, "line": 47}, "message": "'ASTImporterLookupTable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTImporterLookupTable.h", "reportHash": "ac43c9843fbaa706477f97ea14e95719", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 34}, "message": "'ImportExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "64291a1b5221c1ce6a1d49237dfe9ac4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 35}, "message": "'ImportType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "4c5d88c3e14ea579544051a398eaf48e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 36}, "message": "'ImportDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "67717eada141537a9a5bc21de8515ad4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 37}, "message": "'ImportFixedPointExpr' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "5719d117b6a4ca6593fd6ebc389bfcb9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 39}, "message": "'CanonicalRedeclChain' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "6fc4d1c7b30da7c78cf992a5987ee459", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 81}, "message": "'RedirectingImporter' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "2cd2fc08fc64d9c588a523197756e7af", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 102}, "message": "'RedirectingImporterTest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "0ef56d3d368a56f4b2b8363087890b38", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 149}, "message": "'ImportPath' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "db11740b365533512a1abe4d02221ddb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 37, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 36, "line": 647}, "message": "'matcher_hasInitMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "cea1934cbc1f1bdd5ef2e65038fbd485", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 37, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 36, "line": 648}, "message": "'matcher_isRightFoldMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "f97353a36e0b76bde40ebd35766d9444", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 37, "line": 96}, "message": "expanded from macro 'AST_MATCHER'"}, {"location": {"col": 1, "file": 36, "line": 649}, "message": "'matcher_isLeftFoldMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "da1194842c0bc903e6190a82332f9ee7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 1885}, "message": "'ImportFunctions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "6b84f9c2cba702dca9edd2936999d390", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 2299}, "message": "'ImportFunctionTemplates' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "bff91e9dcf0d86e2899a90d28267be11", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 2398}, "message": "'ImportFriendFunctions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "982cbb3a182de4f7a41cd1040faf7f63", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 36, "line": 2863}, "message": "'ImportImplicitMethods' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "b1a41f34d94acbed7d73b9ef991acf87", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 3481}, "message": "'ImportVariables' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "9c241d65cbfb4b4910b1d7cbc3ca32d5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 3570}, "message": "'ImportClasses' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "94737633ccf1053f231d30bd828410b5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 3632}, "message": "'ImportFriendClasses' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "61957775a5dcfe4375439cedcb68e417", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 3982}, "message": "'DeclContextTest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "4a9d177267856f832511728795f28d0b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 4045}, "message": "'ImportFunctionTemplateSpecializations' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "0cdbfd6be3ed106fa3e154b4fe4442aa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 4273}, "message": "'ASTImporterLookupTableTest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "2b56cf4fb98fbc94e27a0e6484a69b20", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 4823}, "message": "'ImportFriendFunctionTemplates' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "6d591190bc1f52dad680b2c9efd4e8d0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 4848}, "message": "'ASTImporterWithFakeErrors' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "a7f74b57987b933005cbff68e7ed3390", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 4853}, "message": "'ErrorHandlingTest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "5f6c8a50b9650eeaf3f5ae2cb2fabfda", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 5345}, "message": "'LLDBLookupTest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "2620260d91d3dfbf0386d0761562427f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 36, "line": 5374}, "message": "'TestExternalASTSource' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "2403ea8c16517df1201a689edb54bc62", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 5390}, "message": "'SVEBuiltins' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "ace7b913339cb85dc13f5d5e61b18d50", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 5618}, "message": "'ImportAutoFunctions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "c3413f9d36587a208d24ecba207cf9cd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 5800}, "message": "'ImportSourceLocations' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "bea892197725117df03a1e8c484f8195", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 5969}, "message": "'ImportWithExternalSource' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "3c8f774380fb375c3a01421f7295df30", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 5984}, "message": "'SourceWithCompletedTagList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "eeaea5a73b3f80f85d2c49123431866a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 6092}, "message": "'CTAD' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/AST/ASTImporterTest.cpp", "reportHash": "61fe8fb8075129d0e314b23a383a253b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
