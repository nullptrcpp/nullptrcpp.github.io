<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/clang/include/clang-c/Index.h", "content": "/*===-- clang-c/Index.h - Indexing Public C Interface -------------*- C -*-===*\\\n|*                                                                            *|\n|* Part of the LLVM Project, under the Apache License v2.0 with LLVM          *|\n|* Exceptions.                                                                *|\n|* See https://llvm.org/LICENSE.txt for license information.                  *|\n|* SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception                    *|\n|*                                                                            *|\n|*===----------------------------------------------------------------------===*|\n|*                                                                            *|\n|* This header provides a public interface to a Clang library for extracting  *|\n|* high-level symbol information from source files without exposing the full  *|\n|* Clang C++ API.                                                             *|\n|*                                                                            *|\n\\*===----------------------------------------------------------------------===*/\n\n#ifndef LLVM_CLANG_C_INDEX_H\n#define LLVM_CLANG_C_INDEX_H\n\n#include <time.h>\n\n#include \"clang-c/BuildSystem.h\"\n#include \"clang-c/CXErrorCode.h\"\n#include \"clang-c/CXString.h\"\n#include \"clang-c/ExternC.h\"\n#include \"clang-c/Platform.h\"\n\n/**\n * The version constants for the libclang API.\n * CINDEX_VERSION_MINOR should increase when there are API additions.\n * CINDEX_VERSION_MAJOR is intended for \"major\" source/ABI breaking changes.\n *\n * The policy about the libclang API was always to keep it source and ABI\n * compatible, thus CINDEX_VERSION_MAJOR is expected to remain stable.\n */\n#define CINDEX_VERSION_MAJOR 0\n#define CINDEX_VERSION_MINOR 61\n\n#define CINDEX_VERSION_ENCODE(major, minor) (((major)*10000) + ((minor)*1))\n\n#define CINDEX_VERSION                                                         \\\n  CINDEX_VERSION_ENCODE(CINDEX_VERSION_MAJOR, CINDEX_VERSION_MINOR)\n\n#define CINDEX_VERSION_STRINGIZE_(major, minor) #major \".\" #minor\n#define CINDEX_VERSION_STRINGIZE(major, minor)                                 \\\n  CINDEX_VERSION_STRINGIZE_(major, minor)\n\n#define CINDEX_VERSION_STRING                                                  \\\n  CINDEX_VERSION_STRINGIZE(CINDEX_VERSION_MAJOR, CINDEX_VERSION_MINOR)\n\nLLVM_CLANG_C_EXTERN_C_BEGIN\n\n/** \\defgroup CINDEX libclang: C Interface to Clang\n *\n * The C Interface to Clang provides a relatively small API that exposes\n * facilities for parsing source code into an abstract syntax tree (AST),\n * loading already-parsed ASTs, traversing the AST, associating\n * physical source locations with elements within the AST, and other\n * facilities that support Clang-based development tools.\n *\n * This C interface to Clang will never provide all of the information\n * representation stored in Clang's C++ AST, nor should it: the intent is to\n * maintain an API that is relatively stable from one release to the next,\n * providing only the basic functionality needed to support development tools.\n *\n * To avoid namespace pollution, data types are prefixed with \"CX\" and\n * functions are prefixed with \"clang_\".\n *\n * @{\n */\n\n/**\n * An \"index\" that consists of a set of translation units that would\n * typically be linked together into an executable or library.\n */\ntypedef void *CXIndex;\n\n/**\n * An opaque type representing target information for a given translation\n * unit.\n */\ntypedef struct CXTargetInfoImpl *CXTargetInfo;\n\n/**\n * A single translation unit, which resides in an index.\n */\ntypedef struct CXTranslationUnitImpl *CXTranslationUnit;\n\n/**\n * Opaque pointer representing client data that will be passed through\n * to various callbacks and visitors.\n */\ntypedef void *CXClientData;\n\n/**\n * Provides the contents of a file that has not yet been saved to disk.\n *\n * Each CXUnsavedFile instance provides the name of a file on the\n * system along with the current contents of that file that have not\n * yet been saved to disk.\n */\nstruct CXUnsavedFile {\n  /**\n   * The file whose contents have not yet been saved.\n   *\n   * This file must already exist in the file system.\n   */\n  const char *Filename;\n\n  /**\n   * A buffer containing the unsaved contents of this file.\n   */\n  const char *Contents;\n\n  /**\n   * The length of the unsaved contents of this buffer.\n   */\n  unsigned long Length;\n};\n\n/**\n * Describes the availability of a particular entity, which indicates\n * whether the use of this entity will result in a warning or error due to\n * it being deprecated or unavailable.\n */\nenum CXAvailabilityKind {\n  /**\n   * The entity is available.\n   */\n  CXAvailability_Available,\n  /**\n   * The entity is available, but has been deprecated (and its use is\n   * not recommended).\n   */\n  CXAvailability_Deprecated,\n  /**\n   * The entity is not available; any use of it will be an error.\n   */\n  CXAvailability_NotAvailable,\n  /**\n   * The entity is available, but not accessible; any use of it will be\n   * an error.\n   */\n  CXAvailability_NotAccessible\n};\n\n/**\n * Describes a version number of the form major.minor.subminor.\n */\ntypedef struct CXVersion {\n  /**\n   * The major version number, e.g., the '10' in '10.7.3'. A negative\n   * value indicates that there is no version number at all.\n   */\n  int Major;\n  /**\n   * The minor version number, e.g., the '7' in '10.7.3'. This value\n   * will be negative if no minor version number was provided, e.g., for\n   * version '10'.\n   */\n  int Minor;\n  /**\n   * The subminor version number, e.g., the '3' in '10.7.3'. This value\n   * will be negative if no minor or subminor version number was provided,\n   * e.g., in version '10' or '10.7'.\n   */\n  int Subminor;\n} CXVersion;\n\n/**\n * Describes the exception specification of a cursor.\n *\n * A negative value indicates that the cursor is not a function declaration.\n */\nenum CXCursor_ExceptionSpecificationKind {\n  /**\n   * The cursor has no exception specification.\n   */\n  CXCursor_ExceptionSpecificationKind_None,\n\n  /**\n   * The cursor has exception specification throw()\n   */\n  CXCursor_ExceptionSpecificationKind_DynamicNone,\n\n  /**\n   * The cursor has exception specification throw(T1, T2)\n   */\n  CXCursor_ExceptionSpecificationKind_Dynamic,\n\n  /**\n   * The cursor has exception specification throw(...).\n   */\n  CXCursor_ExceptionSpecificationKind_MSAny,\n\n  /**\n   * The cursor has exception specification basic noexcept.\n   */\n  CXCursor_ExceptionSpecificationKind_BasicNoexcept,\n\n  /**\n   * The cursor has exception specification computed noexcept.\n   */\n  CXCursor_ExceptionSpecificationKind_ComputedNoexcept,\n\n  /**\n   * The exception specification has not yet been evaluated.\n   */\n  CXCursor_ExceptionSpecificationKind_Unevaluated,\n\n  /**\n   * The exception specification has not yet been instantiated.\n   */\n  CXCursor_ExceptionSpecificationKind_Uninstantiated,\n\n  /**\n   * The exception specification has not been parsed yet.\n   */\n  CXCursor_ExceptionSpecificationKind_Unparsed,\n\n  /**\n   * The cursor has a __declspec(nothrow) exception specification.\n   */\n  CXCursor_ExceptionSpecificationKind_NoThrow\n};\n\n/**\n * Provides a shared context for creating translation units.\n *\n * It provides two options:\n *\n * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of \"local\"\n * declarations (when loading any new translation units). A \"local\" declaration\n * is one that belongs in the translation unit itself and not in a precompiled\n * header that was used by the translation unit. If zero, all declarations\n * will be enumerated.\n *\n * Here is an example:\n *\n * \\code\n *   // excludeDeclsFromPCH = 1, displayDiagnostics=1\n *   Idx = clang_createIndex(1, 1);\n *\n *   // IndexTest.pch was produced with the following command:\n *   // \"clang -x c IndexTest.h -emit-ast -o IndexTest.pch\"\n *   TU = clang_createTranslationUnit(Idx, \"IndexTest.pch\");\n *\n *   // This will load all the symbols from 'IndexTest.pch'\n *   clang_visitChildren(clang_getTranslationUnitCursor(TU),\n *                       TranslationUnitVisitor, 0);\n *   clang_disposeTranslationUnit(TU);\n *\n *   // This will load all the symbols from 'IndexTest.c', excluding symbols\n *   // from 'IndexTest.pch'.\n *   char *args[] = { \"-Xclang\", \"-include-pch=IndexTest.pch\" };\n *   TU = clang_createTranslationUnitFromSourceFile(Idx, \"IndexTest.c\", 2, args,\n *                                                  0, 0);\n *   clang_visitChildren(clang_getTranslationUnitCursor(TU),\n *                       TranslationUnitVisitor, 0);\n *   clang_disposeTranslationUnit(TU);\n * \\endcode\n *\n * This process of creating the 'pch', loading it separately, and using it (via\n * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks\n * (which gives the indexer the same performance benefit as the compiler).\n */\nCINDEX_LINKAGE CXIndex clang_createIndex(int excludeDeclarationsFromPCH,\n                                         int displayDiagnostics);\n\n/**\n * Destroy the given index.\n *\n * The index must not be destroyed until all of the translation units created\n * within that index have been destroyed.\n */\nCINDEX_LINKAGE void clang_disposeIndex(CXIndex index);\n\ntypedef enum {\n  /**\n   * Used to indicate that no special CXIndex options are needed.\n   */\n  CXGlobalOpt_None = 0x0,\n\n  /**\n   * Used to indicate that threads that libclang creates for indexing\n   * purposes should use background priority.\n   *\n   * Affects #clang_indexSourceFile, #clang_indexTranslationUnit,\n   * #clang_parseTranslationUnit, #clang_saveTranslationUnit.\n   */\n  CXGlobalOpt_ThreadBackgroundPriorityForIndexing = 0x1,\n\n  /**\n   * Used to indicate that threads that libclang creates for editing\n   * purposes should use background priority.\n   *\n   * Affects #clang_reparseTranslationUnit, #clang_codeCompleteAt,\n   * #clang_annotateTokens\n   */\n  CXGlobalOpt_ThreadBackgroundPriorityForEditing = 0x2,\n\n  /**\n   * Used to indicate that all threads that libclang creates should use\n   * background priority.\n   */\n  CXGlobalOpt_ThreadBackgroundPriorityForAll =\n      CXGlobalOpt_ThreadBackgroundPriorityForIndexing |\n      CXGlobalOpt_ThreadBackgroundPriorityForEditing\n\n} CXGlobalOptFlags;\n\n/**\n * Sets general options associated with a CXIndex.\n *\n * For example:\n * \\code\n * CXIndex idx = ...;\n * clang_CXIndex_setGlobalOptions(idx,\n *     clang_CXIndex_getGlobalOptions(idx) |\n *     CXGlobalOpt_ThreadBackgroundPriorityForIndexing);\n * \\endcode\n *\n * \\param options A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags.\n */\nCINDEX_LINKAGE void clang_CXIndex_setGlobalOptions(CXIndex, unsigned options);\n\n/**\n * Gets the general options associated with a CXIndex.\n *\n * \\returns A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags that\n * are associated with the given CXIndex object.\n */\nCINDEX_LINKAGE unsigned clang_CXIndex_getGlobalOptions(CXIndex);\n\n/**\n * Sets the invocation emission path option in a CXIndex.\n *\n * The invocation emission path specifies a path which will contain log\n * files for certain libclang invocations. A null value (default) implies that\n * libclang invocations are not logged..\n */\nCINDEX_LINKAGE void\nclang_CXIndex_setInvocationEmissionPathOption(CXIndex, const char *Path);\n\n/**\n * \\defgroup CINDEX_FILES File manipulation routines\n *\n * @{\n */\n\n/**\n * A particular source file that is part of a translation unit.\n */\ntypedef void *CXFile;\n\n/**\n * Retrieve the complete file and path name of the given file.\n */\nCINDEX_LINKAGE CXString clang_getFileName(CXFile SFile);\n\n/**\n * Retrieve the last modification time of the given file.\n */\nCINDEX_LINKAGE time_t clang_getFileTime(CXFile SFile);\n\n/**\n * Uniquely identifies a CXFile, that refers to the same underlying file,\n * across an indexing session.\n */\ntypedef struct {\n  unsigned long long data[3];\n} CXFileUniqueID;\n\n/**\n * Retrieve the unique ID for the given \\c file.\n *\n * \\param file the file to get the ID for.\n * \\param outID stores the returned CXFileUniqueID.\n * \\returns If there was a failure getting the unique ID, returns non-zero,\n * otherwise returns 0.\n */\nCINDEX_LINKAGE int clang_getFileUniqueID(CXFile file, CXFileUniqueID *outID);\n\n/**\n * Determine whether the given header is guarded against\n * multiple inclusions, either with the conventional\n * \\#ifndef/\\#define/\\#endif macro guards or with \\#pragma once.\n */\nCINDEX_LINKAGE unsigned clang_isFileMultipleIncludeGuarded(CXTranslationUnit tu,\n                                                           CXFile file);\n\n/**\n * Retrieve a file handle within the given translation unit.\n *\n * \\param tu the translation unit\n *\n * \\param file_name the name of the file.\n *\n * \\returns the file handle for the named file in the translation unit \\p tu,\n * or a NULL file handle if the file was not a part of this translation unit.\n */\nCINDEX_LINKAGE CXFile clang_getFile(CXTranslationUnit tu,\n                                    const char *file_name);\n\n/**\n * Retrieve the buffer associated with the given file.\n *\n * \\param tu the translation unit\n *\n * \\param file the file for which to retrieve the buffer.\n *\n * \\param size [out] if non-NULL, will be set to the size of the buffer.\n *\n * \\returns a pointer to the buffer in memory that holds the contents of\n * \\p file, or a NULL pointer when the file is not loaded.\n */\nCINDEX_LINKAGE const char *clang_getFileContents(CXTranslationUnit tu,\n                                                 CXFile file, size_t *size);\n\n/**\n * Returns non-zero if the \\c file1 and \\c file2 point to the same file,\n * or they are both NULL.\n */\nCINDEX_LINKAGE int clang_File_isEqual(CXFile file1, CXFile file2);\n\n/**\n * Returns the real path name of \\c file.\n *\n * An empty string may be returned. Use \\c clang_getFileName() in that case.\n */\nCINDEX_LINKAGE CXString clang_File_tryGetRealPathName(CXFile file);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_LOCATIONS Physical source locations\n *\n * Clang represents physical source locations in its abstract syntax tree in\n * great detail, with file, line, and column information for the majority of\n * the tokens parsed in the source code. These data types and functions are\n * used to represent source location information, either for a particular\n * point in the program or for a range of points in the program, and extract\n * specific location information from those data types.\n *\n * @{\n */\n\n/**\n * Identifies a specific source location within a translation\n * unit.\n *\n * Use clang_getExpansionLocation() or clang_getSpellingLocation()\n * to map a source location to a particular file, line, and column.\n */\ntypedef struct {\n  const void *ptr_data[2];\n  unsigned int_data;\n} CXSourceLocation;\n\n/**\n * Identifies a half-open character range in the source code.\n *\n * Use clang_getRangeStart() and clang_getRangeEnd() to retrieve the\n * starting and end locations from a source range, respectively.\n */\ntypedef struct {\n  const void *ptr_data[2];\n  unsigned begin_int_data;\n  unsigned end_int_data;\n} CXSourceRange;\n\n/**\n * Retrieve a NULL (invalid) source location.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getNullLocation(void);\n\n/**\n * Determine whether two source locations, which must refer into\n * the same translation unit, refer to exactly the same point in the source\n * code.\n *\n * \\returns non-zero if the source locations refer to the same location, zero\n * if they refer to different locations.\n */\nCINDEX_LINKAGE unsigned clang_equalLocations(CXSourceLocation loc1,\n                                             CXSourceLocation loc2);\n\n/**\n * Retrieves the source location associated with a given file/line/column\n * in a particular translation unit.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getLocation(CXTranslationUnit tu,\n                                                  CXFile file, unsigned line,\n                                                  unsigned column);\n/**\n * Retrieves the source location associated with a given character offset\n * in a particular translation unit.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getLocationForOffset(CXTranslationUnit tu,\n                                                           CXFile file,\n                                                           unsigned offset);\n\n/**\n * Returns non-zero if the given source location is in a system header.\n */\nCINDEX_LINKAGE int clang_Location_isInSystemHeader(CXSourceLocation location);\n\n/**\n * Returns non-zero if the given source location is in the main file of\n * the corresponding translation unit.\n */\nCINDEX_LINKAGE int clang_Location_isFromMainFile(CXSourceLocation location);\n\n/**\n * Retrieve a NULL (invalid) source range.\n */\nCINDEX_LINKAGE CXSourceRange clang_getNullRange(void);\n\n/**\n * Retrieve a source range given the beginning and ending source\n * locations.\n */\nCINDEX_LINKAGE CXSourceRange clang_getRange(CXSourceLocation begin,\n                                            CXSourceLocation end);\n\n/**\n * Determine whether two ranges are equivalent.\n *\n * \\returns non-zero if the ranges are the same, zero if they differ.\n */\nCINDEX_LINKAGE unsigned clang_equalRanges(CXSourceRange range1,\n                                          CXSourceRange range2);\n\n/**\n * Returns non-zero if \\p range is null.\n */\nCINDEX_LINKAGE int clang_Range_isNull(CXSourceRange range);\n\n/**\n * Retrieve the file, line, column, and offset represented by\n * the given source location.\n *\n * If the location refers into a macro expansion, retrieves the\n * location of the macro expansion.\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param file [out] if non-NULL, will be set to the file to which the given\n * source location points.\n *\n * \\param line [out] if non-NULL, will be set to the line to which the given\n * source location points.\n *\n * \\param column [out] if non-NULL, will be set to the column to which the given\n * source location points.\n *\n * \\param offset [out] if non-NULL, will be set to the offset into the\n * buffer to which the given source location points.\n */\nCINDEX_LINKAGE void clang_getExpansionLocation(CXSourceLocation location,\n                                               CXFile *file, unsigned *line,\n                                               unsigned *column,\n                                               unsigned *offset);\n\n/**\n * Retrieve the file, line and column represented by the given source\n * location, as specified in a # line directive.\n *\n * Example: given the following source code in a file somefile.c\n *\n * \\code\n * #123 \"dummy.c\" 1\n *\n * static int func(void)\n * {\n *     return 0;\n * }\n * \\endcode\n *\n * the location information returned by this function would be\n *\n * File: dummy.c Line: 124 Column: 12\n *\n * whereas clang_getExpansionLocation would have returned\n *\n * File: somefile.c Line: 3 Column: 12\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param filename [out] if non-NULL, will be set to the filename of the\n * source location. Note that filenames returned will be for \"virtual\" files,\n * which don't necessarily exist on the machine running clang - e.g. when\n * parsing preprocessed output obtained from a different environment. If\n * a non-NULL value is passed in, remember to dispose of the returned value\n * using \\c clang_disposeString() once you've finished with it. For an invalid\n * source location, an empty string is returned.\n *\n * \\param line [out] if non-NULL, will be set to the line number of the\n * source location. For an invalid source location, zero is returned.\n *\n * \\param column [out] if non-NULL, will be set to the column number of the\n * source location. For an invalid source location, zero is returned.\n */\nCINDEX_LINKAGE void clang_getPresumedLocation(CXSourceLocation location,\n                                              CXString *filename,\n                                              unsigned *line, unsigned *column);\n\n/**\n * Legacy API to retrieve the file, line, column, and offset represented\n * by the given source location.\n *\n * This interface has been replaced by the newer interface\n * #clang_getExpansionLocation(). See that interface's documentation for\n * details.\n */\nCINDEX_LINKAGE void clang_getInstantiationLocation(CXSourceLocation location,\n                                                   CXFile *file, unsigned *line,\n                                                   unsigned *column,\n                                                   unsigned *offset);\n\n/**\n * Retrieve the file, line, column, and offset represented by\n * the given source location.\n *\n * If the location refers into a macro instantiation, return where the\n * location was originally spelled in the source file.\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param file [out] if non-NULL, will be set to the file to which the given\n * source location points.\n *\n * \\param line [out] if non-NULL, will be set to the line to which the given\n * source location points.\n *\n * \\param column [out] if non-NULL, will be set to the column to which the given\n * source location points.\n *\n * \\param offset [out] if non-NULL, will be set to the offset into the\n * buffer to which the given source location points.\n */\nCINDEX_LINKAGE void clang_getSpellingLocation(CXSourceLocation location,\n                                              CXFile *file, unsigned *line,\n                                              unsigned *column,\n                                              unsigned *offset);\n\n/**\n * Retrieve the file, line, column, and offset represented by\n * the given source location.\n *\n * If the location refers into a macro expansion, return where the macro was\n * expanded or where the macro argument was written, if the location points at\n * a macro argument.\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param file [out] if non-NULL, will be set to the file to which the given\n * source location points.\n *\n * \\param line [out] if non-NULL, will be set to the line to which the given\n * source location points.\n *\n * \\param column [out] if non-NULL, will be set to the column to which the given\n * source location points.\n *\n * \\param offset [out] if non-NULL, will be set to the offset into the\n * buffer to which the given source location points.\n */\nCINDEX_LINKAGE void clang_getFileLocation(CXSourceLocation location,\n                                          CXFile *file, unsigned *line,\n                                          unsigned *column, unsigned *offset);\n\n/**\n * Retrieve a source location representing the first character within a\n * source range.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getRangeStart(CXSourceRange range);\n\n/**\n * Retrieve a source location representing the last character within a\n * source range.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getRangeEnd(CXSourceRange range);\n\n/**\n * Identifies an array of ranges.\n */\ntypedef struct {\n  /** The number of ranges in the \\c ranges array. */\n  unsigned count;\n  /**\n   * An array of \\c CXSourceRanges.\n   */\n  CXSourceRange *ranges;\n} CXSourceRangeList;\n\n/**\n * Retrieve all ranges that were skipped by the preprocessor.\n *\n * The preprocessor will skip lines when they are surrounded by an\n * if/ifdef/ifndef directive whose condition does not evaluate to true.\n */\nCINDEX_LINKAGE CXSourceRangeList *clang_getSkippedRanges(CXTranslationUnit tu,\n                                                         CXFile file);\n\n/**\n * Retrieve all ranges from all files that were skipped by the\n * preprocessor.\n *\n * The preprocessor will skip lines when they are surrounded by an\n * if/ifdef/ifndef directive whose condition does not evaluate to true.\n */\nCINDEX_LINKAGE CXSourceRangeList *\nclang_getAllSkippedRanges(CXTranslationUnit tu);\n\n/**\n * Destroy the given \\c CXSourceRangeList.\n */\nCINDEX_LINKAGE void clang_disposeSourceRangeList(CXSourceRangeList *ranges);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_DIAG Diagnostic reporting\n *\n * @{\n */\n\n/**\n * Describes the severity of a particular diagnostic.\n */\nenum CXDiagnosticSeverity {\n  /**\n   * A diagnostic that has been suppressed, e.g., by a command-line\n   * option.\n   */\n  CXDiagnostic_Ignored = 0,\n\n  /**\n   * This diagnostic is a note that should be attached to the\n   * previous (non-note) diagnostic.\n   */\n  CXDiagnostic_Note = 1,\n\n  /**\n   * This diagnostic indicates suspicious code that may not be\n   * wrong.\n   */\n  CXDiagnostic_Warning = 2,\n\n  /**\n   * This diagnostic indicates that the code is ill-formed.\n   */\n  CXDiagnostic_Error = 3,\n\n  /**\n   * This diagnostic indicates that the code is ill-formed such\n   * that future parser recovery is unlikely to produce useful\n   * results.\n   */\n  CXDiagnostic_Fatal = 4\n};\n\n/**\n * A single diagnostic, containing the diagnostic's severity,\n * location, text, source ranges, and fix-it hints.\n */\ntypedef void *CXDiagnostic;\n\n/**\n * A group of CXDiagnostics.\n */\ntypedef void *CXDiagnosticSet;\n\n/**\n * Determine the number of diagnostics in a CXDiagnosticSet.\n */\nCINDEX_LINKAGE unsigned clang_getNumDiagnosticsInSet(CXDiagnosticSet Diags);\n\n/**\n * Retrieve a diagnostic associated with the given CXDiagnosticSet.\n *\n * \\param Diags the CXDiagnosticSet to query.\n * \\param Index the zero-based diagnostic number to retrieve.\n *\n * \\returns the requested diagnostic. This diagnostic must be freed\n * via a call to \\c clang_disposeDiagnostic().\n */\nCINDEX_LINKAGE CXDiagnostic clang_getDiagnosticInSet(CXDiagnosticSet Diags,\n                                                     unsigned Index);\n\n/**\n * Describes the kind of error that occurred (if any) in a call to\n * \\c clang_loadDiagnostics.\n */\nenum CXLoadDiag_Error {\n  /**\n   * Indicates that no error occurred.\n   */\n  CXLoadDiag_None = 0,\n\n  /**\n   * Indicates that an unknown error occurred while attempting to\n   * deserialize diagnostics.\n   */\n  CXLoadDiag_Unknown = 1,\n\n  /**\n   * Indicates that the file containing the serialized diagnostics\n   * could not be opened.\n   */\n  CXLoadDiag_CannotLoad = 2,\n\n  /**\n   * Indicates that the serialized diagnostics file is invalid or\n   * corrupt.\n   */\n  CXLoadDiag_InvalidFile = 3\n};\n\n/**\n * Deserialize a set of diagnostics from a Clang diagnostics bitcode\n * file.\n *\n * \\param file The name of the file to deserialize.\n * \\param error A pointer to a enum value recording if there was a problem\n *        deserializing the diagnostics.\n * \\param errorString A pointer to a CXString for recording the error string\n *        if the file was not successfully loaded.\n *\n * \\returns A loaded CXDiagnosticSet if successful, and NULL otherwise.  These\n * diagnostics should be released using clang_disposeDiagnosticSet().\n */\nCINDEX_LINKAGE CXDiagnosticSet clang_loadDiagnostics(\n    const char *file, enum CXLoadDiag_Error *error, CXString *errorString);\n\n/**\n * Release a CXDiagnosticSet and all of its contained diagnostics.\n */\nCINDEX_LINKAGE void clang_disposeDiagnosticSet(CXDiagnosticSet Diags);\n\n/**\n * Retrieve the child diagnostics of a CXDiagnostic.\n *\n * This CXDiagnosticSet does not need to be released by\n * clang_disposeDiagnosticSet.\n */\nCINDEX_LINKAGE CXDiagnosticSet clang_getChildDiagnostics(CXDiagnostic D);\n\n/**\n * Determine the number of diagnostics produced for the given\n * translation unit.\n */\nCINDEX_LINKAGE unsigned clang_getNumDiagnostics(CXTranslationUnit Unit);\n\n/**\n * Retrieve a diagnostic associated with the given translation unit.\n *\n * \\param Unit the translation unit to query.\n * \\param Index the zero-based diagnostic number to retrieve.\n *\n * \\returns the requested diagnostic. This diagnostic must be freed\n * via a call to \\c clang_disposeDiagnostic().\n */\nCINDEX_LINKAGE CXDiagnostic clang_getDiagnostic(CXTranslationUnit Unit,\n                                                unsigned Index);\n\n/**\n * Retrieve the complete set of diagnostics associated with a\n *        translation unit.\n *\n * \\param Unit the translation unit to query.\n */\nCINDEX_LINKAGE CXDiagnosticSet\nclang_getDiagnosticSetFromTU(CXTranslationUnit Unit);\n\n/**\n * Destroy a diagnostic.\n */\nCINDEX_LINKAGE void clang_disposeDiagnostic(CXDiagnostic Diagnostic);\n\n/**\n * Options to control the display of diagnostics.\n *\n * The values in this enum are meant to be combined to customize the\n * behavior of \\c clang_formatDiagnostic().\n */\nenum CXDiagnosticDisplayOptions {\n  /**\n   * Display the source-location information where the\n   * diagnostic was located.\n   *\n   * When set, diagnostics will be prefixed by the file, line, and\n   * (optionally) column to which the diagnostic refers. For example,\n   *\n   * \\code\n   * test.c:28: warning: extra tokens at end of #endif directive\n   * \\endcode\n   *\n   * This option corresponds to the clang flag \\c -fshow-source-location.\n   */\n  CXDiagnostic_DisplaySourceLocation = 0x01,\n\n  /**\n   * If displaying the source-location information of the\n   * diagnostic, also include the column number.\n   *\n   * This option corresponds to the clang flag \\c -fshow-column.\n   */\n  CXDiagnostic_DisplayColumn = 0x02,\n\n  /**\n   * If displaying the source-location information of the\n   * diagnostic, also include information about source ranges in a\n   * machine-parsable format.\n   *\n   * This option corresponds to the clang flag\n   * \\c -fdiagnostics-print-source-range-info.\n   */\n  CXDiagnostic_DisplaySourceRanges = 0x04,\n\n  /**\n   * Display the option name associated with this diagnostic, if any.\n   *\n   * The option name displayed (e.g., -Wconversion) will be placed in brackets\n   * after the diagnostic text. This option corresponds to the clang flag\n   * \\c -fdiagnostics-show-option.\n   */\n  CXDiagnostic_DisplayOption = 0x08,\n\n  /**\n   * Display the category number associated with this diagnostic, if any.\n   *\n   * The category number is displayed within brackets after the diagnostic text.\n   * This option corresponds to the clang flag\n   * \\c -fdiagnostics-show-category=id.\n   */\n  CXDiagnostic_DisplayCategoryId = 0x10,\n\n  /**\n   * Display the category name associated with this diagnostic, if any.\n   *\n   * The category name is displayed within brackets after the diagnostic text.\n   * This option corresponds to the clang flag\n   * \\c -fdiagnostics-show-category=name.\n   */\n  CXDiagnostic_DisplayCategoryName = 0x20\n};\n\n/**\n * Format the given diagnostic in a manner that is suitable for display.\n *\n * This routine will format the given diagnostic to a string, rendering\n * the diagnostic according to the various options given. The\n * \\c clang_defaultDiagnosticDisplayOptions() function returns the set of\n * options that most closely mimics the behavior of the clang compiler.\n *\n * \\param Diagnostic The diagnostic to print.\n *\n * \\param Options A set of options that control the diagnostic display,\n * created by combining \\c CXDiagnosticDisplayOptions values.\n *\n * \\returns A new string containing for formatted diagnostic.\n */\nCINDEX_LINKAGE CXString clang_formatDiagnostic(CXDiagnostic Diagnostic,\n                                               unsigned Options);\n\n/**\n * Retrieve the set of display options most similar to the\n * default behavior of the clang compiler.\n *\n * \\returns A set of display options suitable for use with \\c\n * clang_formatDiagnostic().\n */\nCINDEX_LINKAGE unsigned clang_defaultDiagnosticDisplayOptions(void);\n\n/**\n * Determine the severity of the given diagnostic.\n */\nCINDEX_LINKAGE enum CXDiagnosticSeverity\n    clang_getDiagnosticSeverity(CXDiagnostic);\n\n/**\n * Retrieve the source location of the given diagnostic.\n *\n * This location is where Clang would print the caret ('^') when\n * displaying the diagnostic on the command line.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getDiagnosticLocation(CXDiagnostic);\n\n/**\n * Retrieve the text of the given diagnostic.\n */\nCINDEX_LINKAGE CXString clang_getDiagnosticSpelling(CXDiagnostic);\n\n/**\n * Retrieve the name of the command-line option that enabled this\n * diagnostic.\n *\n * \\param Diag The diagnostic to be queried.\n *\n * \\param Disable If non-NULL, will be set to the option that disables this\n * diagnostic (if any).\n *\n * \\returns A string that contains the command-line option used to enable this\n * warning, such as \"-Wconversion\" or \"-pedantic\".\n */\nCINDEX_LINKAGE CXString clang_getDiagnosticOption(CXDiagnostic Diag,\n                                                  CXString *Disable);\n\n/**\n * Retrieve the category number for this diagnostic.\n *\n * Diagnostics can be categorized into groups along with other, related\n * diagnostics (e.g., diagnostics under the same warning flag). This routine\n * retrieves the category number for the given diagnostic.\n *\n * \\returns The number of the category that contains this diagnostic, or zero\n * if this diagnostic is uncategorized.\n */\nCINDEX_LINKAGE unsigned clang_getDiagnosticCategory(CXDiagnostic);\n\n/**\n * Retrieve the name of a particular diagnostic category.  This\n *  is now deprecated.  Use clang_getDiagnosticCategoryText()\n *  instead.\n *\n * \\param Category A diagnostic category number, as returned by\n * \\c clang_getDiagnosticCategory().\n *\n * \\returns The name of the given diagnostic category.\n */\nCINDEX_DEPRECATED CINDEX_LINKAGE CXString\nclang_getDiagnosticCategoryName(unsigned Category);\n\n/**\n * Retrieve the diagnostic category text for a given diagnostic.\n *\n * \\returns The text of the given diagnostic category.\n */\nCINDEX_LINKAGE CXString clang_getDiagnosticCategoryText(CXDiagnostic);\n\n/**\n * Determine the number of source ranges associated with the given\n * diagnostic.\n */\nCINDEX_LINKAGE unsigned clang_getDiagnosticNumRanges(CXDiagnostic);\n\n/**\n * Retrieve a source range associated with the diagnostic.\n *\n * A diagnostic's source ranges highlight important elements in the source\n * code. On the command line, Clang displays source ranges by\n * underlining them with '~' characters.\n *\n * \\param Diagnostic the diagnostic whose range is being extracted.\n *\n * \\param Range the zero-based index specifying which range to\n *\n * \\returns the requested source range.\n */\nCINDEX_LINKAGE CXSourceRange clang_getDiagnosticRange(CXDiagnostic Diagnostic,\n                                                      unsigned Range);\n\n/**\n * Determine the number of fix-it hints associated with the\n * given diagnostic.\n */\nCINDEX_LINKAGE unsigned clang_getDiagnosticNumFixIts(CXDiagnostic Diagnostic);\n\n/**\n * Retrieve the replacement information for a given fix-it.\n *\n * Fix-its are described in terms of a source range whose contents\n * should be replaced by a string. This approach generalizes over\n * three kinds of operations: removal of source code (the range covers\n * the code to be removed and the replacement string is empty),\n * replacement of source code (the range covers the code to be\n * replaced and the replacement string provides the new code), and\n * insertion (both the start and end of the range point at the\n * insertion location, and the replacement string provides the text to\n * insert).\n *\n * \\param Diagnostic The diagnostic whose fix-its are being queried.\n *\n * \\param FixIt The zero-based index of the fix-it.\n *\n * \\param ReplacementRange The source range whose contents will be\n * replaced with the returned replacement string. Note that source\n * ranges are half-open ranges [a, b), so the source code should be\n * replaced from a and up to (but not including) b.\n *\n * \\returns A string containing text that should be replace the source\n * code indicated by the \\c ReplacementRange.\n */\nCINDEX_LINKAGE CXString clang_getDiagnosticFixIt(\n    CXDiagnostic Diagnostic, unsigned FixIt, CXSourceRange *ReplacementRange);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_TRANSLATION_UNIT Translation unit manipulation\n *\n * The routines in this group provide the ability to create and destroy\n * translation units from files, either by parsing the contents of the files or\n * by reading in a serialized representation of a translation unit.\n *\n * @{\n */\n\n/**\n * Get the original translation unit source file name.\n */\nCINDEX_LINKAGE CXString\nclang_getTranslationUnitSpelling(CXTranslationUnit CTUnit);\n\n/**\n * Return the CXTranslationUnit for a given source file and the provided\n * command line arguments one would pass to the compiler.\n *\n * Note: The 'source_filename' argument is optional.  If the caller provides a\n * NULL pointer, the name of the source file is expected to reside in the\n * specified command line arguments.\n *\n * Note: When encountered in 'clang_command_line_args', the following options\n * are ignored:\n *\n *   '-c'\n *   '-emit-ast'\n *   '-fsyntax-only'\n *   '-o \\<output file>'  (both '-o' and '\\<output file>' are ignored)\n *\n * \\param CIdx The index object with which the translation unit will be\n * associated.\n *\n * \\param source_filename The name of the source file to load, or NULL if the\n * source file is included in \\p clang_command_line_args.\n *\n * \\param num_clang_command_line_args The number of command-line arguments in\n * \\p clang_command_line_args.\n *\n * \\param clang_command_line_args The command-line arguments that would be\n * passed to the \\c clang executable if it were being invoked out-of-process.\n * These command-line options will be parsed and will affect how the translation\n * unit is parsed. Note that the following options are ignored: '-c',\n * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \\<output file>'.\n *\n * \\param num_unsaved_files the number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param unsaved_files the files that have not yet been saved to disk\n * but may be required for code completion, including the contents of\n * those files.  The contents and name of these files (as specified by\n * CXUnsavedFile) are copied when necessary, so the client only needs to\n * guarantee their validity until the call to this function returns.\n */\nCINDEX_LINKAGE CXTranslationUnit clang_createTranslationUnitFromSourceFile(\n    CXIndex CIdx, const char *source_filename, int num_clang_command_line_args,\n    const char *const *clang_command_line_args, unsigned num_unsaved_files,\n    struct CXUnsavedFile *unsaved_files);\n\n/**\n * Same as \\c clang_createTranslationUnit2, but returns\n * the \\c CXTranslationUnit instead of an error code.  In case of an error this\n * routine returns a \\c NULL \\c CXTranslationUnit, without further detailed\n * error codes.\n */\nCINDEX_LINKAGE CXTranslationUnit\nclang_createTranslationUnit(CXIndex CIdx, const char *ast_filename);\n\n/**\n * Create a translation unit from an AST file (\\c -emit-ast).\n *\n * \\param[out] out_TU A non-NULL pointer to store the created\n * \\c CXTranslationUnit.\n *\n * \\returns Zero on success, otherwise returns an error code.\n */\nCINDEX_LINKAGE enum CXErrorCode\nclang_createTranslationUnit2(CXIndex CIdx, const char *ast_filename,\n                             CXTranslationUnit *out_TU);\n\n/**\n * Flags that control the creation of translation units.\n *\n * The enumerators in this enumeration type are meant to be bitwise\n * ORed together to specify which options should be used when\n * constructing the translation unit.\n */\nenum CXTranslationUnit_Flags {\n  /**\n   * Used to indicate that no special translation-unit options are\n   * needed.\n   */\n  CXTranslationUnit_None = 0x0,\n\n  /**\n   * Used to indicate that the parser should construct a \"detailed\"\n   * preprocessing record, including all macro definitions and instantiations.\n   *\n   * Constructing a detailed preprocessing record requires more memory\n   * and time to parse, since the information contained in the record\n   * is usually not retained. However, it can be useful for\n   * applications that require more detailed information about the\n   * behavior of the preprocessor.\n   */\n  CXTranslationUnit_DetailedPreprocessingRecord = 0x01,\n\n  /**\n   * Used to indicate that the translation unit is incomplete.\n   *\n   * When a translation unit is considered \"incomplete\", semantic\n   * analysis that is typically performed at the end of the\n   * translation unit will be suppressed. For example, this suppresses\n   * the completion of tentative declarations in C and of\n   * instantiation of implicitly-instantiation function templates in\n   * C++. This option is typically used when parsing a header with the\n   * intent of producing a precompiled header.\n   */\n  CXTranslationUnit_Incomplete = 0x02,\n\n  /**\n   * Used to indicate that the translation unit should be built with an\n   * implicit precompiled header for the preamble.\n   *\n   * An implicit precompiled header is used as an optimization when a\n   * particular translation unit is likely to be reparsed many times\n   * when the sources aren't changing that often. In this case, an\n   * implicit precompiled header will be built containing all of the\n   * initial includes at the top of the main file (what we refer to as\n   * the \"preamble\" of the file). In subsequent parses, if the\n   * preamble or the files in it have not changed, \\c\n   * clang_reparseTranslationUnit() will re-use the implicit\n   * precompiled header to improve parsing performance.\n   */\n  CXTranslationUnit_PrecompiledPreamble = 0x04,\n\n  /**\n   * Used to indicate that the translation unit should cache some\n   * code-completion results with each reparse of the source file.\n   *\n   * Caching of code-completion results is a performance optimization that\n   * introduces some overhead to reparsing but improves the performance of\n   * code-completion operations.\n   */\n  CXTranslationUnit_CacheCompletionResults = 0x08,\n\n  /**\n   * Used to indicate that the translation unit will be serialized with\n   * \\c clang_saveTranslationUnit.\n   *\n   * This option is typically used when parsing a header with the intent of\n   * producing a precompiled header.\n   */\n  CXTranslationUnit_ForSerialization = 0x10,\n\n  /**\n   * DEPRECATED: Enabled chained precompiled preambles in C++.\n   *\n   * Note: this is a *temporary* option that is available only while\n   * we are testing C++ precompiled preamble support. It is deprecated.\n   */\n  CXTranslationUnit_CXXChainedPCH = 0x20,\n\n  /**\n   * Used to indicate that function/method bodies should be skipped while\n   * parsing.\n   *\n   * This option can be used to search for declarations/definitions while\n   * ignoring the usages.\n   */\n  CXTranslationUnit_SkipFunctionBodies = 0x40,\n\n  /**\n   * Used to indicate that brief documentation comments should be\n   * included into the set of code completions returned from this translation\n   * unit.\n   */\n  CXTranslationUnit_IncludeBriefCommentsInCodeCompletion = 0x80,\n\n  /**\n   * Used to indicate that the precompiled preamble should be created on\n   * the first parse. Otherwise it will be created on the first reparse. This\n   * trades runtime on the first parse (serializing the preamble takes time) for\n   * reduced runtime on the second parse (can now reuse the preamble).\n   */\n  CXTranslationUnit_CreatePreambleOnFirstParse = 0x100,\n\n  /**\n   * Do not stop processing when fatal errors are encountered.\n   *\n   * When fatal errors are encountered while parsing a translation unit,\n   * semantic analysis is typically stopped early when compiling code. A common\n   * source for fatal errors are unresolvable include files. For the\n   * purposes of an IDE, this is undesirable behavior and as much information\n   * as possible should be reported. Use this flag to enable this behavior.\n   */\n  CXTranslationUnit_KeepGoing = 0x200,\n\n  /**\n   * Sets the preprocessor in a mode for parsing a single file only.\n   */\n  CXTranslationUnit_SingleFileParse = 0x400,\n\n  /**\n   * Used in combination with CXTranslationUnit_SkipFunctionBodies to\n   * constrain the skipping of function bodies to the preamble.\n   *\n   * The function bodies of the main file are not skipped.\n   */\n  CXTranslationUnit_LimitSkipFunctionBodiesToPreamble = 0x800,\n\n  /**\n   * Used to indicate that attributed types should be included in CXType.\n   */\n  CXTranslationUnit_IncludeAttributedTypes = 0x1000,\n\n  /**\n   * Used to indicate that implicit attributes should be visited.\n   */\n  CXTranslationUnit_VisitImplicitAttributes = 0x2000,\n\n  /**\n   * Used to indicate that non-errors from included files should be ignored.\n   *\n   * If set, clang_getDiagnosticSetFromTU() will not report e.g. warnings from\n   * included files anymore. This speeds up clang_getDiagnosticSetFromTU() for\n   * the case where these warnings are not of interest, as for an IDE for\n   * example, which typically shows only the diagnostics in the main file.\n   */\n  CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles = 0x4000,\n\n  /**\n   * Tells the preprocessor not to skip excluded conditional blocks.\n   */\n  CXTranslationUnit_RetainExcludedConditionalBlocks = 0x8000\n};\n\n/**\n * Returns the set of flags that is suitable for parsing a translation\n * unit that is being edited.\n *\n * The set of flags returned provide options for \\c clang_parseTranslationUnit()\n * to indicate that the translation unit is likely to be reparsed many times,\n * either explicitly (via \\c clang_reparseTranslationUnit()) or implicitly\n * (e.g., by code completion (\\c clang_codeCompletionAt())). The returned flag\n * set contains an unspecified set of optimizations (e.g., the precompiled\n * preamble) geared toward improving the performance of these routines. The\n * set of optimizations enabled may change from one version to the next.\n */\nCINDEX_LINKAGE unsigned clang_defaultEditingTranslationUnitOptions(void);\n\n/**\n * Same as \\c clang_parseTranslationUnit2, but returns\n * the \\c CXTranslationUnit instead of an error code.  In case of an error this\n * routine returns a \\c NULL \\c CXTranslationUnit, without further detailed\n * error codes.\n */\nCINDEX_LINKAGE CXTranslationUnit clang_parseTranslationUnit(\n    CXIndex CIdx, const char *source_filename,\n    const char *const *command_line_args, int num_command_line_args,\n    struct CXUnsavedFile *unsaved_files, unsigned num_unsaved_files,\n    unsigned options);\n\n/**\n * Parse the given source file and the translation unit corresponding\n * to that file.\n *\n * This routine is the main entry point for the Clang C API, providing the\n * ability to parse a source file into a translation unit that can then be\n * queried by other functions in the API. This routine accepts a set of\n * command-line arguments so that the compilation can be configured in the same\n * way that the compiler is configured on the command line.\n *\n * \\param CIdx The index object with which the translation unit will be\n * associated.\n *\n * \\param source_filename The name of the source file to load, or NULL if the\n * source file is included in \\c command_line_args.\n *\n * \\param command_line_args The command-line arguments that would be\n * passed to the \\c clang executable if it were being invoked out-of-process.\n * These command-line options will be parsed and will affect how the translation\n * unit is parsed. Note that the following options are ignored: '-c',\n * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \\<output file>'.\n *\n * \\param num_command_line_args The number of command-line arguments in\n * \\c command_line_args.\n *\n * \\param unsaved_files the files that have not yet been saved to disk\n * but may be required for parsing, including the contents of\n * those files.  The contents and name of these files (as specified by\n * CXUnsavedFile) are copied when necessary, so the client only needs to\n * guarantee their validity until the call to this function returns.\n *\n * \\param num_unsaved_files the number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param options A bitmask of options that affects how the translation unit\n * is managed but not its compilation. This should be a bitwise OR of the\n * CXTranslationUnit_XXX flags.\n *\n * \\param[out] out_TU A non-NULL pointer to store the created\n * \\c CXTranslationUnit, describing the parsed code and containing any\n * diagnostics produced by the compiler.\n *\n * \\returns Zero on success, otherwise returns an error code.\n */\nCINDEX_LINKAGE enum CXErrorCode clang_parseTranslationUnit2(\n    CXIndex CIdx, const char *source_filename,\n    const char *const *command_line_args, int num_command_line_args,\n    struct CXUnsavedFile *unsaved_files, unsigned num_unsaved_files,\n    unsigned options, CXTranslationUnit *out_TU);\n\n/**\n * Same as clang_parseTranslationUnit2 but requires a full command line\n * for \\c command_line_args including argv[0]. This is useful if the standard\n * library paths are relative to the binary.\n */\nCINDEX_LINKAGE enum CXErrorCode clang_parseTranslationUnit2FullArgv(\n    CXIndex CIdx, const char *source_filename,\n    const char *const *command_line_args, int num_command_line_args,\n    struct CXUnsavedFile *unsaved_files, unsigned num_unsaved_files,\n    unsigned options, CXTranslationUnit *out_TU);\n\n/**\n * Flags that control how translation units are saved.\n *\n * The enumerators in this enumeration type are meant to be bitwise\n * ORed together to specify which options should be used when\n * saving the translation unit.\n */\nenum CXSaveTranslationUnit_Flags {\n  /**\n   * Used to indicate that no special saving options are needed.\n   */\n  CXSaveTranslationUnit_None = 0x0\n};\n\n/**\n * Returns the set of flags that is suitable for saving a translation\n * unit.\n *\n * The set of flags returned provide options for\n * \\c clang_saveTranslationUnit() by default. The returned flag\n * set contains an unspecified set of options that save translation units with\n * the most commonly-requested data.\n */\nCINDEX_LINKAGE unsigned clang_defaultSaveOptions(CXTranslationUnit TU);\n\n/**\n * Describes the kind of error that occurred (if any) in a call to\n * \\c clang_saveTranslationUnit().\n */\nenum CXSaveError {\n  /**\n   * Indicates that no error occurred while saving a translation unit.\n   */\n  CXSaveError_None = 0,\n\n  /**\n   * Indicates that an unknown error occurred while attempting to save\n   * the file.\n   *\n   * This error typically indicates that file I/O failed when attempting to\n   * write the file.\n   */\n  CXSaveError_Unknown = 1,\n\n  /**\n   * Indicates that errors during translation prevented this attempt\n   * to save the translation unit.\n   *\n   * Errors that prevent the translation unit from being saved can be\n   * extracted using \\c clang_getNumDiagnostics() and \\c clang_getDiagnostic().\n   */\n  CXSaveError_TranslationErrors = 2,\n\n  /**\n   * Indicates that the translation unit to be saved was somehow\n   * invalid (e.g., NULL).\n   */\n  CXSaveError_InvalidTU = 3\n};\n\n/**\n * Saves a translation unit into a serialized representation of\n * that translation unit on disk.\n *\n * Any translation unit that was parsed without error can be saved\n * into a file. The translation unit can then be deserialized into a\n * new \\c CXTranslationUnit with \\c clang_createTranslationUnit() or,\n * if it is an incomplete translation unit that corresponds to a\n * header, used as a precompiled header when parsing other translation\n * units.\n *\n * \\param TU The translation unit to save.\n *\n * \\param FileName The file to which the translation unit will be saved.\n *\n * \\param options A bitmask of options that affects how the translation unit\n * is saved. This should be a bitwise OR of the\n * CXSaveTranslationUnit_XXX flags.\n *\n * \\returns A value that will match one of the enumerators of the CXSaveError\n * enumeration. Zero (CXSaveError_None) indicates that the translation unit was\n * saved successfully, while a non-zero value indicates that a problem occurred.\n */\nCINDEX_LINKAGE int clang_saveTranslationUnit(CXTranslationUnit TU,\n                                             const char *FileName,\n                                             unsigned options);\n\n/**\n * Suspend a translation unit in order to free memory associated with it.\n *\n * A suspended translation unit uses significantly less memory but on the other\n * side does not support any other calls than \\c clang_reparseTranslationUnit\n * to resume it or \\c clang_disposeTranslationUnit to dispose it completely.\n */\nCINDEX_LINKAGE unsigned clang_suspendTranslationUnit(CXTranslationUnit);\n\n/**\n * Destroy the specified CXTranslationUnit object.\n */\nCINDEX_LINKAGE void clang_disposeTranslationUnit(CXTranslationUnit);\n\n/**\n * Flags that control the reparsing of translation units.\n *\n * The enumerators in this enumeration type are meant to be bitwise\n * ORed together to specify which options should be used when\n * reparsing the translation unit.\n */\nenum CXReparse_Flags {\n  /**\n   * Used to indicate that no special reparsing options are needed.\n   */\n  CXReparse_None = 0x0\n};\n\n/**\n * Returns the set of flags that is suitable for reparsing a translation\n * unit.\n *\n * The set of flags returned provide options for\n * \\c clang_reparseTranslationUnit() by default. The returned flag\n * set contains an unspecified set of optimizations geared toward common uses\n * of reparsing. The set of optimizations enabled may change from one version\n * to the next.\n */\nCINDEX_LINKAGE unsigned clang_defaultReparseOptions(CXTranslationUnit TU);\n\n/**\n * Reparse the source files that produced this translation unit.\n *\n * This routine can be used to re-parse the source files that originally\n * created the given translation unit, for example because those source files\n * have changed (either on disk or as passed via \\p unsaved_files). The\n * source code will be reparsed with the same command-line options as it\n * was originally parsed.\n *\n * Reparsing a translation unit invalidates all cursors and source locations\n * that refer into that translation unit. This makes reparsing a translation\n * unit semantically equivalent to destroying the translation unit and then\n * creating a new translation unit with the same command-line arguments.\n * However, it may be more efficient to reparse a translation\n * unit using this routine.\n *\n * \\param TU The translation unit whose contents will be re-parsed. The\n * translation unit must originally have been built with\n * \\c clang_createTranslationUnitFromSourceFile().\n *\n * \\param num_unsaved_files The number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param unsaved_files The files that have not yet been saved to disk\n * but may be required for parsing, including the contents of\n * those files.  The contents and name of these files (as specified by\n * CXUnsavedFile) are copied when necessary, so the client only needs to\n * guarantee their validity until the call to this function returns.\n *\n * \\param options A bitset of options composed of the flags in CXReparse_Flags.\n * The function \\c clang_defaultReparseOptions() produces a default set of\n * options recommended for most uses, based on the translation unit.\n *\n * \\returns 0 if the sources could be reparsed.  A non-zero error code will be\n * returned if reparsing was impossible, such that the translation unit is\n * invalid. In such cases, the only valid call for \\c TU is\n * \\c clang_disposeTranslationUnit(TU).  The error codes returned by this\n * routine are described by the \\c CXErrorCode enum.\n */\nCINDEX_LINKAGE int\nclang_reparseTranslationUnit(CXTranslationUnit TU, unsigned num_unsaved_files,\n                             struct CXUnsavedFile *unsaved_files,\n                             unsigned options);\n\n/**\n * Categorizes how memory is being used by a translation unit.\n */\nenum CXTUResourceUsageKind {\n  CXTUResourceUsage_AST = 1,\n  CXTUResourceUsage_Identifiers = 2,\n  CXTUResourceUsage_Selectors = 3,\n  CXTUResourceUsage_GlobalCompletionResults = 4,\n  CXTUResourceUsage_SourceManagerContentCache = 5,\n  CXTUResourceUsage_AST_SideTables = 6,\n  CXTUResourceUsage_SourceManager_Membuffer_Malloc = 7,\n  CXTUResourceUsage_SourceManager_Membuffer_MMap = 8,\n  CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc = 9,\n  CXTUResourceUsage_ExternalASTSource_Membuffer_MMap = 10,\n  CXTUResourceUsage_Preprocessor = 11,\n  CXTUResourceUsage_PreprocessingRecord = 12,\n  CXTUResourceUsage_SourceManager_DataStructures = 13,\n  CXTUResourceUsage_Preprocessor_HeaderSearch = 14,\n  CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN = CXTUResourceUsage_AST,\n  CXTUResourceUsage_MEMORY_IN_BYTES_END =\n      CXTUResourceUsage_Preprocessor_HeaderSearch,\n\n  CXTUResourceUsage_First = CXTUResourceUsage_AST,\n  CXTUResourceUsage_Last = CXTUResourceUsage_Preprocessor_HeaderSearch\n};\n\n/**\n * Returns the human-readable null-terminated C string that represents\n *  the name of the memory category.  This string should never be freed.\n */\nCINDEX_LINKAGE\nconst char *clang_getTUResourceUsageName(enum CXTUResourceUsageKind kind);\n\ntypedef struct CXTUResourceUsageEntry {\n  /* The memory usage category. */\n  enum CXTUResourceUsageKind kind;\n  /* Amount of resources used.\n      The units will depend on the resource kind. */\n  unsigned long amount;\n} CXTUResourceUsageEntry;\n\n/**\n * The memory usage of a CXTranslationUnit, broken into categories.\n */\ntypedef struct CXTUResourceUsage {\n  /* Private data member, used for queries. */\n  void *data;\n\n  /* The number of entries in the 'entries' array. */\n  unsigned numEntries;\n\n  /* An array of key-value pairs, representing the breakdown of memory\n            usage. */\n  CXTUResourceUsageEntry *entries;\n\n} CXTUResourceUsage;\n\n/**\n * Return the memory usage of a translation unit.  This object\n *  should be released with clang_disposeCXTUResourceUsage().\n */\nCINDEX_LINKAGE CXTUResourceUsage\nclang_getCXTUResourceUsage(CXTranslationUnit TU);\n\nCINDEX_LINKAGE void clang_disposeCXTUResourceUsage(CXTUResourceUsage usage);\n\n/**\n * Get target information for this translation unit.\n *\n * The CXTargetInfo object cannot outlive the CXTranslationUnit object.\n */\nCINDEX_LINKAGE CXTargetInfo\nclang_getTranslationUnitTargetInfo(CXTranslationUnit CTUnit);\n\n/**\n * Destroy the CXTargetInfo object.\n */\nCINDEX_LINKAGE void clang_TargetInfo_dispose(CXTargetInfo Info);\n\n/**\n * Get the normalized target triple as a string.\n *\n * Returns the empty string in case of any error.\n */\nCINDEX_LINKAGE CXString clang_TargetInfo_getTriple(CXTargetInfo Info);\n\n/**\n * Get the pointer width of the target in bits.\n *\n * Returns -1 in case of error.\n */\nCINDEX_LINKAGE int clang_TargetInfo_getPointerWidth(CXTargetInfo Info);\n\n/**\n * @}\n */\n\n/**\n * Describes the kind of entity that a cursor refers to.\n */\nenum CXCursorKind {\n  /* Declarations */\n  /**\n   * A declaration whose specific kind is not exposed via this\n   * interface.\n   *\n   * Unexposed declarations have the same operations as any other kind\n   * of declaration; one can extract their location information,\n   * spelling, find their definitions, etc. However, the specific kind\n   * of the declaration is not reported.\n   */\n  CXCursor_UnexposedDecl = 1,\n  /** A C or C++ struct. */\n  CXCursor_StructDecl = 2,\n  /** A C or C++ union. */\n  CXCursor_UnionDecl = 3,\n  /** A C++ class. */\n  CXCursor_ClassDecl = 4,\n  /** An enumeration. */\n  CXCursor_EnumDecl = 5,\n  /**\n   * A field (in C) or non-static data member (in C++) in a\n   * struct, union, or C++ class.\n   */\n  CXCursor_FieldDecl = 6,\n  /** An enumerator constant. */\n  CXCursor_EnumConstantDecl = 7,\n  /** A function. */\n  CXCursor_FunctionDecl = 8,\n  /** A variable. */\n  CXCursor_VarDecl = 9,\n  /** A function or method parameter. */\n  CXCursor_ParmDecl = 10,\n  /** An Objective-C \\@interface. */\n  CXCursor_ObjCInterfaceDecl = 11,\n  /** An Objective-C \\@interface for a category. */\n  CXCursor_ObjCCategoryDecl = 12,\n  /** An Objective-C \\@protocol declaration. */\n  CXCursor_ObjCProtocolDecl = 13,\n  /** An Objective-C \\@property declaration. */\n  CXCursor_ObjCPropertyDecl = 14,\n  /** An Objective-C instance variable. */\n  CXCursor_ObjCIvarDecl = 15,\n  /** An Objective-C instance method. */\n  CXCursor_ObjCInstanceMethodDecl = 16,\n  /** An Objective-C class method. */\n  CXCursor_ObjCClassMethodDecl = 17,\n  /** An Objective-C \\@implementation. */\n  CXCursor_ObjCImplementationDecl = 18,\n  /** An Objective-C \\@implementation for a category. */\n  CXCursor_ObjCCategoryImplDecl = 19,\n  /** A typedef. */\n  CXCursor_TypedefDecl = 20,\n  /** A C++ class method. */\n  CXCursor_CXXMethod = 21,\n  /** A C++ namespace. */\n  CXCursor_Namespace = 22,\n  /** A linkage specification, e.g. 'extern \"C\"'. */\n  CXCursor_LinkageSpec = 23,\n  /** A C++ constructor. */\n  CXCursor_Constructor = 24,\n  /** A C++ destructor. */\n  CXCursor_Destructor = 25,\n  /** A C++ conversion function. */\n  CXCursor_ConversionFunction = 26,\n  /** A C++ template type parameter. */\n  CXCursor_TemplateTypeParameter = 27,\n  /** A C++ non-type template parameter. */\n  CXCursor_NonTypeTemplateParameter = 28,\n  /** A C++ template template parameter. */\n  CXCursor_TemplateTemplateParameter = 29,\n  /** A C++ function template. */\n  CXCursor_FunctionTemplate = 30,\n  /** A C++ class template. */\n  CXCursor_ClassTemplate = 31,\n  /** A C++ class template partial specialization. */\n  CXCursor_ClassTemplatePartialSpecialization = 32,\n  /** A C++ namespace alias declaration. */\n  CXCursor_NamespaceAlias = 33,\n  /** A C++ using directive. */\n  CXCursor_UsingDirective = 34,\n  /** A C++ using declaration. */\n  CXCursor_UsingDeclaration = 35,\n  /** A C++ alias declaration */\n  CXCursor_TypeAliasDecl = 36,\n  /** An Objective-C \\@synthesize definition. */\n  CXCursor_ObjCSynthesizeDecl = 37,\n  /** An Objective-C \\@dynamic definition. */\n  CXCursor_ObjCDynamicDecl = 38,\n  /** An access specifier. */\n  CXCursor_CXXAccessSpecifier = 39,\n\n  CXCursor_FirstDecl = CXCursor_UnexposedDecl,\n  CXCursor_LastDecl = CXCursor_CXXAccessSpecifier,\n\n  /* References */\n  CXCursor_FirstRef = 40, /* Decl references */\n  CXCursor_ObjCSuperClassRef = 40,\n  CXCursor_ObjCProtocolRef = 41,\n  CXCursor_ObjCClassRef = 42,\n  /**\n   * A reference to a type declaration.\n   *\n   * A type reference occurs anywhere where a type is named but not\n   * declared. For example, given:\n   *\n   * \\code\n   * typedef unsigned size_type;\n   * size_type size;\n   * \\endcode\n   *\n   * The typedef is a declaration of size_type (CXCursor_TypedefDecl),\n   * while the type of the variable \"size\" is referenced. The cursor\n   * referenced by the type of size is the typedef for size_type.\n   */\n  CXCursor_TypeRef = 43,\n  CXCursor_CXXBaseSpecifier = 44,\n  /**\n   * A reference to a class template, function template, template\n   * template parameter, or class template partial specialization.\n   */\n  CXCursor_TemplateRef = 45,\n  /**\n   * A reference to a namespace or namespace alias.\n   */\n  CXCursor_NamespaceRef = 46,\n  /**\n   * A reference to a member of a struct, union, or class that occurs in\n   * some non-expression context, e.g., a designated initializer.\n   */\n  CXCursor_MemberRef = 47,\n  /**\n   * A reference to a labeled statement.\n   *\n   * This cursor kind is used to describe the jump to \"start_over\" in the\n   * goto statement in the following example:\n   *\n   * \\code\n   *   start_over:\n   *     ++counter;\n   *\n   *     goto start_over;\n   * \\endcode\n   *\n   * A label reference cursor refers to a label statement.\n   */\n  CXCursor_LabelRef = 48,\n\n  /**\n   * A reference to a set of overloaded functions or function templates\n   * that has not yet been resolved to a specific function or function template.\n   *\n   * An overloaded declaration reference cursor occurs in C++ templates where\n   * a dependent name refers to a function. For example:\n   *\n   * \\code\n   * template<typename T> void swap(T&, T&);\n   *\n   * struct X { ... };\n   * void swap(X&, X&);\n   *\n   * template<typename T>\n   * void reverse(T* first, T* last) {\n   *   while (first < last - 1) {\n   *     swap(*first, *--last);\n   *     ++first;\n   *   }\n   * }\n   *\n   * struct Y { };\n   * void swap(Y&, Y&);\n   * \\endcode\n   *\n   * Here, the identifier \"swap\" is associated with an overloaded declaration\n   * reference. In the template definition, \"swap\" refers to either of the two\n   * \"swap\" functions declared above, so both results will be available. At\n   * instantiation time, \"swap\" may also refer to other functions found via\n   * argument-dependent lookup (e.g., the \"swap\" function at the end of the\n   * example).\n   *\n   * The functions \\c clang_getNumOverloadedDecls() and\n   * \\c clang_getOverloadedDecl() can be used to retrieve the definitions\n   * referenced by this cursor.\n   */\n  CXCursor_OverloadedDeclRef = 49,\n\n  /**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */\n  CXCursor_VariableRef = 50,\n\n  CXCursor_LastRef = CXCursor_VariableRef,\n\n  /* Error conditions */\n  CXCursor_FirstInvalid = 70,\n  CXCursor_InvalidFile = 70,\n  CXCursor_NoDeclFound = 71,\n  CXCursor_NotImplemented = 72,\n  CXCursor_InvalidCode = 73,\n  CXCursor_LastInvalid = CXCursor_InvalidCode,\n\n  /* Expressions */\n  CXCursor_FirstExpr = 100,\n\n  /**\n   * An expression whose specific kind is not exposed via this\n   * interface.\n   *\n   * Unexposed expressions have the same operations as any other kind\n   * of expression; one can extract their location information,\n   * spelling, children, etc. However, the specific kind of the\n   * expression is not reported.\n   */\n  CXCursor_UnexposedExpr = 100,\n\n  /**\n   * An expression that refers to some value declaration, such\n   * as a function, variable, or enumerator.\n   */\n  CXCursor_DeclRefExpr = 101,\n\n  /**\n   * An expression that refers to a member of a struct, union,\n   * class, Objective-C class, etc.\n   */\n  CXCursor_MemberRefExpr = 102,\n\n  /** An expression that calls a function. */\n  CXCursor_CallExpr = 103,\n\n  /** An expression that sends a message to an Objective-C\n   object or class. */\n  CXCursor_ObjCMessageExpr = 104,\n\n  /** An expression that represents a block literal. */\n  CXCursor_BlockExpr = 105,\n\n  /** An integer literal.\n   */\n  CXCursor_IntegerLiteral = 106,\n\n  /** A floating point number literal.\n   */\n  CXCursor_FloatingLiteral = 107,\n\n  /** An imaginary number literal.\n   */\n  CXCursor_ImaginaryLiteral = 108,\n\n  /** A string literal.\n   */\n  CXCursor_StringLiteral = 109,\n\n  /** A character literal.\n   */\n  CXCursor_CharacterLiteral = 110,\n\n  /** A parenthesized expression, e.g. \"(1)\".\n   *\n   * This AST node is only formed if full location information is requested.\n   */\n  CXCursor_ParenExpr = 111,\n\n  /** This represents the unary-expression's (except sizeof and\n   * alignof).\n   */\n  CXCursor_UnaryOperator = 112,\n\n  /** [C99 6.5.2.1] Array Subscripting.\n   */\n  CXCursor_ArraySubscriptExpr = 113,\n\n  /** A builtin binary operation expression such as \"x + y\" or\n   * \"x <= y\".\n   */\n  CXCursor_BinaryOperator = 114,\n\n  /** Compound assignment such as \"+=\".\n   */\n  CXCursor_CompoundAssignOperator = 115,\n\n  /** The ?: ternary operator.\n   */\n  CXCursor_ConditionalOperator = 116,\n\n  /** An explicit cast in C (C99 6.5.4) or a C-style cast in C++\n   * (C++ [expr.cast]), which uses the syntax (Type)expr.\n   *\n   * For example: (int)f.\n   */\n  CXCursor_CStyleCastExpr = 117,\n\n  /** [C99 6.5.2.5]\n   */\n  CXCursor_CompoundLiteralExpr = 118,\n\n  /** Describes an C or C++ initializer list.\n   */\n  CXCursor_InitListExpr = 119,\n\n  /** The GNU address of label extension, representing &&label.\n   */\n  CXCursor_AddrLabelExpr = 120,\n\n  /** This is the GNU Statement Expression extension: ({int X=4; X;})\n   */\n  CXCursor_StmtExpr = 121,\n\n  /** Represents a C11 generic selection.\n   */\n  CXCursor_GenericSelectionExpr = 122,\n\n  /** Implements the GNU __null extension, which is a name for a null\n   * pointer constant that has integral type (e.g., int or long) and is the same\n   * size and alignment as a pointer.\n   *\n   * The __null extension is typically only used by system headers, which define\n   * NULL as __null in C++ rather than using 0 (which is an integer that may not\n   * match the size of a pointer).\n   */\n  CXCursor_GNUNullExpr = 123,\n\n  /** C++'s static_cast<> expression.\n   */\n  CXCursor_CXXStaticCastExpr = 124,\n\n  /** C++'s dynamic_cast<> expression.\n   */\n  CXCursor_CXXDynamicCastExpr = 125,\n\n  /** C++'s reinterpret_cast<> expression.\n   */\n  CXCursor_CXXReinterpretCastExpr = 126,\n\n  /** C++'s const_cast<> expression.\n   */\n  CXCursor_CXXConstCastExpr = 127,\n\n  /** Represents an explicit C++ type conversion that uses \"functional\"\n   * notion (C++ [expr.type.conv]).\n   *\n   * Example:\n   * \\code\n   *   x = int(0.5);\n   * \\endcode\n   */\n  CXCursor_CXXFunctionalCastExpr = 128,\n\n  /** A C++ typeid expression (C++ [expr.typeid]).\n   */\n  CXCursor_CXXTypeidExpr = 129,\n\n  /** [C++ 2.13.5] C++ Boolean Literal.\n   */\n  CXCursor_CXXBoolLiteralExpr = 130,\n\n  /** [C++0x 2.14.7] C++ Pointer Literal.\n   */\n  CXCursor_CXXNullPtrLiteralExpr = 131,\n\n  /** Represents the \"this\" expression in C++\n   */\n  CXCursor_CXXThisExpr = 132,\n\n  /** [C++ 15] C++ Throw Expression.\n   *\n   * This handles 'throw' and 'throw' assignment-expression. When\n   * assignment-expression isn't present, Op will be null.\n   */\n  CXCursor_CXXThrowExpr = 133,\n\n  /** A new expression for memory allocation and constructor calls, e.g:\n   * \"new CXXNewExpr(foo)\".\n   */\n  CXCursor_CXXNewExpr = 134,\n\n  /** A delete expression for memory deallocation and destructor calls,\n   * e.g. \"delete[] pArray\".\n   */\n  CXCursor_CXXDeleteExpr = 135,\n\n  /** A unary expression. (noexcept, sizeof, or other traits)\n   */\n  CXCursor_UnaryExpr = 136,\n\n  /** An Objective-C string literal i.e. @\"foo\".\n   */\n  CXCursor_ObjCStringLiteral = 137,\n\n  /** An Objective-C \\@encode expression.\n   */\n  CXCursor_ObjCEncodeExpr = 138,\n\n  /** An Objective-C \\@selector expression.\n   */\n  CXCursor_ObjCSelectorExpr = 139,\n\n  /** An Objective-C \\@protocol expression.\n   */\n  CXCursor_ObjCProtocolExpr = 140,\n\n  /** An Objective-C \"bridged\" cast expression, which casts between\n   * Objective-C pointers and C pointers, transferring ownership in the process.\n   *\n   * \\code\n   *   NSString *str = (__bridge_transfer NSString *)CFCreateString();\n   * \\endcode\n   */\n  CXCursor_ObjCBridgedCastExpr = 141,\n\n  /** Represents a C++0x pack expansion that produces a sequence of\n   * expressions.\n   *\n   * A pack expansion expression contains a pattern (which itself is an\n   * expression) followed by an ellipsis. For example:\n   *\n   * \\code\n   * template<typename F, typename ...Types>\n   * void forward(F f, Types &&...args) {\n   *  f(static_cast<Types&&>(args)...);\n   * }\n   * \\endcode\n   */\n  CXCursor_PackExpansionExpr = 142,\n\n  /** Represents an expression that computes the length of a parameter\n   * pack.\n   *\n   * \\code\n   * template<typename ...Types>\n   * struct count {\n   *   static const unsigned value = sizeof...(Types);\n   * };\n   * \\endcode\n   */\n  CXCursor_SizeOfPackExpr = 143,\n\n  /* Represents a C++ lambda expression that produces a local function\n   * object.\n   *\n   * \\code\n   * void abssort(float *x, unsigned N) {\n   *   std::sort(x, x + N,\n   *             [](float a, float b) {\n   *               return std::abs(a) < std::abs(b);\n   *             });\n   * }\n   * \\endcode\n   */\n  CXCursor_LambdaExpr = 144,\n\n  /** Objective-c Boolean Literal.\n   */\n  CXCursor_ObjCBoolLiteralExpr = 145,\n\n  /** Represents the \"self\" expression in an Objective-C method.\n   */\n  CXCursor_ObjCSelfExpr = 146,\n\n  /** OpenMP 5.0 [2.1.5, Array Section].\n   */\n  CXCursor_OMPArraySectionExpr = 147,\n\n  /** Represents an @available(...) check.\n   */\n  CXCursor_ObjCAvailabilityCheckExpr = 148,\n\n  /**\n   * Fixed point literal\n   */\n  CXCursor_FixedPointLiteral = 149,\n\n  /** OpenMP 5.0 [2.1.4, Array Shaping].\n   */\n  CXCursor_OMPArrayShapingExpr = 150,\n\n  /**\n   * OpenMP 5.0 [2.1.6 Iterators]\n   */\n  CXCursor_OMPIteratorExpr = 151,\n\n  /** OpenCL's addrspace_cast<> expression.\n   */\n  CXCursor_CXXAddrspaceCastExpr = 152,\n\n  CXCursor_LastExpr = CXCursor_CXXAddrspaceCastExpr,\n\n  /* Statements */\n  CXCursor_FirstStmt = 200,\n  /**\n   * A statement whose specific kind is not exposed via this\n   * interface.\n   *\n   * Unexposed statements have the same operations as any other kind of\n   * statement; one can extract their location information, spelling,\n   * children, etc. However, the specific kind of the statement is not\n   * reported.\n   */\n  CXCursor_UnexposedStmt = 200,\n\n  /** A labelled statement in a function.\n   *\n   * This cursor kind is used to describe the \"start_over:\" label statement in\n   * the following example:\n   *\n   * \\code\n   *   start_over:\n   *     ++counter;\n   * \\endcode\n   *\n   */\n  CXCursor_LabelStmt = 201,\n\n  /** A group of statements like { stmt stmt }.\n   *\n   * This cursor kind is used to describe compound statements, e.g. function\n   * bodies.\n   */\n  CXCursor_CompoundStmt = 202,\n\n  /** A case statement.\n   */\n  CXCursor_CaseStmt = 203,\n\n  /** A default statement.\n   */\n  CXCursor_DefaultStmt = 204,\n\n  /** An if statement\n   */\n  CXCursor_IfStmt = 205,\n\n  /** A switch statement.\n   */\n  CXCursor_SwitchStmt = 206,\n\n  /** A while statement.\n   */\n  CXCursor_WhileStmt = 207,\n\n  /** A do statement.\n   */\n  CXCursor_DoStmt = 208,\n\n  /** A for statement.\n   */\n  CXCursor_ForStmt = 209,\n\n  /** A goto statement.\n   */\n  CXCursor_GotoStmt = 210,\n\n  /** An indirect goto statement.\n   */\n  CXCursor_IndirectGotoStmt = 211,\n\n  /** A continue statement.\n   */\n  CXCursor_ContinueStmt = 212,\n\n  /** A break statement.\n   */\n  CXCursor_BreakStmt = 213,\n\n  /** A return statement.\n   */\n  CXCursor_ReturnStmt = 214,\n\n  /** A GCC inline assembly statement extension.\n   */\n  CXCursor_GCCAsmStmt = 215,\n  CXCursor_AsmStmt = CXCursor_GCCAsmStmt,\n\n  /** Objective-C's overall \\@try-\\@catch-\\@finally statement.\n   */\n  CXCursor_ObjCAtTryStmt = 216,\n\n  /** Objective-C's \\@catch statement.\n   */\n  CXCursor_ObjCAtCatchStmt = 217,\n\n  /** Objective-C's \\@finally statement.\n   */\n  CXCursor_ObjCAtFinallyStmt = 218,\n\n  /** Objective-C's \\@throw statement.\n   */\n  CXCursor_ObjCAtThrowStmt = 219,\n\n  /** Objective-C's \\@synchronized statement.\n   */\n  CXCursor_ObjCAtSynchronizedStmt = 220,\n\n  /** Objective-C's autorelease pool statement.\n   */\n  CXCursor_ObjCAutoreleasePoolStmt = 221,\n\n  /** Objective-C's collection statement.\n   */\n  CXCursor_ObjCForCollectionStmt = 222,\n\n  /** C++'s catch statement.\n   */\n  CXCursor_CXXCatchStmt = 223,\n\n  /** C++'s try statement.\n   */\n  CXCursor_CXXTryStmt = 224,\n\n  /** C++'s for (* : *) statement.\n   */\n  CXCursor_CXXForRangeStmt = 225,\n\n  /** Windows Structured Exception Handling's try statement.\n   */\n  CXCursor_SEHTryStmt = 226,\n\n  /** Windows Structured Exception Handling's except statement.\n   */\n  CXCursor_SEHExceptStmt = 227,\n\n  /** Windows Structured Exception Handling's finally statement.\n   */\n  CXCursor_SEHFinallyStmt = 228,\n\n  /** A MS inline assembly statement extension.\n   */\n  CXCursor_MSAsmStmt = 229,\n\n  /** The null statement \";\": C99 6.8.3p3.\n   *\n   * This cursor kind is used to describe the null statement.\n   */\n  CXCursor_NullStmt = 230,\n\n  /** Adaptor class for mixing declarations with statements and\n   * expressions.\n   */\n  CXCursor_DeclStmt = 231,\n\n  /** OpenMP parallel directive.\n   */\n  CXCursor_OMPParallelDirective = 232,\n\n  /** OpenMP SIMD directive.\n   */\n  CXCursor_OMPSimdDirective = 233,\n\n  /** OpenMP for directive.\n   */\n  CXCursor_OMPForDirective = 234,\n\n  /** OpenMP sections directive.\n   */\n  CXCursor_OMPSectionsDirective = 235,\n\n  /** OpenMP section directive.\n   */\n  CXCursor_OMPSectionDirective = 236,\n\n  /** OpenMP single directive.\n   */\n  CXCursor_OMPSingleDirective = 237,\n\n  /** OpenMP parallel for directive.\n   */\n  CXCursor_OMPParallelForDirective = 238,\n\n  /** OpenMP parallel sections directive.\n   */\n  CXCursor_OMPParallelSectionsDirective = 239,\n\n  /** OpenMP task directive.\n   */\n  CXCursor_OMPTaskDirective = 240,\n\n  /** OpenMP master directive.\n   */\n  CXCursor_OMPMasterDirective = 241,\n\n  /** OpenMP critical directive.\n   */\n  CXCursor_OMPCriticalDirective = 242,\n\n  /** OpenMP taskyield directive.\n   */\n  CXCursor_OMPTaskyieldDirective = 243,\n\n  /** OpenMP barrier directive.\n   */\n  CXCursor_OMPBarrierDirective = 244,\n\n  /** OpenMP taskwait directive.\n   */\n  CXCursor_OMPTaskwaitDirective = 245,\n\n  /** OpenMP flush directive.\n   */\n  CXCursor_OMPFlushDirective = 246,\n\n  /** Windows Structured Exception Handling's leave statement.\n   */\n  CXCursor_SEHLeaveStmt = 247,\n\n  /** OpenMP ordered directive.\n   */\n  CXCursor_OMPOrderedDirective = 248,\n\n  /** OpenMP atomic directive.\n   */\n  CXCursor_OMPAtomicDirective = 249,\n\n  /** OpenMP for SIMD directive.\n   */\n  CXCursor_OMPForSimdDirective = 250,\n\n  /** OpenMP parallel for SIMD directive.\n   */\n  CXCursor_OMPParallelForSimdDirective = 251,\n\n  /** OpenMP target directive.\n   */\n  CXCursor_OMPTargetDirective = 252,\n\n  /** OpenMP teams directive.\n   */\n  CXCursor_OMPTeamsDirective = 253,\n\n  /** OpenMP taskgroup directive.\n   */\n  CXCursor_OMPTaskgroupDirective = 254,\n\n  /** OpenMP cancellation point directive.\n   */\n  CXCursor_OMPCancellationPointDirective = 255,\n\n  /** OpenMP cancel directive.\n   */\n  CXCursor_OMPCancelDirective = 256,\n\n  /** OpenMP target data directive.\n   */\n  CXCursor_OMPTargetDataDirective = 257,\n\n  /** OpenMP taskloop directive.\n   */\n  CXCursor_OMPTaskLoopDirective = 258,\n\n  /** OpenMP taskloop simd directive.\n   */\n  CXCursor_OMPTaskLoopSimdDirective = 259,\n\n  /** OpenMP distribute directive.\n   */\n  CXCursor_OMPDistributeDirective = 260,\n\n  /** OpenMP target enter data directive.\n   */\n  CXCursor_OMPTargetEnterDataDirective = 261,\n\n  /** OpenMP target exit data directive.\n   */\n  CXCursor_OMPTargetExitDataDirective = 262,\n\n  /** OpenMP target parallel directive.\n   */\n  CXCursor_OMPTargetParallelDirective = 263,\n\n  /** OpenMP target parallel for directive.\n   */\n  CXCursor_OMPTargetParallelForDirective = 264,\n\n  /** OpenMP target update directive.\n   */\n  CXCursor_OMPTargetUpdateDirective = 265,\n\n  /** OpenMP distribute parallel for directive.\n   */\n  CXCursor_OMPDistributeParallelForDirective = 266,\n\n  /** OpenMP distribute parallel for simd directive.\n   */\n  CXCursor_OMPDistributeParallelForSimdDirective = 267,\n\n  /** OpenMP distribute simd directive.\n   */\n  CXCursor_OMPDistributeSimdDirective = 268,\n\n  /** OpenMP target parallel for simd directive.\n   */\n  CXCursor_OMPTargetParallelForSimdDirective = 269,\n\n  /** OpenMP target simd directive.\n   */\n  CXCursor_OMPTargetSimdDirective = 270,\n\n  /** OpenMP teams distribute directive.\n   */\n  CXCursor_OMPTeamsDistributeDirective = 271,\n\n  /** OpenMP teams distribute simd directive.\n   */\n  CXCursor_OMPTeamsDistributeSimdDirective = 272,\n\n  /** OpenMP teams distribute parallel for simd directive.\n   */\n  CXCursor_OMPTeamsDistributeParallelForSimdDirective = 273,\n\n  /** OpenMP teams distribute parallel for directive.\n   */\n  CXCursor_OMPTeamsDistributeParallelForDirective = 274,\n\n  /** OpenMP target teams directive.\n   */\n  CXCursor_OMPTargetTeamsDirective = 275,\n\n  /** OpenMP target teams distribute directive.\n   */\n  CXCursor_OMPTargetTeamsDistributeDirective = 276,\n\n  /** OpenMP target teams distribute parallel for directive.\n   */\n  CXCursor_OMPTargetTeamsDistributeParallelForDirective = 277,\n\n  /** OpenMP target teams distribute parallel for simd directive.\n   */\n  CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective = 278,\n\n  /** OpenMP target teams distribute simd directive.\n   */\n  CXCursor_OMPTargetTeamsDistributeSimdDirective = 279,\n\n  /** C++2a std::bit_cast expression.\n   */\n  CXCursor_BuiltinBitCastExpr = 280,\n\n  /** OpenMP master taskloop directive.\n   */\n  CXCursor_OMPMasterTaskLoopDirective = 281,\n\n  /** OpenMP parallel master taskloop directive.\n   */\n  CXCursor_OMPParallelMasterTaskLoopDirective = 282,\n\n  /** OpenMP master taskloop simd directive.\n   */\n  CXCursor_OMPMasterTaskLoopSimdDirective = 283,\n\n  /** OpenMP parallel master taskloop simd directive.\n   */\n  CXCursor_OMPParallelMasterTaskLoopSimdDirective = 284,\n\n  /** OpenMP parallel master directive.\n   */\n  CXCursor_OMPParallelMasterDirective = 285,\n\n  /** OpenMP depobj directive.\n   */\n  CXCursor_OMPDepobjDirective = 286,\n\n  /** OpenMP scan directive.\n   */\n  CXCursor_OMPScanDirective = 287,\n\n  /** OpenMP tile directive.\n   */\n  CXCursor_OMPTileDirective = 288,\n\n  /** OpenMP canonical loop.\n   */\n  CXCursor_OMPCanonicalLoop = 289,\n\n  CXCursor_LastStmt = CXCursor_OMPCanonicalLoop,\n\n  /**\n   * Cursor that represents the translation unit itself.\n   *\n   * The translation unit cursor exists primarily to act as the root\n   * cursor for traversing the contents of a translation unit.\n   */\n  CXCursor_TranslationUnit = 300,\n\n  /* Attributes */\n  CXCursor_FirstAttr = 400,\n  /**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */\n  CXCursor_UnexposedAttr = 400,\n\n  CXCursor_IBActionAttr = 401,\n  CXCursor_IBOutletAttr = 402,\n  CXCursor_IBOutletCollectionAttr = 403,\n  CXCursor_CXXFinalAttr = 404,\n  CXCursor_CXXOverrideAttr = 405,\n  CXCursor_AnnotateAttr = 406,\n  CXCursor_AsmLabelAttr = 407,\n  CXCursor_PackedAttr = 408,\n  CXCursor_PureAttr = 409,\n  CXCursor_ConstAttr = 410,\n  CXCursor_NoDuplicateAttr = 411,\n  CXCursor_CUDAConstantAttr = 412,\n  CXCursor_CUDADeviceAttr = 413,\n  CXCursor_CUDAGlobalAttr = 414,\n  CXCursor_CUDAHostAttr = 415,\n  CXCursor_CUDASharedAttr = 416,\n  CXCursor_VisibilityAttr = 417,\n  CXCursor_DLLExport = 418,\n  CXCursor_DLLImport = 419,\n  CXCursor_NSReturnsRetained = 420,\n  CXCursor_NSReturnsNotRetained = 421,\n  CXCursor_NSReturnsAutoreleased = 422,\n  CXCursor_NSConsumesSelf = 423,\n  CXCursor_NSConsumed = 424,\n  CXCursor_ObjCException = 425,\n  CXCursor_ObjCNSObject = 426,\n  CXCursor_ObjCIndependentClass = 427,\n  CXCursor_ObjCPreciseLifetime = 428,\n  CXCursor_ObjCReturnsInnerPointer = 429,\n  CXCursor_ObjCRequiresSuper = 430,\n  CXCursor_ObjCRootClass = 431,\n  CXCursor_ObjCSubclassingRestricted = 432,\n  CXCursor_ObjCExplicitProtocolImpl = 433,\n  CXCursor_ObjCDesignatedInitializer = 434,\n  CXCursor_ObjCRuntimeVisible = 435,\n  CXCursor_ObjCBoxable = 436,\n  CXCursor_FlagEnum = 437,\n  CXCursor_ConvergentAttr = 438,\n  CXCursor_WarnUnusedAttr = 439,\n  CXCursor_WarnUnusedResultAttr = 440,\n  CXCursor_AlignedAttr = 441,\n  CXCursor_LastAttr = CXCursor_AlignedAttr,\n\n  /* Preprocessing */\n  CXCursor_PreprocessingDirective = 500,\n  CXCursor_MacroDefinition = 501,\n  CXCursor_MacroExpansion = 502,\n  CXCursor_MacroInstantiation = CXCursor_MacroExpansion,\n  CXCursor_InclusionDirective = 503,\n  CXCursor_FirstPreprocessing = CXCursor_PreprocessingDirective,\n  CXCursor_LastPreprocessing = CXCursor_InclusionDirective,\n\n  /* Extra Declarations */\n  /**\n   * A module import declaration.\n   */\n  CXCursor_ModuleImportDecl = 600,\n  CXCursor_TypeAliasTemplateDecl = 601,\n  /**\n   * A static_assert or _Static_assert node\n   */\n  CXCursor_StaticAssert = 602,\n  /**\n   * a friend declaration.\n   */\n  CXCursor_FriendDecl = 603,\n  CXCursor_FirstExtraDecl = CXCursor_ModuleImportDecl,\n  CXCursor_LastExtraDecl = CXCursor_FriendDecl,\n\n  /**\n   * A code completion overload candidate.\n   */\n  CXCursor_OverloadCandidate = 700\n};\n\n/**\n * A cursor representing some element in the abstract syntax tree for\n * a translation unit.\n *\n * The cursor abstraction unifies the different kinds of entities in a\n * program--declaration, statements, expressions, references to declarations,\n * etc.--under a single \"cursor\" abstraction with a common set of operations.\n * Common operation for a cursor include: getting the physical location in\n * a source file where the cursor points, getting the name associated with a\n * cursor, and retrieving cursors for any child nodes of a particular cursor.\n *\n * Cursors can be produced in two specific ways.\n * clang_getTranslationUnitCursor() produces a cursor for a translation unit,\n * from which one can use clang_visitChildren() to explore the rest of the\n * translation unit. clang_getCursor() maps from a physical source location\n * to the entity that resides at that location, allowing one to map from the\n * source code into the AST.\n */\ntypedef struct {\n  enum CXCursorKind kind;\n  int xdata;\n  const void *data[3];\n} CXCursor;\n\n/**\n * \\defgroup CINDEX_CURSOR_MANIP Cursor manipulations\n *\n * @{\n */\n\n/**\n * Retrieve the NULL cursor, which represents no entity.\n */\nCINDEX_LINKAGE CXCursor clang_getNullCursor(void);\n\n/**\n * Retrieve the cursor that represents the given translation unit.\n *\n * The translation unit cursor can be used to start traversing the\n * various declarations within the given translation unit.\n */\nCINDEX_LINKAGE CXCursor clang_getTranslationUnitCursor(CXTranslationUnit);\n\n/**\n * Determine whether two cursors are equivalent.\n */\nCINDEX_LINKAGE unsigned clang_equalCursors(CXCursor, CXCursor);\n\n/**\n * Returns non-zero if \\p cursor is null.\n */\nCINDEX_LINKAGE int clang_Cursor_isNull(CXCursor cursor);\n\n/**\n * Compute a hash value for the given cursor.\n */\nCINDEX_LINKAGE unsigned clang_hashCursor(CXCursor);\n\n/**\n * Retrieve the kind of the given cursor.\n */\nCINDEX_LINKAGE enum CXCursorKind clang_getCursorKind(CXCursor);\n\n/**\n * Determine whether the given cursor kind represents a declaration.\n */\nCINDEX_LINKAGE unsigned clang_isDeclaration(enum CXCursorKind);\n\n/**\n * Determine whether the given declaration is invalid.\n *\n * A declaration is invalid if it could not be parsed successfully.\n *\n * \\returns non-zero if the cursor represents a declaration and it is\n * invalid, otherwise NULL.\n */\nCINDEX_LINKAGE unsigned clang_isInvalidDeclaration(CXCursor);\n\n/**\n * Determine whether the given cursor kind represents a simple\n * reference.\n *\n * Note that other kinds of cursors (such as expressions) can also refer to\n * other cursors. Use clang_getCursorReferenced() to determine whether a\n * particular cursor refers to another entity.\n */\nCINDEX_LINKAGE unsigned clang_isReference(enum CXCursorKind);\n\n/**\n * Determine whether the given cursor kind represents an expression.\n */\nCINDEX_LINKAGE unsigned clang_isExpression(enum CXCursorKind);\n\n/**\n * Determine whether the given cursor kind represents a statement.\n */\nCINDEX_LINKAGE unsigned clang_isStatement(enum CXCursorKind);\n\n/**\n * Determine whether the given cursor kind represents an attribute.\n */\nCINDEX_LINKAGE unsigned clang_isAttribute(enum CXCursorKind);\n\n/**\n * Determine whether the given cursor has any attributes.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_hasAttrs(CXCursor C);\n\n/**\n * Determine whether the given cursor kind represents an invalid\n * cursor.\n */\nCINDEX_LINKAGE unsigned clang_isInvalid(enum CXCursorKind);\n\n/**\n * Determine whether the given cursor kind represents a translation\n * unit.\n */\nCINDEX_LINKAGE unsigned clang_isTranslationUnit(enum CXCursorKind);\n\n/***\n * Determine whether the given cursor represents a preprocessing\n * element, such as a preprocessor directive or macro instantiation.\n */\nCINDEX_LINKAGE unsigned clang_isPreprocessing(enum CXCursorKind);\n\n/***\n * Determine whether the given cursor represents a currently\n *  unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).\n */\nCINDEX_LINKAGE unsigned clang_isUnexposed(enum CXCursorKind);\n\n/**\n * Describe the linkage of the entity referred to by a cursor.\n */\nenum CXLinkageKind {\n  /** This value indicates that no linkage information is available\n   * for a provided CXCursor. */\n  CXLinkage_Invalid,\n  /**\n   * This is the linkage for variables, parameters, and so on that\n   *  have automatic storage.  This covers normal (non-extern) local variables.\n   */\n  CXLinkage_NoLinkage,\n  /** This is the linkage for static variables and static functions. */\n  CXLinkage_Internal,\n  /** This is the linkage for entities with external linkage that live\n   * in C++ anonymous namespaces.*/\n  CXLinkage_UniqueExternal,\n  /** This is the linkage for entities with true, external linkage. */\n  CXLinkage_External\n};\n\n/**\n * Determine the linkage of the entity referred to by a given cursor.\n */\nCINDEX_LINKAGE enum CXLinkageKind clang_getCursorLinkage(CXCursor cursor);\n\nenum CXVisibilityKind {\n  /** This value indicates that no visibility information is available\n   * for a provided CXCursor. */\n  CXVisibility_Invalid,\n\n  /** Symbol not seen by the linker. */\n  CXVisibility_Hidden,\n  /** Symbol seen by the linker but resolves to a symbol inside this object. */\n  CXVisibility_Protected,\n  /** Symbol seen by the linker and acts like a normal symbol. */\n  CXVisibility_Default\n};\n\n/**\n * Describe the visibility of the entity referred to by a cursor.\n *\n * This returns the default visibility if not explicitly specified by\n * a visibility attribute. The default visibility may be changed by\n * commandline arguments.\n *\n * \\param cursor The cursor to query.\n *\n * \\returns The visibility of the cursor.\n */\nCINDEX_LINKAGE enum CXVisibilityKind clang_getCursorVisibility(CXCursor cursor);\n\n/**\n * Determine the availability of the entity that this cursor refers to,\n * taking the current target platform into account.\n *\n * \\param cursor The cursor to query.\n *\n * \\returns The availability of the cursor.\n */\nCINDEX_LINKAGE enum CXAvailabilityKind\nclang_getCursorAvailability(CXCursor cursor);\n\n/**\n * Describes the availability of a given entity on a particular platform, e.g.,\n * a particular class might only be available on Mac OS 10.7 or newer.\n */\ntypedef struct CXPlatformAvailability {\n  /**\n   * A string that describes the platform for which this structure\n   * provides availability information.\n   *\n   * Possible values are \"ios\" or \"macos\".\n   */\n  CXString Platform;\n  /**\n   * The version number in which this entity was introduced.\n   */\n  CXVersion Introduced;\n  /**\n   * The version number in which this entity was deprecated (but is\n   * still available).\n   */\n  CXVersion Deprecated;\n  /**\n   * The version number in which this entity was obsoleted, and therefore\n   * is no longer available.\n   */\n  CXVersion Obsoleted;\n  /**\n   * Whether the entity is unconditionally unavailable on this platform.\n   */\n  int Unavailable;\n  /**\n   * An optional message to provide to a user of this API, e.g., to\n   * suggest replacement APIs.\n   */\n  CXString Message;\n} CXPlatformAvailability;\n\n/**\n * Determine the availability of the entity that this cursor refers to\n * on any platforms for which availability information is known.\n *\n * \\param cursor The cursor to query.\n *\n * \\param always_deprecated If non-NULL, will be set to indicate whether the\n * entity is deprecated on all platforms.\n *\n * \\param deprecated_message If non-NULL, will be set to the message text\n * provided along with the unconditional deprecation of this entity. The client\n * is responsible for deallocating this string.\n *\n * \\param always_unavailable If non-NULL, will be set to indicate whether the\n * entity is unavailable on all platforms.\n *\n * \\param unavailable_message If non-NULL, will be set to the message text\n * provided along with the unconditional unavailability of this entity. The\n * client is responsible for deallocating this string.\n *\n * \\param availability If non-NULL, an array of CXPlatformAvailability instances\n * that will be populated with platform availability information, up to either\n * the number of platforms for which availability information is available (as\n * returned by this function) or \\c availability_size, whichever is smaller.\n *\n * \\param availability_size The number of elements available in the\n * \\c availability array.\n *\n * \\returns The number of platforms (N) for which availability information is\n * available (which is unrelated to \\c availability_size).\n *\n * Note that the client is responsible for calling\n * \\c clang_disposeCXPlatformAvailability to free each of the\n * platform-availability structures returned. There are\n * \\c min(N, availability_size) such structures.\n */\nCINDEX_LINKAGE int clang_getCursorPlatformAvailability(\n    CXCursor cursor, int *always_deprecated, CXString *deprecated_message,\n    int *always_unavailable, CXString *unavailable_message,\n    CXPlatformAvailability *availability, int availability_size);\n\n/**\n * Free the memory associated with a \\c CXPlatformAvailability structure.\n */\nCINDEX_LINKAGE void\nclang_disposeCXPlatformAvailability(CXPlatformAvailability *availability);\n\n/**\n * If cursor refers to a variable declaration and it has initializer returns\n * cursor referring to the initializer otherwise return null cursor.\n */\nCINDEX_LINKAGE CXCursor clang_Cursor_getVarDeclInitializer(CXCursor cursor);\n\n/**\n * If cursor refers to a variable declaration that has global storage returns 1.\n * If cursor refers to a variable declaration that doesn't have global storage\n * returns 0. Otherwise returns -1.\n */\nCINDEX_LINKAGE int clang_Cursor_hasVarDeclGlobalStorage(CXCursor cursor);\n\n/**\n * If cursor refers to a variable declaration that has external storage\n * returns 1. If cursor refers to a variable declaration that doesn't have\n * external storage returns 0. Otherwise returns -1.\n */\nCINDEX_LINKAGE int clang_Cursor_hasVarDeclExternalStorage(CXCursor cursor);\n\n/**\n * Describe the \"language\" of the entity referred to by a cursor.\n */\nenum CXLanguageKind {\n  CXLanguage_Invalid = 0,\n  CXLanguage_C,\n  CXLanguage_ObjC,\n  CXLanguage_CPlusPlus\n};\n\n/**\n * Determine the \"language\" of the entity referred to by a given cursor.\n */\nCINDEX_LINKAGE enum CXLanguageKind clang_getCursorLanguage(CXCursor cursor);\n\n/**\n * Describe the \"thread-local storage (TLS) kind\" of the declaration\n * referred to by a cursor.\n */\nenum CXTLSKind { CXTLS_None = 0, CXTLS_Dynamic, CXTLS_Static };\n\n/**\n * Determine the \"thread-local storage (TLS) kind\" of the declaration\n * referred to by a cursor.\n */\nCINDEX_LINKAGE enum CXTLSKind clang_getCursorTLSKind(CXCursor cursor);\n\n/**\n * Returns the translation unit that a cursor originated from.\n */\nCINDEX_LINKAGE CXTranslationUnit clang_Cursor_getTranslationUnit(CXCursor);\n\n/**\n * A fast container representing a set of CXCursors.\n */\ntypedef struct CXCursorSetImpl *CXCursorSet;\n\n/**\n * Creates an empty CXCursorSet.\n */\nCINDEX_LINKAGE CXCursorSet clang_createCXCursorSet(void);\n\n/**\n * Disposes a CXCursorSet and releases its associated memory.\n */\nCINDEX_LINKAGE void clang_disposeCXCursorSet(CXCursorSet cset);\n\n/**\n * Queries a CXCursorSet to see if it contains a specific CXCursor.\n *\n * \\returns non-zero if the set contains the specified cursor.\n */\nCINDEX_LINKAGE unsigned clang_CXCursorSet_contains(CXCursorSet cset,\n                                                   CXCursor cursor);\n\n/**\n * Inserts a CXCursor into a CXCursorSet.\n *\n * \\returns zero if the CXCursor was already in the set, and non-zero otherwise.\n */\nCINDEX_LINKAGE unsigned clang_CXCursorSet_insert(CXCursorSet cset,\n                                                 CXCursor cursor);\n\n/**\n * Determine the semantic parent of the given cursor.\n *\n * The semantic parent of a cursor is the cursor that semantically contains\n * the given \\p cursor. For many declarations, the lexical and semantic parents\n * are equivalent (the lexical parent is returned by\n * \\c clang_getCursorLexicalParent()). They diverge when declarations or\n * definitions are provided out-of-line. For example:\n *\n * \\code\n * class C {\n *  void f();\n * };\n *\n * void C::f() { }\n * \\endcode\n *\n * In the out-of-line definition of \\c C::f, the semantic parent is\n * the class \\c C, of which this function is a member. The lexical parent is\n * the place where the declaration actually occurs in the source code; in this\n * case, the definition occurs in the translation unit. In general, the\n * lexical parent for a given entity can change without affecting the semantics\n * of the program, and the lexical parent of different declarations of the\n * same entity may be different. Changing the semantic parent of a declaration,\n * on the other hand, can have a major impact on semantics, and redeclarations\n * of a particular entity should all have the same semantic context.\n *\n * In the example above, both declarations of \\c C::f have \\c C as their\n * semantic context, while the lexical context of the first \\c C::f is \\c C\n * and the lexical context of the second \\c C::f is the translation unit.\n *\n * For global declarations, the semantic parent is the translation unit.\n */\nCINDEX_LINKAGE CXCursor clang_getCursorSemanticParent(CXCursor cursor);\n\n/**\n * Determine the lexical parent of the given cursor.\n *\n * The lexical parent of a cursor is the cursor in which the given \\p cursor\n * was actually written. For many declarations, the lexical and semantic parents\n * are equivalent (the semantic parent is returned by\n * \\c clang_getCursorSemanticParent()). They diverge when declarations or\n * definitions are provided out-of-line. For example:\n *\n * \\code\n * class C {\n *  void f();\n * };\n *\n * void C::f() { }\n * \\endcode\n *\n * In the out-of-line definition of \\c C::f, the semantic parent is\n * the class \\c C, of which this function is a member. The lexical parent is\n * the place where the declaration actually occurs in the source code; in this\n * case, the definition occurs in the translation unit. In general, the\n * lexical parent for a given entity can change without affecting the semantics\n * of the program, and the lexical parent of different declarations of the\n * same entity may be different. Changing the semantic parent of a declaration,\n * on the other hand, can have a major impact on semantics, and redeclarations\n * of a particular entity should all have the same semantic context.\n *\n * In the example above, both declarations of \\c C::f have \\c C as their\n * semantic context, while the lexical context of the first \\c C::f is \\c C\n * and the lexical context of the second \\c C::f is the translation unit.\n *\n * For declarations written in the global scope, the lexical parent is\n * the translation unit.\n */\nCINDEX_LINKAGE CXCursor clang_getCursorLexicalParent(CXCursor cursor);\n\n/**\n * Determine the set of methods that are overridden by the given\n * method.\n *\n * In both Objective-C and C++, a method (aka virtual member function,\n * in C++) can override a virtual method in a base class. For\n * Objective-C, a method is said to override any method in the class's\n * base class, its protocols, or its categories' protocols, that has the same\n * selector and is of the same kind (class or instance).\n * If no such method exists, the search continues to the class's superclass,\n * its protocols, and its categories, and so on. A method from an Objective-C\n * implementation is considered to override the same methods as its\n * corresponding method in the interface.\n *\n * For C++, a virtual member function overrides any virtual member\n * function with the same signature that occurs in its base\n * classes. With multiple inheritance, a virtual member function can\n * override several virtual member functions coming from different\n * base classes.\n *\n * In all cases, this function determines the immediate overridden\n * method, rather than all of the overridden methods. For example, if\n * a method is originally declared in a class A, then overridden in B\n * (which in inherits from A) and also in C (which inherited from B),\n * then the only overridden method returned from this function when\n * invoked on C's method will be B's method. The client may then\n * invoke this function again, given the previously-found overridden\n * methods, to map out the complete method-override set.\n *\n * \\param cursor A cursor representing an Objective-C or C++\n * method. This routine will compute the set of methods that this\n * method overrides.\n *\n * \\param overridden A pointer whose pointee will be replaced with a\n * pointer to an array of cursors, representing the set of overridden\n * methods. If there are no overridden methods, the pointee will be\n * set to NULL. The pointee must be freed via a call to\n * \\c clang_disposeOverriddenCursors().\n *\n * \\param num_overridden A pointer to the number of overridden\n * functions, will be set to the number of overridden functions in the\n * array pointed to by \\p overridden.\n */\nCINDEX_LINKAGE void clang_getOverriddenCursors(CXCursor cursor,\n                                               CXCursor **overridden,\n                                               unsigned *num_overridden);\n\n/**\n * Free the set of overridden cursors returned by \\c\n * clang_getOverriddenCursors().\n */\nCINDEX_LINKAGE void clang_disposeOverriddenCursors(CXCursor *overridden);\n\n/**\n * Retrieve the file that is included by the given inclusion directive\n * cursor.\n */\nCINDEX_LINKAGE CXFile clang_getIncludedFile(CXCursor cursor);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_CURSOR_SOURCE Mapping between cursors and source code\n *\n * Cursors represent a location within the Abstract Syntax Tree (AST). These\n * routines help map between cursors and the physical locations where the\n * described entities occur in the source code. The mapping is provided in\n * both directions, so one can map from source code to the AST and back.\n *\n * @{\n */\n\n/**\n * Map a source location to the cursor that describes the entity at that\n * location in the source code.\n *\n * clang_getCursor() maps an arbitrary source location within a translation\n * unit down to the most specific cursor that describes the entity at that\n * location. For example, given an expression \\c x + y, invoking\n * clang_getCursor() with a source location pointing to \"x\" will return the\n * cursor for \"x\"; similarly for \"y\". If the cursor points anywhere between\n * \"x\" or \"y\" (e.g., on the + or the whitespace around it), clang_getCursor()\n * will return a cursor referring to the \"+\" expression.\n *\n * \\returns a cursor representing the entity at the given source location, or\n * a NULL cursor if no such entity can be found.\n */\nCINDEX_LINKAGE CXCursor clang_getCursor(CXTranslationUnit, CXSourceLocation);\n\n/**\n * Retrieve the physical location of the source constructor referenced\n * by the given cursor.\n *\n * The location of a declaration is typically the location of the name of that\n * declaration, where the name of that declaration would occur if it is\n * unnamed, or some keyword that introduces that particular declaration.\n * The location of a reference is where that reference occurs within the\n * source code.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getCursorLocation(CXCursor);\n\n/**\n * Retrieve the physical extent of the source construct referenced by\n * the given cursor.\n *\n * The extent of a cursor starts with the file/line/column pointing at the\n * first character within the source construct that the cursor refers to and\n * ends with the last character within that source construct. For a\n * declaration, the extent covers the declaration itself. For a reference,\n * the extent covers the location of the reference (e.g., where the referenced\n * entity was actually used).\n */\nCINDEX_LINKAGE CXSourceRange clang_getCursorExtent(CXCursor);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_TYPES Type information for CXCursors\n *\n * @{\n */\n\n/**\n * Describes the kind of type\n */\nenum CXTypeKind {\n  /**\n   * Represents an invalid type (e.g., where no type is available).\n   */\n  CXType_Invalid = 0,\n\n  /**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */\n  CXType_Unexposed = 1,\n\n  /* Builtin types */\n  CXType_Void = 2,\n  CXType_Bool = 3,\n  CXType_Char_U = 4,\n  CXType_UChar = 5,\n  CXType_Char16 = 6,\n  CXType_Char32 = 7,\n  CXType_UShort = 8,\n  CXType_UInt = 9,\n  CXType_ULong = 10,\n  CXType_ULongLong = 11,\n  CXType_UInt128 = 12,\n  CXType_Char_S = 13,\n  CXType_SChar = 14,\n  CXType_WChar = 15,\n  CXType_Short = 16,\n  CXType_Int = 17,\n  CXType_Long = 18,\n  CXType_LongLong = 19,\n  CXType_Int128 = 20,\n  CXType_Float = 21,\n  CXType_Double = 22,\n  CXType_LongDouble = 23,\n  CXType_NullPtr = 24,\n  CXType_Overload = 25,\n  CXType_Dependent = 26,\n  CXType_ObjCId = 27,\n  CXType_ObjCClass = 28,\n  CXType_ObjCSel = 29,\n  CXType_Float128 = 30,\n  CXType_Half = 31,\n  CXType_Float16 = 32,\n  CXType_ShortAccum = 33,\n  CXType_Accum = 34,\n  CXType_LongAccum = 35,\n  CXType_UShortAccum = 36,\n  CXType_UAccum = 37,\n  CXType_ULongAccum = 38,\n  CXType_BFloat16 = 39,\n  CXType_FirstBuiltin = CXType_Void,\n  CXType_LastBuiltin = CXType_BFloat16,\n\n  CXType_Complex = 100,\n  CXType_Pointer = 101,\n  CXType_BlockPointer = 102,\n  CXType_LValueReference = 103,\n  CXType_RValueReference = 104,\n  CXType_Record = 105,\n  CXType_Enum = 106,\n  CXType_Typedef = 107,\n  CXType_ObjCInterface = 108,\n  CXType_ObjCObjectPointer = 109,\n  CXType_FunctionNoProto = 110,\n  CXType_FunctionProto = 111,\n  CXType_ConstantArray = 112,\n  CXType_Vector = 113,\n  CXType_IncompleteArray = 114,\n  CXType_VariableArray = 115,\n  CXType_DependentSizedArray = 116,\n  CXType_MemberPointer = 117,\n  CXType_Auto = 118,\n\n  /**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */\n  CXType_Elaborated = 119,\n\n  /* OpenCL PipeType. */\n  CXType_Pipe = 120,\n\n  /* OpenCL builtin types. */\n  CXType_OCLImage1dRO = 121,\n  CXType_OCLImage1dArrayRO = 122,\n  CXType_OCLImage1dBufferRO = 123,\n  CXType_OCLImage2dRO = 124,\n  CXType_OCLImage2dArrayRO = 125,\n  CXType_OCLImage2dDepthRO = 126,\n  CXType_OCLImage2dArrayDepthRO = 127,\n  CXType_OCLImage2dMSAARO = 128,\n  CXType_OCLImage2dArrayMSAARO = 129,\n  CXType_OCLImage2dMSAADepthRO = 130,\n  CXType_OCLImage2dArrayMSAADepthRO = 131,\n  CXType_OCLImage3dRO = 132,\n  CXType_OCLImage1dWO = 133,\n  CXType_OCLImage1dArrayWO = 134,\n  CXType_OCLImage1dBufferWO = 135,\n  CXType_OCLImage2dWO = 136,\n  CXType_OCLImage2dArrayWO = 137,\n  CXType_OCLImage2dDepthWO = 138,\n  CXType_OCLImage2dArrayDepthWO = 139,\n  CXType_OCLImage2dMSAAWO = 140,\n  CXType_OCLImage2dArrayMSAAWO = 141,\n  CXType_OCLImage2dMSAADepthWO = 142,\n  CXType_OCLImage2dArrayMSAADepthWO = 143,\n  CXType_OCLImage3dWO = 144,\n  CXType_OCLImage1dRW = 145,\n  CXType_OCLImage1dArrayRW = 146,\n  CXType_OCLImage1dBufferRW = 147,\n  CXType_OCLImage2dRW = 148,\n  CXType_OCLImage2dArrayRW = 149,\n  CXType_OCLImage2dDepthRW = 150,\n  CXType_OCLImage2dArrayDepthRW = 151,\n  CXType_OCLImage2dMSAARW = 152,\n  CXType_OCLImage2dArrayMSAARW = 153,\n  CXType_OCLImage2dMSAADepthRW = 154,\n  CXType_OCLImage2dArrayMSAADepthRW = 155,\n  CXType_OCLImage3dRW = 156,\n  CXType_OCLSampler = 157,\n  CXType_OCLEvent = 158,\n  CXType_OCLQueue = 159,\n  CXType_OCLReserveID = 160,\n\n  CXType_ObjCObject = 161,\n  CXType_ObjCTypeParam = 162,\n  CXType_Attributed = 163,\n\n  CXType_OCLIntelSubgroupAVCMcePayload = 164,\n  CXType_OCLIntelSubgroupAVCImePayload = 165,\n  CXType_OCLIntelSubgroupAVCRefPayload = 166,\n  CXType_OCLIntelSubgroupAVCSicPayload = 167,\n  CXType_OCLIntelSubgroupAVCMceResult = 168,\n  CXType_OCLIntelSubgroupAVCImeResult = 169,\n  CXType_OCLIntelSubgroupAVCRefResult = 170,\n  CXType_OCLIntelSubgroupAVCSicResult = 171,\n  CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout = 172,\n  CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout = 173,\n  CXType_OCLIntelSubgroupAVCImeSingleRefStreamin = 174,\n\n  CXType_OCLIntelSubgroupAVCImeDualRefStreamin = 175,\n\n  CXType_ExtVector = 176,\n  CXType_Atomic = 177\n};\n\n/**\n * Describes the calling convention of a function type\n */\nenum CXCallingConv {\n  CXCallingConv_Default = 0,\n  CXCallingConv_C = 1,\n  CXCallingConv_X86StdCall = 2,\n  CXCallingConv_X86FastCall = 3,\n  CXCallingConv_X86ThisCall = 4,\n  CXCallingConv_X86Pascal = 5,\n  CXCallingConv_AAPCS = 6,\n  CXCallingConv_AAPCS_VFP = 7,\n  CXCallingConv_X86RegCall = 8,\n  CXCallingConv_IntelOclBicc = 9,\n  CXCallingConv_Win64 = 10,\n  /* Alias for compatibility with older versions of API. */\n  CXCallingConv_X86_64Win64 = CXCallingConv_Win64,\n  CXCallingConv_X86_64SysV = 11,\n  CXCallingConv_X86VectorCall = 12,\n  CXCallingConv_Swift = 13,\n  CXCallingConv_PreserveMost = 14,\n  CXCallingConv_PreserveAll = 15,\n  CXCallingConv_AArch64VectorCall = 16,\n\n  CXCallingConv_Invalid = 100,\n  CXCallingConv_Unexposed = 200\n};\n\n/**\n * The type of an element in the abstract syntax tree.\n *\n */\ntypedef struct {\n  enum CXTypeKind kind;\n  void *data[2];\n} CXType;\n\n/**\n * Retrieve the type of a CXCursor (if any).\n */\nCINDEX_LINKAGE CXType clang_getCursorType(CXCursor C);\n\n/**\n * Pretty-print the underlying type using the rules of the\n * language of the translation unit from which it came.\n *\n * If the type is invalid, an empty string is returned.\n */\nCINDEX_LINKAGE CXString clang_getTypeSpelling(CXType CT);\n\n/**\n * Retrieve the underlying type of a typedef declaration.\n *\n * If the cursor does not reference a typedef declaration, an invalid type is\n * returned.\n */\nCINDEX_LINKAGE CXType clang_getTypedefDeclUnderlyingType(CXCursor C);\n\n/**\n * Retrieve the integer type of an enum declaration.\n *\n * If the cursor does not reference an enum declaration, an invalid type is\n * returned.\n */\nCINDEX_LINKAGE CXType clang_getEnumDeclIntegerType(CXCursor C);\n\n/**\n * Retrieve the integer value of an enum constant declaration as a signed\n *  long long.\n *\n * If the cursor does not reference an enum constant declaration, LLONG_MIN is\n * returned. Since this is also potentially a valid constant value, the kind of\n * the cursor must be verified before calling this function.\n */\nCINDEX_LINKAGE long long clang_getEnumConstantDeclValue(CXCursor C);\n\n/**\n * Retrieve the integer value of an enum constant declaration as an unsigned\n *  long long.\n *\n * If the cursor does not reference an enum constant declaration, ULLONG_MAX is\n * returned. Since this is also potentially a valid constant value, the kind of\n * the cursor must be verified before calling this function.\n */\nCINDEX_LINKAGE unsigned long long\nclang_getEnumConstantDeclUnsignedValue(CXCursor C);\n\n/**\n * Retrieve the bit width of a bit field declaration as an integer.\n *\n * If a cursor that is not a bit field declaration is passed in, -1 is returned.\n */\nCINDEX_LINKAGE int clang_getFieldDeclBitWidth(CXCursor C);\n\n/**\n * Retrieve the number of non-variadic arguments associated with a given\n * cursor.\n *\n * The number of arguments can be determined for calls as well as for\n * declarations of functions or methods. For other cursors -1 is returned.\n */\nCINDEX_LINKAGE int clang_Cursor_getNumArguments(CXCursor C);\n\n/**\n * Retrieve the argument cursor of a function or method.\n *\n * The argument cursor can be determined for calls as well as for declarations\n * of functions or methods. For other cursors and for invalid indices, an\n * invalid cursor is returned.\n */\nCINDEX_LINKAGE CXCursor clang_Cursor_getArgument(CXCursor C, unsigned i);\n\n/**\n * Describes the kind of a template argument.\n *\n * See the definition of llvm::clang::TemplateArgument::ArgKind for full\n * element descriptions.\n */\nenum CXTemplateArgumentKind {\n  CXTemplateArgumentKind_Null,\n  CXTemplateArgumentKind_Type,\n  CXTemplateArgumentKind_Declaration,\n  CXTemplateArgumentKind_NullPtr,\n  CXTemplateArgumentKind_Integral,\n  CXTemplateArgumentKind_Template,\n  CXTemplateArgumentKind_TemplateExpansion,\n  CXTemplateArgumentKind_Expression,\n  CXTemplateArgumentKind_Pack,\n  /* Indicates an error case, preventing the kind from being deduced. */\n  CXTemplateArgumentKind_Invalid\n};\n\n/**\n *Returns the number of template args of a function decl representing a\n * template specialization.\n *\n * If the argument cursor cannot be converted into a template function\n * declaration, -1 is returned.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * The value 3 would be returned from this call.\n */\nCINDEX_LINKAGE int clang_Cursor_getNumTemplateArguments(CXCursor C);\n\n/**\n * Retrieve the kind of the I'th template argument of the CXCursor C.\n *\n * If the argument CXCursor does not represent a FunctionDecl, an invalid\n * template argument kind is returned.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * For I = 0, 1, and 2, Type, Integral, and Integral will be returned,\n * respectively.\n */\nCINDEX_LINKAGE enum CXTemplateArgumentKind\nclang_Cursor_getTemplateArgumentKind(CXCursor C, unsigned I);\n\n/**\n * Retrieve a CXType representing the type of a TemplateArgument of a\n *  function decl representing a template specialization.\n *\n * If the argument CXCursor does not represent a FunctionDecl whose I'th\n * template argument has a kind of CXTemplateArgKind_Integral, an invalid type\n * is returned.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * If called with I = 0, \"float\", will be returned.\n * Invalid types will be returned for I == 1 or 2.\n */\nCINDEX_LINKAGE CXType clang_Cursor_getTemplateArgumentType(CXCursor C,\n                                                           unsigned I);\n\n/**\n * Retrieve the value of an Integral TemplateArgument (of a function\n *  decl representing a template specialization) as a signed long long.\n *\n * It is undefined to call this function on a CXCursor that does not represent a\n * FunctionDecl or whose I'th template argument is not an integral value.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * If called with I = 1 or 2, -7 or true will be returned, respectively.\n * For I == 0, this function's behavior is undefined.\n */\nCINDEX_LINKAGE long long clang_Cursor_getTemplateArgumentValue(CXCursor C,\n                                                               unsigned I);\n\n/**\n * Retrieve the value of an Integral TemplateArgument (of a function\n *  decl representing a template specialization) as an unsigned long long.\n *\n * It is undefined to call this function on a CXCursor that does not represent a\n * FunctionDecl or whose I'th template argument is not an integral value.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, 2147483649, true>();\n *\n * If called with I = 1 or 2, 2147483649 or true will be returned, respectively.\n * For I == 0, this function's behavior is undefined.\n */\nCINDEX_LINKAGE unsigned long long\nclang_Cursor_getTemplateArgumentUnsignedValue(CXCursor C, unsigned I);\n\n/**\n * Determine whether two CXTypes represent the same type.\n *\n * \\returns non-zero if the CXTypes represent the same type and\n *          zero otherwise.\n */\nCINDEX_LINKAGE unsigned clang_equalTypes(CXType A, CXType B);\n\n/**\n * Return the canonical type for a CXType.\n *\n * Clang's type system explicitly models typedefs and all the ways\n * a specific type can be represented.  The canonical type is the underlying\n * type with all the \"sugar\" removed.  For example, if 'T' is a typedef\n * for 'int', the canonical type for 'T' would be 'int'.\n */\nCINDEX_LINKAGE CXType clang_getCanonicalType(CXType T);\n\n/**\n * Determine whether a CXType has the \"const\" qualifier set,\n * without looking through typedefs that may have added \"const\" at a\n * different level.\n */\nCINDEX_LINKAGE unsigned clang_isConstQualifiedType(CXType T);\n\n/**\n * Determine whether a  CXCursor that is a macro, is\n * function like.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isMacroFunctionLike(CXCursor C);\n\n/**\n * Determine whether a  CXCursor that is a macro, is a\n * builtin one.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isMacroBuiltin(CXCursor C);\n\n/**\n * Determine whether a  CXCursor that is a function declaration, is an\n * inline declaration.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isFunctionInlined(CXCursor C);\n\n/**\n * Determine whether a CXType has the \"volatile\" qualifier set,\n * without looking through typedefs that may have added \"volatile\" at\n * a different level.\n */\nCINDEX_LINKAGE unsigned clang_isVolatileQualifiedType(CXType T);\n\n/**\n * Determine whether a CXType has the \"restrict\" qualifier set,\n * without looking through typedefs that may have added \"restrict\" at a\n * different level.\n */\nCINDEX_LINKAGE unsigned clang_isRestrictQualifiedType(CXType T);\n\n/**\n * Returns the address space of the given type.\n */\nCINDEX_LINKAGE unsigned clang_getAddressSpace(CXType T);\n\n/**\n * Returns the typedef name of the given type.\n */\nCINDEX_LINKAGE CXString clang_getTypedefName(CXType CT);\n\n/**\n * For pointer types, returns the type of the pointee.\n */\nCINDEX_LINKAGE CXType clang_getPointeeType(CXType T);\n\n/**\n * Return the cursor for the declaration of the given type.\n */\nCINDEX_LINKAGE CXCursor clang_getTypeDeclaration(CXType T);\n\n/**\n * Returns the Objective-C type encoding for the specified declaration.\n */\nCINDEX_LINKAGE CXString clang_getDeclObjCTypeEncoding(CXCursor C);\n\n/**\n * Returns the Objective-C type encoding for the specified CXType.\n */\nCINDEX_LINKAGE CXString clang_Type_getObjCEncoding(CXType type);\n\n/**\n * Retrieve the spelling of a given CXTypeKind.\n */\nCINDEX_LINKAGE CXString clang_getTypeKindSpelling(enum CXTypeKind K);\n\n/**\n * Retrieve the calling convention associated with a function type.\n *\n * If a non-function type is passed in, CXCallingConv_Invalid is returned.\n */\nCINDEX_LINKAGE enum CXCallingConv clang_getFunctionTypeCallingConv(CXType T);\n\n/**\n * Retrieve the return type associated with a function type.\n *\n * If a non-function type is passed in, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_getResultType(CXType T);\n\n/**\n * Retrieve the exception specification type associated with a function type.\n * This is a value of type CXCursor_ExceptionSpecificationKind.\n *\n * If a non-function type is passed in, an error code of -1 is returned.\n */\nCINDEX_LINKAGE int clang_getExceptionSpecificationType(CXType T);\n\n/**\n * Retrieve the number of non-variadic parameters associated with a\n * function type.\n *\n * If a non-function type is passed in, -1 is returned.\n */\nCINDEX_LINKAGE int clang_getNumArgTypes(CXType T);\n\n/**\n * Retrieve the type of a parameter of a function type.\n *\n * If a non-function type is passed in or the function does not have enough\n * parameters, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_getArgType(CXType T, unsigned i);\n\n/**\n * Retrieves the base type of the ObjCObjectType.\n *\n * If the type is not an ObjC object, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getObjCObjectBaseType(CXType T);\n\n/**\n * Retrieve the number of protocol references associated with an ObjC object/id.\n *\n * If the type is not an ObjC object, 0 is returned.\n */\nCINDEX_LINKAGE unsigned clang_Type_getNumObjCProtocolRefs(CXType T);\n\n/**\n * Retrieve the decl for a protocol reference for an ObjC object/id.\n *\n * If the type is not an ObjC object or there are not enough protocol\n * references, an invalid cursor is returned.\n */\nCINDEX_LINKAGE CXCursor clang_Type_getObjCProtocolDecl(CXType T, unsigned i);\n\n/**\n * Retrieve the number of type arguments associated with an ObjC object.\n *\n * If the type is not an ObjC object, 0 is returned.\n */\nCINDEX_LINKAGE unsigned clang_Type_getNumObjCTypeArgs(CXType T);\n\n/**\n * Retrieve a type argument associated with an ObjC object.\n *\n * If the type is not an ObjC or the index is not valid,\n * an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getObjCTypeArg(CXType T, unsigned i);\n\n/**\n * Return 1 if the CXType is a variadic function type, and 0 otherwise.\n */\nCINDEX_LINKAGE unsigned clang_isFunctionTypeVariadic(CXType T);\n\n/**\n * Retrieve the return type associated with a given cursor.\n *\n * This only returns a valid type if the cursor refers to a function or method.\n */\nCINDEX_LINKAGE CXType clang_getCursorResultType(CXCursor C);\n\n/**\n * Retrieve the exception specification type associated with a given cursor.\n * This is a value of type CXCursor_ExceptionSpecificationKind.\n *\n * This only returns a valid result if the cursor refers to a function or\n * method.\n */\nCINDEX_LINKAGE int clang_getCursorExceptionSpecificationType(CXCursor C);\n\n/**\n * Return 1 if the CXType is a POD (plain old data) type, and 0\n *  otherwise.\n */\nCINDEX_LINKAGE unsigned clang_isPODType(CXType T);\n\n/**\n * Return the element type of an array, complex, or vector type.\n *\n * If a type is passed in that is not an array, complex, or vector type,\n * an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_getElementType(CXType T);\n\n/**\n * Return the number of elements of an array or vector type.\n *\n * If a type is passed in that is not an array or vector type,\n * -1 is returned.\n */\nCINDEX_LINKAGE long long clang_getNumElements(CXType T);\n\n/**\n * Return the element type of an array type.\n *\n * If a non-array type is passed in, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_getArrayElementType(CXType T);\n\n/**\n * Return the array size of a constant array.\n *\n * If a non-array type is passed in, -1 is returned.\n */\nCINDEX_LINKAGE long long clang_getArraySize(CXType T);\n\n/**\n * Retrieve the type named by the qualified-id.\n *\n * If a non-elaborated type is passed in, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getNamedType(CXType T);\n\n/**\n * Determine if a typedef is 'transparent' tag.\n *\n * A typedef is considered 'transparent' if it shares a name and spelling\n * location with its underlying tag type, as is the case with the NS_ENUM macro.\n *\n * \\returns non-zero if transparent and zero otherwise.\n */\nCINDEX_LINKAGE unsigned clang_Type_isTransparentTagTypedef(CXType T);\n\nenum CXTypeNullabilityKind {\n  /**\n   * Values of this type can never be null.\n   */\n  CXTypeNullability_NonNull = 0,\n  /**\n   * Values of this type can be null.\n   */\n  CXTypeNullability_Nullable = 1,\n  /**\n   * Whether values of this type can be null is (explicitly)\n   * unspecified. This captures a (fairly rare) case where we\n   * can't conclude anything about the nullability of the type even\n   * though it has been considered.\n   */\n  CXTypeNullability_Unspecified = 2,\n  /**\n   * Nullability is not applicable to this type.\n   */\n  CXTypeNullability_Invalid = 3,\n\n  /**\n   * Generally behaves like Nullable, except when used in a block parameter that\n   * was imported into a swift async method. There, swift will assume that the\n   * parameter can get null even if no error occured. _Nullable parameters are\n   * assumed to only get null on error.\n   */\n  CXTypeNullability_NullableResult = 4\n};\n\n/**\n * Retrieve the nullability kind of a pointer type.\n */\nCINDEX_LINKAGE enum CXTypeNullabilityKind clang_Type_getNullability(CXType T);\n\n/**\n * List the possible error codes for \\c clang_Type_getSizeOf,\n *   \\c clang_Type_getAlignOf, \\c clang_Type_getOffsetOf and\n *   \\c clang_Cursor_getOffsetOf.\n *\n * A value of this enumeration type can be returned if the target type is not\n * a valid argument to sizeof, alignof or offsetof.\n */\nenum CXTypeLayoutError {\n  /**\n   * Type is of kind CXType_Invalid.\n   */\n  CXTypeLayoutError_Invalid = -1,\n  /**\n   * The type is an incomplete Type.\n   */\n  CXTypeLayoutError_Incomplete = -2,\n  /**\n   * The type is a dependent Type.\n   */\n  CXTypeLayoutError_Dependent = -3,\n  /**\n   * The type is not a constant size type.\n   */\n  CXTypeLayoutError_NotConstantSize = -4,\n  /**\n   * The Field name is not valid for this record.\n   */\n  CXTypeLayoutError_InvalidFieldName = -5,\n  /**\n   * The type is undeduced.\n   */\n  CXTypeLayoutError_Undeduced = -6\n};\n\n/**\n * Return the alignment of a type in bytes as per C++[expr.alignof]\n *   standard.\n *\n * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.\n * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete\n *   is returned.\n * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is\n *   returned.\n * If the type declaration is not a constant size type,\n *   CXTypeLayoutError_NotConstantSize is returned.\n */\nCINDEX_LINKAGE long long clang_Type_getAlignOf(CXType T);\n\n/**\n * Return the class type of an member pointer type.\n *\n * If a non-member-pointer type is passed in, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getClassType(CXType T);\n\n/**\n * Return the size of a type in bytes as per C++[expr.sizeof] standard.\n *\n * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.\n * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete\n *   is returned.\n * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is\n *   returned.\n */\nCINDEX_LINKAGE long long clang_Type_getSizeOf(CXType T);\n\n/**\n * Return the offset of a field named S in a record of type T in bits\n *   as it would be returned by __offsetof__ as per C++11[18.2p4]\n *\n * If the cursor is not a record field declaration, CXTypeLayoutError_Invalid\n *   is returned.\n * If the field's type declaration is an incomplete type,\n *   CXTypeLayoutError_Incomplete is returned.\n * If the field's type declaration is a dependent type,\n *   CXTypeLayoutError_Dependent is returned.\n * If the field's name S is not found,\n *   CXTypeLayoutError_InvalidFieldName is returned.\n */\nCINDEX_LINKAGE long long clang_Type_getOffsetOf(CXType T, const char *S);\n\n/**\n * Return the type that was modified by this attributed type.\n *\n * If the type is not an attributed type, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getModifiedType(CXType T);\n\n/**\n * Gets the type contained by this atomic type.\n *\n * If a non-atomic type is passed in, an invalid type is returned.\n */\nCINDEX_LINKAGE CXType clang_Type_getValueType(CXType CT);\n\n/**\n * Return the offset of the field represented by the Cursor.\n *\n * If the cursor is not a field declaration, -1 is returned.\n * If the cursor semantic parent is not a record field declaration,\n *   CXTypeLayoutError_Invalid is returned.\n * If the field's type declaration is an incomplete type,\n *   CXTypeLayoutError_Incomplete is returned.\n * If the field's type declaration is a dependent type,\n *   CXTypeLayoutError_Dependent is returned.\n * If the field's name S is not found,\n *   CXTypeLayoutError_InvalidFieldName is returned.\n */\nCINDEX_LINKAGE long long clang_Cursor_getOffsetOfField(CXCursor C);\n\n/**\n * Determine whether the given cursor represents an anonymous\n * tag or namespace\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isAnonymous(CXCursor C);\n\n/**\n * Determine whether the given cursor represents an anonymous record\n * declaration.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isAnonymousRecordDecl(CXCursor C);\n\n/**\n * Determine whether the given cursor represents an inline namespace\n * declaration.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isInlineNamespace(CXCursor C);\n\nenum CXRefQualifierKind {\n  /** No ref-qualifier was provided. */\n  CXRefQualifier_None = 0,\n  /** An lvalue ref-qualifier was provided (\\c &). */\n  CXRefQualifier_LValue,\n  /** An rvalue ref-qualifier was provided (\\c &&). */\n  CXRefQualifier_RValue\n};\n\n/**\n * Returns the number of template arguments for given template\n * specialization, or -1 if type \\c T is not a template specialization.\n */\nCINDEX_LINKAGE int clang_Type_getNumTemplateArguments(CXType T);\n\n/**\n * Returns the type template argument of a template class specialization\n * at given index.\n *\n * This function only returns template type arguments and does not handle\n * template template arguments or variadic packs.\n */\nCINDEX_LINKAGE CXType clang_Type_getTemplateArgumentAsType(CXType T,\n                                                           unsigned i);\n\n/**\n * Retrieve the ref-qualifier kind of a function or method.\n *\n * The ref-qualifier is returned for C++ functions or methods. For other types\n * or non-C++ declarations, CXRefQualifier_None is returned.\n */\nCINDEX_LINKAGE enum CXRefQualifierKind clang_Type_getCXXRefQualifier(CXType T);\n\n/**\n * Returns non-zero if the cursor specifies a Record member that is a\n *   bitfield.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isBitField(CXCursor C);\n\n/**\n * Returns 1 if the base class specified by the cursor with kind\n *   CX_CXXBaseSpecifier is virtual.\n */\nCINDEX_LINKAGE unsigned clang_isVirtualBase(CXCursor);\n\n/**\n * Represents the C++ access control level to a base class for a\n * cursor with kind CX_CXXBaseSpecifier.\n */\nenum CX_CXXAccessSpecifier {\n  CX_CXXInvalidAccessSpecifier,\n  CX_CXXPublic,\n  CX_CXXProtected,\n  CX_CXXPrivate\n};\n\n/**\n * Returns the access control level for the referenced object.\n *\n * If the cursor refers to a C++ declaration, its access control level within\n * its parent scope is returned. Otherwise, if the cursor refers to a base\n * specifier or access specifier, the specifier itself is returned.\n */\nCINDEX_LINKAGE enum CX_CXXAccessSpecifier clang_getCXXAccessSpecifier(CXCursor);\n\n/**\n * Represents the storage classes as declared in the source. CX_SC_Invalid\n * was added for the case that the passed cursor in not a declaration.\n */\nenum CX_StorageClass {\n  CX_SC_Invalid,\n  CX_SC_None,\n  CX_SC_Extern,\n  CX_SC_Static,\n  CX_SC_PrivateExtern,\n  CX_SC_OpenCLWorkGroupLocal,\n  CX_SC_Auto,\n  CX_SC_Register\n};\n\n/**\n * Returns the storage class for a function or variable declaration.\n *\n * If the passed in Cursor is not a function or variable declaration,\n * CX_SC_Invalid is returned else the storage class.\n */\nCINDEX_LINKAGE enum CX_StorageClass clang_Cursor_getStorageClass(CXCursor);\n\n/**\n * Determine the number of overloaded declarations referenced by a\n * \\c CXCursor_OverloadedDeclRef cursor.\n *\n * \\param cursor The cursor whose overloaded declarations are being queried.\n *\n * \\returns The number of overloaded declarations referenced by \\c cursor. If it\n * is not a \\c CXCursor_OverloadedDeclRef cursor, returns 0.\n */\nCINDEX_LINKAGE unsigned clang_getNumOverloadedDecls(CXCursor cursor);\n\n/**\n * Retrieve a cursor for one of the overloaded declarations referenced\n * by a \\c CXCursor_OverloadedDeclRef cursor.\n *\n * \\param cursor The cursor whose overloaded declarations are being queried.\n *\n * \\param index The zero-based index into the set of overloaded declarations in\n * the cursor.\n *\n * \\returns A cursor representing the declaration referenced by the given\n * \\c cursor at the specified \\c index. If the cursor does not have an\n * associated set of overloaded declarations, or if the index is out of bounds,\n * returns \\c clang_getNullCursor();\n */\nCINDEX_LINKAGE CXCursor clang_getOverloadedDecl(CXCursor cursor,\n                                                unsigned index);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_ATTRIBUTES Information for attributes\n *\n * @{\n */\n\n/**\n * For cursors representing an iboutletcollection attribute,\n *  this function returns the collection element type.\n *\n */\nCINDEX_LINKAGE CXType clang_getIBOutletCollectionType(CXCursor);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_CURSOR_TRAVERSAL Traversing the AST with cursors\n *\n * These routines provide the ability to traverse the abstract syntax tree\n * using cursors.\n *\n * @{\n */\n\n/**\n * Describes how the traversal of the children of a particular\n * cursor should proceed after visiting a particular child cursor.\n *\n * A value of this enumeration type should be returned by each\n * \\c CXCursorVisitor to indicate how clang_visitChildren() proceed.\n */\nenum CXChildVisitResult {\n  /**\n   * Terminates the cursor traversal.\n   */\n  CXChildVisit_Break,\n  /**\n   * Continues the cursor traversal with the next sibling of\n   * the cursor just visited, without visiting its children.\n   */\n  CXChildVisit_Continue,\n  /**\n   * Recursively traverse the children of this cursor, using\n   * the same visitor and client data.\n   */\n  CXChildVisit_Recurse\n};\n\n/**\n * Visitor invoked for each cursor found by a traversal.\n *\n * This visitor function will be invoked for each cursor found by\n * clang_visitCursorChildren(). Its first argument is the cursor being\n * visited, its second argument is the parent visitor for that cursor,\n * and its third argument is the client data provided to\n * clang_visitCursorChildren().\n *\n * The visitor should return one of the \\c CXChildVisitResult values\n * to direct clang_visitCursorChildren().\n */\ntypedef enum CXChildVisitResult (*CXCursorVisitor)(CXCursor cursor,\n                                                   CXCursor parent,\n                                                   CXClientData client_data);\n\n/**\n * Visit the children of a particular cursor.\n *\n * This function visits all the direct children of the given cursor,\n * invoking the given \\p visitor function with the cursors of each\n * visited child. The traversal may be recursive, if the visitor returns\n * \\c CXChildVisit_Recurse. The traversal may also be ended prematurely, if\n * the visitor returns \\c CXChildVisit_Break.\n *\n * \\param parent the cursor whose child may be visited. All kinds of\n * cursors can be visited, including invalid cursors (which, by\n * definition, have no children).\n *\n * \\param visitor the visitor function that will be invoked for each\n * child of \\p parent.\n *\n * \\param client_data pointer data supplied by the client, which will\n * be passed to the visitor each time it is invoked.\n *\n * \\returns a non-zero value if the traversal was terminated\n * prematurely by the visitor returning \\c CXChildVisit_Break.\n */\nCINDEX_LINKAGE unsigned clang_visitChildren(CXCursor parent,\n                                            CXCursorVisitor visitor,\n                                            CXClientData client_data);\n#ifdef __has_feature\n#if __has_feature(blocks)\n/**\n * Visitor invoked for each cursor found by a traversal.\n *\n * This visitor block will be invoked for each cursor found by\n * clang_visitChildrenWithBlock(). Its first argument is the cursor being\n * visited, its second argument is the parent visitor for that cursor.\n *\n * The visitor should return one of the \\c CXChildVisitResult values\n * to direct clang_visitChildrenWithBlock().\n */\ntypedef enum CXChildVisitResult (^CXCursorVisitorBlock)(CXCursor cursor,\n                                                        CXCursor parent);\n\n/**\n * Visits the children of a cursor using the specified block.  Behaves\n * identically to clang_visitChildren() in all other respects.\n */\nCINDEX_LINKAGE unsigned\nclang_visitChildrenWithBlock(CXCursor parent, CXCursorVisitorBlock block);\n#endif\n#endif\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_CURSOR_XREF Cross-referencing in the AST\n *\n * These routines provide the ability to determine references within and\n * across translation units, by providing the names of the entities referenced\n * by cursors, follow reference cursors to the declarations they reference,\n * and associate declarations with their definitions.\n *\n * @{\n */\n\n/**\n * Retrieve a Unified Symbol Resolution (USR) for the entity referenced\n * by the given cursor.\n *\n * A Unified Symbol Resolution (USR) is a string that identifies a particular\n * entity (function, class, variable, etc.) within a program. USRs can be\n * compared across translation units to determine, e.g., when references in\n * one translation refer to an entity defined in another translation unit.\n */\nCINDEX_LINKAGE CXString clang_getCursorUSR(CXCursor);\n\n/**\n * Construct a USR for a specified Objective-C class.\n */\nCINDEX_LINKAGE CXString clang_constructUSR_ObjCClass(const char *class_name);\n\n/**\n * Construct a USR for a specified Objective-C category.\n */\nCINDEX_LINKAGE CXString clang_constructUSR_ObjCCategory(\n    const char *class_name, const char *category_name);\n\n/**\n * Construct a USR for a specified Objective-C protocol.\n */\nCINDEX_LINKAGE CXString\nclang_constructUSR_ObjCProtocol(const char *protocol_name);\n\n/**\n * Construct a USR for a specified Objective-C instance variable and\n *   the USR for its containing class.\n */\nCINDEX_LINKAGE CXString clang_constructUSR_ObjCIvar(const char *name,\n                                                    CXString classUSR);\n\n/**\n * Construct a USR for a specified Objective-C method and\n *   the USR for its containing class.\n */\nCINDEX_LINKAGE CXString clang_constructUSR_ObjCMethod(const char *name,\n                                                      unsigned isInstanceMethod,\n                                                      CXString classUSR);\n\n/**\n * Construct a USR for a specified Objective-C property and the USR\n *  for its containing class.\n */\nCINDEX_LINKAGE CXString clang_constructUSR_ObjCProperty(const char *property,\n                                                        CXString classUSR);\n\n/**\n * Retrieve a name for the entity referenced by this cursor.\n */\nCINDEX_LINKAGE CXString clang_getCursorSpelling(CXCursor);\n\n/**\n * Retrieve a range for a piece that forms the cursors spelling name.\n * Most of the times there is only one range for the complete spelling but for\n * Objective-C methods and Objective-C message expressions, there are multiple\n * pieces for each selector identifier.\n *\n * \\param pieceIndex the index of the spelling name piece. If this is greater\n * than the actual number of pieces, it will return a NULL (invalid) range.\n *\n * \\param options Reserved.\n */\nCINDEX_LINKAGE CXSourceRange clang_Cursor_getSpellingNameRange(\n    CXCursor, unsigned pieceIndex, unsigned options);\n\n/**\n * Opaque pointer representing a policy that controls pretty printing\n * for \\c clang_getCursorPrettyPrinted.\n */\ntypedef void *CXPrintingPolicy;\n\n/**\n * Properties for the printing policy.\n *\n * See \\c clang::PrintingPolicy for more information.\n */\nenum CXPrintingPolicyProperty {\n  CXPrintingPolicy_Indentation,\n  CXPrintingPolicy_SuppressSpecifiers,\n  CXPrintingPolicy_SuppressTagKeyword,\n  CXPrintingPolicy_IncludeTagDefinition,\n  CXPrintingPolicy_SuppressScope,\n  CXPrintingPolicy_SuppressUnwrittenScope,\n  CXPrintingPolicy_SuppressInitializers,\n  CXPrintingPolicy_ConstantArraySizeAsWritten,\n  CXPrintingPolicy_AnonymousTagLocations,\n  CXPrintingPolicy_SuppressStrongLifetime,\n  CXPrintingPolicy_SuppressLifetimeQualifiers,\n  CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors,\n  CXPrintingPolicy_Bool,\n  CXPrintingPolicy_Restrict,\n  CXPrintingPolicy_Alignof,\n  CXPrintingPolicy_UnderscoreAlignof,\n  CXPrintingPolicy_UseVoidForZeroParams,\n  CXPrintingPolicy_TerseOutput,\n  CXPrintingPolicy_PolishForDeclaration,\n  CXPrintingPolicy_Half,\n  CXPrintingPolicy_MSWChar,\n  CXPrintingPolicy_IncludeNewlines,\n  CXPrintingPolicy_MSVCFormatting,\n  CXPrintingPolicy_ConstantsAsWritten,\n  CXPrintingPolicy_SuppressImplicitBase,\n  CXPrintingPolicy_FullyQualifiedName,\n\n  CXPrintingPolicy_LastProperty = CXPrintingPolicy_FullyQualifiedName\n};\n\n/**\n * Get a property value for the given printing policy.\n */\nCINDEX_LINKAGE unsigned\nclang_PrintingPolicy_getProperty(CXPrintingPolicy Policy,\n                                 enum CXPrintingPolicyProperty Property);\n\n/**\n * Set a property value for the given printing policy.\n */\nCINDEX_LINKAGE void\nclang_PrintingPolicy_setProperty(CXPrintingPolicy Policy,\n                                 enum CXPrintingPolicyProperty Property,\n                                 unsigned Value);\n\n/**\n * Retrieve the default policy for the cursor.\n *\n * The policy should be released after use with \\c\n * clang_PrintingPolicy_dispose.\n */\nCINDEX_LINKAGE CXPrintingPolicy clang_getCursorPrintingPolicy(CXCursor);\n\n/**\n * Release a printing policy.\n */\nCINDEX_LINKAGE void clang_PrintingPolicy_dispose(CXPrintingPolicy Policy);\n\n/**\n * Pretty print declarations.\n *\n * \\param Cursor The cursor representing a declaration.\n *\n * \\param Policy The policy to control the entities being printed. If\n * NULL, a default policy is used.\n *\n * \\returns The pretty printed declaration or the empty string for\n * other cursors.\n */\nCINDEX_LINKAGE CXString clang_getCursorPrettyPrinted(CXCursor Cursor,\n                                                     CXPrintingPolicy Policy);\n\n/**\n * Retrieve the display name for the entity referenced by this cursor.\n *\n * The display name contains extra information that helps identify the cursor,\n * such as the parameters of a function or template or the arguments of a\n * class template specialization.\n */\nCINDEX_LINKAGE CXString clang_getCursorDisplayName(CXCursor);\n\n/** For a cursor that is a reference, retrieve a cursor representing the\n * entity that it references.\n *\n * Reference cursors refer to other entities in the AST. For example, an\n * Objective-C superclass reference cursor refers to an Objective-C class.\n * This function produces the cursor for the Objective-C class from the\n * cursor for the superclass reference. If the input cursor is a declaration or\n * definition, it returns that declaration or definition unchanged.\n * Otherwise, returns the NULL cursor.\n */\nCINDEX_LINKAGE CXCursor clang_getCursorReferenced(CXCursor);\n\n/**\n *  For a cursor that is either a reference to or a declaration\n *  of some entity, retrieve a cursor that describes the definition of\n *  that entity.\n *\n *  Some entities can be declared multiple times within a translation\n *  unit, but only one of those declarations can also be a\n *  definition. For example, given:\n *\n *  \\code\n *  int f(int, int);\n *  int g(int x, int y) { return f(x, y); }\n *  int f(int a, int b) { return a + b; }\n *  int f(int, int);\n *  \\endcode\n *\n *  there are three declarations of the function \"f\", but only the\n *  second one is a definition. The clang_getCursorDefinition()\n *  function will take any cursor pointing to a declaration of \"f\"\n *  (the first or fourth lines of the example) or a cursor referenced\n *  that uses \"f\" (the call to \"f' inside \"g\") and will return a\n *  declaration cursor pointing to the definition (the second \"f\"\n *  declaration).\n *\n *  If given a cursor for which there is no corresponding definition,\n *  e.g., because there is no definition of that entity within this\n *  translation unit, returns a NULL cursor.\n */\nCINDEX_LINKAGE CXCursor clang_getCursorDefinition(CXCursor);\n\n/**\n * Determine whether the declaration pointed to by this cursor\n * is also a definition of that entity.\n */\nCINDEX_LINKAGE unsigned clang_isCursorDefinition(CXCursor);\n\n/**\n * Retrieve the canonical cursor corresponding to the given cursor.\n *\n * In the C family of languages, many kinds of entities can be declared several\n * times within a single translation unit. For example, a structure type can\n * be forward-declared (possibly multiple times) and later defined:\n *\n * \\code\n * struct X;\n * struct X;\n * struct X {\n *   int member;\n * };\n * \\endcode\n *\n * The declarations and the definition of \\c X are represented by three\n * different cursors, all of which are declarations of the same underlying\n * entity. One of these cursor is considered the \"canonical\" cursor, which\n * is effectively the representative for the underlying entity. One can\n * determine if two cursors are declarations of the same underlying entity by\n * comparing their canonical cursors.\n *\n * \\returns The canonical cursor for the entity referred to by the given cursor.\n */\nCINDEX_LINKAGE CXCursor clang_getCanonicalCursor(CXCursor);\n\n/**\n * If the cursor points to a selector identifier in an Objective-C\n * method or message expression, this returns the selector index.\n *\n * After getting a cursor with #clang_getCursor, this can be called to\n * determine if the location points to a selector identifier.\n *\n * \\returns The selector index if the cursor is an Objective-C method or message\n * expression and the cursor is pointing to a selector identifier, or -1\n * otherwise.\n */\nCINDEX_LINKAGE int clang_Cursor_getObjCSelectorIndex(CXCursor);\n\n/**\n * Given a cursor pointing to a C++ method call or an Objective-C\n * message, returns non-zero if the method/message is \"dynamic\", meaning:\n *\n * For a C++ method: the call is virtual.\n * For an Objective-C message: the receiver is an object instance, not 'super'\n * or a specific class.\n *\n * If the method/message is \"static\" or the cursor does not point to a\n * method/message, it will return zero.\n */\nCINDEX_LINKAGE int clang_Cursor_isDynamicCall(CXCursor C);\n\n/**\n * Given a cursor pointing to an Objective-C message or property\n * reference, or C++ method call, returns the CXType of the receiver.\n */\nCINDEX_LINKAGE CXType clang_Cursor_getReceiverType(CXCursor C);\n\n/**\n * Property attributes for a \\c CXCursor_ObjCPropertyDecl.\n */\ntypedef enum {\n  CXObjCPropertyAttr_noattr = 0x00,\n  CXObjCPropertyAttr_readonly = 0x01,\n  CXObjCPropertyAttr_getter = 0x02,\n  CXObjCPropertyAttr_assign = 0x04,\n  CXObjCPropertyAttr_readwrite = 0x08,\n  CXObjCPropertyAttr_retain = 0x10,\n  CXObjCPropertyAttr_copy = 0x20,\n  CXObjCPropertyAttr_nonatomic = 0x40,\n  CXObjCPropertyAttr_setter = 0x80,\n  CXObjCPropertyAttr_atomic = 0x100,\n  CXObjCPropertyAttr_weak = 0x200,\n  CXObjCPropertyAttr_strong = 0x400,\n  CXObjCPropertyAttr_unsafe_unretained = 0x800,\n  CXObjCPropertyAttr_class = 0x1000\n} CXObjCPropertyAttrKind;\n\n/**\n * Given a cursor that represents a property declaration, return the\n * associated property attributes. The bits are formed from\n * \\c CXObjCPropertyAttrKind.\n *\n * \\param reserved Reserved for future use, pass 0.\n */\nCINDEX_LINKAGE unsigned\nclang_Cursor_getObjCPropertyAttributes(CXCursor C, unsigned reserved);\n\n/**\n * Given a cursor that represents a property declaration, return the\n * name of the method that implements the getter.\n */\nCINDEX_LINKAGE CXString clang_Cursor_getObjCPropertyGetterName(CXCursor C);\n\n/**\n * Given a cursor that represents a property declaration, return the\n * name of the method that implements the setter, if any.\n */\nCINDEX_LINKAGE CXString clang_Cursor_getObjCPropertySetterName(CXCursor C);\n\n/**\n * 'Qualifiers' written next to the return and parameter types in\n * Objective-C method declarations.\n */\ntypedef enum {\n  CXObjCDeclQualifier_None = 0x0,\n  CXObjCDeclQualifier_In = 0x1,\n  CXObjCDeclQualifier_Inout = 0x2,\n  CXObjCDeclQualifier_Out = 0x4,\n  CXObjCDeclQualifier_Bycopy = 0x8,\n  CXObjCDeclQualifier_Byref = 0x10,\n  CXObjCDeclQualifier_Oneway = 0x20\n} CXObjCDeclQualifierKind;\n\n/**\n * Given a cursor that represents an Objective-C method or parameter\n * declaration, return the associated Objective-C qualifiers for the return\n * type or the parameter respectively. The bits are formed from\n * CXObjCDeclQualifierKind.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_getObjCDeclQualifiers(CXCursor C);\n\n/**\n * Given a cursor that represents an Objective-C method or property\n * declaration, return non-zero if the declaration was affected by \"\\@optional\".\n * Returns zero if the cursor is not such a declaration or it is \"\\@required\".\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isObjCOptional(CXCursor C);\n\n/**\n * Returns non-zero if the given cursor is a variadic function or method.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isVariadic(CXCursor C);\n\n/**\n * Returns non-zero if the given cursor points to a symbol marked with\n * external_source_symbol attribute.\n *\n * \\param language If non-NULL, and the attribute is present, will be set to\n * the 'language' string from the attribute.\n *\n * \\param definedIn If non-NULL, and the attribute is present, will be set to\n * the 'definedIn' string from the attribute.\n *\n * \\param isGenerated If non-NULL, and the attribute is present, will be set to\n * non-zero if the 'generated_declaration' is set in the attribute.\n */\nCINDEX_LINKAGE unsigned clang_Cursor_isExternalSymbol(CXCursor C,\n                                                      CXString *language,\n                                                      CXString *definedIn,\n                                                      unsigned *isGenerated);\n\n/**\n * Given a cursor that represents a declaration, return the associated\n * comment's source range.  The range may include multiple consecutive comments\n * with whitespace in between.\n */\nCINDEX_LINKAGE CXSourceRange clang_Cursor_getCommentRange(CXCursor C);\n\n/**\n * Given a cursor that represents a declaration, return the associated\n * comment text, including comment markers.\n */\nCINDEX_LINKAGE CXString clang_Cursor_getRawCommentText(CXCursor C);\n\n/**\n * Given a cursor that represents a documentable entity (e.g.,\n * declaration), return the associated \\paragraph; otherwise return the\n * first paragraph.\n */\nCINDEX_LINKAGE CXString clang_Cursor_getBriefCommentText(CXCursor C);\n\n/**\n * @}\n */\n\n/** \\defgroup CINDEX_MANGLE Name Mangling API Functions\n *\n * @{\n */\n\n/**\n * Retrieve the CXString representing the mangled name of the cursor.\n */\nCINDEX_LINKAGE CXString clang_Cursor_getMangling(CXCursor);\n\n/**\n * Retrieve the CXStrings representing the mangled symbols of the C++\n * constructor or destructor at the cursor.\n */\nCINDEX_LINKAGE CXStringSet *clang_Cursor_getCXXManglings(CXCursor);\n\n/**\n * Retrieve the CXStrings representing the mangled symbols of the ObjC\n * class interface or implementation at the cursor.\n */\nCINDEX_LINKAGE CXStringSet *clang_Cursor_getObjCManglings(CXCursor);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_MODULE Module introspection\n *\n * The functions in this group provide access to information about modules.\n *\n * @{\n */\n\ntypedef void *CXModule;\n\n/**\n * Given a CXCursor_ModuleImportDecl cursor, return the associated module.\n */\nCINDEX_LINKAGE CXModule clang_Cursor_getModule(CXCursor C);\n\n/**\n * Given a CXFile header file, return the module that contains it, if one\n * exists.\n */\nCINDEX_LINKAGE CXModule clang_getModuleForFile(CXTranslationUnit, CXFile);\n\n/**\n * \\param Module a module object.\n *\n * \\returns the module file where the provided module object came from.\n */\nCINDEX_LINKAGE CXFile clang_Module_getASTFile(CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\returns the parent of a sub-module or NULL if the given module is top-level,\n * e.g. for 'std.vector' it will return the 'std' module.\n */\nCINDEX_LINKAGE CXModule clang_Module_getParent(CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\returns the name of the module, e.g. for the 'std.vector' sub-module it\n * will return \"vector\".\n */\nCINDEX_LINKAGE CXString clang_Module_getName(CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\returns the full name of the module, e.g. \"std.vector\".\n */\nCINDEX_LINKAGE CXString clang_Module_getFullName(CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\returns non-zero if the module is a system one.\n */\nCINDEX_LINKAGE int clang_Module_isSystem(CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\returns the number of top level headers associated with this module.\n */\nCINDEX_LINKAGE unsigned clang_Module_getNumTopLevelHeaders(CXTranslationUnit,\n                                                           CXModule Module);\n\n/**\n * \\param Module a module object.\n *\n * \\param Index top level header index (zero-based).\n *\n * \\returns the specified top level header associated with the module.\n */\nCINDEX_LINKAGE\nCXFile clang_Module_getTopLevelHeader(CXTranslationUnit, CXModule Module,\n                                      unsigned Index);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_CPP C++ AST introspection\n *\n * The routines in this group provide access information in the ASTs specific\n * to C++ language features.\n *\n * @{\n */\n\n/**\n * Determine if a C++ constructor is a converting constructor.\n */\nCINDEX_LINKAGE unsigned\nclang_CXXConstructor_isConvertingConstructor(CXCursor C);\n\n/**\n * Determine if a C++ constructor is a copy constructor.\n */\nCINDEX_LINKAGE unsigned clang_CXXConstructor_isCopyConstructor(CXCursor C);\n\n/**\n * Determine if a C++ constructor is the default constructor.\n */\nCINDEX_LINKAGE unsigned clang_CXXConstructor_isDefaultConstructor(CXCursor C);\n\n/**\n * Determine if a C++ constructor is a move constructor.\n */\nCINDEX_LINKAGE unsigned clang_CXXConstructor_isMoveConstructor(CXCursor C);\n\n/**\n * Determine if a C++ field is declared 'mutable'.\n */\nCINDEX_LINKAGE unsigned clang_CXXField_isMutable(CXCursor C);\n\n/**\n * Determine if a C++ method is declared '= default'.\n */\nCINDEX_LINKAGE unsigned clang_CXXMethod_isDefaulted(CXCursor C);\n\n/**\n * Determine if a C++ member function or member function template is\n * pure virtual.\n */\nCINDEX_LINKAGE unsigned clang_CXXMethod_isPureVirtual(CXCursor C);\n\n/**\n * Determine if a C++ member function or member function template is\n * declared 'static'.\n */\nCINDEX_LINKAGE unsigned clang_CXXMethod_isStatic(CXCursor C);\n\n/**\n * Determine if a C++ member function or member function template is\n * explicitly declared 'virtual' or if it overrides a virtual method from\n * one of the base classes.\n */\nCINDEX_LINKAGE unsigned clang_CXXMethod_isVirtual(CXCursor C);\n\n/**\n * Determine if a C++ record is abstract, i.e. whether a class or struct\n * has a pure virtual member function.\n */\nCINDEX_LINKAGE unsigned clang_CXXRecord_isAbstract(CXCursor C);\n\n/**\n * Determine if an enum declaration refers to a scoped enum.\n */\nCINDEX_LINKAGE unsigned clang_EnumDecl_isScoped(CXCursor C);\n\n/**\n * Determine if a C++ member function or member function template is\n * declared 'const'.\n */\nCINDEX_LINKAGE unsigned clang_CXXMethod_isConst(CXCursor C);\n\n/**\n * Given a cursor that represents a template, determine\n * the cursor kind of the specializations would be generated by instantiating\n * the template.\n *\n * This routine can be used to determine what flavor of function template,\n * class template, or class template partial specialization is stored in the\n * cursor. For example, it can describe whether a class template cursor is\n * declared with \"struct\", \"class\" or \"union\".\n *\n * \\param C The cursor to query. This cursor should represent a template\n * declaration.\n *\n * \\returns The cursor kind of the specializations that would be generated\n * by instantiating the template \\p C. If \\p C is not a template, returns\n * \\c CXCursor_NoDeclFound.\n */\nCINDEX_LINKAGE enum CXCursorKind clang_getTemplateCursorKind(CXCursor C);\n\n/**\n * Given a cursor that may represent a specialization or instantiation\n * of a template, retrieve the cursor that represents the template that it\n * specializes or from which it was instantiated.\n *\n * This routine determines the template involved both for explicit\n * specializations of templates and for implicit instantiations of the template,\n * both of which are referred to as \"specializations\". For a class template\n * specialization (e.g., \\c std::vector<bool>), this routine will return\n * either the primary template (\\c std::vector) or, if the specialization was\n * instantiated from a class template partial specialization, the class template\n * partial specialization. For a class template partial specialization and a\n * function template specialization (including instantiations), this\n * this routine will return the specialized template.\n *\n * For members of a class template (e.g., member functions, member classes, or\n * static data members), returns the specialized or instantiated member.\n * Although not strictly \"templates\" in the C++ language, members of class\n * templates have the same notions of specializations and instantiations that\n * templates do, so this routine treats them similarly.\n *\n * \\param C A cursor that may be a specialization of a template or a member\n * of a template.\n *\n * \\returns If the given cursor is a specialization or instantiation of a\n * template or a member thereof, the template or member that it specializes or\n * from which it was instantiated. Otherwise, returns a NULL cursor.\n */\nCINDEX_LINKAGE CXCursor clang_getSpecializedCursorTemplate(CXCursor C);\n\n/**\n * Given a cursor that references something else, return the source range\n * covering that reference.\n *\n * \\param C A cursor pointing to a member reference, a declaration reference, or\n * an operator call.\n * \\param NameFlags A bitset with three independent flags:\n * CXNameRange_WantQualifier, CXNameRange_WantTemplateArgs, and\n * CXNameRange_WantSinglePiece.\n * \\param PieceIndex For contiguous names or when passing the flag\n * CXNameRange_WantSinglePiece, only one piece with index 0 is\n * available. When the CXNameRange_WantSinglePiece flag is not passed for a\n * non-contiguous names, this index can be used to retrieve the individual\n * pieces of the name. See also CXNameRange_WantSinglePiece.\n *\n * \\returns The piece of the name pointed to by the given cursor. If there is no\n * name, or if the PieceIndex is out-of-range, a null-cursor will be returned.\n */\nCINDEX_LINKAGE CXSourceRange clang_getCursorReferenceNameRange(\n    CXCursor C, unsigned NameFlags, unsigned PieceIndex);\n\nenum CXNameRefFlags {\n  /**\n   * Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the\n   * range.\n   */\n  CXNameRange_WantQualifier = 0x1,\n\n  /**\n   * Include the explicit template arguments, e.g. \\<int> in x.f<int>,\n   * in the range.\n   */\n  CXNameRange_WantTemplateArgs = 0x2,\n\n  /**\n   * If the name is non-contiguous, return the full spanning range.\n   *\n   * Non-contiguous names occur in Objective-C when a selector with two or more\n   * parameters is used, or in C++ when using an operator:\n   * \\code\n   * [object doSomething:here withValue:there]; // Objective-C\n   * return some_vector[1]; // C++\n   * \\endcode\n   */\n  CXNameRange_WantSinglePiece = 0x4\n};\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_LEX Token extraction and manipulation\n *\n * The routines in this group provide access to the tokens within a\n * translation unit, along with a semantic mapping of those tokens to\n * their corresponding cursors.\n *\n * @{\n */\n\n/**\n * Describes a kind of token.\n */\ntypedef enum CXTokenKind {\n  /**\n   * A token that contains some kind of punctuation.\n   */\n  CXToken_Punctuation,\n\n  /**\n   * A language keyword.\n   */\n  CXToken_Keyword,\n\n  /**\n   * An identifier (that is not a keyword).\n   */\n  CXToken_Identifier,\n\n  /**\n   * A numeric, string, or character literal.\n   */\n  CXToken_Literal,\n\n  /**\n   * A comment.\n   */\n  CXToken_Comment\n} CXTokenKind;\n\n/**\n * Describes a single preprocessing token.\n */\ntypedef struct {\n  unsigned int_data[4];\n  void *ptr_data;\n} CXToken;\n\n/**\n * Get the raw lexical token starting with the given location.\n *\n * \\param TU the translation unit whose text is being tokenized.\n *\n * \\param Location the source location with which the token starts.\n *\n * \\returns The token starting with the given location or NULL if no such token\n * exist. The returned pointer must be freed with clang_disposeTokens before the\n * translation unit is destroyed.\n */\nCINDEX_LINKAGE CXToken *clang_getToken(CXTranslationUnit TU,\n                                       CXSourceLocation Location);\n\n/**\n * Determine the kind of the given token.\n */\nCINDEX_LINKAGE CXTokenKind clang_getTokenKind(CXToken);\n\n/**\n * Determine the spelling of the given token.\n *\n * The spelling of a token is the textual representation of that token, e.g.,\n * the text of an identifier or keyword.\n */\nCINDEX_LINKAGE CXString clang_getTokenSpelling(CXTranslationUnit, CXToken);\n\n/**\n * Retrieve the source location of the given token.\n */\nCINDEX_LINKAGE CXSourceLocation clang_getTokenLocation(CXTranslationUnit,\n                                                       CXToken);\n\n/**\n * Retrieve a source range that covers the given token.\n */\nCINDEX_LINKAGE CXSourceRange clang_getTokenExtent(CXTranslationUnit, CXToken);\n\n/**\n * Tokenize the source code described by the given range into raw\n * lexical tokens.\n *\n * \\param TU the translation unit whose text is being tokenized.\n *\n * \\param Range the source range in which text should be tokenized. All of the\n * tokens produced by tokenization will fall within this source range,\n *\n * \\param Tokens this pointer will be set to point to the array of tokens\n * that occur within the given source range. The returned pointer must be\n * freed with clang_disposeTokens() before the translation unit is destroyed.\n *\n * \\param NumTokens will be set to the number of tokens in the \\c *Tokens\n * array.\n *\n */\nCINDEX_LINKAGE void clang_tokenize(CXTranslationUnit TU, CXSourceRange Range,\n                                   CXToken **Tokens, unsigned *NumTokens);\n\n/**\n * Annotate the given set of tokens by providing cursors for each token\n * that can be mapped to a specific entity within the abstract syntax tree.\n *\n * This token-annotation routine is equivalent to invoking\n * clang_getCursor() for the source locations of each of the\n * tokens. The cursors provided are filtered, so that only those\n * cursors that have a direct correspondence to the token are\n * accepted. For example, given a function call \\c f(x),\n * clang_getCursor() would provide the following cursors:\n *\n *   * when the cursor is over the 'f', a DeclRefExpr cursor referring to 'f'.\n *   * when the cursor is over the '(' or the ')', a CallExpr referring to 'f'.\n *   * when the cursor is over the 'x', a DeclRefExpr cursor referring to 'x'.\n *\n * Only the first and last of these cursors will occur within the\n * annotate, since the tokens \"f\" and \"x' directly refer to a function\n * and a variable, respectively, but the parentheses are just a small\n * part of the full syntax of the function call expression, which is\n * not provided as an annotation.\n *\n * \\param TU the translation unit that owns the given tokens.\n *\n * \\param Tokens the set of tokens to annotate.\n *\n * \\param NumTokens the number of tokens in \\p Tokens.\n *\n * \\param Cursors an array of \\p NumTokens cursors, whose contents will be\n * replaced with the cursors corresponding to each token.\n */\nCINDEX_LINKAGE void clang_annotateTokens(CXTranslationUnit TU, CXToken *Tokens,\n                                         unsigned NumTokens, CXCursor *Cursors);\n\n/**\n * Free the given set of tokens.\n */\nCINDEX_LINKAGE void clang_disposeTokens(CXTranslationUnit TU, CXToken *Tokens,\n                                        unsigned NumTokens);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_DEBUG Debugging facilities\n *\n * These routines are used for testing and debugging, only, and should not\n * be relied upon.\n *\n * @{\n */\n\n/* for debug/testing */\nCINDEX_LINKAGE CXString clang_getCursorKindSpelling(enum CXCursorKind Kind);\nCINDEX_LINKAGE void clang_getDefinitionSpellingAndExtent(\n    CXCursor, const char **startBuf, const char **endBuf, unsigned *startLine,\n    unsigned *startColumn, unsigned *endLine, unsigned *endColumn);\nCINDEX_LINKAGE void clang_enableStackTraces(void);\nCINDEX_LINKAGE void clang_executeOnThread(void (*fn)(void *), void *user_data,\n                                          unsigned stack_size);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_CODE_COMPLET Code completion\n *\n * Code completion involves taking an (incomplete) source file, along with\n * knowledge of where the user is actively editing that file, and suggesting\n * syntactically- and semantically-valid constructs that the user might want to\n * use at that particular point in the source code. These data structures and\n * routines provide support for code completion.\n *\n * @{\n */\n\n/**\n * A semantic string that describes a code-completion result.\n *\n * A semantic string that describes the formatting of a code-completion\n * result as a single \"template\" of text that should be inserted into the\n * source buffer when a particular code-completion result is selected.\n * Each semantic string is made up of some number of \"chunks\", each of which\n * contains some text along with a description of what that text means, e.g.,\n * the name of the entity being referenced, whether the text chunk is part of\n * the template, or whether it is a \"placeholder\" that the user should replace\n * with actual code,of a specific kind. See \\c CXCompletionChunkKind for a\n * description of the different kinds of chunks.\n */\ntypedef void *CXCompletionString;\n\n/**\n * A single result of code completion.\n */\ntypedef struct {\n  /**\n   * The kind of entity that this completion refers to.\n   *\n   * The cursor kind will be a macro, keyword, or a declaration (one of the\n   * *Decl cursor kinds), describing the entity that the completion is\n   * referring to.\n   *\n   * \\todo In the future, we would like to provide a full cursor, to allow\n   * the client to extract additional information from declaration.\n   */\n  enum CXCursorKind CursorKind;\n\n  /**\n   * The code-completion string that describes how to insert this\n   * code-completion result into the editing buffer.\n   */\n  CXCompletionString CompletionString;\n} CXCompletionResult;\n\n/**\n * Describes a single piece of text within a code-completion string.\n *\n * Each \"chunk\" within a code-completion string (\\c CXCompletionString) is\n * either a piece of text with a specific \"kind\" that describes how that text\n * should be interpreted by the client or is another completion string.\n */\nenum CXCompletionChunkKind {\n  /**\n   * A code-completion string that describes \"optional\" text that\n   * could be a part of the template (but is not required).\n   *\n   * The Optional chunk is the only kind of chunk that has a code-completion\n   * string for its representation, which is accessible via\n   * \\c clang_getCompletionChunkCompletionString(). The code-completion string\n   * describes an additional part of the template that is completely optional.\n   * For example, optional chunks can be used to describe the placeholders for\n   * arguments that match up with defaulted function parameters, e.g. given:\n   *\n   * \\code\n   * void f(int x, float y = 3.14, double z = 2.71828);\n   * \\endcode\n   *\n   * The code-completion string for this function would contain:\n   *   - a TypedText chunk for \"f\".\n   *   - a LeftParen chunk for \"(\".\n   *   - a Placeholder chunk for \"int x\"\n   *   - an Optional chunk containing the remaining defaulted arguments, e.g.,\n   *       - a Comma chunk for \",\"\n   *       - a Placeholder chunk for \"float y\"\n   *       - an Optional chunk containing the last defaulted argument:\n   *           - a Comma chunk for \",\"\n   *           - a Placeholder chunk for \"double z\"\n   *   - a RightParen chunk for \")\"\n   *\n   * There are many ways to handle Optional chunks. Two simple approaches are:\n   *   - Completely ignore optional chunks, in which case the template for the\n   *     function \"f\" would only include the first parameter (\"int x\").\n   *   - Fully expand all optional chunks, in which case the template for the\n   *     function \"f\" would have all of the parameters.\n   */\n  CXCompletionChunk_Optional,\n  /**\n   * Text that a user would be expected to type to get this\n   * code-completion result.\n   *\n   * There will be exactly one \"typed text\" chunk in a semantic string, which\n   * will typically provide the spelling of a keyword or the name of a\n   * declaration that could be used at the current code point. Clients are\n   * expected to filter the code-completion results based on the text in this\n   * chunk.\n   */\n  CXCompletionChunk_TypedText,\n  /**\n   * Text that should be inserted as part of a code-completion result.\n   *\n   * A \"text\" chunk represents text that is part of the template to be\n   * inserted into user code should this particular code-completion result\n   * be selected.\n   */\n  CXCompletionChunk_Text,\n  /**\n   * Placeholder text that should be replaced by the user.\n   *\n   * A \"placeholder\" chunk marks a place where the user should insert text\n   * into the code-completion template. For example, placeholders might mark\n   * the function parameters for a function declaration, to indicate that the\n   * user should provide arguments for each of those parameters. The actual\n   * text in a placeholder is a suggestion for the text to display before\n   * the user replaces the placeholder with real code.\n   */\n  CXCompletionChunk_Placeholder,\n  /**\n   * Informative text that should be displayed but never inserted as\n   * part of the template.\n   *\n   * An \"informative\" chunk contains annotations that can be displayed to\n   * help the user decide whether a particular code-completion result is the\n   * right option, but which is not part of the actual template to be inserted\n   * by code completion.\n   */\n  CXCompletionChunk_Informative,\n  /**\n   * Text that describes the current parameter when code-completion is\n   * referring to function call, message send, or template specialization.\n   *\n   * A \"current parameter\" chunk occurs when code-completion is providing\n   * information about a parameter corresponding to the argument at the\n   * code-completion point. For example, given a function\n   *\n   * \\code\n   * int add(int x, int y);\n   * \\endcode\n   *\n   * and the source code \\c add(, where the code-completion point is after the\n   * \"(\", the code-completion string will contain a \"current parameter\" chunk\n   * for \"int x\", indicating that the current argument will initialize that\n   * parameter. After typing further, to \\c add(17, (where the code-completion\n   * point is after the \",\"), the code-completion string will contain a\n   * \"current parameter\" chunk to \"int y\".\n   */\n  CXCompletionChunk_CurrentParameter,\n  /**\n   * A left parenthesis ('('), used to initiate a function call or\n   * signal the beginning of a function parameter list.\n   */\n  CXCompletionChunk_LeftParen,\n  /**\n   * A right parenthesis (')'), used to finish a function call or\n   * signal the end of a function parameter list.\n   */\n  CXCompletionChunk_RightParen,\n  /**\n   * A left bracket ('[').\n   */\n  CXCompletionChunk_LeftBracket,\n  /**\n   * A right bracket (']').\n   */\n  CXCompletionChunk_RightBracket,\n  /**\n   * A left brace ('{').\n   */\n  CXCompletionChunk_LeftBrace,\n  /**\n   * A right brace ('}').\n   */\n  CXCompletionChunk_RightBrace,\n  /**\n   * A left angle bracket ('<').\n   */\n  CXCompletionChunk_LeftAngle,\n  /**\n   * A right angle bracket ('>').\n   */\n  CXCompletionChunk_RightAngle,\n  /**\n   * A comma separator (',').\n   */\n  CXCompletionChunk_Comma,\n  /**\n   * Text that specifies the result type of a given result.\n   *\n   * This special kind of informative chunk is not meant to be inserted into\n   * the text buffer. Rather, it is meant to illustrate the type that an\n   * expression using the given completion string would have.\n   */\n  CXCompletionChunk_ResultType,\n  /**\n   * A colon (':').\n   */\n  CXCompletionChunk_Colon,\n  /**\n   * A semicolon (';').\n   */\n  CXCompletionChunk_SemiColon,\n  /**\n   * An '=' sign.\n   */\n  CXCompletionChunk_Equal,\n  /**\n   * Horizontal space (' ').\n   */\n  CXCompletionChunk_HorizontalSpace,\n  /**\n   * Vertical space ('\\\\n'), after which it is generally a good idea to\n   * perform indentation.\n   */\n  CXCompletionChunk_VerticalSpace\n};\n\n/**\n * Determine the kind of a particular chunk within a completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param chunk_number the 0-based index of the chunk in the completion string.\n *\n * \\returns the kind of the chunk at the index \\c chunk_number.\n */\nCINDEX_LINKAGE enum CXCompletionChunkKind\nclang_getCompletionChunkKind(CXCompletionString completion_string,\n                             unsigned chunk_number);\n\n/**\n * Retrieve the text associated with a particular chunk within a\n * completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param chunk_number the 0-based index of the chunk in the completion string.\n *\n * \\returns the text associated with the chunk at index \\c chunk_number.\n */\nCINDEX_LINKAGE CXString clang_getCompletionChunkText(\n    CXCompletionString completion_string, unsigned chunk_number);\n\n/**\n * Retrieve the completion string associated with a particular chunk\n * within a completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param chunk_number the 0-based index of the chunk in the completion string.\n *\n * \\returns the completion string associated with the chunk at index\n * \\c chunk_number.\n */\nCINDEX_LINKAGE CXCompletionString clang_getCompletionChunkCompletionString(\n    CXCompletionString completion_string, unsigned chunk_number);\n\n/**\n * Retrieve the number of chunks in the given code-completion string.\n */\nCINDEX_LINKAGE unsigned\nclang_getNumCompletionChunks(CXCompletionString completion_string);\n\n/**\n * Determine the priority of this code completion.\n *\n * The priority of a code completion indicates how likely it is that this\n * particular completion is the completion that the user will select. The\n * priority is selected by various internal heuristics.\n *\n * \\param completion_string The completion string to query.\n *\n * \\returns The priority of this completion string. Smaller values indicate\n * higher-priority (more likely) completions.\n */\nCINDEX_LINKAGE unsigned\nclang_getCompletionPriority(CXCompletionString completion_string);\n\n/**\n * Determine the availability of the entity that this code-completion\n * string refers to.\n *\n * \\param completion_string The completion string to query.\n *\n * \\returns The availability of the completion string.\n */\nCINDEX_LINKAGE enum CXAvailabilityKind\nclang_getCompletionAvailability(CXCompletionString completion_string);\n\n/**\n * Retrieve the number of annotations associated with the given\n * completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\returns the number of annotations associated with the given completion\n * string.\n */\nCINDEX_LINKAGE unsigned\nclang_getCompletionNumAnnotations(CXCompletionString completion_string);\n\n/**\n * Retrieve the annotation associated with the given completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param annotation_number the 0-based index of the annotation of the\n * completion string.\n *\n * \\returns annotation string associated with the completion at index\n * \\c annotation_number, or a NULL string if that annotation is not available.\n */\nCINDEX_LINKAGE CXString clang_getCompletionAnnotation(\n    CXCompletionString completion_string, unsigned annotation_number);\n\n/**\n * Retrieve the parent context of the given completion string.\n *\n * The parent context of a completion string is the semantic parent of\n * the declaration (if any) that the code completion represents. For example,\n * a code completion for an Objective-C method would have the method's class\n * or protocol as its context.\n *\n * \\param completion_string The code completion string whose parent is\n * being queried.\n *\n * \\param kind DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.\n *\n * \\returns The name of the completion parent, e.g., \"NSObject\" if\n * the completion string represents a method in the NSObject class.\n */\nCINDEX_LINKAGE CXString clang_getCompletionParent(\n    CXCompletionString completion_string, enum CXCursorKind *kind);\n\n/**\n * Retrieve the brief documentation comment attached to the declaration\n * that corresponds to the given completion string.\n */\nCINDEX_LINKAGE CXString\nclang_getCompletionBriefComment(CXCompletionString completion_string);\n\n/**\n * Retrieve a completion string for an arbitrary declaration or macro\n * definition cursor.\n *\n * \\param cursor The cursor to query.\n *\n * \\returns A non-context-sensitive completion string for declaration and macro\n * definition cursors, or NULL for other kinds of cursors.\n */\nCINDEX_LINKAGE CXCompletionString\nclang_getCursorCompletionString(CXCursor cursor);\n\n/**\n * Contains the results of code-completion.\n *\n * This data structure contains the results of code completion, as\n * produced by \\c clang_codeCompleteAt(). Its contents must be freed by\n * \\c clang_disposeCodeCompleteResults.\n */\ntypedef struct {\n  /**\n   * The code-completion results.\n   */\n  CXCompletionResult *Results;\n\n  /**\n   * The number of code-completion results stored in the\n   * \\c Results array.\n   */\n  unsigned NumResults;\n} CXCodeCompleteResults;\n\n/**\n * Retrieve the number of fix-its for the given completion index.\n *\n * Calling this makes sense only if CXCodeComplete_IncludeCompletionsWithFixIts\n * option was set.\n *\n * \\param results The structure keeping all completion results\n *\n * \\param completion_index The index of the completion\n *\n * \\return The number of fix-its which must be applied before the completion at\n * completion_index can be applied\n */\nCINDEX_LINKAGE unsigned\nclang_getCompletionNumFixIts(CXCodeCompleteResults *results,\n                             unsigned completion_index);\n\n/**\n * Fix-its that *must* be applied before inserting the text for the\n * corresponding completion.\n *\n * By default, clang_codeCompleteAt() only returns completions with empty\n * fix-its. Extra completions with non-empty fix-its should be explicitly\n * requested by setting CXCodeComplete_IncludeCompletionsWithFixIts.\n *\n * For the clients to be able to compute position of the cursor after applying\n * fix-its, the following conditions are guaranteed to hold for\n * replacement_range of the stored fix-its:\n *  - Ranges in the fix-its are guaranteed to never contain the completion\n *  point (or identifier under completion point, if any) inside them, except\n *  at the start or at the end of the range.\n *  - If a fix-it range starts or ends with completion point (or starts or\n *  ends after the identifier under completion point), it will contain at\n *  least one character. It allows to unambiguously recompute completion\n *  point after applying the fix-it.\n *\n * The intuition is that provided fix-its change code around the identifier we\n * complete, but are not allowed to touch the identifier itself or the\n * completion point. One example of completions with corrections are the ones\n * replacing '.' with '->' and vice versa:\n *\n * std::unique_ptr<std::vector<int>> vec_ptr;\n * In 'vec_ptr.^', one of the completions is 'push_back', it requires\n * replacing '.' with '->'.\n * In 'vec_ptr->^', one of the completions is 'release', it requires\n * replacing '->' with '.'.\n *\n * \\param results The structure keeping all completion results\n *\n * \\param completion_index The index of the completion\n *\n * \\param fixit_index The index of the fix-it for the completion at\n * completion_index\n *\n * \\param replacement_range The fix-it range that must be replaced before the\n * completion at completion_index can be applied\n *\n * \\returns The fix-it string that must replace the code at replacement_range\n * before the completion at completion_index can be applied\n */\nCINDEX_LINKAGE CXString clang_getCompletionFixIt(\n    CXCodeCompleteResults *results, unsigned completion_index,\n    unsigned fixit_index, CXSourceRange *replacement_range);\n\n/**\n * Flags that can be passed to \\c clang_codeCompleteAt() to\n * modify its behavior.\n *\n * The enumerators in this enumeration can be bitwise-OR'd together to\n * provide multiple options to \\c clang_codeCompleteAt().\n */\nenum CXCodeComplete_Flags {\n  /**\n   * Whether to include macros within the set of code\n   * completions returned.\n   */\n  CXCodeComplete_IncludeMacros = 0x01,\n\n  /**\n   * Whether to include code patterns for language constructs\n   * within the set of code completions, e.g., for loops.\n   */\n  CXCodeComplete_IncludeCodePatterns = 0x02,\n\n  /**\n   * Whether to include brief documentation within the set of code\n   * completions returned.\n   */\n  CXCodeComplete_IncludeBriefComments = 0x04,\n\n  /**\n   * Whether to speed up completion by omitting top- or namespace-level entities\n   * defined in the preamble. There's no guarantee any particular entity is\n   * omitted. This may be useful if the headers are indexed externally.\n   */\n  CXCodeComplete_SkipPreamble = 0x08,\n\n  /**\n   * Whether to include completions with small\n   * fix-its, e.g. change '.' to '->' on member access, etc.\n   */\n  CXCodeComplete_IncludeCompletionsWithFixIts = 0x10\n};\n\n/**\n * Bits that represent the context under which completion is occurring.\n *\n * The enumerators in this enumeration may be bitwise-OR'd together if multiple\n * contexts are occurring simultaneously.\n */\nenum CXCompletionContext {\n  /**\n   * The context for completions is unexposed, as only Clang results\n   * should be included. (This is equivalent to having no context bits set.)\n   */\n  CXCompletionContext_Unexposed = 0,\n\n  /**\n   * Completions for any possible type should be included in the results.\n   */\n  CXCompletionContext_AnyType = 1 << 0,\n\n  /**\n   * Completions for any possible value (variables, function calls, etc.)\n   * should be included in the results.\n   */\n  CXCompletionContext_AnyValue = 1 << 1,\n  /**\n   * Completions for values that resolve to an Objective-C object should\n   * be included in the results.\n   */\n  CXCompletionContext_ObjCObjectValue = 1 << 2,\n  /**\n   * Completions for values that resolve to an Objective-C selector\n   * should be included in the results.\n   */\n  CXCompletionContext_ObjCSelectorValue = 1 << 3,\n  /**\n   * Completions for values that resolve to a C++ class type should be\n   * included in the results.\n   */\n  CXCompletionContext_CXXClassTypeValue = 1 << 4,\n\n  /**\n   * Completions for fields of the member being accessed using the dot\n   * operator should be included in the results.\n   */\n  CXCompletionContext_DotMemberAccess = 1 << 5,\n  /**\n   * Completions for fields of the member being accessed using the arrow\n   * operator should be included in the results.\n   */\n  CXCompletionContext_ArrowMemberAccess = 1 << 6,\n  /**\n   * Completions for properties of the Objective-C object being accessed\n   * using the dot operator should be included in the results.\n   */\n  CXCompletionContext_ObjCPropertyAccess = 1 << 7,\n\n  /**\n   * Completions for enum tags should be included in the results.\n   */\n  CXCompletionContext_EnumTag = 1 << 8,\n  /**\n   * Completions for union tags should be included in the results.\n   */\n  CXCompletionContext_UnionTag = 1 << 9,\n  /**\n   * Completions for struct tags should be included in the results.\n   */\n  CXCompletionContext_StructTag = 1 << 10,\n\n  /**\n   * Completions for C++ class names should be included in the results.\n   */\n  CXCompletionContext_ClassTag = 1 << 11,\n  /**\n   * Completions for C++ namespaces and namespace aliases should be\n   * included in the results.\n   */\n  CXCompletionContext_Namespace = 1 << 12,\n  /**\n   * Completions for C++ nested name specifiers should be included in\n   * the results.\n   */\n  CXCompletionContext_NestedNameSpecifier = 1 << 13,\n\n  /**\n   * Completions for Objective-C interfaces (classes) should be included\n   * in the results.\n   */\n  CXCompletionContext_ObjCInterface = 1 << 14,\n  /**\n   * Completions for Objective-C protocols should be included in\n   * the results.\n   */\n  CXCompletionContext_ObjCProtocol = 1 << 15,\n  /**\n   * Completions for Objective-C categories should be included in\n   * the results.\n   */\n  CXCompletionContext_ObjCCategory = 1 << 16,\n  /**\n   * Completions for Objective-C instance messages should be included\n   * in the results.\n   */\n  CXCompletionContext_ObjCInstanceMessage = 1 << 17,\n  /**\n   * Completions for Objective-C class messages should be included in\n   * the results.\n   */\n  CXCompletionContext_ObjCClassMessage = 1 << 18,\n  /**\n   * Completions for Objective-C selector names should be included in\n   * the results.\n   */\n  CXCompletionContext_ObjCSelectorName = 1 << 19,\n\n  /**\n   * Completions for preprocessor macro names should be included in\n   * the results.\n   */\n  CXCompletionContext_MacroName = 1 << 20,\n\n  /**\n   * Natural language completions should be included in the results.\n   */\n  CXCompletionContext_NaturalLanguage = 1 << 21,\n\n  /**\n   * #include file completions should be included in the results.\n   */\n  CXCompletionContext_IncludedFile = 1 << 22,\n\n  /**\n   * The current context is unknown, so set all contexts.\n   */\n  CXCompletionContext_Unknown = ((1 << 23) - 1)\n};\n\n/**\n * Returns a default set of code-completion options that can be\n * passed to\\c clang_codeCompleteAt().\n */\nCINDEX_LINKAGE unsigned clang_defaultCodeCompleteOptions(void);\n\n/**\n * Perform code completion at a given location in a translation unit.\n *\n * This function performs code completion at a particular file, line, and\n * column within source code, providing results that suggest potential\n * code snippets based on the context of the completion. The basic model\n * for code completion is that Clang will parse a complete source file,\n * performing syntax checking up to the location where code-completion has\n * been requested. At that point, a special code-completion token is passed\n * to the parser, which recognizes this token and determines, based on the\n * current location in the C/Objective-C/C++ grammar and the state of\n * semantic analysis, what completions to provide. These completions are\n * returned via a new \\c CXCodeCompleteResults structure.\n *\n * Code completion itself is meant to be triggered by the client when the\n * user types punctuation characters or whitespace, at which point the\n * code-completion location will coincide with the cursor. For example, if \\c p\n * is a pointer, code-completion might be triggered after the \"-\" and then\n * after the \">\" in \\c p->. When the code-completion location is after the \">\",\n * the completion results will provide, e.g., the members of the struct that\n * \"p\" points to. The client is responsible for placing the cursor at the\n * beginning of the token currently being typed, then filtering the results\n * based on the contents of the token. For example, when code-completing for\n * the expression \\c p->get, the client should provide the location just after\n * the \">\" (e.g., pointing at the \"g\") to this code-completion hook. Then, the\n * client can filter the results based on the current token text (\"get\"), only\n * showing those results that start with \"get\". The intent of this interface\n * is to separate the relatively high-latency acquisition of code-completion\n * results from the filtering of results on a per-character basis, which must\n * have a lower latency.\n *\n * \\param TU The translation unit in which code-completion should\n * occur. The source files for this translation unit need not be\n * completely up-to-date (and the contents of those source files may\n * be overridden via \\p unsaved_files). Cursors referring into the\n * translation unit may be invalidated by this invocation.\n *\n * \\param complete_filename The name of the source file where code\n * completion should be performed. This filename may be any file\n * included in the translation unit.\n *\n * \\param complete_line The line at which code-completion should occur.\n *\n * \\param complete_column The column at which code-completion should occur.\n * Note that the column should point just after the syntactic construct that\n * initiated code completion, and not in the middle of a lexical token.\n *\n * \\param unsaved_files the Files that have not yet been saved to disk\n * but may be required for parsing or code completion, including the\n * contents of those files.  The contents and name of these files (as\n * specified by CXUnsavedFile) are copied when necessary, so the\n * client only needs to guarantee their validity until the call to\n * this function returns.\n *\n * \\param num_unsaved_files The number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param options Extra options that control the behavior of code\n * completion, expressed as a bitwise OR of the enumerators of the\n * CXCodeComplete_Flags enumeration. The\n * \\c clang_defaultCodeCompleteOptions() function returns a default set\n * of code-completion options.\n *\n * \\returns If successful, a new \\c CXCodeCompleteResults structure\n * containing code-completion results, which should eventually be\n * freed with \\c clang_disposeCodeCompleteResults(). If code\n * completion fails, returns NULL.\n */\nCINDEX_LINKAGE\nCXCodeCompleteResults *\nclang_codeCompleteAt(CXTranslationUnit TU, const char *complete_filename,\n                     unsigned complete_line, unsigned complete_column,\n                     struct CXUnsavedFile *unsaved_files,\n                     unsigned num_unsaved_files, unsigned options);\n\n/**\n * Sort the code-completion results in case-insensitive alphabetical\n * order.\n *\n * \\param Results The set of results to sort.\n * \\param NumResults The number of results in \\p Results.\n */\nCINDEX_LINKAGE\nvoid clang_sortCodeCompletionResults(CXCompletionResult *Results,\n                                     unsigned NumResults);\n\n/**\n * Free the given set of code-completion results.\n */\nCINDEX_LINKAGE\nvoid clang_disposeCodeCompleteResults(CXCodeCompleteResults *Results);\n\n/**\n * Determine the number of diagnostics produced prior to the\n * location where code completion was performed.\n */\nCINDEX_LINKAGE\nunsigned clang_codeCompleteGetNumDiagnostics(CXCodeCompleteResults *Results);\n\n/**\n * Retrieve a diagnostic associated with the given code completion.\n *\n * \\param Results the code completion results to query.\n * \\param Index the zero-based diagnostic number to retrieve.\n *\n * \\returns the requested diagnostic. This diagnostic must be freed\n * via a call to \\c clang_disposeDiagnostic().\n */\nCINDEX_LINKAGE\nCXDiagnostic clang_codeCompleteGetDiagnostic(CXCodeCompleteResults *Results,\n                                             unsigned Index);\n\n/**\n * Determines what completions are appropriate for the context\n * the given code completion.\n *\n * \\param Results the code completion results to query\n *\n * \\returns the kinds of completions that are appropriate for use\n * along with the given code completion results.\n */\nCINDEX_LINKAGE\nunsigned long long\nclang_codeCompleteGetContexts(CXCodeCompleteResults *Results);\n\n/**\n * Returns the cursor kind for the container for the current code\n * completion context. The container is only guaranteed to be set for\n * contexts where a container exists (i.e. member accesses or Objective-C\n * message sends); if there is not a container, this function will return\n * CXCursor_InvalidCode.\n *\n * \\param Results the code completion results to query\n *\n * \\param IsIncomplete on return, this value will be false if Clang has complete\n * information about the container. If Clang does not have complete\n * information, this value will be true.\n *\n * \\returns the container kind, or CXCursor_InvalidCode if there is not a\n * container\n */\nCINDEX_LINKAGE\nenum CXCursorKind\nclang_codeCompleteGetContainerKind(CXCodeCompleteResults *Results,\n                                   unsigned *IsIncomplete);\n\n/**\n * Returns the USR for the container for the current code completion\n * context. If there is not a container for the current context, this\n * function will return the empty string.\n *\n * \\param Results the code completion results to query\n *\n * \\returns the USR for the container\n */\nCINDEX_LINKAGE\nCXString clang_codeCompleteGetContainerUSR(CXCodeCompleteResults *Results);\n\n/**\n * Returns the currently-entered selector for an Objective-C message\n * send, formatted like \"initWithFoo:bar:\". Only guaranteed to return a\n * non-empty string for CXCompletionContext_ObjCInstanceMessage and\n * CXCompletionContext_ObjCClassMessage.\n *\n * \\param Results the code completion results to query\n *\n * \\returns the selector (or partial selector) that has been entered thus far\n * for an Objective-C message send.\n */\nCINDEX_LINKAGE\nCXString clang_codeCompleteGetObjCSelector(CXCodeCompleteResults *Results);\n\n/**\n * @}\n */\n\n/**\n * \\defgroup CINDEX_MISC Miscellaneous utility functions\n *\n * @{\n */\n\n/**\n * Return a version string, suitable for showing to a user, but not\n *        intended to be parsed (the format is not guaranteed to be stable).\n */\nCINDEX_LINKAGE CXString clang_getClangVersion(void);\n\n/**\n * Enable/disable crash recovery.\n *\n * \\param isEnabled Flag to indicate if crash recovery is enabled.  A non-zero\n *        value enables crash recovery, while 0 disables it.\n */\nCINDEX_LINKAGE void clang_toggleCrashRecovery(unsigned isEnabled);\n\n/**\n * Visitor invoked for each file in a translation unit\n *        (used with clang_getInclusions()).\n *\n * This visitor function will be invoked by clang_getInclusions() for each\n * file included (either at the top-level or by \\#include directives) within\n * a translation unit.  The first argument is the file being included, and\n * the second and third arguments provide the inclusion stack.  The\n * array is sorted in order of immediate inclusion.  For example,\n * the first element refers to the location that included 'included_file'.\n */\ntypedef void (*CXInclusionVisitor)(CXFile included_file,\n                                   CXSourceLocation *inclusion_stack,\n                                   unsigned include_len,\n                                   CXClientData client_data);\n\n/**\n * Visit the set of preprocessor inclusions in a translation unit.\n *   The visitor function is called with the provided data for every included\n *   file.  This does not include headers included by the PCH file (unless one\n *   is inspecting the inclusions in the PCH file itself).\n */\nCINDEX_LINKAGE void clang_getInclusions(CXTranslationUnit tu,\n                                        CXInclusionVisitor visitor,\n                                        CXClientData client_data);\n\ntypedef enum {\n  CXEval_Int = 1,\n  CXEval_Float = 2,\n  CXEval_ObjCStrLiteral = 3,\n  CXEval_StrLiteral = 4,\n  CXEval_CFStr = 5,\n  CXEval_Other = 6,\n\n  CXEval_UnExposed = 0\n\n} CXEvalResultKind;\n\n/**\n * Evaluation result of a cursor\n */\ntypedef void *CXEvalResult;\n\n/**\n * If cursor is a statement declaration tries to evaluate the\n * statement and if its variable, tries to evaluate its initializer,\n * into its corresponding type.\n * If it's an expression, tries to evaluate the expression.\n */\nCINDEX_LINKAGE CXEvalResult clang_Cursor_Evaluate(CXCursor C);\n\n/**\n * Returns the kind of the evaluated result.\n */\nCINDEX_LINKAGE CXEvalResultKind clang_EvalResult_getKind(CXEvalResult E);\n\n/**\n * Returns the evaluation result as integer if the\n * kind is Int.\n */\nCINDEX_LINKAGE int clang_EvalResult_getAsInt(CXEvalResult E);\n\n/**\n * Returns the evaluation result as a long long integer if the\n * kind is Int. This prevents overflows that may happen if the result is\n * returned with clang_EvalResult_getAsInt.\n */\nCINDEX_LINKAGE long long clang_EvalResult_getAsLongLong(CXEvalResult E);\n\n/**\n * Returns a non-zero value if the kind is Int and the evaluation\n * result resulted in an unsigned integer.\n */\nCINDEX_LINKAGE unsigned clang_EvalResult_isUnsignedInt(CXEvalResult E);\n\n/**\n * Returns the evaluation result as an unsigned integer if\n * the kind is Int and clang_EvalResult_isUnsignedInt is non-zero.\n */\nCINDEX_LINKAGE unsigned long long\nclang_EvalResult_getAsUnsigned(CXEvalResult E);\n\n/**\n * Returns the evaluation result as double if the\n * kind is double.\n */\nCINDEX_LINKAGE double clang_EvalResult_getAsDouble(CXEvalResult E);\n\n/**\n * Returns the evaluation result as a constant string if the\n * kind is other than Int or float. User must not free this pointer,\n * instead call clang_EvalResult_dispose on the CXEvalResult returned\n * by clang_Cursor_Evaluate.\n */\nCINDEX_LINKAGE const char *clang_EvalResult_getAsStr(CXEvalResult E);\n\n/**\n * Disposes the created Eval memory.\n */\nCINDEX_LINKAGE void clang_EvalResult_dispose(CXEvalResult E);\n/**\n * @}\n */\n\n/** \\defgroup CINDEX_REMAPPING Remapping functions\n *\n * @{\n */\n\n/**\n * A remapping of original source files and their translated files.\n */\ntypedef void *CXRemapping;\n\n/**\n * Retrieve a remapping.\n *\n * \\param path the path that contains metadata about remappings.\n *\n * \\returns the requested remapping. This remapping must be freed\n * via a call to \\c clang_remap_dispose(). Can return NULL if an error occurred.\n */\nCINDEX_LINKAGE CXRemapping clang_getRemappings(const char *path);\n\n/**\n * Retrieve a remapping.\n *\n * \\param filePaths pointer to an array of file paths containing remapping info.\n *\n * \\param numFiles number of file paths.\n *\n * \\returns the requested remapping. This remapping must be freed\n * via a call to \\c clang_remap_dispose(). Can return NULL if an error occurred.\n */\nCINDEX_LINKAGE\nCXRemapping clang_getRemappingsFromFileList(const char **filePaths,\n                                            unsigned numFiles);\n\n/**\n * Determine the number of remappings.\n */\nCINDEX_LINKAGE unsigned clang_remap_getNumFiles(CXRemapping);\n\n/**\n * Get the original and the associated filename from the remapping.\n *\n * \\param original If non-NULL, will be set to the original filename.\n *\n * \\param transformed If non-NULL, will be set to the filename that the original\n * is associated with.\n */\nCINDEX_LINKAGE void clang_remap_getFilenames(CXRemapping, unsigned index,\n                                             CXString *original,\n                                             CXString *transformed);\n\n/**\n * Dispose the remapping.\n */\nCINDEX_LINKAGE void clang_remap_dispose(CXRemapping);\n\n/**\n * @}\n */\n\n/** \\defgroup CINDEX_HIGH Higher level API functions\n *\n * @{\n */\n\nenum CXVisitorResult { CXVisit_Break, CXVisit_Continue };\n\ntypedef struct CXCursorAndRangeVisitor {\n  void *context;\n  enum CXVisitorResult (*visit)(void *context, CXCursor, CXSourceRange);\n} CXCursorAndRangeVisitor;\n\ntypedef enum {\n  /**\n   * Function returned successfully.\n   */\n  CXResult_Success = 0,\n  /**\n   * One of the parameters was invalid for the function.\n   */\n  CXResult_Invalid = 1,\n  /**\n   * The function was terminated by a callback (e.g. it returned\n   * CXVisit_Break)\n   */\n  CXResult_VisitBreak = 2\n\n} CXResult;\n\n/**\n * Find references of a declaration in a specific file.\n *\n * \\param cursor pointing to a declaration or a reference of one.\n *\n * \\param file to search for references.\n *\n * \\param visitor callback that will receive pairs of CXCursor/CXSourceRange for\n * each reference found.\n * The CXSourceRange will point inside the file; if the reference is inside\n * a macro (and not a macro argument) the CXSourceRange will be invalid.\n *\n * \\returns one of the CXResult enumerators.\n */\nCINDEX_LINKAGE CXResult clang_findReferencesInFile(\n    CXCursor cursor, CXFile file, CXCursorAndRangeVisitor visitor);\n\n/**\n * Find #import/#include directives in a specific file.\n *\n * \\param TU translation unit containing the file to query.\n *\n * \\param file to search for #import/#include directives.\n *\n * \\param visitor callback that will receive pairs of CXCursor/CXSourceRange for\n * each directive found.\n *\n * \\returns one of the CXResult enumerators.\n */\nCINDEX_LINKAGE CXResult clang_findIncludesInFile(\n    CXTranslationUnit TU, CXFile file, CXCursorAndRangeVisitor visitor);\n\n#ifdef __has_feature\n#if __has_feature(blocks)\n\ntypedef enum CXVisitorResult (^CXCursorAndRangeVisitorBlock)(CXCursor,\n                                                             CXSourceRange);\n\nCINDEX_LINKAGE\nCXResult clang_findReferencesInFileWithBlock(CXCursor, CXFile,\n                                             CXCursorAndRangeVisitorBlock);\n\nCINDEX_LINKAGE\nCXResult clang_findIncludesInFileWithBlock(CXTranslationUnit, CXFile,\n                                           CXCursorAndRangeVisitorBlock);\n\n#endif\n#endif\n\n/**\n * The client's data object that is associated with a CXFile.\n */\ntypedef void *CXIdxClientFile;\n\n/**\n * The client's data object that is associated with a semantic entity.\n */\ntypedef void *CXIdxClientEntity;\n\n/**\n * The client's data object that is associated with a semantic container\n * of entities.\n */\ntypedef void *CXIdxClientContainer;\n\n/**\n * The client's data object that is associated with an AST file (PCH\n * or module).\n */\ntypedef void *CXIdxClientASTFile;\n\n/**\n * Source location passed to index callbacks.\n */\ntypedef struct {\n  void *ptr_data[2];\n  unsigned int_data;\n} CXIdxLoc;\n\n/**\n * Data for ppIncludedFile callback.\n */\ntypedef struct {\n  /**\n   * Location of '#' in the \\#include/\\#import directive.\n   */\n  CXIdxLoc hashLoc;\n  /**\n   * Filename as written in the \\#include/\\#import directive.\n   */\n  const char *filename;\n  /**\n   * The actual file that the \\#include/\\#import directive resolved to.\n   */\n  CXFile file;\n  int isImport;\n  int isAngled;\n  /**\n   * Non-zero if the directive was automatically turned into a module\n   * import.\n   */\n  int isModuleImport;\n} CXIdxIncludedFileInfo;\n\n/**\n * Data for IndexerCallbacks#importedASTFile.\n */\ntypedef struct {\n  /**\n   * Top level AST file containing the imported PCH, module or submodule.\n   */\n  CXFile file;\n  /**\n   * The imported module or NULL if the AST file is a PCH.\n   */\n  CXModule module;\n  /**\n   * Location where the file is imported. Applicable only for modules.\n   */\n  CXIdxLoc loc;\n  /**\n   * Non-zero if an inclusion directive was automatically turned into\n   * a module import. Applicable only for modules.\n   */\n  int isImplicit;\n\n} CXIdxImportedASTFileInfo;\n\ntypedef enum {\n  CXIdxEntity_Unexposed = 0,\n  CXIdxEntity_Typedef = 1,\n  CXIdxEntity_Function = 2,\n  CXIdxEntity_Variable = 3,\n  CXIdxEntity_Field = 4,\n  CXIdxEntity_EnumConstant = 5,\n\n  CXIdxEntity_ObjCClass = 6,\n  CXIdxEntity_ObjCProtocol = 7,\n  CXIdxEntity_ObjCCategory = 8,\n\n  CXIdxEntity_ObjCInstanceMethod = 9,\n  CXIdxEntity_ObjCClassMethod = 10,\n  CXIdxEntity_ObjCProperty = 11,\n  CXIdxEntity_ObjCIvar = 12,\n\n  CXIdxEntity_Enum = 13,\n  CXIdxEntity_Struct = 14,\n  CXIdxEntity_Union = 15,\n\n  CXIdxEntity_CXXClass = 16,\n  CXIdxEntity_CXXNamespace = 17,\n  CXIdxEntity_CXXNamespaceAlias = 18,\n  CXIdxEntity_CXXStaticVariable = 19,\n  CXIdxEntity_CXXStaticMethod = 20,\n  CXIdxEntity_CXXInstanceMethod = 21,\n  CXIdxEntity_CXXConstructor = 22,\n  CXIdxEntity_CXXDestructor = 23,\n  CXIdxEntity_CXXConversionFunction = 24,\n  CXIdxEntity_CXXTypeAlias = 25,\n  CXIdxEntity_CXXInterface = 26\n\n} CXIdxEntityKind;\n\ntypedef enum {\n  CXIdxEntityLang_None = 0,\n  CXIdxEntityLang_C = 1,\n  CXIdxEntityLang_ObjC = 2,\n  CXIdxEntityLang_CXX = 3,\n  CXIdxEntityLang_Swift = 4\n} CXIdxEntityLanguage;\n\n/**\n * Extra C++ template information for an entity. This can apply to:\n * CXIdxEntity_Function\n * CXIdxEntity_CXXClass\n * CXIdxEntity_CXXStaticMethod\n * CXIdxEntity_CXXInstanceMethod\n * CXIdxEntity_CXXConstructor\n * CXIdxEntity_CXXConversionFunction\n * CXIdxEntity_CXXTypeAlias\n */\ntypedef enum {\n  CXIdxEntity_NonTemplate = 0,\n  CXIdxEntity_Template = 1,\n  CXIdxEntity_TemplatePartialSpecialization = 2,\n  CXIdxEntity_TemplateSpecialization = 3\n} CXIdxEntityCXXTemplateKind;\n\ntypedef enum {\n  CXIdxAttr_Unexposed = 0,\n  CXIdxAttr_IBAction = 1,\n  CXIdxAttr_IBOutlet = 2,\n  CXIdxAttr_IBOutletCollection = 3\n} CXIdxAttrKind;\n\ntypedef struct {\n  CXIdxAttrKind kind;\n  CXCursor cursor;\n  CXIdxLoc loc;\n} CXIdxAttrInfo;\n\ntypedef struct {\n  CXIdxEntityKind kind;\n  CXIdxEntityCXXTemplateKind templateKind;\n  CXIdxEntityLanguage lang;\n  const char *name;\n  const char *USR;\n  CXCursor cursor;\n  const CXIdxAttrInfo *const *attributes;\n  unsigned numAttributes;\n} CXIdxEntityInfo;\n\ntypedef struct {\n  CXCursor cursor;\n} CXIdxContainerInfo;\n\ntypedef struct {\n  const CXIdxAttrInfo *attrInfo;\n  const CXIdxEntityInfo *objcClass;\n  CXCursor classCursor;\n  CXIdxLoc classLoc;\n} CXIdxIBOutletCollectionAttrInfo;\n\ntypedef enum { CXIdxDeclFlag_Skipped = 0x1 } CXIdxDeclInfoFlags;\n\ntypedef struct {\n  const CXIdxEntityInfo *entityInfo;\n  CXCursor cursor;\n  CXIdxLoc loc;\n  const CXIdxContainerInfo *semanticContainer;\n  /**\n   * Generally same as #semanticContainer but can be different in\n   * cases like out-of-line C++ member functions.\n   */\n  const CXIdxContainerInfo *lexicalContainer;\n  int isRedeclaration;\n  int isDefinition;\n  int isContainer;\n  const CXIdxContainerInfo *declAsContainer;\n  /**\n   * Whether the declaration exists in code or was created implicitly\n   * by the compiler, e.g. implicit Objective-C methods for properties.\n   */\n  int isImplicit;\n  const CXIdxAttrInfo *const *attributes;\n  unsigned numAttributes;\n\n  unsigned flags;\n\n} CXIdxDeclInfo;\n\ntypedef enum {\n  CXIdxObjCContainer_ForwardRef = 0,\n  CXIdxObjCContainer_Interface = 1,\n  CXIdxObjCContainer_Implementation = 2\n} CXIdxObjCContainerKind;\n\ntypedef struct {\n  const CXIdxDeclInfo *declInfo;\n  CXIdxObjCContainerKind kind;\n} CXIdxObjCContainerDeclInfo;\n\ntypedef struct {\n  const CXIdxEntityInfo *base;\n  CXCursor cursor;\n  CXIdxLoc loc;\n} CXIdxBaseClassInfo;\n\ntypedef struct {\n  const CXIdxEntityInfo *protocol;\n  CXCursor cursor;\n  CXIdxLoc loc;\n} CXIdxObjCProtocolRefInfo;\n\ntypedef struct {\n  const CXIdxObjCProtocolRefInfo *const *protocols;\n  unsigned numProtocols;\n} CXIdxObjCProtocolRefListInfo;\n\ntypedef struct {\n  const CXIdxObjCContainerDeclInfo *containerInfo;\n  const CXIdxBaseClassInfo *superInfo;\n  const CXIdxObjCProtocolRefListInfo *protocols;\n} CXIdxObjCInterfaceDeclInfo;\n\ntypedef struct {\n  const CXIdxObjCContainerDeclInfo *containerInfo;\n  const CXIdxEntityInfo *objcClass;\n  CXCursor classCursor;\n  CXIdxLoc classLoc;\n  const CXIdxObjCProtocolRefListInfo *protocols;\n} CXIdxObjCCategoryDeclInfo;\n\ntypedef struct {\n  const CXIdxDeclInfo *declInfo;\n  const CXIdxEntityInfo *getter;\n  const CXIdxEntityInfo *setter;\n} CXIdxObjCPropertyDeclInfo;\n\ntypedef struct {\n  const CXIdxDeclInfo *declInfo;\n  const CXIdxBaseClassInfo *const *bases;\n  unsigned numBases;\n} CXIdxCXXClassDeclInfo;\n\n/**\n * Data for IndexerCallbacks#indexEntityReference.\n *\n * This may be deprecated in a future version as this duplicates\n * the \\c CXSymbolRole_Implicit bit in \\c CXSymbolRole.\n */\ntypedef enum {\n  /**\n   * The entity is referenced directly in user's code.\n   */\n  CXIdxEntityRef_Direct = 1,\n  /**\n   * An implicit reference, e.g. a reference of an Objective-C method\n   * via the dot syntax.\n   */\n  CXIdxEntityRef_Implicit = 2\n} CXIdxEntityRefKind;\n\n/**\n * Roles that are attributed to symbol occurrences.\n *\n * Internal: this currently mirrors low 9 bits of clang::index::SymbolRole with\n * higher bits zeroed. These high bits may be exposed in the future.\n */\ntypedef enum {\n  CXSymbolRole_None = 0,\n  CXSymbolRole_Declaration = 1 << 0,\n  CXSymbolRole_Definition = 1 << 1,\n  CXSymbolRole_Reference = 1 << 2,\n  CXSymbolRole_Read = 1 << 3,\n  CXSymbolRole_Write = 1 << 4,\n  CXSymbolRole_Call = 1 << 5,\n  CXSymbolRole_Dynamic = 1 << 6,\n  CXSymbolRole_AddressOf = 1 << 7,\n  CXSymbolRole_Implicit = 1 << 8\n} CXSymbolRole;\n\n/**\n * Data for IndexerCallbacks#indexEntityReference.\n */\ntypedef struct {\n  CXIdxEntityRefKind kind;\n  /**\n   * Reference cursor.\n   */\n  CXCursor cursor;\n  CXIdxLoc loc;\n  /**\n   * The entity that gets referenced.\n   */\n  const CXIdxEntityInfo *referencedEntity;\n  /**\n   * Immediate \"parent\" of the reference. For example:\n   *\n   * \\code\n   * Foo *var;\n   * \\endcode\n   *\n   * The parent of reference of type 'Foo' is the variable 'var'.\n   * For references inside statement bodies of functions/methods,\n   * the parentEntity will be the function/method.\n   */\n  const CXIdxEntityInfo *parentEntity;\n  /**\n   * Lexical container context of the reference.\n   */\n  const CXIdxContainerInfo *container;\n  /**\n   * Sets of symbol roles of the reference.\n   */\n  CXSymbolRole role;\n} CXIdxEntityRefInfo;\n\n/**\n * A group of callbacks used by #clang_indexSourceFile and\n * #clang_indexTranslationUnit.\n */\ntypedef struct {\n  /**\n   * Called periodically to check whether indexing should be aborted.\n   * Should return 0 to continue, and non-zero to abort.\n   */\n  int (*abortQuery)(CXClientData client_data, void *reserved);\n\n  /**\n   * Called at the end of indexing; passes the complete diagnostic set.\n   */\n  void (*diagnostic)(CXClientData client_data, CXDiagnosticSet, void *reserved);\n\n  CXIdxClientFile (*enteredMainFile)(CXClientData client_data, CXFile mainFile,\n                                     void *reserved);\n\n  /**\n   * Called when a file gets \\#included/\\#imported.\n   */\n  CXIdxClientFile (*ppIncludedFile)(CXClientData client_data,\n                                    const CXIdxIncludedFileInfo *);\n\n  /**\n   * Called when a AST file (PCH or module) gets imported.\n   *\n   * AST files will not get indexed (there will not be callbacks to index all\n   * the entities in an AST file). The recommended action is that, if the AST\n   * file is not already indexed, to initiate a new indexing job specific to\n   * the AST file.\n   */\n  CXIdxClientASTFile (*importedASTFile)(CXClientData client_data,\n                                        const CXIdxImportedASTFileInfo *);\n\n  /**\n   * Called at the beginning of indexing a translation unit.\n   */\n  CXIdxClientContainer (*startedTranslationUnit)(CXClientData client_data,\n                                                 void *reserved);\n\n  void (*indexDeclaration)(CXClientData client_data, const CXIdxDeclInfo *);\n\n  /**\n   * Called to index a reference of an entity.\n   */\n  void (*indexEntityReference)(CXClientData client_data,\n                               const CXIdxEntityRefInfo *);\n\n} IndexerCallbacks;\n\nCINDEX_LINKAGE int clang_index_isEntityObjCContainerKind(CXIdxEntityKind);\nCINDEX_LINKAGE const CXIdxObjCContainerDeclInfo *\nclang_index_getObjCContainerDeclInfo(const CXIdxDeclInfo *);\n\nCINDEX_LINKAGE const CXIdxObjCInterfaceDeclInfo *\nclang_index_getObjCInterfaceDeclInfo(const CXIdxDeclInfo *);\n\nCINDEX_LINKAGE\nconst CXIdxObjCCategoryDeclInfo *\nclang_index_getObjCCategoryDeclInfo(const CXIdxDeclInfo *);\n\nCINDEX_LINKAGE const CXIdxObjCProtocolRefListInfo *\nclang_index_getObjCProtocolRefListInfo(const CXIdxDeclInfo *);\n\nCINDEX_LINKAGE const CXIdxObjCPropertyDeclInfo *\nclang_index_getObjCPropertyDeclInfo(const CXIdxDeclInfo *);\n\nCINDEX_LINKAGE const CXIdxIBOutletCollectionAttrInfo *\nclang_index_getIBOutletCollectionAttrInfo(const CXIdxAttrInfo *);\n\nCINDEX_LINKAGE const CXIdxCXXClassDeclInfo *\nclang_index_getCXXClassDeclInfo(const CXIdxDeclInfo *);\n\n/**\n * For retrieving a custom CXIdxClientContainer attached to a\n * container.\n */\nCINDEX_LINKAGE CXIdxClientContainer\nclang_index_getClientContainer(const CXIdxContainerInfo *);\n\n/**\n * For setting a custom CXIdxClientContainer attached to a\n * container.\n */\nCINDEX_LINKAGE void clang_index_setClientContainer(const CXIdxContainerInfo *,\n                                                   CXIdxClientContainer);\n\n/**\n * For retrieving a custom CXIdxClientEntity attached to an entity.\n */\nCINDEX_LINKAGE CXIdxClientEntity\nclang_index_getClientEntity(const CXIdxEntityInfo *);\n\n/**\n * For setting a custom CXIdxClientEntity attached to an entity.\n */\nCINDEX_LINKAGE void clang_index_setClientEntity(const CXIdxEntityInfo *,\n                                                CXIdxClientEntity);\n\n/**\n * An indexing action/session, to be applied to one or multiple\n * translation units.\n */\ntypedef void *CXIndexAction;\n\n/**\n * An indexing action/session, to be applied to one or multiple\n * translation units.\n *\n * \\param CIdx The index object with which the index action will be associated.\n */\nCINDEX_LINKAGE CXIndexAction clang_IndexAction_create(CXIndex CIdx);\n\n/**\n * Destroy the given index action.\n *\n * The index action must not be destroyed until all of the translation units\n * created within that index action have been destroyed.\n */\nCINDEX_LINKAGE void clang_IndexAction_dispose(CXIndexAction);\n\ntypedef enum {\n  /**\n   * Used to indicate that no special indexing options are needed.\n   */\n  CXIndexOpt_None = 0x0,\n\n  /**\n   * Used to indicate that IndexerCallbacks#indexEntityReference should\n   * be invoked for only one reference of an entity per source file that does\n   * not also include a declaration/definition of the entity.\n   */\n  CXIndexOpt_SuppressRedundantRefs = 0x1,\n\n  /**\n   * Function-local symbols should be indexed. If this is not set\n   * function-local symbols will be ignored.\n   */\n  CXIndexOpt_IndexFunctionLocalSymbols = 0x2,\n\n  /**\n   * Implicit function/class template instantiations should be indexed.\n   * If this is not set, implicit instantiations will be ignored.\n   */\n  CXIndexOpt_IndexImplicitTemplateInstantiations = 0x4,\n\n  /**\n   * Suppress all compiler warnings when parsing for indexing.\n   */\n  CXIndexOpt_SuppressWarnings = 0x8,\n\n  /**\n   * Skip a function/method body that was already parsed during an\n   * indexing session associated with a \\c CXIndexAction object.\n   * Bodies in system headers are always skipped.\n   */\n  CXIndexOpt_SkipParsedBodiesInSession = 0x10\n\n} CXIndexOptFlags;\n\n/**\n * Index the given source file and the translation unit corresponding\n * to that file via callbacks implemented through #IndexerCallbacks.\n *\n * \\param client_data pointer data supplied by the client, which will\n * be passed to the invoked callbacks.\n *\n * \\param index_callbacks Pointer to indexing callbacks that the client\n * implements.\n *\n * \\param index_callbacks_size Size of #IndexerCallbacks structure that gets\n * passed in index_callbacks.\n *\n * \\param index_options A bitmask of options that affects how indexing is\n * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.\n *\n * \\param[out] out_TU pointer to store a \\c CXTranslationUnit that can be\n * reused after indexing is finished. Set to \\c NULL if you do not require it.\n *\n * \\returns 0 on success or if there were errors from which the compiler could\n * recover.  If there is a failure from which there is no recovery, returns\n * a non-zero \\c CXErrorCode.\n *\n * The rest of the parameters are the same as #clang_parseTranslationUnit.\n */\nCINDEX_LINKAGE int clang_indexSourceFile(\n    CXIndexAction, CXClientData client_data, IndexerCallbacks *index_callbacks,\n    unsigned index_callbacks_size, unsigned index_options,\n    const char *source_filename, const char *const *command_line_args,\n    int num_command_line_args, struct CXUnsavedFile *unsaved_files,\n    unsigned num_unsaved_files, CXTranslationUnit *out_TU, unsigned TU_options);\n\n/**\n * Same as clang_indexSourceFile but requires a full command line\n * for \\c command_line_args including argv[0]. This is useful if the standard\n * library paths are relative to the binary.\n */\nCINDEX_LINKAGE int clang_indexSourceFileFullArgv(\n    CXIndexAction, CXClientData client_data, IndexerCallbacks *index_callbacks,\n    unsigned index_callbacks_size, unsigned index_options,\n    const char *source_filename, const char *const *command_line_args,\n    int num_command_line_args, struct CXUnsavedFile *unsaved_files,\n    unsigned num_unsaved_files, CXTranslationUnit *out_TU, unsigned TU_options);\n\n/**\n * Index the given translation unit via callbacks implemented through\n * #IndexerCallbacks.\n *\n * The order of callback invocations is not guaranteed to be the same as\n * when indexing a source file. The high level order will be:\n *\n *   -Preprocessor callbacks invocations\n *   -Declaration/reference callbacks invocations\n *   -Diagnostic callback invocations\n *\n * The parameters are the same as #clang_indexSourceFile.\n *\n * \\returns If there is a failure from which there is no recovery, returns\n * non-zero, otherwise returns 0.\n */\nCINDEX_LINKAGE int clang_indexTranslationUnit(\n    CXIndexAction, CXClientData client_data, IndexerCallbacks *index_callbacks,\n    unsigned index_callbacks_size, unsigned index_options, CXTranslationUnit);\n\n/**\n * Retrieve the CXIdxFile, file, line, column, and offset represented by\n * the given CXIdxLoc.\n *\n * If the location refers into a macro expansion, retrieves the\n * location of the macro expansion and if it refers into a macro argument\n * retrieves the location of the argument.\n */\nCINDEX_LINKAGE void clang_indexLoc_getFileLocation(CXIdxLoc loc,\n                                                   CXIdxClientFile *indexFile,\n                                                   CXFile *file, unsigned *line,\n                                                   unsigned *column,\n                                                   unsigned *offset);\n\n/**\n * Retrieve the CXSourceLocation represented by the given CXIdxLoc.\n */\nCINDEX_LINKAGE\nCXSourceLocation clang_indexLoc_getCXSourceLocation(CXIdxLoc loc);\n\n/**\n * Visitor invoked for each field found by a traversal.\n *\n * This visitor function will be invoked for each field found by\n * \\c clang_Type_visitFields. Its first argument is the cursor being\n * visited, its second argument is the client data provided to\n * \\c clang_Type_visitFields.\n *\n * The visitor should return one of the \\c CXVisitorResult values\n * to direct \\c clang_Type_visitFields.\n */\ntypedef enum CXVisitorResult (*CXFieldVisitor)(CXCursor C,\n                                               CXClientData client_data);\n\n/**\n * Visit the fields of a particular type.\n *\n * This function visits all the direct fields of the given cursor,\n * invoking the given \\p visitor function with the cursors of each\n * visited field. The traversal may be ended prematurely, if\n * the visitor returns \\c CXFieldVisit_Break.\n *\n * \\param T the record type whose field may be visited.\n *\n * \\param visitor the visitor function that will be invoked for each\n * field of \\p T.\n *\n * \\param client_data pointer data supplied by the client, which will\n * be passed to the visitor each time it is invoked.\n *\n * \\returns a non-zero value if the traversal was terminated\n * prematurely by the visitor returning \\c CXFieldVisit_Break.\n */\nCINDEX_LINKAGE unsigned clang_Type_visitFields(CXType T, CXFieldVisitor visitor,\n                                               CXClientData client_data);\n\n/**\n * @}\n */\n\n/**\n * @}\n */\n\nLLVM_CLANG_C_EXTERN_C_END\n\n#endif\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TypeLoc.h", "content": "//===- TypeLoc.h - Type Source Info Wrapper ---------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::TypeLoc interface and its subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_TYPELOC_H\n#define LLVM_CLANG_AST_TYPELOC_H\n\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <cstring>\n\nnamespace clang {\n\nclass Attr;\nclass ASTContext;\nclass CXXRecordDecl;\nclass ConceptDecl;\nclass Expr;\nclass ObjCInterfaceDecl;\nclass ObjCProtocolDecl;\nclass ObjCTypeParamDecl;\nclass ParmVarDecl;\nclass TemplateTypeParmDecl;\nclass UnqualTypeLoc;\nclass UnresolvedUsingTypenameDecl;\n\n// Predeclare all the type nodes.\n#define ABSTRACT_TYPELOC(Class, Base)\n#define TYPELOC(Class, Base) \\\n  class Class##TypeLoc;\n#include \"clang/AST/TypeLocNodes.def\"\n\n/// Base wrapper for a particular \"section\" of type source info.\n///\n/// A client should use the TypeLoc subclasses through castAs()/getAs()\n/// in order to get at the actual information.\nclass TypeLoc {\nprotected:\n  // The correctness of this relies on the property that, for Type *Ty,\n  //   QualType(Ty, 0).getAsOpaquePtr() == (void*) Ty\n  const void *Ty = nullptr;\n  void *Data = nullptr;\n\npublic:\n  TypeLoc() = default;\n  TypeLoc(QualType ty, void *opaqueData)\n      : Ty(ty.getAsOpaquePtr()), Data(opaqueData) {}\n  TypeLoc(const Type *ty, void *opaqueData)\n      : Ty(ty), Data(opaqueData) {}\n\n  /// Convert to the specified TypeLoc type, asserting that this TypeLoc\n  /// is of the desired type.\n  ///\n  /// \\pre T::isKind(*this)\n  template<typename T>\n  T castAs() const {\n    assert(T::isKind(*this));\n    T t;\n    TypeLoc& tl = t;\n    tl = *this;\n    return t;\n  }\n\n  /// Convert to the specified TypeLoc type, returning a null TypeLoc if\n  /// this TypeLoc is not of the desired type.\n  template<typename T>\n  T getAs() const {\n    if (!T::isKind(*this))\n      return {};\n    T t;\n    TypeLoc& tl = t;\n    tl = *this;\n    return t;\n  }\n\n  /// Convert to the specified TypeLoc type, returning a null TypeLoc if\n  /// this TypeLoc is not of the desired type. It will consider type\n  /// adjustments from a type that was written as a T to another type that is\n  /// still canonically a T (ignores parens, attributes, elaborated types, etc).\n  template <typename T>\n  T getAsAdjusted() const;\n\n  /// The kinds of TypeLocs.  Equivalent to the Type::TypeClass enum,\n  /// except it also defines a Qualified enum that corresponds to the\n  /// QualifiedLoc class.\n  enum TypeLocClass {\n#define ABSTRACT_TYPE(Class, Base)\n#define TYPE(Class, Base) \\\n    Class = Type::Class,\n#include \"clang/AST/TypeNodes.inc\"\n    Qualified\n  };\n\n  TypeLocClass getTypeLocClass() const {\n    if (getType().hasLocalQualifiers()) return Qualified;\n    return (TypeLocClass) getType()->getTypeClass();\n  }\n\n  bool isNull() const { return !Ty; }\n  explicit operator bool() const { return Ty; }\n\n  /// Returns the size of type source info data block for the given type.\n  static unsigned getFullDataSizeForType(QualType Ty);\n\n  /// Returns the alignment of type source info data block for\n  /// the given type.\n  static unsigned getLocalAlignmentForType(QualType Ty);\n\n  /// Get the type for which this source info wrapper provides\n  /// information.\n  QualType getType() const {\n    return QualType::getFromOpaquePtr(Ty);\n  }\n\n  const Type *getTypePtr() const {\n    return QualType::getFromOpaquePtr(Ty).getTypePtr();\n  }\n\n  /// Get the pointer where source information is stored.\n  void *getOpaqueData() const {\n    return Data;\n  }\n\n  /// Get the begin source location.\n  SourceLocation getBeginLoc() const;\n\n  /// Get the end source location.\n  SourceLocation getEndLoc() const;\n\n  /// Get the full source range.\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(getBeginLoc(), getEndLoc());\n  }\n\n\n  /// Get the local source range.\n  SourceRange getLocalSourceRange() const {\n    return getLocalSourceRangeImpl(*this);\n  }\n\n  /// Returns the size of the type source info data block.\n  unsigned getFullDataSize() const {\n    return getFullDataSizeForType(getType());\n  }\n\n  /// Get the next TypeLoc pointed by this TypeLoc, e.g for \"int*\" the\n  /// TypeLoc is a PointerLoc and next TypeLoc is for \"int\".\n  TypeLoc getNextTypeLoc() const {\n    return getNextTypeLocImpl(*this);\n  }\n\n  /// Skips past any qualifiers, if this is qualified.\n  UnqualTypeLoc getUnqualifiedLoc() const; // implemented in this header\n\n  TypeLoc IgnoreParens() const;\n\n  /// Find a type with the location of an explicit type qualifier.\n  ///\n  /// The result, if non-null, will be one of:\n  ///   QualifiedTypeLoc\n  ///   AtomicTypeLoc\n  ///   AttributedTypeLoc, for those type attributes that behave as qualifiers\n  TypeLoc findExplicitQualifierLoc() const;\n\n  /// Get the typeloc of an AutoType whose type will be deduced for a variable\n  /// with an initializer of this type. This looks through declarators like\n  /// pointer types, but not through decltype or typedefs.\n  AutoTypeLoc getContainedAutoTypeLoc() const;\n\n  /// Initializes this to state that every location in this\n  /// type is the given location.\n  ///\n  /// This method exists to provide a simple transition for code that\n  /// relies on location-less types.\n  void initialize(ASTContext &Context, SourceLocation Loc) const {\n    initializeImpl(Context, *this, Loc);\n  }\n\n  /// Initializes this by copying its information from another\n  /// TypeLoc of the same type.\n  void initializeFullCopy(TypeLoc Other) {\n    assert(getType() == Other.getType());\n    copy(Other);\n  }\n\n  /// Initializes this by copying its information from another\n  /// TypeLoc of the same type.  The given size must be the full data\n  /// size.\n  void initializeFullCopy(TypeLoc Other, unsigned Size) {\n    assert(getType() == Other.getType());\n    assert(getFullDataSize() == Size);\n    copy(Other);\n  }\n\n  /// Copies the other type loc into this one.\n  void copy(TypeLoc other);\n\n  friend bool operator==(const TypeLoc &LHS, const TypeLoc &RHS) {\n    return LHS.Ty == RHS.Ty && LHS.Data == RHS.Data;\n  }\n\n  friend bool operator!=(const TypeLoc &LHS, const TypeLoc &RHS) {\n    return !(LHS == RHS);\n  }\n\n  /// Find the location of the nullability specifier (__nonnull,\n  /// __nullable, or __null_unspecifier), if there is one.\n  SourceLocation findNullabilityLoc() const;\n\nprivate:\n  static bool isKind(const TypeLoc&) {\n    return true;\n  }\n\n  static void initializeImpl(ASTContext &Context, TypeLoc TL,\n                             SourceLocation Loc);\n  static TypeLoc getNextTypeLocImpl(TypeLoc TL);\n  static TypeLoc IgnoreParensImpl(TypeLoc TL);\n  static SourceRange getLocalSourceRangeImpl(TypeLoc TL);\n};\n\n/// Return the TypeLoc for a type source info.\ninline TypeLoc TypeSourceInfo::getTypeLoc() const {\n  // TODO: is this alignment already sufficient?\n  return TypeLoc(Ty, const_cast<void*>(static_cast<const void*>(this + 1)));\n}\n\n/// Wrapper of type source information for a type with\n/// no direct qualifiers.\nclass UnqualTypeLoc : public TypeLoc {\npublic:\n  UnqualTypeLoc() = default;\n  UnqualTypeLoc(const Type *Ty, void *Data) : TypeLoc(Ty, Data) {}\n\n  const Type *getTypePtr() const {\n    return reinterpret_cast<const Type*>(Ty);\n  }\n\n  TypeLocClass getTypeLocClass() const {\n    return (TypeLocClass) getTypePtr()->getTypeClass();\n  }\n\nprivate:\n  friend class TypeLoc;\n\n  static bool isKind(const TypeLoc &TL) {\n    return !TL.getType().hasLocalQualifiers();\n  }\n};\n\n/// Wrapper of type source information for a type with\n/// non-trivial direct qualifiers.\n///\n/// Currently, we intentionally do not provide source location for\n/// type qualifiers.\nclass QualifiedTypeLoc : public TypeLoc {\npublic:\n  SourceRange getLocalSourceRange() const { return {}; }\n\n  UnqualTypeLoc getUnqualifiedLoc() const {\n    unsigned align =\n        TypeLoc::getLocalAlignmentForType(QualType(getTypePtr(), 0));\n    auto dataInt = reinterpret_cast<uintptr_t>(Data);\n    dataInt = llvm::alignTo(dataInt, align);\n    return UnqualTypeLoc(getTypePtr(), reinterpret_cast<void*>(dataInt));\n  }\n\n  /// Initializes the local data of this type source info block to\n  /// provide no information.\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    // do nothing\n  }\n\n  void copyLocal(TypeLoc other) {\n    // do nothing\n  }\n\n  TypeLoc getNextTypeLoc() const {\n    return getUnqualifiedLoc();\n  }\n\n  /// Returns the size of the type source info data block that is\n  /// specific to this type.\n  unsigned getLocalDataSize() const {\n    // In fact, we don't currently preserve any location information\n    // for qualifiers.\n    return 0;\n  }\n\n  /// Returns the alignment of the type source info data block that is\n  /// specific to this type.\n  unsigned getLocalDataAlignment() const {\n    // We don't preserve any location information.\n    return 1;\n  }\n\nprivate:\n  friend class TypeLoc;\n\n  static bool isKind(const TypeLoc &TL) {\n    return TL.getType().hasLocalQualifiers();\n  }\n};\n\ninline UnqualTypeLoc TypeLoc::getUnqualifiedLoc() const {\n  if (QualifiedTypeLoc Loc = getAs<QualifiedTypeLoc>())\n    return Loc.getUnqualifiedLoc();\n  return castAs<UnqualTypeLoc>();\n}\n\n/// A metaprogramming base class for TypeLoc classes which correspond\n/// to a particular Type subclass.  It is accepted for a single\n/// TypeLoc class to correspond to multiple Type classes.\n///\n/// \\tparam Base a class from which to derive\n/// \\tparam Derived the class deriving from this one\n/// \\tparam TypeClass the concrete Type subclass associated with this\n///   location type\n/// \\tparam LocalData the structure type of local location data for\n///   this type\n///\n/// TypeLocs with non-constant amounts of local data should override\n/// getExtraLocalDataSize(); getExtraLocalData() will then point to\n/// this extra memory.\n///\n/// TypeLocs with an inner type should define\n///   QualType getInnerType() const\n/// and getInnerTypeLoc() will then point to this inner type's\n/// location data.\n///\n/// A word about hierarchies: this template is not designed to be\n/// derived from multiple times in a hierarchy.  It is also not\n/// designed to be used for classes where subtypes might provide\n/// different amounts of source information.  It should be subclassed\n/// only at the deepest portion of the hierarchy where all children\n/// have identical source information; if that's an abstract type,\n/// then further descendents should inherit from\n/// InheritingConcreteTypeLoc instead.\ntemplate <class Base, class Derived, class TypeClass, class LocalData>\nclass ConcreteTypeLoc : public Base {\n  friend class TypeLoc;\n\n  const Derived *asDerived() const {\n    return static_cast<const Derived*>(this);\n  }\n\n  static bool isKind(const TypeLoc &TL) {\n    return !TL.getType().hasLocalQualifiers() &&\n           Derived::classofType(TL.getTypePtr());\n  }\n\n  static bool classofType(const Type *Ty) {\n    return TypeClass::classof(Ty);\n  }\n\npublic:\n  unsigned getLocalDataAlignment() const {\n    return std::max(unsigned(alignof(LocalData)),\n                    asDerived()->getExtraLocalDataAlignment());\n  }\n\n  unsigned getLocalDataSize() const {\n    unsigned size = sizeof(LocalData);\n    unsigned extraAlign = asDerived()->getExtraLocalDataAlignment();\n    size = llvm::alignTo(size, extraAlign);\n    size += asDerived()->getExtraLocalDataSize();\n    return size;\n  }\n\n  void copyLocal(Derived other) {\n    // Some subclasses have no data to copy.\n    if (asDerived()->getLocalDataSize() == 0) return;\n\n    // Copy the fixed-sized local data.\n    memcpy(getLocalData(), other.getLocalData(), sizeof(LocalData));\n\n    // Copy the variable-sized local data. We need to do this\n    // separately because the padding in the source and the padding in\n    // the destination might be different.\n    memcpy(getExtraLocalData(), other.getExtraLocalData(),\n           asDerived()->getExtraLocalDataSize());\n  }\n\n  TypeLoc getNextTypeLoc() const {\n    return getNextTypeLoc(asDerived()->getInnerType());\n  }\n\n  const TypeClass *getTypePtr() const {\n    return cast<TypeClass>(Base::getTypePtr());\n  }\n\nprotected:\n  unsigned getExtraLocalDataSize() const {\n    return 0;\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return 1;\n  }\n\n  LocalData *getLocalData() const {\n    return static_cast<LocalData*>(Base::Data);\n  }\n\n  /// Gets a pointer past the Info structure; useful for classes with\n  /// local data that can't be captured in the Info (e.g. because it's\n  /// of variable size).\n  void *getExtraLocalData() const {\n    unsigned size = sizeof(LocalData);\n    unsigned extraAlign = asDerived()->getExtraLocalDataAlignment();\n    size = llvm::alignTo(size, extraAlign);\n    return reinterpret_cast<char*>(Base::Data) + size;\n  }\n\n  void *getNonLocalData() const {\n    auto data = reinterpret_cast<uintptr_t>(Base::Data);\n    data += asDerived()->getLocalDataSize();\n    data = llvm::alignTo(data, getNextTypeAlign());\n    return reinterpret_cast<void*>(data);\n  }\n\n  struct HasNoInnerType {};\n  HasNoInnerType getInnerType() const { return HasNoInnerType(); }\n\n  TypeLoc getInnerTypeLoc() const {\n    return TypeLoc(asDerived()->getInnerType(), getNonLocalData());\n  }\n\nprivate:\n  unsigned getInnerTypeSize() const {\n    return getInnerTypeSize(asDerived()->getInnerType());\n  }\n\n  unsigned getInnerTypeSize(HasNoInnerType _) const {\n    return 0;\n  }\n\n  unsigned getInnerTypeSize(QualType _) const {\n    return getInnerTypeLoc().getFullDataSize();\n  }\n\n  unsigned getNextTypeAlign() const {\n    return getNextTypeAlign(asDerived()->getInnerType());\n  }\n\n  unsigned getNextTypeAlign(HasNoInnerType _) const {\n    return 1;\n  }\n\n  unsigned getNextTypeAlign(QualType T) const {\n    return TypeLoc::getLocalAlignmentForType(T);\n  }\n\n  TypeLoc getNextTypeLoc(HasNoInnerType _) const { return {}; }\n\n  TypeLoc getNextTypeLoc(QualType T) const {\n    return TypeLoc(T, getNonLocalData());\n  }\n};\n\n/// A metaprogramming class designed for concrete subtypes of abstract\n/// types where all subtypes share equivalently-structured source\n/// information.  See the note on ConcreteTypeLoc.\ntemplate <class Base, class Derived, class TypeClass>\nclass InheritingConcreteTypeLoc : public Base {\n  friend class TypeLoc;\n\n  static bool classofType(const Type *Ty) {\n    return TypeClass::classof(Ty);\n  }\n\n  static bool isKind(const TypeLoc &TL) {\n    return !TL.getType().hasLocalQualifiers() &&\n           Derived::classofType(TL.getTypePtr());\n  }\n  static bool isKind(const UnqualTypeLoc &TL) {\n    return Derived::classofType(TL.getTypePtr());\n  }\n\npublic:\n  const TypeClass *getTypePtr() const {\n    return cast<TypeClass>(Base::getTypePtr());\n  }\n};\n\nstruct TypeSpecLocInfo {\n  SourceLocation NameLoc;\n};\n\n/// A reasonable base class for TypeLocs that correspond to\n/// types that are written as a type-specifier.\nclass TypeSpecTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                               TypeSpecTypeLoc,\n                                               Type,\n                                               TypeSpecLocInfo> {\npublic:\n  enum {\n    LocalDataSize = sizeof(TypeSpecLocInfo),\n    LocalDataAlignment = alignof(TypeSpecLocInfo)\n  };\n\n  SourceLocation getNameLoc() const {\n    return this->getLocalData()->NameLoc;\n  }\n\n  void setNameLoc(SourceLocation Loc) {\n    this->getLocalData()->NameLoc = Loc;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getNameLoc(), getNameLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setNameLoc(Loc);\n  }\n\nprivate:\n  friend class TypeLoc;\n\n  static bool isKind(const TypeLoc &TL);\n};\n\nstruct BuiltinLocInfo {\n  SourceRange BuiltinRange;\n};\n\n/// Wrapper for source info for builtin types.\nclass BuiltinTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                              BuiltinTypeLoc,\n                                              BuiltinType,\n                                              BuiltinLocInfo> {\npublic:\n  SourceLocation getBuiltinLoc() const {\n    return getLocalData()->BuiltinRange.getBegin();\n  }\n\n  void setBuiltinLoc(SourceLocation Loc) {\n    getLocalData()->BuiltinRange = Loc;\n  }\n\n  void expandBuiltinRange(SourceRange Range) {\n    SourceRange &BuiltinRange = getLocalData()->BuiltinRange;\n    if (!BuiltinRange.getBegin().isValid()) {\n      BuiltinRange = Range;\n    } else {\n      BuiltinRange.setBegin(std::min(Range.getBegin(), BuiltinRange.getBegin()));\n      BuiltinRange.setEnd(std::max(Range.getEnd(), BuiltinRange.getEnd()));\n    }\n  }\n\n  SourceLocation getNameLoc() const { return getBuiltinLoc(); }\n\n  WrittenBuiltinSpecs& getWrittenBuiltinSpecs() {\n    return *(static_cast<WrittenBuiltinSpecs*>(getExtraLocalData()));\n  }\n  const WrittenBuiltinSpecs& getWrittenBuiltinSpecs() const {\n    return *(static_cast<WrittenBuiltinSpecs*>(getExtraLocalData()));\n  }\n\n  bool needsExtraLocalData() const {\n    BuiltinType::Kind bk = getTypePtr()->getKind();\n    return (bk >= BuiltinType::UShort && bk <= BuiltinType::UInt128)\n      || (bk >= BuiltinType::Short && bk <= BuiltinType::Float128)\n      || bk == BuiltinType::UChar\n      || bk == BuiltinType::SChar;\n  }\n\n  unsigned getExtraLocalDataSize() const {\n    return needsExtraLocalData() ? sizeof(WrittenBuiltinSpecs) : 0;\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return needsExtraLocalData() ? alignof(WrittenBuiltinSpecs) : 1;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return getLocalData()->BuiltinRange;\n  }\n\n  TypeSpecifierSign getWrittenSignSpec() const {\n    if (needsExtraLocalData())\n      return static_cast<TypeSpecifierSign>(getWrittenBuiltinSpecs().Sign);\n    else\n      return TypeSpecifierSign::Unspecified;\n  }\n\n  bool hasWrittenSignSpec() const {\n    return getWrittenSignSpec() != TypeSpecifierSign::Unspecified;\n  }\n\n  void setWrittenSignSpec(TypeSpecifierSign written) {\n    if (needsExtraLocalData())\n      getWrittenBuiltinSpecs().Sign = static_cast<unsigned>(written);\n  }\n\n  TypeSpecifierWidth getWrittenWidthSpec() const {\n    if (needsExtraLocalData())\n      return static_cast<TypeSpecifierWidth>(getWrittenBuiltinSpecs().Width);\n    else\n      return TypeSpecifierWidth::Unspecified;\n  }\n\n  bool hasWrittenWidthSpec() const {\n    return getWrittenWidthSpec() != TypeSpecifierWidth::Unspecified;\n  }\n\n  void setWrittenWidthSpec(TypeSpecifierWidth written) {\n    if (needsExtraLocalData())\n      getWrittenBuiltinSpecs().Width = static_cast<unsigned>(written);\n  }\n\n  TypeSpecifierType getWrittenTypeSpec() const;\n\n  bool hasWrittenTypeSpec() const {\n    return getWrittenTypeSpec() != TST_unspecified;\n  }\n\n  void setWrittenTypeSpec(TypeSpecifierType written) {\n    if (needsExtraLocalData())\n      getWrittenBuiltinSpecs().Type = written;\n  }\n\n  bool hasModeAttr() const {\n    if (needsExtraLocalData())\n      return getWrittenBuiltinSpecs().ModeAttr;\n    else\n      return false;\n  }\n\n  void setModeAttr(bool written) {\n    if (needsExtraLocalData())\n      getWrittenBuiltinSpecs().ModeAttr = written;\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setBuiltinLoc(Loc);\n    if (needsExtraLocalData()) {\n      WrittenBuiltinSpecs &wbs = getWrittenBuiltinSpecs();\n      wbs.Sign = static_cast<unsigned>(TypeSpecifierSign::Unspecified);\n      wbs.Width = static_cast<unsigned>(TypeSpecifierWidth::Unspecified);\n      wbs.Type = TST_unspecified;\n      wbs.ModeAttr = false;\n    }\n  }\n};\n\n/// Wrapper for source info for typedefs.\nclass TypedefTypeLoc : public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                                        TypedefTypeLoc,\n                                                        TypedefType> {\npublic:\n  TypedefNameDecl *getTypedefNameDecl() const {\n    return getTypePtr()->getDecl();\n  }\n};\n\n/// Wrapper for source info for injected class names of class\n/// templates.\nclass InjectedClassNameTypeLoc :\n    public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                     InjectedClassNameTypeLoc,\n                                     InjectedClassNameType> {\npublic:\n  CXXRecordDecl *getDecl() const {\n    return getTypePtr()->getDecl();\n  }\n};\n\n/// Wrapper for source info for unresolved typename using decls.\nclass UnresolvedUsingTypeLoc :\n    public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                     UnresolvedUsingTypeLoc,\n                                     UnresolvedUsingType> {\npublic:\n  UnresolvedUsingTypenameDecl *getDecl() const {\n    return getTypePtr()->getDecl();\n  }\n};\n\n/// Wrapper for source info for tag types.  Note that this only\n/// records source info for the name itself; a type written 'struct foo'\n/// should be represented as an ElaboratedTypeLoc.  We currently\n/// only do that when C++ is enabled because of the expense of\n/// creating an ElaboratedType node for so many type references in C.\nclass TagTypeLoc : public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                                    TagTypeLoc,\n                                                    TagType> {\npublic:\n  TagDecl *getDecl() const { return getTypePtr()->getDecl(); }\n\n  /// True if the tag was defined in this type specifier.\n  bool isDefinition() const;\n};\n\n/// Wrapper for source info for record types.\nclass RecordTypeLoc : public InheritingConcreteTypeLoc<TagTypeLoc,\n                                                       RecordTypeLoc,\n                                                       RecordType> {\npublic:\n  RecordDecl *getDecl() const { return getTypePtr()->getDecl(); }\n};\n\n/// Wrapper for source info for enum types.\nclass EnumTypeLoc : public InheritingConcreteTypeLoc<TagTypeLoc,\n                                                     EnumTypeLoc,\n                                                     EnumType> {\npublic:\n  EnumDecl *getDecl() const { return getTypePtr()->getDecl(); }\n};\n\n/// Wrapper for template type parameters.\nclass TemplateTypeParmTypeLoc :\n    public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                     TemplateTypeParmTypeLoc,\n                                     TemplateTypeParmType> {\npublic:\n  TemplateTypeParmDecl *getDecl() const { return getTypePtr()->getDecl(); }\n};\n\nstruct ObjCTypeParamTypeLocInfo {\n  SourceLocation NameLoc;\n};\n\n/// ProtocolLAngleLoc, ProtocolRAngleLoc, and the source locations for\n/// protocol qualifiers are stored after Info.\nclass ObjCTypeParamTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                     ObjCTypeParamTypeLoc,\n                                     ObjCTypeParamType,\n                                     ObjCTypeParamTypeLocInfo> {\n  // SourceLocations are stored after Info, one for each protocol qualifier.\n  SourceLocation *getProtocolLocArray() const {\n    return (SourceLocation*)this->getExtraLocalData() + 2;\n  }\n\npublic:\n  ObjCTypeParamDecl *getDecl() const { return getTypePtr()->getDecl(); }\n\n  SourceLocation getNameLoc() const {\n    return this->getLocalData()->NameLoc;\n  }\n\n  void setNameLoc(SourceLocation Loc) {\n    this->getLocalData()->NameLoc = Loc;\n  }\n\n  SourceLocation getProtocolLAngleLoc() const {\n    return getNumProtocols()  ?\n      *((SourceLocation*)this->getExtraLocalData()) :\n      SourceLocation();\n  }\n\n  void setProtocolLAngleLoc(SourceLocation Loc) {\n    *((SourceLocation*)this->getExtraLocalData()) = Loc;\n  }\n\n  SourceLocation getProtocolRAngleLoc() const {\n    return getNumProtocols()  ?\n      *((SourceLocation*)this->getExtraLocalData() + 1) :\n      SourceLocation();\n  }\n\n  void setProtocolRAngleLoc(SourceLocation Loc) {\n    *((SourceLocation*)this->getExtraLocalData() + 1) = Loc;\n  }\n\n  unsigned getNumProtocols() const {\n    return this->getTypePtr()->getNumProtocols();\n  }\n\n  SourceLocation getProtocolLoc(unsigned i) const {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    return getProtocolLocArray()[i];\n  }\n\n  void setProtocolLoc(unsigned i, SourceLocation Loc) {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    getProtocolLocArray()[i] = Loc;\n  }\n\n  ObjCProtocolDecl *getProtocol(unsigned i) const {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    return *(this->getTypePtr()->qual_begin() + i);\n  }\n\n  ArrayRef<SourceLocation> getProtocolLocs() const {\n    return llvm::makeArrayRef(getProtocolLocArray(), getNumProtocols());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n\n  unsigned getExtraLocalDataSize() const {\n    if (!this->getNumProtocols()) return 0;\n    // When there are protocol qualifers, we have LAngleLoc and RAngleLoc\n    // as well.\n    return (this->getNumProtocols() + 2) * sizeof(SourceLocation) ;\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return alignof(SourceLocation);\n  }\n\n  SourceRange getLocalSourceRange() const {\n    SourceLocation start = getNameLoc();\n    SourceLocation end = getProtocolRAngleLoc();\n    if (end.isInvalid()) return SourceRange(start, start);\n    return SourceRange(start, end);\n  }\n};\n\n/// Wrapper for substituted template type parameters.\nclass SubstTemplateTypeParmTypeLoc :\n    public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                     SubstTemplateTypeParmTypeLoc,\n                                     SubstTemplateTypeParmType> {\n};\n\n  /// Wrapper for substituted template type parameters.\nclass SubstTemplateTypeParmPackTypeLoc :\n    public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                     SubstTemplateTypeParmPackTypeLoc,\n                                     SubstTemplateTypeParmPackType> {\n};\n\nstruct AttributedLocInfo {\n  const Attr *TypeAttr;\n};\n\n/// Type source information for an attributed type.\nclass AttributedTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                                 AttributedTypeLoc,\n                                                 AttributedType,\n                                                 AttributedLocInfo> {\npublic:\n  attr::Kind getAttrKind() const {\n    return getTypePtr()->getAttrKind();\n  }\n\n  bool isQualifier() const {\n    return getTypePtr()->isQualifier();\n  }\n\n  /// The modified type, which is generally canonically different from\n  /// the attribute type.\n  ///    int main(int, char**) __attribute__((noreturn))\n  ///    ~~~     ~~~~~~~~~~~~~\n  TypeLoc getModifiedLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  /// The type attribute.\n  const Attr *getAttr() const {\n    return getLocalData()->TypeAttr;\n  }\n  void setAttr(const Attr *A) {\n    getLocalData()->TypeAttr = A;\n  }\n\n  template<typename T> const T *getAttrAs() {\n    return dyn_cast_or_null<T>(getAttr());\n  }\n\n  SourceRange getLocalSourceRange() const;\n\n  void initializeLocal(ASTContext &Context, SourceLocation loc) {\n    setAttr(nullptr);\n  }\n\n  QualType getInnerType() const {\n    return getTypePtr()->getModifiedType();\n  }\n};\n\nstruct ObjCObjectTypeLocInfo {\n  SourceLocation TypeArgsLAngleLoc;\n  SourceLocation TypeArgsRAngleLoc;\n  SourceLocation ProtocolLAngleLoc;\n  SourceLocation ProtocolRAngleLoc;\n  bool HasBaseTypeAsWritten;\n};\n\n// A helper class for defining ObjC TypeLocs that can qualified with\n// protocols.\n//\n// TypeClass basically has to be either ObjCInterfaceType or\n// ObjCObjectPointerType.\nclass ObjCObjectTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                                 ObjCObjectTypeLoc,\n                                                 ObjCObjectType,\n                                                 ObjCObjectTypeLocInfo> {\n  // TypeSourceInfo*'s are stored after Info, one for each type argument.\n  TypeSourceInfo **getTypeArgLocArray() const {\n    return (TypeSourceInfo**)this->getExtraLocalData();\n  }\n\n  // SourceLocations are stored after the type argument information, one for\n  // each Protocol.\n  SourceLocation *getProtocolLocArray() const {\n    return (SourceLocation*)(getTypeArgLocArray() + getNumTypeArgs());\n  }\n\npublic:\n  SourceLocation getTypeArgsLAngleLoc() const {\n    return this->getLocalData()->TypeArgsLAngleLoc;\n  }\n\n  void setTypeArgsLAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->TypeArgsLAngleLoc = Loc;\n  }\n\n  SourceLocation getTypeArgsRAngleLoc() const {\n    return this->getLocalData()->TypeArgsRAngleLoc;\n  }\n\n  void setTypeArgsRAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->TypeArgsRAngleLoc = Loc;\n  }\n\n  unsigned getNumTypeArgs() const {\n    return this->getTypePtr()->getTypeArgsAsWritten().size();\n  }\n\n  TypeSourceInfo *getTypeArgTInfo(unsigned i) const {\n    assert(i < getNumTypeArgs() && \"Index is out of bounds!\");\n    return getTypeArgLocArray()[i];\n  }\n\n  void setTypeArgTInfo(unsigned i, TypeSourceInfo *TInfo) {\n    assert(i < getNumTypeArgs() && \"Index is out of bounds!\");\n    getTypeArgLocArray()[i] = TInfo;\n  }\n\n  SourceLocation getProtocolLAngleLoc() const {\n    return this->getLocalData()->ProtocolLAngleLoc;\n  }\n\n  void setProtocolLAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->ProtocolLAngleLoc = Loc;\n  }\n\n  SourceLocation getProtocolRAngleLoc() const {\n    return this->getLocalData()->ProtocolRAngleLoc;\n  }\n\n  void setProtocolRAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->ProtocolRAngleLoc = Loc;\n  }\n\n  unsigned getNumProtocols() const {\n    return this->getTypePtr()->getNumProtocols();\n  }\n\n  SourceLocation getProtocolLoc(unsigned i) const {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    return getProtocolLocArray()[i];\n  }\n\n  void setProtocolLoc(unsigned i, SourceLocation Loc) {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    getProtocolLocArray()[i] = Loc;\n  }\n\n  ObjCProtocolDecl *getProtocol(unsigned i) const {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    return *(this->getTypePtr()->qual_begin() + i);\n  }\n\n\n  ArrayRef<SourceLocation> getProtocolLocs() const {\n    return llvm::makeArrayRef(getProtocolLocArray(), getNumProtocols());\n  }\n\n  bool hasBaseTypeAsWritten() const {\n    return getLocalData()->HasBaseTypeAsWritten;\n  }\n\n  void setHasBaseTypeAsWritten(bool HasBaseType) {\n    getLocalData()->HasBaseTypeAsWritten = HasBaseType;\n  }\n\n  TypeLoc getBaseLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    SourceLocation start = getTypeArgsLAngleLoc();\n    if (start.isInvalid())\n      start = getProtocolLAngleLoc();\n    SourceLocation end = getProtocolRAngleLoc();\n    if (end.isInvalid())\n      end = getTypeArgsRAngleLoc();\n    return SourceRange(start, end);\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n\n  unsigned getExtraLocalDataSize() const {\n    return this->getNumTypeArgs() * sizeof(TypeSourceInfo *)\n         + this->getNumProtocols() * sizeof(SourceLocation);\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    static_assert(alignof(ObjCObjectTypeLoc) >= alignof(TypeSourceInfo *),\n                  \"not enough alignment for tail-allocated data\");\n    return alignof(TypeSourceInfo *);\n  }\n\n  QualType getInnerType() const {\n    return getTypePtr()->getBaseType();\n  }\n};\n\nstruct ObjCInterfaceLocInfo {\n  SourceLocation NameLoc;\n  SourceLocation NameEndLoc;\n};\n\n/// Wrapper for source info for ObjC interfaces.\nclass ObjCInterfaceTypeLoc : public ConcreteTypeLoc<ObjCObjectTypeLoc,\n                                                    ObjCInterfaceTypeLoc,\n                                                    ObjCInterfaceType,\n                                                    ObjCInterfaceLocInfo> {\npublic:\n  ObjCInterfaceDecl *getIFaceDecl() const {\n    return getTypePtr()->getDecl();\n  }\n\n  SourceLocation getNameLoc() const {\n    return getLocalData()->NameLoc;\n  }\n\n  void setNameLoc(SourceLocation Loc) {\n    getLocalData()->NameLoc = Loc;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getNameLoc(), getNameEndLoc());\n  }\n\n  SourceLocation getNameEndLoc() const {\n    return getLocalData()->NameEndLoc;\n  }\n\n  void setNameEndLoc(SourceLocation Loc) {\n    getLocalData()->NameEndLoc = Loc;\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setNameLoc(Loc);\n    setNameEndLoc(Loc);\n  }\n};\n\nstruct MacroQualifiedLocInfo {\n  SourceLocation ExpansionLoc;\n};\n\nclass MacroQualifiedTypeLoc\n    : public ConcreteTypeLoc<UnqualTypeLoc, MacroQualifiedTypeLoc,\n                             MacroQualifiedType, MacroQualifiedLocInfo> {\npublic:\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setExpansionLoc(Loc);\n  }\n\n  TypeLoc getInnerLoc() const { return getInnerTypeLoc(); }\n\n  const IdentifierInfo *getMacroIdentifier() const {\n    return getTypePtr()->getMacroIdentifier();\n  }\n\n  SourceLocation getExpansionLoc() const {\n    return this->getLocalData()->ExpansionLoc;\n  }\n\n  void setExpansionLoc(SourceLocation Loc) {\n    this->getLocalData()->ExpansionLoc = Loc;\n  }\n\n  QualType getInnerType() const { return getTypePtr()->getUnderlyingType(); }\n\n  SourceRange getLocalSourceRange() const {\n    return getInnerLoc().getLocalSourceRange();\n  }\n};\n\nstruct ParenLocInfo {\n  SourceLocation LParenLoc;\n  SourceLocation RParenLoc;\n};\n\nclass ParenTypeLoc\n  : public ConcreteTypeLoc<UnqualTypeLoc, ParenTypeLoc, ParenType,\n                           ParenLocInfo> {\npublic:\n  SourceLocation getLParenLoc() const {\n    return this->getLocalData()->LParenLoc;\n  }\n\n  SourceLocation getRParenLoc() const {\n    return this->getLocalData()->RParenLoc;\n  }\n\n  void setLParenLoc(SourceLocation Loc) {\n    this->getLocalData()->LParenLoc = Loc;\n  }\n\n  void setRParenLoc(SourceLocation Loc) {\n    this->getLocalData()->RParenLoc = Loc;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getLParenLoc(), getRParenLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setLParenLoc(Loc);\n    setRParenLoc(Loc);\n  }\n\n  TypeLoc getInnerLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  QualType getInnerType() const {\n    return this->getTypePtr()->getInnerType();\n  }\n};\n\ninline TypeLoc TypeLoc::IgnoreParens() const {\n  if (ParenTypeLoc::isKind(*this))\n    return IgnoreParensImpl(*this);\n  return *this;\n}\n\nstruct AdjustedLocInfo {}; // Nothing.\n\nclass AdjustedTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, AdjustedTypeLoc,\n                                               AdjustedType, AdjustedLocInfo> {\npublic:\n  TypeLoc getOriginalLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    // do nothing\n  }\n\n  QualType getInnerType() const {\n    // The inner type is the undecayed type, since that's what we have source\n    // location information for.\n    return getTypePtr()->getOriginalType();\n  }\n\n  SourceRange getLocalSourceRange() const { return {}; }\n\n  unsigned getLocalDataSize() const {\n    // sizeof(AdjustedLocInfo) is 1, but we don't need its address to be unique\n    // anyway.  TypeLocBuilder can't handle data sizes of 1.\n    return 0;  // No data.\n  }\n};\n\n/// Wrapper for source info for pointers decayed from arrays and\n/// functions.\nclass DecayedTypeLoc : public InheritingConcreteTypeLoc<\n                           AdjustedTypeLoc, DecayedTypeLoc, DecayedType> {\n};\n\nstruct PointerLikeLocInfo {\n  SourceLocation StarLoc;\n};\n\n/// A base class for\ntemplate <class Derived, class TypeClass, class LocalData = PointerLikeLocInfo>\nclass PointerLikeTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, Derived,\n                                                  TypeClass, LocalData> {\npublic:\n  SourceLocation getSigilLoc() const {\n    return this->getLocalData()->StarLoc;\n  }\n\n  void setSigilLoc(SourceLocation Loc) {\n    this->getLocalData()->StarLoc = Loc;\n  }\n\n  TypeLoc getPointeeLoc() const {\n    return this->getInnerTypeLoc();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getSigilLoc(), getSigilLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n\n  QualType getInnerType() const {\n    return this->getTypePtr()->getPointeeType();\n  }\n};\n\n/// Wrapper for source info for pointers.\nclass PointerTypeLoc : public PointerLikeTypeLoc<PointerTypeLoc,\n                                                 PointerType> {\npublic:\n  SourceLocation getStarLoc() const {\n    return getSigilLoc();\n  }\n\n  void setStarLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n};\n\n/// Wrapper for source info for block pointers.\nclass BlockPointerTypeLoc : public PointerLikeTypeLoc<BlockPointerTypeLoc,\n                                                      BlockPointerType> {\npublic:\n  SourceLocation getCaretLoc() const {\n    return getSigilLoc();\n  }\n\n  void setCaretLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n};\n\nstruct MemberPointerLocInfo : public PointerLikeLocInfo {\n  TypeSourceInfo *ClassTInfo;\n};\n\n/// Wrapper for source info for member pointers.\nclass MemberPointerTypeLoc : public PointerLikeTypeLoc<MemberPointerTypeLoc,\n                                                       MemberPointerType,\n                                                       MemberPointerLocInfo> {\npublic:\n  SourceLocation getStarLoc() const {\n    return getSigilLoc();\n  }\n\n  void setStarLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n\n  const Type *getClass() const {\n    return getTypePtr()->getClass();\n  }\n\n  TypeSourceInfo *getClassTInfo() const {\n    return getLocalData()->ClassTInfo;\n  }\n\n  void setClassTInfo(TypeSourceInfo* TI) {\n    getLocalData()->ClassTInfo = TI;\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setSigilLoc(Loc);\n    setClassTInfo(nullptr);\n  }\n\n  SourceRange getLocalSourceRange() const {\n    if (TypeSourceInfo *TI = getClassTInfo())\n      return SourceRange(TI->getTypeLoc().getBeginLoc(), getStarLoc());\n    else\n      return SourceRange(getStarLoc());\n  }\n};\n\n/// Wraps an ObjCPointerType with source location information.\nclass ObjCObjectPointerTypeLoc :\n    public PointerLikeTypeLoc<ObjCObjectPointerTypeLoc,\n                              ObjCObjectPointerType> {\npublic:\n  SourceLocation getStarLoc() const {\n    return getSigilLoc();\n  }\n\n  void setStarLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n};\n\nclass ReferenceTypeLoc : public PointerLikeTypeLoc<ReferenceTypeLoc,\n                                                   ReferenceType> {\npublic:\n  QualType getInnerType() const {\n    return getTypePtr()->getPointeeTypeAsWritten();\n  }\n};\n\nclass LValueReferenceTypeLoc :\n    public InheritingConcreteTypeLoc<ReferenceTypeLoc,\n                                     LValueReferenceTypeLoc,\n                                     LValueReferenceType> {\npublic:\n  SourceLocation getAmpLoc() const {\n    return getSigilLoc();\n  }\n\n  void setAmpLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n};\n\nclass RValueReferenceTypeLoc :\n    public InheritingConcreteTypeLoc<ReferenceTypeLoc,\n                                     RValueReferenceTypeLoc,\n                                     RValueReferenceType> {\npublic:\n  SourceLocation getAmpAmpLoc() const {\n    return getSigilLoc();\n  }\n\n  void setAmpAmpLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n};\n\nstruct FunctionLocInfo {\n  SourceLocation LocalRangeBegin;\n  SourceLocation LParenLoc;\n  SourceLocation RParenLoc;\n  SourceLocation LocalRangeEnd;\n};\n\n/// Wrapper for source info for functions.\nclass FunctionTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                               FunctionTypeLoc,\n                                               FunctionType,\n                                               FunctionLocInfo> {\n  bool hasExceptionSpec() const {\n    if (auto *FPT = dyn_cast<FunctionProtoType>(getTypePtr())) {\n      return FPT->hasExceptionSpec();\n    }\n    return false;\n  }\n\n  SourceRange *getExceptionSpecRangePtr() const {\n    assert(hasExceptionSpec() && \"No exception spec range\");\n    // After the Info comes the ParmVarDecl array, and after that comes the\n    // exception specification information.\n    return (SourceRange *)(getParmArray() + getNumParams());\n  }\n\npublic:\n  SourceLocation getLocalRangeBegin() const {\n    return getLocalData()->LocalRangeBegin;\n  }\n\n  void setLocalRangeBegin(SourceLocation L) {\n    getLocalData()->LocalRangeBegin = L;\n  }\n\n  SourceLocation getLocalRangeEnd() const {\n    return getLocalData()->LocalRangeEnd;\n  }\n\n  void setLocalRangeEnd(SourceLocation L) {\n    getLocalData()->LocalRangeEnd = L;\n  }\n\n  SourceLocation getLParenLoc() const {\n    return this->getLocalData()->LParenLoc;\n  }\n\n  void setLParenLoc(SourceLocation Loc) {\n    this->getLocalData()->LParenLoc = Loc;\n  }\n\n  SourceLocation getRParenLoc() const {\n    return this->getLocalData()->RParenLoc;\n  }\n\n  void setRParenLoc(SourceLocation Loc) {\n    this->getLocalData()->RParenLoc = Loc;\n  }\n\n  SourceRange getParensRange() const {\n    return SourceRange(getLParenLoc(), getRParenLoc());\n  }\n\n  SourceRange getExceptionSpecRange() const {\n    if (hasExceptionSpec())\n      return *getExceptionSpecRangePtr();\n    return {};\n  }\n\n  void setExceptionSpecRange(SourceRange R) {\n    if (hasExceptionSpec())\n      *getExceptionSpecRangePtr() = R;\n  }\n\n  ArrayRef<ParmVarDecl *> getParams() const {\n    return llvm::makeArrayRef(getParmArray(), getNumParams());\n  }\n\n  // ParmVarDecls* are stored after Info, one for each parameter.\n  ParmVarDecl **getParmArray() const {\n    return (ParmVarDecl**) getExtraLocalData();\n  }\n\n  unsigned getNumParams() const {\n    if (isa<FunctionNoProtoType>(getTypePtr()))\n      return 0;\n    return cast<FunctionProtoType>(getTypePtr())->getNumParams();\n  }\n\n  ParmVarDecl *getParam(unsigned i) const { return getParmArray()[i]; }\n  void setParam(unsigned i, ParmVarDecl *VD) { getParmArray()[i] = VD; }\n\n  TypeLoc getReturnLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getLocalRangeBegin(), getLocalRangeEnd());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setLocalRangeBegin(Loc);\n    setLParenLoc(Loc);\n    setRParenLoc(Loc);\n    setLocalRangeEnd(Loc);\n    for (unsigned i = 0, e = getNumParams(); i != e; ++i)\n      setParam(i, nullptr);\n    if (hasExceptionSpec())\n      setExceptionSpecRange(Loc);\n  }\n\n  /// Returns the size of the type source info data block that is\n  /// specific to this type.\n  unsigned getExtraLocalDataSize() const {\n    unsigned ExceptSpecSize = hasExceptionSpec() ? sizeof(SourceRange) : 0;\n    return (getNumParams() * sizeof(ParmVarDecl *)) + ExceptSpecSize;\n  }\n\n  unsigned getExtraLocalDataAlignment() const { return alignof(ParmVarDecl *); }\n\n  QualType getInnerType() const { return getTypePtr()->getReturnType(); }\n};\n\nclass FunctionProtoTypeLoc :\n    public InheritingConcreteTypeLoc<FunctionTypeLoc,\n                                     FunctionProtoTypeLoc,\n                                     FunctionProtoType> {\n};\n\nclass FunctionNoProtoTypeLoc :\n    public InheritingConcreteTypeLoc<FunctionTypeLoc,\n                                     FunctionNoProtoTypeLoc,\n                                     FunctionNoProtoType> {\n};\n\nstruct ArrayLocInfo {\n  SourceLocation LBracketLoc, RBracketLoc;\n  Expr *Size;\n};\n\n/// Wrapper for source info for arrays.\nclass ArrayTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                            ArrayTypeLoc,\n                                            ArrayType,\n                                            ArrayLocInfo> {\npublic:\n  SourceLocation getLBracketLoc() const {\n    return getLocalData()->LBracketLoc;\n  }\n\n  void setLBracketLoc(SourceLocation Loc) {\n    getLocalData()->LBracketLoc = Loc;\n  }\n\n  SourceLocation getRBracketLoc() const {\n    return getLocalData()->RBracketLoc;\n  }\n\n  void setRBracketLoc(SourceLocation Loc) {\n    getLocalData()->RBracketLoc = Loc;\n  }\n\n  SourceRange getBracketsRange() const {\n    return SourceRange(getLBracketLoc(), getRBracketLoc());\n  }\n\n  Expr *getSizeExpr() const {\n    return getLocalData()->Size;\n  }\n\n  void setSizeExpr(Expr *Size) {\n    getLocalData()->Size = Size;\n  }\n\n  TypeLoc getElementLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getLBracketLoc(), getRBracketLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setLBracketLoc(Loc);\n    setRBracketLoc(Loc);\n    setSizeExpr(nullptr);\n  }\n\n  QualType getInnerType() const { return getTypePtr()->getElementType(); }\n};\n\nclass ConstantArrayTypeLoc :\n    public InheritingConcreteTypeLoc<ArrayTypeLoc,\n                                     ConstantArrayTypeLoc,\n                                     ConstantArrayType> {\n};\n\nclass IncompleteArrayTypeLoc :\n    public InheritingConcreteTypeLoc<ArrayTypeLoc,\n                                     IncompleteArrayTypeLoc,\n                                     IncompleteArrayType> {\n};\n\nclass DependentSizedArrayTypeLoc :\n    public InheritingConcreteTypeLoc<ArrayTypeLoc,\n                                     DependentSizedArrayTypeLoc,\n                                     DependentSizedArrayType> {\npublic:\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    ArrayTypeLoc::initializeLocal(Context, Loc);\n    setSizeExpr(getTypePtr()->getSizeExpr());\n  }\n};\n\nclass VariableArrayTypeLoc :\n    public InheritingConcreteTypeLoc<ArrayTypeLoc,\n                                     VariableArrayTypeLoc,\n                                     VariableArrayType> {\n};\n\n// Location information for a TemplateName.  Rudimentary for now.\nstruct TemplateNameLocInfo {\n  SourceLocation NameLoc;\n};\n\nstruct TemplateSpecializationLocInfo : TemplateNameLocInfo {\n  SourceLocation TemplateKWLoc;\n  SourceLocation LAngleLoc;\n  SourceLocation RAngleLoc;\n};\n\nclass TemplateSpecializationTypeLoc :\n    public ConcreteTypeLoc<UnqualTypeLoc,\n                           TemplateSpecializationTypeLoc,\n                           TemplateSpecializationType,\n                           TemplateSpecializationLocInfo> {\npublic:\n  SourceLocation getTemplateKeywordLoc() const {\n    return getLocalData()->TemplateKWLoc;\n  }\n\n  void setTemplateKeywordLoc(SourceLocation Loc) {\n    getLocalData()->TemplateKWLoc = Loc;\n  }\n\n  SourceLocation getLAngleLoc() const {\n    return getLocalData()->LAngleLoc;\n  }\n\n  void setLAngleLoc(SourceLocation Loc) {\n    getLocalData()->LAngleLoc = Loc;\n  }\n\n  SourceLocation getRAngleLoc() const {\n    return getLocalData()->RAngleLoc;\n  }\n\n  void setRAngleLoc(SourceLocation Loc) {\n    getLocalData()->RAngleLoc = Loc;\n  }\n\n  unsigned getNumArgs() const {\n    return getTypePtr()->getNumArgs();\n  }\n\n  void setArgLocInfo(unsigned i, TemplateArgumentLocInfo AI) {\n    getArgInfos()[i] = AI;\n  }\n\n  TemplateArgumentLocInfo getArgLocInfo(unsigned i) const {\n    return getArgInfos()[i];\n  }\n\n  TemplateArgumentLoc getArgLoc(unsigned i) const {\n    return TemplateArgumentLoc(getTypePtr()->getArg(i), getArgLocInfo(i));\n  }\n\n  SourceLocation getTemplateNameLoc() const {\n    return getLocalData()->NameLoc;\n  }\n\n  void setTemplateNameLoc(SourceLocation Loc) {\n    getLocalData()->NameLoc = Loc;\n  }\n\n  /// - Copy the location information from the given info.\n  void copy(TemplateSpecializationTypeLoc Loc) {\n    unsigned size = getFullDataSize();\n    assert(size == Loc.getFullDataSize());\n\n    // We're potentially copying Expr references here.  We don't\n    // bother retaining them because TypeSourceInfos live forever, so\n    // as long as the Expr was retained when originally written into\n    // the TypeLoc, we're okay.\n    memcpy(Data, Loc.Data, size);\n  }\n\n  SourceRange getLocalSourceRange() const {\n    if (getTemplateKeywordLoc().isValid())\n      return SourceRange(getTemplateKeywordLoc(), getRAngleLoc());\n    else\n      return SourceRange(getTemplateNameLoc(), getRAngleLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setTemplateKeywordLoc(Loc);\n    setTemplateNameLoc(Loc);\n    setLAngleLoc(Loc);\n    setRAngleLoc(Loc);\n    initializeArgLocs(Context, getNumArgs(), getTypePtr()->getArgs(),\n                      getArgInfos(), Loc);\n  }\n\n  static void initializeArgLocs(ASTContext &Context, unsigned NumArgs,\n                                const TemplateArgument *Args,\n                                TemplateArgumentLocInfo *ArgInfos,\n                                SourceLocation Loc);\n\n  unsigned getExtraLocalDataSize() const {\n    return getNumArgs() * sizeof(TemplateArgumentLocInfo);\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return alignof(TemplateArgumentLocInfo);\n  }\n\nprivate:\n  TemplateArgumentLocInfo *getArgInfos() const {\n    return static_cast<TemplateArgumentLocInfo*>(getExtraLocalData());\n  }\n};\n\nstruct DependentAddressSpaceLocInfo {\n  Expr *ExprOperand;\n  SourceRange OperandParens;\n  SourceLocation AttrLoc;\n};\n\nclass DependentAddressSpaceTypeLoc\n    : public ConcreteTypeLoc<UnqualTypeLoc,\n                             DependentAddressSpaceTypeLoc,\n                             DependentAddressSpaceType,\n                             DependentAddressSpaceLocInfo> {\npublic:\n  /// The location of the attribute name, i.e.\n  ///    int * __attribute__((address_space(11)))\n  ///                         ^~~~~~~~~~~~~\n  SourceLocation getAttrNameLoc() const {\n    return getLocalData()->AttrLoc;\n  }\n  void setAttrNameLoc(SourceLocation loc) {\n    getLocalData()->AttrLoc = loc;\n  }\n\n  /// The attribute's expression operand, if it has one.\n  ///    int * __attribute__((address_space(11)))\n  ///                                       ^~\n  Expr *getAttrExprOperand() const {\n    return getLocalData()->ExprOperand;\n  }\n  void setAttrExprOperand(Expr *e) {\n    getLocalData()->ExprOperand = e;\n  }\n\n  /// The location of the parentheses around the operand, if there is\n  /// an operand.\n  ///    int * __attribute__((address_space(11)))\n  ///                                      ^  ^\n  SourceRange getAttrOperandParensRange() const {\n    return getLocalData()->OperandParens;\n  }\n  void setAttrOperandParensRange(SourceRange range) {\n    getLocalData()->OperandParens = range;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    SourceRange range(getAttrNameLoc());\n    range.setEnd(getAttrOperandParensRange().getEnd());\n    return range;\n  }\n\n  ///  Returns the type before the address space attribute application\n  ///  area.\n  ///    int * __attribute__((address_space(11))) *\n  ///    ^   ^\n  QualType getInnerType() const {\n    return this->getTypePtr()->getPointeeType();\n  }\n\n  TypeLoc getPointeeTypeLoc() const {\n    return this->getInnerTypeLoc();\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation loc) {\n    setAttrNameLoc(loc);\n    setAttrOperandParensRange(loc);\n    setAttrOperandParensRange(SourceRange(loc));\n    setAttrExprOperand(getTypePtr()->getAddrSpaceExpr());\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//\n//  All of these need proper implementations.\n//\n//===----------------------------------------------------------------------===//\n\n// FIXME: size expression and attribute locations (or keyword if we\n// ever fully support altivec syntax).\nstruct VectorTypeLocInfo {\n  SourceLocation NameLoc;\n};\n\nclass VectorTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, VectorTypeLoc,\n                                             VectorType, VectorTypeLocInfo> {\npublic:\n  SourceLocation getNameLoc() const { return this->getLocalData()->NameLoc; }\n\n  void setNameLoc(SourceLocation Loc) { this->getLocalData()->NameLoc = Loc; }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getNameLoc(), getNameLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setNameLoc(Loc);\n  }\n\n  TypeLoc getElementLoc() const { return getInnerTypeLoc(); }\n\n  QualType getInnerType() const { return this->getTypePtr()->getElementType(); }\n};\n\n// FIXME: size expression and attribute locations (or keyword if we\n// ever fully support altivec syntax).\nclass DependentVectorTypeLoc\n    : public ConcreteTypeLoc<UnqualTypeLoc, DependentVectorTypeLoc,\n                             DependentVectorType, VectorTypeLocInfo> {\npublic:\n  SourceLocation getNameLoc() const { return this->getLocalData()->NameLoc; }\n\n  void setNameLoc(SourceLocation Loc) { this->getLocalData()->NameLoc = Loc; }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getNameLoc(), getNameLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setNameLoc(Loc);\n  }\n\n  TypeLoc getElementLoc() const { return getInnerTypeLoc(); }\n\n  QualType getInnerType() const { return this->getTypePtr()->getElementType(); }\n};\n\n// FIXME: size expression and attribute locations.\nclass ExtVectorTypeLoc\n    : public InheritingConcreteTypeLoc<VectorTypeLoc, ExtVectorTypeLoc,\n                                       ExtVectorType> {};\n\n// FIXME: attribute locations.\n// For some reason, this isn't a subtype of VectorType.\nclass DependentSizedExtVectorTypeLoc\n    : public ConcreteTypeLoc<UnqualTypeLoc, DependentSizedExtVectorTypeLoc,\n                             DependentSizedExtVectorType, VectorTypeLocInfo> {\npublic:\n  SourceLocation getNameLoc() const { return this->getLocalData()->NameLoc; }\n\n  void setNameLoc(SourceLocation Loc) { this->getLocalData()->NameLoc = Loc; }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getNameLoc(), getNameLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setNameLoc(Loc);\n  }\n\n  TypeLoc getElementLoc() const { return getInnerTypeLoc(); }\n\n  QualType getInnerType() const { return this->getTypePtr()->getElementType(); }\n};\n\nstruct MatrixTypeLocInfo {\n  SourceLocation AttrLoc;\n  SourceRange OperandParens;\n  Expr *RowOperand;\n  Expr *ColumnOperand;\n};\n\nclass MatrixTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, MatrixTypeLoc,\n                                             MatrixType, MatrixTypeLocInfo> {\npublic:\n  /// The location of the attribute name, i.e.\n  ///    float __attribute__((matrix_type(4, 2)))\n  ///                         ^~~~~~~~~~~~~~~~~\n  SourceLocation getAttrNameLoc() const { return getLocalData()->AttrLoc; }\n  void setAttrNameLoc(SourceLocation loc) { getLocalData()->AttrLoc = loc; }\n\n  /// The attribute's row operand, if it has one.\n  ///    float __attribute__((matrix_type(4, 2)))\n  ///                                     ^\n  Expr *getAttrRowOperand() const { return getLocalData()->RowOperand; }\n  void setAttrRowOperand(Expr *e) { getLocalData()->RowOperand = e; }\n\n  /// The attribute's column operand, if it has one.\n  ///    float __attribute__((matrix_type(4, 2)))\n  ///                                        ^\n  Expr *getAttrColumnOperand() const { return getLocalData()->ColumnOperand; }\n  void setAttrColumnOperand(Expr *e) { getLocalData()->ColumnOperand = e; }\n\n  /// The location of the parentheses around the operand, if there is\n  /// an operand.\n  ///    float __attribute__((matrix_type(4, 2)))\n  ///                                    ^    ^\n  SourceRange getAttrOperandParensRange() const {\n    return getLocalData()->OperandParens;\n  }\n  void setAttrOperandParensRange(SourceRange range) {\n    getLocalData()->OperandParens = range;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    SourceRange range(getAttrNameLoc());\n    range.setEnd(getAttrOperandParensRange().getEnd());\n    return range;\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation loc) {\n    setAttrNameLoc(loc);\n    setAttrOperandParensRange(loc);\n    setAttrRowOperand(nullptr);\n    setAttrColumnOperand(nullptr);\n  }\n};\n\nclass ConstantMatrixTypeLoc\n    : public InheritingConcreteTypeLoc<MatrixTypeLoc, ConstantMatrixTypeLoc,\n                                       ConstantMatrixType> {};\n\nclass DependentSizedMatrixTypeLoc\n    : public InheritingConcreteTypeLoc<MatrixTypeLoc,\n                                       DependentSizedMatrixTypeLoc,\n                                       DependentSizedMatrixType> {};\n\n// FIXME: location of the '_Complex' keyword.\nclass ComplexTypeLoc : public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                                        ComplexTypeLoc,\n                                                        ComplexType> {\n};\n\nstruct TypeofLocInfo {\n  SourceLocation TypeofLoc;\n  SourceLocation LParenLoc;\n  SourceLocation RParenLoc;\n};\n\nstruct TypeOfExprTypeLocInfo : public TypeofLocInfo {\n};\n\nstruct TypeOfTypeLocInfo : public TypeofLocInfo {\n  TypeSourceInfo* UnderlyingTInfo;\n};\n\ntemplate <class Derived, class TypeClass, class LocalData = TypeofLocInfo>\nclass TypeofLikeTypeLoc\n  : public ConcreteTypeLoc<UnqualTypeLoc, Derived, TypeClass, LocalData> {\npublic:\n  SourceLocation getTypeofLoc() const {\n    return this->getLocalData()->TypeofLoc;\n  }\n\n  void setTypeofLoc(SourceLocation Loc) {\n    this->getLocalData()->TypeofLoc = Loc;\n  }\n\n  SourceLocation getLParenLoc() const {\n    return this->getLocalData()->LParenLoc;\n  }\n\n  void setLParenLoc(SourceLocation Loc) {\n    this->getLocalData()->LParenLoc = Loc;\n  }\n\n  SourceLocation getRParenLoc() const {\n    return this->getLocalData()->RParenLoc;\n  }\n\n  void setRParenLoc(SourceLocation Loc) {\n    this->getLocalData()->RParenLoc = Loc;\n  }\n\n  SourceRange getParensRange() const {\n    return SourceRange(getLParenLoc(), getRParenLoc());\n  }\n\n  void setParensRange(SourceRange range) {\n      setLParenLoc(range.getBegin());\n      setRParenLoc(range.getEnd());\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getTypeofLoc(), getRParenLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setTypeofLoc(Loc);\n    setLParenLoc(Loc);\n    setRParenLoc(Loc);\n  }\n};\n\nclass TypeOfExprTypeLoc : public TypeofLikeTypeLoc<TypeOfExprTypeLoc,\n                                                   TypeOfExprType,\n                                                   TypeOfExprTypeLocInfo> {\npublic:\n  Expr* getUnderlyingExpr() const {\n    return getTypePtr()->getUnderlyingExpr();\n  }\n\n  // Reimplemented to account for GNU/C++ extension\n  //     typeof unary-expression\n  // where there are no parentheses.\n  SourceRange getLocalSourceRange() const;\n};\n\nclass TypeOfTypeLoc\n  : public TypeofLikeTypeLoc<TypeOfTypeLoc, TypeOfType, TypeOfTypeLocInfo> {\npublic:\n  QualType getUnderlyingType() const {\n    return this->getTypePtr()->getUnderlyingType();\n  }\n\n  TypeSourceInfo* getUnderlyingTInfo() const {\n    return this->getLocalData()->UnderlyingTInfo;\n  }\n\n  void setUnderlyingTInfo(TypeSourceInfo* TI) const {\n    this->getLocalData()->UnderlyingTInfo = TI;\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n};\n\n// FIXME: location of the 'decltype' and parens.\nclass DecltypeTypeLoc : public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                                         DecltypeTypeLoc,\n                                                         DecltypeType> {\npublic:\n  Expr *getUnderlyingExpr() const { return getTypePtr()->getUnderlyingExpr(); }\n};\n\nstruct UnaryTransformTypeLocInfo {\n  // FIXME: While there's only one unary transform right now, future ones may\n  // need different representations\n  SourceLocation KWLoc, LParenLoc, RParenLoc;\n  TypeSourceInfo *UnderlyingTInfo;\n};\n\nclass UnaryTransformTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                                    UnaryTransformTypeLoc,\n                                                    UnaryTransformType,\n                                                    UnaryTransformTypeLocInfo> {\npublic:\n  SourceLocation getKWLoc() const { return getLocalData()->KWLoc; }\n  void setKWLoc(SourceLocation Loc) { getLocalData()->KWLoc = Loc; }\n\n  SourceLocation getLParenLoc() const { return getLocalData()->LParenLoc; }\n  void setLParenLoc(SourceLocation Loc) { getLocalData()->LParenLoc = Loc; }\n\n  SourceLocation getRParenLoc() const { return getLocalData()->RParenLoc; }\n  void setRParenLoc(SourceLocation Loc) { getLocalData()->RParenLoc = Loc; }\n\n  TypeSourceInfo* getUnderlyingTInfo() const {\n    return getLocalData()->UnderlyingTInfo;\n  }\n\n  void setUnderlyingTInfo(TypeSourceInfo *TInfo) {\n    getLocalData()->UnderlyingTInfo = TInfo;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getKWLoc(), getRParenLoc());\n  }\n\n  SourceRange getParensRange() const {\n    return SourceRange(getLParenLoc(), getRParenLoc());\n  }\n\n  void setParensRange(SourceRange Range) {\n    setLParenLoc(Range.getBegin());\n    setRParenLoc(Range.getEnd());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n};\n\nclass DeducedTypeLoc\n    : public InheritingConcreteTypeLoc<TypeSpecTypeLoc, DeducedTypeLoc,\n                                       DeducedType> {};\n\nstruct AutoTypeLocInfo : TypeSpecLocInfo {\n  NestedNameSpecifierLoc NestedNameSpec;\n  SourceLocation TemplateKWLoc;\n  SourceLocation ConceptNameLoc;\n  NamedDecl *FoundDecl;\n  SourceLocation LAngleLoc;\n  SourceLocation RAngleLoc;\n};\n\nclass AutoTypeLoc\n    : public ConcreteTypeLoc<DeducedTypeLoc,\n                             AutoTypeLoc,\n                             AutoType,\n                             AutoTypeLocInfo> {\npublic:\n  AutoTypeKeyword getAutoKeyword() const {\n    return getTypePtr()->getKeyword();\n  }\n\n  bool isConstrained() const {\n    return getTypePtr()->isConstrained();\n  }\n\n  const NestedNameSpecifierLoc &getNestedNameSpecifierLoc() const {\n    return getLocalData()->NestedNameSpec;\n  }\n\n  void setNestedNameSpecifierLoc(NestedNameSpecifierLoc NNS) {\n    getLocalData()->NestedNameSpec = NNS;\n  }\n\n  SourceLocation getTemplateKWLoc() const {\n    return getLocalData()->TemplateKWLoc;\n  }\n\n  void setTemplateKWLoc(SourceLocation Loc) {\n    getLocalData()->TemplateKWLoc = Loc;\n  }\n\n  SourceLocation getConceptNameLoc() const {\n    return getLocalData()->ConceptNameLoc;\n  }\n\n  void setConceptNameLoc(SourceLocation Loc) {\n    getLocalData()->ConceptNameLoc = Loc;\n  }\n\n  NamedDecl *getFoundDecl() const {\n    return getLocalData()->FoundDecl;\n  }\n\n  void setFoundDecl(NamedDecl *D) {\n    getLocalData()->FoundDecl = D;\n  }\n\n  ConceptDecl *getNamedConcept() const {\n    return getTypePtr()->getTypeConstraintConcept();\n  }\n\n  DeclarationNameInfo getConceptNameInfo() const;\n\n  bool hasExplicitTemplateArgs() const {\n    return getLocalData()->LAngleLoc.isValid();\n  }\n\n  SourceLocation getLAngleLoc() const {\n    return this->getLocalData()->LAngleLoc;\n  }\n\n  void setLAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->LAngleLoc = Loc;\n  }\n\n  SourceLocation getRAngleLoc() const {\n    return this->getLocalData()->RAngleLoc;\n  }\n\n  void setRAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->RAngleLoc = Loc;\n  }\n\n  unsigned getNumArgs() const {\n    return getTypePtr()->getNumArgs();\n  }\n\n  void setArgLocInfo(unsigned i, TemplateArgumentLocInfo AI) {\n    getArgInfos()[i] = AI;\n  }\n\n  TemplateArgumentLocInfo getArgLocInfo(unsigned i) const {\n    return getArgInfos()[i];\n  }\n\n  TemplateArgumentLoc getArgLoc(unsigned i) const {\n    return TemplateArgumentLoc(getTypePtr()->getTypeConstraintArguments()[i],\n                               getArgLocInfo(i));\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return{\n        isConstrained()\n          ? (getNestedNameSpecifierLoc()\n               ? getNestedNameSpecifierLoc().getBeginLoc()\n               : (getTemplateKWLoc().isValid()\n                  ? getTemplateKWLoc()\n                  : getConceptNameLoc()))\n          : getNameLoc(),\n        getNameLoc()\n    };\n  }\n\n  void copy(AutoTypeLoc Loc) {\n    unsigned size = getFullDataSize();\n    assert(size == Loc.getFullDataSize());\n    memcpy(Data, Loc.Data, size);\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n\n  unsigned getExtraLocalDataSize() const {\n    return getNumArgs() * sizeof(TemplateArgumentLocInfo);\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return alignof(TemplateArgumentLocInfo);\n  }\n\nprivate:\n  TemplateArgumentLocInfo *getArgInfos() const {\n    return static_cast<TemplateArgumentLocInfo*>(getExtraLocalData());\n  }\n};\n\nclass DeducedTemplateSpecializationTypeLoc\n    : public InheritingConcreteTypeLoc<DeducedTypeLoc,\n                                       DeducedTemplateSpecializationTypeLoc,\n                                       DeducedTemplateSpecializationType> {\npublic:\n  SourceLocation getTemplateNameLoc() const {\n    return getNameLoc();\n  }\n\n  void setTemplateNameLoc(SourceLocation Loc) {\n    setNameLoc(Loc);\n  }\n};\n\nstruct ElaboratedLocInfo {\n  SourceLocation ElaboratedKWLoc;\n\n  /// Data associated with the nested-name-specifier location.\n  void *QualifierData;\n};\n\nclass ElaboratedTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                                 ElaboratedTypeLoc,\n                                                 ElaboratedType,\n                                                 ElaboratedLocInfo> {\npublic:\n  SourceLocation getElaboratedKeywordLoc() const {\n    return this->getLocalData()->ElaboratedKWLoc;\n  }\n\n  void setElaboratedKeywordLoc(SourceLocation Loc) {\n    this->getLocalData()->ElaboratedKWLoc = Loc;\n  }\n\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    return NestedNameSpecifierLoc(getTypePtr()->getQualifier(),\n                                  getLocalData()->QualifierData);\n  }\n\n  void setQualifierLoc(NestedNameSpecifierLoc QualifierLoc) {\n    assert(QualifierLoc.getNestedNameSpecifier()\n                                            == getTypePtr()->getQualifier() &&\n           \"Inconsistent nested-name-specifier pointer\");\n    getLocalData()->QualifierData = QualifierLoc.getOpaqueData();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    if (getElaboratedKeywordLoc().isValid())\n      if (getQualifierLoc())\n        return SourceRange(getElaboratedKeywordLoc(),\n                           getQualifierLoc().getEndLoc());\n      else\n        return SourceRange(getElaboratedKeywordLoc());\n    else\n      return getQualifierLoc().getSourceRange();\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n\n  TypeLoc getNamedTypeLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  QualType getInnerType() const {\n    return getTypePtr()->getNamedType();\n  }\n\n  void copy(ElaboratedTypeLoc Loc) {\n    unsigned size = getFullDataSize();\n    assert(size == Loc.getFullDataSize());\n    memcpy(Data, Loc.Data, size);\n  }\n};\n\n// This is exactly the structure of an ElaboratedTypeLoc whose inner\n// type is some sort of TypeDeclTypeLoc.\nstruct DependentNameLocInfo : ElaboratedLocInfo {\n  SourceLocation NameLoc;\n};\n\nclass DependentNameTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                                    DependentNameTypeLoc,\n                                                    DependentNameType,\n                                                    DependentNameLocInfo> {\npublic:\n  SourceLocation getElaboratedKeywordLoc() const {\n    return this->getLocalData()->ElaboratedKWLoc;\n  }\n\n  void setElaboratedKeywordLoc(SourceLocation Loc) {\n    this->getLocalData()->ElaboratedKWLoc = Loc;\n  }\n\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    return NestedNameSpecifierLoc(getTypePtr()->getQualifier(),\n                                  getLocalData()->QualifierData);\n  }\n\n  void setQualifierLoc(NestedNameSpecifierLoc QualifierLoc) {\n    assert(QualifierLoc.getNestedNameSpecifier()\n                                            == getTypePtr()->getQualifier() &&\n           \"Inconsistent nested-name-specifier pointer\");\n    getLocalData()->QualifierData = QualifierLoc.getOpaqueData();\n  }\n\n  SourceLocation getNameLoc() const {\n    return this->getLocalData()->NameLoc;\n  }\n\n  void setNameLoc(SourceLocation Loc) {\n    this->getLocalData()->NameLoc = Loc;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    if (getElaboratedKeywordLoc().isValid())\n      return SourceRange(getElaboratedKeywordLoc(), getNameLoc());\n    else\n      return SourceRange(getQualifierLoc().getBeginLoc(), getNameLoc());\n  }\n\n  void copy(DependentNameTypeLoc Loc) {\n    unsigned size = getFullDataSize();\n    assert(size == Loc.getFullDataSize());\n    memcpy(Data, Loc.Data, size);\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n};\n\nstruct DependentTemplateSpecializationLocInfo : DependentNameLocInfo {\n  SourceLocation TemplateKWLoc;\n  SourceLocation LAngleLoc;\n  SourceLocation RAngleLoc;\n  // followed by a TemplateArgumentLocInfo[]\n};\n\nclass DependentTemplateSpecializationTypeLoc :\n    public ConcreteTypeLoc<UnqualTypeLoc,\n                           DependentTemplateSpecializationTypeLoc,\n                           DependentTemplateSpecializationType,\n                           DependentTemplateSpecializationLocInfo> {\npublic:\n  SourceLocation getElaboratedKeywordLoc() const {\n    return this->getLocalData()->ElaboratedKWLoc;\n  }\n\n  void setElaboratedKeywordLoc(SourceLocation Loc) {\n    this->getLocalData()->ElaboratedKWLoc = Loc;\n  }\n\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    if (!getLocalData()->QualifierData)\n      return NestedNameSpecifierLoc();\n\n    return NestedNameSpecifierLoc(getTypePtr()->getQualifier(),\n                                  getLocalData()->QualifierData);\n  }\n\n  void setQualifierLoc(NestedNameSpecifierLoc QualifierLoc) {\n    if (!QualifierLoc) {\n      // Even if we have a nested-name-specifier in the dependent\n      // template specialization type, we won't record the nested-name-specifier\n      // location information when this type-source location information is\n      // part of a nested-name-specifier.\n      getLocalData()->QualifierData = nullptr;\n      return;\n    }\n\n    assert(QualifierLoc.getNestedNameSpecifier()\n                                        == getTypePtr()->getQualifier() &&\n           \"Inconsistent nested-name-specifier pointer\");\n    getLocalData()->QualifierData = QualifierLoc.getOpaqueData();\n  }\n\n  SourceLocation getTemplateKeywordLoc() const {\n    return getLocalData()->TemplateKWLoc;\n  }\n\n  void setTemplateKeywordLoc(SourceLocation Loc) {\n    getLocalData()->TemplateKWLoc = Loc;\n  }\n\n  SourceLocation getTemplateNameLoc() const {\n    return this->getLocalData()->NameLoc;\n  }\n\n  void setTemplateNameLoc(SourceLocation Loc) {\n    this->getLocalData()->NameLoc = Loc;\n  }\n\n  SourceLocation getLAngleLoc() const {\n    return this->getLocalData()->LAngleLoc;\n  }\n\n  void setLAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->LAngleLoc = Loc;\n  }\n\n  SourceLocation getRAngleLoc() const {\n    return this->getLocalData()->RAngleLoc;\n  }\n\n  void setRAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->RAngleLoc = Loc;\n  }\n\n  unsigned getNumArgs() const {\n    return getTypePtr()->getNumArgs();\n  }\n\n  void setArgLocInfo(unsigned i, TemplateArgumentLocInfo AI) {\n    getArgInfos()[i] = AI;\n  }\n\n  TemplateArgumentLocInfo getArgLocInfo(unsigned i) const {\n    return getArgInfos()[i];\n  }\n\n  TemplateArgumentLoc getArgLoc(unsigned i) const {\n    return TemplateArgumentLoc(getTypePtr()->getArg(i), getArgLocInfo(i));\n  }\n\n  SourceRange getLocalSourceRange() const {\n    if (getElaboratedKeywordLoc().isValid())\n      return SourceRange(getElaboratedKeywordLoc(), getRAngleLoc());\n    else if (getQualifierLoc())\n      return SourceRange(getQualifierLoc().getBeginLoc(), getRAngleLoc());\n    else if (getTemplateKeywordLoc().isValid())\n      return SourceRange(getTemplateKeywordLoc(), getRAngleLoc());\n    else\n      return SourceRange(getTemplateNameLoc(), getRAngleLoc());\n  }\n\n  void copy(DependentTemplateSpecializationTypeLoc Loc) {\n    unsigned size = getFullDataSize();\n    assert(size == Loc.getFullDataSize());\n    memcpy(Data, Loc.Data, size);\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n\n  unsigned getExtraLocalDataSize() const {\n    return getNumArgs() * sizeof(TemplateArgumentLocInfo);\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return alignof(TemplateArgumentLocInfo);\n  }\n\nprivate:\n  TemplateArgumentLocInfo *getArgInfos() const {\n    return static_cast<TemplateArgumentLocInfo*>(getExtraLocalData());\n  }\n};\n\nstruct PackExpansionTypeLocInfo {\n  SourceLocation EllipsisLoc;\n};\n\nclass PackExpansionTypeLoc\n  : public ConcreteTypeLoc<UnqualTypeLoc, PackExpansionTypeLoc,\n                           PackExpansionType, PackExpansionTypeLocInfo> {\npublic:\n  SourceLocation getEllipsisLoc() const {\n    return this->getLocalData()->EllipsisLoc;\n  }\n\n  void setEllipsisLoc(SourceLocation Loc) {\n    this->getLocalData()->EllipsisLoc = Loc;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getEllipsisLoc(), getEllipsisLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setEllipsisLoc(Loc);\n  }\n\n  TypeLoc getPatternLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  QualType getInnerType() const {\n    return this->getTypePtr()->getPattern();\n  }\n};\n\nstruct AtomicTypeLocInfo {\n  SourceLocation KWLoc, LParenLoc, RParenLoc;\n};\n\nclass AtomicTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, AtomicTypeLoc,\n                                             AtomicType, AtomicTypeLocInfo> {\npublic:\n  TypeLoc getValueLoc() const {\n    return this->getInnerTypeLoc();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getKWLoc(), getRParenLoc());\n  }\n\n  SourceLocation getKWLoc() const {\n    return this->getLocalData()->KWLoc;\n  }\n\n  void setKWLoc(SourceLocation Loc) {\n    this->getLocalData()->KWLoc = Loc;\n  }\n\n  SourceLocation getLParenLoc() const {\n    return this->getLocalData()->LParenLoc;\n  }\n\n  void setLParenLoc(SourceLocation Loc) {\n    this->getLocalData()->LParenLoc = Loc;\n  }\n\n  SourceLocation getRParenLoc() const {\n    return this->getLocalData()->RParenLoc;\n  }\n\n  void setRParenLoc(SourceLocation Loc) {\n    this->getLocalData()->RParenLoc = Loc;\n  }\n\n  SourceRange getParensRange() const {\n    return SourceRange(getLParenLoc(), getRParenLoc());\n  }\n\n  void setParensRange(SourceRange Range) {\n    setLParenLoc(Range.getBegin());\n    setRParenLoc(Range.getEnd());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setKWLoc(Loc);\n    setLParenLoc(Loc);\n    setRParenLoc(Loc);\n  }\n\n  QualType getInnerType() const {\n    return this->getTypePtr()->getValueType();\n  }\n};\n\nstruct PipeTypeLocInfo {\n  SourceLocation KWLoc;\n};\n\nclass PipeTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, PipeTypeLoc, PipeType,\n                                           PipeTypeLocInfo> {\npublic:\n  TypeLoc getValueLoc() const { return this->getInnerTypeLoc(); }\n\n  SourceRange getLocalSourceRange() const { return SourceRange(getKWLoc()); }\n\n  SourceLocation getKWLoc() const { return this->getLocalData()->KWLoc; }\n  void setKWLoc(SourceLocation Loc) { this->getLocalData()->KWLoc = Loc; }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setKWLoc(Loc);\n  }\n\n  QualType getInnerType() const { return this->getTypePtr()->getElementType(); }\n};\n\ntemplate <typename T>\ninline T TypeLoc::getAsAdjusted() const {\n  TypeLoc Cur = *this;\n  while (!T::isKind(Cur)) {\n    if (auto PTL = Cur.getAs<ParenTypeLoc>())\n      Cur = PTL.getInnerLoc();\n    else if (auto ATL = Cur.getAs<AttributedTypeLoc>())\n      Cur = ATL.getModifiedLoc();\n    else if (auto ETL = Cur.getAs<ElaboratedTypeLoc>())\n      Cur = ETL.getNamedTypeLoc();\n    else if (auto ATL = Cur.getAs<AdjustedTypeLoc>())\n      Cur = ATL.getOriginalLoc();\n    else if (auto MQL = Cur.getAs<MacroQualifiedTypeLoc>())\n      Cur = MQL.getInnerLoc();\n    else\n      break;\n  }\n  return Cur.getAs<T>();\n}\nclass ExtIntTypeLoc final\n    : public InheritingConcreteTypeLoc<TypeSpecTypeLoc, ExtIntTypeLoc,\n                                        ExtIntType> {};\nclass DependentExtIntTypeLoc final\n    : public InheritingConcreteTypeLoc<TypeSpecTypeLoc, DependentExtIntTypeLoc,\n                                        DependentExtIntType> {};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_TYPELOC_H\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/ABI.h", "content": "//===----- ABI.h - ABI related declarations ---------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Enums/classes describing ABI related information about constructors,\n/// destructors and thunks.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_ABI_H\n#define LLVM_CLANG_BASIC_ABI_H\n\n#include \"llvm/Support/DataTypes.h\"\n#include <cstring>\n\nnamespace clang {\n\n/// C++ constructor types.\nenum CXXCtorType {\n  Ctor_Complete,       ///< Complete object ctor\n  Ctor_Base,           ///< Base object ctor\n  Ctor_Comdat,         ///< The COMDAT used for ctors\n  Ctor_CopyingClosure, ///< Copying closure variant of a ctor\n  Ctor_DefaultClosure, ///< Default closure variant of a ctor\n};\n\n/// C++ destructor types.\nenum CXXDtorType {\n    Dtor_Deleting, ///< Deleting dtor\n    Dtor_Complete, ///< Complete object dtor\n    Dtor_Base,     ///< Base object dtor\n    Dtor_Comdat    ///< The COMDAT used for dtors\n};\n\n/// A return adjustment.\nstruct ReturnAdjustment {\n  /// The non-virtual adjustment from the derived object to its\n  /// nearest virtual base.\n  int64_t NonVirtual;\n\n  /// Holds the ABI-specific information about the virtual return\n  /// adjustment, if needed.\n  union VirtualAdjustment {\n    // Itanium ABI\n    struct {\n      /// The offset (in bytes), relative to the address point\n      /// of the virtual base class offset.\n      int64_t VBaseOffsetOffset;\n    } Itanium;\n\n    // Microsoft ABI\n    struct {\n      /// The offset (in bytes) of the vbptr, relative to the beginning\n      /// of the derived class.\n      uint32_t VBPtrOffset;\n\n      /// Index of the virtual base in the vbtable.\n      uint32_t VBIndex;\n    } Microsoft;\n\n    VirtualAdjustment() {\n      memset(this, 0, sizeof(*this));\n    }\n\n    bool Equals(const VirtualAdjustment &Other) const {\n      return memcmp(this, &Other, sizeof(Other)) == 0;\n    }\n\n    bool isEmpty() const {\n      VirtualAdjustment Zero;\n      return Equals(Zero);\n    }\n\n    bool Less(const VirtualAdjustment &RHS) const {\n      return memcmp(this, &RHS, sizeof(RHS)) < 0;\n    }\n  } Virtual;\n\n  ReturnAdjustment() : NonVirtual(0) {}\n\n  bool isEmpty() const { return !NonVirtual && Virtual.isEmpty(); }\n\n  friend bool operator==(const ReturnAdjustment &LHS,\n                         const ReturnAdjustment &RHS) {\n    return LHS.NonVirtual == RHS.NonVirtual && LHS.Virtual.Equals(RHS.Virtual);\n  }\n\n  friend bool operator!=(const ReturnAdjustment &LHS, const ReturnAdjustment &RHS) {\n    return !(LHS == RHS);\n  }\n\n  friend bool operator<(const ReturnAdjustment &LHS,\n                        const ReturnAdjustment &RHS) {\n    if (LHS.NonVirtual < RHS.NonVirtual)\n      return true;\n\n    return LHS.NonVirtual == RHS.NonVirtual && LHS.Virtual.Less(RHS.Virtual);\n  }\n};\n\n/// A \\c this pointer adjustment.\nstruct ThisAdjustment {\n  /// The non-virtual adjustment from the derived object to its\n  /// nearest virtual base.\n  int64_t NonVirtual;\n\n  /// Holds the ABI-specific information about the virtual this\n  /// adjustment, if needed.\n  union VirtualAdjustment {\n    // Itanium ABI\n    struct {\n      /// The offset (in bytes), relative to the address point,\n      /// of the virtual call offset.\n      int64_t VCallOffsetOffset;\n    } Itanium;\n\n    struct {\n      /// The offset of the vtordisp (in bytes), relative to the ECX.\n      int32_t VtordispOffset;\n\n      /// The offset of the vbptr of the derived class (in bytes),\n      /// relative to the ECX after vtordisp adjustment.\n      int32_t VBPtrOffset;\n\n      /// The offset (in bytes) of the vbase offset in the vbtable.\n      int32_t VBOffsetOffset;\n    } Microsoft;\n\n    VirtualAdjustment() {\n      memset(this, 0, sizeof(*this));\n    }\n\n    bool Equals(const VirtualAdjustment &Other) const {\n      return memcmp(this, &Other, sizeof(Other)) == 0;\n    }\n\n    bool isEmpty() const {\n      VirtualAdjustment Zero;\n      return Equals(Zero);\n    }\n\n    bool Less(const VirtualAdjustment &RHS) const {\n      return memcmp(this, &RHS, sizeof(RHS)) < 0;\n    }\n  } Virtual;\n\n  ThisAdjustment() : NonVirtual(0) { }\n\n  bool isEmpty() const { return !NonVirtual && Virtual.isEmpty(); }\n\n  friend bool operator==(const ThisAdjustment &LHS,\n                         const ThisAdjustment &RHS) {\n    return LHS.NonVirtual == RHS.NonVirtual && LHS.Virtual.Equals(RHS.Virtual);\n  }\n\n  friend bool operator!=(const ThisAdjustment &LHS, const ThisAdjustment &RHS) {\n    return !(LHS == RHS);\n  }\n\n  friend bool operator<(const ThisAdjustment &LHS,\n                        const ThisAdjustment &RHS) {\n    if (LHS.NonVirtual < RHS.NonVirtual)\n      return true;\n\n    return LHS.NonVirtual == RHS.NonVirtual && LHS.Virtual.Less(RHS.Virtual);\n  }\n};\n\nclass CXXMethodDecl;\n\n/// The \\c this pointer adjustment as well as an optional return\n/// adjustment for a thunk.\nstruct ThunkInfo {\n  /// The \\c this pointer adjustment.\n  ThisAdjustment This;\n\n  /// The return adjustment.\n  ReturnAdjustment Return;\n\n  /// Holds a pointer to the overridden method this thunk is for,\n  /// if needed by the ABI to distinguish different thunks with equal\n  /// adjustments. Otherwise, null.\n  /// CAUTION: In the unlikely event you need to sort ThunkInfos, consider using\n  /// an ABI-specific comparator.\n  const CXXMethodDecl *Method;\n\n  ThunkInfo() : Method(nullptr) { }\n\n  ThunkInfo(const ThisAdjustment &This, const ReturnAdjustment &Return,\n            const CXXMethodDecl *Method = nullptr)\n      : This(This), Return(Return), Method(Method) {}\n\n  friend bool operator==(const ThunkInfo &LHS, const ThunkInfo &RHS) {\n    return LHS.This == RHS.This && LHS.Return == RHS.Return &&\n           LHS.Method == RHS.Method;\n  }\n\n  bool isEmpty() const {\n    return This.isEmpty() && Return.isEmpty() && Method == nullptr;\n  }\n};\n\n} // end namespace clang\n\n#endif\n"}, "75": {"id": 75, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Preprocessor.h", "content": "//===- Preprocessor.h - C Language Family Preprocessor ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::Preprocessor interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_LEX_PREPROCESSOR_H\n#define LLVM_CLANG_LEX_PREPROCESSOR_H\n\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Lex/MacroInfo.h\"\n#include \"clang/Lex/ModuleLoader.h\"\n#include \"clang/Lex/ModuleMap.h\"\n#include \"clang/Lex/PPCallbacks.h\"\n#include \"clang/Lex/PreprocessorExcludedConditionalDirectiveSkipMapping.h\"\n#include \"clang/Lex/Token.h\"\n#include \"clang/Lex/TokenLexer.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/FunctionExtras.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Registry.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <map>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\ntemplate<unsigned InternalLen> class SmallString;\n\n} // namespace llvm\n\nnamespace clang {\n\nclass CodeCompletionHandler;\nclass CommentHandler;\nclass DirectoryEntry;\nclass DirectoryLookup;\nclass EmptylineHandler;\nclass ExternalPreprocessorSource;\nclass FileEntry;\nclass FileManager;\nclass HeaderSearch;\nclass MacroArgs;\nclass PragmaHandler;\nclass PragmaNamespace;\nclass PreprocessingRecord;\nclass PreprocessorLexer;\nclass PreprocessorOptions;\nclass ScratchBuffer;\nclass TargetInfo;\n\nnamespace Builtin {\nclass Context;\n}\n\n/// Stores token information for comparing actual tokens with\n/// predefined values.  Only handles simple tokens and identifiers.\nclass TokenValue {\n  tok::TokenKind Kind;\n  IdentifierInfo *II;\n\npublic:\n  TokenValue(tok::TokenKind Kind) : Kind(Kind), II(nullptr) {\n    assert(Kind != tok::raw_identifier && \"Raw identifiers are not supported.\");\n    assert(Kind != tok::identifier &&\n           \"Identifiers should be created by TokenValue(IdentifierInfo *)\");\n    assert(!tok::isLiteral(Kind) && \"Literals are not supported.\");\n    assert(!tok::isAnnotation(Kind) && \"Annotations are not supported.\");\n  }\n\n  TokenValue(IdentifierInfo *II) : Kind(tok::identifier), II(II) {}\n\n  bool operator==(const Token &Tok) const {\n    return Tok.getKind() == Kind &&\n        (!II || II == Tok.getIdentifierInfo());\n  }\n};\n\n/// Context in which macro name is used.\nenum MacroUse {\n  // other than #define or #undef\n  MU_Other  = 0,\n\n  // macro name specified in #define\n  MU_Define = 1,\n\n  // macro name specified in #undef\n  MU_Undef  = 2\n};\n\n/// Engages in a tight little dance with the lexer to efficiently\n/// preprocess tokens.\n///\n/// Lexers know only about tokens within a single source file, and don't\n/// know anything about preprocessor-level issues like the \\#include stack,\n/// token expansion, etc.\nclass Preprocessor {\n  friend class VAOptDefinitionContext;\n  friend class VariadicMacroScopeGuard;\n\n  llvm::unique_function<void(const clang::Token &)> OnToken;\n  std::shared_ptr<PreprocessorOptions> PPOpts;\n  DiagnosticsEngine        *Diags;\n  LangOptions       &LangOpts;\n  const TargetInfo *Target = nullptr;\n  const TargetInfo *AuxTarget = nullptr;\n  FileManager       &FileMgr;\n  SourceManager     &SourceMgr;\n  std::unique_ptr<ScratchBuffer> ScratchBuf;\n  HeaderSearch      &HeaderInfo;\n  ModuleLoader      &TheModuleLoader;\n\n  /// External source of macros.\n  ExternalPreprocessorSource *ExternalSource;\n\n  /// A BumpPtrAllocator object used to quickly allocate and release\n  /// objects internal to the Preprocessor.\n  llvm::BumpPtrAllocator BP;\n\n  /// Identifiers for builtin macros and other builtins.\n  IdentifierInfo *Ident__LINE__, *Ident__FILE__;   // __LINE__, __FILE__\n  IdentifierInfo *Ident__DATE__, *Ident__TIME__;   // __DATE__, __TIME__\n  IdentifierInfo *Ident__INCLUDE_LEVEL__;          // __INCLUDE_LEVEL__\n  IdentifierInfo *Ident__BASE_FILE__;              // __BASE_FILE__\n  IdentifierInfo *Ident__FILE_NAME__;              // __FILE_NAME__\n  IdentifierInfo *Ident__TIMESTAMP__;              // __TIMESTAMP__\n  IdentifierInfo *Ident__COUNTER__;                // __COUNTER__\n  IdentifierInfo *Ident_Pragma, *Ident__pragma;    // _Pragma, __pragma\n  IdentifierInfo *Ident__identifier;               // __identifier\n  IdentifierInfo *Ident__VA_ARGS__;                // __VA_ARGS__\n  IdentifierInfo *Ident__VA_OPT__;                 // __VA_OPT__\n  IdentifierInfo *Ident__has_feature;              // __has_feature\n  IdentifierInfo *Ident__has_extension;            // __has_extension\n  IdentifierInfo *Ident__has_builtin;              // __has_builtin\n  IdentifierInfo *Ident__has_attribute;            // __has_attribute\n  IdentifierInfo *Ident__has_include;              // __has_include\n  IdentifierInfo *Ident__has_include_next;         // __has_include_next\n  IdentifierInfo *Ident__has_warning;              // __has_warning\n  IdentifierInfo *Ident__is_identifier;            // __is_identifier\n  IdentifierInfo *Ident__building_module;          // __building_module\n  IdentifierInfo *Ident__MODULE__;                 // __MODULE__\n  IdentifierInfo *Ident__has_cpp_attribute;        // __has_cpp_attribute\n  IdentifierInfo *Ident__has_c_attribute;          // __has_c_attribute\n  IdentifierInfo *Ident__has_declspec;             // __has_declspec_attribute\n  IdentifierInfo *Ident__is_target_arch;           // __is_target_arch\n  IdentifierInfo *Ident__is_target_vendor;         // __is_target_vendor\n  IdentifierInfo *Ident__is_target_os;             // __is_target_os\n  IdentifierInfo *Ident__is_target_environment;    // __is_target_environment\n\n  // Weak, only valid (and set) while InMacroArgs is true.\n  Token* ArgMacro;\n\n  SourceLocation DATELoc, TIMELoc;\n\n  // Next __COUNTER__ value, starts at 0.\n  unsigned CounterValue = 0;\n\n  enum {\n    /// Maximum depth of \\#includes.\n    MaxAllowedIncludeStackDepth = 200\n  };\n\n  // State that is set before the preprocessor begins.\n  bool KeepComments : 1;\n  bool KeepMacroComments : 1;\n  bool SuppressIncludeNotFoundError : 1;\n\n  // State that changes while the preprocessor runs:\n  bool InMacroArgs : 1;            // True if parsing fn macro invocation args.\n\n  /// Whether the preprocessor owns the header search object.\n  bool OwnsHeaderSearch : 1;\n\n  /// True if macro expansion is disabled.\n  bool DisableMacroExpansion : 1;\n\n  /// Temporarily disables DisableMacroExpansion (i.e. enables expansion)\n  /// when parsing preprocessor directives.\n  bool MacroExpansionInDirectivesOverride : 1;\n\n  class ResetMacroExpansionHelper;\n\n  /// Whether we have already loaded macros from the external source.\n  mutable bool ReadMacrosFromExternalSource : 1;\n\n  /// True if pragmas are enabled.\n  bool PragmasEnabled : 1;\n\n  /// True if the current build action is a preprocessing action.\n  bool PreprocessedOutput : 1;\n\n  /// True if we are currently preprocessing a #if or #elif directive\n  bool ParsingIfOrElifDirective;\n\n  /// True if we are pre-expanding macro arguments.\n  bool InMacroArgPreExpansion;\n\n  /// Mapping/lookup information for all identifiers in\n  /// the program, including program keywords.\n  mutable IdentifierTable Identifiers;\n\n  /// This table contains all the selectors in the program.\n  ///\n  /// Unlike IdentifierTable above, this table *isn't* populated by the\n  /// preprocessor. It is declared/expanded here because its role/lifetime is\n  /// conceptually similar to the IdentifierTable. In addition, the current\n  /// control flow (in clang::ParseAST()), make it convenient to put here.\n  ///\n  /// FIXME: Make sure the lifetime of Identifiers/Selectors *isn't* tied to\n  /// the lifetime of the preprocessor.\n  SelectorTable Selectors;\n\n  /// Information about builtins.\n  std::unique_ptr<Builtin::Context> BuiltinInfo;\n\n  /// Tracks all of the pragmas that the client registered\n  /// with this preprocessor.\n  std::unique_ptr<PragmaNamespace> PragmaHandlers;\n\n  /// Pragma handlers of the original source is stored here during the\n  /// parsing of a model file.\n  std::unique_ptr<PragmaNamespace> PragmaHandlersBackup;\n\n  /// Tracks all of the comment handlers that the client registered\n  /// with this preprocessor.\n  std::vector<CommentHandler *> CommentHandlers;\n\n  /// Empty line handler.\n  EmptylineHandler *Emptyline = nullptr;\n\n  /// True if we want to ignore EOF token and continue later on (thus\n  /// avoid tearing the Lexer and etc. down).\n  bool IncrementalProcessing = false;\n\n  /// The kind of translation unit we are processing.\n  TranslationUnitKind TUKind;\n\n  /// The code-completion handler.\n  CodeCompletionHandler *CodeComplete = nullptr;\n\n  /// The file that we're performing code-completion for, if any.\n  const FileEntry *CodeCompletionFile = nullptr;\n\n  /// The offset in file for the code-completion point.\n  unsigned CodeCompletionOffset = 0;\n\n  /// The location for the code-completion point. This gets instantiated\n  /// when the CodeCompletionFile gets \\#include'ed for preprocessing.\n  SourceLocation CodeCompletionLoc;\n\n  /// The start location for the file of the code-completion point.\n  ///\n  /// This gets instantiated when the CodeCompletionFile gets \\#include'ed\n  /// for preprocessing.\n  SourceLocation CodeCompletionFileLoc;\n\n  /// The source location of the \\c import contextual keyword we just\n  /// lexed, if any.\n  SourceLocation ModuleImportLoc;\n\n  /// The module import path that we're currently processing.\n  SmallVector<std::pair<IdentifierInfo *, SourceLocation>, 2> ModuleImportPath;\n\n  /// Whether the last token we lexed was an '@'.\n  bool LastTokenWasAt = false;\n\n  /// A position within a C++20 import-seq.\n  class ImportSeq {\n  public:\n    enum State : int {\n      // Positive values represent a number of unclosed brackets.\n      AtTopLevel = 0,\n      AfterTopLevelTokenSeq = -1,\n      AfterExport = -2,\n      AfterImportSeq = -3,\n    };\n\n    ImportSeq(State S) : S(S) {}\n\n    /// Saw any kind of open bracket.\n    void handleOpenBracket() {\n      S = static_cast<State>(std::max<int>(S, 0) + 1);\n    }\n    /// Saw any kind of close bracket other than '}'.\n    void handleCloseBracket() {\n      S = static_cast<State>(std::max<int>(S, 1) - 1);\n    }\n    /// Saw a close brace.\n    void handleCloseBrace() {\n      handleCloseBracket();\n      if (S == AtTopLevel && !AfterHeaderName)\n        S = AfterTopLevelTokenSeq;\n    }\n    /// Saw a semicolon.\n    void handleSemi() {\n      if (atTopLevel()) {\n        S = AfterTopLevelTokenSeq;\n        AfterHeaderName = false;\n      }\n    }\n\n    /// Saw an 'export' identifier.\n    void handleExport() {\n      if (S == AfterTopLevelTokenSeq)\n        S = AfterExport;\n      else if (S <= 0)\n        S = AtTopLevel;\n    }\n    /// Saw an 'import' identifier.\n    void handleImport() {\n      if (S == AfterTopLevelTokenSeq || S == AfterExport)\n        S = AfterImportSeq;\n      else if (S <= 0)\n        S = AtTopLevel;\n    }\n\n    /// Saw a 'header-name' token; do not recognize any more 'import' tokens\n    /// until we reach a top-level semicolon.\n    void handleHeaderName() {\n      if (S == AfterImportSeq)\n        AfterHeaderName = true;\n      handleMisc();\n    }\n\n    /// Saw any other token.\n    void handleMisc() {\n      if (S <= 0)\n        S = AtTopLevel;\n    }\n\n    bool atTopLevel() { return S <= 0; }\n    bool afterImportSeq() { return S == AfterImportSeq; }\n\n  private:\n    State S;\n    /// Whether we're in the pp-import-suffix following the header-name in a\n    /// pp-import. If so, a close-brace is not sufficient to end the\n    /// top-level-token-seq of an import-seq.\n    bool AfterHeaderName = false;\n  };\n\n  /// Our current position within a C++20 import-seq.\n  ImportSeq ImportSeqState = ImportSeq::AfterTopLevelTokenSeq;\n\n  /// Whether the module import expects an identifier next. Otherwise,\n  /// it expects a '.' or ';'.\n  bool ModuleImportExpectsIdentifier = false;\n\n  /// The identifier and source location of the currently-active\n  /// \\#pragma clang arc_cf_code_audited begin.\n  std::pair<IdentifierInfo *, SourceLocation> PragmaARCCFCodeAuditedInfo;\n\n  /// The source location of the currently-active\n  /// \\#pragma clang assume_nonnull begin.\n  SourceLocation PragmaAssumeNonNullLoc;\n\n  /// True if we hit the code-completion point.\n  bool CodeCompletionReached = false;\n\n  /// The code completion token containing the information\n  /// on the stem that is to be code completed.\n  IdentifierInfo *CodeCompletionII = nullptr;\n\n  /// Range for the code completion token.\n  SourceRange CodeCompletionTokenRange;\n\n  /// The directory that the main file should be considered to occupy,\n  /// if it does not correspond to a real file (as happens when building a\n  /// module).\n  const DirectoryEntry *MainFileDir = nullptr;\n\n  /// The number of bytes that we will initially skip when entering the\n  /// main file, along with a flag that indicates whether skipping this number\n  /// of bytes will place the lexer at the start of a line.\n  ///\n  /// This is used when loading a precompiled preamble.\n  std::pair<int, bool> SkipMainFilePreamble;\n\n  /// Whether we hit an error due to reaching max allowed include depth. Allows\n  /// to avoid hitting the same error over and over again.\n  bool HasReachedMaxIncludeDepth = false;\n\n  /// The number of currently-active calls to Lex.\n  ///\n  /// Lex is reentrant, and asking for an (end-of-phase-4) token can often\n  /// require asking for multiple additional tokens. This counter makes it\n  /// possible for Lex to detect whether it's producing a token for the end\n  /// of phase 4 of translation or for some other situation.\n  unsigned LexLevel = 0;\n\n  /// The number of (LexLevel 0) preprocessor tokens.\n  unsigned TokenCount = 0;\n\n  /// Preprocess every token regardless of LexLevel.\n  bool PreprocessToken = false;\n\n  /// The maximum number of (LexLevel 0) tokens before issuing a -Wmax-tokens\n  /// warning, or zero for unlimited.\n  unsigned MaxTokens = 0;\n  SourceLocation MaxTokensOverrideLoc;\n\npublic:\n  struct PreambleSkipInfo {\n    SourceLocation HashTokenLoc;\n    SourceLocation IfTokenLoc;\n    bool FoundNonSkipPortion;\n    bool FoundElse;\n    SourceLocation ElseLoc;\n\n    PreambleSkipInfo(SourceLocation HashTokenLoc, SourceLocation IfTokenLoc,\n                     bool FoundNonSkipPortion, bool FoundElse,\n                     SourceLocation ElseLoc)\n        : HashTokenLoc(HashTokenLoc), IfTokenLoc(IfTokenLoc),\n          FoundNonSkipPortion(FoundNonSkipPortion), FoundElse(FoundElse),\n          ElseLoc(ElseLoc) {}\n  };\n\nprivate:\n  friend class ASTReader;\n  friend class MacroArgs;\n\n  class PreambleConditionalStackStore {\n    enum State {\n      Off = 0,\n      Recording = 1,\n      Replaying = 2,\n    };\n\n  public:\n    PreambleConditionalStackStore() = default;\n\n    void startRecording() { ConditionalStackState = Recording; }\n    void startReplaying() { ConditionalStackState = Replaying; }\n    bool isRecording() const { return ConditionalStackState == Recording; }\n    bool isReplaying() const { return ConditionalStackState == Replaying; }\n\n    ArrayRef<PPConditionalInfo> getStack() const {\n      return ConditionalStack;\n    }\n\n    void doneReplaying() {\n      ConditionalStack.clear();\n      ConditionalStackState = Off;\n    }\n\n    void setStack(ArrayRef<PPConditionalInfo> s) {\n      if (!isRecording() && !isReplaying())\n        return;\n      ConditionalStack.clear();\n      ConditionalStack.append(s.begin(), s.end());\n    }\n\n    bool hasRecordedPreamble() const { return !ConditionalStack.empty(); }\n\n    bool reachedEOFWhileSkipping() const { return SkipInfo.hasValue(); }\n\n    void clearSkipInfo() { SkipInfo.reset(); }\n\n    llvm::Optional<PreambleSkipInfo> SkipInfo;\n\n  private:\n    SmallVector<PPConditionalInfo, 4> ConditionalStack;\n    State ConditionalStackState = Off;\n  } PreambleConditionalStack;\n\n  /// The current top of the stack that we're lexing from if\n  /// not expanding a macro and we are lexing directly from source code.\n  ///\n  /// Only one of CurLexer, or CurTokenLexer will be non-null.\n  std::unique_ptr<Lexer> CurLexer;\n\n  /// The current top of the stack what we're lexing from\n  /// if not expanding a macro.\n  ///\n  /// This is an alias for CurLexer.\n  PreprocessorLexer *CurPPLexer = nullptr;\n\n  /// Used to find the current FileEntry, if CurLexer is non-null\n  /// and if applicable.\n  ///\n  /// This allows us to implement \\#include_next and find directory-specific\n  /// properties.\n  const DirectoryLookup *CurDirLookup = nullptr;\n\n  /// The current macro we are expanding, if we are expanding a macro.\n  ///\n  /// One of CurLexer and CurTokenLexer must be null.\n  std::unique_ptr<TokenLexer> CurTokenLexer;\n\n  /// The kind of lexer we're currently working with.\n  enum CurLexerKind {\n    CLK_Lexer,\n    CLK_TokenLexer,\n    CLK_CachingLexer,\n    CLK_LexAfterModuleImport\n  } CurLexerKind = CLK_Lexer;\n\n  /// If the current lexer is for a submodule that is being built, this\n  /// is that submodule.\n  Module *CurLexerSubmodule = nullptr;\n\n  /// Keeps track of the stack of files currently\n  /// \\#included, and macros currently being expanded from, not counting\n  /// CurLexer/CurTokenLexer.\n  struct IncludeStackInfo {\n    enum CurLexerKind           CurLexerKind;\n    Module                     *TheSubmodule;\n    std::unique_ptr<Lexer>      TheLexer;\n    PreprocessorLexer          *ThePPLexer;\n    std::unique_ptr<TokenLexer> TheTokenLexer;\n    const DirectoryLookup      *TheDirLookup;\n\n    // The following constructors are completely useless copies of the default\n    // versions, only needed to pacify MSVC.\n    IncludeStackInfo(enum CurLexerKind CurLexerKind, Module *TheSubmodule,\n                     std::unique_ptr<Lexer> &&TheLexer,\n                     PreprocessorLexer *ThePPLexer,\n                     std::unique_ptr<TokenLexer> &&TheTokenLexer,\n                     const DirectoryLookup *TheDirLookup)\n        : CurLexerKind(std::move(CurLexerKind)),\n          TheSubmodule(std::move(TheSubmodule)), TheLexer(std::move(TheLexer)),\n          ThePPLexer(std::move(ThePPLexer)),\n          TheTokenLexer(std::move(TheTokenLexer)),\n          TheDirLookup(std::move(TheDirLookup)) {}\n  };\n  std::vector<IncludeStackInfo> IncludeMacroStack;\n\n  /// Actions invoked when some preprocessor activity is\n  /// encountered (e.g. a file is \\#included, etc).\n  std::unique_ptr<PPCallbacks> Callbacks;\n\n  struct MacroExpandsInfo {\n    Token Tok;\n    MacroDefinition MD;\n    SourceRange Range;\n\n    MacroExpandsInfo(Token Tok, MacroDefinition MD, SourceRange Range)\n        : Tok(Tok), MD(MD), Range(Range) {}\n  };\n  SmallVector<MacroExpandsInfo, 2> DelayedMacroExpandsCallbacks;\n\n  /// Information about a name that has been used to define a module macro.\n  struct ModuleMacroInfo {\n    /// The most recent macro directive for this identifier.\n    MacroDirective *MD;\n\n    /// The active module macros for this identifier.\n    llvm::TinyPtrVector<ModuleMacro *> ActiveModuleMacros;\n\n    /// The generation number at which we last updated ActiveModuleMacros.\n    /// \\see Preprocessor::VisibleModules.\n    unsigned ActiveModuleMacrosGeneration = 0;\n\n    /// Whether this macro name is ambiguous.\n    bool IsAmbiguous = false;\n\n    /// The module macros that are overridden by this macro.\n    llvm::TinyPtrVector<ModuleMacro *> OverriddenMacros;\n\n    ModuleMacroInfo(MacroDirective *MD) : MD(MD) {}\n  };\n\n  /// The state of a macro for an identifier.\n  class MacroState {\n    mutable llvm::PointerUnion<MacroDirective *, ModuleMacroInfo *> State;\n\n    ModuleMacroInfo *getModuleInfo(Preprocessor &PP,\n                                   const IdentifierInfo *II) const {\n      if (II->isOutOfDate())\n        PP.updateOutOfDateIdentifier(const_cast<IdentifierInfo&>(*II));\n      // FIXME: Find a spare bit on IdentifierInfo and store a\n      //        HasModuleMacros flag.\n      if (!II->hasMacroDefinition() ||\n          (!PP.getLangOpts().Modules &&\n           !PP.getLangOpts().ModulesLocalVisibility) ||\n          !PP.CurSubmoduleState->VisibleModules.getGeneration())\n        return nullptr;\n\n      auto *Info = State.dyn_cast<ModuleMacroInfo*>();\n      if (!Info) {\n        Info = new (PP.getPreprocessorAllocator())\n            ModuleMacroInfo(State.get<MacroDirective *>());\n        State = Info;\n      }\n\n      if (PP.CurSubmoduleState->VisibleModules.getGeneration() !=\n          Info->ActiveModuleMacrosGeneration)\n        PP.updateModuleMacroInfo(II, *Info);\n      return Info;\n    }\n\n  public:\n    MacroState() : MacroState(nullptr) {}\n    MacroState(MacroDirective *MD) : State(MD) {}\n\n    MacroState(MacroState &&O) noexcept : State(O.State) {\n      O.State = (MacroDirective *)nullptr;\n    }\n\n    MacroState &operator=(MacroState &&O) noexcept {\n      auto S = O.State;\n      O.State = (MacroDirective *)nullptr;\n      State = S;\n      return *this;\n    }\n\n    ~MacroState() {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        Info->~ModuleMacroInfo();\n    }\n\n    MacroDirective *getLatest() const {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        return Info->MD;\n      return State.get<MacroDirective*>();\n    }\n\n    void setLatest(MacroDirective *MD) {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        Info->MD = MD;\n      else\n        State = MD;\n    }\n\n    bool isAmbiguous(Preprocessor &PP, const IdentifierInfo *II) const {\n      auto *Info = getModuleInfo(PP, II);\n      return Info ? Info->IsAmbiguous : false;\n    }\n\n    ArrayRef<ModuleMacro *>\n    getActiveModuleMacros(Preprocessor &PP, const IdentifierInfo *II) const {\n      if (auto *Info = getModuleInfo(PP, II))\n        return Info->ActiveModuleMacros;\n      return None;\n    }\n\n    MacroDirective::DefInfo findDirectiveAtLoc(SourceLocation Loc,\n                                               SourceManager &SourceMgr) const {\n      // FIXME: Incorporate module macros into the result of this.\n      if (auto *Latest = getLatest())\n        return Latest->findDirectiveAtLoc(Loc, SourceMgr);\n      return {};\n    }\n\n    void overrideActiveModuleMacros(Preprocessor &PP, IdentifierInfo *II) {\n      if (auto *Info = getModuleInfo(PP, II)) {\n        Info->OverriddenMacros.insert(Info->OverriddenMacros.end(),\n                                      Info->ActiveModuleMacros.begin(),\n                                      Info->ActiveModuleMacros.end());\n        Info->ActiveModuleMacros.clear();\n        Info->IsAmbiguous = false;\n      }\n    }\n\n    ArrayRef<ModuleMacro*> getOverriddenMacros() const {\n      if (auto *Info = State.dyn_cast<ModuleMacroInfo*>())\n        return Info->OverriddenMacros;\n      return None;\n    }\n\n    void setOverriddenMacros(Preprocessor &PP,\n                             ArrayRef<ModuleMacro *> Overrides) {\n      auto *Info = State.dyn_cast<ModuleMacroInfo*>();\n      if (!Info) {\n        if (Overrides.empty())\n          return;\n        Info = new (PP.getPreprocessorAllocator())\n            ModuleMacroInfo(State.get<MacroDirective *>());\n        State = Info;\n      }\n      Info->OverriddenMacros.clear();\n      Info->OverriddenMacros.insert(Info->OverriddenMacros.end(),\n                                    Overrides.begin(), Overrides.end());\n      Info->ActiveModuleMacrosGeneration = 0;\n    }\n  };\n\n  /// For each IdentifierInfo that was associated with a macro, we\n  /// keep a mapping to the history of all macro definitions and #undefs in\n  /// the reverse order (the latest one is in the head of the list).\n  ///\n  /// This mapping lives within the \\p CurSubmoduleState.\n  using MacroMap = llvm::DenseMap<const IdentifierInfo *, MacroState>;\n\n  struct SubmoduleState;\n\n  /// Information about a submodule that we're currently building.\n  struct BuildingSubmoduleInfo {\n    /// The module that we are building.\n    Module *M;\n\n    /// The location at which the module was included.\n    SourceLocation ImportLoc;\n\n    /// Whether we entered this submodule via a pragma.\n    bool IsPragma;\n\n    /// The previous SubmoduleState.\n    SubmoduleState *OuterSubmoduleState;\n\n    /// The number of pending module macro names when we started building this.\n    unsigned OuterPendingModuleMacroNames;\n\n    BuildingSubmoduleInfo(Module *M, SourceLocation ImportLoc, bool IsPragma,\n                          SubmoduleState *OuterSubmoduleState,\n                          unsigned OuterPendingModuleMacroNames)\n        : M(M), ImportLoc(ImportLoc), IsPragma(IsPragma),\n          OuterSubmoduleState(OuterSubmoduleState),\n          OuterPendingModuleMacroNames(OuterPendingModuleMacroNames) {}\n  };\n  SmallVector<BuildingSubmoduleInfo, 8> BuildingSubmoduleStack;\n\n  /// Information about a submodule's preprocessor state.\n  struct SubmoduleState {\n    /// The macros for the submodule.\n    MacroMap Macros;\n\n    /// The set of modules that are visible within the submodule.\n    VisibleModuleSet VisibleModules;\n\n    // FIXME: CounterValue?\n    // FIXME: PragmaPushMacroInfo?\n  };\n  std::map<Module *, SubmoduleState> Submodules;\n\n  /// The preprocessor state for preprocessing outside of any submodule.\n  SubmoduleState NullSubmoduleState;\n\n  /// The current submodule state. Will be \\p NullSubmoduleState if we're not\n  /// in a submodule.\n  SubmoduleState *CurSubmoduleState;\n\n  /// The set of known macros exported from modules.\n  llvm::FoldingSet<ModuleMacro> ModuleMacros;\n\n  /// The names of potential module macros that we've not yet processed.\n  llvm::SmallVector<const IdentifierInfo *, 32> PendingModuleMacroNames;\n\n  /// The list of module macros, for each identifier, that are not overridden by\n  /// any other module macro.\n  llvm::DenseMap<const IdentifierInfo *, llvm::TinyPtrVector<ModuleMacro *>>\n      LeafModuleMacros;\n\n  /// Macros that we want to warn because they are not used at the end\n  /// of the translation unit.\n  ///\n  /// We store just their SourceLocations instead of\n  /// something like MacroInfo*. The benefit of this is that when we are\n  /// deserializing from PCH, we don't need to deserialize identifier & macros\n  /// just so that we can report that they are unused, we just warn using\n  /// the SourceLocations of this set (that will be filled by the ASTReader).\n  /// We are using SmallPtrSet instead of a vector for faster removal.\n  using WarnUnusedMacroLocsTy = llvm::SmallPtrSet<SourceLocation, 32>;\n  WarnUnusedMacroLocsTy WarnUnusedMacroLocs;\n\n  /// A \"freelist\" of MacroArg objects that can be\n  /// reused for quick allocation.\n  MacroArgs *MacroArgCache = nullptr;\n\n  /// For each IdentifierInfo used in a \\#pragma push_macro directive,\n  /// we keep a MacroInfo stack used to restore the previous macro value.\n  llvm::DenseMap<IdentifierInfo *, std::vector<MacroInfo *>>\n      PragmaPushMacroInfo;\n\n  // Various statistics we track for performance analysis.\n  unsigned NumDirectives = 0;\n  unsigned NumDefined = 0;\n  unsigned NumUndefined = 0;\n  unsigned NumPragma = 0;\n  unsigned NumIf = 0;\n  unsigned NumElse = 0;\n  unsigned NumEndif = 0;\n  unsigned NumEnteredSourceFiles = 0;\n  unsigned MaxIncludeStackDepth = 0;\n  unsigned NumMacroExpanded = 0;\n  unsigned NumFnMacroExpanded = 0;\n  unsigned NumBuiltinMacroExpanded = 0;\n  unsigned NumFastMacroExpanded = 0;\n  unsigned NumTokenPaste = 0;\n  unsigned NumFastTokenPaste = 0;\n  unsigned NumSkipped = 0;\n\n  /// The predefined macros that preprocessor should use from the\n  /// command line etc.\n  std::string Predefines;\n\n  /// The file ID for the preprocessor predefines.\n  FileID PredefinesFileID;\n\n  /// The file ID for the PCH through header.\n  FileID PCHThroughHeaderFileID;\n\n  /// Whether tokens are being skipped until a #pragma hdrstop is seen.\n  bool SkippingUntilPragmaHdrStop = false;\n\n  /// Whether tokens are being skipped until the through header is seen.\n  bool SkippingUntilPCHThroughHeader = false;\n\n  /// \\{\n  /// Cache of macro expanders to reduce malloc traffic.\n  enum { TokenLexerCacheSize = 8 };\n  unsigned NumCachedTokenLexers;\n  std::unique_ptr<TokenLexer> TokenLexerCache[TokenLexerCacheSize];\n  /// \\}\n\n  /// Keeps macro expanded tokens for TokenLexers.\n  //\n  /// Works like a stack; a TokenLexer adds the macro expanded tokens that is\n  /// going to lex in the cache and when it finishes the tokens are removed\n  /// from the end of the cache.\n  SmallVector<Token, 16> MacroExpandedTokens;\n  std::vector<std::pair<TokenLexer *, size_t>> MacroExpandingLexersStack;\n\n  /// A record of the macro definitions and expansions that\n  /// occurred during preprocessing.\n  ///\n  /// This is an optional side structure that can be enabled with\n  /// \\c createPreprocessingRecord() prior to preprocessing.\n  PreprocessingRecord *Record = nullptr;\n\n  /// Cached tokens state.\n  using CachedTokensTy = SmallVector<Token, 1>;\n\n  /// Cached tokens are stored here when we do backtracking or\n  /// lookahead. They are \"lexed\" by the CachingLex() method.\n  CachedTokensTy CachedTokens;\n\n  /// The position of the cached token that CachingLex() should\n  /// \"lex\" next.\n  ///\n  /// If it points beyond the CachedTokens vector, it means that a normal\n  /// Lex() should be invoked.\n  CachedTokensTy::size_type CachedLexPos = 0;\n\n  /// Stack of backtrack positions, allowing nested backtracks.\n  ///\n  /// The EnableBacktrackAtThisPos() method pushes a position to\n  /// indicate where CachedLexPos should be set when the BackTrack() method is\n  /// invoked (at which point the last position is popped).\n  std::vector<CachedTokensTy::size_type> BacktrackPositions;\n\n  struct MacroInfoChain {\n    MacroInfo MI;\n    MacroInfoChain *Next;\n  };\n\n  /// MacroInfos are managed as a chain for easy disposal.  This is the head\n  /// of that list.\n  MacroInfoChain *MIChainHead = nullptr;\n\n  void updateOutOfDateIdentifier(IdentifierInfo &II) const;\n\npublic:\n  Preprocessor(std::shared_ptr<PreprocessorOptions> PPOpts,\n               DiagnosticsEngine &diags, LangOptions &opts, SourceManager &SM,\n               HeaderSearch &Headers, ModuleLoader &TheModuleLoader,\n               IdentifierInfoLookup *IILookup = nullptr,\n               bool OwnsHeaderSearch = false,\n               TranslationUnitKind TUKind = TU_Complete);\n\n  ~Preprocessor();\n\n  /// Initialize the preprocessor using information about the target.\n  ///\n  /// \\param Target is owned by the caller and must remain valid for the\n  /// lifetime of the preprocessor.\n  /// \\param AuxTarget is owned by the caller and must remain valid for\n  /// the lifetime of the preprocessor.\n  void Initialize(const TargetInfo &Target,\n                  const TargetInfo *AuxTarget = nullptr);\n\n  /// Initialize the preprocessor to parse a model file\n  ///\n  /// To parse model files the preprocessor of the original source is reused to\n  /// preserver the identifier table. However to avoid some duplicate\n  /// information in the preprocessor some cleanup is needed before it is used\n  /// to parse model files. This method does that cleanup.\n  void InitializeForModelFile();\n\n  /// Cleanup after model file parsing\n  void FinalizeForModelFile();\n\n  /// Retrieve the preprocessor options used to initialize this\n  /// preprocessor.\n  PreprocessorOptions &getPreprocessorOpts() const { return *PPOpts; }\n\n  DiagnosticsEngine &getDiagnostics() const { return *Diags; }\n  void setDiagnostics(DiagnosticsEngine &D) { Diags = &D; }\n\n  const LangOptions &getLangOpts() const { return LangOpts; }\n  const TargetInfo &getTargetInfo() const { return *Target; }\n  const TargetInfo *getAuxTargetInfo() const { return AuxTarget; }\n  FileManager &getFileManager() const { return FileMgr; }\n  SourceManager &getSourceManager() const { return SourceMgr; }\n  HeaderSearch &getHeaderSearchInfo() const { return HeaderInfo; }\n\n  IdentifierTable &getIdentifierTable() { return Identifiers; }\n  const IdentifierTable &getIdentifierTable() const { return Identifiers; }\n  SelectorTable &getSelectorTable() { return Selectors; }\n  Builtin::Context &getBuiltinInfo() { return *BuiltinInfo; }\n  llvm::BumpPtrAllocator &getPreprocessorAllocator() { return BP; }\n\n  void setExternalSource(ExternalPreprocessorSource *Source) {\n    ExternalSource = Source;\n  }\n\n  ExternalPreprocessorSource *getExternalSource() const {\n    return ExternalSource;\n  }\n\n  /// Retrieve the module loader associated with this preprocessor.\n  ModuleLoader &getModuleLoader() const { return TheModuleLoader; }\n\n  bool hadModuleLoaderFatalFailure() const {\n    return TheModuleLoader.HadFatalFailure;\n  }\n\n  /// Retrieve the number of Directives that have been processed by the\n  /// Preprocessor.\n  unsigned getNumDirectives() const {\n    return NumDirectives;\n  }\n\n  /// True if we are currently preprocessing a #if or #elif directive\n  bool isParsingIfOrElifDirective() const {\n    return ParsingIfOrElifDirective;\n  }\n\n  /// Control whether the preprocessor retains comments in output.\n  void SetCommentRetentionState(bool KeepComments, bool KeepMacroComments) {\n    this->KeepComments = KeepComments | KeepMacroComments;\n    this->KeepMacroComments = KeepMacroComments;\n  }\n\n  bool getCommentRetentionState() const { return KeepComments; }\n\n  void setPragmasEnabled(bool Enabled) { PragmasEnabled = Enabled; }\n  bool getPragmasEnabled() const { return PragmasEnabled; }\n\n  void SetSuppressIncludeNotFoundError(bool Suppress) {\n    SuppressIncludeNotFoundError = Suppress;\n  }\n\n  bool GetSuppressIncludeNotFoundError() {\n    return SuppressIncludeNotFoundError;\n  }\n\n  /// Sets whether the preprocessor is responsible for producing output or if\n  /// it is producing tokens to be consumed by Parse and Sema.\n  void setPreprocessedOutput(bool IsPreprocessedOutput) {\n    PreprocessedOutput = IsPreprocessedOutput;\n  }\n\n  /// Returns true if the preprocessor is responsible for generating output,\n  /// false if it is producing tokens to be consumed by Parse and Sema.\n  bool isPreprocessedOutput() const { return PreprocessedOutput; }\n\n  /// Return true if we are lexing directly from the specified lexer.\n  bool isCurrentLexer(const PreprocessorLexer *L) const {\n    return CurPPLexer == L;\n  }\n\n  /// Return the current lexer being lexed from.\n  ///\n  /// Note that this ignores any potentially active macro expansions and _Pragma\n  /// expansions going on at the time.\n  PreprocessorLexer *getCurrentLexer() const { return CurPPLexer; }\n\n  /// Return the current file lexer being lexed from.\n  ///\n  /// Note that this ignores any potentially active macro expansions and _Pragma\n  /// expansions going on at the time.\n  PreprocessorLexer *getCurrentFileLexer() const;\n\n  /// Return the submodule owning the file being lexed. This may not be\n  /// the current module if we have changed modules since entering the file.\n  Module *getCurrentLexerSubmodule() const { return CurLexerSubmodule; }\n\n  /// Returns the FileID for the preprocessor predefines.\n  FileID getPredefinesFileID() const { return PredefinesFileID; }\n\n  /// \\{\n  /// Accessors for preprocessor callbacks.\n  ///\n  /// Note that this class takes ownership of any PPCallbacks object given to\n  /// it.\n  PPCallbacks *getPPCallbacks() const { return Callbacks.get(); }\n  void addPPCallbacks(std::unique_ptr<PPCallbacks> C) {\n    if (Callbacks)\n      C = std::make_unique<PPChainedCallbacks>(std::move(C),\n                                                std::move(Callbacks));\n    Callbacks = std::move(C);\n  }\n  /// \\}\n\n  /// Get the number of tokens processed so far.\n  unsigned getTokenCount() const { return TokenCount; }\n\n  /// Get the max number of tokens before issuing a -Wmax-tokens warning.\n  unsigned getMaxTokens() const { return MaxTokens; }\n\n  void overrideMaxTokens(unsigned Value, SourceLocation Loc) {\n    MaxTokens = Value;\n    MaxTokensOverrideLoc = Loc;\n  };\n\n  SourceLocation getMaxTokensOverrideLoc() const { return MaxTokensOverrideLoc; }\n\n  /// Register a function that would be called on each token in the final\n  /// expanded token stream.\n  /// This also reports annotation tokens produced by the parser.\n  void setTokenWatcher(llvm::unique_function<void(const clang::Token &)> F) {\n    OnToken = std::move(F);\n  }\n\n  void setPreprocessToken(bool Preprocess) { PreprocessToken = Preprocess; }\n\n  bool isMacroDefined(StringRef Id) {\n    return isMacroDefined(&Identifiers.get(Id));\n  }\n  bool isMacroDefined(const IdentifierInfo *II) {\n    return II->hasMacroDefinition() &&\n           (!getLangOpts().Modules || (bool)getMacroDefinition(II));\n  }\n\n  /// Determine whether II is defined as a macro within the module M,\n  /// if that is a module that we've already preprocessed. Does not check for\n  /// macros imported into M.\n  bool isMacroDefinedInLocalModule(const IdentifierInfo *II, Module *M) {\n    if (!II->hasMacroDefinition())\n      return false;\n    auto I = Submodules.find(M);\n    if (I == Submodules.end())\n      return false;\n    auto J = I->second.Macros.find(II);\n    if (J == I->second.Macros.end())\n      return false;\n    auto *MD = J->second.getLatest();\n    return MD && MD->isDefined();\n  }\n\n  MacroDefinition getMacroDefinition(const IdentifierInfo *II) {\n    if (!II->hasMacroDefinition())\n      return {};\n\n    MacroState &S = CurSubmoduleState->Macros[II];\n    auto *MD = S.getLatest();\n    while (MD && isa<VisibilityMacroDirective>(MD))\n      MD = MD->getPrevious();\n    return MacroDefinition(dyn_cast_or_null<DefMacroDirective>(MD),\n                           S.getActiveModuleMacros(*this, II),\n                           S.isAmbiguous(*this, II));\n  }\n\n  MacroDefinition getMacroDefinitionAtLoc(const IdentifierInfo *II,\n                                          SourceLocation Loc) {\n    if (!II->hadMacroDefinition())\n      return {};\n\n    MacroState &S = CurSubmoduleState->Macros[II];\n    MacroDirective::DefInfo DI;\n    if (auto *MD = S.getLatest())\n      DI = MD->findDirectiveAtLoc(Loc, getSourceManager());\n    // FIXME: Compute the set of active module macros at the specified location.\n    return MacroDefinition(DI.getDirective(),\n                           S.getActiveModuleMacros(*this, II),\n                           S.isAmbiguous(*this, II));\n  }\n\n  /// Given an identifier, return its latest non-imported MacroDirective\n  /// if it is \\#define'd and not \\#undef'd, or null if it isn't \\#define'd.\n  MacroDirective *getLocalMacroDirective(const IdentifierInfo *II) const {\n    if (!II->hasMacroDefinition())\n      return nullptr;\n\n    auto *MD = getLocalMacroDirectiveHistory(II);\n    if (!MD || MD->getDefinition().isUndefined())\n      return nullptr;\n\n    return MD;\n  }\n\n  const MacroInfo *getMacroInfo(const IdentifierInfo *II) const {\n    return const_cast<Preprocessor*>(this)->getMacroInfo(II);\n  }\n\n  MacroInfo *getMacroInfo(const IdentifierInfo *II) {\n    if (!II->hasMacroDefinition())\n      return nullptr;\n    if (auto MD = getMacroDefinition(II))\n      return MD.getMacroInfo();\n    return nullptr;\n  }\n\n  /// Given an identifier, return the latest non-imported macro\n  /// directive for that identifier.\n  ///\n  /// One can iterate over all previous macro directives from the most recent\n  /// one.\n  MacroDirective *getLocalMacroDirectiveHistory(const IdentifierInfo *II) const;\n\n  /// Add a directive to the macro directive history for this identifier.\n  void appendMacroDirective(IdentifierInfo *II, MacroDirective *MD);\n  DefMacroDirective *appendDefMacroDirective(IdentifierInfo *II, MacroInfo *MI,\n                                             SourceLocation Loc) {\n    DefMacroDirective *MD = AllocateDefMacroDirective(MI, Loc);\n    appendMacroDirective(II, MD);\n    return MD;\n  }\n  DefMacroDirective *appendDefMacroDirective(IdentifierInfo *II,\n                                             MacroInfo *MI) {\n    return appendDefMacroDirective(II, MI, MI->getDefinitionLoc());\n  }\n\n  /// Set a MacroDirective that was loaded from a PCH file.\n  void setLoadedMacroDirective(IdentifierInfo *II, MacroDirective *ED,\n                               MacroDirective *MD);\n\n  /// Register an exported macro for a module and identifier.\n  ModuleMacro *addModuleMacro(Module *Mod, IdentifierInfo *II, MacroInfo *Macro,\n                              ArrayRef<ModuleMacro *> Overrides, bool &IsNew);\n  ModuleMacro *getModuleMacro(Module *Mod, IdentifierInfo *II);\n\n  /// Get the list of leaf (non-overridden) module macros for a name.\n  ArrayRef<ModuleMacro*> getLeafModuleMacros(const IdentifierInfo *II) const {\n    if (II->isOutOfDate())\n      updateOutOfDateIdentifier(const_cast<IdentifierInfo&>(*II));\n    auto I = LeafModuleMacros.find(II);\n    if (I != LeafModuleMacros.end())\n      return I->second;\n    return None;\n  }\n\n  /// \\{\n  /// Iterators for the macro history table. Currently defined macros have\n  /// IdentifierInfo::hasMacroDefinition() set and an empty\n  /// MacroInfo::getUndefLoc() at the head of the list.\n  using macro_iterator = MacroMap::const_iterator;\n\n  macro_iterator macro_begin(bool IncludeExternalMacros = true) const;\n  macro_iterator macro_end(bool IncludeExternalMacros = true) const;\n\n  llvm::iterator_range<macro_iterator>\n  macros(bool IncludeExternalMacros = true) const {\n    macro_iterator begin = macro_begin(IncludeExternalMacros);\n    macro_iterator end = macro_end(IncludeExternalMacros);\n    return llvm::make_range(begin, end);\n  }\n\n  /// \\}\n\n  /// Return the name of the macro defined before \\p Loc that has\n  /// spelling \\p Tokens.  If there are multiple macros with same spelling,\n  /// return the last one defined.\n  StringRef getLastMacroWithSpelling(SourceLocation Loc,\n                                     ArrayRef<TokenValue> Tokens) const;\n\n  const std::string &getPredefines() const { return Predefines; }\n\n  /// Set the predefines for this Preprocessor.\n  ///\n  /// These predefines are automatically injected when parsing the main file.\n  void setPredefines(const char *P) { Predefines = P; }\n  void setPredefines(StringRef P) { Predefines = std::string(P); }\n\n  /// Return information about the specified preprocessor\n  /// identifier token.\n  IdentifierInfo *getIdentifierInfo(StringRef Name) const {\n    return &Identifiers.get(Name);\n  }\n\n  /// Add the specified pragma handler to this preprocessor.\n  ///\n  /// If \\p Namespace is non-null, then it is a token required to exist on the\n  /// pragma line before the pragma string starts, e.g. \"STDC\" or \"GCC\".\n  void AddPragmaHandler(StringRef Namespace, PragmaHandler *Handler);\n  void AddPragmaHandler(PragmaHandler *Handler) {\n    AddPragmaHandler(StringRef(), Handler);\n  }\n\n  /// Remove the specific pragma handler from this preprocessor.\n  ///\n  /// If \\p Namespace is non-null, then it should be the namespace that\n  /// \\p Handler was added to. It is an error to remove a handler that\n  /// has not been registered.\n  void RemovePragmaHandler(StringRef Namespace, PragmaHandler *Handler);\n  void RemovePragmaHandler(PragmaHandler *Handler) {\n    RemovePragmaHandler(StringRef(), Handler);\n  }\n\n  /// Install empty handlers for all pragmas (making them ignored).\n  void IgnorePragmas();\n\n  /// Set empty line handler.\n  void setEmptylineHandler(EmptylineHandler *Handler) { Emptyline = Handler; }\n\n  EmptylineHandler *getEmptylineHandler() const { return Emptyline; }\n\n  /// Add the specified comment handler to the preprocessor.\n  void addCommentHandler(CommentHandler *Handler);\n\n  /// Remove the specified comment handler.\n  ///\n  /// It is an error to remove a handler that has not been registered.\n  void removeCommentHandler(CommentHandler *Handler);\n\n  /// Set the code completion handler to the given object.\n  void setCodeCompletionHandler(CodeCompletionHandler &Handler) {\n    CodeComplete = &Handler;\n  }\n\n  /// Retrieve the current code-completion handler.\n  CodeCompletionHandler *getCodeCompletionHandler() const {\n    return CodeComplete;\n  }\n\n  /// Clear out the code completion handler.\n  void clearCodeCompletionHandler() {\n    CodeComplete = nullptr;\n  }\n\n  /// Hook used by the lexer to invoke the \"included file\" code\n  /// completion point.\n  void CodeCompleteIncludedFile(llvm::StringRef Dir, bool IsAngled);\n\n  /// Hook used by the lexer to invoke the \"natural language\" code\n  /// completion point.\n  void CodeCompleteNaturalLanguage();\n\n  /// Set the code completion token for filtering purposes.\n  void setCodeCompletionIdentifierInfo(IdentifierInfo *Filter) {\n    CodeCompletionII = Filter;\n  }\n\n  /// Set the code completion token range for detecting replacement range later\n  /// on.\n  void setCodeCompletionTokenRange(const SourceLocation Start,\n                                   const SourceLocation End) {\n    CodeCompletionTokenRange = {Start, End};\n  }\n  SourceRange getCodeCompletionTokenRange() const {\n    return CodeCompletionTokenRange;\n  }\n\n  /// Get the code completion token for filtering purposes.\n  StringRef getCodeCompletionFilter() {\n    if (CodeCompletionII)\n      return CodeCompletionII->getName();\n    return {};\n  }\n\n  /// Retrieve the preprocessing record, or NULL if there is no\n  /// preprocessing record.\n  PreprocessingRecord *getPreprocessingRecord() const { return Record; }\n\n  /// Create a new preprocessing record, which will keep track of\n  /// all macro expansions, macro definitions, etc.\n  void createPreprocessingRecord();\n\n  /// Returns true if the FileEntry is the PCH through header.\n  bool isPCHThroughHeader(const FileEntry *FE);\n\n  /// True if creating a PCH with a through header.\n  bool creatingPCHWithThroughHeader();\n\n  /// True if using a PCH with a through header.\n  bool usingPCHWithThroughHeader();\n\n  /// True if creating a PCH with a #pragma hdrstop.\n  bool creatingPCHWithPragmaHdrStop();\n\n  /// True if using a PCH with a #pragma hdrstop.\n  bool usingPCHWithPragmaHdrStop();\n\n  /// Skip tokens until after the #include of the through header or\n  /// until after a #pragma hdrstop.\n  void SkipTokensWhileUsingPCH();\n\n  /// Process directives while skipping until the through header or\n  /// #pragma hdrstop is found.\n  void HandleSkippedDirectiveWhileUsingPCH(Token &Result,\n                                           SourceLocation HashLoc);\n\n  /// Enter the specified FileID as the main source file,\n  /// which implicitly adds the builtin defines etc.\n  void EnterMainSourceFile();\n\n  /// Inform the preprocessor callbacks that processing is complete.\n  void EndSourceFile();\n\n  /// Add a source file to the top of the include stack and\n  /// start lexing tokens from it instead of the current buffer.\n  ///\n  /// Emits a diagnostic, doesn't enter the file, and returns true on error.\n  bool EnterSourceFile(FileID FID, const DirectoryLookup *Dir,\n                       SourceLocation Loc);\n\n  /// Add a Macro to the top of the include stack and start lexing\n  /// tokens from it instead of the current buffer.\n  ///\n  /// \\param Args specifies the tokens input to a function-like macro.\n  /// \\param ILEnd specifies the location of the ')' for a function-like macro\n  /// or the identifier for an object-like macro.\n  void EnterMacro(Token &Tok, SourceLocation ILEnd, MacroInfo *Macro,\n                  MacroArgs *Args);\n\nprivate:\n  /// Add a \"macro\" context to the top of the include stack,\n  /// which will cause the lexer to start returning the specified tokens.\n  ///\n  /// If \\p DisableMacroExpansion is true, tokens lexed from the token stream\n  /// will not be subject to further macro expansion. Otherwise, these tokens\n  /// will be re-macro-expanded when/if expansion is enabled.\n  ///\n  /// If \\p OwnsTokens is false, this method assumes that the specified stream\n  /// of tokens has a permanent owner somewhere, so they do not need to be\n  /// copied. If it is true, it assumes the array of tokens is allocated with\n  /// \\c new[] and the Preprocessor will delete[] it.\n  ///\n  /// If \\p IsReinject the resulting tokens will have Token::IsReinjected flag\n  /// set, see the flag documentation for details.\n  void EnterTokenStream(const Token *Toks, unsigned NumToks,\n                        bool DisableMacroExpansion, bool OwnsTokens,\n                        bool IsReinject);\n\npublic:\n  void EnterTokenStream(std::unique_ptr<Token[]> Toks, unsigned NumToks,\n                        bool DisableMacroExpansion, bool IsReinject) {\n    EnterTokenStream(Toks.release(), NumToks, DisableMacroExpansion, true,\n                     IsReinject);\n  }\n\n  void EnterTokenStream(ArrayRef<Token> Toks, bool DisableMacroExpansion,\n                        bool IsReinject) {\n    EnterTokenStream(Toks.data(), Toks.size(), DisableMacroExpansion, false,\n                     IsReinject);\n  }\n\n  /// Pop the current lexer/macro exp off the top of the lexer stack.\n  ///\n  /// This should only be used in situations where the current state of the\n  /// top-of-stack lexer is known.\n  void RemoveTopOfLexerStack();\n\n  /// From the point that this method is called, and until\n  /// CommitBacktrackedTokens() or Backtrack() is called, the Preprocessor\n  /// keeps track of the lexed tokens so that a subsequent Backtrack() call will\n  /// make the Preprocessor re-lex the same tokens.\n  ///\n  /// Nested backtracks are allowed, meaning that EnableBacktrackAtThisPos can\n  /// be called multiple times and CommitBacktrackedTokens/Backtrack calls will\n  /// be combined with the EnableBacktrackAtThisPos calls in reverse order.\n  ///\n  /// NOTE: *DO NOT* forget to call either CommitBacktrackedTokens or Backtrack\n  /// at some point after EnableBacktrackAtThisPos. If you don't, caching of\n  /// tokens will continue indefinitely.\n  ///\n  void EnableBacktrackAtThisPos();\n\n  /// Disable the last EnableBacktrackAtThisPos call.\n  void CommitBacktrackedTokens();\n\n  /// Make Preprocessor re-lex the tokens that were lexed since\n  /// EnableBacktrackAtThisPos() was previously called.\n  void Backtrack();\n\n  /// True if EnableBacktrackAtThisPos() was called and\n  /// caching of tokens is on.\n  bool isBacktrackEnabled() const { return !BacktrackPositions.empty(); }\n\n  /// Lex the next token for this preprocessor.\n  void Lex(Token &Result);\n\n  /// Lex a token, forming a header-name token if possible.\n  bool LexHeaderName(Token &Result, bool AllowMacroExpansion = true);\n\n  bool LexAfterModuleImport(Token &Result);\n  void CollectPpImportSuffix(SmallVectorImpl<Token> &Toks);\n\n  void makeModuleVisible(Module *M, SourceLocation Loc);\n\n  SourceLocation getModuleImportLoc(Module *M) const {\n    return CurSubmoduleState->VisibleModules.getImportLoc(M);\n  }\n\n  /// Lex a string literal, which may be the concatenation of multiple\n  /// string literals and may even come from macro expansion.\n  /// \\returns true on success, false if a error diagnostic has been generated.\n  bool LexStringLiteral(Token &Result, std::string &String,\n                        const char *DiagnosticTag, bool AllowMacroExpansion) {\n    if (AllowMacroExpansion)\n      Lex(Result);\n    else\n      LexUnexpandedToken(Result);\n    return FinishLexStringLiteral(Result, String, DiagnosticTag,\n                                  AllowMacroExpansion);\n  }\n\n  /// Complete the lexing of a string literal where the first token has\n  /// already been lexed (see LexStringLiteral).\n  bool FinishLexStringLiteral(Token &Result, std::string &String,\n                              const char *DiagnosticTag,\n                              bool AllowMacroExpansion);\n\n  /// Lex a token.  If it's a comment, keep lexing until we get\n  /// something not a comment.\n  ///\n  /// This is useful in -E -C mode where comments would foul up preprocessor\n  /// directive handling.\n  void LexNonComment(Token &Result) {\n    do\n      Lex(Result);\n    while (Result.getKind() == tok::comment);\n  }\n\n  /// Just like Lex, but disables macro expansion of identifier tokens.\n  void LexUnexpandedToken(Token &Result) {\n    // Disable macro expansion.\n    bool OldVal = DisableMacroExpansion;\n    DisableMacroExpansion = true;\n    // Lex the token.\n    Lex(Result);\n\n    // Reenable it.\n    DisableMacroExpansion = OldVal;\n  }\n\n  /// Like LexNonComment, but this disables macro expansion of\n  /// identifier tokens.\n  void LexUnexpandedNonComment(Token &Result) {\n    do\n      LexUnexpandedToken(Result);\n    while (Result.getKind() == tok::comment);\n  }\n\n  /// Parses a simple integer literal to get its numeric value.  Floating\n  /// point literals and user defined literals are rejected.  Used primarily to\n  /// handle pragmas that accept integer arguments.\n  bool parseSimpleIntegerLiteral(Token &Tok, uint64_t &Value);\n\n  /// Disables macro expansion everywhere except for preprocessor directives.\n  void SetMacroExpansionOnlyInDirectives() {\n    DisableMacroExpansion = true;\n    MacroExpansionInDirectivesOverride = true;\n  }\n\n  /// Peeks ahead N tokens and returns that token without consuming any\n  /// tokens.\n  ///\n  /// LookAhead(0) returns the next token that would be returned by Lex(),\n  /// LookAhead(1) returns the token after it, etc.  This returns normal\n  /// tokens after phase 5.  As such, it is equivalent to using\n  /// 'Lex', not 'LexUnexpandedToken'.\n  const Token &LookAhead(unsigned N) {\n    assert(LexLevel == 0 && \"cannot use lookahead while lexing\");\n    if (CachedLexPos + N < CachedTokens.size())\n      return CachedTokens[CachedLexPos+N];\n    else\n      return PeekAhead(N+1);\n  }\n\n  /// When backtracking is enabled and tokens are cached,\n  /// this allows to revert a specific number of tokens.\n  ///\n  /// Note that the number of tokens being reverted should be up to the last\n  /// backtrack position, not more.\n  void RevertCachedTokens(unsigned N) {\n    assert(isBacktrackEnabled() &&\n           \"Should only be called when tokens are cached for backtracking\");\n    assert(signed(CachedLexPos) - signed(N) >= signed(BacktrackPositions.back())\n         && \"Should revert tokens up to the last backtrack position, not more\");\n    assert(signed(CachedLexPos) - signed(N) >= 0 &&\n           \"Corrupted backtrack positions ?\");\n    CachedLexPos -= N;\n  }\n\n  /// Enters a token in the token stream to be lexed next.\n  ///\n  /// If BackTrack() is called afterwards, the token will remain at the\n  /// insertion point.\n  /// If \\p IsReinject is true, resulting token will have Token::IsReinjected\n  /// flag set. See the flag documentation for details.\n  void EnterToken(const Token &Tok, bool IsReinject) {\n    if (LexLevel) {\n      // It's not correct in general to enter caching lex mode while in the\n      // middle of a nested lexing action.\n      auto TokCopy = std::make_unique<Token[]>(1);\n      TokCopy[0] = Tok;\n      EnterTokenStream(std::move(TokCopy), 1, true, IsReinject);\n    } else {\n      EnterCachingLexMode();\n      assert(IsReinject && \"new tokens in the middle of cached stream\");\n      CachedTokens.insert(CachedTokens.begin()+CachedLexPos, Tok);\n    }\n  }\n\n  /// We notify the Preprocessor that if it is caching tokens (because\n  /// backtrack is enabled) it should replace the most recent cached tokens\n  /// with the given annotation token. This function has no effect if\n  /// backtracking is not enabled.\n  ///\n  /// Note that the use of this function is just for optimization, so that the\n  /// cached tokens doesn't get re-parsed and re-resolved after a backtrack is\n  /// invoked.\n  void AnnotateCachedTokens(const Token &Tok) {\n    assert(Tok.isAnnotation() && \"Expected annotation token\");\n    if (CachedLexPos != 0 && isBacktrackEnabled())\n      AnnotatePreviousCachedTokens(Tok);\n  }\n\n  /// Get the location of the last cached token, suitable for setting the end\n  /// location of an annotation token.\n  SourceLocation getLastCachedTokenLocation() const {\n    assert(CachedLexPos != 0);\n    return CachedTokens[CachedLexPos-1].getLastLoc();\n  }\n\n  /// Whether \\p Tok is the most recent token (`CachedLexPos - 1`) in\n  /// CachedTokens.\n  bool IsPreviousCachedToken(const Token &Tok) const;\n\n  /// Replace token in `CachedLexPos - 1` in CachedTokens by the tokens\n  /// in \\p NewToks.\n  ///\n  /// Useful when a token needs to be split in smaller ones and CachedTokens\n  /// most recent token must to be updated to reflect that.\n  void ReplacePreviousCachedToken(ArrayRef<Token> NewToks);\n\n  /// Replace the last token with an annotation token.\n  ///\n  /// Like AnnotateCachedTokens(), this routine replaces an\n  /// already-parsed (and resolved) token with an annotation\n  /// token. However, this routine only replaces the last token with\n  /// the annotation token; it does not affect any other cached\n  /// tokens. This function has no effect if backtracking is not\n  /// enabled.\n  void ReplaceLastTokenWithAnnotation(const Token &Tok) {\n    assert(Tok.isAnnotation() && \"Expected annotation token\");\n    if (CachedLexPos != 0 && isBacktrackEnabled())\n      CachedTokens[CachedLexPos-1] = Tok;\n  }\n\n  /// Enter an annotation token into the token stream.\n  void EnterAnnotationToken(SourceRange Range, tok::TokenKind Kind,\n                            void *AnnotationVal);\n\n  /// Determine whether it's possible for a future call to Lex to produce an\n  /// annotation token created by a previous call to EnterAnnotationToken.\n  bool mightHavePendingAnnotationTokens() {\n    return CurLexerKind != CLK_Lexer;\n  }\n\n  /// Update the current token to represent the provided\n  /// identifier, in order to cache an action performed by typo correction.\n  void TypoCorrectToken(const Token &Tok) {\n    assert(Tok.getIdentifierInfo() && \"Expected identifier token\");\n    if (CachedLexPos != 0 && isBacktrackEnabled())\n      CachedTokens[CachedLexPos-1] = Tok;\n  }\n\n  /// Recompute the current lexer kind based on the CurLexer/\n  /// CurTokenLexer pointers.\n  void recomputeCurLexerKind();\n\n  /// Returns true if incremental processing is enabled\n  bool isIncrementalProcessingEnabled() const { return IncrementalProcessing; }\n\n  /// Enables the incremental processing\n  void enableIncrementalProcessing(bool value = true) {\n    IncrementalProcessing = value;\n  }\n\n  /// Specify the point at which code-completion will be performed.\n  ///\n  /// \\param File the file in which code completion should occur. If\n  /// this file is included multiple times, code-completion will\n  /// perform completion the first time it is included. If NULL, this\n  /// function clears out the code-completion point.\n  ///\n  /// \\param Line the line at which code completion should occur\n  /// (1-based).\n  ///\n  /// \\param Column the column at which code completion should occur\n  /// (1-based).\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool SetCodeCompletionPoint(const FileEntry *File,\n                              unsigned Line, unsigned Column);\n\n  /// Determine if we are performing code completion.\n  bool isCodeCompletionEnabled() const { return CodeCompletionFile != nullptr; }\n\n  /// Returns the location of the code-completion point.\n  ///\n  /// Returns an invalid location if code-completion is not enabled or the file\n  /// containing the code-completion point has not been lexed yet.\n  SourceLocation getCodeCompletionLoc() const { return CodeCompletionLoc; }\n\n  /// Returns the start location of the file of code-completion point.\n  ///\n  /// Returns an invalid location if code-completion is not enabled or the file\n  /// containing the code-completion point has not been lexed yet.\n  SourceLocation getCodeCompletionFileLoc() const {\n    return CodeCompletionFileLoc;\n  }\n\n  /// Returns true if code-completion is enabled and we have hit the\n  /// code-completion point.\n  bool isCodeCompletionReached() const { return CodeCompletionReached; }\n\n  /// Note that we hit the code-completion point.\n  void setCodeCompletionReached() {\n    assert(isCodeCompletionEnabled() && \"Code-completion not enabled!\");\n    CodeCompletionReached = true;\n    // Silence any diagnostics that occur after we hit the code-completion.\n    getDiagnostics().setSuppressAllDiagnostics(true);\n  }\n\n  /// The location of the currently-active \\#pragma clang\n  /// arc_cf_code_audited begin.\n  ///\n  /// Returns an invalid location if there is no such pragma active.\n  std::pair<IdentifierInfo *, SourceLocation>\n  getPragmaARCCFCodeAuditedInfo() const {\n    return PragmaARCCFCodeAuditedInfo;\n  }\n\n  /// Set the location of the currently-active \\#pragma clang\n  /// arc_cf_code_audited begin.  An invalid location ends the pragma.\n  void setPragmaARCCFCodeAuditedInfo(IdentifierInfo *Ident,\n                                     SourceLocation Loc) {\n    PragmaARCCFCodeAuditedInfo = {Ident, Loc};\n  }\n\n  /// The location of the currently-active \\#pragma clang\n  /// assume_nonnull begin.\n  ///\n  /// Returns an invalid location if there is no such pragma active.\n  SourceLocation getPragmaAssumeNonNullLoc() const {\n    return PragmaAssumeNonNullLoc;\n  }\n\n  /// Set the location of the currently-active \\#pragma clang\n  /// assume_nonnull begin.  An invalid location ends the pragma.\n  void setPragmaAssumeNonNullLoc(SourceLocation Loc) {\n    PragmaAssumeNonNullLoc = Loc;\n  }\n\n  /// Set the directory in which the main file should be considered\n  /// to have been found, if it is not a real file.\n  void setMainFileDir(const DirectoryEntry *Dir) {\n    MainFileDir = Dir;\n  }\n\n  /// Instruct the preprocessor to skip part of the main source file.\n  ///\n  /// \\param Bytes The number of bytes in the preamble to skip.\n  ///\n  /// \\param StartOfLine Whether skipping these bytes puts the lexer at the\n  /// start of a line.\n  void setSkipMainFilePreamble(unsigned Bytes, bool StartOfLine) {\n    SkipMainFilePreamble.first = Bytes;\n    SkipMainFilePreamble.second = StartOfLine;\n  }\n\n  /// Forwarding function for diagnostics.  This emits a diagnostic at\n  /// the specified Token's location, translating the token's start\n  /// position in the current buffer into a SourcePosition object for rendering.\n  DiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID) const {\n    return Diags->Report(Loc, DiagID);\n  }\n\n  DiagnosticBuilder Diag(const Token &Tok, unsigned DiagID) const {\n    return Diags->Report(Tok.getLocation(), DiagID);\n  }\n\n  /// Return the 'spelling' of the token at the given\n  /// location; does not go up to the spelling location or down to the\n  /// expansion location.\n  ///\n  /// \\param buffer A buffer which will be used only if the token requires\n  ///   \"cleaning\", e.g. if it contains trigraphs or escaped newlines\n  /// \\param invalid If non-null, will be set \\c true if an error occurs.\n  StringRef getSpelling(SourceLocation loc,\n                        SmallVectorImpl<char> &buffer,\n                        bool *invalid = nullptr) const {\n    return Lexer::getSpelling(loc, buffer, SourceMgr, LangOpts, invalid);\n  }\n\n  /// Return the 'spelling' of the Tok token.\n  ///\n  /// The spelling of a token is the characters used to represent the token in\n  /// the source file after trigraph expansion and escaped-newline folding.  In\n  /// particular, this wants to get the true, uncanonicalized, spelling of\n  /// things like digraphs, UCNs, etc.\n  ///\n  /// \\param Invalid If non-null, will be set \\c true if an error occurs.\n  std::string getSpelling(const Token &Tok, bool *Invalid = nullptr) const {\n    return Lexer::getSpelling(Tok, SourceMgr, LangOpts, Invalid);\n  }\n\n  /// Get the spelling of a token into a preallocated buffer, instead\n  /// of as an std::string.\n  ///\n  /// The caller is required to allocate enough space for the token, which is\n  /// guaranteed to be at least Tok.getLength() bytes long. The length of the\n  /// actual result is returned.\n  ///\n  /// Note that this method may do two possible things: it may either fill in\n  /// the buffer specified with characters, or it may *change the input pointer*\n  /// to point to a constant buffer with the data already in it (avoiding a\n  /// copy).  The caller is not allowed to modify the returned buffer pointer\n  /// if an internal buffer is returned.\n  unsigned getSpelling(const Token &Tok, const char *&Buffer,\n                       bool *Invalid = nullptr) const {\n    return Lexer::getSpelling(Tok, Buffer, SourceMgr, LangOpts, Invalid);\n  }\n\n  /// Get the spelling of a token into a SmallVector.\n  ///\n  /// Note that the returned StringRef may not point to the\n  /// supplied buffer if a copy can be avoided.\n  StringRef getSpelling(const Token &Tok,\n                        SmallVectorImpl<char> &Buffer,\n                        bool *Invalid = nullptr) const;\n\n  /// Relex the token at the specified location.\n  /// \\returns true if there was a failure, false on success.\n  bool getRawToken(SourceLocation Loc, Token &Result,\n                   bool IgnoreWhiteSpace = false) {\n    return Lexer::getRawToken(Loc, Result, SourceMgr, LangOpts, IgnoreWhiteSpace);\n  }\n\n  /// Given a Token \\p Tok that is a numeric constant with length 1,\n  /// return the character.\n  char\n  getSpellingOfSingleCharacterNumericConstant(const Token &Tok,\n                                              bool *Invalid = nullptr) const {\n    assert(Tok.is(tok::numeric_constant) &&\n           Tok.getLength() == 1 && \"Called on unsupported token\");\n    assert(!Tok.needsCleaning() && \"Token can't need cleaning with length 1\");\n\n    // If the token is carrying a literal data pointer, just use it.\n    if (const char *D = Tok.getLiteralData())\n      return *D;\n\n    // Otherwise, fall back on getCharacterData, which is slower, but always\n    // works.\n    return *SourceMgr.getCharacterData(Tok.getLocation(), Invalid);\n  }\n\n  /// Retrieve the name of the immediate macro expansion.\n  ///\n  /// This routine starts from a source location, and finds the name of the\n  /// macro responsible for its immediate expansion. It looks through any\n  /// intervening macro argument expansions to compute this. It returns a\n  /// StringRef that refers to the SourceManager-owned buffer of the source\n  /// where that macro name is spelled. Thus, the result shouldn't out-live\n  /// the SourceManager.\n  StringRef getImmediateMacroName(SourceLocation Loc) {\n    return Lexer::getImmediateMacroName(Loc, SourceMgr, getLangOpts());\n  }\n\n  /// Plop the specified string into a scratch buffer and set the\n  /// specified token's location and length to it.\n  ///\n  /// If specified, the source location provides a location of the expansion\n  /// point of the token.\n  void CreateString(StringRef Str, Token &Tok,\n                    SourceLocation ExpansionLocStart = SourceLocation(),\n                    SourceLocation ExpansionLocEnd = SourceLocation());\n\n  /// Split the first Length characters out of the token starting at TokLoc\n  /// and return a location pointing to the split token. Re-lexing from the\n  /// split token will return the split token rather than the original.\n  SourceLocation SplitToken(SourceLocation TokLoc, unsigned Length);\n\n  /// Computes the source location just past the end of the\n  /// token at this source location.\n  ///\n  /// This routine can be used to produce a source location that\n  /// points just past the end of the token referenced by \\p Loc, and\n  /// is generally used when a diagnostic needs to point just after a\n  /// token where it expected something different that it received. If\n  /// the returned source location would not be meaningful (e.g., if\n  /// it points into a macro), this routine returns an invalid\n  /// source location.\n  ///\n  /// \\param Offset an offset from the end of the token, where the source\n  /// location should refer to. The default offset (0) produces a source\n  /// location pointing just past the end of the token; an offset of 1 produces\n  /// a source location pointing to the last character in the token, etc.\n  SourceLocation getLocForEndOfToken(SourceLocation Loc, unsigned Offset = 0) {\n    return Lexer::getLocForEndOfToken(Loc, Offset, SourceMgr, LangOpts);\n  }\n\n  /// Returns true if the given MacroID location points at the first\n  /// token of the macro expansion.\n  ///\n  /// \\param MacroBegin If non-null and function returns true, it is set to\n  /// begin location of the macro.\n  bool isAtStartOfMacroExpansion(SourceLocation loc,\n                                 SourceLocation *MacroBegin = nullptr) const {\n    return Lexer::isAtStartOfMacroExpansion(loc, SourceMgr, LangOpts,\n                                            MacroBegin);\n  }\n\n  /// Returns true if the given MacroID location points at the last\n  /// token of the macro expansion.\n  ///\n  /// \\param MacroEnd If non-null and function returns true, it is set to\n  /// end location of the macro.\n  bool isAtEndOfMacroExpansion(SourceLocation loc,\n                               SourceLocation *MacroEnd = nullptr) const {\n    return Lexer::isAtEndOfMacroExpansion(loc, SourceMgr, LangOpts, MacroEnd);\n  }\n\n  /// Print the token to stderr, used for debugging.\n  void DumpToken(const Token &Tok, bool DumpFlags = false) const;\n  void DumpLocation(SourceLocation Loc) const;\n  void DumpMacro(const MacroInfo &MI) const;\n  void dumpMacroInfo(const IdentifierInfo *II);\n\n  /// Given a location that specifies the start of a\n  /// token, return a new location that specifies a character within the token.\n  SourceLocation AdvanceToTokenCharacter(SourceLocation TokStart,\n                                         unsigned Char) const {\n    return Lexer::AdvanceToTokenCharacter(TokStart, Char, SourceMgr, LangOpts);\n  }\n\n  /// Increment the counters for the number of token paste operations\n  /// performed.\n  ///\n  /// If fast was specified, this is a 'fast paste' case we handled.\n  void IncrementPasteCounter(bool isFast) {\n    if (isFast)\n      ++NumFastTokenPaste;\n    else\n      ++NumTokenPaste;\n  }\n\n  void PrintStats();\n\n  size_t getTotalMemory() const;\n\n  /// When the macro expander pastes together a comment (/##/) in Microsoft\n  /// mode, this method handles updating the current state, returning the\n  /// token on the next source line.\n  void HandleMicrosoftCommentPaste(Token &Tok);\n\n  //===--------------------------------------------------------------------===//\n  // Preprocessor callback methods.  These are invoked by a lexer as various\n  // directives and events are found.\n\n  /// Given a tok::raw_identifier token, look up the\n  /// identifier information for the token and install it into the token,\n  /// updating the token kind accordingly.\n  IdentifierInfo *LookUpIdentifierInfo(Token &Identifier) const;\n\nprivate:\n  llvm::DenseMap<IdentifierInfo*,unsigned> PoisonReasons;\n\npublic:\n  /// Specifies the reason for poisoning an identifier.\n  ///\n  /// If that identifier is accessed while poisoned, then this reason will be\n  /// used instead of the default \"poisoned\" diagnostic.\n  void SetPoisonReason(IdentifierInfo *II, unsigned DiagID);\n\n  /// Display reason for poisoned identifier.\n  void HandlePoisonedIdentifier(Token & Identifier);\n\n  void MaybeHandlePoisonedIdentifier(Token & Identifier) {\n    if(IdentifierInfo * II = Identifier.getIdentifierInfo()) {\n      if(II->isPoisoned()) {\n        HandlePoisonedIdentifier(Identifier);\n      }\n    }\n  }\n\nprivate:\n  /// Identifiers used for SEH handling in Borland. These are only\n  /// allowed in particular circumstances\n  // __except block\n  IdentifierInfo *Ident__exception_code,\n                 *Ident___exception_code,\n                 *Ident_GetExceptionCode;\n  // __except filter expression\n  IdentifierInfo *Ident__exception_info,\n                 *Ident___exception_info,\n                 *Ident_GetExceptionInfo;\n  // __finally\n  IdentifierInfo *Ident__abnormal_termination,\n                 *Ident___abnormal_termination,\n                 *Ident_AbnormalTermination;\n\n  const char *getCurLexerEndPos();\n  void diagnoseMissingHeaderInUmbrellaDir(const Module &Mod);\n\npublic:\n  void PoisonSEHIdentifiers(bool Poison = true); // Borland\n\n  /// Callback invoked when the lexer reads an identifier and has\n  /// filled in the tokens IdentifierInfo member.\n  ///\n  /// This callback potentially macro expands it or turns it into a named\n  /// token (like 'for').\n  ///\n  /// \\returns true if we actually computed a token, false if we need to\n  /// lex again.\n  bool HandleIdentifier(Token &Identifier);\n\n  /// Callback invoked when the lexer hits the end of the current file.\n  ///\n  /// This either returns the EOF token and returns true, or\n  /// pops a level off the include stack and returns false, at which point the\n  /// client should call lex again.\n  bool HandleEndOfFile(Token &Result, bool isEndOfMacro = false);\n\n  /// Callback invoked when the current TokenLexer hits the end of its\n  /// token stream.\n  bool HandleEndOfTokenLexer(Token &Result);\n\n  /// Callback invoked when the lexer sees a # token at the start of a\n  /// line.\n  ///\n  /// This consumes the directive, modifies the lexer/preprocessor state, and\n  /// advances the lexer(s) so that the next token read is the correct one.\n  void HandleDirective(Token &Result);\n\n  /// Ensure that the next token is a tok::eod token.\n  ///\n  /// If not, emit a diagnostic and consume up until the eod.\n  /// If \\p EnableMacros is true, then we consider macros that expand to zero\n  /// tokens as being ok.\n  ///\n  /// \\return The location of the end of the directive (the terminating\n  /// newline).\n  SourceLocation CheckEndOfDirective(const char *DirType,\n                                     bool EnableMacros = false);\n\n  /// Read and discard all tokens remaining on the current line until\n  /// the tok::eod token is found. Returns the range of the skipped tokens.\n  SourceRange DiscardUntilEndOfDirective();\n\n  /// Returns true if the preprocessor has seen a use of\n  /// __DATE__ or __TIME__ in the file so far.\n  bool SawDateOrTime() const {\n    return DATELoc != SourceLocation() || TIMELoc != SourceLocation();\n  }\n  unsigned getCounterValue() const { return CounterValue; }\n  void setCounterValue(unsigned V) { CounterValue = V; }\n\n  /// Retrieves the module that we're currently building, if any.\n  Module *getCurrentModule();\n\n  /// Allocate a new MacroInfo object with the provided SourceLocation.\n  MacroInfo *AllocateMacroInfo(SourceLocation L);\n\n  /// Turn the specified lexer token into a fully checked and spelled\n  /// filename, e.g. as an operand of \\#include.\n  ///\n  /// The caller is expected to provide a buffer that is large enough to hold\n  /// the spelling of the filename, but is also expected to handle the case\n  /// when this method decides to use a different buffer.\n  ///\n  /// \\returns true if the input filename was in <>'s or false if it was\n  /// in \"\"'s.\n  bool GetIncludeFilenameSpelling(SourceLocation Loc,StringRef &Buffer);\n\n  /// Given a \"foo\" or \\<foo> reference, look up the indicated file.\n  ///\n  /// Returns None on failure.  \\p isAngled indicates whether the file\n  /// reference is for system \\#include's or not (i.e. using <> instead of \"\").\n  Optional<FileEntryRef>\n  LookupFile(SourceLocation FilenameLoc, StringRef Filename, bool isAngled,\n             const DirectoryLookup *FromDir, const FileEntry *FromFile,\n             const DirectoryLookup *&CurDir, SmallVectorImpl<char> *SearchPath,\n             SmallVectorImpl<char> *RelativePath,\n             ModuleMap::KnownHeader *SuggestedModule, bool *IsMapped,\n             bool *IsFrameworkFound, bool SkipCache = false);\n\n  /// Get the DirectoryLookup structure used to find the current\n  /// FileEntry, if CurLexer is non-null and if applicable.\n  ///\n  /// This allows us to implement \\#include_next and find directory-specific\n  /// properties.\n  const DirectoryLookup *GetCurDirLookup() { return CurDirLookup; }\n\n  /// Return true if we're in the top-level file, not in a \\#include.\n  bool isInPrimaryFile() const;\n\n  /// Lex an on-off-switch (C99 6.10.6p2) and verify that it is\n  /// followed by EOD.  Return true if the token is not a valid on-off-switch.\n  bool LexOnOffSwitch(tok::OnOffSwitch &Result);\n\n  bool CheckMacroName(Token &MacroNameTok, MacroUse isDefineUndef,\n                      bool *ShadowFlag = nullptr);\n\n  void EnterSubmodule(Module *M, SourceLocation ImportLoc, bool ForPragma);\n  Module *LeaveSubmodule(bool ForPragma);\n\nprivate:\n  friend void TokenLexer::ExpandFunctionArguments();\n\n  void PushIncludeMacroStack() {\n    assert(CurLexerKind != CLK_CachingLexer && \"cannot push a caching lexer\");\n    IncludeMacroStack.emplace_back(CurLexerKind, CurLexerSubmodule,\n                                   std::move(CurLexer), CurPPLexer,\n                                   std::move(CurTokenLexer), CurDirLookup);\n    CurPPLexer = nullptr;\n  }\n\n  void PopIncludeMacroStack() {\n    CurLexer = std::move(IncludeMacroStack.back().TheLexer);\n    CurPPLexer = IncludeMacroStack.back().ThePPLexer;\n    CurTokenLexer = std::move(IncludeMacroStack.back().TheTokenLexer);\n    CurDirLookup  = IncludeMacroStack.back().TheDirLookup;\n    CurLexerSubmodule = IncludeMacroStack.back().TheSubmodule;\n    CurLexerKind = IncludeMacroStack.back().CurLexerKind;\n    IncludeMacroStack.pop_back();\n  }\n\n  void PropagateLineStartLeadingSpaceInfo(Token &Result);\n\n  /// Determine whether we need to create module macros for #defines in the\n  /// current context.\n  bool needModuleMacros() const;\n\n  /// Update the set of active module macros and ambiguity flag for a module\n  /// macro name.\n  void updateModuleMacroInfo(const IdentifierInfo *II, ModuleMacroInfo &Info);\n\n  DefMacroDirective *AllocateDefMacroDirective(MacroInfo *MI,\n                                               SourceLocation Loc);\n  UndefMacroDirective *AllocateUndefMacroDirective(SourceLocation UndefLoc);\n  VisibilityMacroDirective *AllocateVisibilityMacroDirective(SourceLocation Loc,\n                                                             bool isPublic);\n\n  /// Lex and validate a macro name, which occurs after a\n  /// \\#define or \\#undef.\n  ///\n  /// \\param MacroNameTok Token that represents the name defined or undefined.\n  /// \\param IsDefineUndef Kind if preprocessor directive.\n  /// \\param ShadowFlag Points to flag that is set if macro name shadows\n  ///                   a keyword.\n  ///\n  /// This emits a diagnostic, sets the token kind to eod,\n  /// and discards the rest of the macro line if the macro name is invalid.\n  void ReadMacroName(Token &MacroNameTok, MacroUse IsDefineUndef = MU_Other,\n                     bool *ShadowFlag = nullptr);\n\n  /// ReadOptionalMacroParameterListAndBody - This consumes all (i.e. the\n  /// entire line) of the macro's tokens and adds them to MacroInfo, and while\n  /// doing so performs certain validity checks including (but not limited to):\n  ///   - # (stringization) is followed by a macro parameter\n  /// \\param MacroNameTok - Token that represents the macro name\n  /// \\param ImmediatelyAfterHeaderGuard - Macro follows an #ifdef header guard\n  ///\n  ///  Either returns a pointer to a MacroInfo object OR emits a diagnostic and\n  ///  returns a nullptr if an invalid sequence of tokens is encountered.\n  MacroInfo *ReadOptionalMacroParameterListAndBody(\n      const Token &MacroNameTok, bool ImmediatelyAfterHeaderGuard);\n\n  /// The ( starting an argument list of a macro definition has just been read.\n  /// Lex the rest of the parameters and the closing ), updating \\p MI with\n  /// what we learn and saving in \\p LastTok the last token read.\n  /// Return true if an error occurs parsing the arg list.\n  bool ReadMacroParameterList(MacroInfo *MI, Token& LastTok);\n\n  /// We just read a \\#if or related directive and decided that the\n  /// subsequent tokens are in the \\#if'd out portion of the\n  /// file.  Lex the rest of the file, until we see an \\#endif.  If \\p\n  /// FoundNonSkipPortion is true, then we have already emitted code for part of\n  /// this \\#if directive, so \\#else/\\#elif blocks should never be entered. If\n  /// \\p FoundElse is false, then \\#else directives are ok, if not, then we have\n  /// already seen one so a \\#else directive is a duplicate.  When this returns,\n  /// the caller can lex the first valid token.\n  void SkipExcludedConditionalBlock(SourceLocation HashTokenLoc,\n                                    SourceLocation IfTokenLoc,\n                                    bool FoundNonSkipPortion, bool FoundElse,\n                                    SourceLocation ElseLoc = SourceLocation());\n\n  /// Information about the result for evaluating an expression for a\n  /// preprocessor directive.\n  struct DirectiveEvalResult {\n    /// Whether the expression was evaluated as true or not.\n    bool Conditional;\n\n    /// True if the expression contained identifiers that were undefined.\n    bool IncludedUndefinedIds;\n\n    /// The source range for the expression.\n    SourceRange ExprRange;\n  };\n\n  /// Evaluate an integer constant expression that may occur after a\n  /// \\#if or \\#elif directive and return a \\p DirectiveEvalResult object.\n  ///\n  /// If the expression is equivalent to \"!defined(X)\" return X in IfNDefMacro.\n  DirectiveEvalResult EvaluateDirectiveExpression(IdentifierInfo *&IfNDefMacro);\n\n  /// Install the standard preprocessor pragmas:\n  /// \\#pragma GCC poison/system_header/dependency and \\#pragma once.\n  void RegisterBuiltinPragmas();\n\n  /// Register builtin macros such as __LINE__ with the identifier table.\n  void RegisterBuiltinMacros();\n\n  /// If an identifier token is read that is to be expanded as a macro, handle\n  /// it and return the next token as 'Tok'.  If we lexed a token, return true;\n  /// otherwise the caller should lex again.\n  bool HandleMacroExpandedIdentifier(Token &Identifier, const MacroDefinition &MD);\n\n  /// Cache macro expanded tokens for TokenLexers.\n  //\n  /// Works like a stack; a TokenLexer adds the macro expanded tokens that is\n  /// going to lex in the cache and when it finishes the tokens are removed\n  /// from the end of the cache.\n  Token *cacheMacroExpandedTokens(TokenLexer *tokLexer,\n                                  ArrayRef<Token> tokens);\n\n  void removeCachedMacroExpandedTokensOfLastLexer();\n\n  /// Determine whether the next preprocessor token to be\n  /// lexed is a '('.  If so, consume the token and return true, if not, this\n  /// method should have no observable side-effect on the lexed tokens.\n  bool isNextPPTokenLParen();\n\n  /// After reading \"MACRO(\", this method is invoked to read all of the formal\n  /// arguments specified for the macro invocation.  Returns null on error.\n  MacroArgs *ReadMacroCallArgumentList(Token &MacroName, MacroInfo *MI,\n                                       SourceLocation &MacroEnd);\n\n  /// If an identifier token is read that is to be expanded\n  /// as a builtin macro, handle it and return the next token as 'Tok'.\n  void ExpandBuiltinMacro(Token &Tok);\n\n  /// Read a \\c _Pragma directive, slice it up, process it, then\n  /// return the first token after the directive.\n  /// This assumes that the \\c _Pragma token has just been read into \\p Tok.\n  void Handle_Pragma(Token &Tok);\n\n  /// Like Handle_Pragma except the pragma text is not enclosed within\n  /// a string literal.\n  void HandleMicrosoft__pragma(Token &Tok);\n\n  /// Add a lexer to the top of the include stack and\n  /// start lexing tokens from it instead of the current buffer.\n  void EnterSourceFileWithLexer(Lexer *TheLexer, const DirectoryLookup *Dir);\n\n  /// Set the FileID for the preprocessor predefines.\n  void setPredefinesFileID(FileID FID) {\n    assert(PredefinesFileID.isInvalid() && \"PredefinesFileID already set!\");\n    PredefinesFileID = FID;\n  }\n\n  /// Set the FileID for the PCH through header.\n  void setPCHThroughHeaderFileID(FileID FID);\n\n  /// Returns true if we are lexing from a file and not a\n  /// pragma or a macro.\n  static bool IsFileLexer(const Lexer* L, const PreprocessorLexer* P) {\n    return L ? !L->isPragmaLexer() : P != nullptr;\n  }\n\n  static bool IsFileLexer(const IncludeStackInfo& I) {\n    return IsFileLexer(I.TheLexer.get(), I.ThePPLexer);\n  }\n\n  bool IsFileLexer() const {\n    return IsFileLexer(CurLexer.get(), CurPPLexer);\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Caching stuff.\n  void CachingLex(Token &Result);\n\n  bool InCachingLexMode() const {\n    // If the Lexer pointers are 0 and IncludeMacroStack is empty, it means\n    // that we are past EOF, not that we are in CachingLex mode.\n    return !CurPPLexer && !CurTokenLexer && !IncludeMacroStack.empty();\n  }\n\n  void EnterCachingLexMode();\n  void EnterCachingLexModeUnchecked();\n\n  void ExitCachingLexMode() {\n    if (InCachingLexMode())\n      RemoveTopOfLexerStack();\n  }\n\n  const Token &PeekAhead(unsigned N);\n  void AnnotatePreviousCachedTokens(const Token &Tok);\n\n  //===--------------------------------------------------------------------===//\n  /// Handle*Directive - implement the various preprocessor directives.  These\n  /// should side-effect the current preprocessor object so that the next call\n  /// to Lex() will return the appropriate token next.\n  void HandleLineDirective();\n  void HandleDigitDirective(Token &Tok);\n  void HandleUserDiagnosticDirective(Token &Tok, bool isWarning);\n  void HandleIdentSCCSDirective(Token &Tok);\n  void HandleMacroPublicDirective(Token &Tok);\n  void HandleMacroPrivateDirective();\n\n  /// An additional notification that can be produced by a header inclusion or\n  /// import to tell the parser what happened.\n  struct ImportAction {\n    enum ActionKind {\n      None,\n      ModuleBegin,\n      ModuleImport,\n      SkippedModuleImport,\n      Failure,\n    } Kind;\n    Module *ModuleForHeader = nullptr;\n\n    ImportAction(ActionKind AK, Module *Mod = nullptr)\n        : Kind(AK), ModuleForHeader(Mod) {\n      assert((AK == None || Mod || AK == Failure) &&\n             \"no module for module action\");\n    }\n  };\n\n  Optional<FileEntryRef> LookupHeaderIncludeOrImport(\n      const DirectoryLookup *&CurDir, StringRef &Filename,\n      SourceLocation FilenameLoc, CharSourceRange FilenameRange,\n      const Token &FilenameTok, bool &IsFrameworkFound, bool IsImportDecl,\n      bool &IsMapped, const DirectoryLookup *LookupFrom,\n      const FileEntry *LookupFromFile, StringRef &LookupFilename,\n      SmallVectorImpl<char> &RelativePath, SmallVectorImpl<char> &SearchPath,\n      ModuleMap::KnownHeader &SuggestedModule, bool isAngled);\n\n  // File inclusion.\n  void HandleIncludeDirective(SourceLocation HashLoc, Token &Tok,\n                              const DirectoryLookup *LookupFrom = nullptr,\n                              const FileEntry *LookupFromFile = nullptr);\n  ImportAction\n  HandleHeaderIncludeOrImport(SourceLocation HashLoc, Token &IncludeTok,\n                              Token &FilenameTok, SourceLocation EndLoc,\n                              const DirectoryLookup *LookupFrom = nullptr,\n                              const FileEntry *LookupFromFile = nullptr);\n  void HandleIncludeNextDirective(SourceLocation HashLoc, Token &Tok);\n  void HandleIncludeMacrosDirective(SourceLocation HashLoc, Token &Tok);\n  void HandleImportDirective(SourceLocation HashLoc, Token &Tok);\n  void HandleMicrosoftImportDirective(Token &Tok);\n\npublic:\n  /// Check that the given module is available, producing a diagnostic if not.\n  /// \\return \\c true if the check failed (because the module is not available).\n  ///         \\c false if the module appears to be usable.\n  static bool checkModuleIsAvailable(const LangOptions &LangOpts,\n                                     const TargetInfo &TargetInfo,\n                                     DiagnosticsEngine &Diags, Module *M);\n\n  // Module inclusion testing.\n  /// Find the module that owns the source or header file that\n  /// \\p Loc points to. If the location is in a file that was included\n  /// into a module, or is outside any module, returns nullptr.\n  Module *getModuleForLocation(SourceLocation Loc);\n\n  /// We want to produce a diagnostic at location IncLoc concerning an\n  /// unreachable effect at location MLoc (eg, where a desired entity was\n  /// declared or defined). Determine whether the right way to make MLoc\n  /// reachable is by #include, and if so, what header should be included.\n  ///\n  /// This is not necessarily fast, and might load unexpected module maps, so\n  /// should only be called by code that intends to produce an error.\n  ///\n  /// \\param IncLoc The location at which the missing effect was detected.\n  /// \\param MLoc A location within an unimported module at which the desired\n  ///        effect occurred.\n  /// \\return A file that can be #included to provide the desired effect. Null\n  ///         if no such file could be determined or if a #include is not\n  ///         appropriate (eg, if a module should be imported instead).\n  const FileEntry *getHeaderToIncludeForDiagnostics(SourceLocation IncLoc,\n                                                    SourceLocation MLoc);\n\n  bool isRecordingPreamble() const {\n    return PreambleConditionalStack.isRecording();\n  }\n\n  bool hasRecordedPreamble() const {\n    return PreambleConditionalStack.hasRecordedPreamble();\n  }\n\n  ArrayRef<PPConditionalInfo> getPreambleConditionalStack() const {\n      return PreambleConditionalStack.getStack();\n  }\n\n  void setRecordedPreambleConditionalStack(ArrayRef<PPConditionalInfo> s) {\n    PreambleConditionalStack.setStack(s);\n  }\n\n  void setReplayablePreambleConditionalStack(ArrayRef<PPConditionalInfo> s,\n                                             llvm::Optional<PreambleSkipInfo> SkipInfo) {\n    PreambleConditionalStack.startReplaying();\n    PreambleConditionalStack.setStack(s);\n    PreambleConditionalStack.SkipInfo = SkipInfo;\n  }\n\n  llvm::Optional<PreambleSkipInfo> getPreambleSkipInfo() const {\n    return PreambleConditionalStack.SkipInfo;\n  }\n\nprivate:\n  /// After processing predefined file, initialize the conditional stack from\n  /// the preamble.\n  void replayPreambleConditionalStack();\n\n  // Macro handling.\n  void HandleDefineDirective(Token &Tok, bool ImmediatelyAfterHeaderGuard);\n  void HandleUndefDirective();\n\n  // Conditional Inclusion.\n  void HandleIfdefDirective(Token &Result, const Token &HashToken,\n                            bool isIfndef, bool ReadAnyTokensBeforeDirective);\n  void HandleIfDirective(Token &IfToken, const Token &HashToken,\n                         bool ReadAnyTokensBeforeDirective);\n  void HandleEndifDirective(Token &EndifToken);\n  void HandleElseDirective(Token &Result, const Token &HashToken);\n  void HandleElifDirective(Token &ElifToken, const Token &HashToken);\n\n  // Pragmas.\n  void HandlePragmaDirective(PragmaIntroducer Introducer);\n\npublic:\n  void HandlePragmaOnce(Token &OnceTok);\n  void HandlePragmaMark();\n  void HandlePragmaPoison();\n  void HandlePragmaSystemHeader(Token &SysHeaderTok);\n  void HandlePragmaDependency(Token &DependencyTok);\n  void HandlePragmaPushMacro(Token &Tok);\n  void HandlePragmaPopMacro(Token &Tok);\n  void HandlePragmaIncludeAlias(Token &Tok);\n  void HandlePragmaModuleBuild(Token &Tok);\n  void HandlePragmaHdrstop(Token &Tok);\n  IdentifierInfo *ParsePragmaPushOrPopMacro(Token &Tok);\n\n  // Return true and store the first token only if any CommentHandler\n  // has inserted some tokens and getCommentRetentionState() is false.\n  bool HandleComment(Token &result, SourceRange Comment);\n\n  /// A macro is used, update information about macros that need unused\n  /// warnings.\n  void markMacroAsUsed(MacroInfo *MI);\n\nprivate:\n  Optional<unsigned>\n  getSkippedRangeForExcludedConditionalBlock(SourceLocation HashLoc);\n\n  /// Contains the currently active skipped range mappings for skipping excluded\n  /// conditional directives.\n  ExcludedPreprocessorDirectiveSkipMapping\n      *ExcludedConditionalDirectiveSkipMappings;\n};\n\n/// Abstract base class that describes a handler that will receive\n/// source ranges for each of the comments encountered in the source file.\nclass CommentHandler {\npublic:\n  virtual ~CommentHandler();\n\n  // The handler shall return true if it has pushed any tokens\n  // to be read using e.g. EnterToken or EnterTokenStream.\n  virtual bool HandleComment(Preprocessor &PP, SourceRange Comment) = 0;\n};\n\n/// Abstract base class that describes a handler that will receive\n/// source ranges for empty lines encountered in the source file.\nclass EmptylineHandler {\npublic:\n  virtual ~EmptylineHandler();\n\n  // The handler handles empty lines.\n  virtual void HandleEmptyline(SourceRange Range) = 0;\n};\n\n/// Registry of pragma handlers added by plugins\nusing PragmaHandlerRegistry = llvm::Registry<PragmaHandler>;\n\n} // namespace clang\n\n#endif // LLVM_CLANG_LEX_PREPROCESSOR_H\n"}, "85": {"id": 85, "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CIndex.cpp", "content": "//===- CIndex.cpp - Clang-C Source Indexing Library -----------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the main API hooks in the Clang-C Source Indexing\n// library.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"CIndexDiagnostic.h\"\n#include \"CIndexer.h\"\n#include \"CLog.h\"\n#include \"CXCursor.h\"\n#include \"CXSourceLocation.h\"\n#include \"CXString.h\"\n#include \"CXTranslationUnit.h\"\n#include \"CXType.h\"\n#include \"CursorVisitor.h\"\n#include \"clang-c/FatalErrorHandler.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/DeclObjCCommon.h\"\n#include \"clang/AST/Mangle.h\"\n#include \"clang/AST/OpenMPClause.h\"\n#include \"clang/AST/StmtVisitor.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/DiagnosticCategories.h\"\n#include \"clang/Basic/DiagnosticIDs.h\"\n#include \"clang/Basic/Stack.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Basic/Version.h\"\n#include \"clang/Frontend/ASTUnit.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Index/CommentToXML.h\"\n#include \"clang/Lex/HeaderSearch.h\"\n#include \"clang/Lex/Lexer.h\"\n#include \"clang/Lex/PreprocessingRecord.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/CrashRecoveryContext.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/ManagedStatic.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/Program.h\"\n#include \"llvm/Support/SaveAndRestore.h\"\n#include \"llvm/Support/Signals.h\"\n#include \"llvm/Support/TargetSelect.h\"\n#include \"llvm/Support/Threading.h\"\n#include \"llvm/Support/Timer.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <mutex>\n\n#if LLVM_ENABLE_THREADS != 0 && defined(__APPLE__)\n#define USE_DARWIN_THREADS\n#endif\n\n#ifdef USE_DARWIN_THREADS\n#include <pthread.h>\n#endif\n\nusing namespace clang;\nusing namespace clang::cxcursor;\nusing namespace clang::cxtu;\nusing namespace clang::cxindex;\n\nCXTranslationUnit cxtu::MakeCXTranslationUnit(CIndexer *CIdx,\n                                              std::unique_ptr<ASTUnit> AU) {\n  if (!AU)\n    return nullptr;\n  assert(CIdx);\n  CXTranslationUnit D = new CXTranslationUnitImpl();\n  D->CIdx = CIdx;\n  D->TheASTUnit = AU.release();\n  D->StringPool = new cxstring::CXStringPool();\n  D->Diagnostics = nullptr;\n  D->OverridenCursorsPool = createOverridenCXCursorsPool();\n  D->CommentToXML = nullptr;\n  D->ParsingOptions = 0;\n  D->Arguments = {};\n  return D;\n}\n\nbool cxtu::isASTReadError(ASTUnit *AU) {\n  for (ASTUnit::stored_diag_iterator D = AU->stored_diag_begin(),\n                                     DEnd = AU->stored_diag_end();\n       D != DEnd; ++D) {\n    if (D->getLevel() >= DiagnosticsEngine::Error &&\n        DiagnosticIDs::getCategoryNumberForDiag(D->getID()) ==\n            diag::DiagCat_AST_Deserialization_Issue)\n      return true;\n  }\n  return false;\n}\n\ncxtu::CXTUOwner::~CXTUOwner() {\n  if (TU)\n    clang_disposeTranslationUnit(TU);\n}\n\n/// Compare two source ranges to determine their relative position in\n/// the translation unit.\nstatic RangeComparisonResult RangeCompare(SourceManager &SM, SourceRange R1,\n                                          SourceRange R2) {\n  assert(R1.isValid() && \"First range is invalid?\");\n  assert(R2.isValid() && \"Second range is invalid?\");\n  if (R1.getEnd() != R2.getBegin() &&\n      SM.isBeforeInTranslationUnit(R1.getEnd(), R2.getBegin()))\n    return RangeBefore;\n  if (R2.getEnd() != R1.getBegin() &&\n      SM.isBeforeInTranslationUnit(R2.getEnd(), R1.getBegin()))\n    return RangeAfter;\n  return RangeOverlap;\n}\n\n/// Determine if a source location falls within, before, or after a\n///   a given source range.\nstatic RangeComparisonResult LocationCompare(SourceManager &SM,\n                                             SourceLocation L, SourceRange R) {\n  assert(R.isValid() && \"First range is invalid?\");\n  assert(L.isValid() && \"Second range is invalid?\");\n  if (L == R.getBegin() || L == R.getEnd())\n    return RangeOverlap;\n  if (SM.isBeforeInTranslationUnit(L, R.getBegin()))\n    return RangeBefore;\n  if (SM.isBeforeInTranslationUnit(R.getEnd(), L))\n    return RangeAfter;\n  return RangeOverlap;\n}\n\n/// Translate a Clang source range into a CIndex source range.\n///\n/// Clang internally represents ranges where the end location points to the\n/// start of the token at the end. However, for external clients it is more\n/// useful to have a CXSourceRange be a proper half-open interval. This routine\n/// does the appropriate translation.\nCXSourceRange cxloc::translateSourceRange(const SourceManager &SM,\n                                          const LangOptions &LangOpts,\n                                          const CharSourceRange &R) {\n  // We want the last character in this location, so we will adjust the\n  // location accordingly.\n  SourceLocation EndLoc = R.getEnd();\n  bool IsTokenRange = R.isTokenRange();\n  if (EndLoc.isValid() && EndLoc.isMacroID() &&\n      !SM.isMacroArgExpansion(EndLoc)) {\n    CharSourceRange Expansion = SM.getExpansionRange(EndLoc);\n    EndLoc = Expansion.getEnd();\n    IsTokenRange = Expansion.isTokenRange();\n  }\n  if (IsTokenRange && EndLoc.isValid()) {\n    unsigned Length =\n        Lexer::MeasureTokenLength(SM.getSpellingLoc(EndLoc), SM, LangOpts);\n    EndLoc = EndLoc.getLocWithOffset(Length);\n  }\n\n  CXSourceRange Result = {\n      {&SM, &LangOpts}, R.getBegin().getRawEncoding(), EndLoc.getRawEncoding()};\n  return Result;\n}\n\nCharSourceRange cxloc::translateCXRangeToCharRange(CXSourceRange R) {\n  return CharSourceRange::getCharRange(\n      SourceLocation::getFromRawEncoding(R.begin_int_data),\n      SourceLocation::getFromRawEncoding(R.end_int_data));\n}\n\n//===----------------------------------------------------------------------===//\n// Cursor visitor.\n//===----------------------------------------------------------------------===//\n\nstatic SourceRange getRawCursorExtent(CXCursor C);\nstatic SourceRange getFullCursorExtent(CXCursor C, SourceManager &SrcMgr);\n\nRangeComparisonResult CursorVisitor::CompareRegionOfInterest(SourceRange R) {\n  return RangeCompare(AU->getSourceManager(), R, RegionOfInterest);\n}\n\n/// Visit the given cursor and, if requested by the visitor,\n/// its children.\n///\n/// \\param Cursor the cursor to visit.\n///\n/// \\param CheckedRegionOfInterest if true, then the caller already checked\n/// that this cursor is within the region of interest.\n///\n/// \\returns true if the visitation should be aborted, false if it\n/// should continue.\nbool CursorVisitor::Visit(CXCursor Cursor, bool CheckedRegionOfInterest) {\n  if (clang_isInvalid(Cursor.kind))\n    return false;\n\n  if (clang_isDeclaration(Cursor.kind)) {\n    const Decl *D = getCursorDecl(Cursor);\n    if (!D) {\n      assert(0 && \"Invalid declaration cursor\");\n      return true; // abort.\n    }\n\n    // Ignore implicit declarations, unless it's an objc method because\n    // currently we should report implicit methods for properties when indexing.\n    if (D->isImplicit() && !isa<ObjCMethodDecl>(D))\n      return false;\n  }\n\n  // If we have a range of interest, and this cursor doesn't intersect with it,\n  // we're done.\n  if (RegionOfInterest.isValid() && !CheckedRegionOfInterest) {\n    SourceRange Range = getRawCursorExtent(Cursor);\n    if (Range.isInvalid() || CompareRegionOfInterest(Range))\n      return false;\n  }\n\n  switch (Visitor(Cursor, Parent, ClientData)) {\n  case CXChildVisit_Break:\n    return true;\n\n  case CXChildVisit_Continue:\n    return false;\n\n  case CXChildVisit_Recurse: {\n    bool ret = VisitChildren(Cursor);\n    if (PostChildrenVisitor)\n      if (PostChildrenVisitor(Cursor, ClientData))\n        return true;\n    return ret;\n  }\n  }\n\n  llvm_unreachable(\"Invalid CXChildVisitResult!\");\n}\n\nstatic bool visitPreprocessedEntitiesInRange(SourceRange R,\n                                             PreprocessingRecord &PPRec,\n                                             CursorVisitor &Visitor) {\n  SourceManager &SM = Visitor.getASTUnit()->getSourceManager();\n  FileID FID;\n\n  if (!Visitor.shouldVisitIncludedEntities()) {\n    // If the begin/end of the range lie in the same FileID, do the optimization\n    // where we skip preprocessed entities that do not come from the same\n    // FileID.\n    FID = SM.getFileID(SM.getFileLoc(R.getBegin()));\n    if (FID != SM.getFileID(SM.getFileLoc(R.getEnd())))\n      FID = FileID();\n  }\n\n  const auto &Entities = PPRec.getPreprocessedEntitiesInRange(R);\n  return Visitor.visitPreprocessedEntities(Entities.begin(), Entities.end(),\n                                           PPRec, FID);\n}\n\nbool CursorVisitor::visitFileRegion() {\n  if (RegionOfInterest.isInvalid())\n    return false;\n\n  ASTUnit *Unit = cxtu::getASTUnit(TU);\n  SourceManager &SM = Unit->getSourceManager();\n\n  std::pair<FileID, unsigned> Begin = SM.getDecomposedLoc(\n                                  SM.getFileLoc(RegionOfInterest.getBegin())),\n                              End = SM.getDecomposedLoc(\n                                  SM.getFileLoc(RegionOfInterest.getEnd()));\n\n  if (End.first != Begin.first) {\n    // If the end does not reside in the same file, try to recover by\n    // picking the end of the file of begin location.\n    End.first = Begin.first;\n    End.second = SM.getFileIDSize(Begin.first);\n  }\n\n  assert(Begin.first == End.first);\n  if (Begin.second > End.second)\n    return false;\n\n  FileID File = Begin.first;\n  unsigned Offset = Begin.second;\n  unsigned Length = End.second - Begin.second;\n\n  if (!VisitDeclsOnly && !VisitPreprocessorLast)\n    if (visitPreprocessedEntitiesInRegion())\n      return true; // visitation break.\n\n  if (visitDeclsFromFileRegion(File, Offset, Length))\n    return true; // visitation break.\n\n  if (!VisitDeclsOnly && VisitPreprocessorLast)\n    return visitPreprocessedEntitiesInRegion();\n\n  return false;\n}\n\nstatic bool isInLexicalContext(Decl *D, DeclContext *DC) {\n  if (!DC)\n    return false;\n\n  for (DeclContext *DeclDC = D->getLexicalDeclContext(); DeclDC;\n       DeclDC = DeclDC->getLexicalParent()) {\n    if (DeclDC == DC)\n      return true;\n  }\n  return false;\n}\n\nbool CursorVisitor::visitDeclsFromFileRegion(FileID File, unsigned Offset,\n                                             unsigned Length) {\n  ASTUnit *Unit = cxtu::getASTUnit(TU);\n  SourceManager &SM = Unit->getSourceManager();\n  SourceRange Range = RegionOfInterest;\n\n  SmallVector<Decl *, 16> Decls;\n  Unit->findFileRegionDecls(File, Offset, Length, Decls);\n\n  // If we didn't find any file level decls for the file, try looking at the\n  // file that it was included from.\n  while (Decls.empty() || Decls.front()->isTopLevelDeclInObjCContainer()) {\n    bool Invalid = false;\n    const SrcMgr::SLocEntry &SLEntry = SM.getSLocEntry(File, &Invalid);\n    if (Invalid)\n      return false;\n\n    SourceLocation Outer;\n    if (SLEntry.isFile())\n      Outer = SLEntry.getFile().getIncludeLoc();\n    else\n      Outer = SLEntry.getExpansion().getExpansionLocStart();\n    if (Outer.isInvalid())\n      return false;\n\n    std::tie(File, Offset) = SM.getDecomposedExpansionLoc(Outer);\n    Length = 0;\n    Unit->findFileRegionDecls(File, Offset, Length, Decls);\n  }\n\n  assert(!Decls.empty());\n\n  bool VisitedAtLeastOnce = false;\n  DeclContext *CurDC = nullptr;\n  SmallVectorImpl<Decl *>::iterator DIt = Decls.begin();\n  for (SmallVectorImpl<Decl *>::iterator DE = Decls.end(); DIt != DE; ++DIt) {\n    Decl *D = *DIt;\n    if (D->getSourceRange().isInvalid())\n      continue;\n\n    if (isInLexicalContext(D, CurDC))\n      continue;\n\n    CurDC = dyn_cast<DeclContext>(D);\n\n    if (TagDecl *TD = dyn_cast<TagDecl>(D))\n      if (!TD->isFreeStanding())\n        continue;\n\n    RangeComparisonResult CompRes =\n        RangeCompare(SM, D->getSourceRange(), Range);\n    if (CompRes == RangeBefore)\n      continue;\n    if (CompRes == RangeAfter)\n      break;\n\n    assert(CompRes == RangeOverlap);\n    VisitedAtLeastOnce = true;\n\n    if (isa<ObjCContainerDecl>(D)) {\n      FileDI_current = &DIt;\n      FileDE_current = DE;\n    } else {\n      FileDI_current = nullptr;\n    }\n\n    if (Visit(MakeCXCursor(D, TU, Range), /*CheckedRegionOfInterest=*/true))\n      return true; // visitation break.\n  }\n\n  if (VisitedAtLeastOnce)\n    return false;\n\n  // No Decls overlapped with the range. Move up the lexical context until there\n  // is a context that contains the range or we reach the translation unit\n  // level.\n  DeclContext *DC = DIt == Decls.begin()\n                        ? (*DIt)->getLexicalDeclContext()\n                        : (*(DIt - 1))->getLexicalDeclContext();\n\n  while (DC && !DC->isTranslationUnit()) {\n    Decl *D = cast<Decl>(DC);\n    SourceRange CurDeclRange = D->getSourceRange();\n    if (CurDeclRange.isInvalid())\n      break;\n\n    if (RangeCompare(SM, CurDeclRange, Range) == RangeOverlap) {\n      if (Visit(MakeCXCursor(D, TU, Range), /*CheckedRegionOfInterest=*/true))\n        return true; // visitation break.\n    }\n\n    DC = D->getLexicalDeclContext();\n  }\n\n  return false;\n}\n\nbool CursorVisitor::visitPreprocessedEntitiesInRegion() {\n  if (!AU->getPreprocessor().getPreprocessingRecord())\n    return false;\n\n  PreprocessingRecord &PPRec = *AU->getPreprocessor().getPreprocessingRecord();\n  SourceManager &SM = AU->getSourceManager();\n\n  if (RegionOfInterest.isValid()) {\n    SourceRange MappedRange = AU->mapRangeToPreamble(RegionOfInterest);\n    SourceLocation B = MappedRange.getBegin();\n    SourceLocation E = MappedRange.getEnd();\n\n    if (AU->isInPreambleFileID(B)) {\n      if (SM.isLoadedSourceLocation(E))\n        return visitPreprocessedEntitiesInRange(SourceRange(B, E), PPRec,\n                                                *this);\n\n      // Beginning of range lies in the preamble but it also extends beyond\n      // it into the main file. Split the range into 2 parts, one covering\n      // the preamble and another covering the main file. This allows subsequent\n      // calls to visitPreprocessedEntitiesInRange to accept a source range that\n      // lies in the same FileID, allowing it to skip preprocessed entities that\n      // do not come from the same FileID.\n      bool breaked = visitPreprocessedEntitiesInRange(\n          SourceRange(B, AU->getEndOfPreambleFileID()), PPRec, *this);\n      if (breaked)\n        return true;\n      return visitPreprocessedEntitiesInRange(\n          SourceRange(AU->getStartOfMainFileID(), E), PPRec, *this);\n    }\n\n    return visitPreprocessedEntitiesInRange(SourceRange(B, E), PPRec, *this);\n  }\n\n  bool OnlyLocalDecls = !AU->isMainFileAST() && AU->getOnlyLocalDecls();\n\n  if (OnlyLocalDecls)\n    return visitPreprocessedEntities(PPRec.local_begin(), PPRec.local_end(),\n                                     PPRec);\n\n  return visitPreprocessedEntities(PPRec.begin(), PPRec.end(), PPRec);\n}\n\ntemplate <typename InputIterator>\nbool CursorVisitor::visitPreprocessedEntities(InputIterator First,\n                                              InputIterator Last,\n                                              PreprocessingRecord &PPRec,\n                                              FileID FID) {\n  for (; First != Last; ++First) {\n    if (!FID.isInvalid() && !PPRec.isEntityInFileID(First, FID))\n      continue;\n\n    PreprocessedEntity *PPE = *First;\n    if (!PPE)\n      continue;\n\n    if (MacroExpansion *ME = dyn_cast<MacroExpansion>(PPE)) {\n      if (Visit(MakeMacroExpansionCursor(ME, TU)))\n        return true;\n\n      continue;\n    }\n\n    if (MacroDefinitionRecord *MD = dyn_cast<MacroDefinitionRecord>(PPE)) {\n      if (Visit(MakeMacroDefinitionCursor(MD, TU)))\n        return true;\n\n      continue;\n    }\n\n    if (InclusionDirective *ID = dyn_cast<InclusionDirective>(PPE)) {\n      if (Visit(MakeInclusionDirectiveCursor(ID, TU)))\n        return true;\n\n      continue;\n    }\n  }\n\n  return false;\n}\n\n/// Visit the children of the given cursor.\n///\n/// \\returns true if the visitation should be aborted, false if it\n/// should continue.\nbool CursorVisitor::VisitChildren(CXCursor Cursor) {\n  if (clang_isReference(Cursor.kind) &&\n      Cursor.kind != CXCursor_CXXBaseSpecifier) {\n    // By definition, references have no children.\n    return false;\n  }\n\n  // Set the Parent field to Cursor, then back to its old value once we're\n  // done.\n  SetParentRAII SetParent(Parent, StmtParent, Cursor);\n\n  if (clang_isDeclaration(Cursor.kind)) {\n    Decl *D = const_cast<Decl *>(getCursorDecl(Cursor));\n    if (!D)\n      return false;\n\n    return VisitAttributes(D) || Visit(D);\n  }\n\n  if (clang_isStatement(Cursor.kind)) {\n    if (const Stmt *S = getCursorStmt(Cursor))\n      return Visit(S);\n\n    return false;\n  }\n\n  if (clang_isExpression(Cursor.kind)) {\n    if (const Expr *E = getCursorExpr(Cursor))\n      return Visit(E);\n\n    return false;\n  }\n\n  if (clang_isTranslationUnit(Cursor.kind)) {\n    CXTranslationUnit TU = getCursorTU(Cursor);\n    ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n\n    int VisitOrder[2] = {VisitPreprocessorLast, !VisitPreprocessorLast};\n    for (unsigned I = 0; I != 2; ++I) {\n      if (VisitOrder[I]) {\n        if (!CXXUnit->isMainFileAST() && CXXUnit->getOnlyLocalDecls() &&\n            RegionOfInterest.isInvalid()) {\n          for (ASTUnit::top_level_iterator TL = CXXUnit->top_level_begin(),\n                                           TLEnd = CXXUnit->top_level_end();\n               TL != TLEnd; ++TL) {\n            const Optional<bool> V = handleDeclForVisitation(*TL);\n            if (!V.hasValue())\n              continue;\n            return V.getValue();\n          }\n        } else if (VisitDeclContext(\n                       CXXUnit->getASTContext().getTranslationUnitDecl()))\n          return true;\n        continue;\n      }\n\n      // Walk the preprocessing record.\n      if (CXXUnit->getPreprocessor().getPreprocessingRecord())\n        visitPreprocessedEntitiesInRegion();\n    }\n\n    return false;\n  }\n\n  if (Cursor.kind == CXCursor_CXXBaseSpecifier) {\n    if (const CXXBaseSpecifier *Base = getCursorCXXBaseSpecifier(Cursor)) {\n      if (TypeSourceInfo *BaseTSInfo = Base->getTypeSourceInfo()) {\n        return Visit(BaseTSInfo->getTypeLoc());\n      }\n    }\n  }\n\n  if (Cursor.kind == CXCursor_IBOutletCollectionAttr) {\n    const IBOutletCollectionAttr *A =\n        cast<IBOutletCollectionAttr>(cxcursor::getCursorAttr(Cursor));\n    if (const ObjCObjectType *ObjT = A->getInterface()->getAs<ObjCObjectType>())\n      return Visit(cxcursor::MakeCursorObjCClassRef(\n          ObjT->getInterface(),\n          A->getInterfaceLoc()->getTypeLoc().getBeginLoc(), TU));\n  }\n\n  // If pointing inside a macro definition, check if the token is an identifier\n  // that was ever defined as a macro. In such a case, create a \"pseudo\" macro\n  // expansion cursor for that token.\n  SourceLocation BeginLoc = RegionOfInterest.getBegin();\n  if (Cursor.kind == CXCursor_MacroDefinition &&\n      BeginLoc == RegionOfInterest.getEnd()) {\n    SourceLocation Loc = AU->mapLocationToPreamble(BeginLoc);\n    const MacroInfo *MI =\n        getMacroInfo(cxcursor::getCursorMacroDefinition(Cursor), TU);\n    if (MacroDefinitionRecord *MacroDef =\n            checkForMacroInMacroDefinition(MI, Loc, TU))\n      return Visit(cxcursor::MakeMacroExpansionCursor(MacroDef, BeginLoc, TU));\n  }\n\n  // Nothing to visit at the moment.\n  return false;\n}\n\nbool CursorVisitor::VisitBlockDecl(BlockDecl *B) {\n  if (TypeSourceInfo *TSInfo = B->getSignatureAsWritten())\n    if (Visit(TSInfo->getTypeLoc()))\n      return true;\n\n  if (Stmt *Body = B->getBody())\n    return Visit(MakeCXCursor(Body, StmtParent, TU, RegionOfInterest));\n\n  return false;\n}\n\nOptional<bool> CursorVisitor::shouldVisitCursor(CXCursor Cursor) {\n  if (RegionOfInterest.isValid()) {\n    SourceRange Range = getFullCursorExtent(Cursor, AU->getSourceManager());\n    if (Range.isInvalid())\n      return None;\n\n    switch (CompareRegionOfInterest(Range)) {\n    case RangeBefore:\n      // This declaration comes before the region of interest; skip it.\n      return None;\n\n    case RangeAfter:\n      // This declaration comes after the region of interest; we're done.\n      return false;\n\n    case RangeOverlap:\n      // This declaration overlaps the region of interest; visit it.\n      break;\n    }\n  }\n  return true;\n}\n\nbool CursorVisitor::VisitDeclContext(DeclContext *DC) {\n  DeclContext::decl_iterator I = DC->decls_begin(), E = DC->decls_end();\n\n  // FIXME: Eventually remove.  This part of a hack to support proper\n  // iteration over all Decls contained lexically within an ObjC container.\n  SaveAndRestore<DeclContext::decl_iterator *> DI_saved(DI_current, &I);\n  SaveAndRestore<DeclContext::decl_iterator> DE_saved(DE_current, E);\n\n  for (; I != E; ++I) {\n    Decl *D = *I;\n    if (D->getLexicalDeclContext() != DC)\n      continue;\n    // Filter out synthesized property accessor redeclarations.\n    if (isa<ObjCImplDecl>(DC))\n      if (auto *OMD = dyn_cast<ObjCMethodDecl>(D))\n        if (OMD->isSynthesizedAccessorStub())\n          continue;\n    const Optional<bool> V = handleDeclForVisitation(D);\n    if (!V.hasValue())\n      continue;\n    return V.getValue();\n  }\n  return false;\n}\n\nOptional<bool> CursorVisitor::handleDeclForVisitation(const Decl *D) {\n  CXCursor Cursor = MakeCXCursor(D, TU, RegionOfInterest);\n\n  // Ignore synthesized ivars here, otherwise if we have something like:\n  //   @synthesize prop = _prop;\n  // and '_prop' is not declared, we will encounter a '_prop' ivar before\n  // encountering the 'prop' synthesize declaration and we will think that\n  // we passed the region-of-interest.\n  if (auto *ivarD = dyn_cast<ObjCIvarDecl>(D)) {\n    if (ivarD->getSynthesize())\n      return None;\n  }\n\n  // FIXME: ObjCClassRef/ObjCProtocolRef for forward class/protocol\n  // declarations is a mismatch with the compiler semantics.\n  if (Cursor.kind == CXCursor_ObjCInterfaceDecl) {\n    auto *ID = cast<ObjCInterfaceDecl>(D);\n    if (!ID->isThisDeclarationADefinition())\n      Cursor = MakeCursorObjCClassRef(ID, ID->getLocation(), TU);\n\n  } else if (Cursor.kind == CXCursor_ObjCProtocolDecl) {\n    auto *PD = cast<ObjCProtocolDecl>(D);\n    if (!PD->isThisDeclarationADefinition())\n      Cursor = MakeCursorObjCProtocolRef(PD, PD->getLocation(), TU);\n  }\n\n  const Optional<bool> V = shouldVisitCursor(Cursor);\n  if (!V.hasValue())\n    return None;\n  if (!V.getValue())\n    return false;\n  if (Visit(Cursor, true))\n    return true;\n  return None;\n}\n\nbool CursorVisitor::VisitTranslationUnitDecl(TranslationUnitDecl *D) {\n  llvm_unreachable(\"Translation units are visited directly by Visit()\");\n}\n\nbool CursorVisitor::VisitTypeAliasTemplateDecl(TypeAliasTemplateDecl *D) {\n  if (VisitTemplateParameters(D->getTemplateParameters()))\n    return true;\n\n  return Visit(MakeCXCursor(D->getTemplatedDecl(), TU, RegionOfInterest));\n}\n\nbool CursorVisitor::VisitTypeAliasDecl(TypeAliasDecl *D) {\n  if (TypeSourceInfo *TSInfo = D->getTypeSourceInfo())\n    return Visit(TSInfo->getTypeLoc());\n\n  return false;\n}\n\nbool CursorVisitor::VisitTypedefDecl(TypedefDecl *D) {\n  if (TypeSourceInfo *TSInfo = D->getTypeSourceInfo())\n    return Visit(TSInfo->getTypeLoc());\n\n  return false;\n}\n\nbool CursorVisitor::VisitTagDecl(TagDecl *D) { return VisitDeclContext(D); }\n\nbool CursorVisitor::VisitClassTemplateSpecializationDecl(\n    ClassTemplateSpecializationDecl *D) {\n  bool ShouldVisitBody = false;\n  switch (D->getSpecializationKind()) {\n  case TSK_Undeclared:\n  case TSK_ImplicitInstantiation:\n    // Nothing to visit\n    return false;\n\n  case TSK_ExplicitInstantiationDeclaration:\n  case TSK_ExplicitInstantiationDefinition:\n    break;\n\n  case TSK_ExplicitSpecialization:\n    ShouldVisitBody = true;\n    break;\n  }\n\n  // Visit the template arguments used in the specialization.\n  if (TypeSourceInfo *SpecType = D->getTypeAsWritten()) {\n    TypeLoc TL = SpecType->getTypeLoc();\n    if (TemplateSpecializationTypeLoc TSTLoc =\n            TL.getAs<TemplateSpecializationTypeLoc>()) {\n      for (unsigned I = 0, N = TSTLoc.getNumArgs(); I != N; ++I)\n        if (VisitTemplateArgumentLoc(TSTLoc.getArgLoc(I)))\n          return true;\n    }\n  }\n\n  return ShouldVisitBody && VisitCXXRecordDecl(D);\n}\n\nbool CursorVisitor::VisitClassTemplatePartialSpecializationDecl(\n    ClassTemplatePartialSpecializationDecl *D) {\n  // FIXME: Visit the \"outer\" template parameter lists on the TagDecl\n  // before visiting these template parameters.\n  if (VisitTemplateParameters(D->getTemplateParameters()))\n    return true;\n\n  // Visit the partial specialization arguments.\n  const ASTTemplateArgumentListInfo *Info = D->getTemplateArgsAsWritten();\n  const TemplateArgumentLoc *TemplateArgs = Info->getTemplateArgs();\n  for (unsigned I = 0, N = Info->NumTemplateArgs; I != N; ++I)\n    if (VisitTemplateArgumentLoc(TemplateArgs[I]))\n      return true;\n\n  return VisitCXXRecordDecl(D);\n}\n\nbool CursorVisitor::VisitTemplateTypeParmDecl(TemplateTypeParmDecl *D) {\n  if (const auto *TC = D->getTypeConstraint())\n    if (Visit(MakeCXCursor(TC->getImmediatelyDeclaredConstraint(), StmtParent,\n                           TU, RegionOfInterest)))\n      return true;\n\n  // Visit the default argument.\n  if (D->hasDefaultArgument() && !D->defaultArgumentWasInherited())\n    if (TypeSourceInfo *DefArg = D->getDefaultArgumentInfo())\n      if (Visit(DefArg->getTypeLoc()))\n        return true;\n\n  return false;\n}\n\nbool CursorVisitor::VisitEnumConstantDecl(EnumConstantDecl *D) {\n  if (Expr *Init = D->getInitExpr())\n    return Visit(MakeCXCursor(Init, StmtParent, TU, RegionOfInterest));\n  return false;\n}\n\nbool CursorVisitor::VisitDeclaratorDecl(DeclaratorDecl *DD) {\n  unsigned NumParamList = DD->getNumTemplateParameterLists();\n  for (unsigned i = 0; i < NumParamList; i++) {\n    TemplateParameterList *Params = DD->getTemplateParameterList(i);\n    if (VisitTemplateParameters(Params))\n      return true;\n  }\n\n  if (TypeSourceInfo *TSInfo = DD->getTypeSourceInfo())\n    if (Visit(TSInfo->getTypeLoc()))\n      return true;\n\n  // Visit the nested-name-specifier, if present.\n  if (NestedNameSpecifierLoc QualifierLoc = DD->getQualifierLoc())\n    if (VisitNestedNameSpecifierLoc(QualifierLoc))\n      return true;\n\n  return false;\n}\n\nstatic bool HasTrailingReturnType(FunctionDecl *ND) {\n  const QualType Ty = ND->getType();\n  if (const FunctionType *AFT = Ty->getAs<FunctionType>()) {\n    if (const FunctionProtoType *FT = dyn_cast<FunctionProtoType>(AFT))\n      return FT->hasTrailingReturn();\n  }\n\n  return false;\n}\n\n/// Compare two base or member initializers based on their source order.\nstatic int CompareCXXCtorInitializers(CXXCtorInitializer *const *X,\n                                      CXXCtorInitializer *const *Y) {\n  return (*X)->getSourceOrder() - (*Y)->getSourceOrder();\n}\n\nbool CursorVisitor::VisitFunctionDecl(FunctionDecl *ND) {\n  unsigned NumParamList = ND->getNumTemplateParameterLists();\n  for (unsigned i = 0; i < NumParamList; i++) {\n    TemplateParameterList *Params = ND->getTemplateParameterList(i);\n    if (VisitTemplateParameters(Params))\n      return true;\n  }\n\n  if (TypeSourceInfo *TSInfo = ND->getTypeSourceInfo()) {\n    // Visit the function declaration's syntactic components in the order\n    // written. This requires a bit of work.\n    TypeLoc TL = TSInfo->getTypeLoc().IgnoreParens();\n    FunctionTypeLoc FTL = TL.getAs<FunctionTypeLoc>();\n    const bool HasTrailingRT = HasTrailingReturnType(ND);\n\n    // If we have a function declared directly (without the use of a typedef),\n    // visit just the return type. Otherwise, just visit the function's type\n    // now.\n    if ((FTL && !isa<CXXConversionDecl>(ND) && !HasTrailingRT &&\n         Visit(FTL.getReturnLoc())) ||\n        (!FTL && Visit(TL)))\n      return true;\n\n    // Visit the nested-name-specifier, if present.\n    if (NestedNameSpecifierLoc QualifierLoc = ND->getQualifierLoc())\n      if (VisitNestedNameSpecifierLoc(QualifierLoc))\n        return true;\n\n    // Visit the declaration name.\n    if (!isa<CXXDestructorDecl>(ND))\n      if (VisitDeclarationNameInfo(ND->getNameInfo()))\n        return true;\n\n    // FIXME: Visit explicitly-specified template arguments!\n\n    // Visit the function parameters, if we have a function type.\n    if (FTL && VisitFunctionTypeLoc(FTL, true))\n      return true;\n\n    // Visit the function's trailing return type.\n    if (FTL && HasTrailingRT && Visit(FTL.getReturnLoc()))\n      return true;\n\n    // FIXME: Attributes?\n  }\n\n  if (ND->doesThisDeclarationHaveABody() && !ND->isLateTemplateParsed()) {\n    if (CXXConstructorDecl *Constructor = dyn_cast<CXXConstructorDecl>(ND)) {\n      // Find the initializers that were written in the source.\n      SmallVector<CXXCtorInitializer *, 4> WrittenInits;\n      for (auto *I : Constructor->inits()) {\n        if (!I->isWritten())\n          continue;\n\n        WrittenInits.push_back(I);\n      }\n\n      // Sort the initializers in source order\n      llvm::array_pod_sort(WrittenInits.begin(), WrittenInits.end(),\n                           &CompareCXXCtorInitializers);\n\n      // Visit the initializers in source order\n      for (unsigned I = 0, N = WrittenInits.size(); I != N; ++I) {\n        CXXCtorInitializer *Init = WrittenInits[I];\n        if (Init->isAnyMemberInitializer()) {\n          if (Visit(MakeCursorMemberRef(Init->getAnyMember(),\n                                        Init->getMemberLocation(), TU)))\n            return true;\n        } else if (TypeSourceInfo *TInfo = Init->getTypeSourceInfo()) {\n          if (Visit(TInfo->getTypeLoc()))\n            return true;\n        }\n\n        // Visit the initializer value.\n        if (Expr *Initializer = Init->getInit())\n          if (Visit(MakeCXCursor(Initializer, ND, TU, RegionOfInterest)))\n            return true;\n      }\n    }\n\n    if (Visit(MakeCXCursor(ND->getBody(), StmtParent, TU, RegionOfInterest)))\n      return true;\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitFieldDecl(FieldDecl *D) {\n  if (VisitDeclaratorDecl(D))\n    return true;\n\n  if (Expr *BitWidth = D->getBitWidth())\n    return Visit(MakeCXCursor(BitWidth, StmtParent, TU, RegionOfInterest));\n\n  if (Expr *Init = D->getInClassInitializer())\n    return Visit(MakeCXCursor(Init, StmtParent, TU, RegionOfInterest));\n\n  return false;\n}\n\nbool CursorVisitor::VisitVarDecl(VarDecl *D) {\n  if (VisitDeclaratorDecl(D))\n    return true;\n\n  if (Expr *Init = D->getInit())\n    return Visit(MakeCXCursor(Init, StmtParent, TU, RegionOfInterest));\n\n  return false;\n}\n\nbool CursorVisitor::VisitNonTypeTemplateParmDecl(NonTypeTemplateParmDecl *D) {\n  if (VisitDeclaratorDecl(D))\n    return true;\n\n  if (D->hasDefaultArgument() && !D->defaultArgumentWasInherited())\n    if (Expr *DefArg = D->getDefaultArgument())\n      return Visit(MakeCXCursor(DefArg, StmtParent, TU, RegionOfInterest));\n\n  return false;\n}\n\nbool CursorVisitor::VisitFunctionTemplateDecl(FunctionTemplateDecl *D) {\n  // FIXME: Visit the \"outer\" template parameter lists on the FunctionDecl\n  // before visiting these template parameters.\n  if (VisitTemplateParameters(D->getTemplateParameters()))\n    return true;\n\n  auto *FD = D->getTemplatedDecl();\n  return VisitAttributes(FD) || VisitFunctionDecl(FD);\n}\n\nbool CursorVisitor::VisitClassTemplateDecl(ClassTemplateDecl *D) {\n  // FIXME: Visit the \"outer\" template parameter lists on the TagDecl\n  // before visiting these template parameters.\n  if (VisitTemplateParameters(D->getTemplateParameters()))\n    return true;\n\n  auto *CD = D->getTemplatedDecl();\n  return VisitAttributes(CD) || VisitCXXRecordDecl(CD);\n}\n\nbool CursorVisitor::VisitTemplateTemplateParmDecl(TemplateTemplateParmDecl *D) {\n  if (VisitTemplateParameters(D->getTemplateParameters()))\n    return true;\n\n  if (D->hasDefaultArgument() && !D->defaultArgumentWasInherited() &&\n      VisitTemplateArgumentLoc(D->getDefaultArgument()))\n    return true;\n\n  return false;\n}\n\nbool CursorVisitor::VisitObjCTypeParamDecl(ObjCTypeParamDecl *D) {\n  // Visit the bound, if it's explicit.\n  if (D->hasExplicitBound()) {\n    if (auto TInfo = D->getTypeSourceInfo()) {\n      if (Visit(TInfo->getTypeLoc()))\n        return true;\n    }\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitObjCMethodDecl(ObjCMethodDecl *ND) {\n  if (TypeSourceInfo *TSInfo = ND->getReturnTypeSourceInfo())\n    if (Visit(TSInfo->getTypeLoc()))\n      return true;\n\n  for (const auto *P : ND->parameters()) {\n    if (Visit(MakeCXCursor(P, TU, RegionOfInterest)))\n      return true;\n  }\n\n  return ND->isThisDeclarationADefinition() &&\n         Visit(MakeCXCursor(ND->getBody(), StmtParent, TU, RegionOfInterest));\n}\n\ntemplate <typename DeclIt>\nstatic void addRangedDeclsInContainer(DeclIt *DI_current, DeclIt DE_current,\n                                      SourceManager &SM, SourceLocation EndLoc,\n                                      SmallVectorImpl<Decl *> &Decls) {\n  DeclIt next = *DI_current;\n  while (++next != DE_current) {\n    Decl *D_next = *next;\n    if (!D_next)\n      break;\n    SourceLocation L = D_next->getBeginLoc();\n    if (!L.isValid())\n      break;\n    if (SM.isBeforeInTranslationUnit(L, EndLoc)) {\n      *DI_current = next;\n      Decls.push_back(D_next);\n      continue;\n    }\n    break;\n  }\n}\n\nbool CursorVisitor::VisitObjCContainerDecl(ObjCContainerDecl *D) {\n  // FIXME: Eventually convert back to just 'VisitDeclContext()'.  Essentially\n  // an @implementation can lexically contain Decls that are not properly\n  // nested in the AST.  When we identify such cases, we need to retrofit\n  // this nesting here.\n  if (!DI_current && !FileDI_current)\n    return VisitDeclContext(D);\n\n  // Scan the Decls that immediately come after the container\n  // in the current DeclContext.  If any fall within the\n  // container's lexical region, stash them into a vector\n  // for later processing.\n  SmallVector<Decl *, 24> DeclsInContainer;\n  SourceLocation EndLoc = D->getSourceRange().getEnd();\n  SourceManager &SM = AU->getSourceManager();\n  if (EndLoc.isValid()) {\n    if (DI_current) {\n      addRangedDeclsInContainer(DI_current, DE_current, SM, EndLoc,\n                                DeclsInContainer);\n    } else {\n      addRangedDeclsInContainer(FileDI_current, FileDE_current, SM, EndLoc,\n                                DeclsInContainer);\n    }\n  }\n\n  // The common case.\n  if (DeclsInContainer.empty())\n    return VisitDeclContext(D);\n\n  // Get all the Decls in the DeclContext, and sort them with the\n  // additional ones we've collected.  Then visit them.\n  for (auto *SubDecl : D->decls()) {\n    if (!SubDecl || SubDecl->getLexicalDeclContext() != D ||\n        SubDecl->getBeginLoc().isInvalid())\n      continue;\n    DeclsInContainer.push_back(SubDecl);\n  }\n\n  // Now sort the Decls so that they appear in lexical order.\n  llvm::sort(DeclsInContainer, [&SM](Decl *A, Decl *B) {\n    SourceLocation L_A = A->getBeginLoc();\n    SourceLocation L_B = B->getBeginLoc();\n    return L_A != L_B\n               ? SM.isBeforeInTranslationUnit(L_A, L_B)\n               : SM.isBeforeInTranslationUnit(A->getEndLoc(), B->getEndLoc());\n  });\n\n  // Now visit the decls.\n  for (SmallVectorImpl<Decl *>::iterator I = DeclsInContainer.begin(),\n                                         E = DeclsInContainer.end();\n       I != E; ++I) {\n    CXCursor Cursor = MakeCXCursor(*I, TU, RegionOfInterest);\n    const Optional<bool> &V = shouldVisitCursor(Cursor);\n    if (!V.hasValue())\n      continue;\n    if (!V.getValue())\n      return false;\n    if (Visit(Cursor, true))\n      return true;\n  }\n  return false;\n}\n\nbool CursorVisitor::VisitObjCCategoryDecl(ObjCCategoryDecl *ND) {\n  if (Visit(MakeCursorObjCClassRef(ND->getClassInterface(), ND->getLocation(),\n                                   TU)))\n    return true;\n\n  if (VisitObjCTypeParamList(ND->getTypeParamList()))\n    return true;\n\n  ObjCCategoryDecl::protocol_loc_iterator PL = ND->protocol_loc_begin();\n  for (ObjCCategoryDecl::protocol_iterator I = ND->protocol_begin(),\n                                           E = ND->protocol_end();\n       I != E; ++I, ++PL)\n    if (Visit(MakeCursorObjCProtocolRef(*I, *PL, TU)))\n      return true;\n\n  return VisitObjCContainerDecl(ND);\n}\n\nbool CursorVisitor::VisitObjCProtocolDecl(ObjCProtocolDecl *PID) {\n  if (!PID->isThisDeclarationADefinition())\n    return Visit(MakeCursorObjCProtocolRef(PID, PID->getLocation(), TU));\n\n  ObjCProtocolDecl::protocol_loc_iterator PL = PID->protocol_loc_begin();\n  for (ObjCProtocolDecl::protocol_iterator I = PID->protocol_begin(),\n                                           E = PID->protocol_end();\n       I != E; ++I, ++PL)\n    if (Visit(MakeCursorObjCProtocolRef(*I, *PL, TU)))\n      return true;\n\n  return VisitObjCContainerDecl(PID);\n}\n\nbool CursorVisitor::VisitObjCPropertyDecl(ObjCPropertyDecl *PD) {\n  if (PD->getTypeSourceInfo() && Visit(PD->getTypeSourceInfo()->getTypeLoc()))\n    return true;\n\n  // FIXME: This implements a workaround with @property declarations also being\n  // installed in the DeclContext for the @interface.  Eventually this code\n  // should be removed.\n  ObjCCategoryDecl *CDecl = dyn_cast<ObjCCategoryDecl>(PD->getDeclContext());\n  if (!CDecl || !CDecl->IsClassExtension())\n    return false;\n\n  ObjCInterfaceDecl *ID = CDecl->getClassInterface();\n  if (!ID)\n    return false;\n\n  IdentifierInfo *PropertyId = PD->getIdentifier();\n  ObjCPropertyDecl *prevDecl = ObjCPropertyDecl::findPropertyDecl(\n      cast<DeclContext>(ID), PropertyId, PD->getQueryKind());\n\n  if (!prevDecl)\n    return false;\n\n  // Visit synthesized methods since they will be skipped when visiting\n  // the @interface.\n  if (ObjCMethodDecl *MD = prevDecl->getGetterMethodDecl())\n    if (MD->isPropertyAccessor() && MD->getLexicalDeclContext() == CDecl)\n      if (Visit(MakeCXCursor(MD, TU, RegionOfInterest)))\n        return true;\n\n  if (ObjCMethodDecl *MD = prevDecl->getSetterMethodDecl())\n    if (MD->isPropertyAccessor() && MD->getLexicalDeclContext() == CDecl)\n      if (Visit(MakeCXCursor(MD, TU, RegionOfInterest)))\n        return true;\n\n  return false;\n}\n\nbool CursorVisitor::VisitObjCTypeParamList(ObjCTypeParamList *typeParamList) {\n  if (!typeParamList)\n    return false;\n\n  for (auto *typeParam : *typeParamList) {\n    // Visit the type parameter.\n    if (Visit(MakeCXCursor(typeParam, TU, RegionOfInterest)))\n      return true;\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitObjCInterfaceDecl(ObjCInterfaceDecl *D) {\n  if (!D->isThisDeclarationADefinition()) {\n    // Forward declaration is treated like a reference.\n    return Visit(MakeCursorObjCClassRef(D, D->getLocation(), TU));\n  }\n\n  // Objective-C type parameters.\n  if (VisitObjCTypeParamList(D->getTypeParamListAsWritten()))\n    return true;\n\n  // Issue callbacks for super class.\n  if (D->getSuperClass() && Visit(MakeCursorObjCSuperClassRef(\n                                D->getSuperClass(), D->getSuperClassLoc(), TU)))\n    return true;\n\n  if (TypeSourceInfo *SuperClassTInfo = D->getSuperClassTInfo())\n    if (Visit(SuperClassTInfo->getTypeLoc()))\n      return true;\n\n  ObjCInterfaceDecl::protocol_loc_iterator PL = D->protocol_loc_begin();\n  for (ObjCInterfaceDecl::protocol_iterator I = D->protocol_begin(),\n                                            E = D->protocol_end();\n       I != E; ++I, ++PL)\n    if (Visit(MakeCursorObjCProtocolRef(*I, *PL, TU)))\n      return true;\n\n  return VisitObjCContainerDecl(D);\n}\n\nbool CursorVisitor::VisitObjCImplDecl(ObjCImplDecl *D) {\n  return VisitObjCContainerDecl(D);\n}\n\nbool CursorVisitor::VisitObjCCategoryImplDecl(ObjCCategoryImplDecl *D) {\n  // 'ID' could be null when dealing with invalid code.\n  if (ObjCInterfaceDecl *ID = D->getClassInterface())\n    if (Visit(MakeCursorObjCClassRef(ID, D->getLocation(), TU)))\n      return true;\n\n  return VisitObjCImplDecl(D);\n}\n\nbool CursorVisitor::VisitObjCImplementationDecl(ObjCImplementationDecl *D) {\n#if 0\n  // Issue callbacks for super class.\n  // FIXME: No source location information!\n  if (D->getSuperClass() &&\n      Visit(MakeCursorObjCSuperClassRef(D->getSuperClass(),\n                                        D->getSuperClassLoc(),\n                                        TU)))\n    return true;\n#endif\n\n  return VisitObjCImplDecl(D);\n}\n\nbool CursorVisitor::VisitObjCPropertyImplDecl(ObjCPropertyImplDecl *PD) {\n  if (ObjCIvarDecl *Ivar = PD->getPropertyIvarDecl())\n    if (PD->isIvarNameSpecified())\n      return Visit(MakeCursorMemberRef(Ivar, PD->getPropertyIvarDeclLoc(), TU));\n\n  return false;\n}\n\nbool CursorVisitor::VisitNamespaceDecl(NamespaceDecl *D) {\n  return VisitDeclContext(D);\n}\n\nbool CursorVisitor::VisitNamespaceAliasDecl(NamespaceAliasDecl *D) {\n  // Visit nested-name-specifier.\n  if (NestedNameSpecifierLoc QualifierLoc = D->getQualifierLoc())\n    if (VisitNestedNameSpecifierLoc(QualifierLoc))\n      return true;\n\n  return Visit(MakeCursorNamespaceRef(D->getAliasedNamespace(),\n                                      D->getTargetNameLoc(), TU));\n}\n\nbool CursorVisitor::VisitUsingDecl(UsingDecl *D) {\n  // Visit nested-name-specifier.\n  if (NestedNameSpecifierLoc QualifierLoc = D->getQualifierLoc()) {\n    if (VisitNestedNameSpecifierLoc(QualifierLoc))\n      return true;\n  }\n\n  if (Visit(MakeCursorOverloadedDeclRef(D, D->getLocation(), TU)))\n    return true;\n\n  return VisitDeclarationNameInfo(D->getNameInfo());\n}\n\nbool CursorVisitor::VisitUsingDirectiveDecl(UsingDirectiveDecl *D) {\n  // Visit nested-name-specifier.\n  if (NestedNameSpecifierLoc QualifierLoc = D->getQualifierLoc())\n    if (VisitNestedNameSpecifierLoc(QualifierLoc))\n      return true;\n\n  return Visit(MakeCursorNamespaceRef(D->getNominatedNamespaceAsWritten(),\n                                      D->getIdentLocation(), TU));\n}\n\nbool CursorVisitor::VisitUnresolvedUsingValueDecl(UnresolvedUsingValueDecl *D) {\n  // Visit nested-name-specifier.\n  if (NestedNameSpecifierLoc QualifierLoc = D->getQualifierLoc()) {\n    if (VisitNestedNameSpecifierLoc(QualifierLoc))\n      return true;\n  }\n\n  return VisitDeclarationNameInfo(D->getNameInfo());\n}\n\nbool CursorVisitor::VisitUnresolvedUsingTypenameDecl(\n    UnresolvedUsingTypenameDecl *D) {\n  // Visit nested-name-specifier.\n  if (NestedNameSpecifierLoc QualifierLoc = D->getQualifierLoc())\n    if (VisitNestedNameSpecifierLoc(QualifierLoc))\n      return true;\n\n  return false;\n}\n\nbool CursorVisitor::VisitStaticAssertDecl(StaticAssertDecl *D) {\n  if (Visit(MakeCXCursor(D->getAssertExpr(), StmtParent, TU, RegionOfInterest)))\n    return true;\n  if (StringLiteral *Message = D->getMessage())\n    if (Visit(MakeCXCursor(Message, StmtParent, TU, RegionOfInterest)))\n      return true;\n  return false;\n}\n\nbool CursorVisitor::VisitFriendDecl(FriendDecl *D) {\n  if (NamedDecl *FriendD = D->getFriendDecl()) {\n    if (Visit(MakeCXCursor(FriendD, TU, RegionOfInterest)))\n      return true;\n  } else if (TypeSourceInfo *TI = D->getFriendType()) {\n    if (Visit(TI->getTypeLoc()))\n      return true;\n  }\n  return false;\n}\n\nbool CursorVisitor::VisitDecompositionDecl(DecompositionDecl *D) {\n  for (auto *B : D->bindings()) {\n    if (Visit(MakeCXCursor(B, TU, RegionOfInterest)))\n      return true;\n  }\n  return VisitVarDecl(D);\n}\n\nbool CursorVisitor::VisitDeclarationNameInfo(DeclarationNameInfo Name) {\n  switch (Name.getName().getNameKind()) {\n  case clang::DeclarationName::Identifier:\n  case clang::DeclarationName::CXXLiteralOperatorName:\n  case clang::DeclarationName::CXXDeductionGuideName:\n  case clang::DeclarationName::CXXOperatorName:\n  case clang::DeclarationName::CXXUsingDirective:\n    return false;\n\n  case clang::DeclarationName::CXXConstructorName:\n  case clang::DeclarationName::CXXDestructorName:\n  case clang::DeclarationName::CXXConversionFunctionName:\n    if (TypeSourceInfo *TSInfo = Name.getNamedTypeInfo())\n      return Visit(TSInfo->getTypeLoc());\n    return false;\n\n  case clang::DeclarationName::ObjCZeroArgSelector:\n  case clang::DeclarationName::ObjCOneArgSelector:\n  case clang::DeclarationName::ObjCMultiArgSelector:\n    // FIXME: Per-identifier location info?\n    return false;\n  }\n\n  llvm_unreachable(\"Invalid DeclarationName::Kind!\");\n}\n\nbool CursorVisitor::VisitNestedNameSpecifier(NestedNameSpecifier *NNS,\n                                             SourceRange Range) {\n  // FIXME: This whole routine is a hack to work around the lack of proper\n  // source information in nested-name-specifiers (PR5791). Since we do have\n  // a beginning source location, we can visit the first component of the\n  // nested-name-specifier, if it's a single-token component.\n  if (!NNS)\n    return false;\n\n  // Get the first component in the nested-name-specifier.\n  while (NestedNameSpecifier *Prefix = NNS->getPrefix())\n    NNS = Prefix;\n\n  switch (NNS->getKind()) {\n  case NestedNameSpecifier::Namespace:\n    return Visit(\n        MakeCursorNamespaceRef(NNS->getAsNamespace(), Range.getBegin(), TU));\n\n  case NestedNameSpecifier::NamespaceAlias:\n    return Visit(MakeCursorNamespaceRef(NNS->getAsNamespaceAlias(),\n                                        Range.getBegin(), TU));\n\n  case NestedNameSpecifier::TypeSpec: {\n    // If the type has a form where we know that the beginning of the source\n    // range matches up with a reference cursor. Visit the appropriate reference\n    // cursor.\n    const Type *T = NNS->getAsType();\n    if (const TypedefType *Typedef = dyn_cast<TypedefType>(T))\n      return Visit(MakeCursorTypeRef(Typedef->getDecl(), Range.getBegin(), TU));\n    if (const TagType *Tag = dyn_cast<TagType>(T))\n      return Visit(MakeCursorTypeRef(Tag->getDecl(), Range.getBegin(), TU));\n    if (const TemplateSpecializationType *TST =\n            dyn_cast<TemplateSpecializationType>(T))\n      return VisitTemplateName(TST->getTemplateName(), Range.getBegin());\n    break;\n  }\n\n  case NestedNameSpecifier::TypeSpecWithTemplate:\n  case NestedNameSpecifier::Global:\n  case NestedNameSpecifier::Identifier:\n  case NestedNameSpecifier::Super:\n    break;\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitNestedNameSpecifierLoc(\n    NestedNameSpecifierLoc Qualifier) {\n  SmallVector<NestedNameSpecifierLoc, 4> Qualifiers;\n  for (; Qualifier; Qualifier = Qualifier.getPrefix())\n    Qualifiers.push_back(Qualifier);\n\n  while (!Qualifiers.empty()) {\n    NestedNameSpecifierLoc Q = Qualifiers.pop_back_val();\n    NestedNameSpecifier *NNS = Q.getNestedNameSpecifier();\n    switch (NNS->getKind()) {\n    case NestedNameSpecifier::Namespace:\n      if (Visit(MakeCursorNamespaceRef(NNS->getAsNamespace(),\n                                       Q.getLocalBeginLoc(), TU)))\n        return true;\n\n      break;\n\n    case NestedNameSpecifier::NamespaceAlias:\n      if (Visit(MakeCursorNamespaceRef(NNS->getAsNamespaceAlias(),\n                                       Q.getLocalBeginLoc(), TU)))\n        return true;\n\n      break;\n\n    case NestedNameSpecifier::TypeSpec:\n    case NestedNameSpecifier::TypeSpecWithTemplate:\n      if (Visit(Q.getTypeLoc()))\n        return true;\n\n      break;\n\n    case NestedNameSpecifier::Global:\n    case NestedNameSpecifier::Identifier:\n    case NestedNameSpecifier::Super:\n      break;\n    }\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitTemplateParameters(\n    const TemplateParameterList *Params) {\n  if (!Params)\n    return false;\n\n  for (TemplateParameterList::const_iterator P = Params->begin(),\n                                             PEnd = Params->end();\n       P != PEnd; ++P) {\n    if (Visit(MakeCXCursor(*P, TU, RegionOfInterest)))\n      return true;\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitTemplateName(TemplateName Name, SourceLocation Loc) {\n  switch (Name.getKind()) {\n  case TemplateName::Template:\n    return Visit(MakeCursorTemplateRef(Name.getAsTemplateDecl(), Loc, TU));\n\n  case TemplateName::OverloadedTemplate:\n    // Visit the overloaded template set.\n    if (Visit(MakeCursorOverloadedDeclRef(Name, Loc, TU)))\n      return true;\n\n    return false;\n\n  case TemplateName::AssumedTemplate:\n    // FIXME: Visit DeclarationName?\n    return false;\n\n  case TemplateName::DependentTemplate:\n    // FIXME: Visit nested-name-specifier.\n    return false;\n\n  case TemplateName::QualifiedTemplate:\n    // FIXME: Visit nested-name-specifier.\n    return Visit(MakeCursorTemplateRef(\n        Name.getAsQualifiedTemplateName()->getDecl(), Loc, TU));\n\n  case TemplateName::SubstTemplateTemplateParm:\n    return Visit(MakeCursorTemplateRef(\n        Name.getAsSubstTemplateTemplateParm()->getParameter(), Loc, TU));\n\n  case TemplateName::SubstTemplateTemplateParmPack:\n    return Visit(MakeCursorTemplateRef(\n        Name.getAsSubstTemplateTemplateParmPack()->getParameterPack(), Loc,\n        TU));\n  }\n\n  llvm_unreachable(\"Invalid TemplateName::Kind!\");\n}\n\nbool CursorVisitor::VisitTemplateArgumentLoc(const TemplateArgumentLoc &TAL) {\n  switch (TAL.getArgument().getKind()) {\n  case TemplateArgument::Null:\n  case TemplateArgument::Integral:\n  case TemplateArgument::Pack:\n    return false;\n\n  case TemplateArgument::Type:\n    if (TypeSourceInfo *TSInfo = TAL.getTypeSourceInfo())\n      return Visit(TSInfo->getTypeLoc());\n    return false;\n\n  case TemplateArgument::Declaration:\n    if (Expr *E = TAL.getSourceDeclExpression())\n      return Visit(MakeCXCursor(E, StmtParent, TU, RegionOfInterest));\n    return false;\n\n  case TemplateArgument::NullPtr:\n    if (Expr *E = TAL.getSourceNullPtrExpression())\n      return Visit(MakeCXCursor(E, StmtParent, TU, RegionOfInterest));\n    return false;\n\n  case TemplateArgument::Expression:\n    if (Expr *E = TAL.getSourceExpression())\n      return Visit(MakeCXCursor(E, StmtParent, TU, RegionOfInterest));\n    return false;\n\n  case TemplateArgument::Template:\n  case TemplateArgument::TemplateExpansion:\n    if (VisitNestedNameSpecifierLoc(TAL.getTemplateQualifierLoc()))\n      return true;\n\n    return VisitTemplateName(TAL.getArgument().getAsTemplateOrTemplatePattern(),\n                             TAL.getTemplateNameLoc());\n  }\n\n  llvm_unreachable(\"Invalid TemplateArgument::Kind!\");\n}\n\nbool CursorVisitor::VisitLinkageSpecDecl(LinkageSpecDecl *D) {\n  return VisitDeclContext(D);\n}\n\nbool CursorVisitor::VisitQualifiedTypeLoc(QualifiedTypeLoc TL) {\n  return Visit(TL.getUnqualifiedLoc());\n}\n\nbool CursorVisitor::VisitBuiltinTypeLoc(BuiltinTypeLoc TL) {\n  ASTContext &Context = AU->getASTContext();\n\n  // Some builtin types (such as Objective-C's \"id\", \"sel\", and\n  // \"Class\") have associated declarations. Create cursors for those.\n  QualType VisitType;\n  switch (TL.getTypePtr()->getKind()) {\n\n  case BuiltinType::Void:\n  case BuiltinType::NullPtr:\n  case BuiltinType::Dependent:\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix)                   \\\n  case BuiltinType::Id:\n#include \"clang/Basic/OpenCLImageTypes.def\"\n#define EXT_OPAQUE_TYPE(ExtTYpe, Id, Ext) case BuiltinType::Id:\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n  case BuiltinType::OCLSampler:\n  case BuiltinType::OCLEvent:\n  case BuiltinType::OCLClkEvent:\n  case BuiltinType::OCLQueue:\n  case BuiltinType::OCLReserveID:\n#define SVE_TYPE(Name, Id, SingletonId) case BuiltinType::Id:\n#include \"clang/Basic/AArch64SVEACLETypes.def\"\n#define PPC_VECTOR_TYPE(Name, Id, Size) case BuiltinType::Id:\n#include \"clang/Basic/PPCTypes.def\"\n#define RVV_TYPE(Name, Id, SingletonId) case BuiltinType::Id:\n#include \"clang/Basic/RISCVVTypes.def\"\n#define BUILTIN_TYPE(Id, SingletonId)\n#define SIGNED_TYPE(Id, SingletonId) case BuiltinType::Id:\n#define UNSIGNED_TYPE(Id, SingletonId) case BuiltinType::Id:\n#define FLOATING_TYPE(Id, SingletonId) case BuiltinType::Id:\n#define PLACEHOLDER_TYPE(Id, SingletonId) case BuiltinType::Id:\n#include \"clang/AST/BuiltinTypes.def\"\n    break;\n\n  case BuiltinType::ObjCId:\n    VisitType = Context.getObjCIdType();\n    break;\n\n  case BuiltinType::ObjCClass:\n    VisitType = Context.getObjCClassType();\n    break;\n\n  case BuiltinType::ObjCSel:\n    VisitType = Context.getObjCSelType();\n    break;\n  }\n\n  if (!VisitType.isNull()) {\n    if (const TypedefType *Typedef = VisitType->getAs<TypedefType>())\n      return Visit(\n          MakeCursorTypeRef(Typedef->getDecl(), TL.getBuiltinLoc(), TU));\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitTypedefTypeLoc(TypedefTypeLoc TL) {\n  return Visit(MakeCursorTypeRef(TL.getTypedefNameDecl(), TL.getNameLoc(), TU));\n}\n\nbool CursorVisitor::VisitUnresolvedUsingTypeLoc(UnresolvedUsingTypeLoc TL) {\n  return Visit(MakeCursorTypeRef(TL.getDecl(), TL.getNameLoc(), TU));\n}\n\nbool CursorVisitor::VisitTagTypeLoc(TagTypeLoc TL) {\n  if (TL.isDefinition())\n    return Visit(MakeCXCursor(TL.getDecl(), TU, RegionOfInterest));\n\n  return Visit(MakeCursorTypeRef(TL.getDecl(), TL.getNameLoc(), TU));\n}\n\nbool CursorVisitor::VisitTemplateTypeParmTypeLoc(TemplateTypeParmTypeLoc TL) {\n  return Visit(MakeCursorTypeRef(TL.getDecl(), TL.getNameLoc(), TU));\n}\n\nbool CursorVisitor::VisitObjCInterfaceTypeLoc(ObjCInterfaceTypeLoc TL) {\n  return Visit(MakeCursorObjCClassRef(TL.getIFaceDecl(), TL.getNameLoc(), TU));\n}\n\nbool CursorVisitor::VisitObjCTypeParamTypeLoc(ObjCTypeParamTypeLoc TL) {\n  if (Visit(MakeCursorTypeRef(TL.getDecl(), TL.getBeginLoc(), TU)))\n    return true;\n  for (unsigned I = 0, N = TL.getNumProtocols(); I != N; ++I) {\n    if (Visit(MakeCursorObjCProtocolRef(TL.getProtocol(I), TL.getProtocolLoc(I),\n                                        TU)))\n      return true;\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitObjCObjectTypeLoc(ObjCObjectTypeLoc TL) {\n  if (TL.hasBaseTypeAsWritten() && Visit(TL.getBaseLoc()))\n    return true;\n\n  for (unsigned I = 0, N = TL.getNumTypeArgs(); I != N; ++I) {\n    if (Visit(TL.getTypeArgTInfo(I)->getTypeLoc()))\n      return true;\n  }\n\n  for (unsigned I = 0, N = TL.getNumProtocols(); I != N; ++I) {\n    if (Visit(MakeCursorObjCProtocolRef(TL.getProtocol(I), TL.getProtocolLoc(I),\n                                        TU)))\n      return true;\n  }\n\n  return false;\n}\n\nbool CursorVisitor::VisitObjCObjectPointerTypeLoc(ObjCObjectPointerTypeLoc TL) {\n  return Visit(TL.getPointeeLoc());\n}\n\nbool CursorVisitor::VisitParenTypeLoc(ParenTypeLoc TL) {\n  return Visit(TL.getInnerLoc());\n}\n\nbool CursorVisitor::VisitMacroQualifiedTypeLoc(MacroQualifiedTypeLoc TL) {\n  return Visit(TL.getInnerLoc());\n}\n\nbool CursorVisitor::VisitPointerTypeLoc(PointerTypeLoc TL) {\n  return Visit(TL.getPointeeLoc());\n}\n\nbool CursorVisitor::VisitBlockPointerTypeLoc(BlockPointerTypeLoc TL) {\n  return Visit(TL.getPointeeLoc());\n}\n\nbool CursorVisitor::VisitMemberPointerTypeLoc(MemberPointerTypeLoc TL) {\n  return Visit(TL.getPointeeLoc());\n}\n\nbool CursorVisitor::VisitLValueReferenceTypeLoc(LValueReferenceTypeLoc TL) {\n  return Visit(TL.getPointeeLoc());\n}\n\nbool CursorVisitor::VisitRValueReferenceTypeLoc(RValueReferenceTypeLoc TL) {\n  return Visit(TL.getPointeeLoc());\n}\n\nbool CursorVisitor::VisitAttributedTypeLoc(AttributedTypeLoc TL) {\n  return Visit(TL.getModifiedLoc());\n}\n\nbool CursorVisitor::VisitFunctionTypeLoc(FunctionTypeLoc TL,\n                                         bool SkipResultType) {\n  if (!SkipResultType && Visit(TL.getReturnLoc()))\n    return true;\n\n  for (unsigned I = 0, N = TL.getNumParams(); I != N; ++I)\n    if (Decl *D = TL.getParam(I))\n      if (Visit(MakeCXCursor(D, TU, RegionOfInterest)))\n        return true;\n\n  return false;\n}\n\nbool CursorVisitor::VisitArrayTypeLoc(ArrayTypeLoc TL) {\n  if (Visit(TL.getElementLoc()))\n    return true;\n\n  if (Expr *Size = TL.getSizeExpr())\n    return Visit(MakeCXCursor(Size, StmtParent, TU, RegionOfInterest));\n\n  return false;\n}\n\nbool CursorVisitor::VisitDecayedTypeLoc(DecayedTypeLoc TL) {\n  return Visit(TL.getOriginalLoc());\n}\n\nbool CursorVisitor::VisitAdjustedTypeLoc(AdjustedTypeLoc TL) {\n  return Visit(TL.getOriginalLoc());\n}\n\nbool CursorVisitor::VisitDeducedTemplateSpecializationTypeLoc(\n    DeducedTemplateSpecializationTypeLoc TL) {\n  if (VisitTemplateName(TL.getTypePtr()->getTemplateName(),\n                        TL.getTemplateNameLoc()))\n    return true;\n\n  return false;\n}\n\nbool CursorVisitor::VisitTemplateSpecializationTypeLoc(\n    TemplateSpecializationTypeLoc TL) {\n  // Visit the template name.\n  if (VisitTemplateName(TL.getTypePtr()->getTemplateName(),\n                        TL.getTemplateNameLoc()))\n    return true;\n\n  // Visit the template arguments.\n  for (unsigned I = 0, N = TL.getNumArgs(); I != N; ++I)\n    if (VisitTemplateArgumentLoc(TL.getArgLoc(I)))\n      return true;\n\n  return false;\n}\n\nbool CursorVisitor::VisitTypeOfExprTypeLoc(TypeOfExprTypeLoc TL) {\n  return Visit(MakeCXCursor(TL.getUnderlyingExpr(), StmtParent, TU));\n}\n\nbool CursorVisitor::VisitTypeOfTypeLoc(TypeOfTypeLoc TL) {\n  if (TypeSourceInfo *TSInfo = TL.getUnderlyingTInfo())\n    return Visit(TSInfo->getTypeLoc());\n\n  return false;\n}\n\nbool CursorVisitor::VisitUnaryTransformTypeLoc(UnaryTransformTypeLoc TL) {\n  if (TypeSourceInfo *TSInfo = TL.getUnderlyingTInfo())\n    return Visit(TSInfo->getTypeLoc());\n\n  return false;\n}\n\nbool CursorVisitor::VisitDependentNameTypeLoc(DependentNameTypeLoc TL) {\n  return VisitNestedNameSpecifierLoc(TL.getQualifierLoc());\n}\n\nbool CursorVisitor::VisitDependentTemplateSpecializationTypeLoc(\n    DependentTemplateSpecializationTypeLoc TL) {\n  // Visit the nested-name-specifier, if there is one.\n  if (TL.getQualifierLoc() && VisitNestedNameSpecifierLoc(TL.getQualifierLoc()))\n    return true;\n\n  // Visit the template arguments.\n  for (unsigned I = 0, N = TL.getNumArgs(); I != N; ++I)\n    if (VisitTemplateArgumentLoc(TL.getArgLoc(I)))\n      return true;\n\n  return false;\n}\n\nbool CursorVisitor::VisitElaboratedTypeLoc(ElaboratedTypeLoc TL) {\n  if (VisitNestedNameSpecifierLoc(TL.getQualifierLoc()))\n    return true;\n\n  return Visit(TL.getNamedTypeLoc());\n}\n\nbool CursorVisitor::VisitPackExpansionTypeLoc(PackExpansionTypeLoc TL) {\n  return Visit(TL.getPatternLoc());\n}\n\nbool CursorVisitor::VisitDecltypeTypeLoc(DecltypeTypeLoc TL) {\n  if (Expr *E = TL.getUnderlyingExpr())\n    return Visit(MakeCXCursor(E, StmtParent, TU));\n\n  return false;\n}\n\nbool CursorVisitor::VisitInjectedClassNameTypeLoc(InjectedClassNameTypeLoc TL) {\n  return Visit(MakeCursorTypeRef(TL.getDecl(), TL.getNameLoc(), TU));\n}\n\nbool CursorVisitor::VisitAtomicTypeLoc(AtomicTypeLoc TL) {\n  return Visit(TL.getValueLoc());\n}\n\nbool CursorVisitor::VisitPipeTypeLoc(PipeTypeLoc TL) {\n  return Visit(TL.getValueLoc());\n}\n\n#define DEFAULT_TYPELOC_IMPL(CLASS, PARENT)                                    \\\n  bool CursorVisitor::Visit##CLASS##TypeLoc(CLASS##TypeLoc TL) {               \\\n    return Visit##PARENT##Loc(TL);                                             \\\n  }\n\nDEFAULT_TYPELOC_IMPL(Complex, Type)\nDEFAULT_TYPELOC_IMPL(ConstantArray, ArrayType)\nDEFAULT_TYPELOC_IMPL(IncompleteArray, ArrayType)\nDEFAULT_TYPELOC_IMPL(VariableArray, ArrayType)\nDEFAULT_TYPELOC_IMPL(DependentSizedArray, ArrayType)\nDEFAULT_TYPELOC_IMPL(DependentAddressSpace, Type)\nDEFAULT_TYPELOC_IMPL(DependentVector, Type)\nDEFAULT_TYPELOC_IMPL(DependentSizedExtVector, Type)\nDEFAULT_TYPELOC_IMPL(Vector, Type)\nDEFAULT_TYPELOC_IMPL(ExtVector, VectorType)\nDEFAULT_TYPELOC_IMPL(ConstantMatrix, MatrixType)\nDEFAULT_TYPELOC_IMPL(DependentSizedMatrix, MatrixType)\nDEFAULT_TYPELOC_IMPL(FunctionProto, FunctionType)\nDEFAULT_TYPELOC_IMPL(FunctionNoProto, FunctionType)\nDEFAULT_TYPELOC_IMPL(Record, TagType)\nDEFAULT_TYPELOC_IMPL(Enum, TagType)\nDEFAULT_TYPELOC_IMPL(SubstTemplateTypeParm, Type)\nDEFAULT_TYPELOC_IMPL(SubstTemplateTypeParmPack, Type)\nDEFAULT_TYPELOC_IMPL(Auto, Type)\nDEFAULT_TYPELOC_IMPL(ExtInt, Type)\nDEFAULT_TYPELOC_IMPL(DependentExtInt, Type)\n\nbool CursorVisitor::VisitCXXRecordDecl(CXXRecordDecl *D) {\n  // Visit the nested-name-specifier, if present.\n  if (NestedNameSpecifierLoc QualifierLoc = D->getQualifierLoc())\n    if (VisitNestedNameSpecifierLoc(QualifierLoc))\n      return true;\n\n  if (D->isCompleteDefinition()) {\n    for (const auto &I : D->bases()) {\n      if (Visit(cxcursor::MakeCursorCXXBaseSpecifier(&I, TU)))\n        return true;\n    }\n  }\n\n  return VisitTagDecl(D);\n}\n\nbool CursorVisitor::VisitAttributes(Decl *D) {\n  for (const auto *I : D->attrs())\n    if ((TU->ParsingOptions & CXTranslationUnit_VisitImplicitAttributes ||\n         !I->isImplicit()) &&\n        Visit(MakeCXCursor(I, D, TU)))\n      return true;\n\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n// Data-recursive visitor methods.\n//===----------------------------------------------------------------------===//\n\nnamespace {\n#define DEF_JOB(NAME, DATA, KIND)                                              \\\n  class NAME : public VisitorJob {                                             \\\n  public:                                                                      \\\n    NAME(const DATA *d, CXCursor parent)                                       \\\n        : VisitorJob(parent, VisitorJob::KIND, d) {}                           \\\n    static bool classof(const VisitorJob *VJ) {                                \\\n      return VJ->getKind() == KIND;                                            \\\n    }                                                                          \\\n    const DATA *get() const { return static_cast<const DATA *>(data[0]); }     \\\n  };\n\nDEF_JOB(StmtVisit, Stmt, StmtVisitKind)\nDEF_JOB(MemberExprParts, MemberExpr, MemberExprPartsKind)\nDEF_JOB(DeclRefExprParts, DeclRefExpr, DeclRefExprPartsKind)\nDEF_JOB(OverloadExprParts, OverloadExpr, OverloadExprPartsKind)\nDEF_JOB(SizeOfPackExprParts, SizeOfPackExpr, SizeOfPackExprPartsKind)\nDEF_JOB(LambdaExprParts, LambdaExpr, LambdaExprPartsKind)\nDEF_JOB(PostChildrenVisit, void, PostChildrenVisitKind)\n#undef DEF_JOB\n\nclass ExplicitTemplateArgsVisit : public VisitorJob {\npublic:\n  ExplicitTemplateArgsVisit(const TemplateArgumentLoc *Begin,\n                            const TemplateArgumentLoc *End, CXCursor parent)\n      : VisitorJob(parent, VisitorJob::ExplicitTemplateArgsVisitKind, Begin,\n                   End) {}\n  static bool classof(const VisitorJob *VJ) {\n    return VJ->getKind() == ExplicitTemplateArgsVisitKind;\n  }\n  const TemplateArgumentLoc *begin() const {\n    return static_cast<const TemplateArgumentLoc *>(data[0]);\n  }\n  const TemplateArgumentLoc *end() {\n    return static_cast<const TemplateArgumentLoc *>(data[1]);\n  }\n};\nclass DeclVisit : public VisitorJob {\npublic:\n  DeclVisit(const Decl *D, CXCursor parent, bool isFirst)\n      : VisitorJob(parent, VisitorJob::DeclVisitKind, D,\n                   isFirst ? (void *)1 : (void *)nullptr) {}\n  static bool classof(const VisitorJob *VJ) {\n    return VJ->getKind() == DeclVisitKind;\n  }\n  const Decl *get() const { return static_cast<const Decl *>(data[0]); }\n  bool isFirst() const { return data[1] != nullptr; }\n};\nclass TypeLocVisit : public VisitorJob {\npublic:\n  TypeLocVisit(TypeLoc tl, CXCursor parent)\n      : VisitorJob(parent, VisitorJob::TypeLocVisitKind,\n                   tl.getType().getAsOpaquePtr(), tl.getOpaqueData()) {}\n\n  static bool classof(const VisitorJob *VJ) {\n    return VJ->getKind() == TypeLocVisitKind;\n  }\n\n  TypeLoc get() const {\n    QualType T = QualType::getFromOpaquePtr(data[0]);\n    return TypeLoc(T, const_cast<void *>(data[1]));\n  }\n};\n\nclass LabelRefVisit : public VisitorJob {\npublic:\n  LabelRefVisit(LabelDecl *LD, SourceLocation labelLoc, CXCursor parent)\n      : VisitorJob(parent, VisitorJob::LabelRefVisitKind, LD,\n                   labelLoc.getPtrEncoding()) {}\n\n  static bool classof(const VisitorJob *VJ) {\n    return VJ->getKind() == VisitorJob::LabelRefVisitKind;\n  }\n  const LabelDecl *get() const {\n    return static_cast<const LabelDecl *>(data[0]);\n  }\n  SourceLocation getLoc() const {\n    return SourceLocation::getFromPtrEncoding(data[1]);\n  }\n};\n\nclass NestedNameSpecifierLocVisit : public VisitorJob {\npublic:\n  NestedNameSpecifierLocVisit(NestedNameSpecifierLoc Qualifier, CXCursor parent)\n      : VisitorJob(parent, VisitorJob::NestedNameSpecifierLocVisitKind,\n                   Qualifier.getNestedNameSpecifier(),\n                   Qualifier.getOpaqueData()) {}\n\n  static bool classof(const VisitorJob *VJ) {\n    return VJ->getKind() == VisitorJob::NestedNameSpecifierLocVisitKind;\n  }\n\n  NestedNameSpecifierLoc get() const {\n    return NestedNameSpecifierLoc(\n        const_cast<NestedNameSpecifier *>(\n            static_cast<const NestedNameSpecifier *>(data[0])),\n        const_cast<void *>(data[1]));\n  }\n};\n\nclass DeclarationNameInfoVisit : public VisitorJob {\npublic:\n  DeclarationNameInfoVisit(const Stmt *S, CXCursor parent)\n      : VisitorJob(parent, VisitorJob::DeclarationNameInfoVisitKind, S) {}\n  static bool classof(const VisitorJob *VJ) {\n    return VJ->getKind() == VisitorJob::DeclarationNameInfoVisitKind;\n  }\n  DeclarationNameInfo get() const {\n    const Stmt *S = static_cast<const Stmt *>(data[0]);\n    switch (S->getStmtClass()) {\n    default:\n      llvm_unreachable(\"Unhandled Stmt\");\n    case clang::Stmt::MSDependentExistsStmtClass:\n      return cast<MSDependentExistsStmt>(S)->getNameInfo();\n    case Stmt::CXXDependentScopeMemberExprClass:\n      return cast<CXXDependentScopeMemberExpr>(S)->getMemberNameInfo();\n    case Stmt::DependentScopeDeclRefExprClass:\n      return cast<DependentScopeDeclRefExpr>(S)->getNameInfo();\n    case Stmt::OMPCriticalDirectiveClass:\n      return cast<OMPCriticalDirective>(S)->getDirectiveName();\n    }\n  }\n};\nclass MemberRefVisit : public VisitorJob {\npublic:\n  MemberRefVisit(const FieldDecl *D, SourceLocation L, CXCursor parent)\n      : VisitorJob(parent, VisitorJob::MemberRefVisitKind, D,\n                   L.getPtrEncoding()) {}\n  static bool classof(const VisitorJob *VJ) {\n    return VJ->getKind() == VisitorJob::MemberRefVisitKind;\n  }\n  const FieldDecl *get() const {\n    return static_cast<const FieldDecl *>(data[0]);\n  }\n  SourceLocation getLoc() const {\n    return SourceLocation::getFromRawEncoding((unsigned)(uintptr_t)data[1]);\n  }\n};\nclass EnqueueVisitor : public ConstStmtVisitor<EnqueueVisitor, void> {\n  friend class OMPClauseEnqueue;\n  VisitorWorkList &WL;\n  CXCursor Parent;\n\npublic:\n  EnqueueVisitor(VisitorWorkList &wl, CXCursor parent)\n      : WL(wl), Parent(parent) {}\n\n  void VisitAddrLabelExpr(const AddrLabelExpr *E);\n  void VisitBlockExpr(const BlockExpr *B);\n  void VisitCompoundLiteralExpr(const CompoundLiteralExpr *E);\n  void VisitCompoundStmt(const CompoundStmt *S);\n  void VisitCXXDefaultArgExpr(const CXXDefaultArgExpr *E) { /* Do nothing. */\n  }\n  void VisitMSDependentExistsStmt(const MSDependentExistsStmt *S);\n  void VisitCXXDependentScopeMemberExpr(const CXXDependentScopeMemberExpr *E);\n  void VisitCXXNewExpr(const CXXNewExpr *E);\n  void VisitCXXScalarValueInitExpr(const CXXScalarValueInitExpr *E);\n  void VisitCXXOperatorCallExpr(const CXXOperatorCallExpr *E);\n  void VisitCXXPseudoDestructorExpr(const CXXPseudoDestructorExpr *E);\n  void VisitCXXTemporaryObjectExpr(const CXXTemporaryObjectExpr *E);\n  void VisitCXXTypeidExpr(const CXXTypeidExpr *E);\n  void VisitCXXUnresolvedConstructExpr(const CXXUnresolvedConstructExpr *E);\n  void VisitCXXUuidofExpr(const CXXUuidofExpr *E);\n  void VisitCXXCatchStmt(const CXXCatchStmt *S);\n  void VisitCXXForRangeStmt(const CXXForRangeStmt *S);\n  void VisitDeclRefExpr(const DeclRefExpr *D);\n  void VisitDeclStmt(const DeclStmt *S);\n  void VisitDependentScopeDeclRefExpr(const DependentScopeDeclRefExpr *E);\n  void VisitDesignatedInitExpr(const DesignatedInitExpr *E);\n  void VisitExplicitCastExpr(const ExplicitCastExpr *E);\n  void VisitForStmt(const ForStmt *FS);\n  void VisitGotoStmt(const GotoStmt *GS);\n  void VisitIfStmt(const IfStmt *If);\n  void VisitInitListExpr(const InitListExpr *IE);\n  void VisitMemberExpr(const MemberExpr *M);\n  void VisitOffsetOfExpr(const OffsetOfExpr *E);\n  void VisitObjCEncodeExpr(const ObjCEncodeExpr *E);\n  void VisitObjCMessageExpr(const ObjCMessageExpr *M);\n  void VisitOverloadExpr(const OverloadExpr *E);\n  void VisitUnaryExprOrTypeTraitExpr(const UnaryExprOrTypeTraitExpr *E);\n  void VisitStmt(const Stmt *S);\n  void VisitSwitchStmt(const SwitchStmt *S);\n  void VisitWhileStmt(const WhileStmt *W);\n  void VisitTypeTraitExpr(const TypeTraitExpr *E);\n  void VisitArrayTypeTraitExpr(const ArrayTypeTraitExpr *E);\n  void VisitExpressionTraitExpr(const ExpressionTraitExpr *E);\n  void VisitUnresolvedMemberExpr(const UnresolvedMemberExpr *U);\n  void VisitVAArgExpr(const VAArgExpr *E);\n  void VisitSizeOfPackExpr(const SizeOfPackExpr *E);\n  void VisitPseudoObjectExpr(const PseudoObjectExpr *E);\n  void VisitOpaqueValueExpr(const OpaqueValueExpr *E);\n  void VisitLambdaExpr(const LambdaExpr *E);\n  void VisitOMPExecutableDirective(const OMPExecutableDirective *D);\n  void VisitOMPLoopBasedDirective(const OMPLoopBasedDirective *D);\n  void VisitOMPLoopDirective(const OMPLoopDirective *D);\n  void VisitOMPParallelDirective(const OMPParallelDirective *D);\n  void VisitOMPSimdDirective(const OMPSimdDirective *D);\n  void VisitOMPTileDirective(const OMPTileDirective *D);\n  void VisitOMPForDirective(const OMPForDirective *D);\n  void VisitOMPForSimdDirective(const OMPForSimdDirective *D);\n  void VisitOMPSectionsDirective(const OMPSectionsDirective *D);\n  void VisitOMPSectionDirective(const OMPSectionDirective *D);\n  void VisitOMPSingleDirective(const OMPSingleDirective *D);\n  void VisitOMPMasterDirective(const OMPMasterDirective *D);\n  void VisitOMPCriticalDirective(const OMPCriticalDirective *D);\n  void VisitOMPParallelForDirective(const OMPParallelForDirective *D);\n  void VisitOMPParallelForSimdDirective(const OMPParallelForSimdDirective *D);\n  void VisitOMPParallelMasterDirective(const OMPParallelMasterDirective *D);\n  void VisitOMPParallelSectionsDirective(const OMPParallelSectionsDirective *D);\n  void VisitOMPTaskDirective(const OMPTaskDirective *D);\n  void VisitOMPTaskyieldDirective(const OMPTaskyieldDirective *D);\n  void VisitOMPBarrierDirective(const OMPBarrierDirective *D);\n  void VisitOMPTaskwaitDirective(const OMPTaskwaitDirective *D);\n  void VisitOMPTaskgroupDirective(const OMPTaskgroupDirective *D);\n  void\n  VisitOMPCancellationPointDirective(const OMPCancellationPointDirective *D);\n  void VisitOMPCancelDirective(const OMPCancelDirective *D);\n  void VisitOMPFlushDirective(const OMPFlushDirective *D);\n  void VisitOMPDepobjDirective(const OMPDepobjDirective *D);\n  void VisitOMPScanDirective(const OMPScanDirective *D);\n  void VisitOMPOrderedDirective(const OMPOrderedDirective *D);\n  void VisitOMPAtomicDirective(const OMPAtomicDirective *D);\n  void VisitOMPTargetDirective(const OMPTargetDirective *D);\n  void VisitOMPTargetDataDirective(const OMPTargetDataDirective *D);\n  void VisitOMPTargetEnterDataDirective(const OMPTargetEnterDataDirective *D);\n  void VisitOMPTargetExitDataDirective(const OMPTargetExitDataDirective *D);\n  void VisitOMPTargetParallelDirective(const OMPTargetParallelDirective *D);\n  void\n  VisitOMPTargetParallelForDirective(const OMPTargetParallelForDirective *D);\n  void VisitOMPTeamsDirective(const OMPTeamsDirective *D);\n  void VisitOMPTaskLoopDirective(const OMPTaskLoopDirective *D);\n  void VisitOMPTaskLoopSimdDirective(const OMPTaskLoopSimdDirective *D);\n  void VisitOMPMasterTaskLoopDirective(const OMPMasterTaskLoopDirective *D);\n  void\n  VisitOMPMasterTaskLoopSimdDirective(const OMPMasterTaskLoopSimdDirective *D);\n  void VisitOMPParallelMasterTaskLoopDirective(\n      const OMPParallelMasterTaskLoopDirective *D);\n  void VisitOMPParallelMasterTaskLoopSimdDirective(\n      const OMPParallelMasterTaskLoopSimdDirective *D);\n  void VisitOMPDistributeDirective(const OMPDistributeDirective *D);\n  void VisitOMPDistributeParallelForDirective(\n      const OMPDistributeParallelForDirective *D);\n  void VisitOMPDistributeParallelForSimdDirective(\n      const OMPDistributeParallelForSimdDirective *D);\n  void VisitOMPDistributeSimdDirective(const OMPDistributeSimdDirective *D);\n  void VisitOMPTargetParallelForSimdDirective(\n      const OMPTargetParallelForSimdDirective *D);\n  void VisitOMPTargetSimdDirective(const OMPTargetSimdDirective *D);\n  void VisitOMPTeamsDistributeDirective(const OMPTeamsDistributeDirective *D);\n  void VisitOMPTeamsDistributeSimdDirective(\n      const OMPTeamsDistributeSimdDirective *D);\n  void VisitOMPTeamsDistributeParallelForSimdDirective(\n      const OMPTeamsDistributeParallelForSimdDirective *D);\n  void VisitOMPTeamsDistributeParallelForDirective(\n      const OMPTeamsDistributeParallelForDirective *D);\n  void VisitOMPTargetTeamsDirective(const OMPTargetTeamsDirective *D);\n  void VisitOMPTargetTeamsDistributeDirective(\n      const OMPTargetTeamsDistributeDirective *D);\n  void VisitOMPTargetTeamsDistributeParallelForDirective(\n      const OMPTargetTeamsDistributeParallelForDirective *D);\n  void VisitOMPTargetTeamsDistributeParallelForSimdDirective(\n      const OMPTargetTeamsDistributeParallelForSimdDirective *D);\n  void VisitOMPTargetTeamsDistributeSimdDirective(\n      const OMPTargetTeamsDistributeSimdDirective *D);\n\nprivate:\n  void AddDeclarationNameInfo(const Stmt *S);\n  void AddNestedNameSpecifierLoc(NestedNameSpecifierLoc Qualifier);\n  void AddExplicitTemplateArgs(const TemplateArgumentLoc *A,\n                               unsigned NumTemplateArgs);\n  void AddMemberRef(const FieldDecl *D, SourceLocation L);\n  void AddStmt(const Stmt *S);\n  void AddDecl(const Decl *D, bool isFirst = true);\n  void AddTypeLoc(TypeSourceInfo *TI);\n  void EnqueueChildren(const Stmt *S);\n  void EnqueueChildren(const OMPClause *S);\n};\n} // namespace\n\nvoid EnqueueVisitor::AddDeclarationNameInfo(const Stmt *S) {\n  // 'S' should always be non-null, since it comes from the\n  // statement we are visiting.\n  WL.push_back(DeclarationNameInfoVisit(S, Parent));\n}\n\nvoid EnqueueVisitor::AddNestedNameSpecifierLoc(\n    NestedNameSpecifierLoc Qualifier) {\n  if (Qualifier)\n    WL.push_back(NestedNameSpecifierLocVisit(Qualifier, Parent));\n}\n\nvoid EnqueueVisitor::AddStmt(const Stmt *S) {\n  if (S)\n    WL.push_back(StmtVisit(S, Parent));\n}\nvoid EnqueueVisitor::AddDecl(const Decl *D, bool isFirst) {\n  if (D)\n    WL.push_back(DeclVisit(D, Parent, isFirst));\n}\nvoid EnqueueVisitor::AddExplicitTemplateArgs(const TemplateArgumentLoc *A,\n                                             unsigned NumTemplateArgs) {\n  WL.push_back(ExplicitTemplateArgsVisit(A, A + NumTemplateArgs, Parent));\n}\nvoid EnqueueVisitor::AddMemberRef(const FieldDecl *D, SourceLocation L) {\n  if (D)\n    WL.push_back(MemberRefVisit(D, L, Parent));\n}\nvoid EnqueueVisitor::AddTypeLoc(TypeSourceInfo *TI) {\n  if (TI)\n    WL.push_back(TypeLocVisit(TI->getTypeLoc(), Parent));\n}\nvoid EnqueueVisitor::EnqueueChildren(const Stmt *S) {\n  unsigned size = WL.size();\n  for (const Stmt *SubStmt : S->children()) {\n    AddStmt(SubStmt);\n  }\n  if (size == WL.size())\n    return;\n  // Now reverse the entries we just added.  This will match the DFS\n  // ordering performed by the worklist.\n  VisitorWorkList::iterator I = WL.begin() + size, E = WL.end();\n  std::reverse(I, E);\n}\nnamespace {\nclass OMPClauseEnqueue : public ConstOMPClauseVisitor<OMPClauseEnqueue> {\n  EnqueueVisitor *Visitor;\n  /// Process clauses with list of variables.\n  template <typename T> void VisitOMPClauseList(T *Node);\n\npublic:\n  OMPClauseEnqueue(EnqueueVisitor *Visitor) : Visitor(Visitor) {}\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class) void Visit##Class(const Class *C);\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n  void VisitOMPClauseWithPreInit(const OMPClauseWithPreInit *C);\n  void VisitOMPClauseWithPostUpdate(const OMPClauseWithPostUpdate *C);\n};\n\nvoid OMPClauseEnqueue::VisitOMPClauseWithPreInit(\n    const OMPClauseWithPreInit *C) {\n  Visitor->AddStmt(C->getPreInitStmt());\n}\n\nvoid OMPClauseEnqueue::VisitOMPClauseWithPostUpdate(\n    const OMPClauseWithPostUpdate *C) {\n  VisitOMPClauseWithPreInit(C);\n  Visitor->AddStmt(C->getPostUpdateExpr());\n}\n\nvoid OMPClauseEnqueue::VisitOMPIfClause(const OMPIfClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  Visitor->AddStmt(C->getCondition());\n}\n\nvoid OMPClauseEnqueue::VisitOMPFinalClause(const OMPFinalClause *C) {\n  Visitor->AddStmt(C->getCondition());\n}\n\nvoid OMPClauseEnqueue::VisitOMPNumThreadsClause(const OMPNumThreadsClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  Visitor->AddStmt(C->getNumThreads());\n}\n\nvoid OMPClauseEnqueue::VisitOMPSafelenClause(const OMPSafelenClause *C) {\n  Visitor->AddStmt(C->getSafelen());\n}\n\nvoid OMPClauseEnqueue::VisitOMPSimdlenClause(const OMPSimdlenClause *C) {\n  Visitor->AddStmt(C->getSimdlen());\n}\n\nvoid OMPClauseEnqueue::VisitOMPSizesClause(const OMPSizesClause *C) {\n  for (auto E : C->getSizesRefs())\n    Visitor->AddStmt(E);\n}\n\nvoid OMPClauseEnqueue::VisitOMPAllocatorClause(const OMPAllocatorClause *C) {\n  Visitor->AddStmt(C->getAllocator());\n}\n\nvoid OMPClauseEnqueue::VisitOMPCollapseClause(const OMPCollapseClause *C) {\n  Visitor->AddStmt(C->getNumForLoops());\n}\n\nvoid OMPClauseEnqueue::VisitOMPDefaultClause(const OMPDefaultClause *C) {}\n\nvoid OMPClauseEnqueue::VisitOMPProcBindClause(const OMPProcBindClause *C) {}\n\nvoid OMPClauseEnqueue::VisitOMPScheduleClause(const OMPScheduleClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  Visitor->AddStmt(C->getChunkSize());\n}\n\nvoid OMPClauseEnqueue::VisitOMPOrderedClause(const OMPOrderedClause *C) {\n  Visitor->AddStmt(C->getNumForLoops());\n}\n\nvoid OMPClauseEnqueue::VisitOMPDetachClause(const OMPDetachClause *C) {\n  Visitor->AddStmt(C->getEventHandler());\n}\n\nvoid OMPClauseEnqueue::VisitOMPNowaitClause(const OMPNowaitClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPUntiedClause(const OMPUntiedClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPMergeableClause(const OMPMergeableClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPReadClause(const OMPReadClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPWriteClause(const OMPWriteClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPUpdateClause(const OMPUpdateClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPCaptureClause(const OMPCaptureClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPSeqCstClause(const OMPSeqCstClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPAcqRelClause(const OMPAcqRelClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPAcquireClause(const OMPAcquireClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPReleaseClause(const OMPReleaseClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPRelaxedClause(const OMPRelaxedClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPThreadsClause(const OMPThreadsClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPSIMDClause(const OMPSIMDClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPNogroupClause(const OMPNogroupClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPDestroyClause(const OMPDestroyClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPUnifiedAddressClause(\n    const OMPUnifiedAddressClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPUnifiedSharedMemoryClause(\n    const OMPUnifiedSharedMemoryClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPReverseOffloadClause(\n    const OMPReverseOffloadClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPDynamicAllocatorsClause(\n    const OMPDynamicAllocatorsClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPAtomicDefaultMemOrderClause(\n    const OMPAtomicDefaultMemOrderClause *) {}\n\nvoid OMPClauseEnqueue::VisitOMPDeviceClause(const OMPDeviceClause *C) {\n  Visitor->AddStmt(C->getDevice());\n}\n\nvoid OMPClauseEnqueue::VisitOMPNumTeamsClause(const OMPNumTeamsClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  Visitor->AddStmt(C->getNumTeams());\n}\n\nvoid OMPClauseEnqueue::VisitOMPThreadLimitClause(\n    const OMPThreadLimitClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  Visitor->AddStmt(C->getThreadLimit());\n}\n\nvoid OMPClauseEnqueue::VisitOMPPriorityClause(const OMPPriorityClause *C) {\n  Visitor->AddStmt(C->getPriority());\n}\n\nvoid OMPClauseEnqueue::VisitOMPGrainsizeClause(const OMPGrainsizeClause *C) {\n  Visitor->AddStmt(C->getGrainsize());\n}\n\nvoid OMPClauseEnqueue::VisitOMPNumTasksClause(const OMPNumTasksClause *C) {\n  Visitor->AddStmt(C->getNumTasks());\n}\n\nvoid OMPClauseEnqueue::VisitOMPHintClause(const OMPHintClause *C) {\n  Visitor->AddStmt(C->getHint());\n}\n\ntemplate <typename T> void OMPClauseEnqueue::VisitOMPClauseList(T *Node) {\n  for (const auto *I : Node->varlists()) {\n    Visitor->AddStmt(I);\n  }\n}\n\nvoid OMPClauseEnqueue::VisitOMPInclusiveClause(const OMPInclusiveClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPExclusiveClause(const OMPExclusiveClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPAllocateClause(const OMPAllocateClause *C) {\n  VisitOMPClauseList(C);\n  Visitor->AddStmt(C->getAllocator());\n}\nvoid OMPClauseEnqueue::VisitOMPPrivateClause(const OMPPrivateClause *C) {\n  VisitOMPClauseList(C);\n  for (const auto *E : C->private_copies()) {\n    Visitor->AddStmt(E);\n  }\n}\nvoid OMPClauseEnqueue::VisitOMPFirstprivateClause(\n    const OMPFirstprivateClause *C) {\n  VisitOMPClauseList(C);\n  VisitOMPClauseWithPreInit(C);\n  for (const auto *E : C->private_copies()) {\n    Visitor->AddStmt(E);\n  }\n  for (const auto *E : C->inits()) {\n    Visitor->AddStmt(E);\n  }\n}\nvoid OMPClauseEnqueue::VisitOMPLastprivateClause(\n    const OMPLastprivateClause *C) {\n  VisitOMPClauseList(C);\n  VisitOMPClauseWithPostUpdate(C);\n  for (auto *E : C->private_copies()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->source_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->destination_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->assignment_ops()) {\n    Visitor->AddStmt(E);\n  }\n}\nvoid OMPClauseEnqueue::VisitOMPSharedClause(const OMPSharedClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPReductionClause(const OMPReductionClause *C) {\n  VisitOMPClauseList(C);\n  VisitOMPClauseWithPostUpdate(C);\n  for (auto *E : C->privates()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->lhs_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->rhs_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->reduction_ops()) {\n    Visitor->AddStmt(E);\n  }\n  if (C->getModifier() == clang::OMPC_REDUCTION_inscan) {\n    for (auto *E : C->copy_ops()) {\n      Visitor->AddStmt(E);\n    }\n    for (auto *E : C->copy_array_temps()) {\n      Visitor->AddStmt(E);\n    }\n    for (auto *E : C->copy_array_elems()) {\n      Visitor->AddStmt(E);\n    }\n  }\n}\nvoid OMPClauseEnqueue::VisitOMPTaskReductionClause(\n    const OMPTaskReductionClause *C) {\n  VisitOMPClauseList(C);\n  VisitOMPClauseWithPostUpdate(C);\n  for (auto *E : C->privates()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->lhs_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->rhs_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->reduction_ops()) {\n    Visitor->AddStmt(E);\n  }\n}\nvoid OMPClauseEnqueue::VisitOMPInReductionClause(\n    const OMPInReductionClause *C) {\n  VisitOMPClauseList(C);\n  VisitOMPClauseWithPostUpdate(C);\n  for (auto *E : C->privates()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->lhs_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->rhs_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->reduction_ops()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->taskgroup_descriptors())\n    Visitor->AddStmt(E);\n}\nvoid OMPClauseEnqueue::VisitOMPLinearClause(const OMPLinearClause *C) {\n  VisitOMPClauseList(C);\n  VisitOMPClauseWithPostUpdate(C);\n  for (const auto *E : C->privates()) {\n    Visitor->AddStmt(E);\n  }\n  for (const auto *E : C->inits()) {\n    Visitor->AddStmt(E);\n  }\n  for (const auto *E : C->updates()) {\n    Visitor->AddStmt(E);\n  }\n  for (const auto *E : C->finals()) {\n    Visitor->AddStmt(E);\n  }\n  Visitor->AddStmt(C->getStep());\n  Visitor->AddStmt(C->getCalcStep());\n}\nvoid OMPClauseEnqueue::VisitOMPAlignedClause(const OMPAlignedClause *C) {\n  VisitOMPClauseList(C);\n  Visitor->AddStmt(C->getAlignment());\n}\nvoid OMPClauseEnqueue::VisitOMPCopyinClause(const OMPCopyinClause *C) {\n  VisitOMPClauseList(C);\n  for (auto *E : C->source_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->destination_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->assignment_ops()) {\n    Visitor->AddStmt(E);\n  }\n}\nvoid OMPClauseEnqueue::VisitOMPCopyprivateClause(\n    const OMPCopyprivateClause *C) {\n  VisitOMPClauseList(C);\n  for (auto *E : C->source_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->destination_exprs()) {\n    Visitor->AddStmt(E);\n  }\n  for (auto *E : C->assignment_ops()) {\n    Visitor->AddStmt(E);\n  }\n}\nvoid OMPClauseEnqueue::VisitOMPFlushClause(const OMPFlushClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPDepobjClause(const OMPDepobjClause *C) {\n  Visitor->AddStmt(C->getDepobj());\n}\nvoid OMPClauseEnqueue::VisitOMPDependClause(const OMPDependClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPMapClause(const OMPMapClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPDistScheduleClause(\n    const OMPDistScheduleClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  Visitor->AddStmt(C->getChunkSize());\n}\nvoid OMPClauseEnqueue::VisitOMPDefaultmapClause(\n    const OMPDefaultmapClause * /*C*/) {}\nvoid OMPClauseEnqueue::VisitOMPToClause(const OMPToClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPFromClause(const OMPFromClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPUseDevicePtrClause(\n    const OMPUseDevicePtrClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPUseDeviceAddrClause(\n    const OMPUseDeviceAddrClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPIsDevicePtrClause(\n    const OMPIsDevicePtrClause *C) {\n  VisitOMPClauseList(C);\n}\nvoid OMPClauseEnqueue::VisitOMPNontemporalClause(\n    const OMPNontemporalClause *C) {\n  VisitOMPClauseList(C);\n  for (const auto *E : C->private_refs())\n    Visitor->AddStmt(E);\n}\nvoid OMPClauseEnqueue::VisitOMPOrderClause(const OMPOrderClause *C) {}\nvoid OMPClauseEnqueue::VisitOMPUsesAllocatorsClause(\n    const OMPUsesAllocatorsClause *C) {\n  for (unsigned I = 0, E = C->getNumberOfAllocators(); I < E; ++I) {\n    const OMPUsesAllocatorsClause::Data &D = C->getAllocatorData(I);\n    Visitor->AddStmt(D.Allocator);\n    Visitor->AddStmt(D.AllocatorTraits);\n  }\n}\nvoid OMPClauseEnqueue::VisitOMPAffinityClause(const OMPAffinityClause *C) {\n  Visitor->AddStmt(C->getModifier());\n  for (const Expr *E : C->varlists())\n    Visitor->AddStmt(E);\n}\n} // namespace\n\nvoid EnqueueVisitor::EnqueueChildren(const OMPClause *S) {\n  unsigned size = WL.size();\n  OMPClauseEnqueue Visitor(this);\n  Visitor.Visit(S);\n  if (size == WL.size())\n    return;\n  // Now reverse the entries we just added.  This will match the DFS\n  // ordering performed by the worklist.\n  VisitorWorkList::iterator I = WL.begin() + size, E = WL.end();\n  std::reverse(I, E);\n}\nvoid EnqueueVisitor::VisitAddrLabelExpr(const AddrLabelExpr *E) {\n  WL.push_back(LabelRefVisit(E->getLabel(), E->getLabelLoc(), Parent));\n}\nvoid EnqueueVisitor::VisitBlockExpr(const BlockExpr *B) {\n  AddDecl(B->getBlockDecl());\n}\nvoid EnqueueVisitor::VisitCompoundLiteralExpr(const CompoundLiteralExpr *E) {\n  EnqueueChildren(E);\n  AddTypeLoc(E->getTypeSourceInfo());\n}\nvoid EnqueueVisitor::VisitCompoundStmt(const CompoundStmt *S) {\n  for (auto &I : llvm::reverse(S->body()))\n    AddStmt(I);\n}\nvoid EnqueueVisitor::VisitMSDependentExistsStmt(\n    const MSDependentExistsStmt *S) {\n  AddStmt(S->getSubStmt());\n  AddDeclarationNameInfo(S);\n  if (NestedNameSpecifierLoc QualifierLoc = S->getQualifierLoc())\n    AddNestedNameSpecifierLoc(QualifierLoc);\n}\n\nvoid EnqueueVisitor::VisitCXXDependentScopeMemberExpr(\n    const CXXDependentScopeMemberExpr *E) {\n  if (E->hasExplicitTemplateArgs())\n    AddExplicitTemplateArgs(E->getTemplateArgs(), E->getNumTemplateArgs());\n  AddDeclarationNameInfo(E);\n  if (NestedNameSpecifierLoc QualifierLoc = E->getQualifierLoc())\n    AddNestedNameSpecifierLoc(QualifierLoc);\n  if (!E->isImplicitAccess())\n    AddStmt(E->getBase());\n}\nvoid EnqueueVisitor::VisitCXXNewExpr(const CXXNewExpr *E) {\n  // Enqueue the initializer , if any.\n  AddStmt(E->getInitializer());\n  // Enqueue the array size, if any.\n  AddStmt(E->getArraySize().getValueOr(nullptr));\n  // Enqueue the allocated type.\n  AddTypeLoc(E->getAllocatedTypeSourceInfo());\n  // Enqueue the placement arguments.\n  for (unsigned I = E->getNumPlacementArgs(); I > 0; --I)\n    AddStmt(E->getPlacementArg(I - 1));\n}\nvoid EnqueueVisitor::VisitCXXOperatorCallExpr(const CXXOperatorCallExpr *CE) {\n  for (unsigned I = CE->getNumArgs(); I > 1 /* Yes, this is 1 */; --I)\n    AddStmt(CE->getArg(I - 1));\n  AddStmt(CE->getCallee());\n  AddStmt(CE->getArg(0));\n}\nvoid EnqueueVisitor::VisitCXXPseudoDestructorExpr(\n    const CXXPseudoDestructorExpr *E) {\n  // Visit the name of the type being destroyed.\n  AddTypeLoc(E->getDestroyedTypeInfo());\n  // Visit the scope type that looks disturbingly like the nested-name-specifier\n  // but isn't.\n  AddTypeLoc(E->getScopeTypeInfo());\n  // Visit the nested-name-specifier.\n  if (NestedNameSpecifierLoc QualifierLoc = E->getQualifierLoc())\n    AddNestedNameSpecifierLoc(QualifierLoc);\n  // Visit base expression.\n  AddStmt(E->getBase());\n}\nvoid EnqueueVisitor::VisitCXXScalarValueInitExpr(\n    const CXXScalarValueInitExpr *E) {\n  AddTypeLoc(E->getTypeSourceInfo());\n}\nvoid EnqueueVisitor::VisitCXXTemporaryObjectExpr(\n    const CXXTemporaryObjectExpr *E) {\n  EnqueueChildren(E);\n  AddTypeLoc(E->getTypeSourceInfo());\n}\nvoid EnqueueVisitor::VisitCXXTypeidExpr(const CXXTypeidExpr *E) {\n  EnqueueChildren(E);\n  if (E->isTypeOperand())\n    AddTypeLoc(E->getTypeOperandSourceInfo());\n}\n\nvoid EnqueueVisitor::VisitCXXUnresolvedConstructExpr(\n    const CXXUnresolvedConstructExpr *E) {\n  EnqueueChildren(E);\n  AddTypeLoc(E->getTypeSourceInfo());\n}\nvoid EnqueueVisitor::VisitCXXUuidofExpr(const CXXUuidofExpr *E) {\n  EnqueueChildren(E);\n  if (E->isTypeOperand())\n    AddTypeLoc(E->getTypeOperandSourceInfo());\n}\n\nvoid EnqueueVisitor::VisitCXXCatchStmt(const CXXCatchStmt *S) {\n  EnqueueChildren(S);\n  AddDecl(S->getExceptionDecl());\n}\n\nvoid EnqueueVisitor::VisitCXXForRangeStmt(const CXXForRangeStmt *S) {\n  AddStmt(S->getBody());\n  AddStmt(S->getRangeInit());\n  AddDecl(S->getLoopVariable());\n}\n\nvoid EnqueueVisitor::VisitDeclRefExpr(const DeclRefExpr *DR) {\n  if (DR->hasExplicitTemplateArgs())\n    AddExplicitTemplateArgs(DR->getTemplateArgs(), DR->getNumTemplateArgs());\n  WL.push_back(DeclRefExprParts(DR, Parent));\n}\nvoid EnqueueVisitor::VisitDependentScopeDeclRefExpr(\n    const DependentScopeDeclRefExpr *E) {\n  if (E->hasExplicitTemplateArgs())\n    AddExplicitTemplateArgs(E->getTemplateArgs(), E->getNumTemplateArgs());\n  AddDeclarationNameInfo(E);\n  AddNestedNameSpecifierLoc(E->getQualifierLoc());\n}\nvoid EnqueueVisitor::VisitDeclStmt(const DeclStmt *S) {\n  unsigned size = WL.size();\n  bool isFirst = true;\n  for (const auto *D : S->decls()) {\n    AddDecl(D, isFirst);\n    isFirst = false;\n  }\n  if (size == WL.size())\n    return;\n  // Now reverse the entries we just added.  This will match the DFS\n  // ordering performed by the worklist.\n  VisitorWorkList::iterator I = WL.begin() + size, E = WL.end();\n  std::reverse(I, E);\n}\nvoid EnqueueVisitor::VisitDesignatedInitExpr(const DesignatedInitExpr *E) {\n  AddStmt(E->getInit());\n  for (const DesignatedInitExpr::Designator &D :\n       llvm::reverse(E->designators())) {\n    if (D.isFieldDesignator()) {\n      if (FieldDecl *Field = D.getField())\n        AddMemberRef(Field, D.getFieldLoc());\n      continue;\n    }\n    if (D.isArrayDesignator()) {\n      AddStmt(E->getArrayIndex(D));\n      continue;\n    }\n    assert(D.isArrayRangeDesignator() && \"Unknown designator kind\");\n    AddStmt(E->getArrayRangeEnd(D));\n    AddStmt(E->getArrayRangeStart(D));\n  }\n}\nvoid EnqueueVisitor::VisitExplicitCastExpr(const ExplicitCastExpr *E) {\n  EnqueueChildren(E);\n  AddTypeLoc(E->getTypeInfoAsWritten());\n}\nvoid EnqueueVisitor::VisitForStmt(const ForStmt *FS) {\n  AddStmt(FS->getBody());\n  AddStmt(FS->getInc());\n  AddStmt(FS->getCond());\n  AddDecl(FS->getConditionVariable());\n  AddStmt(FS->getInit());\n}\nvoid EnqueueVisitor::VisitGotoStmt(const GotoStmt *GS) {\n  WL.push_back(LabelRefVisit(GS->getLabel(), GS->getLabelLoc(), Parent));\n}\nvoid EnqueueVisitor::VisitIfStmt(const IfStmt *If) {\n  AddStmt(If->getElse());\n  AddStmt(If->getThen());\n  AddStmt(If->getCond());\n  AddStmt(If->getInit());\n  AddDecl(If->getConditionVariable());\n}\nvoid EnqueueVisitor::VisitInitListExpr(const InitListExpr *IE) {\n  // We care about the syntactic form of the initializer list, only.\n  if (InitListExpr *Syntactic = IE->getSyntacticForm())\n    IE = Syntactic;\n  EnqueueChildren(IE);\n}\nvoid EnqueueVisitor::VisitMemberExpr(const MemberExpr *M) {\n  WL.push_back(MemberExprParts(M, Parent));\n\n  // If the base of the member access expression is an implicit 'this', don't\n  // visit it.\n  // FIXME: If we ever want to show these implicit accesses, this will be\n  // unfortunate. However, clang_getCursor() relies on this behavior.\n  if (M->isImplicitAccess())\n    return;\n\n  // Ignore base anonymous struct/union fields, otherwise they will shadow the\n  // real field that we are interested in.\n  if (auto *SubME = dyn_cast<MemberExpr>(M->getBase())) {\n    if (auto *FD = dyn_cast_or_null<FieldDecl>(SubME->getMemberDecl())) {\n      if (FD->isAnonymousStructOrUnion()) {\n        AddStmt(SubME->getBase());\n        return;\n      }\n    }\n  }\n\n  AddStmt(M->getBase());\n}\nvoid EnqueueVisitor::VisitObjCEncodeExpr(const ObjCEncodeExpr *E) {\n  AddTypeLoc(E->getEncodedTypeSourceInfo());\n}\nvoid EnqueueVisitor::VisitObjCMessageExpr(const ObjCMessageExpr *M) {\n  EnqueueChildren(M);\n  AddTypeLoc(M->getClassReceiverTypeInfo());\n}\nvoid EnqueueVisitor::VisitOffsetOfExpr(const OffsetOfExpr *E) {\n  // Visit the components of the offsetof expression.\n  for (unsigned N = E->getNumComponents(), I = N; I > 0; --I) {\n    const OffsetOfNode &Node = E->getComponent(I - 1);\n    switch (Node.getKind()) {\n    case OffsetOfNode::Array:\n      AddStmt(E->getIndexExpr(Node.getArrayExprIndex()));\n      break;\n    case OffsetOfNode::Field:\n      AddMemberRef(Node.getField(), Node.getSourceRange().getEnd());\n      break;\n    case OffsetOfNode::Identifier:\n    case OffsetOfNode::Base:\n      continue;\n    }\n  }\n  // Visit the type into which we're computing the offset.\n  AddTypeLoc(E->getTypeSourceInfo());\n}\nvoid EnqueueVisitor::VisitOverloadExpr(const OverloadExpr *E) {\n  if (E->hasExplicitTemplateArgs())\n    AddExplicitTemplateArgs(E->getTemplateArgs(), E->getNumTemplateArgs());\n  WL.push_back(OverloadExprParts(E, Parent));\n}\nvoid EnqueueVisitor::VisitUnaryExprOrTypeTraitExpr(\n    const UnaryExprOrTypeTraitExpr *E) {\n  EnqueueChildren(E);\n  if (E->isArgumentType())\n    AddTypeLoc(E->getArgumentTypeInfo());\n}\nvoid EnqueueVisitor::VisitStmt(const Stmt *S) { EnqueueChildren(S); }\nvoid EnqueueVisitor::VisitSwitchStmt(const SwitchStmt *S) {\n  AddStmt(S->getBody());\n  AddStmt(S->getCond());\n  AddDecl(S->getConditionVariable());\n}\n\nvoid EnqueueVisitor::VisitWhileStmt(const WhileStmt *W) {\n  AddStmt(W->getBody());\n  AddStmt(W->getCond());\n  AddDecl(W->getConditionVariable());\n}\n\nvoid EnqueueVisitor::VisitTypeTraitExpr(const TypeTraitExpr *E) {\n  for (unsigned I = E->getNumArgs(); I > 0; --I)\n    AddTypeLoc(E->getArg(I - 1));\n}\n\nvoid EnqueueVisitor::VisitArrayTypeTraitExpr(const ArrayTypeTraitExpr *E) {\n  AddTypeLoc(E->getQueriedTypeSourceInfo());\n}\n\nvoid EnqueueVisitor::VisitExpressionTraitExpr(const ExpressionTraitExpr *E) {\n  EnqueueChildren(E);\n}\n\nvoid EnqueueVisitor::VisitUnresolvedMemberExpr(const UnresolvedMemberExpr *U) {\n  VisitOverloadExpr(U);\n  if (!U->isImplicitAccess())\n    AddStmt(U->getBase());\n}\nvoid EnqueueVisitor::VisitVAArgExpr(const VAArgExpr *E) {\n  AddStmt(E->getSubExpr());\n  AddTypeLoc(E->getWrittenTypeInfo());\n}\nvoid EnqueueVisitor::VisitSizeOfPackExpr(const SizeOfPackExpr *E) {\n  WL.push_back(SizeOfPackExprParts(E, Parent));\n}\nvoid EnqueueVisitor::VisitOpaqueValueExpr(const OpaqueValueExpr *E) {\n  // If the opaque value has a source expression, just transparently\n  // visit that.  This is useful for (e.g.) pseudo-object expressions.\n  if (Expr *SourceExpr = E->getSourceExpr())\n    return Visit(SourceExpr);\n}\nvoid EnqueueVisitor::VisitLambdaExpr(const LambdaExpr *E) {\n  AddStmt(E->getBody());\n  WL.push_back(LambdaExprParts(E, Parent));\n}\nvoid EnqueueVisitor::VisitPseudoObjectExpr(const PseudoObjectExpr *E) {\n  // Treat the expression like its syntactic form.\n  Visit(E->getSyntacticForm());\n}\n\nvoid EnqueueVisitor::VisitOMPExecutableDirective(\n    const OMPExecutableDirective *D) {\n  EnqueueChildren(D);\n  for (ArrayRef<OMPClause *>::iterator I = D->clauses().begin(),\n                                       E = D->clauses().end();\n       I != E; ++I)\n    EnqueueChildren(*I);\n}\n\nvoid EnqueueVisitor::VisitOMPLoopBasedDirective(\n    const OMPLoopBasedDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPLoopDirective(const OMPLoopDirective *D) {\n  VisitOMPLoopBasedDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPParallelDirective(const OMPParallelDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPSimdDirective(const OMPSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTileDirective(const OMPTileDirective *D) {\n  VisitOMPLoopBasedDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPForDirective(const OMPForDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPForSimdDirective(const OMPForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPSectionsDirective(const OMPSectionsDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPSectionDirective(const OMPSectionDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPSingleDirective(const OMPSingleDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPMasterDirective(const OMPMasterDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPCriticalDirective(const OMPCriticalDirective *D) {\n  VisitOMPExecutableDirective(D);\n  AddDeclarationNameInfo(D);\n}\n\nvoid EnqueueVisitor::VisitOMPParallelForDirective(\n    const OMPParallelForDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPParallelForSimdDirective(\n    const OMPParallelForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPParallelMasterDirective(\n    const OMPParallelMasterDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPParallelSectionsDirective(\n    const OMPParallelSectionsDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTaskDirective(const OMPTaskDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTaskyieldDirective(\n    const OMPTaskyieldDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPBarrierDirective(const OMPBarrierDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTaskwaitDirective(const OMPTaskwaitDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTaskgroupDirective(\n    const OMPTaskgroupDirective *D) {\n  VisitOMPExecutableDirective(D);\n  if (const Expr *E = D->getReductionRef())\n    VisitStmt(E);\n}\n\nvoid EnqueueVisitor::VisitOMPFlushDirective(const OMPFlushDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPDepobjDirective(const OMPDepobjDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPScanDirective(const OMPScanDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPOrderedDirective(const OMPOrderedDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPAtomicDirective(const OMPAtomicDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetDirective(const OMPTargetDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetDataDirective(\n    const OMPTargetDataDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetEnterDataDirective(\n    const OMPTargetEnterDataDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetExitDataDirective(\n    const OMPTargetExitDataDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetParallelDirective(\n    const OMPTargetParallelDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetParallelForDirective(\n    const OMPTargetParallelForDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTeamsDirective(const OMPTeamsDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPCancellationPointDirective(\n    const OMPCancellationPointDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPCancelDirective(const OMPCancelDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTaskLoopDirective(const OMPTaskLoopDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTaskLoopSimdDirective(\n    const OMPTaskLoopSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPMasterTaskLoopDirective(\n    const OMPMasterTaskLoopDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPMasterTaskLoopSimdDirective(\n    const OMPMasterTaskLoopSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPParallelMasterTaskLoopDirective(\n    const OMPParallelMasterTaskLoopDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPParallelMasterTaskLoopSimdDirective(\n    const OMPParallelMasterTaskLoopSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPDistributeDirective(\n    const OMPDistributeDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPDistributeParallelForDirective(\n    const OMPDistributeParallelForDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPDistributeParallelForSimdDirective(\n    const OMPDistributeParallelForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPDistributeSimdDirective(\n    const OMPDistributeSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetParallelForSimdDirective(\n    const OMPTargetParallelForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetSimdDirective(\n    const OMPTargetSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTeamsDistributeDirective(\n    const OMPTeamsDistributeDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTeamsDistributeSimdDirective(\n    const OMPTeamsDistributeSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTeamsDistributeParallelForSimdDirective(\n    const OMPTeamsDistributeParallelForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTeamsDistributeParallelForDirective(\n    const OMPTeamsDistributeParallelForDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetTeamsDirective(\n    const OMPTargetTeamsDirective *D) {\n  VisitOMPExecutableDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetTeamsDistributeDirective(\n    const OMPTargetTeamsDistributeDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetTeamsDistributeParallelForDirective(\n    const OMPTargetTeamsDistributeParallelForDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetTeamsDistributeParallelForSimdDirective(\n    const OMPTargetTeamsDistributeParallelForSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid EnqueueVisitor::VisitOMPTargetTeamsDistributeSimdDirective(\n    const OMPTargetTeamsDistributeSimdDirective *D) {\n  VisitOMPLoopDirective(D);\n}\n\nvoid CursorVisitor::EnqueueWorkList(VisitorWorkList &WL, const Stmt *S) {\n  EnqueueVisitor(WL, MakeCXCursor(S, StmtParent, TU, RegionOfInterest))\n      .Visit(S);\n}\n\nbool CursorVisitor::IsInRegionOfInterest(CXCursor C) {\n  if (RegionOfInterest.isValid()) {\n    SourceRange Range = getRawCursorExtent(C);\n    if (Range.isInvalid() || CompareRegionOfInterest(Range))\n      return false;\n  }\n  return true;\n}\n\nbool CursorVisitor::RunVisitorWorkList(VisitorWorkList &WL) {\n  while (!WL.empty()) {\n    // Dequeue the worklist item.\n    VisitorJob LI = WL.pop_back_val();\n\n    // Set the Parent field, then back to its old value once we're done.\n    SetParentRAII SetParent(Parent, StmtParent, LI.getParent());\n\n    switch (LI.getKind()) {\n    case VisitorJob::DeclVisitKind: {\n      const Decl *D = cast<DeclVisit>(&LI)->get();\n      if (!D)\n        continue;\n\n      // For now, perform default visitation for Decls.\n      if (Visit(MakeCXCursor(D, TU, RegionOfInterest,\n                             cast<DeclVisit>(&LI)->isFirst())))\n        return true;\n\n      continue;\n    }\n    case VisitorJob::ExplicitTemplateArgsVisitKind: {\n      for (const TemplateArgumentLoc &Arg :\n           *cast<ExplicitTemplateArgsVisit>(&LI)) {\n        if (VisitTemplateArgumentLoc(Arg))\n          return true;\n      }\n      continue;\n    }\n    case VisitorJob::TypeLocVisitKind: {\n      // Perform default visitation for TypeLocs.\n      if (Visit(cast<TypeLocVisit>(&LI)->get()))\n        return true;\n      continue;\n    }\n    case VisitorJob::LabelRefVisitKind: {\n      const LabelDecl *LS = cast<LabelRefVisit>(&LI)->get();\n      if (LabelStmt *stmt = LS->getStmt()) {\n        if (Visit(MakeCursorLabelRef(stmt, cast<LabelRefVisit>(&LI)->getLoc(),\n                                     TU))) {\n          return true;\n        }\n      }\n      continue;\n    }\n\n    case VisitorJob::NestedNameSpecifierLocVisitKind: {\n      NestedNameSpecifierLocVisit *V = cast<NestedNameSpecifierLocVisit>(&LI);\n      if (VisitNestedNameSpecifierLoc(V->get()))\n        return true;\n      continue;\n    }\n\n    case VisitorJob::DeclarationNameInfoVisitKind: {\n      if (VisitDeclarationNameInfo(cast<DeclarationNameInfoVisit>(&LI)->get()))\n        return true;\n      continue;\n    }\n    case VisitorJob::MemberRefVisitKind: {\n      MemberRefVisit *V = cast<MemberRefVisit>(&LI);\n      if (Visit(MakeCursorMemberRef(V->get(), V->getLoc(), TU)))\n        return true;\n      continue;\n    }\n    case VisitorJob::StmtVisitKind: {\n      const Stmt *S = cast<StmtVisit>(&LI)->get();\n      if (!S)\n        continue;\n\n      // Update the current cursor.\n      CXCursor Cursor = MakeCXCursor(S, StmtParent, TU, RegionOfInterest);\n      if (!IsInRegionOfInterest(Cursor))\n        continue;\n      switch (Visitor(Cursor, Parent, ClientData)) {\n      case CXChildVisit_Break:\n        return true;\n      case CXChildVisit_Continue:\n        break;\n      case CXChildVisit_Recurse:\n        if (PostChildrenVisitor)\n          WL.push_back(PostChildrenVisit(nullptr, Cursor));\n        EnqueueWorkList(WL, S);\n        break;\n      }\n      continue;\n    }\n    case VisitorJob::MemberExprPartsKind: {\n      // Handle the other pieces in the MemberExpr besides the base.\n      const MemberExpr *M = cast<MemberExprParts>(&LI)->get();\n\n      // Visit the nested-name-specifier\n      if (NestedNameSpecifierLoc QualifierLoc = M->getQualifierLoc())\n        if (VisitNestedNameSpecifierLoc(QualifierLoc))\n          return true;\n\n      // Visit the declaration name.\n      if (VisitDeclarationNameInfo(M->getMemberNameInfo()))\n        return true;\n\n      // Visit the explicitly-specified template arguments, if any.\n      if (M->hasExplicitTemplateArgs()) {\n        for (const TemplateArgumentLoc *Arg = M->getTemplateArgs(),\n                                       *ArgEnd = Arg + M->getNumTemplateArgs();\n             Arg != ArgEnd; ++Arg) {\n          if (VisitTemplateArgumentLoc(*Arg))\n            return true;\n        }\n      }\n      continue;\n    }\n    case VisitorJob::DeclRefExprPartsKind: {\n      const DeclRefExpr *DR = cast<DeclRefExprParts>(&LI)->get();\n      // Visit nested-name-specifier, if present.\n      if (NestedNameSpecifierLoc QualifierLoc = DR->getQualifierLoc())\n        if (VisitNestedNameSpecifierLoc(QualifierLoc))\n          return true;\n      // Visit declaration name.\n      if (VisitDeclarationNameInfo(DR->getNameInfo()))\n        return true;\n      continue;\n    }\n    case VisitorJob::OverloadExprPartsKind: {\n      const OverloadExpr *O = cast<OverloadExprParts>(&LI)->get();\n      // Visit the nested-name-specifier.\n      if (NestedNameSpecifierLoc QualifierLoc = O->getQualifierLoc())\n        if (VisitNestedNameSpecifierLoc(QualifierLoc))\n          return true;\n      // Visit the declaration name.\n      if (VisitDeclarationNameInfo(O->getNameInfo()))\n        return true;\n      // Visit the overloaded declaration reference.\n      if (Visit(MakeCursorOverloadedDeclRef(O, TU)))\n        return true;\n      continue;\n    }\n    case VisitorJob::SizeOfPackExprPartsKind: {\n      const SizeOfPackExpr *E = cast<SizeOfPackExprParts>(&LI)->get();\n      NamedDecl *Pack = E->getPack();\n      if (isa<TemplateTypeParmDecl>(Pack)) {\n        if (Visit(MakeCursorTypeRef(cast<TemplateTypeParmDecl>(Pack),\n                                    E->getPackLoc(), TU)))\n          return true;\n\n        continue;\n      }\n\n      if (isa<TemplateTemplateParmDecl>(Pack)) {\n        if (Visit(MakeCursorTemplateRef(cast<TemplateTemplateParmDecl>(Pack),\n                                        E->getPackLoc(), TU)))\n          return true;\n\n        continue;\n      }\n\n      // Non-type template parameter packs and function parameter packs are\n      // treated like DeclRefExpr cursors.\n      continue;\n    }\n\n    case VisitorJob::LambdaExprPartsKind: {\n      // Visit non-init captures.\n      const LambdaExpr *E = cast<LambdaExprParts>(&LI)->get();\n      for (LambdaExpr::capture_iterator C = E->explicit_capture_begin(),\n                                        CEnd = E->explicit_capture_end();\n           C != CEnd; ++C) {\n        if (!C->capturesVariable())\n          continue;\n\n        if (Visit(MakeCursorVariableRef(C->getCapturedVar(), C->getLocation(),\n                                        TU)))\n          return true;\n      }\n      // Visit init captures\n      for (auto InitExpr : E->capture_inits()) {\n        if (InitExpr && Visit(InitExpr))\n          return true;\n      }\n\n      TypeLoc TL = E->getCallOperator()->getTypeSourceInfo()->getTypeLoc();\n      // Visit parameters and return type, if present.\n      if (FunctionTypeLoc Proto = TL.getAs<FunctionProtoTypeLoc>()) {\n        if (E->hasExplicitParameters()) {\n          // Visit parameters.\n          for (unsigned I = 0, N = Proto.getNumParams(); I != N; ++I)\n            if (Visit(MakeCXCursor(Proto.getParam(I), TU)))\n              return true;\n        }\n        if (E->hasExplicitResultType()) {\n          // Visit result type.\n          if (Visit(Proto.getReturnLoc()))\n            return true;\n        }\n      }\n      break;\n    }\n\n    case VisitorJob::PostChildrenVisitKind:\n      if (PostChildrenVisitor(Parent, ClientData))\n        return true;\n      break;\n    }\n  }\n  return false;\n}\n\nbool CursorVisitor::Visit(const Stmt *S) {\n  VisitorWorkList *WL = nullptr;\n  if (!WorkListFreeList.empty()) {\n    WL = WorkListFreeList.back();\n    WL->clear();\n    WorkListFreeList.pop_back();\n  } else {\n    WL = new VisitorWorkList();\n    WorkListCache.push_back(WL);\n  }\n  EnqueueWorkList(*WL, S);\n  bool result = RunVisitorWorkList(*WL);\n  WorkListFreeList.push_back(WL);\n  return result;\n}\n\nnamespace {\ntypedef SmallVector<SourceRange, 4> RefNamePieces;\nRefNamePieces buildPieces(unsigned NameFlags, bool IsMemberRefExpr,\n                          const DeclarationNameInfo &NI, SourceRange QLoc,\n                          const SourceRange *TemplateArgsLoc = nullptr) {\n  const bool WantQualifier = NameFlags & CXNameRange_WantQualifier;\n  const bool WantTemplateArgs = NameFlags & CXNameRange_WantTemplateArgs;\n  const bool WantSinglePiece = NameFlags & CXNameRange_WantSinglePiece;\n\n  const DeclarationName::NameKind Kind = NI.getName().getNameKind();\n\n  RefNamePieces Pieces;\n\n  if (WantQualifier && QLoc.isValid())\n    Pieces.push_back(QLoc);\n\n  if (Kind != DeclarationName::CXXOperatorName || IsMemberRefExpr)\n    Pieces.push_back(NI.getLoc());\n\n  if (WantTemplateArgs && TemplateArgsLoc && TemplateArgsLoc->isValid())\n    Pieces.push_back(*TemplateArgsLoc);\n\n  if (Kind == DeclarationName::CXXOperatorName) {\n    Pieces.push_back(NI.getInfo().getCXXOperatorNameBeginLoc());\n    Pieces.push_back(NI.getInfo().getCXXOperatorNameEndLoc());\n  }\n\n  if (WantSinglePiece) {\n    SourceRange R(Pieces.front().getBegin(), Pieces.back().getEnd());\n    Pieces.clear();\n    Pieces.push_back(R);\n  }\n\n  return Pieces;\n}\n} // namespace\n\n//===----------------------------------------------------------------------===//\n// Misc. API hooks.\n//===----------------------------------------------------------------------===//\n\nnamespace {\nstruct RegisterFatalErrorHandler {\n  RegisterFatalErrorHandler() {\n    clang_install_aborting_llvm_fatal_error_handler();\n  }\n};\n} // namespace\n\nstatic llvm::ManagedStatic<RegisterFatalErrorHandler>\n    RegisterFatalErrorHandlerOnce;\n\nCXIndex clang_createIndex(int excludeDeclarationsFromPCH,\n                          int displayDiagnostics) {\n  // We use crash recovery to make some of our APIs more reliable, implicitly\n  // enable it.\n  if (!getenv(\"LIBCLANG_DISABLE_CRASH_RECOVERY\"))\n    llvm::CrashRecoveryContext::Enable();\n\n  // Look through the managed static to trigger construction of the managed\n  // static which registers our fatal error handler. This ensures it is only\n  // registered once.\n  (void)*RegisterFatalErrorHandlerOnce;\n\n  // Initialize targets for clang module support.\n  llvm::InitializeAllTargets();\n  llvm::InitializeAllTargetMCs();\n  llvm::InitializeAllAsmPrinters();\n  llvm::InitializeAllAsmParsers();\n\n  CIndexer *CIdxr = new CIndexer();\n\n  if (excludeDeclarationsFromPCH)\n    CIdxr->setOnlyLocalDecls();\n  if (displayDiagnostics)\n    CIdxr->setDisplayDiagnostics();\n\n  if (getenv(\"LIBCLANG_BGPRIO_INDEX\"))\n    CIdxr->setCXGlobalOptFlags(CIdxr->getCXGlobalOptFlags() |\n                               CXGlobalOpt_ThreadBackgroundPriorityForIndexing);\n  if (getenv(\"LIBCLANG_BGPRIO_EDIT\"))\n    CIdxr->setCXGlobalOptFlags(CIdxr->getCXGlobalOptFlags() |\n                               CXGlobalOpt_ThreadBackgroundPriorityForEditing);\n\n  return CIdxr;\n}\n\nvoid clang_disposeIndex(CXIndex CIdx) {\n  if (CIdx)\n    delete static_cast<CIndexer *>(CIdx);\n}\n\nvoid clang_CXIndex_setGlobalOptions(CXIndex CIdx, unsigned options) {\n  if (CIdx)\n    static_cast<CIndexer *>(CIdx)->setCXGlobalOptFlags(options);\n}\n\nunsigned clang_CXIndex_getGlobalOptions(CXIndex CIdx) {\n  if (CIdx)\n    return static_cast<CIndexer *>(CIdx)->getCXGlobalOptFlags();\n  return 0;\n}\n\nvoid clang_CXIndex_setInvocationEmissionPathOption(CXIndex CIdx,\n                                                   const char *Path) {\n  if (CIdx)\n    static_cast<CIndexer *>(CIdx)->setInvocationEmissionPath(Path ? Path : \"\");\n}\n\nvoid clang_toggleCrashRecovery(unsigned isEnabled) {\n  if (isEnabled)\n    llvm::CrashRecoveryContext::Enable();\n  else\n    llvm::CrashRecoveryContext::Disable();\n}\n\nCXTranslationUnit clang_createTranslationUnit(CXIndex CIdx,\n                                              const char *ast_filename) {\n  CXTranslationUnit TU;\n  enum CXErrorCode Result =\n      clang_createTranslationUnit2(CIdx, ast_filename, &TU);\n  (void)Result;\n  assert((TU && Result == CXError_Success) ||\n         (!TU && Result != CXError_Success));\n  return TU;\n}\n\nenum CXErrorCode clang_createTranslationUnit2(CXIndex CIdx,\n                                              const char *ast_filename,\n                                              CXTranslationUnit *out_TU) {\n  if (out_TU)\n    *out_TU = nullptr;\n\n  if (!CIdx || !ast_filename || !out_TU)\n    return CXError_InvalidArguments;\n\n  LOG_FUNC_SECTION { *Log << ast_filename; }\n\n  CIndexer *CXXIdx = static_cast<CIndexer *>(CIdx);\n  FileSystemOptions FileSystemOpts;\n\n  IntrusiveRefCntPtr<DiagnosticsEngine> Diags =\n      CompilerInstance::createDiagnostics(new DiagnosticOptions());\n  std::unique_ptr<ASTUnit> AU = ASTUnit::LoadFromASTFile(\n      ast_filename, CXXIdx->getPCHContainerOperations()->getRawReader(),\n      ASTUnit::LoadEverything, Diags, FileSystemOpts, /*UseDebugInfo=*/false,\n      CXXIdx->getOnlyLocalDecls(), CaptureDiagsKind::All,\n      /*AllowASTWithCompilerErrors=*/true,\n      /*UserFilesAreVolatile=*/true);\n  *out_TU = MakeCXTranslationUnit(CXXIdx, std::move(AU));\n  return *out_TU ? CXError_Success : CXError_Failure;\n}\n\nunsigned clang_defaultEditingTranslationUnitOptions() {\n  return CXTranslationUnit_PrecompiledPreamble |\n         CXTranslationUnit_CacheCompletionResults;\n}\n\nCXTranslationUnit clang_createTranslationUnitFromSourceFile(\n    CXIndex CIdx, const char *source_filename, int num_command_line_args,\n    const char *const *command_line_args, unsigned num_unsaved_files,\n    struct CXUnsavedFile *unsaved_files) {\n  unsigned Options = CXTranslationUnit_DetailedPreprocessingRecord;\n  return clang_parseTranslationUnit(CIdx, source_filename, command_line_args,\n                                    num_command_line_args, unsaved_files,\n                                    num_unsaved_files, Options);\n}\n\nstatic CXErrorCode\nclang_parseTranslationUnit_Impl(CXIndex CIdx, const char *source_filename,\n                                const char *const *command_line_args,\n                                int num_command_line_args,\n                                ArrayRef<CXUnsavedFile> unsaved_files,\n                                unsigned options, CXTranslationUnit *out_TU) {\n  // Set up the initial return values.\n  if (out_TU)\n    *out_TU = nullptr;\n\n  // Check arguments.\n  if (!CIdx || !out_TU)\n    return CXError_InvalidArguments;\n\n  CIndexer *CXXIdx = static_cast<CIndexer *>(CIdx);\n\n  if (CXXIdx->isOptEnabled(CXGlobalOpt_ThreadBackgroundPriorityForIndexing))\n    setThreadBackgroundPriority();\n\n  bool PrecompilePreamble = options & CXTranslationUnit_PrecompiledPreamble;\n  bool CreatePreambleOnFirstParse =\n      options & CXTranslationUnit_CreatePreambleOnFirstParse;\n  // FIXME: Add a flag for modules.\n  TranslationUnitKind TUKind = (options & (CXTranslationUnit_Incomplete |\n                                           CXTranslationUnit_SingleFileParse))\n                                   ? TU_Prefix\n                                   : TU_Complete;\n  bool CacheCodeCompletionResults =\n      options & CXTranslationUnit_CacheCompletionResults;\n  bool IncludeBriefCommentsInCodeCompletion =\n      options & CXTranslationUnit_IncludeBriefCommentsInCodeCompletion;\n  bool SingleFileParse = options & CXTranslationUnit_SingleFileParse;\n  bool ForSerialization = options & CXTranslationUnit_ForSerialization;\n  bool RetainExcludedCB =\n      options & CXTranslationUnit_RetainExcludedConditionalBlocks;\n  SkipFunctionBodiesScope SkipFunctionBodies = SkipFunctionBodiesScope::None;\n  if (options & CXTranslationUnit_SkipFunctionBodies) {\n    SkipFunctionBodies =\n        (options & CXTranslationUnit_LimitSkipFunctionBodiesToPreamble)\n            ? SkipFunctionBodiesScope::Preamble\n            : SkipFunctionBodiesScope::PreambleAndMainFile;\n  }\n\n  // Configure the diagnostics.\n  IntrusiveRefCntPtr<DiagnosticsEngine> Diags(\n      CompilerInstance::createDiagnostics(new DiagnosticOptions));\n\n  if (options & CXTranslationUnit_KeepGoing)\n    Diags->setFatalsAsError(true);\n\n  CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::All;\n  if (options & CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles)\n    CaptureDiagnostics = CaptureDiagsKind::AllWithoutNonErrorsFromIncludes;\n\n  // Recover resources if we crash before exiting this function.\n  llvm::CrashRecoveryContextCleanupRegistrar<\n      DiagnosticsEngine,\n      llvm::CrashRecoveryContextReleaseRefCleanup<DiagnosticsEngine>>\n      DiagCleanup(Diags.get());\n\n  std::unique_ptr<std::vector<ASTUnit::RemappedFile>> RemappedFiles(\n      new std::vector<ASTUnit::RemappedFile>());\n\n  // Recover resources if we crash before exiting this function.\n  llvm::CrashRecoveryContextCleanupRegistrar<std::vector<ASTUnit::RemappedFile>>\n      RemappedCleanup(RemappedFiles.get());\n\n  for (auto &UF : unsaved_files) {\n    std::unique_ptr<llvm::MemoryBuffer> MB =\n        llvm::MemoryBuffer::getMemBufferCopy(getContents(UF), UF.Filename);\n    RemappedFiles->push_back(std::make_pair(UF.Filename, MB.release()));\n  }\n\n  std::unique_ptr<std::vector<const char *>> Args(\n      new std::vector<const char *>());\n\n  // Recover resources if we crash before exiting this method.\n  llvm::CrashRecoveryContextCleanupRegistrar<std::vector<const char *>>\n      ArgsCleanup(Args.get());\n\n  // Since the Clang C library is primarily used by batch tools dealing with\n  // (often very broken) source code, where spell-checking can have a\n  // significant negative impact on performance (particularly when\n  // precompiled headers are involved), we disable it by default.\n  // Only do this if we haven't found a spell-checking-related argument.\n  bool FoundSpellCheckingArgument = false;\n  for (int I = 0; I != num_command_line_args; ++I) {\n    if (strcmp(command_line_args[I], \"-fno-spell-checking\") == 0 ||\n        strcmp(command_line_args[I], \"-fspell-checking\") == 0) {\n      FoundSpellCheckingArgument = true;\n      break;\n    }\n  }\n  Args->insert(Args->end(), command_line_args,\n               command_line_args + num_command_line_args);\n\n  if (!FoundSpellCheckingArgument)\n    Args->insert(Args->begin() + 1, \"-fno-spell-checking\");\n\n  // The 'source_filename' argument is optional.  If the caller does not\n  // specify it then it is assumed that the source file is specified\n  // in the actual argument list.\n  // Put the source file after command_line_args otherwise if '-x' flag is\n  // present it will be unused.\n  if (source_filename)\n    Args->push_back(source_filename);\n\n  // Do we need the detailed preprocessing record?\n  if (options & CXTranslationUnit_DetailedPreprocessingRecord) {\n    Args->push_back(\"-Xclang\");\n    Args->push_back(\"-detailed-preprocessing-record\");\n  }\n\n  // Suppress any editor placeholder diagnostics.\n  Args->push_back(\"-fallow-editor-placeholders\");\n\n  unsigned NumErrors = Diags->getClient()->getNumErrors();\n  std::unique_ptr<ASTUnit> ErrUnit;\n  // Unless the user specified that they want the preamble on the first parse\n  // set it up to be created on the first reparse. This makes the first parse\n  // faster, trading for a slower (first) reparse.\n  unsigned PrecompilePreambleAfterNParses =\n      !PrecompilePreamble ? 0 : 2 - CreatePreambleOnFirstParse;\n\n  LibclangInvocationReporter InvocationReporter(\n      *CXXIdx, LibclangInvocationReporter::OperationKind::ParseOperation,\n      options, llvm::makeArrayRef(*Args), /*InvocationArgs=*/None,\n      unsaved_files);\n  std::unique_ptr<ASTUnit> Unit(ASTUnit::LoadFromCommandLine(\n      Args->data(), Args->data() + Args->size(),\n      CXXIdx->getPCHContainerOperations(), Diags,\n      CXXIdx->getClangResourcesPath(), CXXIdx->getOnlyLocalDecls(),\n      CaptureDiagnostics, *RemappedFiles.get(),\n      /*RemappedFilesKeepOriginalName=*/true, PrecompilePreambleAfterNParses,\n      TUKind, CacheCodeCompletionResults, IncludeBriefCommentsInCodeCompletion,\n      /*AllowPCHWithCompilerErrors=*/true, SkipFunctionBodies, SingleFileParse,\n      /*UserFilesAreVolatile=*/true, ForSerialization, RetainExcludedCB,\n      CXXIdx->getPCHContainerOperations()->getRawReader().getFormat(),\n      &ErrUnit));\n\n  // Early failures in LoadFromCommandLine may return with ErrUnit unset.\n  if (!Unit && !ErrUnit)\n    return CXError_ASTReadError;\n\n  if (NumErrors != Diags->getClient()->getNumErrors()) {\n    // Make sure to check that 'Unit' is non-NULL.\n    if (CXXIdx->getDisplayDiagnostics())\n      printDiagsToStderr(Unit ? Unit.get() : ErrUnit.get());\n  }\n\n  if (isASTReadError(Unit ? Unit.get() : ErrUnit.get()))\n    return CXError_ASTReadError;\n\n  *out_TU = MakeCXTranslationUnit(CXXIdx, std::move(Unit));\n  if (CXTranslationUnitImpl *TU = *out_TU) {\n    TU->ParsingOptions = options;\n    TU->Arguments.reserve(Args->size());\n    for (const char *Arg : *Args)\n      TU->Arguments.push_back(Arg);\n    return CXError_Success;\n  }\n  return CXError_Failure;\n}\n\nCXTranslationUnit\nclang_parseTranslationUnit(CXIndex CIdx, const char *source_filename,\n                           const char *const *command_line_args,\n                           int num_command_line_args,\n                           struct CXUnsavedFile *unsaved_files,\n                           unsigned num_unsaved_files, unsigned options) {\n  CXTranslationUnit TU;\n  enum CXErrorCode Result = clang_parseTranslationUnit2(\n      CIdx, source_filename, command_line_args, num_command_line_args,\n      unsaved_files, num_unsaved_files, options, &TU);\n  (void)Result;\n  assert((TU && Result == CXError_Success) ||\n         (!TU && Result != CXError_Success));\n  return TU;\n}\n\nenum CXErrorCode clang_parseTranslationUnit2(\n    CXIndex CIdx, const char *source_filename,\n    const char *const *command_line_args, int num_command_line_args,\n    struct CXUnsavedFile *unsaved_files, unsigned num_unsaved_files,\n    unsigned options, CXTranslationUnit *out_TU) {\n  noteBottomOfStack();\n  SmallVector<const char *, 4> Args;\n  Args.push_back(\"clang\");\n  Args.append(command_line_args, command_line_args + num_command_line_args);\n  return clang_parseTranslationUnit2FullArgv(\n      CIdx, source_filename, Args.data(), Args.size(), unsaved_files,\n      num_unsaved_files, options, out_TU);\n}\n\nenum CXErrorCode clang_parseTranslationUnit2FullArgv(\n    CXIndex CIdx, const char *source_filename,\n    const char *const *command_line_args, int num_command_line_args,\n    struct CXUnsavedFile *unsaved_files, unsigned num_unsaved_files,\n    unsigned options, CXTranslationUnit *out_TU) {\n  LOG_FUNC_SECTION {\n    *Log << source_filename << \": \";\n    for (int i = 0; i != num_command_line_args; ++i)\n      *Log << command_line_args[i] << \" \";\n  }\n\n  if (num_unsaved_files && !unsaved_files)\n    return CXError_InvalidArguments;\n\n  CXErrorCode result = CXError_Failure;\n  auto ParseTranslationUnitImpl = [=, &result] {\n    noteBottomOfStack();\n    result = clang_parseTranslationUnit_Impl(\n        CIdx, source_filename, command_line_args, num_command_line_args,\n        llvm::makeArrayRef(unsaved_files, num_unsaved_files), options, out_TU);\n  };\n\n  llvm::CrashRecoveryContext CRC;\n\n  if (!RunSafely(CRC, ParseTranslationUnitImpl)) {\n    fprintf(stderr, \"libclang: crash detected during parsing: {\\n\");\n    fprintf(stderr, \"  'source_filename' : '%s'\\n\", source_filename);\n    fprintf(stderr, \"  'command_line_args' : [\");\n    for (int i = 0; i != num_command_line_args; ++i) {\n      if (i)\n        fprintf(stderr, \", \");\n      fprintf(stderr, \"'%s'\", command_line_args[i]);\n    }\n    fprintf(stderr, \"],\\n\");\n    fprintf(stderr, \"  'unsaved_files' : [\");\n    for (unsigned i = 0; i != num_unsaved_files; ++i) {\n      if (i)\n        fprintf(stderr, \", \");\n      fprintf(stderr, \"('%s', '...', %ld)\", unsaved_files[i].Filename,\n              unsaved_files[i].Length);\n    }\n    fprintf(stderr, \"],\\n\");\n    fprintf(stderr, \"  'options' : %d,\\n\", options);\n    fprintf(stderr, \"}\\n\");\n\n    return CXError_Crashed;\n  } else if (getenv(\"LIBCLANG_RESOURCE_USAGE\")) {\n    if (CXTranslationUnit *TU = out_TU)\n      PrintLibclangResourceUsage(*TU);\n  }\n\n  return result;\n}\n\nCXString clang_Type_getObjCEncoding(CXType CT) {\n  CXTranslationUnit tu = static_cast<CXTranslationUnit>(CT.data[1]);\n  ASTContext &Ctx = getASTUnit(tu)->getASTContext();\n  std::string encoding;\n  Ctx.getObjCEncodingForType(QualType::getFromOpaquePtr(CT.data[0]), encoding);\n\n  return cxstring::createDup(encoding);\n}\n\nstatic const IdentifierInfo *getMacroIdentifier(CXCursor C) {\n  if (C.kind == CXCursor_MacroDefinition) {\n    if (const MacroDefinitionRecord *MDR = getCursorMacroDefinition(C))\n      return MDR->getName();\n  } else if (C.kind == CXCursor_MacroExpansion) {\n    MacroExpansionCursor ME = getCursorMacroExpansion(C);\n    return ME.getName();\n  }\n  return nullptr;\n}\n\nunsigned clang_Cursor_isMacroFunctionLike(CXCursor C) {\n  const IdentifierInfo *II = getMacroIdentifier(C);\n  if (!II) {\n    return false;\n  }\n  ASTUnit *ASTU = getCursorASTUnit(C);\n  Preprocessor &PP = ASTU->getPreprocessor();\n  if (const MacroInfo *MI = PP.getMacroInfo(II))\n    return MI->isFunctionLike();\n  return false;\n}\n\nunsigned clang_Cursor_isMacroBuiltin(CXCursor C) {\n  const IdentifierInfo *II = getMacroIdentifier(C);\n  if (!II) {\n    return false;\n  }\n  ASTUnit *ASTU = getCursorASTUnit(C);\n  Preprocessor &PP = ASTU->getPreprocessor();\n  if (const MacroInfo *MI = PP.getMacroInfo(II))\n    return MI->isBuiltinMacro();\n  return false;\n}\n\nunsigned clang_Cursor_isFunctionInlined(CXCursor C) {\n  const Decl *D = getCursorDecl(C);\n  const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D);\n  if (!FD) {\n    return false;\n  }\n  return FD->isInlined();\n}\n\nstatic StringLiteral *getCFSTR_value(CallExpr *callExpr) {\n  if (callExpr->getNumArgs() != 1) {\n    return nullptr;\n  }\n\n  StringLiteral *S = nullptr;\n  auto *arg = callExpr->getArg(0);\n  if (arg->getStmtClass() == Stmt::ImplicitCastExprClass) {\n    ImplicitCastExpr *I = static_cast<ImplicitCastExpr *>(arg);\n    auto *subExpr = I->getSubExprAsWritten();\n\n    if (subExpr->getStmtClass() != Stmt::StringLiteralClass) {\n      return nullptr;\n    }\n\n    S = static_cast<StringLiteral *>(I->getSubExprAsWritten());\n  } else if (arg->getStmtClass() == Stmt::StringLiteralClass) {\n    S = static_cast<StringLiteral *>(callExpr->getArg(0));\n  } else {\n    return nullptr;\n  }\n  return S;\n}\n\nstruct ExprEvalResult {\n  CXEvalResultKind EvalType;\n  union {\n    unsigned long long unsignedVal;\n    long long intVal;\n    double floatVal;\n    char *stringVal;\n  } EvalData;\n  bool IsUnsignedInt;\n  ~ExprEvalResult() {\n    if (EvalType != CXEval_UnExposed && EvalType != CXEval_Float &&\n        EvalType != CXEval_Int) {\n      delete[] EvalData.stringVal;\n    }\n  }\n};\n\nvoid clang_EvalResult_dispose(CXEvalResult E) {\n  delete static_cast<ExprEvalResult *>(E);\n}\n\nCXEvalResultKind clang_EvalResult_getKind(CXEvalResult E) {\n  if (!E) {\n    return CXEval_UnExposed;\n  }\n  return ((ExprEvalResult *)E)->EvalType;\n}\n\nint clang_EvalResult_getAsInt(CXEvalResult E) {\n  return clang_EvalResult_getAsLongLong(E);\n}\n\nlong long clang_EvalResult_getAsLongLong(CXEvalResult E) {\n  if (!E) {\n    return 0;\n  }\n  ExprEvalResult *Result = (ExprEvalResult *)E;\n  if (Result->IsUnsignedInt)\n    return Result->EvalData.unsignedVal;\n  return Result->EvalData.intVal;\n}\n\nunsigned clang_EvalResult_isUnsignedInt(CXEvalResult E) {\n  return ((ExprEvalResult *)E)->IsUnsignedInt;\n}\n\nunsigned long long clang_EvalResult_getAsUnsigned(CXEvalResult E) {\n  if (!E) {\n    return 0;\n  }\n\n  ExprEvalResult *Result = (ExprEvalResult *)E;\n  if (Result->IsUnsignedInt)\n    return Result->EvalData.unsignedVal;\n  return Result->EvalData.intVal;\n}\n\ndouble clang_EvalResult_getAsDouble(CXEvalResult E) {\n  if (!E) {\n    return 0;\n  }\n  return ((ExprEvalResult *)E)->EvalData.floatVal;\n}\n\nconst char *clang_EvalResult_getAsStr(CXEvalResult E) {\n  if (!E) {\n    return nullptr;\n  }\n  return ((ExprEvalResult *)E)->EvalData.stringVal;\n}\n\nstatic const ExprEvalResult *evaluateExpr(Expr *expr, CXCursor C) {\n  Expr::EvalResult ER;\n  ASTContext &ctx = getCursorContext(C);\n  if (!expr)\n    return nullptr;\n\n  expr = expr->IgnoreParens();\n  if (expr->isValueDependent())\n    return nullptr;\n  if (!expr->EvaluateAsRValue(ER, ctx))\n    return nullptr;\n\n  QualType rettype;\n  CallExpr *callExpr;\n  auto result = std::make_unique<ExprEvalResult>();\n  result->EvalType = CXEval_UnExposed;\n  result->IsUnsignedInt = false;\n\n  if (ER.Val.isInt()) {\n    result->EvalType = CXEval_Int;\n\n    auto &val = ER.Val.getInt();\n    if (val.isUnsigned()) {\n      result->IsUnsignedInt = true;\n      result->EvalData.unsignedVal = val.getZExtValue();\n    } else {\n      result->EvalData.intVal = val.getExtValue();\n    }\n\n    return result.release();\n  }\n\n  if (ER.Val.isFloat()) {\n    llvm::SmallVector<char, 100> Buffer;\n    ER.Val.getFloat().toString(Buffer);\n    std::string floatStr(Buffer.data(), Buffer.size());\n    result->EvalType = CXEval_Float;\n    bool ignored;\n    llvm::APFloat apFloat = ER.Val.getFloat();\n    apFloat.convert(llvm::APFloat::IEEEdouble(),\n                    llvm::APFloat::rmNearestTiesToEven, &ignored);\n    result->EvalData.floatVal = apFloat.convertToDouble();\n    return result.release();\n  }\n\n  if (expr->getStmtClass() == Stmt::ImplicitCastExprClass) {\n    const ImplicitCastExpr *I = dyn_cast<ImplicitCastExpr>(expr);\n    auto *subExpr = I->getSubExprAsWritten();\n    if (subExpr->getStmtClass() == Stmt::StringLiteralClass ||\n        subExpr->getStmtClass() == Stmt::ObjCStringLiteralClass) {\n      const StringLiteral *StrE = nullptr;\n      const ObjCStringLiteral *ObjCExpr;\n      ObjCExpr = dyn_cast<ObjCStringLiteral>(subExpr);\n\n      if (ObjCExpr) {\n        StrE = ObjCExpr->getString();\n        result->EvalType = CXEval_ObjCStrLiteral;\n      } else {\n        StrE = cast<StringLiteral>(I->getSubExprAsWritten());\n        result->EvalType = CXEval_StrLiteral;\n      }\n\n      std::string strRef(StrE->getString().str());\n      result->EvalData.stringVal = new char[strRef.size() + 1];\n      strncpy((char *)result->EvalData.stringVal, strRef.c_str(),\n              strRef.size());\n      result->EvalData.stringVal[strRef.size()] = '\\0';\n      return result.release();\n    }\n  } else if (expr->getStmtClass() == Stmt::ObjCStringLiteralClass ||\n             expr->getStmtClass() == Stmt::StringLiteralClass) {\n    const StringLiteral *StrE = nullptr;\n    const ObjCStringLiteral *ObjCExpr;\n    ObjCExpr = dyn_cast<ObjCStringLiteral>(expr);\n\n    if (ObjCExpr) {\n      StrE = ObjCExpr->getString();\n      result->EvalType = CXEval_ObjCStrLiteral;\n    } else {\n      StrE = cast<StringLiteral>(expr);\n      result->EvalType = CXEval_StrLiteral;\n    }\n\n    std::string strRef(StrE->getString().str());\n    result->EvalData.stringVal = new char[strRef.size() + 1];\n    strncpy((char *)result->EvalData.stringVal, strRef.c_str(), strRef.size());\n    result->EvalData.stringVal[strRef.size()] = '\\0';\n    return result.release();\n  }\n\n  if (expr->getStmtClass() == Stmt::CStyleCastExprClass) {\n    CStyleCastExpr *CC = static_cast<CStyleCastExpr *>(expr);\n\n    rettype = CC->getType();\n    if (rettype.getAsString() == \"CFStringRef\" &&\n        CC->getSubExpr()->getStmtClass() == Stmt::CallExprClass) {\n\n      callExpr = static_cast<CallExpr *>(CC->getSubExpr());\n      StringLiteral *S = getCFSTR_value(callExpr);\n      if (S) {\n        std::string strLiteral(S->getString().str());\n        result->EvalType = CXEval_CFStr;\n\n        result->EvalData.stringVal = new char[strLiteral.size() + 1];\n        strncpy((char *)result->EvalData.stringVal, strLiteral.c_str(),\n                strLiteral.size());\n        result->EvalData.stringVal[strLiteral.size()] = '\\0';\n        return result.release();\n      }\n    }\n\n  } else if (expr->getStmtClass() == Stmt::CallExprClass) {\n    callExpr = static_cast<CallExpr *>(expr);\n    rettype = callExpr->getCallReturnType(ctx);\n\n    if (rettype->isVectorType() || callExpr->getNumArgs() > 1)\n      return nullptr;\n\n    if (rettype->isIntegralType(ctx) || rettype->isRealFloatingType()) {\n      if (callExpr->getNumArgs() == 1 &&\n          !callExpr->getArg(0)->getType()->isIntegralType(ctx))\n        return nullptr;\n    } else if (rettype.getAsString() == \"CFStringRef\") {\n\n      StringLiteral *S = getCFSTR_value(callExpr);\n      if (S) {\n        std::string strLiteral(S->getString().str());\n        result->EvalType = CXEval_CFStr;\n        result->EvalData.stringVal = new char[strLiteral.size() + 1];\n        strncpy((char *)result->EvalData.stringVal, strLiteral.c_str(),\n                strLiteral.size());\n        result->EvalData.stringVal[strLiteral.size()] = '\\0';\n        return result.release();\n      }\n    }\n  } else if (expr->getStmtClass() == Stmt::DeclRefExprClass) {\n    DeclRefExpr *D = static_cast<DeclRefExpr *>(expr);\n    ValueDecl *V = D->getDecl();\n    if (V->getKind() == Decl::Function) {\n      std::string strName = V->getNameAsString();\n      result->EvalType = CXEval_Other;\n      result->EvalData.stringVal = new char[strName.size() + 1];\n      strncpy(result->EvalData.stringVal, strName.c_str(), strName.size());\n      result->EvalData.stringVal[strName.size()] = '\\0';\n      return result.release();\n    }\n  }\n\n  return nullptr;\n}\n\nstatic const Expr *evaluateDeclExpr(const Decl *D) {\n  if (!D)\n    return nullptr;\n  if (auto *Var = dyn_cast<VarDecl>(D))\n    return Var->getInit();\n  else if (auto *Field = dyn_cast<FieldDecl>(D))\n    return Field->getInClassInitializer();\n  return nullptr;\n}\n\nstatic const Expr *evaluateCompoundStmtExpr(const CompoundStmt *CS) {\n  assert(CS && \"invalid compound statement\");\n  for (auto *bodyIterator : CS->body()) {\n    if (const auto *E = dyn_cast<Expr>(bodyIterator))\n      return E;\n  }\n  return nullptr;\n}\n\nCXEvalResult clang_Cursor_Evaluate(CXCursor C) {\n  const Expr *E = nullptr;\n  if (clang_getCursorKind(C) == CXCursor_CompoundStmt)\n    E = evaluateCompoundStmtExpr(cast<CompoundStmt>(getCursorStmt(C)));\n  else if (clang_isDeclaration(C.kind))\n    E = evaluateDeclExpr(getCursorDecl(C));\n  else if (clang_isExpression(C.kind))\n    E = getCursorExpr(C);\n  if (E)\n    return const_cast<CXEvalResult>(\n        reinterpret_cast<const void *>(evaluateExpr(const_cast<Expr *>(E), C)));\n  return nullptr;\n}\n\nunsigned clang_Cursor_hasAttrs(CXCursor C) {\n  const Decl *D = getCursorDecl(C);\n  if (!D) {\n    return 0;\n  }\n\n  if (D->hasAttrs()) {\n    return 1;\n  }\n\n  return 0;\n}\nunsigned clang_defaultSaveOptions(CXTranslationUnit TU) {\n  return CXSaveTranslationUnit_None;\n}\n\nstatic CXSaveError clang_saveTranslationUnit_Impl(CXTranslationUnit TU,\n                                                  const char *FileName,\n                                                  unsigned options) {\n  CIndexer *CXXIdx = TU->CIdx;\n  if (CXXIdx->isOptEnabled(CXGlobalOpt_ThreadBackgroundPriorityForIndexing))\n    setThreadBackgroundPriority();\n\n  bool hadError = cxtu::getASTUnit(TU)->Save(FileName);\n  return hadError ? CXSaveError_Unknown : CXSaveError_None;\n}\n\nint clang_saveTranslationUnit(CXTranslationUnit TU, const char *FileName,\n                              unsigned options) {\n  LOG_FUNC_SECTION { *Log << TU << ' ' << FileName; }\n\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return CXSaveError_InvalidTU;\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  ASTUnit::ConcurrencyCheck Check(*CXXUnit);\n  if (!CXXUnit->hasSema())\n    return CXSaveError_InvalidTU;\n\n  CXSaveError result;\n  auto SaveTranslationUnitImpl = [=, &result]() {\n    result = clang_saveTranslationUnit_Impl(TU, FileName, options);\n  };\n\n  if (!CXXUnit->getDiagnostics().hasUnrecoverableErrorOccurred()) {\n    SaveTranslationUnitImpl();\n\n    if (getenv(\"LIBCLANG_RESOURCE_USAGE\"))\n      PrintLibclangResourceUsage(TU);\n\n    return result;\n  }\n\n  // We have an AST that has invalid nodes due to compiler errors.\n  // Use a crash recovery thread for protection.\n\n  llvm::CrashRecoveryContext CRC;\n\n  if (!RunSafely(CRC, SaveTranslationUnitImpl)) {\n    fprintf(stderr, \"libclang: crash detected during AST saving: {\\n\");\n    fprintf(stderr, \"  'filename' : '%s'\\n\", FileName);\n    fprintf(stderr, \"  'options' : %d,\\n\", options);\n    fprintf(stderr, \"}\\n\");\n\n    return CXSaveError_Unknown;\n\n  } else if (getenv(\"LIBCLANG_RESOURCE_USAGE\")) {\n    PrintLibclangResourceUsage(TU);\n  }\n\n  return result;\n}\n\nvoid clang_disposeTranslationUnit(CXTranslationUnit CTUnit) {\n  if (CTUnit) {\n    // If the translation unit has been marked as unsafe to free, just discard\n    // it.\n    ASTUnit *Unit = cxtu::getASTUnit(CTUnit);\n    if (Unit && Unit->isUnsafeToFree())\n      return;\n\n    delete cxtu::getASTUnit(CTUnit);\n    delete CTUnit->StringPool;\n    delete static_cast<CXDiagnosticSetImpl *>(CTUnit->Diagnostics);\n    disposeOverridenCXCursorsPool(CTUnit->OverridenCursorsPool);\n    delete CTUnit->CommentToXML;\n    delete CTUnit;\n  }\n}\n\nunsigned clang_suspendTranslationUnit(CXTranslationUnit CTUnit) {\n  if (CTUnit) {\n    ASTUnit *Unit = cxtu::getASTUnit(CTUnit);\n\n    if (Unit && Unit->isUnsafeToFree())\n      return false;\n\n    Unit->ResetForParse();\n    return true;\n  }\n\n  return false;\n}\n\nunsigned clang_defaultReparseOptions(CXTranslationUnit TU) {\n  return CXReparse_None;\n}\n\nstatic CXErrorCode\nclang_reparseTranslationUnit_Impl(CXTranslationUnit TU,\n                                  ArrayRef<CXUnsavedFile> unsaved_files,\n                                  unsigned options) {\n  // Check arguments.\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return CXError_InvalidArguments;\n  }\n\n  // Reset the associated diagnostics.\n  delete static_cast<CXDiagnosticSetImpl *>(TU->Diagnostics);\n  TU->Diagnostics = nullptr;\n\n  CIndexer *CXXIdx = TU->CIdx;\n  if (CXXIdx->isOptEnabled(CXGlobalOpt_ThreadBackgroundPriorityForEditing))\n    setThreadBackgroundPriority();\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  ASTUnit::ConcurrencyCheck Check(*CXXUnit);\n\n  std::unique_ptr<std::vector<ASTUnit::RemappedFile>> RemappedFiles(\n      new std::vector<ASTUnit::RemappedFile>());\n\n  // Recover resources if we crash before exiting this function.\n  llvm::CrashRecoveryContextCleanupRegistrar<std::vector<ASTUnit::RemappedFile>>\n      RemappedCleanup(RemappedFiles.get());\n\n  for (auto &UF : unsaved_files) {\n    std::unique_ptr<llvm::MemoryBuffer> MB =\n        llvm::MemoryBuffer::getMemBufferCopy(getContents(UF), UF.Filename);\n    RemappedFiles->push_back(std::make_pair(UF.Filename, MB.release()));\n  }\n\n  if (!CXXUnit->Reparse(CXXIdx->getPCHContainerOperations(),\n                        *RemappedFiles.get()))\n    return CXError_Success;\n  if (isASTReadError(CXXUnit))\n    return CXError_ASTReadError;\n  return CXError_Failure;\n}\n\nint clang_reparseTranslationUnit(CXTranslationUnit TU,\n                                 unsigned num_unsaved_files,\n                                 struct CXUnsavedFile *unsaved_files,\n                                 unsigned options) {\n  LOG_FUNC_SECTION { *Log << TU; }\n\n  if (num_unsaved_files && !unsaved_files)\n    return CXError_InvalidArguments;\n\n  CXErrorCode result;\n  auto ReparseTranslationUnitImpl = [=, &result]() {\n    result = clang_reparseTranslationUnit_Impl(\n        TU, llvm::makeArrayRef(unsaved_files, num_unsaved_files), options);\n  };\n\n  llvm::CrashRecoveryContext CRC;\n\n  if (!RunSafely(CRC, ReparseTranslationUnitImpl)) {\n    fprintf(stderr, \"libclang: crash detected during reparsing\\n\");\n    cxtu::getASTUnit(TU)->setUnsafeToFree(true);\n    return CXError_Crashed;\n  } else if (getenv(\"LIBCLANG_RESOURCE_USAGE\"))\n    PrintLibclangResourceUsage(TU);\n\n  return result;\n}\n\nCXString clang_getTranslationUnitSpelling(CXTranslationUnit CTUnit) {\n  if (isNotUsableTU(CTUnit)) {\n    LOG_BAD_TU(CTUnit);\n    return cxstring::createEmpty();\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(CTUnit);\n  return cxstring::createDup(CXXUnit->getOriginalSourceFileName());\n}\n\nCXCursor clang_getTranslationUnitCursor(CXTranslationUnit TU) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return clang_getNullCursor();\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  return MakeCXCursor(CXXUnit->getASTContext().getTranslationUnitDecl(), TU);\n}\n\nCXTargetInfo clang_getTranslationUnitTargetInfo(CXTranslationUnit CTUnit) {\n  if (isNotUsableTU(CTUnit)) {\n    LOG_BAD_TU(CTUnit);\n    return nullptr;\n  }\n\n  CXTargetInfoImpl *impl = new CXTargetInfoImpl();\n  impl->TranslationUnit = CTUnit;\n  return impl;\n}\n\nCXString clang_TargetInfo_getTriple(CXTargetInfo TargetInfo) {\n  if (!TargetInfo)\n    return cxstring::createEmpty();\n\n  CXTranslationUnit CTUnit = TargetInfo->TranslationUnit;\n  assert(!isNotUsableTU(CTUnit) &&\n         \"Unexpected unusable translation unit in TargetInfo\");\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(CTUnit);\n  std::string Triple =\n      CXXUnit->getASTContext().getTargetInfo().getTriple().normalize();\n  return cxstring::createDup(Triple);\n}\n\nint clang_TargetInfo_getPointerWidth(CXTargetInfo TargetInfo) {\n  if (!TargetInfo)\n    return -1;\n\n  CXTranslationUnit CTUnit = TargetInfo->TranslationUnit;\n  assert(!isNotUsableTU(CTUnit) &&\n         \"Unexpected unusable translation unit in TargetInfo\");\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(CTUnit);\n  return CXXUnit->getASTContext().getTargetInfo().getMaxPointerWidth();\n}\n\nvoid clang_TargetInfo_dispose(CXTargetInfo TargetInfo) {\n  if (!TargetInfo)\n    return;\n\n  delete TargetInfo;\n}\n\n//===----------------------------------------------------------------------===//\n// CXFile Operations.\n//===----------------------------------------------------------------------===//\n\nCXString clang_getFileName(CXFile SFile) {\n  if (!SFile)\n    return cxstring::createNull();\n\n  FileEntry *FEnt = static_cast<FileEntry *>(SFile);\n  return cxstring::createRef(FEnt->getName());\n}\n\ntime_t clang_getFileTime(CXFile SFile) {\n  if (!SFile)\n    return 0;\n\n  FileEntry *FEnt = static_cast<FileEntry *>(SFile);\n  return FEnt->getModificationTime();\n}\n\nCXFile clang_getFile(CXTranslationUnit TU, const char *file_name) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return nullptr;\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n\n  FileManager &FMgr = CXXUnit->getFileManager();\n  auto File = FMgr.getFile(file_name);\n  if (!File)\n    return nullptr;\n  return const_cast<FileEntry *>(*File);\n}\n\nconst char *clang_getFileContents(CXTranslationUnit TU, CXFile file,\n                                  size_t *size) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return nullptr;\n  }\n\n  const SourceManager &SM = cxtu::getASTUnit(TU)->getSourceManager();\n  FileID fid = SM.translateFile(static_cast<FileEntry *>(file));\n  llvm::Optional<llvm::MemoryBufferRef> buf = SM.getBufferOrNone(fid);\n  if (!buf) {\n    if (size)\n      *size = 0;\n    return nullptr;\n  }\n  if (size)\n    *size = buf->getBufferSize();\n  return buf->getBufferStart();\n}\n\nunsigned clang_isFileMultipleIncludeGuarded(CXTranslationUnit TU, CXFile file) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return 0;\n  }\n\n  if (!file)\n    return 0;\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  FileEntry *FEnt = static_cast<FileEntry *>(file);\n  return CXXUnit->getPreprocessor()\n      .getHeaderSearchInfo()\n      .isFileMultipleIncludeGuarded(FEnt);\n}\n\nint clang_getFileUniqueID(CXFile file, CXFileUniqueID *outID) {\n  if (!file || !outID)\n    return 1;\n\n  FileEntry *FEnt = static_cast<FileEntry *>(file);\n  const llvm::sys::fs::UniqueID &ID = FEnt->getUniqueID();\n  outID->data[0] = ID.getDevice();\n  outID->data[1] = ID.getFile();\n  outID->data[2] = FEnt->getModificationTime();\n  return 0;\n}\n\nint clang_File_isEqual(CXFile file1, CXFile file2) {\n  if (file1 == file2)\n    return true;\n\n  if (!file1 || !file2)\n    return false;\n\n  FileEntry *FEnt1 = static_cast<FileEntry *>(file1);\n  FileEntry *FEnt2 = static_cast<FileEntry *>(file2);\n  return FEnt1->getUniqueID() == FEnt2->getUniqueID();\n}\n\nCXString clang_File_tryGetRealPathName(CXFile SFile) {\n  if (!SFile)\n    return cxstring::createNull();\n\n  FileEntry *FEnt = static_cast<FileEntry *>(SFile);\n  return cxstring::createRef(FEnt->tryGetRealPathName());\n}\n\n//===----------------------------------------------------------------------===//\n// CXCursor Operations.\n//===----------------------------------------------------------------------===//\n\nstatic const Decl *getDeclFromExpr(const Stmt *E) {\n  if (const ImplicitCastExpr *CE = dyn_cast<ImplicitCastExpr>(E))\n    return getDeclFromExpr(CE->getSubExpr());\n\n  if (const DeclRefExpr *RefExpr = dyn_cast<DeclRefExpr>(E))\n    return RefExpr->getDecl();\n  if (const MemberExpr *ME = dyn_cast<MemberExpr>(E))\n    return ME->getMemberDecl();\n  if (const ObjCIvarRefExpr *RE = dyn_cast<ObjCIvarRefExpr>(E))\n    return RE->getDecl();\n  if (const ObjCPropertyRefExpr *PRE = dyn_cast<ObjCPropertyRefExpr>(E)) {\n    if (PRE->isExplicitProperty())\n      return PRE->getExplicitProperty();\n    // It could be messaging both getter and setter as in:\n    // ++myobj.myprop;\n    // in which case prefer to associate the setter since it is less obvious\n    // from inspecting the source that the setter is going to get called.\n    if (PRE->isMessagingSetter())\n      return PRE->getImplicitPropertySetter();\n    return PRE->getImplicitPropertyGetter();\n  }\n  if (const PseudoObjectExpr *POE = dyn_cast<PseudoObjectExpr>(E))\n    return getDeclFromExpr(POE->getSyntacticForm());\n  if (const OpaqueValueExpr *OVE = dyn_cast<OpaqueValueExpr>(E))\n    if (Expr *Src = OVE->getSourceExpr())\n      return getDeclFromExpr(Src);\n\n  if (const CallExpr *CE = dyn_cast<CallExpr>(E))\n    return getDeclFromExpr(CE->getCallee());\n  if (const CXXConstructExpr *CE = dyn_cast<CXXConstructExpr>(E))\n    if (!CE->isElidable())\n      return CE->getConstructor();\n  if (const CXXInheritedCtorInitExpr *CE =\n          dyn_cast<CXXInheritedCtorInitExpr>(E))\n    return CE->getConstructor();\n  if (const ObjCMessageExpr *OME = dyn_cast<ObjCMessageExpr>(E))\n    return OME->getMethodDecl();\n\n  if (const ObjCProtocolExpr *PE = dyn_cast<ObjCProtocolExpr>(E))\n    return PE->getProtocol();\n  if (const SubstNonTypeTemplateParmPackExpr *NTTP =\n          dyn_cast<SubstNonTypeTemplateParmPackExpr>(E))\n    return NTTP->getParameterPack();\n  if (const SizeOfPackExpr *SizeOfPack = dyn_cast<SizeOfPackExpr>(E))\n    if (isa<NonTypeTemplateParmDecl>(SizeOfPack->getPack()) ||\n        isa<ParmVarDecl>(SizeOfPack->getPack()))\n      return SizeOfPack->getPack();\n\n  return nullptr;\n}\n\nstatic SourceLocation getLocationFromExpr(const Expr *E) {\n  if (const ImplicitCastExpr *CE = dyn_cast<ImplicitCastExpr>(E))\n    return getLocationFromExpr(CE->getSubExpr());\n\n  if (const ObjCMessageExpr *Msg = dyn_cast<ObjCMessageExpr>(E))\n    return /*FIXME:*/ Msg->getLeftLoc();\n  if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E))\n    return DRE->getLocation();\n  if (const MemberExpr *Member = dyn_cast<MemberExpr>(E))\n    return Member->getMemberLoc();\n  if (const ObjCIvarRefExpr *Ivar = dyn_cast<ObjCIvarRefExpr>(E))\n    return Ivar->getLocation();\n  if (const SizeOfPackExpr *SizeOfPack = dyn_cast<SizeOfPackExpr>(E))\n    return SizeOfPack->getPackLoc();\n  if (const ObjCPropertyRefExpr *PropRef = dyn_cast<ObjCPropertyRefExpr>(E))\n    return PropRef->getLocation();\n\n  return E->getBeginLoc();\n}\n\nextern \"C\" {\n\nunsigned clang_visitChildren(CXCursor parent, CXCursorVisitor visitor,\n                             CXClientData client_data) {\n  CursorVisitor CursorVis(getCursorTU(parent), visitor, client_data,\n                          /*VisitPreprocessorLast=*/false);\n  return CursorVis.VisitChildren(parent);\n}\n\n#ifndef __has_feature\n#define __has_feature(x) 0\n#endif\n#if __has_feature(blocks)\ntypedef enum CXChildVisitResult (^CXCursorVisitorBlock)(CXCursor cursor,\n                                                        CXCursor parent);\n\nstatic enum CXChildVisitResult visitWithBlock(CXCursor cursor, CXCursor parent,\n                                              CXClientData client_data) {\n  CXCursorVisitorBlock block = (CXCursorVisitorBlock)client_data;\n  return block(cursor, parent);\n}\n#else\n// If we are compiled with a compiler that doesn't have native blocks support,\n// define and call the block manually, so the\ntypedef struct _CXChildVisitResult {\n  void *isa;\n  int flags;\n  int reserved;\n  enum CXChildVisitResult (*invoke)(struct _CXChildVisitResult *, CXCursor,\n                                    CXCursor);\n} * CXCursorVisitorBlock;\n\nstatic enum CXChildVisitResult visitWithBlock(CXCursor cursor, CXCursor parent,\n                                              CXClientData client_data) {\n  CXCursorVisitorBlock block = (CXCursorVisitorBlock)client_data;\n  return block->invoke(block, cursor, parent);\n}\n#endif\n\nunsigned clang_visitChildrenWithBlock(CXCursor parent,\n                                      CXCursorVisitorBlock block) {\n  return clang_visitChildren(parent, visitWithBlock, block);\n}\n\nstatic CXString getDeclSpelling(const Decl *D) {\n  if (!D)\n    return cxstring::createEmpty();\n\n  const NamedDecl *ND = dyn_cast<NamedDecl>(D);\n  if (!ND) {\n    if (const ObjCPropertyImplDecl *PropImpl =\n            dyn_cast<ObjCPropertyImplDecl>(D))\n      if (ObjCPropertyDecl *Property = PropImpl->getPropertyDecl())\n        return cxstring::createDup(Property->getIdentifier()->getName());\n\n    if (const ImportDecl *ImportD = dyn_cast<ImportDecl>(D))\n      if (Module *Mod = ImportD->getImportedModule())\n        return cxstring::createDup(Mod->getFullModuleName());\n\n    return cxstring::createEmpty();\n  }\n\n  if (const ObjCMethodDecl *OMD = dyn_cast<ObjCMethodDecl>(ND))\n    return cxstring::createDup(OMD->getSelector().getAsString());\n\n  if (const ObjCCategoryImplDecl *CIMP = dyn_cast<ObjCCategoryImplDecl>(ND))\n    // No, this isn't the same as the code below. getIdentifier() is non-virtual\n    // and returns different names. NamedDecl returns the class name and\n    // ObjCCategoryImplDecl returns the category name.\n    return cxstring::createRef(CIMP->getIdentifier()->getNameStart());\n\n  if (isa<UsingDirectiveDecl>(D))\n    return cxstring::createEmpty();\n\n  SmallString<1024> S;\n  llvm::raw_svector_ostream os(S);\n  ND->printName(os);\n\n  return cxstring::createDup(os.str());\n}\n\nCXString clang_getCursorSpelling(CXCursor C) {\n  if (clang_isTranslationUnit(C.kind))\n    return clang_getTranslationUnitSpelling(getCursorTU(C));\n\n  if (clang_isReference(C.kind)) {\n    switch (C.kind) {\n    case CXCursor_ObjCSuperClassRef: {\n      const ObjCInterfaceDecl *Super = getCursorObjCSuperClassRef(C).first;\n      return cxstring::createRef(Super->getIdentifier()->getNameStart());\n    }\n    case CXCursor_ObjCClassRef: {\n      const ObjCInterfaceDecl *Class = getCursorObjCClassRef(C).first;\n      return cxstring::createRef(Class->getIdentifier()->getNameStart());\n    }\n    case CXCursor_ObjCProtocolRef: {\n      const ObjCProtocolDecl *OID = getCursorObjCProtocolRef(C).first;\n      assert(OID && \"getCursorSpelling(): Missing protocol decl\");\n      return cxstring::createRef(OID->getIdentifier()->getNameStart());\n    }\n    case CXCursor_CXXBaseSpecifier: {\n      const CXXBaseSpecifier *B = getCursorCXXBaseSpecifier(C);\n      return cxstring::createDup(B->getType().getAsString());\n    }\n    case CXCursor_TypeRef: {\n      const TypeDecl *Type = getCursorTypeRef(C).first;\n      assert(Type && \"Missing type decl\");\n\n      return cxstring::createDup(\n          getCursorContext(C).getTypeDeclType(Type).getAsString());\n    }\n    case CXCursor_TemplateRef: {\n      const TemplateDecl *Template = getCursorTemplateRef(C).first;\n      assert(Template && \"Missing template decl\");\n\n      return cxstring::createDup(Template->getNameAsString());\n    }\n\n    case CXCursor_NamespaceRef: {\n      const NamedDecl *NS = getCursorNamespaceRef(C).first;\n      assert(NS && \"Missing namespace decl\");\n\n      return cxstring::createDup(NS->getNameAsString());\n    }\n\n    case CXCursor_MemberRef: {\n      const FieldDecl *Field = getCursorMemberRef(C).first;\n      assert(Field && \"Missing member decl\");\n\n      return cxstring::createDup(Field->getNameAsString());\n    }\n\n    case CXCursor_LabelRef: {\n      const LabelStmt *Label = getCursorLabelRef(C).first;\n      assert(Label && \"Missing label\");\n\n      return cxstring::createRef(Label->getName());\n    }\n\n    case CXCursor_OverloadedDeclRef: {\n      OverloadedDeclRefStorage Storage = getCursorOverloadedDeclRef(C).first;\n      if (const Decl *D = Storage.dyn_cast<const Decl *>()) {\n        if (const NamedDecl *ND = dyn_cast<NamedDecl>(D))\n          return cxstring::createDup(ND->getNameAsString());\n        return cxstring::createEmpty();\n      }\n      if (const OverloadExpr *E = Storage.dyn_cast<const OverloadExpr *>())\n        return cxstring::createDup(E->getName().getAsString());\n      OverloadedTemplateStorage *Ovl =\n          Storage.get<OverloadedTemplateStorage *>();\n      if (Ovl->size() == 0)\n        return cxstring::createEmpty();\n      return cxstring::createDup((*Ovl->begin())->getNameAsString());\n    }\n\n    case CXCursor_VariableRef: {\n      const VarDecl *Var = getCursorVariableRef(C).first;\n      assert(Var && \"Missing variable decl\");\n\n      return cxstring::createDup(Var->getNameAsString());\n    }\n\n    default:\n      return cxstring::createRef(\"<not implemented>\");\n    }\n  }\n\n  if (clang_isExpression(C.kind)) {\n    const Expr *E = getCursorExpr(C);\n\n    if (C.kind == CXCursor_ObjCStringLiteral ||\n        C.kind == CXCursor_StringLiteral) {\n      const StringLiteral *SLit;\n      if (const ObjCStringLiteral *OSL = dyn_cast<ObjCStringLiteral>(E)) {\n        SLit = OSL->getString();\n      } else {\n        SLit = cast<StringLiteral>(E);\n      }\n      SmallString<256> Buf;\n      llvm::raw_svector_ostream OS(Buf);\n      SLit->outputString(OS);\n      return cxstring::createDup(OS.str());\n    }\n\n    const Decl *D = getDeclFromExpr(getCursorExpr(C));\n    if (D)\n      return getDeclSpelling(D);\n    return cxstring::createEmpty();\n  }\n\n  if (clang_isStatement(C.kind)) {\n    const Stmt *S = getCursorStmt(C);\n    if (const LabelStmt *Label = dyn_cast_or_null<LabelStmt>(S))\n      return cxstring::createRef(Label->getName());\n\n    return cxstring::createEmpty();\n  }\n\n  if (C.kind == CXCursor_MacroExpansion)\n    return cxstring::createRef(\n        getCursorMacroExpansion(C).getName()->getNameStart());\n\n  if (C.kind == CXCursor_MacroDefinition)\n    return cxstring::createRef(\n        getCursorMacroDefinition(C)->getName()->getNameStart());\n\n  if (C.kind == CXCursor_InclusionDirective)\n    return cxstring::createDup(getCursorInclusionDirective(C)->getFileName());\n\n  if (clang_isDeclaration(C.kind))\n    return getDeclSpelling(getCursorDecl(C));\n\n  if (C.kind == CXCursor_AnnotateAttr) {\n    const AnnotateAttr *AA = cast<AnnotateAttr>(cxcursor::getCursorAttr(C));\n    return cxstring::createDup(AA->getAnnotation());\n  }\n\n  if (C.kind == CXCursor_AsmLabelAttr) {\n    const AsmLabelAttr *AA = cast<AsmLabelAttr>(cxcursor::getCursorAttr(C));\n    return cxstring::createDup(AA->getLabel());\n  }\n\n  if (C.kind == CXCursor_PackedAttr) {\n    return cxstring::createRef(\"packed\");\n  }\n\n  if (C.kind == CXCursor_VisibilityAttr) {\n    const VisibilityAttr *AA = cast<VisibilityAttr>(cxcursor::getCursorAttr(C));\n    switch (AA->getVisibility()) {\n    case VisibilityAttr::VisibilityType::Default:\n      return cxstring::createRef(\"default\");\n    case VisibilityAttr::VisibilityType::Hidden:\n      return cxstring::createRef(\"hidden\");\n    case VisibilityAttr::VisibilityType::Protected:\n      return cxstring::createRef(\"protected\");\n    }\n    llvm_unreachable(\"unknown visibility type\");\n  }\n\n  return cxstring::createEmpty();\n}\n\nCXSourceRange clang_Cursor_getSpellingNameRange(CXCursor C, unsigned pieceIndex,\n                                                unsigned options) {\n  if (clang_Cursor_isNull(C))\n    return clang_getNullRange();\n\n  ASTContext &Ctx = getCursorContext(C);\n\n  if (clang_isStatement(C.kind)) {\n    const Stmt *S = getCursorStmt(C);\n    if (const LabelStmt *Label = dyn_cast_or_null<LabelStmt>(S)) {\n      if (pieceIndex > 0)\n        return clang_getNullRange();\n      return cxloc::translateSourceRange(Ctx, Label->getIdentLoc());\n    }\n\n    return clang_getNullRange();\n  }\n\n  if (C.kind == CXCursor_ObjCMessageExpr) {\n    if (const ObjCMessageExpr *ME =\n            dyn_cast_or_null<ObjCMessageExpr>(getCursorExpr(C))) {\n      if (pieceIndex >= ME->getNumSelectorLocs())\n        return clang_getNullRange();\n      return cxloc::translateSourceRange(Ctx, ME->getSelectorLoc(pieceIndex));\n    }\n  }\n\n  if (C.kind == CXCursor_ObjCInstanceMethodDecl ||\n      C.kind == CXCursor_ObjCClassMethodDecl) {\n    if (const ObjCMethodDecl *MD =\n            dyn_cast_or_null<ObjCMethodDecl>(getCursorDecl(C))) {\n      if (pieceIndex >= MD->getNumSelectorLocs())\n        return clang_getNullRange();\n      return cxloc::translateSourceRange(Ctx, MD->getSelectorLoc(pieceIndex));\n    }\n  }\n\n  if (C.kind == CXCursor_ObjCCategoryDecl ||\n      C.kind == CXCursor_ObjCCategoryImplDecl) {\n    if (pieceIndex > 0)\n      return clang_getNullRange();\n    if (const ObjCCategoryDecl *CD =\n            dyn_cast_or_null<ObjCCategoryDecl>(getCursorDecl(C)))\n      return cxloc::translateSourceRange(Ctx, CD->getCategoryNameLoc());\n    if (const ObjCCategoryImplDecl *CID =\n            dyn_cast_or_null<ObjCCategoryImplDecl>(getCursorDecl(C)))\n      return cxloc::translateSourceRange(Ctx, CID->getCategoryNameLoc());\n  }\n\n  if (C.kind == CXCursor_ModuleImportDecl) {\n    if (pieceIndex > 0)\n      return clang_getNullRange();\n    if (const ImportDecl *ImportD =\n            dyn_cast_or_null<ImportDecl>(getCursorDecl(C))) {\n      ArrayRef<SourceLocation> Locs = ImportD->getIdentifierLocs();\n      if (!Locs.empty())\n        return cxloc::translateSourceRange(\n            Ctx, SourceRange(Locs.front(), Locs.back()));\n    }\n    return clang_getNullRange();\n  }\n\n  if (C.kind == CXCursor_CXXMethod || C.kind == CXCursor_Destructor ||\n      C.kind == CXCursor_ConversionFunction ||\n      C.kind == CXCursor_FunctionDecl) {\n    if (pieceIndex > 0)\n      return clang_getNullRange();\n    if (const FunctionDecl *FD =\n            dyn_cast_or_null<FunctionDecl>(getCursorDecl(C))) {\n      DeclarationNameInfo FunctionName = FD->getNameInfo();\n      return cxloc::translateSourceRange(Ctx, FunctionName.getSourceRange());\n    }\n    return clang_getNullRange();\n  }\n\n  // FIXME: A CXCursor_InclusionDirective should give the location of the\n  // filename, but we don't keep track of this.\n\n  // FIXME: A CXCursor_AnnotateAttr should give the location of the annotation\n  // but we don't keep track of this.\n\n  // FIXME: A CXCursor_AsmLabelAttr should give the location of the label\n  // but we don't keep track of this.\n\n  // Default handling, give the location of the cursor.\n\n  if (pieceIndex > 0)\n    return clang_getNullRange();\n\n  CXSourceLocation CXLoc = clang_getCursorLocation(C);\n  SourceLocation Loc = cxloc::translateSourceLocation(CXLoc);\n  return cxloc::translateSourceRange(Ctx, Loc);\n}\n\nCXString clang_Cursor_getMangling(CXCursor C) {\n  if (clang_isInvalid(C.kind) || !clang_isDeclaration(C.kind))\n    return cxstring::createEmpty();\n\n  // Mangling only works for functions and variables.\n  const Decl *D = getCursorDecl(C);\n  if (!D || !(isa<FunctionDecl>(D) || isa<VarDecl>(D)))\n    return cxstring::createEmpty();\n\n  ASTContext &Ctx = D->getASTContext();\n  ASTNameGenerator ASTNameGen(Ctx);\n  return cxstring::createDup(ASTNameGen.getName(D));\n}\n\nCXStringSet *clang_Cursor_getCXXManglings(CXCursor C) {\n  if (clang_isInvalid(C.kind) || !clang_isDeclaration(C.kind))\n    return nullptr;\n\n  const Decl *D = getCursorDecl(C);\n  if (!(isa<CXXRecordDecl>(D) || isa<CXXMethodDecl>(D)))\n    return nullptr;\n\n  ASTContext &Ctx = D->getASTContext();\n  ASTNameGenerator ASTNameGen(Ctx);\n  std::vector<std::string> Manglings = ASTNameGen.getAllManglings(D);\n  return cxstring::createSet(Manglings);\n}\n\nCXStringSet *clang_Cursor_getObjCManglings(CXCursor C) {\n  if (clang_isInvalid(C.kind) || !clang_isDeclaration(C.kind))\n    return nullptr;\n\n  const Decl *D = getCursorDecl(C);\n  if (!(isa<ObjCInterfaceDecl>(D) || isa<ObjCImplementationDecl>(D)))\n    return nullptr;\n\n  ASTContext &Ctx = D->getASTContext();\n  ASTNameGenerator ASTNameGen(Ctx);\n  std::vector<std::string> Manglings = ASTNameGen.getAllManglings(D);\n  return cxstring::createSet(Manglings);\n}\n\nCXPrintingPolicy clang_getCursorPrintingPolicy(CXCursor C) {\n  if (clang_Cursor_isNull(C))\n    return 0;\n  return new PrintingPolicy(getCursorContext(C).getPrintingPolicy());\n}\n\nvoid clang_PrintingPolicy_dispose(CXPrintingPolicy Policy) {\n  if (Policy)\n    delete static_cast<PrintingPolicy *>(Policy);\n}\n\nunsigned\nclang_PrintingPolicy_getProperty(CXPrintingPolicy Policy,\n                                 enum CXPrintingPolicyProperty Property) {\n  if (!Policy)\n    return 0;\n\n  PrintingPolicy *P = static_cast<PrintingPolicy *>(Policy);\n  switch (Property) {\n  case CXPrintingPolicy_Indentation:\n    return P->Indentation;\n  case CXPrintingPolicy_SuppressSpecifiers:\n    return P->SuppressSpecifiers;\n  case CXPrintingPolicy_SuppressTagKeyword:\n    return P->SuppressTagKeyword;\n  case CXPrintingPolicy_IncludeTagDefinition:\n    return P->IncludeTagDefinition;\n  case CXPrintingPolicy_SuppressScope:\n    return P->SuppressScope;\n  case CXPrintingPolicy_SuppressUnwrittenScope:\n    return P->SuppressUnwrittenScope;\n  case CXPrintingPolicy_SuppressInitializers:\n    return P->SuppressInitializers;\n  case CXPrintingPolicy_ConstantArraySizeAsWritten:\n    return P->ConstantArraySizeAsWritten;\n  case CXPrintingPolicy_AnonymousTagLocations:\n    return P->AnonymousTagLocations;\n  case CXPrintingPolicy_SuppressStrongLifetime:\n    return P->SuppressStrongLifetime;\n  case CXPrintingPolicy_SuppressLifetimeQualifiers:\n    return P->SuppressLifetimeQualifiers;\n  case CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors:\n    return P->SuppressTemplateArgsInCXXConstructors;\n  case CXPrintingPolicy_Bool:\n    return P->Bool;\n  case CXPrintingPolicy_Restrict:\n    return P->Restrict;\n  case CXPrintingPolicy_Alignof:\n    return P->Alignof;\n  case CXPrintingPolicy_UnderscoreAlignof:\n    return P->UnderscoreAlignof;\n  case CXPrintingPolicy_UseVoidForZeroParams:\n    return P->UseVoidForZeroParams;\n  case CXPrintingPolicy_TerseOutput:\n    return P->TerseOutput;\n  case CXPrintingPolicy_PolishForDeclaration:\n    return P->PolishForDeclaration;\n  case CXPrintingPolicy_Half:\n    return P->Half;\n  case CXPrintingPolicy_MSWChar:\n    return P->MSWChar;\n  case CXPrintingPolicy_IncludeNewlines:\n    return P->IncludeNewlines;\n  case CXPrintingPolicy_MSVCFormatting:\n    return P->MSVCFormatting;\n  case CXPrintingPolicy_ConstantsAsWritten:\n    return P->ConstantsAsWritten;\n  case CXPrintingPolicy_SuppressImplicitBase:\n    return P->SuppressImplicitBase;\n  case CXPrintingPolicy_FullyQualifiedName:\n    return P->FullyQualifiedName;\n  }\n\n  assert(false && \"Invalid CXPrintingPolicyProperty\");\n  return 0;\n}\n\nvoid clang_PrintingPolicy_setProperty(CXPrintingPolicy Policy,\n                                      enum CXPrintingPolicyProperty Property,\n                                      unsigned Value) {\n  if (!Policy)\n    return;\n\n  PrintingPolicy *P = static_cast<PrintingPolicy *>(Policy);\n  switch (Property) {\n  case CXPrintingPolicy_Indentation:\n    P->Indentation = Value;\n    return;\n  case CXPrintingPolicy_SuppressSpecifiers:\n    P->SuppressSpecifiers = Value;\n    return;\n  case CXPrintingPolicy_SuppressTagKeyword:\n    P->SuppressTagKeyword = Value;\n    return;\n  case CXPrintingPolicy_IncludeTagDefinition:\n    P->IncludeTagDefinition = Value;\n    return;\n  case CXPrintingPolicy_SuppressScope:\n    P->SuppressScope = Value;\n    return;\n  case CXPrintingPolicy_SuppressUnwrittenScope:\n    P->SuppressUnwrittenScope = Value;\n    return;\n  case CXPrintingPolicy_SuppressInitializers:\n    P->SuppressInitializers = Value;\n    return;\n  case CXPrintingPolicy_ConstantArraySizeAsWritten:\n    P->ConstantArraySizeAsWritten = Value;\n    return;\n  case CXPrintingPolicy_AnonymousTagLocations:\n    P->AnonymousTagLocations = Value;\n    return;\n  case CXPrintingPolicy_SuppressStrongLifetime:\n    P->SuppressStrongLifetime = Value;\n    return;\n  case CXPrintingPolicy_SuppressLifetimeQualifiers:\n    P->SuppressLifetimeQualifiers = Value;\n    return;\n  case CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors:\n    P->SuppressTemplateArgsInCXXConstructors = Value;\n    return;\n  case CXPrintingPolicy_Bool:\n    P->Bool = Value;\n    return;\n  case CXPrintingPolicy_Restrict:\n    P->Restrict = Value;\n    return;\n  case CXPrintingPolicy_Alignof:\n    P->Alignof = Value;\n    return;\n  case CXPrintingPolicy_UnderscoreAlignof:\n    P->UnderscoreAlignof = Value;\n    return;\n  case CXPrintingPolicy_UseVoidForZeroParams:\n    P->UseVoidForZeroParams = Value;\n    return;\n  case CXPrintingPolicy_TerseOutput:\n    P->TerseOutput = Value;\n    return;\n  case CXPrintingPolicy_PolishForDeclaration:\n    P->PolishForDeclaration = Value;\n    return;\n  case CXPrintingPolicy_Half:\n    P->Half = Value;\n    return;\n  case CXPrintingPolicy_MSWChar:\n    P->MSWChar = Value;\n    return;\n  case CXPrintingPolicy_IncludeNewlines:\n    P->IncludeNewlines = Value;\n    return;\n  case CXPrintingPolicy_MSVCFormatting:\n    P->MSVCFormatting = Value;\n    return;\n  case CXPrintingPolicy_ConstantsAsWritten:\n    P->ConstantsAsWritten = Value;\n    return;\n  case CXPrintingPolicy_SuppressImplicitBase:\n    P->SuppressImplicitBase = Value;\n    return;\n  case CXPrintingPolicy_FullyQualifiedName:\n    P->FullyQualifiedName = Value;\n    return;\n  }\n\n  assert(false && \"Invalid CXPrintingPolicyProperty\");\n}\n\nCXString clang_getCursorPrettyPrinted(CXCursor C, CXPrintingPolicy cxPolicy) {\n  if (clang_Cursor_isNull(C))\n    return cxstring::createEmpty();\n\n  if (clang_isDeclaration(C.kind)) {\n    const Decl *D = getCursorDecl(C);\n    if (!D)\n      return cxstring::createEmpty();\n\n    SmallString<128> Str;\n    llvm::raw_svector_ostream OS(Str);\n    PrintingPolicy *UserPolicy = static_cast<PrintingPolicy *>(cxPolicy);\n    D->print(OS, UserPolicy ? *UserPolicy\n                            : getCursorContext(C).getPrintingPolicy());\n\n    return cxstring::createDup(OS.str());\n  }\n\n  return cxstring::createEmpty();\n}\n\nCXString clang_getCursorDisplayName(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return clang_getCursorSpelling(C);\n\n  const Decl *D = getCursorDecl(C);\n  if (!D)\n    return cxstring::createEmpty();\n\n  PrintingPolicy Policy = getCursorContext(C).getPrintingPolicy();\n  if (const FunctionTemplateDecl *FunTmpl = dyn_cast<FunctionTemplateDecl>(D))\n    D = FunTmpl->getTemplatedDecl();\n\n  if (const FunctionDecl *Function = dyn_cast<FunctionDecl>(D)) {\n    SmallString<64> Str;\n    llvm::raw_svector_ostream OS(Str);\n    OS << *Function;\n    if (Function->getPrimaryTemplate())\n      OS << \"<>\";\n    OS << \"(\";\n    for (unsigned I = 0, N = Function->getNumParams(); I != N; ++I) {\n      if (I)\n        OS << \", \";\n      OS << Function->getParamDecl(I)->getType().getAsString(Policy);\n    }\n\n    if (Function->isVariadic()) {\n      if (Function->getNumParams())\n        OS << \", \";\n      OS << \"...\";\n    }\n    OS << \")\";\n    return cxstring::createDup(OS.str());\n  }\n\n  if (const ClassTemplateDecl *ClassTemplate = dyn_cast<ClassTemplateDecl>(D)) {\n    SmallString<64> Str;\n    llvm::raw_svector_ostream OS(Str);\n    OS << *ClassTemplate;\n    OS << \"<\";\n    TemplateParameterList *Params = ClassTemplate->getTemplateParameters();\n    for (unsigned I = 0, N = Params->size(); I != N; ++I) {\n      if (I)\n        OS << \", \";\n\n      NamedDecl *Param = Params->getParam(I);\n      if (Param->getIdentifier()) {\n        OS << Param->getIdentifier()->getName();\n        continue;\n      }\n\n      // There is no parameter name, which makes this tricky. Try to come up\n      // with something useful that isn't too long.\n      if (TemplateTypeParmDecl *TTP = dyn_cast<TemplateTypeParmDecl>(Param))\n        if (const auto *TC = TTP->getTypeConstraint()) {\n          TC->getConceptNameInfo().printName(OS, Policy);\n          if (TC->hasExplicitTemplateArgs())\n            OS << \"<...>\";\n        } else\n          OS << (TTP->wasDeclaredWithTypename() ? \"typename\" : \"class\");\n      else if (NonTypeTemplateParmDecl *NTTP =\n                   dyn_cast<NonTypeTemplateParmDecl>(Param))\n        OS << NTTP->getType().getAsString(Policy);\n      else\n        OS << \"template<...> class\";\n    }\n\n    OS << \">\";\n    return cxstring::createDup(OS.str());\n  }\n\n  if (const ClassTemplateSpecializationDecl *ClassSpec =\n          dyn_cast<ClassTemplateSpecializationDecl>(D)) {\n    // If the type was explicitly written, use that.\n    if (TypeSourceInfo *TSInfo = ClassSpec->getTypeAsWritten())\n      return cxstring::createDup(TSInfo->getType().getAsString(Policy));\n\n    SmallString<128> Str;\n    llvm::raw_svector_ostream OS(Str);\n    OS << *ClassSpec;\n    printTemplateArgumentList(OS, ClassSpec->getTemplateArgs().asArray(),\n                              Policy);\n    return cxstring::createDup(OS.str());\n  }\n\n  return clang_getCursorSpelling(C);\n}\n\nCXString clang_getCursorKindSpelling(enum CXCursorKind Kind) {\n  switch (Kind) {\n  case CXCursor_FunctionDecl:\n    return cxstring::createRef(\"FunctionDecl\");\n  case CXCursor_TypedefDecl:\n    return cxstring::createRef(\"TypedefDecl\");\n  case CXCursor_EnumDecl:\n    return cxstring::createRef(\"EnumDecl\");\n  case CXCursor_EnumConstantDecl:\n    return cxstring::createRef(\"EnumConstantDecl\");\n  case CXCursor_StructDecl:\n    return cxstring::createRef(\"StructDecl\");\n  case CXCursor_UnionDecl:\n    return cxstring::createRef(\"UnionDecl\");\n  case CXCursor_ClassDecl:\n    return cxstring::createRef(\"ClassDecl\");\n  case CXCursor_FieldDecl:\n    return cxstring::createRef(\"FieldDecl\");\n  case CXCursor_VarDecl:\n    return cxstring::createRef(\"VarDecl\");\n  case CXCursor_ParmDecl:\n    return cxstring::createRef(\"ParmDecl\");\n  case CXCursor_ObjCInterfaceDecl:\n    return cxstring::createRef(\"ObjCInterfaceDecl\");\n  case CXCursor_ObjCCategoryDecl:\n    return cxstring::createRef(\"ObjCCategoryDecl\");\n  case CXCursor_ObjCProtocolDecl:\n    return cxstring::createRef(\"ObjCProtocolDecl\");\n  case CXCursor_ObjCPropertyDecl:\n    return cxstring::createRef(\"ObjCPropertyDecl\");\n  case CXCursor_ObjCIvarDecl:\n    return cxstring::createRef(\"ObjCIvarDecl\");\n  case CXCursor_ObjCInstanceMethodDecl:\n    return cxstring::createRef(\"ObjCInstanceMethodDecl\");\n  case CXCursor_ObjCClassMethodDecl:\n    return cxstring::createRef(\"ObjCClassMethodDecl\");\n  case CXCursor_ObjCImplementationDecl:\n    return cxstring::createRef(\"ObjCImplementationDecl\");\n  case CXCursor_ObjCCategoryImplDecl:\n    return cxstring::createRef(\"ObjCCategoryImplDecl\");\n  case CXCursor_CXXMethod:\n    return cxstring::createRef(\"CXXMethod\");\n  case CXCursor_UnexposedDecl:\n    return cxstring::createRef(\"UnexposedDecl\");\n  case CXCursor_ObjCSuperClassRef:\n    return cxstring::createRef(\"ObjCSuperClassRef\");\n  case CXCursor_ObjCProtocolRef:\n    return cxstring::createRef(\"ObjCProtocolRef\");\n  case CXCursor_ObjCClassRef:\n    return cxstring::createRef(\"ObjCClassRef\");\n  case CXCursor_TypeRef:\n    return cxstring::createRef(\"TypeRef\");\n  case CXCursor_TemplateRef:\n    return cxstring::createRef(\"TemplateRef\");\n  case CXCursor_NamespaceRef:\n    return cxstring::createRef(\"NamespaceRef\");\n  case CXCursor_MemberRef:\n    return cxstring::createRef(\"MemberRef\");\n  case CXCursor_LabelRef:\n    return cxstring::createRef(\"LabelRef\");\n  case CXCursor_OverloadedDeclRef:\n    return cxstring::createRef(\"OverloadedDeclRef\");\n  case CXCursor_VariableRef:\n    return cxstring::createRef(\"VariableRef\");\n  case CXCursor_IntegerLiteral:\n    return cxstring::createRef(\"IntegerLiteral\");\n  case CXCursor_FixedPointLiteral:\n    return cxstring::createRef(\"FixedPointLiteral\");\n  case CXCursor_FloatingLiteral:\n    return cxstring::createRef(\"FloatingLiteral\");\n  case CXCursor_ImaginaryLiteral:\n    return cxstring::createRef(\"ImaginaryLiteral\");\n  case CXCursor_StringLiteral:\n    return cxstring::createRef(\"StringLiteral\");\n  case CXCursor_CharacterLiteral:\n    return cxstring::createRef(\"CharacterLiteral\");\n  case CXCursor_ParenExpr:\n    return cxstring::createRef(\"ParenExpr\");\n  case CXCursor_UnaryOperator:\n    return cxstring::createRef(\"UnaryOperator\");\n  case CXCursor_ArraySubscriptExpr:\n    return cxstring::createRef(\"ArraySubscriptExpr\");\n  case CXCursor_OMPArraySectionExpr:\n    return cxstring::createRef(\"OMPArraySectionExpr\");\n  case CXCursor_OMPArrayShapingExpr:\n    return cxstring::createRef(\"OMPArrayShapingExpr\");\n  case CXCursor_OMPIteratorExpr:\n    return cxstring::createRef(\"OMPIteratorExpr\");\n  case CXCursor_BinaryOperator:\n    return cxstring::createRef(\"BinaryOperator\");\n  case CXCursor_CompoundAssignOperator:\n    return cxstring::createRef(\"CompoundAssignOperator\");\n  case CXCursor_ConditionalOperator:\n    return cxstring::createRef(\"ConditionalOperator\");\n  case CXCursor_CStyleCastExpr:\n    return cxstring::createRef(\"CStyleCastExpr\");\n  case CXCursor_CompoundLiteralExpr:\n    return cxstring::createRef(\"CompoundLiteralExpr\");\n  case CXCursor_InitListExpr:\n    return cxstring::createRef(\"InitListExpr\");\n  case CXCursor_AddrLabelExpr:\n    return cxstring::createRef(\"AddrLabelExpr\");\n  case CXCursor_StmtExpr:\n    return cxstring::createRef(\"StmtExpr\");\n  case CXCursor_GenericSelectionExpr:\n    return cxstring::createRef(\"GenericSelectionExpr\");\n  case CXCursor_GNUNullExpr:\n    return cxstring::createRef(\"GNUNullExpr\");\n  case CXCursor_CXXStaticCastExpr:\n    return cxstring::createRef(\"CXXStaticCastExpr\");\n  case CXCursor_CXXDynamicCastExpr:\n    return cxstring::createRef(\"CXXDynamicCastExpr\");\n  case CXCursor_CXXReinterpretCastExpr:\n    return cxstring::createRef(\"CXXReinterpretCastExpr\");\n  case CXCursor_CXXConstCastExpr:\n    return cxstring::createRef(\"CXXConstCastExpr\");\n  case CXCursor_CXXFunctionalCastExpr:\n    return cxstring::createRef(\"CXXFunctionalCastExpr\");\n  case CXCursor_CXXAddrspaceCastExpr:\n    return cxstring::createRef(\"CXXAddrspaceCastExpr\");\n  case CXCursor_CXXTypeidExpr:\n    return cxstring::createRef(\"CXXTypeidExpr\");\n  case CXCursor_CXXBoolLiteralExpr:\n    return cxstring::createRef(\"CXXBoolLiteralExpr\");\n  case CXCursor_CXXNullPtrLiteralExpr:\n    return cxstring::createRef(\"CXXNullPtrLiteralExpr\");\n  case CXCursor_CXXThisExpr:\n    return cxstring::createRef(\"CXXThisExpr\");\n  case CXCursor_CXXThrowExpr:\n    return cxstring::createRef(\"CXXThrowExpr\");\n  case CXCursor_CXXNewExpr:\n    return cxstring::createRef(\"CXXNewExpr\");\n  case CXCursor_CXXDeleteExpr:\n    return cxstring::createRef(\"CXXDeleteExpr\");\n  case CXCursor_UnaryExpr:\n    return cxstring::createRef(\"UnaryExpr\");\n  case CXCursor_ObjCStringLiteral:\n    return cxstring::createRef(\"ObjCStringLiteral\");\n  case CXCursor_ObjCBoolLiteralExpr:\n    return cxstring::createRef(\"ObjCBoolLiteralExpr\");\n  case CXCursor_ObjCAvailabilityCheckExpr:\n    return cxstring::createRef(\"ObjCAvailabilityCheckExpr\");\n  case CXCursor_ObjCSelfExpr:\n    return cxstring::createRef(\"ObjCSelfExpr\");\n  case CXCursor_ObjCEncodeExpr:\n    return cxstring::createRef(\"ObjCEncodeExpr\");\n  case CXCursor_ObjCSelectorExpr:\n    return cxstring::createRef(\"ObjCSelectorExpr\");\n  case CXCursor_ObjCProtocolExpr:\n    return cxstring::createRef(\"ObjCProtocolExpr\");\n  case CXCursor_ObjCBridgedCastExpr:\n    return cxstring::createRef(\"ObjCBridgedCastExpr\");\n  case CXCursor_BlockExpr:\n    return cxstring::createRef(\"BlockExpr\");\n  case CXCursor_PackExpansionExpr:\n    return cxstring::createRef(\"PackExpansionExpr\");\n  case CXCursor_SizeOfPackExpr:\n    return cxstring::createRef(\"SizeOfPackExpr\");\n  case CXCursor_LambdaExpr:\n    return cxstring::createRef(\"LambdaExpr\");\n  case CXCursor_UnexposedExpr:\n    return cxstring::createRef(\"UnexposedExpr\");\n  case CXCursor_DeclRefExpr:\n    return cxstring::createRef(\"DeclRefExpr\");\n  case CXCursor_MemberRefExpr:\n    return cxstring::createRef(\"MemberRefExpr\");\n  case CXCursor_CallExpr:\n    return cxstring::createRef(\"CallExpr\");\n  case CXCursor_ObjCMessageExpr:\n    return cxstring::createRef(\"ObjCMessageExpr\");\n  case CXCursor_BuiltinBitCastExpr:\n    return cxstring::createRef(\"BuiltinBitCastExpr\");\n  case CXCursor_UnexposedStmt:\n    return cxstring::createRef(\"UnexposedStmt\");\n  case CXCursor_DeclStmt:\n    return cxstring::createRef(\"DeclStmt\");\n  case CXCursor_LabelStmt:\n    return cxstring::createRef(\"LabelStmt\");\n  case CXCursor_CompoundStmt:\n    return cxstring::createRef(\"CompoundStmt\");\n  case CXCursor_CaseStmt:\n    return cxstring::createRef(\"CaseStmt\");\n  case CXCursor_DefaultStmt:\n    return cxstring::createRef(\"DefaultStmt\");\n  case CXCursor_IfStmt:\n    return cxstring::createRef(\"IfStmt\");\n  case CXCursor_SwitchStmt:\n    return cxstring::createRef(\"SwitchStmt\");\n  case CXCursor_WhileStmt:\n    return cxstring::createRef(\"WhileStmt\");\n  case CXCursor_DoStmt:\n    return cxstring::createRef(\"DoStmt\");\n  case CXCursor_ForStmt:\n    return cxstring::createRef(\"ForStmt\");\n  case CXCursor_GotoStmt:\n    return cxstring::createRef(\"GotoStmt\");\n  case CXCursor_IndirectGotoStmt:\n    return cxstring::createRef(\"IndirectGotoStmt\");\n  case CXCursor_ContinueStmt:\n    return cxstring::createRef(\"ContinueStmt\");\n  case CXCursor_BreakStmt:\n    return cxstring::createRef(\"BreakStmt\");\n  case CXCursor_ReturnStmt:\n    return cxstring::createRef(\"ReturnStmt\");\n  case CXCursor_GCCAsmStmt:\n    return cxstring::createRef(\"GCCAsmStmt\");\n  case CXCursor_MSAsmStmt:\n    return cxstring::createRef(\"MSAsmStmt\");\n  case CXCursor_ObjCAtTryStmt:\n    return cxstring::createRef(\"ObjCAtTryStmt\");\n  case CXCursor_ObjCAtCatchStmt:\n    return cxstring::createRef(\"ObjCAtCatchStmt\");\n  case CXCursor_ObjCAtFinallyStmt:\n    return cxstring::createRef(\"ObjCAtFinallyStmt\");\n  case CXCursor_ObjCAtThrowStmt:\n    return cxstring::createRef(\"ObjCAtThrowStmt\");\n  case CXCursor_ObjCAtSynchronizedStmt:\n    return cxstring::createRef(\"ObjCAtSynchronizedStmt\");\n  case CXCursor_ObjCAutoreleasePoolStmt:\n    return cxstring::createRef(\"ObjCAutoreleasePoolStmt\");\n  case CXCursor_ObjCForCollectionStmt:\n    return cxstring::createRef(\"ObjCForCollectionStmt\");\n  case CXCursor_CXXCatchStmt:\n    return cxstring::createRef(\"CXXCatchStmt\");\n  case CXCursor_CXXTryStmt:\n    return cxstring::createRef(\"CXXTryStmt\");\n  case CXCursor_CXXForRangeStmt:\n    return cxstring::createRef(\"CXXForRangeStmt\");\n  case CXCursor_SEHTryStmt:\n    return cxstring::createRef(\"SEHTryStmt\");\n  case CXCursor_SEHExceptStmt:\n    return cxstring::createRef(\"SEHExceptStmt\");\n  case CXCursor_SEHFinallyStmt:\n    return cxstring::createRef(\"SEHFinallyStmt\");\n  case CXCursor_SEHLeaveStmt:\n    return cxstring::createRef(\"SEHLeaveStmt\");\n  case CXCursor_NullStmt:\n    return cxstring::createRef(\"NullStmt\");\n  case CXCursor_InvalidFile:\n    return cxstring::createRef(\"InvalidFile\");\n  case CXCursor_InvalidCode:\n    return cxstring::createRef(\"InvalidCode\");\n  case CXCursor_NoDeclFound:\n    return cxstring::createRef(\"NoDeclFound\");\n  case CXCursor_NotImplemented:\n    return cxstring::createRef(\"NotImplemented\");\n  case CXCursor_TranslationUnit:\n    return cxstring::createRef(\"TranslationUnit\");\n  case CXCursor_UnexposedAttr:\n    return cxstring::createRef(\"UnexposedAttr\");\n  case CXCursor_IBActionAttr:\n    return cxstring::createRef(\"attribute(ibaction)\");\n  case CXCursor_IBOutletAttr:\n    return cxstring::createRef(\"attribute(iboutlet)\");\n  case CXCursor_IBOutletCollectionAttr:\n    return cxstring::createRef(\"attribute(iboutletcollection)\");\n  case CXCursor_CXXFinalAttr:\n    return cxstring::createRef(\"attribute(final)\");\n  case CXCursor_CXXOverrideAttr:\n    return cxstring::createRef(\"attribute(override)\");\n  case CXCursor_AnnotateAttr:\n    return cxstring::createRef(\"attribute(annotate)\");\n  case CXCursor_AsmLabelAttr:\n    return cxstring::createRef(\"asm label\");\n  case CXCursor_PackedAttr:\n    return cxstring::createRef(\"attribute(packed)\");\n  case CXCursor_PureAttr:\n    return cxstring::createRef(\"attribute(pure)\");\n  case CXCursor_ConstAttr:\n    return cxstring::createRef(\"attribute(const)\");\n  case CXCursor_NoDuplicateAttr:\n    return cxstring::createRef(\"attribute(noduplicate)\");\n  case CXCursor_CUDAConstantAttr:\n    return cxstring::createRef(\"attribute(constant)\");\n  case CXCursor_CUDADeviceAttr:\n    return cxstring::createRef(\"attribute(device)\");\n  case CXCursor_CUDAGlobalAttr:\n    return cxstring::createRef(\"attribute(global)\");\n  case CXCursor_CUDAHostAttr:\n    return cxstring::createRef(\"attribute(host)\");\n  case CXCursor_CUDASharedAttr:\n    return cxstring::createRef(\"attribute(shared)\");\n  case CXCursor_VisibilityAttr:\n    return cxstring::createRef(\"attribute(visibility)\");\n  case CXCursor_DLLExport:\n    return cxstring::createRef(\"attribute(dllexport)\");\n  case CXCursor_DLLImport:\n    return cxstring::createRef(\"attribute(dllimport)\");\n  case CXCursor_NSReturnsRetained:\n    return cxstring::createRef(\"attribute(ns_returns_retained)\");\n  case CXCursor_NSReturnsNotRetained:\n    return cxstring::createRef(\"attribute(ns_returns_not_retained)\");\n  case CXCursor_NSReturnsAutoreleased:\n    return cxstring::createRef(\"attribute(ns_returns_autoreleased)\");\n  case CXCursor_NSConsumesSelf:\n    return cxstring::createRef(\"attribute(ns_consumes_self)\");\n  case CXCursor_NSConsumed:\n    return cxstring::createRef(\"attribute(ns_consumed)\");\n  case CXCursor_ObjCException:\n    return cxstring::createRef(\"attribute(objc_exception)\");\n  case CXCursor_ObjCNSObject:\n    return cxstring::createRef(\"attribute(NSObject)\");\n  case CXCursor_ObjCIndependentClass:\n    return cxstring::createRef(\"attribute(objc_independent_class)\");\n  case CXCursor_ObjCPreciseLifetime:\n    return cxstring::createRef(\"attribute(objc_precise_lifetime)\");\n  case CXCursor_ObjCReturnsInnerPointer:\n    return cxstring::createRef(\"attribute(objc_returns_inner_pointer)\");\n  case CXCursor_ObjCRequiresSuper:\n    return cxstring::createRef(\"attribute(objc_requires_super)\");\n  case CXCursor_ObjCRootClass:\n    return cxstring::createRef(\"attribute(objc_root_class)\");\n  case CXCursor_ObjCSubclassingRestricted:\n    return cxstring::createRef(\"attribute(objc_subclassing_restricted)\");\n  case CXCursor_ObjCExplicitProtocolImpl:\n    return cxstring::createRef(\n        \"attribute(objc_protocol_requires_explicit_implementation)\");\n  case CXCursor_ObjCDesignatedInitializer:\n    return cxstring::createRef(\"attribute(objc_designated_initializer)\");\n  case CXCursor_ObjCRuntimeVisible:\n    return cxstring::createRef(\"attribute(objc_runtime_visible)\");\n  case CXCursor_ObjCBoxable:\n    return cxstring::createRef(\"attribute(objc_boxable)\");\n  case CXCursor_FlagEnum:\n    return cxstring::createRef(\"attribute(flag_enum)\");\n  case CXCursor_PreprocessingDirective:\n    return cxstring::createRef(\"preprocessing directive\");\n  case CXCursor_MacroDefinition:\n    return cxstring::createRef(\"macro definition\");\n  case CXCursor_MacroExpansion:\n    return cxstring::createRef(\"macro expansion\");\n  case CXCursor_InclusionDirective:\n    return cxstring::createRef(\"inclusion directive\");\n  case CXCursor_Namespace:\n    return cxstring::createRef(\"Namespace\");\n  case CXCursor_LinkageSpec:\n    return cxstring::createRef(\"LinkageSpec\");\n  case CXCursor_CXXBaseSpecifier:\n    return cxstring::createRef(\"C++ base class specifier\");\n  case CXCursor_Constructor:\n    return cxstring::createRef(\"CXXConstructor\");\n  case CXCursor_Destructor:\n    return cxstring::createRef(\"CXXDestructor\");\n  case CXCursor_ConversionFunction:\n    return cxstring::createRef(\"CXXConversion\");\n  case CXCursor_TemplateTypeParameter:\n    return cxstring::createRef(\"TemplateTypeParameter\");\n  case CXCursor_NonTypeTemplateParameter:\n    return cxstring::createRef(\"NonTypeTemplateParameter\");\n  case CXCursor_TemplateTemplateParameter:\n    return cxstring::createRef(\"TemplateTemplateParameter\");\n  case CXCursor_FunctionTemplate:\n    return cxstring::createRef(\"FunctionTemplate\");\n  case CXCursor_ClassTemplate:\n    return cxstring::createRef(\"ClassTemplate\");\n  case CXCursor_ClassTemplatePartialSpecialization:\n    return cxstring::createRef(\"ClassTemplatePartialSpecialization\");\n  case CXCursor_NamespaceAlias:\n    return cxstring::createRef(\"NamespaceAlias\");\n  case CXCursor_UsingDirective:\n    return cxstring::createRef(\"UsingDirective\");\n  case CXCursor_UsingDeclaration:\n    return cxstring::createRef(\"UsingDeclaration\");\n  case CXCursor_TypeAliasDecl:\n    return cxstring::createRef(\"TypeAliasDecl\");\n  case CXCursor_ObjCSynthesizeDecl:\n    return cxstring::createRef(\"ObjCSynthesizeDecl\");\n  case CXCursor_ObjCDynamicDecl:\n    return cxstring::createRef(\"ObjCDynamicDecl\");\n  case CXCursor_CXXAccessSpecifier:\n    return cxstring::createRef(\"CXXAccessSpecifier\");\n  case CXCursor_ModuleImportDecl:\n    return cxstring::createRef(\"ModuleImport\");\n  case CXCursor_OMPCanonicalLoop:\n    return cxstring::createRef(\"OMPCanonicalLoop\");\n  case CXCursor_OMPParallelDirective:\n    return cxstring::createRef(\"OMPParallelDirective\");\n  case CXCursor_OMPSimdDirective:\n    return cxstring::createRef(\"OMPSimdDirective\");\n  case CXCursor_OMPTileDirective:\n    return cxstring::createRef(\"OMPTileDirective\");\n  case CXCursor_OMPForDirective:\n    return cxstring::createRef(\"OMPForDirective\");\n  case CXCursor_OMPForSimdDirective:\n    return cxstring::createRef(\"OMPForSimdDirective\");\n  case CXCursor_OMPSectionsDirective:\n    return cxstring::createRef(\"OMPSectionsDirective\");\n  case CXCursor_OMPSectionDirective:\n    return cxstring::createRef(\"OMPSectionDirective\");\n  case CXCursor_OMPSingleDirective:\n    return cxstring::createRef(\"OMPSingleDirective\");\n  case CXCursor_OMPMasterDirective:\n    return cxstring::createRef(\"OMPMasterDirective\");\n  case CXCursor_OMPCriticalDirective:\n    return cxstring::createRef(\"OMPCriticalDirective\");\n  case CXCursor_OMPParallelForDirective:\n    return cxstring::createRef(\"OMPParallelForDirective\");\n  case CXCursor_OMPParallelForSimdDirective:\n    return cxstring::createRef(\"OMPParallelForSimdDirective\");\n  case CXCursor_OMPParallelMasterDirective:\n    return cxstring::createRef(\"OMPParallelMasterDirective\");\n  case CXCursor_OMPParallelSectionsDirective:\n    return cxstring::createRef(\"OMPParallelSectionsDirective\");\n  case CXCursor_OMPTaskDirective:\n    return cxstring::createRef(\"OMPTaskDirective\");\n  case CXCursor_OMPTaskyieldDirective:\n    return cxstring::createRef(\"OMPTaskyieldDirective\");\n  case CXCursor_OMPBarrierDirective:\n    return cxstring::createRef(\"OMPBarrierDirective\");\n  case CXCursor_OMPTaskwaitDirective:\n    return cxstring::createRef(\"OMPTaskwaitDirective\");\n  case CXCursor_OMPTaskgroupDirective:\n    return cxstring::createRef(\"OMPTaskgroupDirective\");\n  case CXCursor_OMPFlushDirective:\n    return cxstring::createRef(\"OMPFlushDirective\");\n  case CXCursor_OMPDepobjDirective:\n    return cxstring::createRef(\"OMPDepobjDirective\");\n  case CXCursor_OMPScanDirective:\n    return cxstring::createRef(\"OMPScanDirective\");\n  case CXCursor_OMPOrderedDirective:\n    return cxstring::createRef(\"OMPOrderedDirective\");\n  case CXCursor_OMPAtomicDirective:\n    return cxstring::createRef(\"OMPAtomicDirective\");\n  case CXCursor_OMPTargetDirective:\n    return cxstring::createRef(\"OMPTargetDirective\");\n  case CXCursor_OMPTargetDataDirective:\n    return cxstring::createRef(\"OMPTargetDataDirective\");\n  case CXCursor_OMPTargetEnterDataDirective:\n    return cxstring::createRef(\"OMPTargetEnterDataDirective\");\n  case CXCursor_OMPTargetExitDataDirective:\n    return cxstring::createRef(\"OMPTargetExitDataDirective\");\n  case CXCursor_OMPTargetParallelDirective:\n    return cxstring::createRef(\"OMPTargetParallelDirective\");\n  case CXCursor_OMPTargetParallelForDirective:\n    return cxstring::createRef(\"OMPTargetParallelForDirective\");\n  case CXCursor_OMPTargetUpdateDirective:\n    return cxstring::createRef(\"OMPTargetUpdateDirective\");\n  case CXCursor_OMPTeamsDirective:\n    return cxstring::createRef(\"OMPTeamsDirective\");\n  case CXCursor_OMPCancellationPointDirective:\n    return cxstring::createRef(\"OMPCancellationPointDirective\");\n  case CXCursor_OMPCancelDirective:\n    return cxstring::createRef(\"OMPCancelDirective\");\n  case CXCursor_OMPTaskLoopDirective:\n    return cxstring::createRef(\"OMPTaskLoopDirective\");\n  case CXCursor_OMPTaskLoopSimdDirective:\n    return cxstring::createRef(\"OMPTaskLoopSimdDirective\");\n  case CXCursor_OMPMasterTaskLoopDirective:\n    return cxstring::createRef(\"OMPMasterTaskLoopDirective\");\n  case CXCursor_OMPMasterTaskLoopSimdDirective:\n    return cxstring::createRef(\"OMPMasterTaskLoopSimdDirective\");\n  case CXCursor_OMPParallelMasterTaskLoopDirective:\n    return cxstring::createRef(\"OMPParallelMasterTaskLoopDirective\");\n  case CXCursor_OMPParallelMasterTaskLoopSimdDirective:\n    return cxstring::createRef(\"OMPParallelMasterTaskLoopSimdDirective\");\n  case CXCursor_OMPDistributeDirective:\n    return cxstring::createRef(\"OMPDistributeDirective\");\n  case CXCursor_OMPDistributeParallelForDirective:\n    return cxstring::createRef(\"OMPDistributeParallelForDirective\");\n  case CXCursor_OMPDistributeParallelForSimdDirective:\n    return cxstring::createRef(\"OMPDistributeParallelForSimdDirective\");\n  case CXCursor_OMPDistributeSimdDirective:\n    return cxstring::createRef(\"OMPDistributeSimdDirective\");\n  case CXCursor_OMPTargetParallelForSimdDirective:\n    return cxstring::createRef(\"OMPTargetParallelForSimdDirective\");\n  case CXCursor_OMPTargetSimdDirective:\n    return cxstring::createRef(\"OMPTargetSimdDirective\");\n  case CXCursor_OMPTeamsDistributeDirective:\n    return cxstring::createRef(\"OMPTeamsDistributeDirective\");\n  case CXCursor_OMPTeamsDistributeSimdDirective:\n    return cxstring::createRef(\"OMPTeamsDistributeSimdDirective\");\n  case CXCursor_OMPTeamsDistributeParallelForSimdDirective:\n    return cxstring::createRef(\"OMPTeamsDistributeParallelForSimdDirective\");\n  case CXCursor_OMPTeamsDistributeParallelForDirective:\n    return cxstring::createRef(\"OMPTeamsDistributeParallelForDirective\");\n  case CXCursor_OMPTargetTeamsDirective:\n    return cxstring::createRef(\"OMPTargetTeamsDirective\");\n  case CXCursor_OMPTargetTeamsDistributeDirective:\n    return cxstring::createRef(\"OMPTargetTeamsDistributeDirective\");\n  case CXCursor_OMPTargetTeamsDistributeParallelForDirective:\n    return cxstring::createRef(\"OMPTargetTeamsDistributeParallelForDirective\");\n  case CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective:\n    return cxstring::createRef(\n        \"OMPTargetTeamsDistributeParallelForSimdDirective\");\n  case CXCursor_OMPTargetTeamsDistributeSimdDirective:\n    return cxstring::createRef(\"OMPTargetTeamsDistributeSimdDirective\");\n  case CXCursor_OverloadCandidate:\n    return cxstring::createRef(\"OverloadCandidate\");\n  case CXCursor_TypeAliasTemplateDecl:\n    return cxstring::createRef(\"TypeAliasTemplateDecl\");\n  case CXCursor_StaticAssert:\n    return cxstring::createRef(\"StaticAssert\");\n  case CXCursor_FriendDecl:\n    return cxstring::createRef(\"FriendDecl\");\n  case CXCursor_ConvergentAttr:\n    return cxstring::createRef(\"attribute(convergent)\");\n  case CXCursor_WarnUnusedAttr:\n    return cxstring::createRef(\"attribute(warn_unused)\");\n  case CXCursor_WarnUnusedResultAttr:\n    return cxstring::createRef(\"attribute(warn_unused_result)\");\n  case CXCursor_AlignedAttr:\n    return cxstring::createRef(\"attribute(aligned)\");\n  }\n\n  llvm_unreachable(\"Unhandled CXCursorKind\");\n}\n\nstruct GetCursorData {\n  SourceLocation TokenBeginLoc;\n  bool PointsAtMacroArgExpansion;\n  bool VisitedObjCPropertyImplDecl;\n  SourceLocation VisitedDeclaratorDeclStartLoc;\n  CXCursor &BestCursor;\n\n  GetCursorData(SourceManager &SM, SourceLocation tokenBegin,\n                CXCursor &outputCursor)\n      : TokenBeginLoc(tokenBegin), BestCursor(outputCursor) {\n    PointsAtMacroArgExpansion = SM.isMacroArgExpansion(tokenBegin);\n    VisitedObjCPropertyImplDecl = false;\n  }\n};\n\nstatic enum CXChildVisitResult\nGetCursorVisitor(CXCursor cursor, CXCursor parent, CXClientData client_data) {\n  GetCursorData *Data = static_cast<GetCursorData *>(client_data);\n  CXCursor *BestCursor = &Data->BestCursor;\n\n  // If we point inside a macro argument we should provide info of what the\n  // token is so use the actual cursor, don't replace it with a macro expansion\n  // cursor.\n  if (cursor.kind == CXCursor_MacroExpansion && Data->PointsAtMacroArgExpansion)\n    return CXChildVisit_Recurse;\n\n  if (clang_isDeclaration(cursor.kind)) {\n    // Avoid having the implicit methods override the property decls.\n    if (const ObjCMethodDecl *MD =\n            dyn_cast_or_null<ObjCMethodDecl>(getCursorDecl(cursor))) {\n      if (MD->isImplicit())\n        return CXChildVisit_Break;\n\n    } else if (const ObjCInterfaceDecl *ID =\n                   dyn_cast_or_null<ObjCInterfaceDecl>(getCursorDecl(cursor))) {\n      // Check that when we have multiple @class references in the same line,\n      // that later ones do not override the previous ones.\n      // If we have:\n      // @class Foo, Bar;\n      // source ranges for both start at '@', so 'Bar' will end up overriding\n      // 'Foo' even though the cursor location was at 'Foo'.\n      if (BestCursor->kind == CXCursor_ObjCInterfaceDecl ||\n          BestCursor->kind == CXCursor_ObjCClassRef)\n        if (const ObjCInterfaceDecl *PrevID =\n                dyn_cast_or_null<ObjCInterfaceDecl>(\n                    getCursorDecl(*BestCursor))) {\n          if (PrevID != ID && !PrevID->isThisDeclarationADefinition() &&\n              !ID->isThisDeclarationADefinition())\n            return CXChildVisit_Break;\n        }\n\n    } else if (const DeclaratorDecl *DD =\n                   dyn_cast_or_null<DeclaratorDecl>(getCursorDecl(cursor))) {\n      SourceLocation StartLoc = DD->getSourceRange().getBegin();\n      // Check that when we have multiple declarators in the same line,\n      // that later ones do not override the previous ones.\n      // If we have:\n      // int Foo, Bar;\n      // source ranges for both start at 'int', so 'Bar' will end up overriding\n      // 'Foo' even though the cursor location was at 'Foo'.\n      if (Data->VisitedDeclaratorDeclStartLoc == StartLoc)\n        return CXChildVisit_Break;\n      Data->VisitedDeclaratorDeclStartLoc = StartLoc;\n\n    } else if (const ObjCPropertyImplDecl *PropImp =\n                   dyn_cast_or_null<ObjCPropertyImplDecl>(\n                       getCursorDecl(cursor))) {\n      (void)PropImp;\n      // Check that when we have multiple @synthesize in the same line,\n      // that later ones do not override the previous ones.\n      // If we have:\n      // @synthesize Foo, Bar;\n      // source ranges for both start at '@', so 'Bar' will end up overriding\n      // 'Foo' even though the cursor location was at 'Foo'.\n      if (Data->VisitedObjCPropertyImplDecl)\n        return CXChildVisit_Break;\n      Data->VisitedObjCPropertyImplDecl = true;\n    }\n  }\n\n  if (clang_isExpression(cursor.kind) &&\n      clang_isDeclaration(BestCursor->kind)) {\n    if (const Decl *D = getCursorDecl(*BestCursor)) {\n      // Avoid having the cursor of an expression replace the declaration cursor\n      // when the expression source range overlaps the declaration range.\n      // This can happen for C++ constructor expressions whose range generally\n      // include the variable declaration, e.g.:\n      //  MyCXXClass foo; // Make sure pointing at 'foo' returns a VarDecl\n      //  cursor.\n      if (D->getLocation().isValid() && Data->TokenBeginLoc.isValid() &&\n          D->getLocation() == Data->TokenBeginLoc)\n        return CXChildVisit_Break;\n    }\n  }\n\n  // If our current best cursor is the construction of a temporary object,\n  // don't replace that cursor with a type reference, because we want\n  // clang_getCursor() to point at the constructor.\n  if (clang_isExpression(BestCursor->kind) &&\n      isa<CXXTemporaryObjectExpr>(getCursorExpr(*BestCursor)) &&\n      cursor.kind == CXCursor_TypeRef) {\n    // Keep the cursor pointing at CXXTemporaryObjectExpr but also mark it\n    // as having the actual point on the type reference.\n    *BestCursor = getTypeRefedCallExprCursor(*BestCursor);\n    return CXChildVisit_Recurse;\n  }\n\n  // If we already have an Objective-C superclass reference, don't\n  // update it further.\n  if (BestCursor->kind == CXCursor_ObjCSuperClassRef)\n    return CXChildVisit_Break;\n\n  *BestCursor = cursor;\n  return CXChildVisit_Recurse;\n}\n\nCXCursor clang_getCursor(CXTranslationUnit TU, CXSourceLocation Loc) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return clang_getNullCursor();\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  ASTUnit::ConcurrencyCheck Check(*CXXUnit);\n\n  SourceLocation SLoc = cxloc::translateSourceLocation(Loc);\n  CXCursor Result = cxcursor::getCursor(TU, SLoc);\n\n  LOG_FUNC_SECTION {\n    CXFile SearchFile;\n    unsigned SearchLine, SearchColumn;\n    CXFile ResultFile;\n    unsigned ResultLine, ResultColumn;\n    CXString SearchFileName, ResultFileName, KindSpelling, USR;\n    const char *IsDef = clang_isCursorDefinition(Result) ? \" (Definition)\" : \"\";\n    CXSourceLocation ResultLoc = clang_getCursorLocation(Result);\n\n    clang_getFileLocation(Loc, &SearchFile, &SearchLine, &SearchColumn,\n                          nullptr);\n    clang_getFileLocation(ResultLoc, &ResultFile, &ResultLine, &ResultColumn,\n                          nullptr);\n    SearchFileName = clang_getFileName(SearchFile);\n    ResultFileName = clang_getFileName(ResultFile);\n    KindSpelling = clang_getCursorKindSpelling(Result.kind);\n    USR = clang_getCursorUSR(Result);\n    *Log << llvm::format(\"(%s:%d:%d) = %s\", clang_getCString(SearchFileName),\n                         SearchLine, SearchColumn,\n                         clang_getCString(KindSpelling))\n         << llvm::format(\"(%s:%d:%d):%s%s\", clang_getCString(ResultFileName),\n                         ResultLine, ResultColumn, clang_getCString(USR),\n                         IsDef);\n    clang_disposeString(SearchFileName);\n    clang_disposeString(ResultFileName);\n    clang_disposeString(KindSpelling);\n    clang_disposeString(USR);\n\n    CXCursor Definition = clang_getCursorDefinition(Result);\n    if (!clang_equalCursors(Definition, clang_getNullCursor())) {\n      CXSourceLocation DefinitionLoc = clang_getCursorLocation(Definition);\n      CXString DefinitionKindSpelling =\n          clang_getCursorKindSpelling(Definition.kind);\n      CXFile DefinitionFile;\n      unsigned DefinitionLine, DefinitionColumn;\n      clang_getFileLocation(DefinitionLoc, &DefinitionFile, &DefinitionLine,\n                            &DefinitionColumn, nullptr);\n      CXString DefinitionFileName = clang_getFileName(DefinitionFile);\n      *Log << llvm::format(\"  -> %s(%s:%d:%d)\",\n                           clang_getCString(DefinitionKindSpelling),\n                           clang_getCString(DefinitionFileName), DefinitionLine,\n                           DefinitionColumn);\n      clang_disposeString(DefinitionFileName);\n      clang_disposeString(DefinitionKindSpelling);\n    }\n  }\n\n  return Result;\n}\n\nCXCursor clang_getNullCursor(void) {\n  return MakeCXCursorInvalid(CXCursor_InvalidFile);\n}\n\nunsigned clang_equalCursors(CXCursor X, CXCursor Y) {\n  // Clear out the \"FirstInDeclGroup\" part in a declaration cursor, since we\n  // can't set consistently. For example, when visiting a DeclStmt we will set\n  // it but we don't set it on the result of clang_getCursorDefinition for\n  // a reference of the same declaration.\n  // FIXME: Setting \"FirstInDeclGroup\" in CXCursors is a hack that only works\n  // when visiting a DeclStmt currently, the AST should be enhanced to be able\n  // to provide that kind of info.\n  if (clang_isDeclaration(X.kind))\n    X.data[1] = nullptr;\n  if (clang_isDeclaration(Y.kind))\n    Y.data[1] = nullptr;\n\n  return X == Y;\n}\n\nunsigned clang_hashCursor(CXCursor C) {\n  unsigned Index = 0;\n  if (clang_isExpression(C.kind) || clang_isStatement(C.kind))\n    Index = 1;\n\n  return llvm::DenseMapInfo<std::pair<unsigned, const void *>>::getHashValue(\n      std::make_pair(C.kind, C.data[Index]));\n}\n\nunsigned clang_isInvalid(enum CXCursorKind K) {\n  return K >= CXCursor_FirstInvalid && K <= CXCursor_LastInvalid;\n}\n\nunsigned clang_isDeclaration(enum CXCursorKind K) {\n  return (K >= CXCursor_FirstDecl && K <= CXCursor_LastDecl) ||\n         (K >= CXCursor_FirstExtraDecl && K <= CXCursor_LastExtraDecl);\n}\n\nunsigned clang_isInvalidDeclaration(CXCursor C) {\n  if (clang_isDeclaration(C.kind)) {\n    if (const Decl *D = getCursorDecl(C))\n      return D->isInvalidDecl();\n  }\n\n  return 0;\n}\n\nunsigned clang_isReference(enum CXCursorKind K) {\n  return K >= CXCursor_FirstRef && K <= CXCursor_LastRef;\n}\n\nunsigned clang_isExpression(enum CXCursorKind K) {\n  return K >= CXCursor_FirstExpr && K <= CXCursor_LastExpr;\n}\n\nunsigned clang_isStatement(enum CXCursorKind K) {\n  return K >= CXCursor_FirstStmt && K <= CXCursor_LastStmt;\n}\n\nunsigned clang_isAttribute(enum CXCursorKind K) {\n  return K >= CXCursor_FirstAttr && K <= CXCursor_LastAttr;\n}\n\nunsigned clang_isTranslationUnit(enum CXCursorKind K) {\n  return K == CXCursor_TranslationUnit;\n}\n\nunsigned clang_isPreprocessing(enum CXCursorKind K) {\n  return K >= CXCursor_FirstPreprocessing && K <= CXCursor_LastPreprocessing;\n}\n\nunsigned clang_isUnexposed(enum CXCursorKind K) {\n  switch (K) {\n  case CXCursor_UnexposedDecl:\n  case CXCursor_UnexposedExpr:\n  case CXCursor_UnexposedStmt:\n  case CXCursor_UnexposedAttr:\n    return true;\n  default:\n    return false;\n  }\n}\n\nCXCursorKind clang_getCursorKind(CXCursor C) { return C.kind; }\n\nCXSourceLocation clang_getCursorLocation(CXCursor C) {\n  if (clang_isReference(C.kind)) {\n    switch (C.kind) {\n    case CXCursor_ObjCSuperClassRef: {\n      std::pair<const ObjCInterfaceDecl *, SourceLocation> P =\n          getCursorObjCSuperClassRef(C);\n      return cxloc::translateSourceLocation(P.first->getASTContext(), P.second);\n    }\n\n    case CXCursor_ObjCProtocolRef: {\n      std::pair<const ObjCProtocolDecl *, SourceLocation> P =\n          getCursorObjCProtocolRef(C);\n      return cxloc::translateSourceLocation(P.first->getASTContext(), P.second);\n    }\n\n    case CXCursor_ObjCClassRef: {\n      std::pair<const ObjCInterfaceDecl *, SourceLocation> P =\n          getCursorObjCClassRef(C);\n      return cxloc::translateSourceLocation(P.first->getASTContext(), P.second);\n    }\n\n    case CXCursor_TypeRef: {\n      std::pair<const TypeDecl *, SourceLocation> P = getCursorTypeRef(C);\n      return cxloc::translateSourceLocation(P.first->getASTContext(), P.second);\n    }\n\n    case CXCursor_TemplateRef: {\n      std::pair<const TemplateDecl *, SourceLocation> P =\n          getCursorTemplateRef(C);\n      return cxloc::translateSourceLocation(P.first->getASTContext(), P.second);\n    }\n\n    case CXCursor_NamespaceRef: {\n      std::pair<const NamedDecl *, SourceLocation> P = getCursorNamespaceRef(C);\n      return cxloc::translateSourceLocation(P.first->getASTContext(), P.second);\n    }\n\n    case CXCursor_MemberRef: {\n      std::pair<const FieldDecl *, SourceLocation> P = getCursorMemberRef(C);\n      return cxloc::translateSourceLocation(P.first->getASTContext(), P.second);\n    }\n\n    case CXCursor_VariableRef: {\n      std::pair<const VarDecl *, SourceLocation> P = getCursorVariableRef(C);\n      return cxloc::translateSourceLocation(P.first->getASTContext(), P.second);\n    }\n\n    case CXCursor_CXXBaseSpecifier: {\n      const CXXBaseSpecifier *BaseSpec = getCursorCXXBaseSpecifier(C);\n      if (!BaseSpec)\n        return clang_getNullLocation();\n\n      if (TypeSourceInfo *TSInfo = BaseSpec->getTypeSourceInfo())\n        return cxloc::translateSourceLocation(\n            getCursorContext(C), TSInfo->getTypeLoc().getBeginLoc());\n\n      return cxloc::translateSourceLocation(getCursorContext(C),\n                                            BaseSpec->getBeginLoc());\n    }\n\n    case CXCursor_LabelRef: {\n      std::pair<const LabelStmt *, SourceLocation> P = getCursorLabelRef(C);\n      return cxloc::translateSourceLocation(getCursorContext(C), P.second);\n    }\n\n    case CXCursor_OverloadedDeclRef:\n      return cxloc::translateSourceLocation(\n          getCursorContext(C), getCursorOverloadedDeclRef(C).second);\n\n    default:\n      // FIXME: Need a way to enumerate all non-reference cases.\n      llvm_unreachable(\"Missed a reference kind\");\n    }\n  }\n\n  if (clang_isExpression(C.kind))\n    return cxloc::translateSourceLocation(\n        getCursorContext(C), getLocationFromExpr(getCursorExpr(C)));\n\n  if (clang_isStatement(C.kind))\n    return cxloc::translateSourceLocation(getCursorContext(C),\n                                          getCursorStmt(C)->getBeginLoc());\n\n  if (C.kind == CXCursor_PreprocessingDirective) {\n    SourceLocation L = cxcursor::getCursorPreprocessingDirective(C).getBegin();\n    return cxloc::translateSourceLocation(getCursorContext(C), L);\n  }\n\n  if (C.kind == CXCursor_MacroExpansion) {\n    SourceLocation L =\n        cxcursor::getCursorMacroExpansion(C).getSourceRange().getBegin();\n    return cxloc::translateSourceLocation(getCursorContext(C), L);\n  }\n\n  if (C.kind == CXCursor_MacroDefinition) {\n    SourceLocation L = cxcursor::getCursorMacroDefinition(C)->getLocation();\n    return cxloc::translateSourceLocation(getCursorContext(C), L);\n  }\n\n  if (C.kind == CXCursor_InclusionDirective) {\n    SourceLocation L =\n        cxcursor::getCursorInclusionDirective(C)->getSourceRange().getBegin();\n    return cxloc::translateSourceLocation(getCursorContext(C), L);\n  }\n\n  if (clang_isAttribute(C.kind)) {\n    SourceLocation L = cxcursor::getCursorAttr(C)->getLocation();\n    return cxloc::translateSourceLocation(getCursorContext(C), L);\n  }\n\n  if (!clang_isDeclaration(C.kind))\n    return clang_getNullLocation();\n\n  const Decl *D = getCursorDecl(C);\n  if (!D)\n    return clang_getNullLocation();\n\n  SourceLocation Loc = D->getLocation();\n  // FIXME: Multiple variables declared in a single declaration\n  // currently lack the information needed to correctly determine their\n  // ranges when accounting for the type-specifier.  We use context\n  // stored in the CXCursor to determine if the VarDecl is in a DeclGroup,\n  // and if so, whether it is the first decl.\n  if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {\n    if (!cxcursor::isFirstInDeclGroup(C))\n      Loc = VD->getLocation();\n  }\n\n  // For ObjC methods, give the start location of the method name.\n  if (const ObjCMethodDecl *MD = dyn_cast<ObjCMethodDecl>(D))\n    Loc = MD->getSelectorStartLoc();\n\n  return cxloc::translateSourceLocation(getCursorContext(C), Loc);\n}\n\n} // end extern \"C\"\n\nCXCursor cxcursor::getCursor(CXTranslationUnit TU, SourceLocation SLoc) {\n  assert(TU);\n\n  // Guard against an invalid SourceLocation, or we may assert in one\n  // of the following calls.\n  if (SLoc.isInvalid())\n    return clang_getNullCursor();\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n\n  // Translate the given source location to make it point at the beginning of\n  // the token under the cursor.\n  SLoc = Lexer::GetBeginningOfToken(SLoc, CXXUnit->getSourceManager(),\n                                    CXXUnit->getASTContext().getLangOpts());\n\n  CXCursor Result = MakeCXCursorInvalid(CXCursor_NoDeclFound);\n  if (SLoc.isValid()) {\n    GetCursorData ResultData(CXXUnit->getSourceManager(), SLoc, Result);\n    CursorVisitor CursorVis(TU, GetCursorVisitor, &ResultData,\n                            /*VisitPreprocessorLast=*/true,\n                            /*VisitIncludedEntities=*/false,\n                            SourceLocation(SLoc));\n    CursorVis.visitFileRegion();\n  }\n\n  return Result;\n}\n\nstatic SourceRange getRawCursorExtent(CXCursor C) {\n  if (clang_isReference(C.kind)) {\n    switch (C.kind) {\n    case CXCursor_ObjCSuperClassRef:\n      return getCursorObjCSuperClassRef(C).second;\n\n    case CXCursor_ObjCProtocolRef:\n      return getCursorObjCProtocolRef(C).second;\n\n    case CXCursor_ObjCClassRef:\n      return getCursorObjCClassRef(C).second;\n\n    case CXCursor_TypeRef:\n      return getCursorTypeRef(C).second;\n\n    case CXCursor_TemplateRef:\n      return getCursorTemplateRef(C).second;\n\n    case CXCursor_NamespaceRef:\n      return getCursorNamespaceRef(C).second;\n\n    case CXCursor_MemberRef:\n      return getCursorMemberRef(C).second;\n\n    case CXCursor_CXXBaseSpecifier:\n      return getCursorCXXBaseSpecifier(C)->getSourceRange();\n\n    case CXCursor_LabelRef:\n      return getCursorLabelRef(C).second;\n\n    case CXCursor_OverloadedDeclRef:\n      return getCursorOverloadedDeclRef(C).second;\n\n    case CXCursor_VariableRef:\n      return getCursorVariableRef(C).second;\n\n    default:\n      // FIXME: Need a way to enumerate all non-reference cases.\n      llvm_unreachable(\"Missed a reference kind\");\n    }\n  }\n\n  if (clang_isExpression(C.kind))\n    return getCursorExpr(C)->getSourceRange();\n\n  if (clang_isStatement(C.kind))\n    return getCursorStmt(C)->getSourceRange();\n\n  if (clang_isAttribute(C.kind))\n    return getCursorAttr(C)->getRange();\n\n  if (C.kind == CXCursor_PreprocessingDirective)\n    return cxcursor::getCursorPreprocessingDirective(C);\n\n  if (C.kind == CXCursor_MacroExpansion) {\n    ASTUnit *TU = getCursorASTUnit(C);\n    SourceRange Range = cxcursor::getCursorMacroExpansion(C).getSourceRange();\n    return TU->mapRangeFromPreamble(Range);\n  }\n\n  if (C.kind == CXCursor_MacroDefinition) {\n    ASTUnit *TU = getCursorASTUnit(C);\n    SourceRange Range = cxcursor::getCursorMacroDefinition(C)->getSourceRange();\n    return TU->mapRangeFromPreamble(Range);\n  }\n\n  if (C.kind == CXCursor_InclusionDirective) {\n    ASTUnit *TU = getCursorASTUnit(C);\n    SourceRange Range =\n        cxcursor::getCursorInclusionDirective(C)->getSourceRange();\n    return TU->mapRangeFromPreamble(Range);\n  }\n\n  if (C.kind == CXCursor_TranslationUnit) {\n    ASTUnit *TU = getCursorASTUnit(C);\n    FileID MainID = TU->getSourceManager().getMainFileID();\n    SourceLocation Start = TU->getSourceManager().getLocForStartOfFile(MainID);\n    SourceLocation End = TU->getSourceManager().getLocForEndOfFile(MainID);\n    return SourceRange(Start, End);\n  }\n\n  if (clang_isDeclaration(C.kind)) {\n    const Decl *D = cxcursor::getCursorDecl(C);\n    if (!D)\n      return SourceRange();\n\n    SourceRange R = D->getSourceRange();\n    // FIXME: Multiple variables declared in a single declaration\n    // currently lack the information needed to correctly determine their\n    // ranges when accounting for the type-specifier.  We use context\n    // stored in the CXCursor to determine if the VarDecl is in a DeclGroup,\n    // and if so, whether it is the first decl.\n    if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {\n      if (!cxcursor::isFirstInDeclGroup(C))\n        R.setBegin(VD->getLocation());\n    }\n    return R;\n  }\n  return SourceRange();\n}\n\n/// Retrieves the \"raw\" cursor extent, which is then extended to include\n/// the decl-specifier-seq for declarations.\nstatic SourceRange getFullCursorExtent(CXCursor C, SourceManager &SrcMgr) {\n  if (clang_isDeclaration(C.kind)) {\n    const Decl *D = cxcursor::getCursorDecl(C);\n    if (!D)\n      return SourceRange();\n\n    SourceRange R = D->getSourceRange();\n\n    // Adjust the start of the location for declarations preceded by\n    // declaration specifiers.\n    SourceLocation StartLoc;\n    if (const DeclaratorDecl *DD = dyn_cast<DeclaratorDecl>(D)) {\n      if (TypeSourceInfo *TI = DD->getTypeSourceInfo())\n        StartLoc = TI->getTypeLoc().getBeginLoc();\n    } else if (const TypedefDecl *Typedef = dyn_cast<TypedefDecl>(D)) {\n      if (TypeSourceInfo *TI = Typedef->getTypeSourceInfo())\n        StartLoc = TI->getTypeLoc().getBeginLoc();\n    }\n\n    if (StartLoc.isValid() && R.getBegin().isValid() &&\n        SrcMgr.isBeforeInTranslationUnit(StartLoc, R.getBegin()))\n      R.setBegin(StartLoc);\n\n    // FIXME: Multiple variables declared in a single declaration\n    // currently lack the information needed to correctly determine their\n    // ranges when accounting for the type-specifier.  We use context\n    // stored in the CXCursor to determine if the VarDecl is in a DeclGroup,\n    // and if so, whether it is the first decl.\n    if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {\n      if (!cxcursor::isFirstInDeclGroup(C))\n        R.setBegin(VD->getLocation());\n    }\n\n    return R;\n  }\n\n  return getRawCursorExtent(C);\n}\n\nCXSourceRange clang_getCursorExtent(CXCursor C) {\n  SourceRange R = getRawCursorExtent(C);\n  if (R.isInvalid())\n    return clang_getNullRange();\n\n  return cxloc::translateSourceRange(getCursorContext(C), R);\n}\n\nCXCursor clang_getCursorReferenced(CXCursor C) {\n  if (clang_isInvalid(C.kind))\n    return clang_getNullCursor();\n\n  CXTranslationUnit tu = getCursorTU(C);\n  if (clang_isDeclaration(C.kind)) {\n    const Decl *D = getCursorDecl(C);\n    if (!D)\n      return clang_getNullCursor();\n    if (const UsingDecl *Using = dyn_cast<UsingDecl>(D))\n      return MakeCursorOverloadedDeclRef(Using, D->getLocation(), tu);\n    if (const ObjCPropertyImplDecl *PropImpl =\n            dyn_cast<ObjCPropertyImplDecl>(D))\n      if (ObjCPropertyDecl *Property = PropImpl->getPropertyDecl())\n        return MakeCXCursor(Property, tu);\n\n    return C;\n  }\n\n  if (clang_isExpression(C.kind)) {\n    const Expr *E = getCursorExpr(C);\n    const Decl *D = getDeclFromExpr(E);\n    if (D) {\n      CXCursor declCursor = MakeCXCursor(D, tu);\n      declCursor = getSelectorIdentifierCursor(getSelectorIdentifierIndex(C),\n                                               declCursor);\n      return declCursor;\n    }\n\n    if (const OverloadExpr *Ovl = dyn_cast_or_null<OverloadExpr>(E))\n      return MakeCursorOverloadedDeclRef(Ovl, tu);\n\n    return clang_getNullCursor();\n  }\n\n  if (clang_isStatement(C.kind)) {\n    const Stmt *S = getCursorStmt(C);\n    if (const GotoStmt *Goto = dyn_cast_or_null<GotoStmt>(S))\n      if (LabelDecl *label = Goto->getLabel())\n        if (LabelStmt *labelS = label->getStmt())\n          return MakeCXCursor(labelS, getCursorDecl(C), tu);\n\n    return clang_getNullCursor();\n  }\n\n  if (C.kind == CXCursor_MacroExpansion) {\n    if (const MacroDefinitionRecord *Def =\n            getCursorMacroExpansion(C).getDefinition())\n      return MakeMacroDefinitionCursor(Def, tu);\n  }\n\n  if (!clang_isReference(C.kind))\n    return clang_getNullCursor();\n\n  switch (C.kind) {\n  case CXCursor_ObjCSuperClassRef:\n    return MakeCXCursor(getCursorObjCSuperClassRef(C).first, tu);\n\n  case CXCursor_ObjCProtocolRef: {\n    const ObjCProtocolDecl *Prot = getCursorObjCProtocolRef(C).first;\n    if (const ObjCProtocolDecl *Def = Prot->getDefinition())\n      return MakeCXCursor(Def, tu);\n\n    return MakeCXCursor(Prot, tu);\n  }\n\n  case CXCursor_ObjCClassRef: {\n    const ObjCInterfaceDecl *Class = getCursorObjCClassRef(C).first;\n    if (const ObjCInterfaceDecl *Def = Class->getDefinition())\n      return MakeCXCursor(Def, tu);\n\n    return MakeCXCursor(Class, tu);\n  }\n\n  case CXCursor_TypeRef:\n    return MakeCXCursor(getCursorTypeRef(C).first, tu);\n\n  case CXCursor_TemplateRef:\n    return MakeCXCursor(getCursorTemplateRef(C).first, tu);\n\n  case CXCursor_NamespaceRef:\n    return MakeCXCursor(getCursorNamespaceRef(C).first, tu);\n\n  case CXCursor_MemberRef:\n    return MakeCXCursor(getCursorMemberRef(C).first, tu);\n\n  case CXCursor_CXXBaseSpecifier: {\n    const CXXBaseSpecifier *B = cxcursor::getCursorCXXBaseSpecifier(C);\n    return clang_getTypeDeclaration(cxtype::MakeCXType(B->getType(), tu));\n  }\n\n  case CXCursor_LabelRef:\n    // FIXME: We end up faking the \"parent\" declaration here because we\n    // don't want to make CXCursor larger.\n    return MakeCXCursor(\n        getCursorLabelRef(C).first,\n        cxtu::getASTUnit(tu)->getASTContext().getTranslationUnitDecl(), tu);\n\n  case CXCursor_OverloadedDeclRef:\n    return C;\n\n  case CXCursor_VariableRef:\n    return MakeCXCursor(getCursorVariableRef(C).first, tu);\n\n  default:\n    // We would prefer to enumerate all non-reference cursor kinds here.\n    llvm_unreachable(\"Unhandled reference cursor kind\");\n  }\n}\n\nCXCursor clang_getCursorDefinition(CXCursor C) {\n  if (clang_isInvalid(C.kind))\n    return clang_getNullCursor();\n\n  CXTranslationUnit TU = getCursorTU(C);\n\n  bool WasReference = false;\n  if (clang_isReference(C.kind) || clang_isExpression(C.kind)) {\n    C = clang_getCursorReferenced(C);\n    WasReference = true;\n  }\n\n  if (C.kind == CXCursor_MacroExpansion)\n    return clang_getCursorReferenced(C);\n\n  if (!clang_isDeclaration(C.kind))\n    return clang_getNullCursor();\n\n  const Decl *D = getCursorDecl(C);\n  if (!D)\n    return clang_getNullCursor();\n\n  switch (D->getKind()) {\n  // Declaration kinds that don't really separate the notions of\n  // declaration and definition.\n  case Decl::Namespace:\n  case Decl::Typedef:\n  case Decl::TypeAlias:\n  case Decl::TypeAliasTemplate:\n  case Decl::TemplateTypeParm:\n  case Decl::EnumConstant:\n  case Decl::Field:\n  case Decl::Binding:\n  case Decl::MSProperty:\n  case Decl::MSGuid:\n  case Decl::TemplateParamObject:\n  case Decl::IndirectField:\n  case Decl::ObjCIvar:\n  case Decl::ObjCAtDefsField:\n  case Decl::ImplicitParam:\n  case Decl::ParmVar:\n  case Decl::NonTypeTemplateParm:\n  case Decl::TemplateTemplateParm:\n  case Decl::ObjCCategoryImpl:\n  case Decl::ObjCImplementation:\n  case Decl::AccessSpec:\n  case Decl::LinkageSpec:\n  case Decl::Export:\n  case Decl::ObjCPropertyImpl:\n  case Decl::FileScopeAsm:\n  case Decl::StaticAssert:\n  case Decl::Block:\n  case Decl::Captured:\n  case Decl::OMPCapturedExpr:\n  case Decl::Label: // FIXME: Is this right??\n  case Decl::ClassScopeFunctionSpecialization:\n  case Decl::CXXDeductionGuide:\n  case Decl::Import:\n  case Decl::OMPThreadPrivate:\n  case Decl::OMPAllocate:\n  case Decl::OMPDeclareReduction:\n  case Decl::OMPDeclareMapper:\n  case Decl::OMPRequires:\n  case Decl::ObjCTypeParam:\n  case Decl::BuiltinTemplate:\n  case Decl::PragmaComment:\n  case Decl::PragmaDetectMismatch:\n  case Decl::UsingPack:\n  case Decl::Concept:\n  case Decl::LifetimeExtendedTemporary:\n  case Decl::RequiresExprBody:\n    return C;\n\n  // Declaration kinds that don't make any sense here, but are\n  // nonetheless harmless.\n  case Decl::Empty:\n  case Decl::TranslationUnit:\n  case Decl::ExternCContext:\n    break;\n\n  // Declaration kinds for which the definition is not resolvable.\n  case Decl::UnresolvedUsingTypename:\n  case Decl::UnresolvedUsingValue:\n    break;\n\n  case Decl::UsingDirective:\n    return MakeCXCursor(cast<UsingDirectiveDecl>(D)->getNominatedNamespace(),\n                        TU);\n\n  case Decl::NamespaceAlias:\n    return MakeCXCursor(cast<NamespaceAliasDecl>(D)->getNamespace(), TU);\n\n  case Decl::Enum:\n  case Decl::Record:\n  case Decl::CXXRecord:\n  case Decl::ClassTemplateSpecialization:\n  case Decl::ClassTemplatePartialSpecialization:\n    if (TagDecl *Def = cast<TagDecl>(D)->getDefinition())\n      return MakeCXCursor(Def, TU);\n    return clang_getNullCursor();\n\n  case Decl::Function:\n  case Decl::CXXMethod:\n  case Decl::CXXConstructor:\n  case Decl::CXXDestructor:\n  case Decl::CXXConversion: {\n    const FunctionDecl *Def = nullptr;\n    if (cast<FunctionDecl>(D)->getBody(Def))\n      return MakeCXCursor(Def, TU);\n    return clang_getNullCursor();\n  }\n\n  case Decl::Var:\n  case Decl::VarTemplateSpecialization:\n  case Decl::VarTemplatePartialSpecialization:\n  case Decl::Decomposition: {\n    // Ask the variable if it has a definition.\n    if (const VarDecl *Def = cast<VarDecl>(D)->getDefinition())\n      return MakeCXCursor(Def, TU);\n    return clang_getNullCursor();\n  }\n\n  case Decl::FunctionTemplate: {\n    const FunctionDecl *Def = nullptr;\n    if (cast<FunctionTemplateDecl>(D)->getTemplatedDecl()->getBody(Def))\n      return MakeCXCursor(Def->getDescribedFunctionTemplate(), TU);\n    return clang_getNullCursor();\n  }\n\n  case Decl::ClassTemplate: {\n    if (RecordDecl *Def =\n            cast<ClassTemplateDecl>(D)->getTemplatedDecl()->getDefinition())\n      return MakeCXCursor(cast<CXXRecordDecl>(Def)->getDescribedClassTemplate(),\n                          TU);\n    return clang_getNullCursor();\n  }\n\n  case Decl::VarTemplate: {\n    if (VarDecl *Def =\n            cast<VarTemplateDecl>(D)->getTemplatedDecl()->getDefinition())\n      return MakeCXCursor(cast<VarDecl>(Def)->getDescribedVarTemplate(), TU);\n    return clang_getNullCursor();\n  }\n\n  case Decl::Using:\n    return MakeCursorOverloadedDeclRef(cast<UsingDecl>(D), D->getLocation(),\n                                       TU);\n\n  case Decl::UsingShadow:\n  case Decl::ConstructorUsingShadow:\n    return clang_getCursorDefinition(\n        MakeCXCursor(cast<UsingShadowDecl>(D)->getTargetDecl(), TU));\n\n  case Decl::ObjCMethod: {\n    const ObjCMethodDecl *Method = cast<ObjCMethodDecl>(D);\n    if (Method->isThisDeclarationADefinition())\n      return C;\n\n    // Dig out the method definition in the associated\n    // @implementation, if we have it.\n    // FIXME: The ASTs should make finding the definition easier.\n    if (const ObjCInterfaceDecl *Class =\n            dyn_cast<ObjCInterfaceDecl>(Method->getDeclContext()))\n      if (ObjCImplementationDecl *ClassImpl = Class->getImplementation())\n        if (ObjCMethodDecl *Def = ClassImpl->getMethod(\n                Method->getSelector(), Method->isInstanceMethod()))\n          if (Def->isThisDeclarationADefinition())\n            return MakeCXCursor(Def, TU);\n\n    return clang_getNullCursor();\n  }\n\n  case Decl::ObjCCategory:\n    if (ObjCCategoryImplDecl *Impl =\n            cast<ObjCCategoryDecl>(D)->getImplementation())\n      return MakeCXCursor(Impl, TU);\n    return clang_getNullCursor();\n\n  case Decl::ObjCProtocol:\n    if (const ObjCProtocolDecl *Def =\n            cast<ObjCProtocolDecl>(D)->getDefinition())\n      return MakeCXCursor(Def, TU);\n    return clang_getNullCursor();\n\n  case Decl::ObjCInterface: {\n    // There are two notions of a \"definition\" for an Objective-C\n    // class: the interface and its implementation. When we resolved a\n    // reference to an Objective-C class, produce the @interface as\n    // the definition; when we were provided with the interface,\n    // produce the @implementation as the definition.\n    const ObjCInterfaceDecl *IFace = cast<ObjCInterfaceDecl>(D);\n    if (WasReference) {\n      if (const ObjCInterfaceDecl *Def = IFace->getDefinition())\n        return MakeCXCursor(Def, TU);\n    } else if (ObjCImplementationDecl *Impl = IFace->getImplementation())\n      return MakeCXCursor(Impl, TU);\n    return clang_getNullCursor();\n  }\n\n  case Decl::ObjCProperty:\n    // FIXME: We don't really know where to find the\n    // ObjCPropertyImplDecls that implement this property.\n    return clang_getNullCursor();\n\n  case Decl::ObjCCompatibleAlias:\n    if (const ObjCInterfaceDecl *Class =\n            cast<ObjCCompatibleAliasDecl>(D)->getClassInterface())\n      if (const ObjCInterfaceDecl *Def = Class->getDefinition())\n        return MakeCXCursor(Def, TU);\n\n    return clang_getNullCursor();\n\n  case Decl::Friend:\n    if (NamedDecl *Friend = cast<FriendDecl>(D)->getFriendDecl())\n      return clang_getCursorDefinition(MakeCXCursor(Friend, TU));\n    return clang_getNullCursor();\n\n  case Decl::FriendTemplate:\n    if (NamedDecl *Friend = cast<FriendTemplateDecl>(D)->getFriendDecl())\n      return clang_getCursorDefinition(MakeCXCursor(Friend, TU));\n    return clang_getNullCursor();\n  }\n\n  return clang_getNullCursor();\n}\n\nunsigned clang_isCursorDefinition(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  return clang_getCursorDefinition(C) == C;\n}\n\nCXCursor clang_getCanonicalCursor(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return C;\n\n  if (const Decl *D = getCursorDecl(C)) {\n    if (const ObjCCategoryImplDecl *CatImplD =\n            dyn_cast<ObjCCategoryImplDecl>(D))\n      if (ObjCCategoryDecl *CatD = CatImplD->getCategoryDecl())\n        return MakeCXCursor(CatD, getCursorTU(C));\n\n    if (const ObjCImplDecl *ImplD = dyn_cast<ObjCImplDecl>(D))\n      if (const ObjCInterfaceDecl *IFD = ImplD->getClassInterface())\n        return MakeCXCursor(IFD, getCursorTU(C));\n\n    return MakeCXCursor(D->getCanonicalDecl(), getCursorTU(C));\n  }\n\n  return C;\n}\n\nint clang_Cursor_getObjCSelectorIndex(CXCursor cursor) {\n  return cxcursor::getSelectorIdentifierIndexAndLoc(cursor).first;\n}\n\nunsigned clang_getNumOverloadedDecls(CXCursor C) {\n  if (C.kind != CXCursor_OverloadedDeclRef)\n    return 0;\n\n  OverloadedDeclRefStorage Storage = getCursorOverloadedDeclRef(C).first;\n  if (const OverloadExpr *E = Storage.dyn_cast<const OverloadExpr *>())\n    return E->getNumDecls();\n\n  if (OverloadedTemplateStorage *S =\n          Storage.dyn_cast<OverloadedTemplateStorage *>())\n    return S->size();\n\n  const Decl *D = Storage.get<const Decl *>();\n  if (const UsingDecl *Using = dyn_cast<UsingDecl>(D))\n    return Using->shadow_size();\n\n  return 0;\n}\n\nCXCursor clang_getOverloadedDecl(CXCursor cursor, unsigned index) {\n  if (cursor.kind != CXCursor_OverloadedDeclRef)\n    return clang_getNullCursor();\n\n  if (index >= clang_getNumOverloadedDecls(cursor))\n    return clang_getNullCursor();\n\n  CXTranslationUnit TU = getCursorTU(cursor);\n  OverloadedDeclRefStorage Storage = getCursorOverloadedDeclRef(cursor).first;\n  if (const OverloadExpr *E = Storage.dyn_cast<const OverloadExpr *>())\n    return MakeCXCursor(E->decls_begin()[index], TU);\n\n  if (OverloadedTemplateStorage *S =\n          Storage.dyn_cast<OverloadedTemplateStorage *>())\n    return MakeCXCursor(S->begin()[index], TU);\n\n  const Decl *D = Storage.get<const Decl *>();\n  if (const UsingDecl *Using = dyn_cast<UsingDecl>(D)) {\n    // FIXME: This is, unfortunately, linear time.\n    UsingDecl::shadow_iterator Pos = Using->shadow_begin();\n    std::advance(Pos, index);\n    return MakeCXCursor(cast<UsingShadowDecl>(*Pos)->getTargetDecl(), TU);\n  }\n\n  return clang_getNullCursor();\n}\n\nvoid clang_getDefinitionSpellingAndExtent(\n    CXCursor C, const char **startBuf, const char **endBuf, unsigned *startLine,\n    unsigned *startColumn, unsigned *endLine, unsigned *endColumn) {\n  assert(getCursorDecl(C) && \"CXCursor has null decl\");\n  const FunctionDecl *FD = dyn_cast<FunctionDecl>(getCursorDecl(C));\n  CompoundStmt *Body = dyn_cast<CompoundStmt>(FD->getBody());\n\n  SourceManager &SM = FD->getASTContext().getSourceManager();\n  *startBuf = SM.getCharacterData(Body->getLBracLoc());\n  *endBuf = SM.getCharacterData(Body->getRBracLoc());\n  *startLine = SM.getSpellingLineNumber(Body->getLBracLoc());\n  *startColumn = SM.getSpellingColumnNumber(Body->getLBracLoc());\n  *endLine = SM.getSpellingLineNumber(Body->getRBracLoc());\n  *endColumn = SM.getSpellingColumnNumber(Body->getRBracLoc());\n}\n\nCXSourceRange clang_getCursorReferenceNameRange(CXCursor C, unsigned NameFlags,\n                                                unsigned PieceIndex) {\n  RefNamePieces Pieces;\n\n  switch (C.kind) {\n  case CXCursor_MemberRefExpr:\n    if (const MemberExpr *E = dyn_cast<MemberExpr>(getCursorExpr(C)))\n      Pieces = buildPieces(NameFlags, true, E->getMemberNameInfo(),\n                           E->getQualifierLoc().getSourceRange());\n    break;\n\n  case CXCursor_DeclRefExpr:\n    if (const DeclRefExpr *E = dyn_cast<DeclRefExpr>(getCursorExpr(C))) {\n      SourceRange TemplateArgLoc(E->getLAngleLoc(), E->getRAngleLoc());\n      Pieces =\n          buildPieces(NameFlags, false, E->getNameInfo(),\n                      E->getQualifierLoc().getSourceRange(), &TemplateArgLoc);\n    }\n    break;\n\n  case CXCursor_CallExpr:\n    if (const CXXOperatorCallExpr *OCE =\n            dyn_cast<CXXOperatorCallExpr>(getCursorExpr(C))) {\n      const Expr *Callee = OCE->getCallee();\n      if (const ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(Callee))\n        Callee = ICE->getSubExpr();\n\n      if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(Callee))\n        Pieces = buildPieces(NameFlags, false, DRE->getNameInfo(),\n                             DRE->getQualifierLoc().getSourceRange());\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  if (Pieces.empty()) {\n    if (PieceIndex == 0)\n      return clang_getCursorExtent(C);\n  } else if (PieceIndex < Pieces.size()) {\n    SourceRange R = Pieces[PieceIndex];\n    if (R.isValid())\n      return cxloc::translateSourceRange(getCursorContext(C), R);\n  }\n\n  return clang_getNullRange();\n}\n\nvoid clang_enableStackTraces(void) {\n  // FIXME: Provide an argv0 here so we can find llvm-symbolizer.\n  llvm::sys::PrintStackTraceOnErrorSignal(StringRef());\n}\n\nvoid clang_executeOnThread(void (*fn)(void *), void *user_data,\n                           unsigned stack_size) {\n  llvm::llvm_execute_on_thread(fn, user_data,\n                               stack_size == 0\n                                   ? clang::DesiredStackSize\n                                   : llvm::Optional<unsigned>(stack_size));\n}\n\n//===----------------------------------------------------------------------===//\n// Token-based Operations.\n//===----------------------------------------------------------------------===//\n\n/* CXToken layout:\n *   int_data[0]: a CXTokenKind\n *   int_data[1]: starting token location\n *   int_data[2]: token length\n *   int_data[3]: reserved\n *   ptr_data: for identifiers and keywords, an IdentifierInfo*.\n *   otherwise unused.\n */\nCXTokenKind clang_getTokenKind(CXToken CXTok) {\n  return static_cast<CXTokenKind>(CXTok.int_data[0]);\n}\n\nCXString clang_getTokenSpelling(CXTranslationUnit TU, CXToken CXTok) {\n  switch (clang_getTokenKind(CXTok)) {\n  case CXToken_Identifier:\n  case CXToken_Keyword:\n    // We know we have an IdentifierInfo*, so use that.\n    return cxstring::createRef(\n        static_cast<IdentifierInfo *>(CXTok.ptr_data)->getNameStart());\n\n  case CXToken_Literal: {\n    // We have stashed the starting pointer in the ptr_data field. Use it.\n    const char *Text = static_cast<const char *>(CXTok.ptr_data);\n    return cxstring::createDup(StringRef(Text, CXTok.int_data[2]));\n  }\n\n  case CXToken_Punctuation:\n  case CXToken_Comment:\n    break;\n  }\n\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return cxstring::createEmpty();\n  }\n\n  // We have to find the starting buffer pointer the hard way, by\n  // deconstructing the source location.\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  if (!CXXUnit)\n    return cxstring::createEmpty();\n\n  SourceLocation Loc = SourceLocation::getFromRawEncoding(CXTok.int_data[1]);\n  std::pair<FileID, unsigned> LocInfo =\n      CXXUnit->getSourceManager().getDecomposedSpellingLoc(Loc);\n  bool Invalid = false;\n  StringRef Buffer =\n      CXXUnit->getSourceManager().getBufferData(LocInfo.first, &Invalid);\n  if (Invalid)\n    return cxstring::createEmpty();\n\n  return cxstring::createDup(Buffer.substr(LocInfo.second, CXTok.int_data[2]));\n}\n\nCXSourceLocation clang_getTokenLocation(CXTranslationUnit TU, CXToken CXTok) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return clang_getNullLocation();\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  if (!CXXUnit)\n    return clang_getNullLocation();\n\n  return cxloc::translateSourceLocation(\n      CXXUnit->getASTContext(),\n      SourceLocation::getFromRawEncoding(CXTok.int_data[1]));\n}\n\nCXSourceRange clang_getTokenExtent(CXTranslationUnit TU, CXToken CXTok) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return clang_getNullRange();\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  if (!CXXUnit)\n    return clang_getNullRange();\n\n  return cxloc::translateSourceRange(\n      CXXUnit->getASTContext(),\n      SourceLocation::getFromRawEncoding(CXTok.int_data[1]));\n}\n\nstatic void getTokens(ASTUnit *CXXUnit, SourceRange Range,\n                      SmallVectorImpl<CXToken> &CXTokens) {\n  SourceManager &SourceMgr = CXXUnit->getSourceManager();\n  std::pair<FileID, unsigned> BeginLocInfo =\n      SourceMgr.getDecomposedSpellingLoc(Range.getBegin());\n  std::pair<FileID, unsigned> EndLocInfo =\n      SourceMgr.getDecomposedSpellingLoc(Range.getEnd());\n\n  // Cannot tokenize across files.\n  if (BeginLocInfo.first != EndLocInfo.first)\n    return;\n\n  // Create a lexer\n  bool Invalid = false;\n  StringRef Buffer = SourceMgr.getBufferData(BeginLocInfo.first, &Invalid);\n  if (Invalid)\n    return;\n\n  Lexer Lex(SourceMgr.getLocForStartOfFile(BeginLocInfo.first),\n            CXXUnit->getASTContext().getLangOpts(), Buffer.begin(),\n            Buffer.data() + BeginLocInfo.second, Buffer.end());\n  Lex.SetCommentRetentionState(true);\n\n  // Lex tokens until we hit the end of the range.\n  const char *EffectiveBufferEnd = Buffer.data() + EndLocInfo.second;\n  Token Tok;\n  bool previousWasAt = false;\n  do {\n    // Lex the next token\n    Lex.LexFromRawLexer(Tok);\n    if (Tok.is(tok::eof))\n      break;\n\n    // Initialize the CXToken.\n    CXToken CXTok;\n\n    //   - Common fields\n    CXTok.int_data[1] = Tok.getLocation().getRawEncoding();\n    CXTok.int_data[2] = Tok.getLength();\n    CXTok.int_data[3] = 0;\n\n    //   - Kind-specific fields\n    if (Tok.isLiteral()) {\n      CXTok.int_data[0] = CXToken_Literal;\n      CXTok.ptr_data = const_cast<char *>(Tok.getLiteralData());\n    } else if (Tok.is(tok::raw_identifier)) {\n      // Lookup the identifier to determine whether we have a keyword.\n      IdentifierInfo *II = CXXUnit->getPreprocessor().LookUpIdentifierInfo(Tok);\n\n      if ((II->getObjCKeywordID() != tok::objc_not_keyword) && previousWasAt) {\n        CXTok.int_data[0] = CXToken_Keyword;\n      } else {\n        CXTok.int_data[0] =\n            Tok.is(tok::identifier) ? CXToken_Identifier : CXToken_Keyword;\n      }\n      CXTok.ptr_data = II;\n    } else if (Tok.is(tok::comment)) {\n      CXTok.int_data[0] = CXToken_Comment;\n      CXTok.ptr_data = nullptr;\n    } else {\n      CXTok.int_data[0] = CXToken_Punctuation;\n      CXTok.ptr_data = nullptr;\n    }\n    CXTokens.push_back(CXTok);\n    previousWasAt = Tok.is(tok::at);\n  } while (Lex.getBufferLocation() < EffectiveBufferEnd);\n}\n\nCXToken *clang_getToken(CXTranslationUnit TU, CXSourceLocation Location) {\n  LOG_FUNC_SECTION { *Log << TU << ' ' << Location; }\n\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return NULL;\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  if (!CXXUnit)\n    return NULL;\n\n  SourceLocation Begin = cxloc::translateSourceLocation(Location);\n  if (Begin.isInvalid())\n    return NULL;\n  SourceManager &SM = CXXUnit->getSourceManager();\n  std::pair<FileID, unsigned> DecomposedEnd = SM.getDecomposedLoc(Begin);\n  DecomposedEnd.second +=\n      Lexer::MeasureTokenLength(Begin, SM, CXXUnit->getLangOpts());\n\n  SourceLocation End =\n      SM.getComposedLoc(DecomposedEnd.first, DecomposedEnd.second);\n\n  SmallVector<CXToken, 32> CXTokens;\n  getTokens(CXXUnit, SourceRange(Begin, End), CXTokens);\n\n  if (CXTokens.empty())\n    return NULL;\n\n  CXTokens.resize(1);\n  CXToken *Token = static_cast<CXToken *>(llvm::safe_malloc(sizeof(CXToken)));\n\n  memmove(Token, CXTokens.data(), sizeof(CXToken));\n  return Token;\n}\n\nvoid clang_tokenize(CXTranslationUnit TU, CXSourceRange Range, CXToken **Tokens,\n                    unsigned *NumTokens) {\n  LOG_FUNC_SECTION { *Log << TU << ' ' << Range; }\n\n  if (Tokens)\n    *Tokens = nullptr;\n  if (NumTokens)\n    *NumTokens = 0;\n\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return;\n  }\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  if (!CXXUnit || !Tokens || !NumTokens)\n    return;\n\n  ASTUnit::ConcurrencyCheck Check(*CXXUnit);\n\n  SourceRange R = cxloc::translateCXSourceRange(Range);\n  if (R.isInvalid())\n    return;\n\n  SmallVector<CXToken, 32> CXTokens;\n  getTokens(CXXUnit, R, CXTokens);\n\n  if (CXTokens.empty())\n    return;\n\n  *Tokens = static_cast<CXToken *>(\n      llvm::safe_malloc(sizeof(CXToken) * CXTokens.size()));\n  memmove(*Tokens, CXTokens.data(), sizeof(CXToken) * CXTokens.size());\n  *NumTokens = CXTokens.size();\n}\n\nvoid clang_disposeTokens(CXTranslationUnit TU, CXToken *Tokens,\n                         unsigned NumTokens) {\n  free(Tokens);\n}\n\n//===----------------------------------------------------------------------===//\n// Token annotation APIs.\n//===----------------------------------------------------------------------===//\n\nstatic enum CXChildVisitResult AnnotateTokensVisitor(CXCursor cursor,\n                                                     CXCursor parent,\n                                                     CXClientData client_data);\nstatic bool AnnotateTokensPostChildrenVisitor(CXCursor cursor,\n                                              CXClientData client_data);\n\nnamespace {\nclass AnnotateTokensWorker {\n  CXToken *Tokens;\n  CXCursor *Cursors;\n  unsigned NumTokens;\n  unsigned TokIdx;\n  unsigned PreprocessingTokIdx;\n  CursorVisitor AnnotateVis;\n  SourceManager &SrcMgr;\n  bool HasContextSensitiveKeywords;\n\n  struct PostChildrenAction {\n    CXCursor cursor;\n    enum Action { Invalid, Ignore, Postpone } action;\n  };\n  using PostChildrenActions = SmallVector<PostChildrenAction, 0>;\n\n  struct PostChildrenInfo {\n    CXCursor Cursor;\n    SourceRange CursorRange;\n    unsigned BeforeReachingCursorIdx;\n    unsigned BeforeChildrenTokenIdx;\n    PostChildrenActions ChildActions;\n  };\n  SmallVector<PostChildrenInfo, 8> PostChildrenInfos;\n\n  CXToken &getTok(unsigned Idx) {\n    assert(Idx < NumTokens);\n    return Tokens[Idx];\n  }\n  const CXToken &getTok(unsigned Idx) const {\n    assert(Idx < NumTokens);\n    return Tokens[Idx];\n  }\n  bool MoreTokens() const { return TokIdx < NumTokens; }\n  unsigned NextToken() const { return TokIdx; }\n  void AdvanceToken() { ++TokIdx; }\n  SourceLocation GetTokenLoc(unsigned tokI) {\n    return SourceLocation::getFromRawEncoding(getTok(tokI).int_data[1]);\n  }\n  bool isFunctionMacroToken(unsigned tokI) const {\n    return getTok(tokI).int_data[3] != 0;\n  }\n  SourceLocation getFunctionMacroTokenLoc(unsigned tokI) const {\n    return SourceLocation::getFromRawEncoding(getTok(tokI).int_data[3]);\n  }\n\n  void annotateAndAdvanceTokens(CXCursor, RangeComparisonResult, SourceRange);\n  bool annotateAndAdvanceFunctionMacroTokens(CXCursor, RangeComparisonResult,\n                                             SourceRange);\n\npublic:\n  AnnotateTokensWorker(CXToken *tokens, CXCursor *cursors, unsigned numTokens,\n                       CXTranslationUnit TU, SourceRange RegionOfInterest)\n      : Tokens(tokens), Cursors(cursors), NumTokens(numTokens), TokIdx(0),\n        PreprocessingTokIdx(0),\n        AnnotateVis(TU, AnnotateTokensVisitor, this,\n                    /*VisitPreprocessorLast=*/true,\n                    /*VisitIncludedEntities=*/false, RegionOfInterest,\n                    /*VisitDeclsOnly=*/false,\n                    AnnotateTokensPostChildrenVisitor),\n        SrcMgr(cxtu::getASTUnit(TU)->getSourceManager()),\n        HasContextSensitiveKeywords(false) {}\n\n  void VisitChildren(CXCursor C) { AnnotateVis.VisitChildren(C); }\n  enum CXChildVisitResult Visit(CXCursor cursor, CXCursor parent);\n  bool IsIgnoredChildCursor(CXCursor cursor) const;\n  PostChildrenActions DetermineChildActions(CXCursor Cursor) const;\n\n  bool postVisitChildren(CXCursor cursor);\n  void HandlePostPonedChildCursors(const PostChildrenInfo &Info);\n  void HandlePostPonedChildCursor(CXCursor Cursor, unsigned StartTokenIndex);\n\n  void AnnotateTokens();\n\n  /// Determine whether the annotator saw any cursors that have\n  /// context-sensitive keywords.\n  bool hasContextSensitiveKeywords() const {\n    return HasContextSensitiveKeywords;\n  }\n\n  ~AnnotateTokensWorker() { assert(PostChildrenInfos.empty()); }\n};\n} // namespace\n\nvoid AnnotateTokensWorker::AnnotateTokens() {\n  // Walk the AST within the region of interest, annotating tokens\n  // along the way.\n  AnnotateVis.visitFileRegion();\n}\n\nbool AnnotateTokensWorker::IsIgnoredChildCursor(CXCursor cursor) const {\n  if (PostChildrenInfos.empty())\n    return false;\n\n  for (const auto &ChildAction : PostChildrenInfos.back().ChildActions) {\n    if (ChildAction.cursor == cursor &&\n        ChildAction.action == PostChildrenAction::Ignore) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nconst CXXOperatorCallExpr *GetSubscriptOrCallOperator(CXCursor Cursor) {\n  if (!clang_isExpression(Cursor.kind))\n    return nullptr;\n\n  const Expr *E = getCursorExpr(Cursor);\n  if (const auto *OCE = dyn_cast<CXXOperatorCallExpr>(E)) {\n    const OverloadedOperatorKind Kind = OCE->getOperator();\n    if (Kind == OO_Call || Kind == OO_Subscript)\n      return OCE;\n  }\n\n  return nullptr;\n}\n\nAnnotateTokensWorker::PostChildrenActions\nAnnotateTokensWorker::DetermineChildActions(CXCursor Cursor) const {\n  PostChildrenActions actions;\n\n  // The DeclRefExpr of CXXOperatorCallExpr refering to the custom operator is\n  // visited before the arguments to the operator call. For the Call and\n  // Subscript operator the range of this DeclRefExpr includes the whole call\n  // expression, so that all tokens in that range would be mapped to the\n  // operator function, including the tokens of the arguments. To avoid that,\n  // ensure to visit this DeclRefExpr as last node.\n  if (const auto *OCE = GetSubscriptOrCallOperator(Cursor)) {\n    const Expr *Callee = OCE->getCallee();\n    if (const ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(Callee)) {\n      const Expr *SubExpr = ICE->getSubExpr();\n      if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(SubExpr)) {\n        const Decl *parentDecl = getCursorDecl(Cursor);\n        CXTranslationUnit TU = clang_Cursor_getTranslationUnit(Cursor);\n\n        // Visit the DeclRefExpr as last.\n        CXCursor cxChild = MakeCXCursor(DRE, parentDecl, TU);\n        actions.push_back({cxChild, PostChildrenAction::Postpone});\n\n        // The parent of the DeclRefExpr, an ImplicitCastExpr, has an equally\n        // wide range as the DeclRefExpr. We can skip visiting this entirely.\n        cxChild = MakeCXCursor(ICE, parentDecl, TU);\n        actions.push_back({cxChild, PostChildrenAction::Ignore});\n      }\n    }\n  }\n\n  return actions;\n}\n\nstatic inline void updateCursorAnnotation(CXCursor &Cursor,\n                                          const CXCursor &updateC) {\n  if (clang_isInvalid(updateC.kind) || !clang_isInvalid(Cursor.kind))\n    return;\n  Cursor = updateC;\n}\n\n/// It annotates and advances tokens with a cursor until the comparison\n//// between the cursor location and the source range is the same as\n/// \\arg compResult.\n///\n/// Pass RangeBefore to annotate tokens with a cursor until a range is reached.\n/// Pass RangeOverlap to annotate tokens inside a range.\nvoid AnnotateTokensWorker::annotateAndAdvanceTokens(\n    CXCursor updateC, RangeComparisonResult compResult, SourceRange range) {\n  while (MoreTokens()) {\n    const unsigned I = NextToken();\n    if (isFunctionMacroToken(I))\n      if (!annotateAndAdvanceFunctionMacroTokens(updateC, compResult, range))\n        return;\n\n    SourceLocation TokLoc = GetTokenLoc(I);\n    if (LocationCompare(SrcMgr, TokLoc, range) == compResult) {\n      updateCursorAnnotation(Cursors[I], updateC);\n      AdvanceToken();\n      continue;\n    }\n    break;\n  }\n}\n\n/// Special annotation handling for macro argument tokens.\n/// \\returns true if it advanced beyond all macro tokens, false otherwise.\nbool AnnotateTokensWorker::annotateAndAdvanceFunctionMacroTokens(\n    CXCursor updateC, RangeComparisonResult compResult, SourceRange range) {\n  assert(MoreTokens());\n  assert(isFunctionMacroToken(NextToken()) &&\n         \"Should be called only for macro arg tokens\");\n\n  // This works differently than annotateAndAdvanceTokens; because expanded\n  // macro arguments can have arbitrary translation-unit source order, we do not\n  // advance the token index one by one until a token fails the range test.\n  // We only advance once past all of the macro arg tokens if all of them\n  // pass the range test. If one of them fails we keep the token index pointing\n  // at the start of the macro arg tokens so that the failing token will be\n  // annotated by a subsequent annotation try.\n\n  bool atLeastOneCompFail = false;\n\n  unsigned I = NextToken();\n  for (; I < NumTokens && isFunctionMacroToken(I); ++I) {\n    SourceLocation TokLoc = getFunctionMacroTokenLoc(I);\n    if (TokLoc.isFileID())\n      continue; // not macro arg token, it's parens or comma.\n    if (LocationCompare(SrcMgr, TokLoc, range) == compResult) {\n      if (clang_isInvalid(clang_getCursorKind(Cursors[I])))\n        Cursors[I] = updateC;\n    } else\n      atLeastOneCompFail = true;\n  }\n\n  if (atLeastOneCompFail)\n    return false;\n\n  TokIdx = I; // All of the tokens were handled, advance beyond all of them.\n  return true;\n}\n\nenum CXChildVisitResult AnnotateTokensWorker::Visit(CXCursor cursor,\n                                                    CXCursor parent) {\n  SourceRange cursorRange = getRawCursorExtent(cursor);\n  if (cursorRange.isInvalid())\n    return CXChildVisit_Recurse;\n\n  if (IsIgnoredChildCursor(cursor))\n    return CXChildVisit_Continue;\n\n  if (!HasContextSensitiveKeywords) {\n    // Objective-C properties can have context-sensitive keywords.\n    if (cursor.kind == CXCursor_ObjCPropertyDecl) {\n      if (const ObjCPropertyDecl *Property =\n              dyn_cast_or_null<ObjCPropertyDecl>(getCursorDecl(cursor)))\n        HasContextSensitiveKeywords =\n            Property->getPropertyAttributesAsWritten() != 0;\n    }\n    // Objective-C methods can have context-sensitive keywords.\n    else if (cursor.kind == CXCursor_ObjCInstanceMethodDecl ||\n             cursor.kind == CXCursor_ObjCClassMethodDecl) {\n      if (const ObjCMethodDecl *Method =\n              dyn_cast_or_null<ObjCMethodDecl>(getCursorDecl(cursor))) {\n        if (Method->getObjCDeclQualifier())\n          HasContextSensitiveKeywords = true;\n        else {\n          for (const auto *P : Method->parameters()) {\n            if (P->getObjCDeclQualifier()) {\n              HasContextSensitiveKeywords = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n    // C++ methods can have context-sensitive keywords.\n    else if (cursor.kind == CXCursor_CXXMethod) {\n      if (const CXXMethodDecl *Method =\n              dyn_cast_or_null<CXXMethodDecl>(getCursorDecl(cursor))) {\n        if (Method->hasAttr<FinalAttr>() || Method->hasAttr<OverrideAttr>())\n          HasContextSensitiveKeywords = true;\n      }\n    }\n    // C++ classes can have context-sensitive keywords.\n    else if (cursor.kind == CXCursor_StructDecl ||\n             cursor.kind == CXCursor_ClassDecl ||\n             cursor.kind == CXCursor_ClassTemplate ||\n             cursor.kind == CXCursor_ClassTemplatePartialSpecialization) {\n      if (const Decl *D = getCursorDecl(cursor))\n        if (D->hasAttr<FinalAttr>())\n          HasContextSensitiveKeywords = true;\n    }\n  }\n\n  // Don't override a property annotation with its getter/setter method.\n  if (cursor.kind == CXCursor_ObjCInstanceMethodDecl &&\n      parent.kind == CXCursor_ObjCPropertyDecl)\n    return CXChildVisit_Continue;\n\n  if (clang_isPreprocessing(cursor.kind)) {\n    // Items in the preprocessing record are kept separate from items in\n    // declarations, so we keep a separate token index.\n    unsigned SavedTokIdx = TokIdx;\n    TokIdx = PreprocessingTokIdx;\n\n    // Skip tokens up until we catch up to the beginning of the preprocessing\n    // entry.\n    while (MoreTokens()) {\n      const unsigned I = NextToken();\n      SourceLocation TokLoc = GetTokenLoc(I);\n      switch (LocationCompare(SrcMgr, TokLoc, cursorRange)) {\n      case RangeBefore:\n        AdvanceToken();\n        continue;\n      case RangeAfter:\n      case RangeOverlap:\n        break;\n      }\n      break;\n    }\n\n    // Look at all of the tokens within this range.\n    while (MoreTokens()) {\n      const unsigned I = NextToken();\n      SourceLocation TokLoc = GetTokenLoc(I);\n      switch (LocationCompare(SrcMgr, TokLoc, cursorRange)) {\n      case RangeBefore:\n        llvm_unreachable(\"Infeasible\");\n      case RangeAfter:\n        break;\n      case RangeOverlap:\n        // For macro expansions, just note where the beginning of the macro\n        // expansion occurs.\n        if (cursor.kind == CXCursor_MacroExpansion) {\n          if (TokLoc == cursorRange.getBegin())\n            Cursors[I] = cursor;\n          AdvanceToken();\n          break;\n        }\n        // We may have already annotated macro names inside macro definitions.\n        if (Cursors[I].kind != CXCursor_MacroExpansion)\n          Cursors[I] = cursor;\n        AdvanceToken();\n        continue;\n      }\n      break;\n    }\n\n    // Save the preprocessing token index; restore the non-preprocessing\n    // token index.\n    PreprocessingTokIdx = TokIdx;\n    TokIdx = SavedTokIdx;\n    return CXChildVisit_Recurse;\n  }\n\n  if (cursorRange.isInvalid())\n    return CXChildVisit_Continue;\n\n  unsigned BeforeReachingCursorIdx = NextToken();\n  const enum CXCursorKind cursorK = clang_getCursorKind(cursor);\n  const enum CXCursorKind K = clang_getCursorKind(parent);\n  const CXCursor updateC =\n      (clang_isInvalid(K) || K == CXCursor_TranslationUnit ||\n       // Attributes are annotated out-of-order, skip tokens until we reach it.\n       clang_isAttribute(cursor.kind))\n          ? clang_getNullCursor()\n          : parent;\n\n  annotateAndAdvanceTokens(updateC, RangeBefore, cursorRange);\n\n  // Avoid having the cursor of an expression \"overwrite\" the annotation of the\n  // variable declaration that it belongs to.\n  // This can happen for C++ constructor expressions whose range generally\n  // include the variable declaration, e.g.:\n  //  MyCXXClass foo; // Make sure we don't annotate 'foo' as a CallExpr cursor.\n  if (clang_isExpression(cursorK) && MoreTokens()) {\n    const Expr *E = getCursorExpr(cursor);\n    if (const Decl *D = getCursorDecl(cursor)) {\n      const unsigned I = NextToken();\n      if (E->getBeginLoc().isValid() && D->getLocation().isValid() &&\n          E->getBeginLoc() == D->getLocation() &&\n          E->getBeginLoc() == GetTokenLoc(I)) {\n        updateCursorAnnotation(Cursors[I], updateC);\n        AdvanceToken();\n      }\n    }\n  }\n\n  // Before recursing into the children keep some state that we are going\n  // to use in the AnnotateTokensWorker::postVisitChildren callback to do some\n  // extra work after the child nodes are visited.\n  // Note that we don't call VisitChildren here to avoid traversing statements\n  // code-recursively which can blow the stack.\n\n  PostChildrenInfo Info;\n  Info.Cursor = cursor;\n  Info.CursorRange = cursorRange;\n  Info.BeforeReachingCursorIdx = BeforeReachingCursorIdx;\n  Info.BeforeChildrenTokenIdx = NextToken();\n  Info.ChildActions = DetermineChildActions(cursor);\n  PostChildrenInfos.push_back(Info);\n\n  return CXChildVisit_Recurse;\n}\n\nbool AnnotateTokensWorker::postVisitChildren(CXCursor cursor) {\n  if (PostChildrenInfos.empty())\n    return false;\n  const PostChildrenInfo &Info = PostChildrenInfos.back();\n  if (!clang_equalCursors(Info.Cursor, cursor))\n    return false;\n\n  HandlePostPonedChildCursors(Info);\n\n  const unsigned BeforeChildren = Info.BeforeChildrenTokenIdx;\n  const unsigned AfterChildren = NextToken();\n  SourceRange cursorRange = Info.CursorRange;\n\n  // Scan the tokens that are at the end of the cursor, but are not captured\n  // but the child cursors.\n  annotateAndAdvanceTokens(cursor, RangeOverlap, cursorRange);\n\n  // Scan the tokens that are at the beginning of the cursor, but are not\n  // capture by the child cursors.\n  for (unsigned I = BeforeChildren; I != AfterChildren; ++I) {\n    if (!clang_isInvalid(clang_getCursorKind(Cursors[I])))\n      break;\n\n    Cursors[I] = cursor;\n  }\n\n  // Attributes are annotated out-of-order, rewind TokIdx to when we first\n  // encountered the attribute cursor.\n  if (clang_isAttribute(cursor.kind))\n    TokIdx = Info.BeforeReachingCursorIdx;\n\n  PostChildrenInfos.pop_back();\n  return false;\n}\n\nvoid AnnotateTokensWorker::HandlePostPonedChildCursors(\n    const PostChildrenInfo &Info) {\n  for (const auto &ChildAction : Info.ChildActions) {\n    if (ChildAction.action == PostChildrenAction::Postpone) {\n      HandlePostPonedChildCursor(ChildAction.cursor,\n                                 Info.BeforeChildrenTokenIdx);\n    }\n  }\n}\n\nvoid AnnotateTokensWorker::HandlePostPonedChildCursor(\n    CXCursor Cursor, unsigned StartTokenIndex) {\n  unsigned I = StartTokenIndex;\n\n  // The bracket tokens of a Call or Subscript operator are mapped to\n  // CallExpr/CXXOperatorCallExpr because we skipped visiting the corresponding\n  // DeclRefExpr. Remap these tokens to the DeclRefExpr cursors.\n  for (unsigned RefNameRangeNr = 0; I < NumTokens; RefNameRangeNr++) {\n    const CXSourceRange CXRefNameRange = clang_getCursorReferenceNameRange(\n        Cursor, CXNameRange_WantQualifier, RefNameRangeNr);\n    if (clang_Range_isNull(CXRefNameRange))\n      break; // All ranges handled.\n\n    SourceRange RefNameRange = cxloc::translateCXSourceRange(CXRefNameRange);\n    while (I < NumTokens) {\n      const SourceLocation TokenLocation = GetTokenLoc(I);\n      if (!TokenLocation.isValid())\n        break;\n\n      // Adapt the end range, because LocationCompare() reports\n      // RangeOverlap even for the not-inclusive end location.\n      const SourceLocation fixedEnd =\n          RefNameRange.getEnd().getLocWithOffset(-1);\n      RefNameRange = SourceRange(RefNameRange.getBegin(), fixedEnd);\n\n      const RangeComparisonResult ComparisonResult =\n          LocationCompare(SrcMgr, TokenLocation, RefNameRange);\n\n      if (ComparisonResult == RangeOverlap) {\n        Cursors[I++] = Cursor;\n      } else if (ComparisonResult == RangeBefore) {\n        ++I; // Not relevant token, check next one.\n      } else if (ComparisonResult == RangeAfter) {\n        break; // All tokens updated for current range, check next.\n      }\n    }\n  }\n}\n\nstatic enum CXChildVisitResult AnnotateTokensVisitor(CXCursor cursor,\n                                                     CXCursor parent,\n                                                     CXClientData client_data) {\n  return static_cast<AnnotateTokensWorker *>(client_data)\n      ->Visit(cursor, parent);\n}\n\nstatic bool AnnotateTokensPostChildrenVisitor(CXCursor cursor,\n                                              CXClientData client_data) {\n  return static_cast<AnnotateTokensWorker *>(client_data)\n      ->postVisitChildren(cursor);\n}\n\nnamespace {\n\n/// Uses the macro expansions in the preprocessing record to find\n/// and mark tokens that are macro arguments. This info is used by the\n/// AnnotateTokensWorker.\nclass MarkMacroArgTokensVisitor {\n  SourceManager &SM;\n  CXToken *Tokens;\n  unsigned NumTokens;\n  unsigned CurIdx;\n\npublic:\n  MarkMacroArgTokensVisitor(SourceManager &SM, CXToken *tokens,\n                            unsigned numTokens)\n      : SM(SM), Tokens(tokens), NumTokens(numTokens), CurIdx(0) {}\n\n  CXChildVisitResult visit(CXCursor cursor, CXCursor parent) {\n    if (cursor.kind != CXCursor_MacroExpansion)\n      return CXChildVisit_Continue;\n\n    SourceRange macroRange = getCursorMacroExpansion(cursor).getSourceRange();\n    if (macroRange.getBegin() == macroRange.getEnd())\n      return CXChildVisit_Continue; // it's not a function macro.\n\n    for (; CurIdx < NumTokens; ++CurIdx) {\n      if (!SM.isBeforeInTranslationUnit(getTokenLoc(CurIdx),\n                                        macroRange.getBegin()))\n        break;\n    }\n\n    if (CurIdx == NumTokens)\n      return CXChildVisit_Break;\n\n    for (; CurIdx < NumTokens; ++CurIdx) {\n      SourceLocation tokLoc = getTokenLoc(CurIdx);\n      if (!SM.isBeforeInTranslationUnit(tokLoc, macroRange.getEnd()))\n        break;\n\n      setFunctionMacroTokenLoc(CurIdx, SM.getMacroArgExpandedLocation(tokLoc));\n    }\n\n    if (CurIdx == NumTokens)\n      return CXChildVisit_Break;\n\n    return CXChildVisit_Continue;\n  }\n\nprivate:\n  CXToken &getTok(unsigned Idx) {\n    assert(Idx < NumTokens);\n    return Tokens[Idx];\n  }\n  const CXToken &getTok(unsigned Idx) const {\n    assert(Idx < NumTokens);\n    return Tokens[Idx];\n  }\n\n  SourceLocation getTokenLoc(unsigned tokI) {\n    return SourceLocation::getFromRawEncoding(getTok(tokI).int_data[1]);\n  }\n\n  void setFunctionMacroTokenLoc(unsigned tokI, SourceLocation loc) {\n    // The third field is reserved and currently not used. Use it here\n    // to mark macro arg expanded tokens with their expanded locations.\n    getTok(tokI).int_data[3] = loc.getRawEncoding();\n  }\n};\n\n} // end anonymous namespace\n\nstatic CXChildVisitResult\nMarkMacroArgTokensVisitorDelegate(CXCursor cursor, CXCursor parent,\n                                  CXClientData client_data) {\n  return static_cast<MarkMacroArgTokensVisitor *>(client_data)\n      ->visit(cursor, parent);\n}\n\n/// Used by \\c annotatePreprocessorTokens.\n/// \\returns true if lexing was finished, false otherwise.\nstatic bool lexNext(Lexer &Lex, Token &Tok, unsigned &NextIdx,\n                    unsigned NumTokens) {\n  if (NextIdx >= NumTokens)\n    return true;\n\n  ++NextIdx;\n  Lex.LexFromRawLexer(Tok);\n  return Tok.is(tok::eof);\n}\n\nstatic void annotatePreprocessorTokens(CXTranslationUnit TU,\n                                       SourceRange RegionOfInterest,\n                                       CXCursor *Cursors, CXToken *Tokens,\n                                       unsigned NumTokens) {\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n\n  Preprocessor &PP = CXXUnit->getPreprocessor();\n  SourceManager &SourceMgr = CXXUnit->getSourceManager();\n  std::pair<FileID, unsigned> BeginLocInfo =\n      SourceMgr.getDecomposedSpellingLoc(RegionOfInterest.getBegin());\n  std::pair<FileID, unsigned> EndLocInfo =\n      SourceMgr.getDecomposedSpellingLoc(RegionOfInterest.getEnd());\n\n  if (BeginLocInfo.first != EndLocInfo.first)\n    return;\n\n  StringRef Buffer;\n  bool Invalid = false;\n  Buffer = SourceMgr.getBufferData(BeginLocInfo.first, &Invalid);\n  if (Buffer.empty() || Invalid)\n    return;\n\n  Lexer Lex(SourceMgr.getLocForStartOfFile(BeginLocInfo.first),\n            CXXUnit->getASTContext().getLangOpts(), Buffer.begin(),\n            Buffer.data() + BeginLocInfo.second, Buffer.end());\n  Lex.SetCommentRetentionState(true);\n\n  unsigned NextIdx = 0;\n  // Lex tokens in raw mode until we hit the end of the range, to avoid\n  // entering #includes or expanding macros.\n  while (true) {\n    Token Tok;\n    if (lexNext(Lex, Tok, NextIdx, NumTokens))\n      break;\n    unsigned TokIdx = NextIdx - 1;\n    assert(Tok.getLocation() ==\n           SourceLocation::getFromRawEncoding(Tokens[TokIdx].int_data[1]));\n\n  reprocess:\n    if (Tok.is(tok::hash) && Tok.isAtStartOfLine()) {\n      // We have found a preprocessing directive. Annotate the tokens\n      // appropriately.\n      //\n      // FIXME: Some simple tests here could identify macro definitions and\n      // #undefs, to provide specific cursor kinds for those.\n\n      SourceLocation BeginLoc = Tok.getLocation();\n      if (lexNext(Lex, Tok, NextIdx, NumTokens))\n        break;\n\n      MacroInfo *MI = nullptr;\n      if (Tok.is(tok::raw_identifier) && Tok.getRawIdentifier() == \"define\") {\n        if (lexNext(Lex, Tok, NextIdx, NumTokens))\n          break;\n\n        if (Tok.is(tok::raw_identifier)) {\n          IdentifierInfo &II =\n              PP.getIdentifierTable().get(Tok.getRawIdentifier());\n          SourceLocation MappedTokLoc =\n              CXXUnit->mapLocationToPreamble(Tok.getLocation());\n          MI = getMacroInfo(II, MappedTokLoc, TU);\n        }\n      }\n\n      bool finished = false;\n      do {\n        if (lexNext(Lex, Tok, NextIdx, NumTokens)) {\n          finished = true;\n          break;\n        }\n        // If we are in a macro definition, check if the token was ever a\n        // macro name and annotate it if that's the case.\n        if (MI) {\n          SourceLocation SaveLoc = Tok.getLocation();\n          Tok.setLocation(CXXUnit->mapLocationToPreamble(SaveLoc));\n          MacroDefinitionRecord *MacroDef =\n              checkForMacroInMacroDefinition(MI, Tok, TU);\n          Tok.setLocation(SaveLoc);\n          if (MacroDef)\n            Cursors[NextIdx - 1] =\n                MakeMacroExpansionCursor(MacroDef, Tok.getLocation(), TU);\n        }\n      } while (!Tok.isAtStartOfLine());\n\n      unsigned LastIdx = finished ? NextIdx - 1 : NextIdx - 2;\n      assert(TokIdx <= LastIdx);\n      SourceLocation EndLoc =\n          SourceLocation::getFromRawEncoding(Tokens[LastIdx].int_data[1]);\n      CXCursor Cursor =\n          MakePreprocessingDirectiveCursor(SourceRange(BeginLoc, EndLoc), TU);\n\n      for (; TokIdx <= LastIdx; ++TokIdx)\n        updateCursorAnnotation(Cursors[TokIdx], Cursor);\n\n      if (finished)\n        break;\n      goto reprocess;\n    }\n  }\n}\n\n// This gets run a separate thread to avoid stack blowout.\nstatic void clang_annotateTokensImpl(CXTranslationUnit TU, ASTUnit *CXXUnit,\n                                     CXToken *Tokens, unsigned NumTokens,\n                                     CXCursor *Cursors) {\n  CIndexer *CXXIdx = TU->CIdx;\n  if (CXXIdx->isOptEnabled(CXGlobalOpt_ThreadBackgroundPriorityForEditing))\n    setThreadBackgroundPriority();\n\n  // Determine the region of interest, which contains all of the tokens.\n  SourceRange RegionOfInterest;\n  RegionOfInterest.setBegin(\n      cxloc::translateSourceLocation(clang_getTokenLocation(TU, Tokens[0])));\n  RegionOfInterest.setEnd(cxloc::translateSourceLocation(\n      clang_getTokenLocation(TU, Tokens[NumTokens - 1])));\n\n  // Relex the tokens within the source range to look for preprocessing\n  // directives.\n  annotatePreprocessorTokens(TU, RegionOfInterest, Cursors, Tokens, NumTokens);\n\n  // If begin location points inside a macro argument, set it to the expansion\n  // location so we can have the full context when annotating semantically.\n  {\n    SourceManager &SM = CXXUnit->getSourceManager();\n    SourceLocation Loc =\n        SM.getMacroArgExpandedLocation(RegionOfInterest.getBegin());\n    if (Loc.isMacroID())\n      RegionOfInterest.setBegin(SM.getExpansionLoc(Loc));\n  }\n\n  if (CXXUnit->getPreprocessor().getPreprocessingRecord()) {\n    // Search and mark tokens that are macro argument expansions.\n    MarkMacroArgTokensVisitor Visitor(CXXUnit->getSourceManager(), Tokens,\n                                      NumTokens);\n    CursorVisitor MacroArgMarker(\n        TU, MarkMacroArgTokensVisitorDelegate, &Visitor,\n        /*VisitPreprocessorLast=*/true,\n        /*VisitIncludedEntities=*/false, RegionOfInterest);\n    MacroArgMarker.visitPreprocessedEntitiesInRegion();\n  }\n\n  // Annotate all of the source locations in the region of interest that map to\n  // a specific cursor.\n  AnnotateTokensWorker W(Tokens, Cursors, NumTokens, TU, RegionOfInterest);\n\n  // FIXME: We use a ridiculous stack size here because the data-recursion\n  // algorithm uses a large stack frame than the non-data recursive version,\n  // and AnnotationTokensWorker currently transforms the data-recursion\n  // algorithm back into a traditional recursion by explicitly calling\n  // VisitChildren().  We will need to remove this explicit recursive call.\n  W.AnnotateTokens();\n\n  // If we ran into any entities that involve context-sensitive keywords,\n  // take another pass through the tokens to mark them as such.\n  if (W.hasContextSensitiveKeywords()) {\n    for (unsigned I = 0; I != NumTokens; ++I) {\n      if (clang_getTokenKind(Tokens[I]) != CXToken_Identifier)\n        continue;\n\n      if (Cursors[I].kind == CXCursor_ObjCPropertyDecl) {\n        IdentifierInfo *II = static_cast<IdentifierInfo *>(Tokens[I].ptr_data);\n        if (const ObjCPropertyDecl *Property =\n                dyn_cast_or_null<ObjCPropertyDecl>(getCursorDecl(Cursors[I]))) {\n          if (Property->getPropertyAttributesAsWritten() != 0 &&\n              llvm::StringSwitch<bool>(II->getName())\n                  .Case(\"readonly\", true)\n                  .Case(\"assign\", true)\n                  .Case(\"unsafe_unretained\", true)\n                  .Case(\"readwrite\", true)\n                  .Case(\"retain\", true)\n                  .Case(\"copy\", true)\n                  .Case(\"nonatomic\", true)\n                  .Case(\"atomic\", true)\n                  .Case(\"getter\", true)\n                  .Case(\"setter\", true)\n                  .Case(\"strong\", true)\n                  .Case(\"weak\", true)\n                  .Case(\"class\", true)\n                  .Default(false))\n            Tokens[I].int_data[0] = CXToken_Keyword;\n        }\n        continue;\n      }\n\n      if (Cursors[I].kind == CXCursor_ObjCInstanceMethodDecl ||\n          Cursors[I].kind == CXCursor_ObjCClassMethodDecl) {\n        IdentifierInfo *II = static_cast<IdentifierInfo *>(Tokens[I].ptr_data);\n        if (llvm::StringSwitch<bool>(II->getName())\n                .Case(\"in\", true)\n                .Case(\"out\", true)\n                .Case(\"inout\", true)\n                .Case(\"oneway\", true)\n                .Case(\"bycopy\", true)\n                .Case(\"byref\", true)\n                .Default(false))\n          Tokens[I].int_data[0] = CXToken_Keyword;\n        continue;\n      }\n\n      if (Cursors[I].kind == CXCursor_CXXFinalAttr ||\n          Cursors[I].kind == CXCursor_CXXOverrideAttr) {\n        Tokens[I].int_data[0] = CXToken_Keyword;\n        continue;\n      }\n    }\n  }\n}\n\nvoid clang_annotateTokens(CXTranslationUnit TU, CXToken *Tokens,\n                          unsigned NumTokens, CXCursor *Cursors) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return;\n  }\n  if (NumTokens == 0 || !Tokens || !Cursors) {\n    LOG_FUNC_SECTION { *Log << \"<null input>\"; }\n    return;\n  }\n\n  LOG_FUNC_SECTION {\n    *Log << TU << ' ';\n    CXSourceLocation bloc = clang_getTokenLocation(TU, Tokens[0]);\n    CXSourceLocation eloc = clang_getTokenLocation(TU, Tokens[NumTokens - 1]);\n    *Log << clang_getRange(bloc, eloc);\n  }\n\n  // Any token we don't specifically annotate will have a NULL cursor.\n  CXCursor C = clang_getNullCursor();\n  for (unsigned I = 0; I != NumTokens; ++I)\n    Cursors[I] = C;\n\n  ASTUnit *CXXUnit = cxtu::getASTUnit(TU);\n  if (!CXXUnit)\n    return;\n\n  ASTUnit::ConcurrencyCheck Check(*CXXUnit);\n\n  auto AnnotateTokensImpl = [=]() {\n    clang_annotateTokensImpl(TU, CXXUnit, Tokens, NumTokens, Cursors);\n  };\n  llvm::CrashRecoveryContext CRC;\n  if (!RunSafely(CRC, AnnotateTokensImpl, GetSafetyThreadStackSize() * 2)) {\n    fprintf(stderr, \"libclang: crash detected while annotating tokens\\n\");\n  }\n}\n\n//===----------------------------------------------------------------------===//\n// Operations for querying linkage of a cursor.\n//===----------------------------------------------------------------------===//\n\nCXLinkageKind clang_getCursorLinkage(CXCursor cursor) {\n  if (!clang_isDeclaration(cursor.kind))\n    return CXLinkage_Invalid;\n\n  const Decl *D = cxcursor::getCursorDecl(cursor);\n  if (const NamedDecl *ND = dyn_cast_or_null<NamedDecl>(D))\n    switch (ND->getLinkageInternal()) {\n    case NoLinkage:\n    case VisibleNoLinkage:\n      return CXLinkage_NoLinkage;\n    case ModuleInternalLinkage:\n    case InternalLinkage:\n      return CXLinkage_Internal;\n    case UniqueExternalLinkage:\n      return CXLinkage_UniqueExternal;\n    case ModuleLinkage:\n    case ExternalLinkage:\n      return CXLinkage_External;\n    };\n\n  return CXLinkage_Invalid;\n}\n\n//===----------------------------------------------------------------------===//\n// Operations for querying visibility of a cursor.\n//===----------------------------------------------------------------------===//\n\nCXVisibilityKind clang_getCursorVisibility(CXCursor cursor) {\n  if (!clang_isDeclaration(cursor.kind))\n    return CXVisibility_Invalid;\n\n  const Decl *D = cxcursor::getCursorDecl(cursor);\n  if (const NamedDecl *ND = dyn_cast_or_null<NamedDecl>(D))\n    switch (ND->getVisibility()) {\n    case HiddenVisibility:\n      return CXVisibility_Hidden;\n    case ProtectedVisibility:\n      return CXVisibility_Protected;\n    case DefaultVisibility:\n      return CXVisibility_Default;\n    };\n\n  return CXVisibility_Invalid;\n}\n\n//===----------------------------------------------------------------------===//\n// Operations for querying language of a cursor.\n//===----------------------------------------------------------------------===//\n\nstatic CXLanguageKind getDeclLanguage(const Decl *D) {\n  if (!D)\n    return CXLanguage_C;\n\n  switch (D->getKind()) {\n  default:\n    break;\n  case Decl::ImplicitParam:\n  case Decl::ObjCAtDefsField:\n  case Decl::ObjCCategory:\n  case Decl::ObjCCategoryImpl:\n  case Decl::ObjCCompatibleAlias:\n  case Decl::ObjCImplementation:\n  case Decl::ObjCInterface:\n  case Decl::ObjCIvar:\n  case Decl::ObjCMethod:\n  case Decl::ObjCProperty:\n  case Decl::ObjCPropertyImpl:\n  case Decl::ObjCProtocol:\n  case Decl::ObjCTypeParam:\n    return CXLanguage_ObjC;\n  case Decl::CXXConstructor:\n  case Decl::CXXConversion:\n  case Decl::CXXDestructor:\n  case Decl::CXXMethod:\n  case Decl::CXXRecord:\n  case Decl::ClassTemplate:\n  case Decl::ClassTemplatePartialSpecialization:\n  case Decl::ClassTemplateSpecialization:\n  case Decl::Friend:\n  case Decl::FriendTemplate:\n  case Decl::FunctionTemplate:\n  case Decl::LinkageSpec:\n  case Decl::Namespace:\n  case Decl::NamespaceAlias:\n  case Decl::NonTypeTemplateParm:\n  case Decl::StaticAssert:\n  case Decl::TemplateTemplateParm:\n  case Decl::TemplateTypeParm:\n  case Decl::UnresolvedUsingTypename:\n  case Decl::UnresolvedUsingValue:\n  case Decl::Using:\n  case Decl::UsingDirective:\n  case Decl::UsingShadow:\n    return CXLanguage_CPlusPlus;\n  }\n\n  return CXLanguage_C;\n}\n\nstatic CXAvailabilityKind getCursorAvailabilityForDecl(const Decl *D) {\n  if (isa<FunctionDecl>(D) && cast<FunctionDecl>(D)->isDeleted())\n    return CXAvailability_NotAvailable;\n\n  switch (D->getAvailability()) {\n  case AR_Available:\n  case AR_NotYetIntroduced:\n    if (const EnumConstantDecl *EnumConst = dyn_cast<EnumConstantDecl>(D))\n      return getCursorAvailabilityForDecl(\n          cast<Decl>(EnumConst->getDeclContext()));\n    return CXAvailability_Available;\n\n  case AR_Deprecated:\n    return CXAvailability_Deprecated;\n\n  case AR_Unavailable:\n    return CXAvailability_NotAvailable;\n  }\n\n  llvm_unreachable(\"Unknown availability kind!\");\n}\n\nenum CXAvailabilityKind clang_getCursorAvailability(CXCursor cursor) {\n  if (clang_isDeclaration(cursor.kind))\n    if (const Decl *D = cxcursor::getCursorDecl(cursor))\n      return getCursorAvailabilityForDecl(D);\n\n  return CXAvailability_Available;\n}\n\nstatic CXVersion convertVersion(VersionTuple In) {\n  CXVersion Out = {-1, -1, -1};\n  if (In.empty())\n    return Out;\n\n  Out.Major = In.getMajor();\n\n  Optional<unsigned> Minor = In.getMinor();\n  if (Minor.hasValue())\n    Out.Minor = *Minor;\n  else\n    return Out;\n\n  Optional<unsigned> Subminor = In.getSubminor();\n  if (Subminor.hasValue())\n    Out.Subminor = *Subminor;\n\n  return Out;\n}\n\nstatic void getCursorPlatformAvailabilityForDecl(\n    const Decl *D, int *always_deprecated, CXString *deprecated_message,\n    int *always_unavailable, CXString *unavailable_message,\n    SmallVectorImpl<AvailabilityAttr *> &AvailabilityAttrs) {\n  bool HadAvailAttr = false;\n  for (auto A : D->attrs()) {\n    if (DeprecatedAttr *Deprecated = dyn_cast<DeprecatedAttr>(A)) {\n      HadAvailAttr = true;\n      if (always_deprecated)\n        *always_deprecated = 1;\n      if (deprecated_message) {\n        clang_disposeString(*deprecated_message);\n        *deprecated_message = cxstring::createDup(Deprecated->getMessage());\n      }\n      continue;\n    }\n\n    if (UnavailableAttr *Unavailable = dyn_cast<UnavailableAttr>(A)) {\n      HadAvailAttr = true;\n      if (always_unavailable)\n        *always_unavailable = 1;\n      if (unavailable_message) {\n        clang_disposeString(*unavailable_message);\n        *unavailable_message = cxstring::createDup(Unavailable->getMessage());\n      }\n      continue;\n    }\n\n    if (AvailabilityAttr *Avail = dyn_cast<AvailabilityAttr>(A)) {\n      AvailabilityAttrs.push_back(Avail);\n      HadAvailAttr = true;\n    }\n  }\n\n  if (!HadAvailAttr)\n    if (const EnumConstantDecl *EnumConst = dyn_cast<EnumConstantDecl>(D))\n      return getCursorPlatformAvailabilityForDecl(\n          cast<Decl>(EnumConst->getDeclContext()), always_deprecated,\n          deprecated_message, always_unavailable, unavailable_message,\n          AvailabilityAttrs);\n\n  if (AvailabilityAttrs.empty())\n    return;\n\n  llvm::sort(\n      AvailabilityAttrs, [](AvailabilityAttr *LHS, AvailabilityAttr *RHS) {\n        return LHS->getPlatform()->getName() < RHS->getPlatform()->getName();\n      });\n  ASTContext &Ctx = D->getASTContext();\n  auto It = std::unique(\n      AvailabilityAttrs.begin(), AvailabilityAttrs.end(),\n      [&Ctx](AvailabilityAttr *LHS, AvailabilityAttr *RHS) {\n        if (LHS->getPlatform() != RHS->getPlatform())\n          return false;\n\n        if (LHS->getIntroduced() == RHS->getIntroduced() &&\n            LHS->getDeprecated() == RHS->getDeprecated() &&\n            LHS->getObsoleted() == RHS->getObsoleted() &&\n            LHS->getMessage() == RHS->getMessage() &&\n            LHS->getReplacement() == RHS->getReplacement())\n          return true;\n\n        if ((!LHS->getIntroduced().empty() && !RHS->getIntroduced().empty()) ||\n            (!LHS->getDeprecated().empty() && !RHS->getDeprecated().empty()) ||\n            (!LHS->getObsoleted().empty() && !RHS->getObsoleted().empty()))\n          return false;\n\n        if (LHS->getIntroduced().empty() && !RHS->getIntroduced().empty())\n          LHS->setIntroduced(Ctx, RHS->getIntroduced());\n\n        if (LHS->getDeprecated().empty() && !RHS->getDeprecated().empty()) {\n          LHS->setDeprecated(Ctx, RHS->getDeprecated());\n          if (LHS->getMessage().empty())\n            LHS->setMessage(Ctx, RHS->getMessage());\n          if (LHS->getReplacement().empty())\n            LHS->setReplacement(Ctx, RHS->getReplacement());\n        }\n\n        if (LHS->getObsoleted().empty() && !RHS->getObsoleted().empty()) {\n          LHS->setObsoleted(Ctx, RHS->getObsoleted());\n          if (LHS->getMessage().empty())\n            LHS->setMessage(Ctx, RHS->getMessage());\n          if (LHS->getReplacement().empty())\n            LHS->setReplacement(Ctx, RHS->getReplacement());\n        }\n\n        return true;\n      });\n  AvailabilityAttrs.erase(It, AvailabilityAttrs.end());\n}\n\nint clang_getCursorPlatformAvailability(CXCursor cursor, int *always_deprecated,\n                                        CXString *deprecated_message,\n                                        int *always_unavailable,\n                                        CXString *unavailable_message,\n                                        CXPlatformAvailability *availability,\n                                        int availability_size) {\n  if (always_deprecated)\n    *always_deprecated = 0;\n  if (deprecated_message)\n    *deprecated_message = cxstring::createEmpty();\n  if (always_unavailable)\n    *always_unavailable = 0;\n  if (unavailable_message)\n    *unavailable_message = cxstring::createEmpty();\n\n  if (!clang_isDeclaration(cursor.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(cursor);\n  if (!D)\n    return 0;\n\n  SmallVector<AvailabilityAttr *, 8> AvailabilityAttrs;\n  getCursorPlatformAvailabilityForDecl(D, always_deprecated, deprecated_message,\n                                       always_unavailable, unavailable_message,\n                                       AvailabilityAttrs);\n  for (const auto &Avail :\n       llvm::enumerate(llvm::makeArrayRef(AvailabilityAttrs)\n                           .take_front(availability_size))) {\n    availability[Avail.index()].Platform =\n        cxstring::createDup(Avail.value()->getPlatform()->getName());\n    availability[Avail.index()].Introduced =\n        convertVersion(Avail.value()->getIntroduced());\n    availability[Avail.index()].Deprecated =\n        convertVersion(Avail.value()->getDeprecated());\n    availability[Avail.index()].Obsoleted =\n        convertVersion(Avail.value()->getObsoleted());\n    availability[Avail.index()].Unavailable = Avail.value()->getUnavailable();\n    availability[Avail.index()].Message =\n        cxstring::createDup(Avail.value()->getMessage());\n  }\n\n  return AvailabilityAttrs.size();\n}\n\nvoid clang_disposeCXPlatformAvailability(CXPlatformAvailability *availability) {\n  clang_disposeString(availability->Platform);\n  clang_disposeString(availability->Message);\n}\n\nCXLanguageKind clang_getCursorLanguage(CXCursor cursor) {\n  if (clang_isDeclaration(cursor.kind))\n    return getDeclLanguage(cxcursor::getCursorDecl(cursor));\n\n  return CXLanguage_Invalid;\n}\n\nCXTLSKind clang_getCursorTLSKind(CXCursor cursor) {\n  const Decl *D = cxcursor::getCursorDecl(cursor);\n  if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {\n    switch (VD->getTLSKind()) {\n    case VarDecl::TLS_None:\n      return CXTLS_None;\n    case VarDecl::TLS_Dynamic:\n      return CXTLS_Dynamic;\n    case VarDecl::TLS_Static:\n      return CXTLS_Static;\n    }\n  }\n\n  return CXTLS_None;\n}\n\n/// If the given cursor is the \"templated\" declaration\n/// describing a class or function template, return the class or\n/// function template.\nstatic const Decl *maybeGetTemplateCursor(const Decl *D) {\n  if (!D)\n    return nullptr;\n\n  if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D))\n    if (FunctionTemplateDecl *FunTmpl = FD->getDescribedFunctionTemplate())\n      return FunTmpl;\n\n  if (const CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(D))\n    if (ClassTemplateDecl *ClassTmpl = RD->getDescribedClassTemplate())\n      return ClassTmpl;\n\n  return D;\n}\n\nenum CX_StorageClass clang_Cursor_getStorageClass(CXCursor C) {\n  StorageClass sc = SC_None;\n  const Decl *D = getCursorDecl(C);\n  if (D) {\n    if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {\n      sc = FD->getStorageClass();\n    } else if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {\n      sc = VD->getStorageClass();\n    } else {\n      return CX_SC_Invalid;\n    }\n  } else {\n    return CX_SC_Invalid;\n  }\n  switch (sc) {\n  case SC_None:\n    return CX_SC_None;\n  case SC_Extern:\n    return CX_SC_Extern;\n  case SC_Static:\n    return CX_SC_Static;\n  case SC_PrivateExtern:\n    return CX_SC_PrivateExtern;\n  case SC_Auto:\n    return CX_SC_Auto;\n  case SC_Register:\n    return CX_SC_Register;\n  }\n  llvm_unreachable(\"Unhandled storage class!\");\n}\n\nCXCursor clang_getCursorSemanticParent(CXCursor cursor) {\n  if (clang_isDeclaration(cursor.kind)) {\n    if (const Decl *D = getCursorDecl(cursor)) {\n      const DeclContext *DC = D->getDeclContext();\n      if (!DC)\n        return clang_getNullCursor();\n\n      return MakeCXCursor(maybeGetTemplateCursor(cast<Decl>(DC)),\n                          getCursorTU(cursor));\n    }\n  }\n\n  if (clang_isStatement(cursor.kind) || clang_isExpression(cursor.kind)) {\n    if (const Decl *D = getCursorDecl(cursor))\n      return MakeCXCursor(D, getCursorTU(cursor));\n  }\n\n  return clang_getNullCursor();\n}\n\nCXCursor clang_getCursorLexicalParent(CXCursor cursor) {\n  if (clang_isDeclaration(cursor.kind)) {\n    if (const Decl *D = getCursorDecl(cursor)) {\n      const DeclContext *DC = D->getLexicalDeclContext();\n      if (!DC)\n        return clang_getNullCursor();\n\n      return MakeCXCursor(maybeGetTemplateCursor(cast<Decl>(DC)),\n                          getCursorTU(cursor));\n    }\n  }\n\n  // FIXME: Note that we can't easily compute the lexical context of a\n  // statement or expression, so we return nothing.\n  return clang_getNullCursor();\n}\n\nCXFile clang_getIncludedFile(CXCursor cursor) {\n  if (cursor.kind != CXCursor_InclusionDirective)\n    return nullptr;\n\n  const InclusionDirective *ID = getCursorInclusionDirective(cursor);\n  return const_cast<FileEntry *>(ID->getFile());\n}\n\nunsigned clang_Cursor_getObjCPropertyAttributes(CXCursor C, unsigned reserved) {\n  if (C.kind != CXCursor_ObjCPropertyDecl)\n    return CXObjCPropertyAttr_noattr;\n\n  unsigned Result = CXObjCPropertyAttr_noattr;\n  const ObjCPropertyDecl *PD = dyn_cast<ObjCPropertyDecl>(getCursorDecl(C));\n  ObjCPropertyAttribute::Kind Attr = PD->getPropertyAttributesAsWritten();\n\n#define SET_CXOBJCPROP_ATTR(A)                                                 \\\n  if (Attr & ObjCPropertyAttribute::kind_##A)                                  \\\n  Result |= CXObjCPropertyAttr_##A\n  SET_CXOBJCPROP_ATTR(readonly);\n  SET_CXOBJCPROP_ATTR(getter);\n  SET_CXOBJCPROP_ATTR(assign);\n  SET_CXOBJCPROP_ATTR(readwrite);\n  SET_CXOBJCPROP_ATTR(retain);\n  SET_CXOBJCPROP_ATTR(copy);\n  SET_CXOBJCPROP_ATTR(nonatomic);\n  SET_CXOBJCPROP_ATTR(setter);\n  SET_CXOBJCPROP_ATTR(atomic);\n  SET_CXOBJCPROP_ATTR(weak);\n  SET_CXOBJCPROP_ATTR(strong);\n  SET_CXOBJCPROP_ATTR(unsafe_unretained);\n  SET_CXOBJCPROP_ATTR(class);\n#undef SET_CXOBJCPROP_ATTR\n\n  return Result;\n}\n\nCXString clang_Cursor_getObjCPropertyGetterName(CXCursor C) {\n  if (C.kind != CXCursor_ObjCPropertyDecl)\n    return cxstring::createNull();\n\n  const ObjCPropertyDecl *PD = dyn_cast<ObjCPropertyDecl>(getCursorDecl(C));\n  Selector sel = PD->getGetterName();\n  if (sel.isNull())\n    return cxstring::createNull();\n\n  return cxstring::createDup(sel.getAsString());\n}\n\nCXString clang_Cursor_getObjCPropertySetterName(CXCursor C) {\n  if (C.kind != CXCursor_ObjCPropertyDecl)\n    return cxstring::createNull();\n\n  const ObjCPropertyDecl *PD = dyn_cast<ObjCPropertyDecl>(getCursorDecl(C));\n  Selector sel = PD->getSetterName();\n  if (sel.isNull())\n    return cxstring::createNull();\n\n  return cxstring::createDup(sel.getAsString());\n}\n\nunsigned clang_Cursor_getObjCDeclQualifiers(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return CXObjCDeclQualifier_None;\n\n  Decl::ObjCDeclQualifier QT = Decl::OBJC_TQ_None;\n  const Decl *D = getCursorDecl(C);\n  if (const ObjCMethodDecl *MD = dyn_cast<ObjCMethodDecl>(D))\n    QT = MD->getObjCDeclQualifier();\n  else if (const ParmVarDecl *PD = dyn_cast<ParmVarDecl>(D))\n    QT = PD->getObjCDeclQualifier();\n  if (QT == Decl::OBJC_TQ_None)\n    return CXObjCDeclQualifier_None;\n\n  unsigned Result = CXObjCDeclQualifier_None;\n  if (QT & Decl::OBJC_TQ_In)\n    Result |= CXObjCDeclQualifier_In;\n  if (QT & Decl::OBJC_TQ_Inout)\n    Result |= CXObjCDeclQualifier_Inout;\n  if (QT & Decl::OBJC_TQ_Out)\n    Result |= CXObjCDeclQualifier_Out;\n  if (QT & Decl::OBJC_TQ_Bycopy)\n    Result |= CXObjCDeclQualifier_Bycopy;\n  if (QT & Decl::OBJC_TQ_Byref)\n    Result |= CXObjCDeclQualifier_Byref;\n  if (QT & Decl::OBJC_TQ_Oneway)\n    Result |= CXObjCDeclQualifier_Oneway;\n\n  return Result;\n}\n\nunsigned clang_Cursor_isObjCOptional(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = getCursorDecl(C);\n  if (const ObjCPropertyDecl *PD = dyn_cast<ObjCPropertyDecl>(D))\n    return PD->getPropertyImplementation() == ObjCPropertyDecl::Optional;\n  if (const ObjCMethodDecl *MD = dyn_cast<ObjCMethodDecl>(D))\n    return MD->getImplementationControl() == ObjCMethodDecl::Optional;\n\n  return 0;\n}\n\nunsigned clang_Cursor_isVariadic(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = getCursorDecl(C);\n  if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D))\n    return FD->isVariadic();\n  if (const ObjCMethodDecl *MD = dyn_cast<ObjCMethodDecl>(D))\n    return MD->isVariadic();\n\n  return 0;\n}\n\nunsigned clang_Cursor_isExternalSymbol(CXCursor C, CXString *language,\n                                       CXString *definedIn,\n                                       unsigned *isGenerated) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = getCursorDecl(C);\n\n  if (auto *attr = D->getExternalSourceSymbolAttr()) {\n    if (language)\n      *language = cxstring::createDup(attr->getLanguage());\n    if (definedIn)\n      *definedIn = cxstring::createDup(attr->getDefinedIn());\n    if (isGenerated)\n      *isGenerated = attr->getGeneratedDeclaration();\n    return 1;\n  }\n  return 0;\n}\n\nCXSourceRange clang_Cursor_getCommentRange(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return clang_getNullRange();\n\n  const Decl *D = getCursorDecl(C);\n  ASTContext &Context = getCursorContext(C);\n  const RawComment *RC = Context.getRawCommentForAnyRedecl(D);\n  if (!RC)\n    return clang_getNullRange();\n\n  return cxloc::translateSourceRange(Context, RC->getSourceRange());\n}\n\nCXString clang_Cursor_getRawCommentText(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return cxstring::createNull();\n\n  const Decl *D = getCursorDecl(C);\n  ASTContext &Context = getCursorContext(C);\n  const RawComment *RC = Context.getRawCommentForAnyRedecl(D);\n  StringRef RawText =\n      RC ? RC->getRawText(Context.getSourceManager()) : StringRef();\n\n  // Don't duplicate the string because RawText points directly into source\n  // code.\n  return cxstring::createRef(RawText);\n}\n\nCXString clang_Cursor_getBriefCommentText(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return cxstring::createNull();\n\n  const Decl *D = getCursorDecl(C);\n  const ASTContext &Context = getCursorContext(C);\n  const RawComment *RC = Context.getRawCommentForAnyRedecl(D);\n\n  if (RC) {\n    StringRef BriefText = RC->getBriefText(Context);\n\n    // Don't duplicate the string because RawComment ensures that this memory\n    // will not go away.\n    return cxstring::createRef(BriefText);\n  }\n\n  return cxstring::createNull();\n}\n\nCXModule clang_Cursor_getModule(CXCursor C) {\n  if (C.kind == CXCursor_ModuleImportDecl) {\n    if (const ImportDecl *ImportD =\n            dyn_cast_or_null<ImportDecl>(getCursorDecl(C)))\n      return ImportD->getImportedModule();\n  }\n\n  return nullptr;\n}\n\nCXModule clang_getModuleForFile(CXTranslationUnit TU, CXFile File) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return nullptr;\n  }\n  if (!File)\n    return nullptr;\n  FileEntry *FE = static_cast<FileEntry *>(File);\n\n  ASTUnit &Unit = *cxtu::getASTUnit(TU);\n  HeaderSearch &HS = Unit.getPreprocessor().getHeaderSearchInfo();\n  ModuleMap::KnownHeader Header = HS.findModuleForHeader(FE);\n\n  return Header.getModule();\n}\n\nCXFile clang_Module_getASTFile(CXModule CXMod) {\n  if (!CXMod)\n    return nullptr;\n  Module *Mod = static_cast<Module *>(CXMod);\n  if (auto File = Mod->getASTFile())\n    return const_cast<FileEntry *>(&File->getFileEntry());\n  return nullptr;\n}\n\nCXModule clang_Module_getParent(CXModule CXMod) {\n  if (!CXMod)\n    return nullptr;\n  Module *Mod = static_cast<Module *>(CXMod);\n  return Mod->Parent;\n}\n\nCXString clang_Module_getName(CXModule CXMod) {\n  if (!CXMod)\n    return cxstring::createEmpty();\n  Module *Mod = static_cast<Module *>(CXMod);\n  return cxstring::createDup(Mod->Name);\n}\n\nCXString clang_Module_getFullName(CXModule CXMod) {\n  if (!CXMod)\n    return cxstring::createEmpty();\n  Module *Mod = static_cast<Module *>(CXMod);\n  return cxstring::createDup(Mod->getFullModuleName());\n}\n\nint clang_Module_isSystem(CXModule CXMod) {\n  if (!CXMod)\n    return 0;\n  Module *Mod = static_cast<Module *>(CXMod);\n  return Mod->IsSystem;\n}\n\nunsigned clang_Module_getNumTopLevelHeaders(CXTranslationUnit TU,\n                                            CXModule CXMod) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return 0;\n  }\n  if (!CXMod)\n    return 0;\n  Module *Mod = static_cast<Module *>(CXMod);\n  FileManager &FileMgr = cxtu::getASTUnit(TU)->getFileManager();\n  ArrayRef<const FileEntry *> TopHeaders = Mod->getTopHeaders(FileMgr);\n  return TopHeaders.size();\n}\n\nCXFile clang_Module_getTopLevelHeader(CXTranslationUnit TU, CXModule CXMod,\n                                      unsigned Index) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return nullptr;\n  }\n  if (!CXMod)\n    return nullptr;\n  Module *Mod = static_cast<Module *>(CXMod);\n  FileManager &FileMgr = cxtu::getASTUnit(TU)->getFileManager();\n\n  ArrayRef<const FileEntry *> TopHeaders = Mod->getTopHeaders(FileMgr);\n  if (Index < TopHeaders.size())\n    return const_cast<FileEntry *>(TopHeaders[Index]);\n\n  return nullptr;\n}\n\n//===----------------------------------------------------------------------===//\n// C++ AST instrospection.\n//===----------------------------------------------------------------------===//\n\nunsigned clang_CXXConstructor_isDefaultConstructor(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXConstructorDecl *Constructor =\n      D ? dyn_cast_or_null<CXXConstructorDecl>(D->getAsFunction()) : nullptr;\n  return (Constructor && Constructor->isDefaultConstructor()) ? 1 : 0;\n}\n\nunsigned clang_CXXConstructor_isCopyConstructor(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXConstructorDecl *Constructor =\n      D ? dyn_cast_or_null<CXXConstructorDecl>(D->getAsFunction()) : nullptr;\n  return (Constructor && Constructor->isCopyConstructor()) ? 1 : 0;\n}\n\nunsigned clang_CXXConstructor_isMoveConstructor(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXConstructorDecl *Constructor =\n      D ? dyn_cast_or_null<CXXConstructorDecl>(D->getAsFunction()) : nullptr;\n  return (Constructor && Constructor->isMoveConstructor()) ? 1 : 0;\n}\n\nunsigned clang_CXXConstructor_isConvertingConstructor(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXConstructorDecl *Constructor =\n      D ? dyn_cast_or_null<CXXConstructorDecl>(D->getAsFunction()) : nullptr;\n  // Passing 'false' excludes constructors marked 'explicit'.\n  return (Constructor && Constructor->isConvertingConstructor(false)) ? 1 : 0;\n}\n\nunsigned clang_CXXField_isMutable(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  if (const auto D = cxcursor::getCursorDecl(C))\n    if (const auto FD = dyn_cast_or_null<FieldDecl>(D))\n      return FD->isMutable() ? 1 : 0;\n  return 0;\n}\n\nunsigned clang_CXXMethod_isPureVirtual(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXMethodDecl *Method =\n      D ? dyn_cast_or_null<CXXMethodDecl>(D->getAsFunction()) : nullptr;\n  return (Method && Method->isVirtual() && Method->isPure()) ? 1 : 0;\n}\n\nunsigned clang_CXXMethod_isConst(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXMethodDecl *Method =\n      D ? dyn_cast_or_null<CXXMethodDecl>(D->getAsFunction()) : nullptr;\n  return (Method && Method->getMethodQualifiers().hasConst()) ? 1 : 0;\n}\n\nunsigned clang_CXXMethod_isDefaulted(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXMethodDecl *Method =\n      D ? dyn_cast_or_null<CXXMethodDecl>(D->getAsFunction()) : nullptr;\n  return (Method && Method->isDefaulted()) ? 1 : 0;\n}\n\nunsigned clang_CXXMethod_isStatic(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXMethodDecl *Method =\n      D ? dyn_cast_or_null<CXXMethodDecl>(D->getAsFunction()) : nullptr;\n  return (Method && Method->isStatic()) ? 1 : 0;\n}\n\nunsigned clang_CXXMethod_isVirtual(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  const CXXMethodDecl *Method =\n      D ? dyn_cast_or_null<CXXMethodDecl>(D->getAsFunction()) : nullptr;\n  return (Method && Method->isVirtual()) ? 1 : 0;\n}\n\nunsigned clang_CXXRecord_isAbstract(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const auto *D = cxcursor::getCursorDecl(C);\n  const auto *RD = dyn_cast_or_null<CXXRecordDecl>(D);\n  if (RD)\n    RD = RD->getDefinition();\n  return (RD && RD->isAbstract()) ? 1 : 0;\n}\n\nunsigned clang_EnumDecl_isScoped(CXCursor C) {\n  if (!clang_isDeclaration(C.kind))\n    return 0;\n\n  const Decl *D = cxcursor::getCursorDecl(C);\n  auto *Enum = dyn_cast_or_null<EnumDecl>(D);\n  return (Enum && Enum->isScoped()) ? 1 : 0;\n}\n\n//===----------------------------------------------------------------------===//\n// Attribute introspection.\n//===----------------------------------------------------------------------===//\n\nCXType clang_getIBOutletCollectionType(CXCursor C) {\n  if (C.kind != CXCursor_IBOutletCollectionAttr)\n    return cxtype::MakeCXType(QualType(), cxcursor::getCursorTU(C));\n\n  const IBOutletCollectionAttr *A =\n      cast<IBOutletCollectionAttr>(cxcursor::getCursorAttr(C));\n\n  return cxtype::MakeCXType(A->getInterface(), cxcursor::getCursorTU(C));\n}\n\n//===----------------------------------------------------------------------===//\n// Inspecting memory usage.\n//===----------------------------------------------------------------------===//\n\ntypedef std::vector<CXTUResourceUsageEntry> MemUsageEntries;\n\nstatic inline void createCXTUResourceUsageEntry(MemUsageEntries &entries,\n                                                enum CXTUResourceUsageKind k,\n                                                unsigned long amount) {\n  CXTUResourceUsageEntry entry = {k, amount};\n  entries.push_back(entry);\n}\n\nconst char *clang_getTUResourceUsageName(CXTUResourceUsageKind kind) {\n  const char *str = \"\";\n  switch (kind) {\n  case CXTUResourceUsage_AST:\n    str = \"ASTContext: expressions, declarations, and types\";\n    break;\n  case CXTUResourceUsage_Identifiers:\n    str = \"ASTContext: identifiers\";\n    break;\n  case CXTUResourceUsage_Selectors:\n    str = \"ASTContext: selectors\";\n    break;\n  case CXTUResourceUsage_GlobalCompletionResults:\n    str = \"Code completion: cached global results\";\n    break;\n  case CXTUResourceUsage_SourceManagerContentCache:\n    str = \"SourceManager: content cache allocator\";\n    break;\n  case CXTUResourceUsage_AST_SideTables:\n    str = \"ASTContext: side tables\";\n    break;\n  case CXTUResourceUsage_SourceManager_Membuffer_Malloc:\n    str = \"SourceManager: malloc'ed memory buffers\";\n    break;\n  case CXTUResourceUsage_SourceManager_Membuffer_MMap:\n    str = \"SourceManager: mmap'ed memory buffers\";\n    break;\n  case CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc:\n    str = \"ExternalASTSource: malloc'ed memory buffers\";\n    break;\n  case CXTUResourceUsage_ExternalASTSource_Membuffer_MMap:\n    str = \"ExternalASTSource: mmap'ed memory buffers\";\n    break;\n  case CXTUResourceUsage_Preprocessor:\n    str = \"Preprocessor: malloc'ed memory\";\n    break;\n  case CXTUResourceUsage_PreprocessingRecord:\n    str = \"Preprocessor: PreprocessingRecord\";\n    break;\n  case CXTUResourceUsage_SourceManager_DataStructures:\n    str = \"SourceManager: data structures and tables\";\n    break;\n  case CXTUResourceUsage_Preprocessor_HeaderSearch:\n    str = \"Preprocessor: header search tables\";\n    break;\n  }\n  return str;\n}\n\nCXTUResourceUsage clang_getCXTUResourceUsage(CXTranslationUnit TU) {\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    CXTUResourceUsage usage = {(void *)nullptr, 0, nullptr};\n    return usage;\n  }\n\n  ASTUnit *astUnit = cxtu::getASTUnit(TU);\n  std::unique_ptr<MemUsageEntries> entries(new MemUsageEntries());\n  ASTContext &astContext = astUnit->getASTContext();\n\n  // How much memory is used by AST nodes and types?\n  createCXTUResourceUsageEntry(\n      *entries, CXTUResourceUsage_AST,\n      (unsigned long)astContext.getASTAllocatedMemory());\n\n  // How much memory is used by identifiers?\n  createCXTUResourceUsageEntry(\n      *entries, CXTUResourceUsage_Identifiers,\n      (unsigned long)astContext.Idents.getAllocator().getTotalMemory());\n\n  // How much memory is used for selectors?\n  createCXTUResourceUsageEntry(\n      *entries, CXTUResourceUsage_Selectors,\n      (unsigned long)astContext.Selectors.getTotalMemory());\n\n  // How much memory is used by ASTContext's side tables?\n  createCXTUResourceUsageEntry(\n      *entries, CXTUResourceUsage_AST_SideTables,\n      (unsigned long)astContext.getSideTableAllocatedMemory());\n\n  // How much memory is used for caching global code completion results?\n  unsigned long completionBytes = 0;\n  if (GlobalCodeCompletionAllocator *completionAllocator =\n          astUnit->getCachedCompletionAllocator().get()) {\n    completionBytes = completionAllocator->getTotalMemory();\n  }\n  createCXTUResourceUsageEntry(\n      *entries, CXTUResourceUsage_GlobalCompletionResults, completionBytes);\n\n  // How much memory is being used by SourceManager's content cache?\n  createCXTUResourceUsageEntry(\n      *entries, CXTUResourceUsage_SourceManagerContentCache,\n      (unsigned long)astContext.getSourceManager().getContentCacheSize());\n\n  // How much memory is being used by the MemoryBuffer's in SourceManager?\n  const SourceManager::MemoryBufferSizes &srcBufs =\n      astUnit->getSourceManager().getMemoryBufferSizes();\n\n  createCXTUResourceUsageEntry(*entries,\n                               CXTUResourceUsage_SourceManager_Membuffer_Malloc,\n                               (unsigned long)srcBufs.malloc_bytes);\n  createCXTUResourceUsageEntry(*entries,\n                               CXTUResourceUsage_SourceManager_Membuffer_MMap,\n                               (unsigned long)srcBufs.mmap_bytes);\n  createCXTUResourceUsageEntry(\n      *entries, CXTUResourceUsage_SourceManager_DataStructures,\n      (unsigned long)astContext.getSourceManager().getDataStructureSizes());\n\n  // How much memory is being used by the ExternalASTSource?\n  if (ExternalASTSource *esrc = astContext.getExternalSource()) {\n    const ExternalASTSource::MemoryBufferSizes &sizes =\n        esrc->getMemoryBufferSizes();\n\n    createCXTUResourceUsageEntry(\n        *entries, CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc,\n        (unsigned long)sizes.malloc_bytes);\n    createCXTUResourceUsageEntry(\n        *entries, CXTUResourceUsage_ExternalASTSource_Membuffer_MMap,\n        (unsigned long)sizes.mmap_bytes);\n  }\n\n  // How much memory is being used by the Preprocessor?\n  Preprocessor &pp = astUnit->getPreprocessor();\n  createCXTUResourceUsageEntry(*entries, CXTUResourceUsage_Preprocessor,\n                               pp.getTotalMemory());\n\n  if (PreprocessingRecord *pRec = pp.getPreprocessingRecord()) {\n    createCXTUResourceUsageEntry(*entries,\n                                 CXTUResourceUsage_PreprocessingRecord,\n                                 pRec->getTotalMemory());\n  }\n\n  createCXTUResourceUsageEntry(*entries,\n                               CXTUResourceUsage_Preprocessor_HeaderSearch,\n                               pp.getHeaderSearchInfo().getTotalMemory());\n\n  CXTUResourceUsage usage = {(void *)entries.get(), (unsigned)entries->size(),\n                             !entries->empty() ? &(*entries)[0] : nullptr};\n  (void)entries.release();\n  return usage;\n}\n\nvoid clang_disposeCXTUResourceUsage(CXTUResourceUsage usage) {\n  if (usage.data)\n    delete (MemUsageEntries *)usage.data;\n}\n\nCXSourceRangeList *clang_getSkippedRanges(CXTranslationUnit TU, CXFile file) {\n  CXSourceRangeList *skipped = new CXSourceRangeList;\n  skipped->count = 0;\n  skipped->ranges = nullptr;\n\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return skipped;\n  }\n\n  if (!file)\n    return skipped;\n\n  ASTUnit *astUnit = cxtu::getASTUnit(TU);\n  PreprocessingRecord *ppRec =\n      astUnit->getPreprocessor().getPreprocessingRecord();\n  if (!ppRec)\n    return skipped;\n\n  ASTContext &Ctx = astUnit->getASTContext();\n  SourceManager &sm = Ctx.getSourceManager();\n  FileEntry *fileEntry = static_cast<FileEntry *>(file);\n  FileID wantedFileID = sm.translateFile(fileEntry);\n  bool isMainFile = wantedFileID == sm.getMainFileID();\n\n  const std::vector<SourceRange> &SkippedRanges = ppRec->getSkippedRanges();\n  std::vector<SourceRange> wantedRanges;\n  for (std::vector<SourceRange>::const_iterator i = SkippedRanges.begin(),\n                                                ei = SkippedRanges.end();\n       i != ei; ++i) {\n    if (sm.getFileID(i->getBegin()) == wantedFileID ||\n        sm.getFileID(i->getEnd()) == wantedFileID)\n      wantedRanges.push_back(*i);\n    else if (isMainFile && (astUnit->isInPreambleFileID(i->getBegin()) ||\n                            astUnit->isInPreambleFileID(i->getEnd())))\n      wantedRanges.push_back(*i);\n  }\n\n  skipped->count = wantedRanges.size();\n  skipped->ranges = new CXSourceRange[skipped->count];\n  for (unsigned i = 0, ei = skipped->count; i != ei; ++i)\n    skipped->ranges[i] = cxloc::translateSourceRange(Ctx, wantedRanges[i]);\n\n  return skipped;\n}\n\nCXSourceRangeList *clang_getAllSkippedRanges(CXTranslationUnit TU) {\n  CXSourceRangeList *skipped = new CXSourceRangeList;\n  skipped->count = 0;\n  skipped->ranges = nullptr;\n\n  if (isNotUsableTU(TU)) {\n    LOG_BAD_TU(TU);\n    return skipped;\n  }\n\n  ASTUnit *astUnit = cxtu::getASTUnit(TU);\n  PreprocessingRecord *ppRec =\n      astUnit->getPreprocessor().getPreprocessingRecord();\n  if (!ppRec)\n    return skipped;\n\n  ASTContext &Ctx = astUnit->getASTContext();\n\n  const std::vector<SourceRange> &SkippedRanges = ppRec->getSkippedRanges();\n\n  skipped->count = SkippedRanges.size();\n  skipped->ranges = new CXSourceRange[skipped->count];\n  for (unsigned i = 0, ei = skipped->count; i != ei; ++i)\n    skipped->ranges[i] = cxloc::translateSourceRange(Ctx, SkippedRanges[i]);\n\n  return skipped;\n}\n\nvoid clang_disposeSourceRangeList(CXSourceRangeList *ranges) {\n  if (ranges) {\n    delete[] ranges->ranges;\n    delete ranges;\n  }\n}\n\nvoid clang::PrintLibclangResourceUsage(CXTranslationUnit TU) {\n  CXTUResourceUsage Usage = clang_getCXTUResourceUsage(TU);\n  for (unsigned I = 0; I != Usage.numEntries; ++I)\n    fprintf(stderr, \"  %s: %lu\\n\",\n            clang_getTUResourceUsageName(Usage.entries[I].kind),\n            Usage.entries[I].amount);\n\n  clang_disposeCXTUResourceUsage(Usage);\n}\n\nCXCursor clang_Cursor_getVarDeclInitializer(CXCursor cursor) {\n  const Decl *const D = getCursorDecl(cursor);\n  if (!D)\n    return clang_getNullCursor();\n  const auto *const VD = dyn_cast<VarDecl>(D);\n  if (!VD)\n    return clang_getNullCursor();\n  const Expr *const Init = VD->getInit();\n  if (!Init)\n    return clang_getNullCursor();\n\n  return cxcursor::MakeCXCursor(Init, VD, cxcursor::getCursorTU(cursor));\n}\n\nint clang_Cursor_hasVarDeclGlobalStorage(CXCursor cursor) {\n  const Decl *const D = getCursorDecl(cursor);\n  if (!D)\n    return -1;\n  const auto *const VD = dyn_cast<VarDecl>(D);\n  if (!VD)\n    return -1;\n\n  return VD->hasGlobalStorage();\n}\n\nint clang_Cursor_hasVarDeclExternalStorage(CXCursor cursor) {\n  const Decl *const D = getCursorDecl(cursor);\n  if (!D)\n    return -1;\n  const auto *const VD = dyn_cast<VarDecl>(D);\n  if (!VD)\n    return -1;\n\n  return VD->hasExternalStorage();\n}\n\n//===----------------------------------------------------------------------===//\n// Misc. utility functions.\n//===----------------------------------------------------------------------===//\n\n/// Default to using our desired 8 MB stack size on \"safety\" threads.\nstatic unsigned SafetyStackThreadSize = DesiredStackSize;\n\nnamespace clang {\n\nbool RunSafely(llvm::CrashRecoveryContext &CRC, llvm::function_ref<void()> Fn,\n               unsigned Size) {\n  if (!Size)\n    Size = GetSafetyThreadStackSize();\n  if (Size && !getenv(\"LIBCLANG_NOTHREADS\"))\n    return CRC.RunSafelyOnThread(Fn, Size);\n  return CRC.RunSafely(Fn);\n}\n\nunsigned GetSafetyThreadStackSize() { return SafetyStackThreadSize; }\n\nvoid SetSafetyThreadStackSize(unsigned Value) { SafetyStackThreadSize = Value; }\n\n} // namespace clang\n\nvoid clang::setThreadBackgroundPriority() {\n  if (getenv(\"LIBCLANG_BGPRIO_DISABLE\"))\n    return;\n\n#if LLVM_ENABLE_THREADS\n  llvm::set_thread_priority(llvm::ThreadPriority::Background);\n#endif\n}\n\nvoid cxindex::printDiagsToStderr(ASTUnit *Unit) {\n  if (!Unit)\n    return;\n\n  for (ASTUnit::stored_diag_iterator D = Unit->stored_diag_begin(),\n                                     DEnd = Unit->stored_diag_end();\n       D != DEnd; ++D) {\n    CXStoredDiagnostic Diag(*D, Unit->getLangOpts());\n    CXString Msg =\n        clang_formatDiagnostic(&Diag, clang_defaultDiagnosticDisplayOptions());\n    fprintf(stderr, \"%s\\n\", clang_getCString(Msg));\n    clang_disposeString(Msg);\n  }\n#ifdef _WIN32\n  // On Windows, force a flush, since there may be multiple copies of\n  // stderr and stdout in the file system, all with different buffers\n  // but writing to the same device.\n  fflush(stderr);\n#endif\n}\n\nMacroInfo *cxindex::getMacroInfo(const IdentifierInfo &II,\n                                 SourceLocation MacroDefLoc,\n                                 CXTranslationUnit TU) {\n  if (MacroDefLoc.isInvalid() || !TU)\n    return nullptr;\n  if (!II.hadMacroDefinition())\n    return nullptr;\n\n  ASTUnit *Unit = cxtu::getASTUnit(TU);\n  Preprocessor &PP = Unit->getPreprocessor();\n  MacroDirective *MD = PP.getLocalMacroDirectiveHistory(&II);\n  if (MD) {\n    for (MacroDirective::DefInfo Def = MD->getDefinition(); Def;\n         Def = Def.getPreviousDefinition()) {\n      if (MacroDefLoc == Def.getMacroInfo()->getDefinitionLoc())\n        return Def.getMacroInfo();\n    }\n  }\n\n  return nullptr;\n}\n\nconst MacroInfo *cxindex::getMacroInfo(const MacroDefinitionRecord *MacroDef,\n                                       CXTranslationUnit TU) {\n  if (!MacroDef || !TU)\n    return nullptr;\n  const IdentifierInfo *II = MacroDef->getName();\n  if (!II)\n    return nullptr;\n\n  return getMacroInfo(*II, MacroDef->getLocation(), TU);\n}\n\nMacroDefinitionRecord *\ncxindex::checkForMacroInMacroDefinition(const MacroInfo *MI, const Token &Tok,\n                                        CXTranslationUnit TU) {\n  if (!MI || !TU)\n    return nullptr;\n  if (Tok.isNot(tok::raw_identifier))\n    return nullptr;\n\n  if (MI->getNumTokens() == 0)\n    return nullptr;\n  SourceRange DefRange(MI->getReplacementToken(0).getLocation(),\n                       MI->getDefinitionEndLoc());\n  ASTUnit *Unit = cxtu::getASTUnit(TU);\n\n  // Check that the token is inside the definition and not its argument list.\n  SourceManager &SM = Unit->getSourceManager();\n  if (SM.isBeforeInTranslationUnit(Tok.getLocation(), DefRange.getBegin()))\n    return nullptr;\n  if (SM.isBeforeInTranslationUnit(DefRange.getEnd(), Tok.getLocation()))\n    return nullptr;\n\n  Preprocessor &PP = Unit->getPreprocessor();\n  PreprocessingRecord *PPRec = PP.getPreprocessingRecord();\n  if (!PPRec)\n    return nullptr;\n\n  IdentifierInfo &II = PP.getIdentifierTable().get(Tok.getRawIdentifier());\n  if (!II.hadMacroDefinition())\n    return nullptr;\n\n  // Check that the identifier is not one of the macro arguments.\n  if (std::find(MI->param_begin(), MI->param_end(), &II) != MI->param_end())\n    return nullptr;\n\n  MacroDirective *InnerMD = PP.getLocalMacroDirectiveHistory(&II);\n  if (!InnerMD)\n    return nullptr;\n\n  return PPRec->findMacroDefinition(InnerMD->getMacroInfo());\n}\n\nMacroDefinitionRecord *\ncxindex::checkForMacroInMacroDefinition(const MacroInfo *MI, SourceLocation Loc,\n                                        CXTranslationUnit TU) {\n  if (Loc.isInvalid() || !MI || !TU)\n    return nullptr;\n\n  if (MI->getNumTokens() == 0)\n    return nullptr;\n  ASTUnit *Unit = cxtu::getASTUnit(TU);\n  Preprocessor &PP = Unit->getPreprocessor();\n  if (!PP.getPreprocessingRecord())\n    return nullptr;\n  Loc = Unit->getSourceManager().getSpellingLoc(Loc);\n  Token Tok;\n  if (PP.getRawToken(Loc, Tok))\n    return nullptr;\n\n  return checkForMacroInMacroDefinition(MI, Tok, TU);\n}\n\nCXString clang_getClangVersion() {\n  return cxstring::createDup(getClangFullVersion());\n}\n\nLogger &cxindex::Logger::operator<<(CXTranslationUnit TU) {\n  if (TU) {\n    if (ASTUnit *Unit = cxtu::getASTUnit(TU)) {\n      LogOS << '<' << Unit->getMainFileName() << '>';\n      if (Unit->isMainFileAST())\n        LogOS << \" (\" << Unit->getASTFileName() << ')';\n      return *this;\n    }\n  } else {\n    LogOS << \"<NULL TU>\";\n  }\n  return *this;\n}\n\nLogger &cxindex::Logger::operator<<(const FileEntry *FE) {\n  *this << FE->getName();\n  return *this;\n}\n\nLogger &cxindex::Logger::operator<<(CXCursor cursor) {\n  CXString cursorName = clang_getCursorDisplayName(cursor);\n  *this << cursorName << \"@\" << clang_getCursorLocation(cursor);\n  clang_disposeString(cursorName);\n  return *this;\n}\n\nLogger &cxindex::Logger::operator<<(CXSourceLocation Loc) {\n  CXFile File;\n  unsigned Line, Column;\n  clang_getFileLocation(Loc, &File, &Line, &Column, nullptr);\n  CXString FileName = clang_getFileName(File);\n  *this << llvm::format(\"(%s:%d:%d)\", clang_getCString(FileName), Line, Column);\n  clang_disposeString(FileName);\n  return *this;\n}\n\nLogger &cxindex::Logger::operator<<(CXSourceRange range) {\n  CXSourceLocation BLoc = clang_getRangeStart(range);\n  CXSourceLocation ELoc = clang_getRangeEnd(range);\n\n  CXFile BFile;\n  unsigned BLine, BColumn;\n  clang_getFileLocation(BLoc, &BFile, &BLine, &BColumn, nullptr);\n\n  CXFile EFile;\n  unsigned ELine, EColumn;\n  clang_getFileLocation(ELoc, &EFile, &ELine, &EColumn, nullptr);\n\n  CXString BFileName = clang_getFileName(BFile);\n  if (BFile == EFile) {\n    *this << llvm::format(\"[%s %d:%d-%d:%d]\", clang_getCString(BFileName),\n                          BLine, BColumn, ELine, EColumn);\n  } else {\n    CXString EFileName = clang_getFileName(EFile);\n    *this << llvm::format(\"[%s:%d:%d - \", clang_getCString(BFileName), BLine,\n                          BColumn)\n          << llvm::format(\"%s:%d:%d]\", clang_getCString(EFileName), ELine,\n                          EColumn);\n    clang_disposeString(EFileName);\n  }\n  clang_disposeString(BFileName);\n  return *this;\n}\n\nLogger &cxindex::Logger::operator<<(CXString Str) {\n  *this << clang_getCString(Str);\n  return *this;\n}\n\nLogger &cxindex::Logger::operator<<(const llvm::format_object_base &Fmt) {\n  LogOS << Fmt;\n  return *this;\n}\n\nstatic llvm::ManagedStatic<std::mutex> LoggingMutex;\n\ncxindex::Logger::~Logger() {\n  std::lock_guard<std::mutex> L(*LoggingMutex);\n\n  static llvm::TimeRecord sBeginTR = llvm::TimeRecord::getCurrentTime();\n\n  raw_ostream &OS = llvm::errs();\n  OS << \"[libclang:\" << Name << ':';\n\n#ifdef USE_DARWIN_THREADS\n  // TODO: Portability.\n  mach_port_t tid = pthread_mach_thread_np(pthread_self());\n  OS << tid << ':';\n#endif\n\n  llvm::TimeRecord TR = llvm::TimeRecord::getCurrentTime();\n  OS << llvm::format(\"%7.4f] \", TR.getWallTime() - sBeginTR.getWallTime());\n  OS << Msg << '\\n';\n\n  if (Trace) {\n    llvm::sys::PrintStackTrace(OS);\n    OS << \"--------------------------------------------------\\n\";\n  }\n}\n"}, "86": {"id": 86, "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CIndexer.h", "content": "//===- CIndexer.h - Clang-C Source Indexing Library -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines CIndexer, a subclass of Indexer that provides extra\n// functionality needed by the CIndex library.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_LIBCLANG_CINDEXER_H\n#define LLVM_CLANG_TOOLS_LIBCLANG_CINDEXER_H\n\n#include \"clang-c/Index.h\"\n#include \"clang/Frontend/PCHContainerOperations.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include <utility>\n\nnamespace llvm {\n  class CrashRecoveryContext;\n}\n\nnamespace clang {\nclass ASTUnit;\nclass MacroInfo;\nclass MacroDefinitionRecord;\nclass SourceLocation;\nclass Token;\nclass IdentifierInfo;\n\nclass CIndexer {\n  bool OnlyLocalDecls;\n  bool DisplayDiagnostics;\n  unsigned Options; // CXGlobalOptFlags.\n\n  std::string ResourcesPath;\n  std::shared_ptr<PCHContainerOperations> PCHContainerOps;\n\n  std::string ToolchainPath;\n\n  std::string InvocationEmissionPath;\n\npublic:\n  CIndexer(std::shared_ptr<PCHContainerOperations> PCHContainerOps =\n               std::make_shared<PCHContainerOperations>())\n      : OnlyLocalDecls(false), DisplayDiagnostics(false),\n        Options(CXGlobalOpt_None), PCHContainerOps(std::move(PCHContainerOps)) {\n  }\n\n  /// Whether we only want to see \"local\" declarations (that did not\n  /// come from a previous precompiled header). If false, we want to see all\n  /// declarations.\n  bool getOnlyLocalDecls() const { return OnlyLocalDecls; }\n  void setOnlyLocalDecls(bool Local = true) { OnlyLocalDecls = Local; }\n  \n  bool getDisplayDiagnostics() const { return DisplayDiagnostics; }\n  void setDisplayDiagnostics(bool Display = true) {\n    DisplayDiagnostics = Display;\n  }\n\n  std::shared_ptr<PCHContainerOperations> getPCHContainerOperations() const {\n    return PCHContainerOps;\n  }\n\n  unsigned getCXGlobalOptFlags() const { return Options; }\n  void setCXGlobalOptFlags(unsigned options) { Options = options; }\n\n  bool isOptEnabled(CXGlobalOptFlags opt) const {\n    return Options & opt;\n  }\n\n  /// Get the path of the clang resource files.\n  const std::string &getClangResourcesPath();\n\n  StringRef getClangToolchainPath();\n\n  void setInvocationEmissionPath(StringRef Str) {\n    InvocationEmissionPath = std::string(Str);\n  }\n\n  StringRef getInvocationEmissionPath() const { return InvocationEmissionPath; }\n};\n\n/// Logs information about a particular libclang operation like parsing to\n/// a new file in the invocation emission path.\nclass LibclangInvocationReporter {\npublic:\n  enum class OperationKind { ParseOperation, CompletionOperation };\n\n  LibclangInvocationReporter(CIndexer &Idx, OperationKind Op,\n                             unsigned ParseOptions,\n                             llvm::ArrayRef<const char *> Args,\n                             llvm::ArrayRef<std::string> InvocationArgs,\n                             llvm::ArrayRef<CXUnsavedFile> UnsavedFiles);\n  ~LibclangInvocationReporter();\n\nprivate:\n  std::string File;\n};\n\n  /// Return the current size to request for \"safety\".\n  unsigned GetSafetyThreadStackSize();\n\n  /// Set the current size to request for \"safety\" (or 0, if safety\n  /// threads should not be used).\n  void SetSafetyThreadStackSize(unsigned Value);\n\n  /// Execution the given code \"safely\", using crash recovery or safety\n  /// threads when possible.\n  ///\n  /// \\return False if a crash was detected.\n  bool RunSafely(llvm::CrashRecoveryContext &CRC, llvm::function_ref<void()> Fn,\n                 unsigned Size = 0);\n\n  /// Set the thread priority to background.\n  /// FIXME: Move to llvm/Support.\n  void setThreadBackgroundPriority();\n\n  /// Print libclang's resource usage to standard error.\n  void PrintLibclangResourceUsage(CXTranslationUnit TU);\n\n  namespace cxindex {\n    void printDiagsToStderr(ASTUnit *Unit);\n\n    /// If \\c MacroDefLoc points at a macro definition with \\c II as\n    /// its name, this retrieves its MacroInfo.\n    MacroInfo *getMacroInfo(const IdentifierInfo &II,\n                            SourceLocation MacroDefLoc, CXTranslationUnit TU);\n\n    /// Retrieves the corresponding MacroInfo of a MacroDefinitionRecord.\n    const MacroInfo *getMacroInfo(const MacroDefinitionRecord *MacroDef,\n                                  CXTranslationUnit TU);\n\n    /// If \\c Loc resides inside the definition of \\c MI and it points at\n    /// an identifier that has ever been a macro name, this returns the latest\n    /// MacroDefinitionRecord for that name, otherwise it returns NULL.\n    MacroDefinitionRecord *checkForMacroInMacroDefinition(const MacroInfo *MI,\n                                                          SourceLocation Loc,\n                                                          CXTranslationUnit TU);\n\n    /// If \\c Tok resides inside the definition of \\c MI and it points at\n    /// an identifier that has ever been a macro name, this returns the latest\n    /// MacroDefinitionRecord for that name, otherwise it returns NULL.\n    MacroDefinitionRecord *checkForMacroInMacroDefinition(const MacroInfo *MI,\n                                                          const Token &Tok,\n                                                          CXTranslationUnit TU);\n    }\n    }\n\n#endif\n"}, "87": {"id": 87, "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CXTranslationUnit.h", "content": "//===- CXTranslationUnit.h - Routines for manipulating CXTranslationUnits -===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines routines for manipulating CXTranslationUnits.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_LIBCLANG_CXTRANSLATIONUNIT_H\n#define LLVM_CLANG_TOOLS_LIBCLANG_CXTRANSLATIONUNIT_H\n\n#include \"CLog.h\"\n#include \"CXString.h\"\n#include \"clang-c/Index.h\"\n\nnamespace clang {\n  class ASTUnit;\n  class CIndexer;\nnamespace index {\nclass CommentToXMLConverter;\n} // namespace index\n} // namespace clang\n\nstruct CXTranslationUnitImpl {\n  clang::CIndexer *CIdx;\n  clang::ASTUnit *TheASTUnit;\n  clang::cxstring::CXStringPool *StringPool;\n  void *Diagnostics;\n  void *OverridenCursorsPool;\n  clang::index::CommentToXMLConverter *CommentToXML;\n  unsigned ParsingOptions;\n  std::vector<std::string> Arguments;\n};\n\nstruct CXTargetInfoImpl {\n  CXTranslationUnit TranslationUnit;\n};\n\nnamespace clang {\nnamespace cxtu {\n\nCXTranslationUnitImpl *MakeCXTranslationUnit(CIndexer *CIdx,\n                                             std::unique_ptr<ASTUnit> AU);\n\nstatic inline ASTUnit *getASTUnit(CXTranslationUnit TU) {\n  if (!TU)\n    return nullptr;\n  return TU->TheASTUnit;\n}\n\n/// \\returns true if the ASTUnit has a diagnostic about the AST file being\n/// corrupted.\nbool isASTReadError(ASTUnit *AU);\n\nstatic inline bool isNotUsableTU(CXTranslationUnit TU) {\n  return !TU;\n}\n\n#define LOG_BAD_TU(TU)                                  \\\n    do {                                                \\\n      LOG_FUNC_SECTION {                                \\\n        *Log << \"called with a bad TU: \" << TU;         \\\n      }                                                 \\\n    } while(false)\n\nclass CXTUOwner {\n  CXTranslationUnitImpl *TU;\n  \npublic:\n  CXTUOwner(CXTranslationUnitImpl *tu) : TU(tu) { }\n  ~CXTUOwner();\n\n  CXTranslationUnitImpl *getTU() const { return TU; }\n\n  CXTranslationUnitImpl *takeTU() {\n    CXTranslationUnitImpl *retTU = TU;\n    TU = nullptr;\n    return retTU;\n  }\n};\n\n\n}} // end namespace clang::cxtu\n\n#endif\n"}, "88": {"id": 88, "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CursorVisitor.h", "content": "//===- CursorVisitor.h - CursorVisitor interface ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_LIBCLANG_CURSORVISITOR_H\n#define LLVM_CLANG_TOOLS_LIBCLANG_CURSORVISITOR_H\n\n#include \"CXCursor.h\"\n#include \"CXTranslationUnit.h\"\n#include \"Index_Internal.h\"\n#include \"clang/AST/DeclVisitor.h\"\n#include \"clang/AST/TypeLocVisitor.h\"\n\nnamespace clang {\nclass PreprocessingRecord;\nclass ASTUnit;\n\nnamespace cxcursor {\n\nclass VisitorJob {\npublic:\n  enum Kind {\n    DeclVisitKind,\n    StmtVisitKind,\n    MemberExprPartsKind,\n    TypeLocVisitKind,\n    OverloadExprPartsKind,\n    DeclRefExprPartsKind,\n    LabelRefVisitKind,\n    ExplicitTemplateArgsVisitKind,\n    NestedNameSpecifierLocVisitKind,\n    DeclarationNameInfoVisitKind,\n    MemberRefVisitKind,\n    SizeOfPackExprPartsKind,\n    LambdaExprPartsKind,\n    PostChildrenVisitKind\n  };\n\nprotected:\n  const void *data[3];\n  CXCursor parent;\n  Kind K;\n  VisitorJob(CXCursor C, Kind k, const void *d1, const void *d2 = nullptr,\n             const void *d3 = nullptr)\n      : parent(C), K(k) {\n    data[0] = d1;\n    data[1] = d2;\n    data[2] = d3;\n  }\n\npublic:\n  Kind getKind() const { return K; }\n  const CXCursor &getParent() const { return parent; }\n};\n\ntypedef SmallVector<VisitorJob, 10> VisitorWorkList;\n\n// Cursor visitor.\nclass CursorVisitor : public DeclVisitor<CursorVisitor, bool>,\n                      public TypeLocVisitor<CursorVisitor, bool> {\npublic:\n  /// Callback called after child nodes of a cursor have been visited.\n  /// Return true to break visitation or false to continue.\n  typedef bool (*PostChildrenVisitorTy)(CXCursor cursor,\n                                        CXClientData client_data);\n\nprivate:\n  /// The translation unit we are traversing.\n  CXTranslationUnit TU;\n  ASTUnit *AU;\n\n  /// The parent cursor whose children we are traversing.\n  CXCursor Parent;\n\n  /// The declaration that serves at the parent of any statement or\n  /// expression nodes.\n  const Decl *StmtParent;\n\n  /// The visitor function.\n  CXCursorVisitor Visitor;\n\n  PostChildrenVisitorTy PostChildrenVisitor;\n\n  /// The opaque client data, to be passed along to the visitor.\n  CXClientData ClientData;\n\n  /// Whether we should visit the preprocessing record entries last,\n  /// after visiting other declarations.\n  bool VisitPreprocessorLast;\n\n  /// Whether we should visit declarations or preprocessing record\n  /// entries that are #included inside the \\arg RegionOfInterest.\n  bool VisitIncludedEntities;\n\n  /// When valid, a source range to which the cursor should restrict\n  /// its search.\n  SourceRange RegionOfInterest;\n\n  /// Whether we should only visit declarations and not preprocessing\n  /// record entries.\n  bool VisitDeclsOnly;\n\n  // FIXME: Eventually remove.  This part of a hack to support proper\n  // iteration over all Decls contained lexically within an ObjC container.\n  DeclContext::decl_iterator *DI_current;\n  DeclContext::decl_iterator DE_current;\n  SmallVectorImpl<Decl *>::iterator *FileDI_current;\n  SmallVectorImpl<Decl *>::iterator FileDE_current;\n\n  // Cache of pre-allocated worklists for data-recursion walk of Stmts.\n  SmallVector<VisitorWorkList *, 5> WorkListFreeList;\n  SmallVector<VisitorWorkList *, 5> WorkListCache;\n\n  using DeclVisitor<CursorVisitor, bool>::Visit;\n  using TypeLocVisitor<CursorVisitor, bool>::Visit;\n\n  /// Determine whether this particular source range comes before, comes\n  /// after, or overlaps the region of interest.\n  ///\n  /// \\param R a half-open source range retrieved from the abstract syntax tree.\n  RangeComparisonResult CompareRegionOfInterest(SourceRange R);\n\n  bool visitDeclsFromFileRegion(FileID File, unsigned Offset, unsigned Length);\n\n  class SetParentRAII {\n    CXCursor &Parent;\n    const Decl *&StmtParent;\n    CXCursor OldParent;\n\n  public:\n    SetParentRAII(CXCursor &Parent, const Decl *&StmtParent, CXCursor NewParent)\n        : Parent(Parent), StmtParent(StmtParent), OldParent(Parent) {\n      Parent = NewParent;\n      if (clang_isDeclaration(Parent.kind))\n        StmtParent = getCursorDecl(Parent);\n    }\n\n    ~SetParentRAII() {\n      Parent = OldParent;\n      if (clang_isDeclaration(Parent.kind))\n        StmtParent = getCursorDecl(Parent);\n    }\n  };\n\npublic:\n  CursorVisitor(CXTranslationUnit TU, CXCursorVisitor Visitor,\n                CXClientData ClientData, bool VisitPreprocessorLast,\n                bool VisitIncludedPreprocessingEntries = false,\n                SourceRange RegionOfInterest = SourceRange(),\n                bool VisitDeclsOnly = false,\n                PostChildrenVisitorTy PostChildrenVisitor = nullptr)\n      : TU(TU), AU(cxtu::getASTUnit(TU)), Visitor(Visitor),\n        PostChildrenVisitor(PostChildrenVisitor), ClientData(ClientData),\n        VisitPreprocessorLast(VisitPreprocessorLast),\n        VisitIncludedEntities(VisitIncludedPreprocessingEntries),\n        RegionOfInterest(RegionOfInterest), VisitDeclsOnly(VisitDeclsOnly),\n        DI_current(nullptr), FileDI_current(nullptr) {\n    Parent.kind = CXCursor_NoDeclFound;\n    Parent.data[0] = nullptr;\n    Parent.data[1] = nullptr;\n    Parent.data[2] = nullptr;\n    StmtParent = nullptr;\n  }\n\n  ~CursorVisitor() {\n    // Free the pre-allocated worklists for data-recursion.\n    for (SmallVectorImpl<VisitorWorkList *>::iterator I = WorkListCache.begin(),\n                                                      E = WorkListCache.end();\n         I != E; ++I) {\n      delete *I;\n    }\n  }\n\n  ASTUnit *getASTUnit() const { return AU; }\n  CXTranslationUnit getTU() const { return TU; }\n\n  bool Visit(CXCursor Cursor, bool CheckedRegionOfInterest = false);\n\n  /// Visit declarations and preprocessed entities for the file region\n  /// designated by \\see RegionOfInterest.\n  bool visitFileRegion();\n\n  bool visitPreprocessedEntitiesInRegion();\n\n  bool shouldVisitIncludedEntities() const { return VisitIncludedEntities; }\n\n  template <typename InputIterator>\n  bool visitPreprocessedEntities(InputIterator First, InputIterator Last,\n                                 PreprocessingRecord &PPRec,\n                                 FileID FID = FileID());\n\n  bool VisitChildren(CXCursor Parent);\n\n  // Declaration visitors\n  bool VisitTypeAliasTemplateDecl(TypeAliasTemplateDecl *D);\n  bool VisitTypeAliasDecl(TypeAliasDecl *D);\n  bool VisitAttributes(Decl *D);\n  bool VisitBlockDecl(BlockDecl *B);\n  bool VisitCXXRecordDecl(CXXRecordDecl *D);\n  Optional<bool> shouldVisitCursor(CXCursor C);\n  bool VisitDeclContext(DeclContext *DC);\n  bool VisitTranslationUnitDecl(TranslationUnitDecl *D);\n  bool VisitTypedefDecl(TypedefDecl *D);\n  bool VisitTagDecl(TagDecl *D);\n  bool VisitClassTemplateSpecializationDecl(ClassTemplateSpecializationDecl *D);\n  bool VisitClassTemplatePartialSpecializationDecl(\n      ClassTemplatePartialSpecializationDecl *D);\n  bool VisitTemplateTypeParmDecl(TemplateTypeParmDecl *D);\n  bool VisitEnumConstantDecl(EnumConstantDecl *D);\n  bool VisitDeclaratorDecl(DeclaratorDecl *DD);\n  bool VisitFunctionDecl(FunctionDecl *ND);\n  bool VisitFieldDecl(FieldDecl *D);\n  bool VisitVarDecl(VarDecl *);\n  bool VisitNonTypeTemplateParmDecl(NonTypeTemplateParmDecl *D);\n  bool VisitFunctionTemplateDecl(FunctionTemplateDecl *D);\n  bool VisitClassTemplateDecl(ClassTemplateDecl *D);\n  bool VisitTemplateTemplateParmDecl(TemplateTemplateParmDecl *D);\n  bool VisitObjCTypeParamDecl(ObjCTypeParamDecl *D);\n  bool VisitObjCMethodDecl(ObjCMethodDecl *ND);\n  bool VisitObjCContainerDecl(ObjCContainerDecl *D);\n  bool VisitObjCCategoryDecl(ObjCCategoryDecl *ND);\n  bool VisitObjCProtocolDecl(ObjCProtocolDecl *PID);\n  bool VisitObjCPropertyDecl(ObjCPropertyDecl *PD);\n  bool VisitObjCTypeParamList(ObjCTypeParamList *typeParamList);\n  bool VisitObjCInterfaceDecl(ObjCInterfaceDecl *D);\n  bool VisitObjCImplDecl(ObjCImplDecl *D);\n  bool VisitObjCCategoryImplDecl(ObjCCategoryImplDecl *D);\n  bool VisitObjCImplementationDecl(ObjCImplementationDecl *D);\n  // FIXME: ObjCCompatibleAliasDecl requires aliased-class locations.\n  bool VisitObjCPropertyImplDecl(ObjCPropertyImplDecl *PD);\n  bool VisitLinkageSpecDecl(LinkageSpecDecl *D);\n  bool VisitNamespaceDecl(NamespaceDecl *D);\n  bool VisitNamespaceAliasDecl(NamespaceAliasDecl *D);\n  bool VisitUsingDirectiveDecl(UsingDirectiveDecl *D);\n  bool VisitUsingDecl(UsingDecl *D);\n  bool VisitUnresolvedUsingValueDecl(UnresolvedUsingValueDecl *D);\n  bool VisitUnresolvedUsingTypenameDecl(UnresolvedUsingTypenameDecl *D);\n  bool VisitStaticAssertDecl(StaticAssertDecl *D);\n  bool VisitFriendDecl(FriendDecl *D);\n  bool VisitDecompositionDecl(DecompositionDecl *D);\n\n  // Name visitor\n  bool VisitDeclarationNameInfo(DeclarationNameInfo Name);\n  bool VisitNestedNameSpecifier(NestedNameSpecifier *NNS, SourceRange Range);\n  bool VisitNestedNameSpecifierLoc(NestedNameSpecifierLoc NNS);\n\n  // Template visitors\n  bool VisitTemplateParameters(const TemplateParameterList *Params);\n  bool VisitTemplateName(TemplateName Name, SourceLocation Loc);\n  bool VisitTemplateArgumentLoc(const TemplateArgumentLoc &TAL);\n\n  // Type visitors\n#define ABSTRACT_TYPELOC(CLASS, PARENT)\n#define TYPELOC(CLASS, PARENT) bool Visit##CLASS##TypeLoc(CLASS##TypeLoc TyLoc);\n#include \"clang/AST/TypeLocNodes.def\"\n\n  bool VisitTagTypeLoc(TagTypeLoc TL);\n  bool VisitArrayTypeLoc(ArrayTypeLoc TL);\n  bool VisitFunctionTypeLoc(FunctionTypeLoc TL, bool SkipResultType = false);\n\n  // Data-recursive visitor functions.\n  bool IsInRegionOfInterest(CXCursor C);\n  bool RunVisitorWorkList(VisitorWorkList &WL);\n  void EnqueueWorkList(VisitorWorkList &WL, const Stmt *S);\n  LLVM_ATTRIBUTE_NOINLINE bool Visit(const Stmt *S);\n\nprivate:\n  Optional<bool> handleDeclForVisitation(const Decl *D);\n};\n\n} // namespace cxcursor\n} // namespace clang\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 0, "line": 693}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang-c/Index.h", "reportHash": "f61eecd813b4cea2c175eb16d05ba31b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 0, "line": 4979}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang-c/Index.h", "reportHash": "f61eecd813b4cea2c175eb16d05ba31b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 707}, "message": "'TagTypeLoc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TypeLoc.h", "reportHash": "4c0ba29718655ac68908d26981f96e8c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 1351}, "message": "'FunctionTypeLoc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TypeLoc.h", "reportHash": "cecf9269000259d6f67605d8eed7ffc7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 1484}, "message": "'ArrayTypeLoc' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TypeLoc.h", "reportHash": "ff3973ad41f3cf66213922c0fa5699ac", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 38, "line": 41}, "message": "'ReturnAdjustment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/ABI.h", "reportHash": "a27d82cff5f01946c19986323c3e8fca", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 38, "line": 48}, "message": "'VirtualAdjustment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/ABI.h", "reportHash": "bbf10618a674087dce18cad88a541e9e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 38, "line": 50}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/ABI.h", "reportHash": "7c895d881f7ddec8ed13ea7aa0a9838c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 38, "line": 57}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/ABI.h", "reportHash": "7c895d881f7ddec8ed13ea7aa0a9838c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 38, "line": 107}, "message": "'ThisAdjustment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/ABI.h", "reportHash": "48f3cd16b9fbe2af697d2a22d0d79863", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 38, "line": 114}, "message": "'VirtualAdjustment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/ABI.h", "reportHash": "bbf10618a674087dce18cad88a541e9e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 38, "line": 116}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/ABI.h", "reportHash": "7c895d881f7ddec8ed13ea7aa0a9838c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 38, "line": 122}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/ABI.h", "reportHash": "7c895d881f7ddec8ed13ea7aa0a9838c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 75, "line": 746}, "message": "'SubmoduleState' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Lex/Preprocessor.h", "reportHash": "4198a79354475368ed971a0b99cb4f00", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 85, "line": 1988}, "message": "'EnqueueVisitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CIndex.cpp", "reportHash": "f0f74d32df5a38b001a797071da01e79", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 85, "line": 2174}, "message": "'OMPClauseEnqueue' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CIndex.cpp", "reportHash": "9c8cda6c9b075074a8f274d10ea0e691", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 85, "line": 5679}, "message": "'GetCursorData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CIndex.cpp", "reportHash": "7dca932ceb7fa1ab834a099d6800b798", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 85, "line": 7008}, "message": "'PostChildrenInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CIndex.cpp", "reportHash": "220040843813c7145859bfcccaf034df", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 85, "line": 7477}, "message": "'MarkMacroArgTokensVisitor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CIndex.cpp", "reportHash": "9a7b106bcadea677610922465e2a502c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 86, "line": 34}, "message": "'CIndexer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CIndexer.h", "reportHash": "2e726ddfef6ff8109383db86b254f35b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 87, "line": 39}, "message": "'CXTargetInfoImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CXTranslationUnit.h", "reportHash": "79ef11e3dd73403440cab5f94c77c074", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 88, "line": 24}, "message": "'VisitorJob' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/tools/libclang/CursorVisitor.h", "reportHash": "835911d026eae407a280b2e1b29b83e2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
