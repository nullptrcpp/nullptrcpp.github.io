<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/VTableBuilder.cpp", "content": "//===--- VTableBuilder.cpp - C++ vtable layout builder --------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This contains code dealing with generation of the layout of virtual tables.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/AST/VTableBuilder.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTDiagnostic.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"llvm/ADT/SetOperations.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cstdio>\n\nusing namespace clang;\n\n#define DUMP_OVERRIDERS 0\n\nnamespace {\n\n/// BaseOffset - Represents an offset from a derived class to a direct or\n/// indirect base class.\nstruct BaseOffset {\n  /// DerivedClass - The derived class.\n  const CXXRecordDecl *DerivedClass;\n\n  /// VirtualBase - If the path from the derived class to the base class\n  /// involves virtual base classes, this holds the declaration of the last\n  /// virtual base in this path (i.e. closest to the base class).\n  const CXXRecordDecl *VirtualBase;\n\n  /// NonVirtualOffset - The offset from the derived class to the base class.\n  /// (Or the offset from the virtual base class to the base class, if the\n  /// path from the derived class to the base class involves a virtual base\n  /// class.\n  CharUnits NonVirtualOffset;\n\n  BaseOffset() : DerivedClass(nullptr), VirtualBase(nullptr),\n                 NonVirtualOffset(CharUnits::Zero()) { }\n  BaseOffset(const CXXRecordDecl *DerivedClass,\n             const CXXRecordDecl *VirtualBase, CharUnits NonVirtualOffset)\n    : DerivedClass(DerivedClass), VirtualBase(VirtualBase),\n    NonVirtualOffset(NonVirtualOffset) { }\n\n  bool isEmpty() const { return NonVirtualOffset.isZero() && !VirtualBase; }\n};\n\n/// FinalOverriders - Contains the final overrider member functions for all\n/// member functions in the base subobjects of a class.\nclass FinalOverriders {\npublic:\n  /// OverriderInfo - Information about a final overrider.\n  struct OverriderInfo {\n    /// Method - The method decl of the overrider.\n    const CXXMethodDecl *Method;\n\n    /// VirtualBase - The virtual base class subobject of this overrider.\n    /// Note that this records the closest derived virtual base class subobject.\n    const CXXRecordDecl *VirtualBase;\n\n    /// Offset - the base offset of the overrider's parent in the layout class.\n    CharUnits Offset;\n\n    OverriderInfo() : Method(nullptr), VirtualBase(nullptr),\n                      Offset(CharUnits::Zero()) { }\n  };\n\nprivate:\n  /// MostDerivedClass - The most derived class for which the final overriders\n  /// are stored.\n  const CXXRecordDecl *MostDerivedClass;\n\n  /// MostDerivedClassOffset - If we're building final overriders for a\n  /// construction vtable, this holds the offset from the layout class to the\n  /// most derived class.\n  const CharUnits MostDerivedClassOffset;\n\n  /// LayoutClass - The class we're using for layout information. Will be\n  /// different than the most derived class if the final overriders are for a\n  /// construction vtable.\n  const CXXRecordDecl *LayoutClass;\n\n  ASTContext &Context;\n\n  /// MostDerivedClassLayout - the AST record layout of the most derived class.\n  const ASTRecordLayout &MostDerivedClassLayout;\n\n  /// MethodBaseOffsetPairTy - Uniquely identifies a member function\n  /// in a base subobject.\n  typedef std::pair<const CXXMethodDecl *, CharUnits> MethodBaseOffsetPairTy;\n\n  typedef llvm::DenseMap<MethodBaseOffsetPairTy,\n                         OverriderInfo> OverridersMapTy;\n\n  /// OverridersMap - The final overriders for all virtual member functions of\n  /// all the base subobjects of the most derived class.\n  OverridersMapTy OverridersMap;\n\n  /// SubobjectsToOffsetsMapTy - A mapping from a base subobject (represented\n  /// as a record decl and a subobject number) and its offsets in the most\n  /// derived class as well as the layout class.\n  typedef llvm::DenseMap<std::pair<const CXXRecordDecl *, unsigned>,\n                         CharUnits> SubobjectOffsetMapTy;\n\n  typedef llvm::DenseMap<const CXXRecordDecl *, unsigned> SubobjectCountMapTy;\n\n  /// ComputeBaseOffsets - Compute the offsets for all base subobjects of the\n  /// given base.\n  void ComputeBaseOffsets(BaseSubobject Base, bool IsVirtual,\n                          CharUnits OffsetInLayoutClass,\n                          SubobjectOffsetMapTy &SubobjectOffsets,\n                          SubobjectOffsetMapTy &SubobjectLayoutClassOffsets,\n                          SubobjectCountMapTy &SubobjectCounts);\n\n  typedef llvm::SmallPtrSet<const CXXRecordDecl *, 4> VisitedVirtualBasesSetTy;\n\n  /// dump - dump the final overriders for a base subobject, and all its direct\n  /// and indirect base subobjects.\n  void dump(raw_ostream &Out, BaseSubobject Base,\n            VisitedVirtualBasesSetTy& VisitedVirtualBases);\n\npublic:\n  FinalOverriders(const CXXRecordDecl *MostDerivedClass,\n                  CharUnits MostDerivedClassOffset,\n                  const CXXRecordDecl *LayoutClass);\n\n  /// getOverrider - Get the final overrider for the given method declaration in\n  /// the subobject with the given base offset.\n  OverriderInfo getOverrider(const CXXMethodDecl *MD,\n                             CharUnits BaseOffset) const {\n    assert(OverridersMap.count(std::make_pair(MD, BaseOffset)) &&\n           \"Did not find overrider!\");\n\n    return OverridersMap.lookup(std::make_pair(MD, BaseOffset));\n  }\n\n  /// dump - dump the final overriders.\n  void dump() {\n    VisitedVirtualBasesSetTy VisitedVirtualBases;\n    dump(llvm::errs(), BaseSubobject(MostDerivedClass, CharUnits::Zero()),\n         VisitedVirtualBases);\n  }\n\n};\n\nFinalOverriders::FinalOverriders(const CXXRecordDecl *MostDerivedClass,\n                                 CharUnits MostDerivedClassOffset,\n                                 const CXXRecordDecl *LayoutClass)\n  : MostDerivedClass(MostDerivedClass),\n  MostDerivedClassOffset(MostDerivedClassOffset), LayoutClass(LayoutClass),\n  Context(MostDerivedClass->getASTContext()),\n  MostDerivedClassLayout(Context.getASTRecordLayout(MostDerivedClass)) {\n\n  // Compute base offsets.\n  SubobjectOffsetMapTy SubobjectOffsets;\n  SubobjectOffsetMapTy SubobjectLayoutClassOffsets;\n  SubobjectCountMapTy SubobjectCounts;\n  ComputeBaseOffsets(BaseSubobject(MostDerivedClass, CharUnits::Zero()),\n                     /*IsVirtual=*/false,\n                     MostDerivedClassOffset,\n                     SubobjectOffsets, SubobjectLayoutClassOffsets,\n                     SubobjectCounts);\n\n  // Get the final overriders.\n  CXXFinalOverriderMap FinalOverriders;\n  MostDerivedClass->getFinalOverriders(FinalOverriders);\n\n  for (const auto &Overrider : FinalOverriders) {\n    const CXXMethodDecl *MD = Overrider.first;\n    const OverridingMethods &Methods = Overrider.second;\n\n    for (const auto &M : Methods) {\n      unsigned SubobjectNumber = M.first;\n      assert(SubobjectOffsets.count(std::make_pair(MD->getParent(),\n                                                   SubobjectNumber)) &&\n             \"Did not find subobject offset!\");\n\n      CharUnits BaseOffset = SubobjectOffsets[std::make_pair(MD->getParent(),\n                                                            SubobjectNumber)];\n\n      assert(M.second.size() == 1 && \"Final overrider is not unique!\");\n      const UniqueVirtualMethod &Method = M.second.front();\n\n      const CXXRecordDecl *OverriderRD = Method.Method->getParent();\n      assert(SubobjectLayoutClassOffsets.count(\n             std::make_pair(OverriderRD, Method.Subobject))\n             && \"Did not find subobject offset!\");\n      CharUnits OverriderOffset =\n        SubobjectLayoutClassOffsets[std::make_pair(OverriderRD,\n                                                   Method.Subobject)];\n\n      OverriderInfo& Overrider = OverridersMap[std::make_pair(MD, BaseOffset)];\n      assert(!Overrider.Method && \"Overrider should not exist yet!\");\n\n      Overrider.Offset = OverriderOffset;\n      Overrider.Method = Method.Method;\n      Overrider.VirtualBase = Method.InVirtualSubobject;\n    }\n  }\n\n#if DUMP_OVERRIDERS\n  // And dump them (for now).\n  dump();\n#endif\n}\n\nstatic BaseOffset ComputeBaseOffset(const ASTContext &Context,\n                                    const CXXRecordDecl *DerivedRD,\n                                    const CXXBasePath &Path) {\n  CharUnits NonVirtualOffset = CharUnits::Zero();\n\n  unsigned NonVirtualStart = 0;\n  const CXXRecordDecl *VirtualBase = nullptr;\n\n  // First, look for the virtual base class.\n  for (int I = Path.size(), E = 0; I != E; --I) {\n    const CXXBasePathElement &Element = Path[I - 1];\n\n    if (Element.Base->isVirtual()) {\n      NonVirtualStart = I;\n      QualType VBaseType = Element.Base->getType();\n      VirtualBase = VBaseType->getAsCXXRecordDecl();\n      break;\n    }\n  }\n\n  // Now compute the non-virtual offset.\n  for (unsigned I = NonVirtualStart, E = Path.size(); I != E; ++I) {\n    const CXXBasePathElement &Element = Path[I];\n\n    // Check the base class offset.\n    const ASTRecordLayout &Layout = Context.getASTRecordLayout(Element.Class);\n\n    const CXXRecordDecl *Base = Element.Base->getType()->getAsCXXRecordDecl();\n\n    NonVirtualOffset += Layout.getBaseClassOffset(Base);\n  }\n\n  // FIXME: This should probably use CharUnits or something. Maybe we should\n  // even change the base offsets in ASTRecordLayout to be specified in\n  // CharUnits.\n  return BaseOffset(DerivedRD, VirtualBase, NonVirtualOffset);\n\n}\n\nstatic BaseOffset ComputeBaseOffset(const ASTContext &Context,\n                                    const CXXRecordDecl *BaseRD,\n                                    const CXXRecordDecl *DerivedRD) {\n  CXXBasePaths Paths(/*FindAmbiguities=*/false,\n                     /*RecordPaths=*/true, /*DetectVirtual=*/false);\n\n  if (!DerivedRD->isDerivedFrom(BaseRD, Paths))\n    llvm_unreachable(\"Class must be derived from the passed in base class!\");\n\n  return ComputeBaseOffset(Context, DerivedRD, Paths.front());\n}\n\nstatic BaseOffset\nComputeReturnAdjustmentBaseOffset(ASTContext &Context,\n                                  const CXXMethodDecl *DerivedMD,\n                                  const CXXMethodDecl *BaseMD) {\n  const auto *BaseFT = BaseMD->getType()->castAs<FunctionType>();\n  const auto *DerivedFT = DerivedMD->getType()->castAs<FunctionType>();\n\n  // Canonicalize the return types.\n  CanQualType CanDerivedReturnType =\n      Context.getCanonicalType(DerivedFT->getReturnType());\n  CanQualType CanBaseReturnType =\n      Context.getCanonicalType(BaseFT->getReturnType());\n\n  assert(CanDerivedReturnType->getTypeClass() ==\n         CanBaseReturnType->getTypeClass() &&\n         \"Types must have same type class!\");\n\n  if (CanDerivedReturnType == CanBaseReturnType) {\n    // No adjustment needed.\n    return BaseOffset();\n  }\n\n  if (isa<ReferenceType>(CanDerivedReturnType)) {\n    CanDerivedReturnType =\n      CanDerivedReturnType->getAs<ReferenceType>()->getPointeeType();\n    CanBaseReturnType =\n      CanBaseReturnType->getAs<ReferenceType>()->getPointeeType();\n  } else if (isa<PointerType>(CanDerivedReturnType)) {\n    CanDerivedReturnType =\n      CanDerivedReturnType->getAs<PointerType>()->getPointeeType();\n    CanBaseReturnType =\n      CanBaseReturnType->getAs<PointerType>()->getPointeeType();\n  } else {\n    llvm_unreachable(\"Unexpected return type!\");\n  }\n\n  // We need to compare unqualified types here; consider\n  //   const T *Base::foo();\n  //   T *Derived::foo();\n  if (CanDerivedReturnType.getUnqualifiedType() ==\n      CanBaseReturnType.getUnqualifiedType()) {\n    // No adjustment needed.\n    return BaseOffset();\n  }\n\n  const CXXRecordDecl *DerivedRD =\n    cast<CXXRecordDecl>(cast<RecordType>(CanDerivedReturnType)->getDecl());\n\n  const CXXRecordDecl *BaseRD =\n    cast<CXXRecordDecl>(cast<RecordType>(CanBaseReturnType)->getDecl());\n\n  return ComputeBaseOffset(Context, BaseRD, DerivedRD);\n}\n\nvoid\nFinalOverriders::ComputeBaseOffsets(BaseSubobject Base, bool IsVirtual,\n                              CharUnits OffsetInLayoutClass,\n                              SubobjectOffsetMapTy &SubobjectOffsets,\n                              SubobjectOffsetMapTy &SubobjectLayoutClassOffsets,\n                              SubobjectCountMapTy &SubobjectCounts) {\n  const CXXRecordDecl *RD = Base.getBase();\n\n  unsigned SubobjectNumber = 0;\n  if (!IsVirtual)\n    SubobjectNumber = ++SubobjectCounts[RD];\n\n  // Set up the subobject to offset mapping.\n  assert(!SubobjectOffsets.count(std::make_pair(RD, SubobjectNumber))\n         && \"Subobject offset already exists!\");\n  assert(!SubobjectLayoutClassOffsets.count(std::make_pair(RD, SubobjectNumber))\n         && \"Subobject offset already exists!\");\n\n  SubobjectOffsets[std::make_pair(RD, SubobjectNumber)] = Base.getBaseOffset();\n  SubobjectLayoutClassOffsets[std::make_pair(RD, SubobjectNumber)] =\n    OffsetInLayoutClass;\n\n  // Traverse our bases.\n  for (const auto &B : RD->bases()) {\n    const CXXRecordDecl *BaseDecl = B.getType()->getAsCXXRecordDecl();\n\n    CharUnits BaseOffset;\n    CharUnits BaseOffsetInLayoutClass;\n    if (B.isVirtual()) {\n      // Check if we've visited this virtual base before.\n      if (SubobjectOffsets.count(std::make_pair(BaseDecl, 0)))\n        continue;\n\n      const ASTRecordLayout &LayoutClassLayout =\n        Context.getASTRecordLayout(LayoutClass);\n\n      BaseOffset = MostDerivedClassLayout.getVBaseClassOffset(BaseDecl);\n      BaseOffsetInLayoutClass =\n        LayoutClassLayout.getVBaseClassOffset(BaseDecl);\n    } else {\n      const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n      CharUnits Offset = Layout.getBaseClassOffset(BaseDecl);\n\n      BaseOffset = Base.getBaseOffset() + Offset;\n      BaseOffsetInLayoutClass = OffsetInLayoutClass + Offset;\n    }\n\n    ComputeBaseOffsets(BaseSubobject(BaseDecl, BaseOffset),\n                       B.isVirtual(), BaseOffsetInLayoutClass,\n                       SubobjectOffsets, SubobjectLayoutClassOffsets,\n                       SubobjectCounts);\n  }\n}\n\nvoid FinalOverriders::dump(raw_ostream &Out, BaseSubobject Base,\n                           VisitedVirtualBasesSetTy &VisitedVirtualBases) {\n  const CXXRecordDecl *RD = Base.getBase();\n  const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n\n  for (const auto &B : RD->bases()) {\n    const CXXRecordDecl *BaseDecl = B.getType()->getAsCXXRecordDecl();\n\n    // Ignore bases that don't have any virtual member functions.\n    if (!BaseDecl->isPolymorphic())\n      continue;\n\n    CharUnits BaseOffset;\n    if (B.isVirtual()) {\n      if (!VisitedVirtualBases.insert(BaseDecl).second) {\n        // We've visited this base before.\n        continue;\n      }\n\n      BaseOffset = MostDerivedClassLayout.getVBaseClassOffset(BaseDecl);\n    } else {\n      BaseOffset = Layout.getBaseClassOffset(BaseDecl) + Base.getBaseOffset();\n    }\n\n    dump(Out, BaseSubobject(BaseDecl, BaseOffset), VisitedVirtualBases);\n  }\n\n  Out << \"Final overriders for (\";\n  RD->printQualifiedName(Out);\n  Out << \", \";\n  Out << Base.getBaseOffset().getQuantity() << \")\\n\";\n\n  // Now dump the overriders for this base subobject.\n  for (const auto *MD : RD->methods()) {\n    if (!VTableContextBase::hasVtableSlot(MD))\n      continue;\n    MD = MD->getCanonicalDecl();\n\n    OverriderInfo Overrider = getOverrider(MD, Base.getBaseOffset());\n\n    Out << \"  \";\n    MD->printQualifiedName(Out);\n    Out << \" - (\";\n    Overrider.Method->printQualifiedName(Out);\n    Out << \", \" << Overrider.Offset.getQuantity() << ')';\n\n    BaseOffset Offset;\n    if (!Overrider.Method->isPure())\n      Offset = ComputeReturnAdjustmentBaseOffset(Context, Overrider.Method, MD);\n\n    if (!Offset.isEmpty()) {\n      Out << \" [ret-adj: \";\n      if (Offset.VirtualBase) {\n        Offset.VirtualBase->printQualifiedName(Out);\n        Out << \" vbase, \";\n      }\n\n      Out << Offset.NonVirtualOffset.getQuantity() << \" nv]\";\n    }\n\n    Out << \"\\n\";\n  }\n}\n\n/// VCallOffsetMap - Keeps track of vcall offsets when building a vtable.\nstruct VCallOffsetMap {\n\n  typedef std::pair<const CXXMethodDecl *, CharUnits> MethodAndOffsetPairTy;\n\n  /// Offsets - Keeps track of methods and their offsets.\n  // FIXME: This should be a real map and not a vector.\n  SmallVector<MethodAndOffsetPairTy, 16> Offsets;\n\n  /// MethodsCanShareVCallOffset - Returns whether two virtual member functions\n  /// can share the same vcall offset.\n  static bool MethodsCanShareVCallOffset(const CXXMethodDecl *LHS,\n                                         const CXXMethodDecl *RHS);\n\npublic:\n  /// AddVCallOffset - Adds a vcall offset to the map. Returns true if the\n  /// add was successful, or false if there was already a member function with\n  /// the same signature in the map.\n  bool AddVCallOffset(const CXXMethodDecl *MD, CharUnits OffsetOffset);\n\n  /// getVCallOffsetOffset - Returns the vcall offset offset (relative to the\n  /// vtable address point) for the given virtual member function.\n  CharUnits getVCallOffsetOffset(const CXXMethodDecl *MD);\n\n  // empty - Return whether the offset map is empty or not.\n  bool empty() const { return Offsets.empty(); }\n};\n\nstatic bool HasSameVirtualSignature(const CXXMethodDecl *LHS,\n                                    const CXXMethodDecl *RHS) {\n  const FunctionProtoType *LT =\n    cast<FunctionProtoType>(LHS->getType().getCanonicalType());\n  const FunctionProtoType *RT =\n    cast<FunctionProtoType>(RHS->getType().getCanonicalType());\n\n  // Fast-path matches in the canonical types.\n  if (LT == RT) return true;\n\n  // Force the signatures to match.  We can't rely on the overrides\n  // list here because there isn't necessarily an inheritance\n  // relationship between the two methods.\n  if (LT->getMethodQuals() != RT->getMethodQuals())\n    return false;\n  return LT->getParamTypes() == RT->getParamTypes();\n}\n\nbool VCallOffsetMap::MethodsCanShareVCallOffset(const CXXMethodDecl *LHS,\n                                                const CXXMethodDecl *RHS) {\n  assert(VTableContextBase::hasVtableSlot(LHS) && \"LHS must be virtual!\");\n  assert(VTableContextBase::hasVtableSlot(RHS) && \"LHS must be virtual!\");\n\n  // A destructor can share a vcall offset with another destructor.\n  if (isa<CXXDestructorDecl>(LHS))\n    return isa<CXXDestructorDecl>(RHS);\n\n  // FIXME: We need to check more things here.\n\n  // The methods must have the same name.\n  DeclarationName LHSName = LHS->getDeclName();\n  DeclarationName RHSName = RHS->getDeclName();\n  if (LHSName != RHSName)\n    return false;\n\n  // And the same signatures.\n  return HasSameVirtualSignature(LHS, RHS);\n}\n\nbool VCallOffsetMap::AddVCallOffset(const CXXMethodDecl *MD,\n                                    CharUnits OffsetOffset) {\n  // Check if we can reuse an offset.\n  for (const auto &OffsetPair : Offsets) {\n    if (MethodsCanShareVCallOffset(OffsetPair.first, MD))\n      return false;\n  }\n\n  // Add the offset.\n  Offsets.push_back(MethodAndOffsetPairTy(MD, OffsetOffset));\n  return true;\n}\n\nCharUnits VCallOffsetMap::getVCallOffsetOffset(const CXXMethodDecl *MD) {\n  // Look for an offset.\n  for (const auto &OffsetPair : Offsets) {\n    if (MethodsCanShareVCallOffset(OffsetPair.first, MD))\n      return OffsetPair.second;\n  }\n\n  llvm_unreachable(\"Should always find a vcall offset offset!\");\n}\n\n/// VCallAndVBaseOffsetBuilder - Class for building vcall and vbase offsets.\nclass VCallAndVBaseOffsetBuilder {\npublic:\n  typedef llvm::DenseMap<const CXXRecordDecl *, CharUnits>\n    VBaseOffsetOffsetsMapTy;\n\nprivate:\n  const ItaniumVTableContext &VTables;\n\n  /// MostDerivedClass - The most derived class for which we're building vcall\n  /// and vbase offsets.\n  const CXXRecordDecl *MostDerivedClass;\n\n  /// LayoutClass - The class we're using for layout information. Will be\n  /// different than the most derived class if we're building a construction\n  /// vtable.\n  const CXXRecordDecl *LayoutClass;\n\n  /// Context - The ASTContext which we will use for layout information.\n  ASTContext &Context;\n\n  /// Components - vcall and vbase offset components\n  typedef SmallVector<VTableComponent, 64> VTableComponentVectorTy;\n  VTableComponentVectorTy Components;\n\n  /// VisitedVirtualBases - Visited virtual bases.\n  llvm::SmallPtrSet<const CXXRecordDecl *, 4> VisitedVirtualBases;\n\n  /// VCallOffsets - Keeps track of vcall offsets.\n  VCallOffsetMap VCallOffsets;\n\n\n  /// VBaseOffsetOffsets - Contains the offsets of the virtual base offsets,\n  /// relative to the address point.\n  VBaseOffsetOffsetsMapTy VBaseOffsetOffsets;\n\n  /// FinalOverriders - The final overriders of the most derived class.\n  /// (Can be null when we're not building a vtable of the most derived class).\n  const FinalOverriders *Overriders;\n\n  /// AddVCallAndVBaseOffsets - Add vcall offsets and vbase offsets for the\n  /// given base subobject.\n  void AddVCallAndVBaseOffsets(BaseSubobject Base, bool BaseIsVirtual,\n                               CharUnits RealBaseOffset);\n\n  /// AddVCallOffsets - Add vcall offsets for the given base subobject.\n  void AddVCallOffsets(BaseSubobject Base, CharUnits VBaseOffset);\n\n  /// AddVBaseOffsets - Add vbase offsets for the given class.\n  void AddVBaseOffsets(const CXXRecordDecl *Base,\n                       CharUnits OffsetInLayoutClass);\n\n  /// getCurrentOffsetOffset - Get the current vcall or vbase offset offset in\n  /// chars, relative to the vtable address point.\n  CharUnits getCurrentOffsetOffset() const;\n\npublic:\n  VCallAndVBaseOffsetBuilder(const ItaniumVTableContext &VTables,\n                             const CXXRecordDecl *MostDerivedClass,\n                             const CXXRecordDecl *LayoutClass,\n                             const FinalOverriders *Overriders,\n                             BaseSubobject Base, bool BaseIsVirtual,\n                             CharUnits OffsetInLayoutClass)\n      : VTables(VTables), MostDerivedClass(MostDerivedClass),\n        LayoutClass(LayoutClass), Context(MostDerivedClass->getASTContext()),\n        Overriders(Overriders) {\n\n    // Add vcall and vbase offsets.\n    AddVCallAndVBaseOffsets(Base, BaseIsVirtual, OffsetInLayoutClass);\n  }\n\n  /// Methods for iterating over the components.\n  typedef VTableComponentVectorTy::const_reverse_iterator const_iterator;\n  const_iterator components_begin() const { return Components.rbegin(); }\n  const_iterator components_end() const { return Components.rend(); }\n\n  const VCallOffsetMap &getVCallOffsets() const { return VCallOffsets; }\n  const VBaseOffsetOffsetsMapTy &getVBaseOffsetOffsets() const {\n    return VBaseOffsetOffsets;\n  }\n};\n\nvoid\nVCallAndVBaseOffsetBuilder::AddVCallAndVBaseOffsets(BaseSubobject Base,\n                                                    bool BaseIsVirtual,\n                                                    CharUnits RealBaseOffset) {\n  const ASTRecordLayout &Layout = Context.getASTRecordLayout(Base.getBase());\n\n  // Itanium C++ ABI 2.5.2:\n  //   ..in classes sharing a virtual table with a primary base class, the vcall\n  //   and vbase offsets added by the derived class all come before the vcall\n  //   and vbase offsets required by the base class, so that the latter may be\n  //   laid out as required by the base class without regard to additions from\n  //   the derived class(es).\n\n  // (Since we're emitting the vcall and vbase offsets in reverse order, we'll\n  // emit them for the primary base first).\n  if (const CXXRecordDecl *PrimaryBase = Layout.getPrimaryBase()) {\n    bool PrimaryBaseIsVirtual = Layout.isPrimaryBaseVirtual();\n\n    CharUnits PrimaryBaseOffset;\n\n    // Get the base offset of the primary base.\n    if (PrimaryBaseIsVirtual) {\n      assert(Layout.getVBaseClassOffset(PrimaryBase).isZero() &&\n             \"Primary vbase should have a zero offset!\");\n\n      const ASTRecordLayout &MostDerivedClassLayout =\n        Context.getASTRecordLayout(MostDerivedClass);\n\n      PrimaryBaseOffset =\n        MostDerivedClassLayout.getVBaseClassOffset(PrimaryBase);\n    } else {\n      assert(Layout.getBaseClassOffset(PrimaryBase).isZero() &&\n             \"Primary base should have a zero offset!\");\n\n      PrimaryBaseOffset = Base.getBaseOffset();\n    }\n\n    AddVCallAndVBaseOffsets(\n      BaseSubobject(PrimaryBase,PrimaryBaseOffset),\n      PrimaryBaseIsVirtual, RealBaseOffset);\n  }\n\n  AddVBaseOffsets(Base.getBase(), RealBaseOffset);\n\n  // We only want to add vcall offsets for virtual bases.\n  if (BaseIsVirtual)\n    AddVCallOffsets(Base, RealBaseOffset);\n}\n\nCharUnits VCallAndVBaseOffsetBuilder::getCurrentOffsetOffset() const {\n  // OffsetIndex is the index of this vcall or vbase offset, relative to the\n  // vtable address point. (We subtract 3 to account for the information just\n  // above the address point, the RTTI info, the offset to top, and the\n  // vcall offset itself).\n  int64_t OffsetIndex = -(int64_t)(3 + Components.size());\n\n  // Under the relative ABI, the offset widths are 32-bit ints instead of\n  // pointer widths.\n  CharUnits OffsetWidth = Context.toCharUnitsFromBits(\n      VTables.isRelativeLayout() ? 32\n                                 : Context.getTargetInfo().getPointerWidth(0));\n  CharUnits OffsetOffset = OffsetWidth * OffsetIndex;\n\n  return OffsetOffset;\n}\n\nvoid VCallAndVBaseOffsetBuilder::AddVCallOffsets(BaseSubobject Base,\n                                                 CharUnits VBaseOffset) {\n  const CXXRecordDecl *RD = Base.getBase();\n  const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n\n  const CXXRecordDecl *PrimaryBase = Layout.getPrimaryBase();\n\n  // Handle the primary base first.\n  // We only want to add vcall offsets if the base is non-virtual; a virtual\n  // primary base will have its vcall and vbase offsets emitted already.\n  if (PrimaryBase && !Layout.isPrimaryBaseVirtual()) {\n    // Get the base offset of the primary base.\n    assert(Layout.getBaseClassOffset(PrimaryBase).isZero() &&\n           \"Primary base should have a zero offset!\");\n\n    AddVCallOffsets(BaseSubobject(PrimaryBase, Base.getBaseOffset()),\n                    VBaseOffset);\n  }\n\n  // Add the vcall offsets.\n  for (const auto *MD : RD->methods()) {\n    if (!VTableContextBase::hasVtableSlot(MD))\n      continue;\n    MD = MD->getCanonicalDecl();\n\n    CharUnits OffsetOffset = getCurrentOffsetOffset();\n\n    // Don't add a vcall offset if we already have one for this member function\n    // signature.\n    if (!VCallOffsets.AddVCallOffset(MD, OffsetOffset))\n      continue;\n\n    CharUnits Offset = CharUnits::Zero();\n\n    if (Overriders) {\n      // Get the final overrider.\n      FinalOverriders::OverriderInfo Overrider =\n        Overriders->getOverrider(MD, Base.getBaseOffset());\n\n      /// The vcall offset is the offset from the virtual base to the object\n      /// where the function was overridden.\n      Offset = Overrider.Offset - VBaseOffset;\n    }\n\n    Components.push_back(\n      VTableComponent::MakeVCallOffset(Offset));\n  }\n\n  // And iterate over all non-virtual bases (ignoring the primary base).\n  for (const auto &B : RD->bases()) {\n    if (B.isVirtual())\n      continue;\n\n    const CXXRecordDecl *BaseDecl = B.getType()->getAsCXXRecordDecl();\n    if (BaseDecl == PrimaryBase)\n      continue;\n\n    // Get the base offset of this base.\n    CharUnits BaseOffset = Base.getBaseOffset() +\n      Layout.getBaseClassOffset(BaseDecl);\n\n    AddVCallOffsets(BaseSubobject(BaseDecl, BaseOffset),\n                    VBaseOffset);\n  }\n}\n\nvoid\nVCallAndVBaseOffsetBuilder::AddVBaseOffsets(const CXXRecordDecl *RD,\n                                            CharUnits OffsetInLayoutClass) {\n  const ASTRecordLayout &LayoutClassLayout =\n    Context.getASTRecordLayout(LayoutClass);\n\n  // Add vbase offsets.\n  for (const auto &B : RD->bases()) {\n    const CXXRecordDecl *BaseDecl = B.getType()->getAsCXXRecordDecl();\n\n    // Check if this is a virtual base that we haven't visited before.\n    if (B.isVirtual() && VisitedVirtualBases.insert(BaseDecl).second) {\n      CharUnits Offset =\n        LayoutClassLayout.getVBaseClassOffset(BaseDecl) - OffsetInLayoutClass;\n\n      // Add the vbase offset offset.\n      assert(!VBaseOffsetOffsets.count(BaseDecl) &&\n             \"vbase offset offset already exists!\");\n\n      CharUnits VBaseOffsetOffset = getCurrentOffsetOffset();\n      VBaseOffsetOffsets.insert(\n          std::make_pair(BaseDecl, VBaseOffsetOffset));\n\n      Components.push_back(\n          VTableComponent::MakeVBaseOffset(Offset));\n    }\n\n    // Check the base class looking for more vbase offsets.\n    AddVBaseOffsets(BaseDecl, OffsetInLayoutClass);\n  }\n}\n\n/// ItaniumVTableBuilder - Class for building vtable layout information.\nclass ItaniumVTableBuilder {\npublic:\n  /// PrimaryBasesSetVectorTy - A set vector of direct and indirect\n  /// primary bases.\n  typedef llvm::SmallSetVector<const CXXRecordDecl *, 8>\n    PrimaryBasesSetVectorTy;\n\n  typedef llvm::DenseMap<const CXXRecordDecl *, CharUnits>\n    VBaseOffsetOffsetsMapTy;\n\n  typedef VTableLayout::AddressPointsMapTy AddressPointsMapTy;\n\n  typedef llvm::DenseMap<GlobalDecl, int64_t> MethodVTableIndicesTy;\n\nprivate:\n  /// VTables - Global vtable information.\n  ItaniumVTableContext &VTables;\n\n  /// MostDerivedClass - The most derived class for which we're building this\n  /// vtable.\n  const CXXRecordDecl *MostDerivedClass;\n\n  /// MostDerivedClassOffset - If we're building a construction vtable, this\n  /// holds the offset from the layout class to the most derived class.\n  const CharUnits MostDerivedClassOffset;\n\n  /// MostDerivedClassIsVirtual - Whether the most derived class is a virtual\n  /// base. (This only makes sense when building a construction vtable).\n  bool MostDerivedClassIsVirtual;\n\n  /// LayoutClass - The class we're using for layout information. Will be\n  /// different than the most derived class if we're building a construction\n  /// vtable.\n  const CXXRecordDecl *LayoutClass;\n\n  /// Context - The ASTContext which we will use for layout information.\n  ASTContext &Context;\n\n  /// FinalOverriders - The final overriders of the most derived class.\n  const FinalOverriders Overriders;\n\n  /// VCallOffsetsForVBases - Keeps track of vcall offsets for the virtual\n  /// bases in this vtable.\n  llvm::DenseMap<const CXXRecordDecl *, VCallOffsetMap> VCallOffsetsForVBases;\n\n  /// VBaseOffsetOffsets - Contains the offsets of the virtual base offsets for\n  /// the most derived class.\n  VBaseOffsetOffsetsMapTy VBaseOffsetOffsets;\n\n  /// Components - The components of the vtable being built.\n  SmallVector<VTableComponent, 64> Components;\n\n  /// AddressPoints - Address points for the vtable being built.\n  AddressPointsMapTy AddressPoints;\n\n  /// MethodInfo - Contains information about a method in a vtable.\n  /// (Used for computing 'this' pointer adjustment thunks.\n  struct MethodInfo {\n    /// BaseOffset - The base offset of this method.\n    const CharUnits BaseOffset;\n\n    /// BaseOffsetInLayoutClass - The base offset in the layout class of this\n    /// method.\n    const CharUnits BaseOffsetInLayoutClass;\n\n    /// VTableIndex - The index in the vtable that this method has.\n    /// (For destructors, this is the index of the complete destructor).\n    const uint64_t VTableIndex;\n\n    MethodInfo(CharUnits BaseOffset, CharUnits BaseOffsetInLayoutClass,\n               uint64_t VTableIndex)\n      : BaseOffset(BaseOffset),\n      BaseOffsetInLayoutClass(BaseOffsetInLayoutClass),\n      VTableIndex(VTableIndex) { }\n\n    MethodInfo()\n      : BaseOffset(CharUnits::Zero()),\n      BaseOffsetInLayoutClass(CharUnits::Zero()),\n      VTableIndex(0) { }\n\n    MethodInfo(MethodInfo const&) = default;\n  };\n\n  typedef llvm::DenseMap<const CXXMethodDecl *, MethodInfo> MethodInfoMapTy;\n\n  /// MethodInfoMap - The information for all methods in the vtable we're\n  /// currently building.\n  MethodInfoMapTy MethodInfoMap;\n\n  /// MethodVTableIndices - Contains the index (relative to the vtable address\n  /// point) where the function pointer for a virtual function is stored.\n  MethodVTableIndicesTy MethodVTableIndices;\n\n  typedef llvm::DenseMap<uint64_t, ThunkInfo> VTableThunksMapTy;\n\n  /// VTableThunks - The thunks by vtable index in the vtable currently being\n  /// built.\n  VTableThunksMapTy VTableThunks;\n\n  typedef SmallVector<ThunkInfo, 1> ThunkInfoVectorTy;\n  typedef llvm::DenseMap<const CXXMethodDecl *, ThunkInfoVectorTy> ThunksMapTy;\n\n  /// Thunks - A map that contains all the thunks needed for all methods in the\n  /// most derived class for which the vtable is currently being built.\n  ThunksMapTy Thunks;\n\n  /// AddThunk - Add a thunk for the given method.\n  void AddThunk(const CXXMethodDecl *MD, const ThunkInfo &Thunk);\n\n  /// ComputeThisAdjustments - Compute the 'this' pointer adjustments for the\n  /// part of the vtable we're currently building.\n  void ComputeThisAdjustments();\n\n  typedef llvm::SmallPtrSet<const CXXRecordDecl *, 4> VisitedVirtualBasesSetTy;\n\n  /// PrimaryVirtualBases - All known virtual bases who are a primary base of\n  /// some other base.\n  VisitedVirtualBasesSetTy PrimaryVirtualBases;\n\n  /// ComputeReturnAdjustment - Compute the return adjustment given a return\n  /// adjustment base offset.\n  ReturnAdjustment ComputeReturnAdjustment(BaseOffset Offset);\n\n  /// ComputeThisAdjustmentBaseOffset - Compute the base offset for adjusting\n  /// the 'this' pointer from the base subobject to the derived subobject.\n  BaseOffset ComputeThisAdjustmentBaseOffset(BaseSubobject Base,\n                                             BaseSubobject Derived) const;\n\n  /// ComputeThisAdjustment - Compute the 'this' pointer adjustment for the\n  /// given virtual member function, its offset in the layout class and its\n  /// final overrider.\n  ThisAdjustment\n  ComputeThisAdjustment(const CXXMethodDecl *MD,\n                        CharUnits BaseOffsetInLayoutClass,\n                        FinalOverriders::OverriderInfo Overrider);\n\n  /// AddMethod - Add a single virtual member function to the vtable\n  /// components vector.\n  void AddMethod(const CXXMethodDecl *MD, ReturnAdjustment ReturnAdjustment);\n\n  /// IsOverriderUsed - Returns whether the overrider will ever be used in this\n  /// part of the vtable.\n  ///\n  /// Itanium C++ ABI 2.5.2:\n  ///\n  ///   struct A { virtual void f(); };\n  ///   struct B : virtual public A { int i; };\n  ///   struct C : virtual public A { int j; };\n  ///   struct D : public B, public C {};\n  ///\n  ///   When B and C are declared, A is a primary base in each case, so although\n  ///   vcall offsets are allocated in the A-in-B and A-in-C vtables, no this\n  ///   adjustment is required and no thunk is generated. However, inside D\n  ///   objects, A is no longer a primary base of C, so if we allowed calls to\n  ///   C::f() to use the copy of A's vtable in the C subobject, we would need\n  ///   to adjust this from C* to B::A*, which would require a third-party\n  ///   thunk. Since we require that a call to C::f() first convert to A*,\n  ///   C-in-D's copy of A's vtable is never referenced, so this is not\n  ///   necessary.\n  bool IsOverriderUsed(const CXXMethodDecl *Overrider,\n                       CharUnits BaseOffsetInLayoutClass,\n                       const CXXRecordDecl *FirstBaseInPrimaryBaseChain,\n                       CharUnits FirstBaseOffsetInLayoutClass) const;\n\n\n  /// AddMethods - Add the methods of this base subobject and all its\n  /// primary bases to the vtable components vector.\n  void AddMethods(BaseSubobject Base, CharUnits BaseOffsetInLayoutClass,\n                  const CXXRecordDecl *FirstBaseInPrimaryBaseChain,\n                  CharUnits FirstBaseOffsetInLayoutClass,\n                  PrimaryBasesSetVectorTy &PrimaryBases);\n\n  // LayoutVTable - Layout the vtable for the given base class, including its\n  // secondary vtables and any vtables for virtual bases.\n  void LayoutVTable();\n\n  /// LayoutPrimaryAndSecondaryVTables - Layout the primary vtable for the\n  /// given base subobject, as well as all its secondary vtables.\n  ///\n  /// \\param BaseIsMorallyVirtual whether the base subobject is a virtual base\n  /// or a direct or indirect base of a virtual base.\n  ///\n  /// \\param BaseIsVirtualInLayoutClass - Whether the base subobject is virtual\n  /// in the layout class.\n  void LayoutPrimaryAndSecondaryVTables(BaseSubobject Base,\n                                        bool BaseIsMorallyVirtual,\n                                        bool BaseIsVirtualInLayoutClass,\n                                        CharUnits OffsetInLayoutClass);\n\n  /// LayoutSecondaryVTables - Layout the secondary vtables for the given base\n  /// subobject.\n  ///\n  /// \\param BaseIsMorallyVirtual whether the base subobject is a virtual base\n  /// or a direct or indirect base of a virtual base.\n  void LayoutSecondaryVTables(BaseSubobject Base, bool BaseIsMorallyVirtual,\n                              CharUnits OffsetInLayoutClass);\n\n  /// DeterminePrimaryVirtualBases - Determine the primary virtual bases in this\n  /// class hierarchy.\n  void DeterminePrimaryVirtualBases(const CXXRecordDecl *RD,\n                                    CharUnits OffsetInLayoutClass,\n                                    VisitedVirtualBasesSetTy &VBases);\n\n  /// LayoutVTablesForVirtualBases - Layout vtables for all virtual bases of the\n  /// given base (excluding any primary bases).\n  void LayoutVTablesForVirtualBases(const CXXRecordDecl *RD,\n                                    VisitedVirtualBasesSetTy &VBases);\n\n  /// isBuildingConstructionVTable - Return whether this vtable builder is\n  /// building a construction vtable.\n  bool isBuildingConstructorVTable() const {\n    return MostDerivedClass != LayoutClass;\n  }\n\npublic:\n  /// Component indices of the first component of each of the vtables in the\n  /// vtable group.\n  SmallVector<size_t, 4> VTableIndices;\n\n  ItaniumVTableBuilder(ItaniumVTableContext &VTables,\n                       const CXXRecordDecl *MostDerivedClass,\n                       CharUnits MostDerivedClassOffset,\n                       bool MostDerivedClassIsVirtual,\n                       const CXXRecordDecl *LayoutClass)\n      : VTables(VTables), MostDerivedClass(MostDerivedClass),\n        MostDerivedClassOffset(MostDerivedClassOffset),\n        MostDerivedClassIsVirtual(MostDerivedClassIsVirtual),\n        LayoutClass(LayoutClass), Context(MostDerivedClass->getASTContext()),\n        Overriders(MostDerivedClass, MostDerivedClassOffset, LayoutClass) {\n    assert(!Context.getTargetInfo().getCXXABI().isMicrosoft());\n\n    LayoutVTable();\n\n    if (Context.getLangOpts().DumpVTableLayouts)\n      dumpLayout(llvm::outs());\n  }\n\n  uint64_t getNumThunks() const {\n    return Thunks.size();\n  }\n\n  ThunksMapTy::const_iterator thunks_begin() const {\n    return Thunks.begin();\n  }\n\n  ThunksMapTy::const_iterator thunks_end() const {\n    return Thunks.end();\n  }\n\n  const VBaseOffsetOffsetsMapTy &getVBaseOffsetOffsets() const {\n    return VBaseOffsetOffsets;\n  }\n\n  const AddressPointsMapTy &getAddressPoints() const {\n    return AddressPoints;\n  }\n\n  MethodVTableIndicesTy::const_iterator vtable_indices_begin() const {\n    return MethodVTableIndices.begin();\n  }\n\n  MethodVTableIndicesTy::const_iterator vtable_indices_end() const {\n    return MethodVTableIndices.end();\n  }\n\n  ArrayRef<VTableComponent> vtable_components() const { return Components; }\n\n  AddressPointsMapTy::const_iterator address_points_begin() const {\n    return AddressPoints.begin();\n  }\n\n  AddressPointsMapTy::const_iterator address_points_end() const {\n    return AddressPoints.end();\n  }\n\n  VTableThunksMapTy::const_iterator vtable_thunks_begin() const {\n    return VTableThunks.begin();\n  }\n\n  VTableThunksMapTy::const_iterator vtable_thunks_end() const {\n    return VTableThunks.end();\n  }\n\n  /// dumpLayout - Dump the vtable layout.\n  void dumpLayout(raw_ostream&);\n};\n\nvoid ItaniumVTableBuilder::AddThunk(const CXXMethodDecl *MD,\n                                    const ThunkInfo &Thunk) {\n  assert(!isBuildingConstructorVTable() &&\n         \"Can't add thunks for construction vtable\");\n\n  SmallVectorImpl<ThunkInfo> &ThunksVector = Thunks[MD];\n\n  // Check if we have this thunk already.\n  if (llvm::find(ThunksVector, Thunk) != ThunksVector.end())\n    return;\n\n  ThunksVector.push_back(Thunk);\n}\n\ntypedef llvm::SmallPtrSet<const CXXMethodDecl *, 8> OverriddenMethodsSetTy;\n\n/// Visit all the methods overridden by the given method recursively,\n/// in a depth-first pre-order. The Visitor's visitor method returns a bool\n/// indicating whether to continue the recursion for the given overridden\n/// method (i.e. returning false stops the iteration).\ntemplate <class VisitorTy>\nstatic void\nvisitAllOverriddenMethods(const CXXMethodDecl *MD, VisitorTy &Visitor) {\n  assert(VTableContextBase::hasVtableSlot(MD) && \"Method is not virtual!\");\n\n  for (const CXXMethodDecl *OverriddenMD : MD->overridden_methods()) {\n    if (!Visitor(OverriddenMD))\n      continue;\n    visitAllOverriddenMethods(OverriddenMD, Visitor);\n  }\n}\n\n/// ComputeAllOverriddenMethods - Given a method decl, will return a set of all\n/// the overridden methods that the function decl overrides.\nstatic void\nComputeAllOverriddenMethods(const CXXMethodDecl *MD,\n                            OverriddenMethodsSetTy& OverriddenMethods) {\n  auto OverriddenMethodsCollector = [&](const CXXMethodDecl *MD) {\n    // Don't recurse on this method if we've already collected it.\n    return OverriddenMethods.insert(MD).second;\n  };\n  visitAllOverriddenMethods(MD, OverriddenMethodsCollector);\n}\n\nvoid ItaniumVTableBuilder::ComputeThisAdjustments() {\n  // Now go through the method info map and see if any of the methods need\n  // 'this' pointer adjustments.\n  for (const auto &MI : MethodInfoMap) {\n    const CXXMethodDecl *MD = MI.first;\n    const MethodInfo &MethodInfo = MI.second;\n\n    // Ignore adjustments for unused function pointers.\n    uint64_t VTableIndex = MethodInfo.VTableIndex;\n    if (Components[VTableIndex].getKind() ==\n        VTableComponent::CK_UnusedFunctionPointer)\n      continue;\n\n    // Get the final overrider for this method.\n    FinalOverriders::OverriderInfo Overrider =\n      Overriders.getOverrider(MD, MethodInfo.BaseOffset);\n\n    // Check if we need an adjustment at all.\n    if (MethodInfo.BaseOffsetInLayoutClass == Overrider.Offset) {\n      // When a return thunk is needed by a derived class that overrides a\n      // virtual base, gcc uses a virtual 'this' adjustment as well.\n      // While the thunk itself might be needed by vtables in subclasses or\n      // in construction vtables, there doesn't seem to be a reason for using\n      // the thunk in this vtable. Still, we do so to match gcc.\n      if (VTableThunks.lookup(VTableIndex).Return.isEmpty())\n        continue;\n    }\n\n    ThisAdjustment ThisAdjustment =\n      ComputeThisAdjustment(MD, MethodInfo.BaseOffsetInLayoutClass, Overrider);\n\n    if (ThisAdjustment.isEmpty())\n      continue;\n\n    // Add it.\n    VTableThunks[VTableIndex].This = ThisAdjustment;\n\n    if (isa<CXXDestructorDecl>(MD)) {\n      // Add an adjustment for the deleting destructor as well.\n      VTableThunks[VTableIndex + 1].This = ThisAdjustment;\n    }\n  }\n\n  /// Clear the method info map.\n  MethodInfoMap.clear();\n\n  if (isBuildingConstructorVTable()) {\n    // We don't need to store thunk information for construction vtables.\n    return;\n  }\n\n  for (const auto &TI : VTableThunks) {\n    const VTableComponent &Component = Components[TI.first];\n    const ThunkInfo &Thunk = TI.second;\n    const CXXMethodDecl *MD;\n\n    switch (Component.getKind()) {\n    default:\n      llvm_unreachable(\"Unexpected vtable component kind!\");\n    case VTableComponent::CK_FunctionPointer:\n      MD = Component.getFunctionDecl();\n      break;\n    case VTableComponent::CK_CompleteDtorPointer:\n      MD = Component.getDestructorDecl();\n      break;\n    case VTableComponent::CK_DeletingDtorPointer:\n      // We've already added the thunk when we saw the complete dtor pointer.\n      continue;\n    }\n\n    if (MD->getParent() == MostDerivedClass)\n      AddThunk(MD, Thunk);\n  }\n}\n\nReturnAdjustment\nItaniumVTableBuilder::ComputeReturnAdjustment(BaseOffset Offset) {\n  ReturnAdjustment Adjustment;\n\n  if (!Offset.isEmpty()) {\n    if (Offset.VirtualBase) {\n      // Get the virtual base offset offset.\n      if (Offset.DerivedClass == MostDerivedClass) {\n        // We can get the offset offset directly from our map.\n        Adjustment.Virtual.Itanium.VBaseOffsetOffset =\n          VBaseOffsetOffsets.lookup(Offset.VirtualBase).getQuantity();\n      } else {\n        Adjustment.Virtual.Itanium.VBaseOffsetOffset =\n          VTables.getVirtualBaseOffsetOffset(Offset.DerivedClass,\n                                             Offset.VirtualBase).getQuantity();\n      }\n    }\n\n    Adjustment.NonVirtual = Offset.NonVirtualOffset.getQuantity();\n  }\n\n  return Adjustment;\n}\n\nBaseOffset ItaniumVTableBuilder::ComputeThisAdjustmentBaseOffset(\n    BaseSubobject Base, BaseSubobject Derived) const {\n  const CXXRecordDecl *BaseRD = Base.getBase();\n  const CXXRecordDecl *DerivedRD = Derived.getBase();\n\n  CXXBasePaths Paths(/*FindAmbiguities=*/true,\n                     /*RecordPaths=*/true, /*DetectVirtual=*/true);\n\n  if (!DerivedRD->isDerivedFrom(BaseRD, Paths))\n    llvm_unreachable(\"Class must be derived from the passed in base class!\");\n\n  // We have to go through all the paths, and see which one leads us to the\n  // right base subobject.\n  for (const CXXBasePath &Path : Paths) {\n    BaseOffset Offset = ComputeBaseOffset(Context, DerivedRD, Path);\n\n    CharUnits OffsetToBaseSubobject = Offset.NonVirtualOffset;\n\n    if (Offset.VirtualBase) {\n      // If we have a virtual base class, the non-virtual offset is relative\n      // to the virtual base class offset.\n      const ASTRecordLayout &LayoutClassLayout =\n        Context.getASTRecordLayout(LayoutClass);\n\n      /// Get the virtual base offset, relative to the most derived class\n      /// layout.\n      OffsetToBaseSubobject +=\n        LayoutClassLayout.getVBaseClassOffset(Offset.VirtualBase);\n    } else {\n      // Otherwise, the non-virtual offset is relative to the derived class\n      // offset.\n      OffsetToBaseSubobject += Derived.getBaseOffset();\n    }\n\n    // Check if this path gives us the right base subobject.\n    if (OffsetToBaseSubobject == Base.getBaseOffset()) {\n      // Since we're going from the base class _to_ the derived class, we'll\n      // invert the non-virtual offset here.\n      Offset.NonVirtualOffset = -Offset.NonVirtualOffset;\n      return Offset;\n    }\n  }\n\n  return BaseOffset();\n}\n\nThisAdjustment ItaniumVTableBuilder::ComputeThisAdjustment(\n    const CXXMethodDecl *MD, CharUnits BaseOffsetInLayoutClass,\n    FinalOverriders::OverriderInfo Overrider) {\n  // Ignore adjustments for pure virtual member functions.\n  if (Overrider.Method->isPure())\n    return ThisAdjustment();\n\n  BaseSubobject OverriddenBaseSubobject(MD->getParent(),\n                                        BaseOffsetInLayoutClass);\n\n  BaseSubobject OverriderBaseSubobject(Overrider.Method->getParent(),\n                                       Overrider.Offset);\n\n  // Compute the adjustment offset.\n  BaseOffset Offset = ComputeThisAdjustmentBaseOffset(OverriddenBaseSubobject,\n                                                      OverriderBaseSubobject);\n  if (Offset.isEmpty())\n    return ThisAdjustment();\n\n  ThisAdjustment Adjustment;\n\n  if (Offset.VirtualBase) {\n    // Get the vcall offset map for this virtual base.\n    VCallOffsetMap &VCallOffsets = VCallOffsetsForVBases[Offset.VirtualBase];\n\n    if (VCallOffsets.empty()) {\n      // We don't have vcall offsets for this virtual base, go ahead and\n      // build them.\n      VCallAndVBaseOffsetBuilder Builder(\n          VTables, MostDerivedClass, MostDerivedClass,\n          /*Overriders=*/nullptr,\n          BaseSubobject(Offset.VirtualBase, CharUnits::Zero()),\n          /*BaseIsVirtual=*/true,\n          /*OffsetInLayoutClass=*/\n          CharUnits::Zero());\n\n      VCallOffsets = Builder.getVCallOffsets();\n    }\n\n    Adjustment.Virtual.Itanium.VCallOffsetOffset =\n      VCallOffsets.getVCallOffsetOffset(MD).getQuantity();\n  }\n\n  // Set the non-virtual part of the adjustment.\n  Adjustment.NonVirtual = Offset.NonVirtualOffset.getQuantity();\n\n  return Adjustment;\n}\n\nvoid ItaniumVTableBuilder::AddMethod(const CXXMethodDecl *MD,\n                                     ReturnAdjustment ReturnAdjustment) {\n  if (const CXXDestructorDecl *DD = dyn_cast<CXXDestructorDecl>(MD)) {\n    assert(ReturnAdjustment.isEmpty() &&\n           \"Destructor can't have return adjustment!\");\n\n    // Add both the complete destructor and the deleting destructor.\n    Components.push_back(VTableComponent::MakeCompleteDtor(DD));\n    Components.push_back(VTableComponent::MakeDeletingDtor(DD));\n  } else {\n    // Add the return adjustment if necessary.\n    if (!ReturnAdjustment.isEmpty())\n      VTableThunks[Components.size()].Return = ReturnAdjustment;\n\n    // Add the function.\n    Components.push_back(VTableComponent::MakeFunction(MD));\n  }\n}\n\n/// OverridesIndirectMethodInBase - Return whether the given member function\n/// overrides any methods in the set of given bases.\n/// Unlike OverridesMethodInBase, this checks \"overriders of overriders\".\n/// For example, if we have:\n///\n/// struct A { virtual void f(); }\n/// struct B : A { virtual void f(); }\n/// struct C : B { virtual void f(); }\n///\n/// OverridesIndirectMethodInBase will return true if given C::f as the method\n/// and { A } as the set of bases.\nstatic bool OverridesIndirectMethodInBases(\n    const CXXMethodDecl *MD,\n    ItaniumVTableBuilder::PrimaryBasesSetVectorTy &Bases) {\n  if (Bases.count(MD->getParent()))\n    return true;\n\n  for (const CXXMethodDecl *OverriddenMD : MD->overridden_methods()) {\n    // Check \"indirect overriders\".\n    if (OverridesIndirectMethodInBases(OverriddenMD, Bases))\n      return true;\n  }\n\n  return false;\n}\n\nbool ItaniumVTableBuilder::IsOverriderUsed(\n    const CXXMethodDecl *Overrider, CharUnits BaseOffsetInLayoutClass,\n    const CXXRecordDecl *FirstBaseInPrimaryBaseChain,\n    CharUnits FirstBaseOffsetInLayoutClass) const {\n  // If the base and the first base in the primary base chain have the same\n  // offsets, then this overrider will be used.\n  if (BaseOffsetInLayoutClass == FirstBaseOffsetInLayoutClass)\n   return true;\n\n  // We know now that Base (or a direct or indirect base of it) is a primary\n  // base in part of the class hierarchy, but not a primary base in the most\n  // derived class.\n\n  // If the overrider is the first base in the primary base chain, we know\n  // that the overrider will be used.\n  if (Overrider->getParent() == FirstBaseInPrimaryBaseChain)\n    return true;\n\n  ItaniumVTableBuilder::PrimaryBasesSetVectorTy PrimaryBases;\n\n  const CXXRecordDecl *RD = FirstBaseInPrimaryBaseChain;\n  PrimaryBases.insert(RD);\n\n  // Now traverse the base chain, starting with the first base, until we find\n  // the base that is no longer a primary base.\n  while (true) {\n    const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n    const CXXRecordDecl *PrimaryBase = Layout.getPrimaryBase();\n\n    if (!PrimaryBase)\n      break;\n\n    if (Layout.isPrimaryBaseVirtual()) {\n      assert(Layout.getVBaseClassOffset(PrimaryBase).isZero() &&\n             \"Primary base should always be at offset 0!\");\n\n      const ASTRecordLayout &LayoutClassLayout =\n        Context.getASTRecordLayout(LayoutClass);\n\n      // Now check if this is the primary base that is not a primary base in the\n      // most derived class.\n      if (LayoutClassLayout.getVBaseClassOffset(PrimaryBase) !=\n          FirstBaseOffsetInLayoutClass) {\n        // We found it, stop walking the chain.\n        break;\n      }\n    } else {\n      assert(Layout.getBaseClassOffset(PrimaryBase).isZero() &&\n             \"Primary base should always be at offset 0!\");\n    }\n\n    if (!PrimaryBases.insert(PrimaryBase))\n      llvm_unreachable(\"Found a duplicate primary base!\");\n\n    RD = PrimaryBase;\n  }\n\n  // If the final overrider is an override of one of the primary bases,\n  // then we know that it will be used.\n  return OverridesIndirectMethodInBases(Overrider, PrimaryBases);\n}\n\ntypedef llvm::SmallSetVector<const CXXRecordDecl *, 8> BasesSetVectorTy;\n\n/// FindNearestOverriddenMethod - Given a method, returns the overridden method\n/// from the nearest base. Returns null if no method was found.\n/// The Bases are expected to be sorted in a base-to-derived order.\nstatic const CXXMethodDecl *\nFindNearestOverriddenMethod(const CXXMethodDecl *MD,\n                            BasesSetVectorTy &Bases) {\n  OverriddenMethodsSetTy OverriddenMethods;\n  ComputeAllOverriddenMethods(MD, OverriddenMethods);\n\n  for (const CXXRecordDecl *PrimaryBase :\n       llvm::make_range(Bases.rbegin(), Bases.rend())) {\n    // Now check the overridden methods.\n    for (const CXXMethodDecl *OverriddenMD : OverriddenMethods) {\n      // We found our overridden method.\n      if (OverriddenMD->getParent() == PrimaryBase)\n        return OverriddenMD;\n    }\n  }\n\n  return nullptr;\n}\n\nvoid ItaniumVTableBuilder::AddMethods(\n    BaseSubobject Base, CharUnits BaseOffsetInLayoutClass,\n    const CXXRecordDecl *FirstBaseInPrimaryBaseChain,\n    CharUnits FirstBaseOffsetInLayoutClass,\n    PrimaryBasesSetVectorTy &PrimaryBases) {\n  // Itanium C++ ABI 2.5.2:\n  //   The order of the virtual function pointers in a virtual table is the\n  //   order of declaration of the corresponding member functions in the class.\n  //\n  //   There is an entry for any virtual function declared in a class,\n  //   whether it is a new function or overrides a base class function,\n  //   unless it overrides a function from the primary base, and conversion\n  //   between their return types does not require an adjustment.\n\n  const CXXRecordDecl *RD = Base.getBase();\n  const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n\n  if (const CXXRecordDecl *PrimaryBase = Layout.getPrimaryBase()) {\n    CharUnits PrimaryBaseOffset;\n    CharUnits PrimaryBaseOffsetInLayoutClass;\n    if (Layout.isPrimaryBaseVirtual()) {\n      assert(Layout.getVBaseClassOffset(PrimaryBase).isZero() &&\n             \"Primary vbase should have a zero offset!\");\n\n      const ASTRecordLayout &MostDerivedClassLayout =\n        Context.getASTRecordLayout(MostDerivedClass);\n\n      PrimaryBaseOffset =\n        MostDerivedClassLayout.getVBaseClassOffset(PrimaryBase);\n\n      const ASTRecordLayout &LayoutClassLayout =\n        Context.getASTRecordLayout(LayoutClass);\n\n      PrimaryBaseOffsetInLayoutClass =\n        LayoutClassLayout.getVBaseClassOffset(PrimaryBase);\n    } else {\n      assert(Layout.getBaseClassOffset(PrimaryBase).isZero() &&\n             \"Primary base should have a zero offset!\");\n\n      PrimaryBaseOffset = Base.getBaseOffset();\n      PrimaryBaseOffsetInLayoutClass = BaseOffsetInLayoutClass;\n    }\n\n    AddMethods(BaseSubobject(PrimaryBase, PrimaryBaseOffset),\n               PrimaryBaseOffsetInLayoutClass, FirstBaseInPrimaryBaseChain,\n               FirstBaseOffsetInLayoutClass, PrimaryBases);\n\n    if (!PrimaryBases.insert(PrimaryBase))\n      llvm_unreachable(\"Found a duplicate primary base!\");\n  }\n\n  typedef llvm::SmallVector<const CXXMethodDecl *, 8> NewVirtualFunctionsTy;\n  NewVirtualFunctionsTy NewVirtualFunctions;\n\n  llvm::SmallVector<const CXXMethodDecl*, 4> NewImplicitVirtualFunctions;\n\n  // Now go through all virtual member functions and add them.\n  for (const auto *MD : RD->methods()) {\n    if (!ItaniumVTableContext::hasVtableSlot(MD))\n      continue;\n    MD = MD->getCanonicalDecl();\n\n    // Get the final overrider.\n    FinalOverriders::OverriderInfo Overrider =\n      Overriders.getOverrider(MD, Base.getBaseOffset());\n\n    // Check if this virtual member function overrides a method in a primary\n    // base. If this is the case, and the return type doesn't require adjustment\n    // then we can just use the member function from the primary base.\n    if (const CXXMethodDecl *OverriddenMD =\n          FindNearestOverriddenMethod(MD, PrimaryBases)) {\n      if (ComputeReturnAdjustmentBaseOffset(Context, MD,\n                                            OverriddenMD).isEmpty()) {\n        // Replace the method info of the overridden method with our own\n        // method.\n        assert(MethodInfoMap.count(OverriddenMD) &&\n               \"Did not find the overridden method!\");\n        MethodInfo &OverriddenMethodInfo = MethodInfoMap[OverriddenMD];\n\n        MethodInfo MethodInfo(Base.getBaseOffset(), BaseOffsetInLayoutClass,\n                              OverriddenMethodInfo.VTableIndex);\n\n        assert(!MethodInfoMap.count(MD) &&\n               \"Should not have method info for this method yet!\");\n\n        MethodInfoMap.insert(std::make_pair(MD, MethodInfo));\n        MethodInfoMap.erase(OverriddenMD);\n\n        // If the overridden method exists in a virtual base class or a direct\n        // or indirect base class of a virtual base class, we need to emit a\n        // thunk if we ever have a class hierarchy where the base class is not\n        // a primary base in the complete object.\n        if (!isBuildingConstructorVTable() && OverriddenMD != MD) {\n          // Compute the this adjustment.\n          ThisAdjustment ThisAdjustment =\n            ComputeThisAdjustment(OverriddenMD, BaseOffsetInLayoutClass,\n                                  Overrider);\n\n          if (ThisAdjustment.Virtual.Itanium.VCallOffsetOffset &&\n              Overrider.Method->getParent() == MostDerivedClass) {\n\n            // There's no return adjustment from OverriddenMD and MD,\n            // but that doesn't mean there isn't one between MD and\n            // the final overrider.\n            BaseOffset ReturnAdjustmentOffset =\n              ComputeReturnAdjustmentBaseOffset(Context, Overrider.Method, MD);\n            ReturnAdjustment ReturnAdjustment =\n              ComputeReturnAdjustment(ReturnAdjustmentOffset);\n\n            // This is a virtual thunk for the most derived class, add it.\n            AddThunk(Overrider.Method,\n                     ThunkInfo(ThisAdjustment, ReturnAdjustment));\n          }\n        }\n\n        continue;\n      }\n    }\n\n    if (MD->isImplicit())\n      NewImplicitVirtualFunctions.push_back(MD);\n    else\n      NewVirtualFunctions.push_back(MD);\n  }\n\n  std::stable_sort(\n      NewImplicitVirtualFunctions.begin(), NewImplicitVirtualFunctions.end(),\n      [](const CXXMethodDecl *A, const CXXMethodDecl *B) {\n        if (A->isCopyAssignmentOperator() != B->isCopyAssignmentOperator())\n          return A->isCopyAssignmentOperator();\n        if (A->isMoveAssignmentOperator() != B->isMoveAssignmentOperator())\n          return A->isMoveAssignmentOperator();\n        if (isa<CXXDestructorDecl>(A) != isa<CXXDestructorDecl>(B))\n          return isa<CXXDestructorDecl>(A);\n        assert(A->getOverloadedOperator() == OO_EqualEqual &&\n               B->getOverloadedOperator() == OO_EqualEqual &&\n               \"unexpected or duplicate implicit virtual function\");\n        // We rely on Sema to have declared the operator== members in the\n        // same order as the corresponding operator<=> members.\n        return false;\n      });\n  NewVirtualFunctions.append(NewImplicitVirtualFunctions.begin(),\n                             NewImplicitVirtualFunctions.end());\n\n  for (const CXXMethodDecl *MD : NewVirtualFunctions) {\n    // Get the final overrider.\n    FinalOverriders::OverriderInfo Overrider =\n      Overriders.getOverrider(MD, Base.getBaseOffset());\n\n    // Insert the method info for this method.\n    MethodInfo MethodInfo(Base.getBaseOffset(), BaseOffsetInLayoutClass,\n                          Components.size());\n\n    assert(!MethodInfoMap.count(MD) &&\n           \"Should not have method info for this method yet!\");\n    MethodInfoMap.insert(std::make_pair(MD, MethodInfo));\n\n    // Check if this overrider is going to be used.\n    const CXXMethodDecl *OverriderMD = Overrider.Method;\n    if (!IsOverriderUsed(OverriderMD, BaseOffsetInLayoutClass,\n                         FirstBaseInPrimaryBaseChain,\n                         FirstBaseOffsetInLayoutClass)) {\n      Components.push_back(VTableComponent::MakeUnusedFunction(OverriderMD));\n      continue;\n    }\n\n    // Check if this overrider needs a return adjustment.\n    // We don't want to do this for pure virtual member functions.\n    BaseOffset ReturnAdjustmentOffset;\n    if (!OverriderMD->isPure()) {\n      ReturnAdjustmentOffset =\n        ComputeReturnAdjustmentBaseOffset(Context, OverriderMD, MD);\n    }\n\n    ReturnAdjustment ReturnAdjustment =\n      ComputeReturnAdjustment(ReturnAdjustmentOffset);\n\n    AddMethod(Overrider.Method, ReturnAdjustment);\n  }\n}\n\nvoid ItaniumVTableBuilder::LayoutVTable() {\n  LayoutPrimaryAndSecondaryVTables(BaseSubobject(MostDerivedClass,\n                                                 CharUnits::Zero()),\n                                   /*BaseIsMorallyVirtual=*/false,\n                                   MostDerivedClassIsVirtual,\n                                   MostDerivedClassOffset);\n\n  VisitedVirtualBasesSetTy VBases;\n\n  // Determine the primary virtual bases.\n  DeterminePrimaryVirtualBases(MostDerivedClass, MostDerivedClassOffset,\n                               VBases);\n  VBases.clear();\n\n  LayoutVTablesForVirtualBases(MostDerivedClass, VBases);\n\n  // -fapple-kext adds an extra entry at end of vtbl.\n  bool IsAppleKext = Context.getLangOpts().AppleKext;\n  if (IsAppleKext)\n    Components.push_back(VTableComponent::MakeVCallOffset(CharUnits::Zero()));\n}\n\nvoid ItaniumVTableBuilder::LayoutPrimaryAndSecondaryVTables(\n    BaseSubobject Base, bool BaseIsMorallyVirtual,\n    bool BaseIsVirtualInLayoutClass, CharUnits OffsetInLayoutClass) {\n  assert(Base.getBase()->isDynamicClass() && \"class does not have a vtable!\");\n\n  unsigned VTableIndex = Components.size();\n  VTableIndices.push_back(VTableIndex);\n\n  // Add vcall and vbase offsets for this vtable.\n  VCallAndVBaseOffsetBuilder Builder(\n      VTables, MostDerivedClass, LayoutClass, &Overriders, Base,\n      BaseIsVirtualInLayoutClass, OffsetInLayoutClass);\n  Components.append(Builder.components_begin(), Builder.components_end());\n\n  // Check if we need to add these vcall offsets.\n  if (BaseIsVirtualInLayoutClass && !Builder.getVCallOffsets().empty()) {\n    VCallOffsetMap &VCallOffsets = VCallOffsetsForVBases[Base.getBase()];\n\n    if (VCallOffsets.empty())\n      VCallOffsets = Builder.getVCallOffsets();\n  }\n\n  // If we're laying out the most derived class we want to keep track of the\n  // virtual base class offset offsets.\n  if (Base.getBase() == MostDerivedClass)\n    VBaseOffsetOffsets = Builder.getVBaseOffsetOffsets();\n\n  // Add the offset to top.\n  CharUnits OffsetToTop = MostDerivedClassOffset - OffsetInLayoutClass;\n  Components.push_back(VTableComponent::MakeOffsetToTop(OffsetToTop));\n\n  // Next, add the RTTI.\n  Components.push_back(VTableComponent::MakeRTTI(MostDerivedClass));\n\n  uint64_t AddressPoint = Components.size();\n\n  // Now go through all virtual member functions and add them.\n  PrimaryBasesSetVectorTy PrimaryBases;\n  AddMethods(Base, OffsetInLayoutClass,\n             Base.getBase(), OffsetInLayoutClass,\n             PrimaryBases);\n\n  const CXXRecordDecl *RD = Base.getBase();\n  if (RD == MostDerivedClass) {\n    assert(MethodVTableIndices.empty());\n    for (const auto &I : MethodInfoMap) {\n      const CXXMethodDecl *MD = I.first;\n      const MethodInfo &MI = I.second;\n      if (const CXXDestructorDecl *DD = dyn_cast<CXXDestructorDecl>(MD)) {\n        MethodVTableIndices[GlobalDecl(DD, Dtor_Complete)]\n            = MI.VTableIndex - AddressPoint;\n        MethodVTableIndices[GlobalDecl(DD, Dtor_Deleting)]\n            = MI.VTableIndex + 1 - AddressPoint;\n      } else {\n        MethodVTableIndices[MD] = MI.VTableIndex - AddressPoint;\n      }\n    }\n  }\n\n  // Compute 'this' pointer adjustments.\n  ComputeThisAdjustments();\n\n  // Add all address points.\n  while (true) {\n    AddressPoints.insert(\n        std::make_pair(BaseSubobject(RD, OffsetInLayoutClass),\n                       VTableLayout::AddressPointLocation{\n                           unsigned(VTableIndices.size() - 1),\n                           unsigned(AddressPoint - VTableIndex)}));\n\n    const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n    const CXXRecordDecl *PrimaryBase = Layout.getPrimaryBase();\n\n    if (!PrimaryBase)\n      break;\n\n    if (Layout.isPrimaryBaseVirtual()) {\n      // Check if this virtual primary base is a primary base in the layout\n      // class. If it's not, we don't want to add it.\n      const ASTRecordLayout &LayoutClassLayout =\n        Context.getASTRecordLayout(LayoutClass);\n\n      if (LayoutClassLayout.getVBaseClassOffset(PrimaryBase) !=\n          OffsetInLayoutClass) {\n        // We don't want to add this class (or any of its primary bases).\n        break;\n      }\n    }\n\n    RD = PrimaryBase;\n  }\n\n  // Layout secondary vtables.\n  LayoutSecondaryVTables(Base, BaseIsMorallyVirtual, OffsetInLayoutClass);\n}\n\nvoid\nItaniumVTableBuilder::LayoutSecondaryVTables(BaseSubobject Base,\n                                             bool BaseIsMorallyVirtual,\n                                             CharUnits OffsetInLayoutClass) {\n  // Itanium C++ ABI 2.5.2:\n  //   Following the primary virtual table of a derived class are secondary\n  //   virtual tables for each of its proper base classes, except any primary\n  //   base(s) with which it shares its primary virtual table.\n\n  const CXXRecordDecl *RD = Base.getBase();\n  const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n  const CXXRecordDecl *PrimaryBase = Layout.getPrimaryBase();\n\n  for (const auto &B : RD->bases()) {\n    // Ignore virtual bases, we'll emit them later.\n    if (B.isVirtual())\n      continue;\n\n    const CXXRecordDecl *BaseDecl = B.getType()->getAsCXXRecordDecl();\n\n    // Ignore bases that don't have a vtable.\n    if (!BaseDecl->isDynamicClass())\n      continue;\n\n    if (isBuildingConstructorVTable()) {\n      // Itanium C++ ABI 2.6.4:\n      //   Some of the base class subobjects may not need construction virtual\n      //   tables, which will therefore not be present in the construction\n      //   virtual table group, even though the subobject virtual tables are\n      //   present in the main virtual table group for the complete object.\n      if (!BaseIsMorallyVirtual && !BaseDecl->getNumVBases())\n        continue;\n    }\n\n    // Get the base offset of this base.\n    CharUnits RelativeBaseOffset = Layout.getBaseClassOffset(BaseDecl);\n    CharUnits BaseOffset = Base.getBaseOffset() + RelativeBaseOffset;\n\n    CharUnits BaseOffsetInLayoutClass =\n      OffsetInLayoutClass + RelativeBaseOffset;\n\n    // Don't emit a secondary vtable for a primary base. We might however want\n    // to emit secondary vtables for other bases of this base.\n    if (BaseDecl == PrimaryBase) {\n      LayoutSecondaryVTables(BaseSubobject(BaseDecl, BaseOffset),\n                             BaseIsMorallyVirtual, BaseOffsetInLayoutClass);\n      continue;\n    }\n\n    // Layout the primary vtable (and any secondary vtables) for this base.\n    LayoutPrimaryAndSecondaryVTables(\n      BaseSubobject(BaseDecl, BaseOffset),\n      BaseIsMorallyVirtual,\n      /*BaseIsVirtualInLayoutClass=*/false,\n      BaseOffsetInLayoutClass);\n  }\n}\n\nvoid ItaniumVTableBuilder::DeterminePrimaryVirtualBases(\n    const CXXRecordDecl *RD, CharUnits OffsetInLayoutClass,\n    VisitedVirtualBasesSetTy &VBases) {\n  const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n\n  // Check if this base has a primary base.\n  if (const CXXRecordDecl *PrimaryBase = Layout.getPrimaryBase()) {\n\n    // Check if it's virtual.\n    if (Layout.isPrimaryBaseVirtual()) {\n      bool IsPrimaryVirtualBase = true;\n\n      if (isBuildingConstructorVTable()) {\n        // Check if the base is actually a primary base in the class we use for\n        // layout.\n        const ASTRecordLayout &LayoutClassLayout =\n          Context.getASTRecordLayout(LayoutClass);\n\n        CharUnits PrimaryBaseOffsetInLayoutClass =\n          LayoutClassLayout.getVBaseClassOffset(PrimaryBase);\n\n        // We know that the base is not a primary base in the layout class if\n        // the base offsets are different.\n        if (PrimaryBaseOffsetInLayoutClass != OffsetInLayoutClass)\n          IsPrimaryVirtualBase = false;\n      }\n\n      if (IsPrimaryVirtualBase)\n        PrimaryVirtualBases.insert(PrimaryBase);\n    }\n  }\n\n  // Traverse bases, looking for more primary virtual bases.\n  for (const auto &B : RD->bases()) {\n    const CXXRecordDecl *BaseDecl = B.getType()->getAsCXXRecordDecl();\n\n    CharUnits BaseOffsetInLayoutClass;\n\n    if (B.isVirtual()) {\n      if (!VBases.insert(BaseDecl).second)\n        continue;\n\n      const ASTRecordLayout &LayoutClassLayout =\n        Context.getASTRecordLayout(LayoutClass);\n\n      BaseOffsetInLayoutClass =\n        LayoutClassLayout.getVBaseClassOffset(BaseDecl);\n    } else {\n      BaseOffsetInLayoutClass =\n        OffsetInLayoutClass + Layout.getBaseClassOffset(BaseDecl);\n    }\n\n    DeterminePrimaryVirtualBases(BaseDecl, BaseOffsetInLayoutClass, VBases);\n  }\n}\n\nvoid ItaniumVTableBuilder::LayoutVTablesForVirtualBases(\n    const CXXRecordDecl *RD, VisitedVirtualBasesSetTy &VBases) {\n  // Itanium C++ ABI 2.5.2:\n  //   Then come the virtual base virtual tables, also in inheritance graph\n  //   order, and again excluding primary bases (which share virtual tables with\n  //   the classes for which they are primary).\n  for (const auto &B : RD->bases()) {\n    const CXXRecordDecl *BaseDecl = B.getType()->getAsCXXRecordDecl();\n\n    // Check if this base needs a vtable. (If it's virtual, not a primary base\n    // of some other class, and we haven't visited it before).\n    if (B.isVirtual() && BaseDecl->isDynamicClass() &&\n        !PrimaryVirtualBases.count(BaseDecl) &&\n        VBases.insert(BaseDecl).second) {\n      const ASTRecordLayout &MostDerivedClassLayout =\n        Context.getASTRecordLayout(MostDerivedClass);\n      CharUnits BaseOffset =\n        MostDerivedClassLayout.getVBaseClassOffset(BaseDecl);\n\n      const ASTRecordLayout &LayoutClassLayout =\n        Context.getASTRecordLayout(LayoutClass);\n      CharUnits BaseOffsetInLayoutClass =\n        LayoutClassLayout.getVBaseClassOffset(BaseDecl);\n\n      LayoutPrimaryAndSecondaryVTables(\n        BaseSubobject(BaseDecl, BaseOffset),\n        /*BaseIsMorallyVirtual=*/true,\n        /*BaseIsVirtualInLayoutClass=*/true,\n        BaseOffsetInLayoutClass);\n    }\n\n    // We only need to check the base for virtual base vtables if it actually\n    // has virtual bases.\n    if (BaseDecl->getNumVBases())\n      LayoutVTablesForVirtualBases(BaseDecl, VBases);\n  }\n}\n\n/// dumpLayout - Dump the vtable layout.\nvoid ItaniumVTableBuilder::dumpLayout(raw_ostream &Out) {\n  // FIXME: write more tests that actually use the dumpLayout output to prevent\n  // ItaniumVTableBuilder regressions.\n\n  if (isBuildingConstructorVTable()) {\n    Out << \"Construction vtable for ('\";\n    MostDerivedClass->printQualifiedName(Out);\n    Out << \"', \";\n    Out << MostDerivedClassOffset.getQuantity() << \") in '\";\n    LayoutClass->printQualifiedName(Out);\n  } else {\n    Out << \"Vtable for '\";\n    MostDerivedClass->printQualifiedName(Out);\n  }\n  Out << \"' (\" << Components.size() << \" entries).\\n\";\n\n  // Iterate through the address points and insert them into a new map where\n  // they are keyed by the index and not the base object.\n  // Since an address point can be shared by multiple subobjects, we use an\n  // STL multimap.\n  std::multimap<uint64_t, BaseSubobject> AddressPointsByIndex;\n  for (const auto &AP : AddressPoints) {\n    const BaseSubobject &Base = AP.first;\n    uint64_t Index =\n        VTableIndices[AP.second.VTableIndex] + AP.second.AddressPointIndex;\n\n    AddressPointsByIndex.insert(std::make_pair(Index, Base));\n  }\n\n  for (unsigned I = 0, E = Components.size(); I != E; ++I) {\n    uint64_t Index = I;\n\n    Out << llvm::format(\"%4d | \", I);\n\n    const VTableComponent &Component = Components[I];\n\n    // Dump the component.\n    switch (Component.getKind()) {\n\n    case VTableComponent::CK_VCallOffset:\n      Out << \"vcall_offset (\"\n          << Component.getVCallOffset().getQuantity()\n          << \")\";\n      break;\n\n    case VTableComponent::CK_VBaseOffset:\n      Out << \"vbase_offset (\"\n          << Component.getVBaseOffset().getQuantity()\n          << \")\";\n      break;\n\n    case VTableComponent::CK_OffsetToTop:\n      Out << \"offset_to_top (\"\n          << Component.getOffsetToTop().getQuantity()\n          << \")\";\n      break;\n\n    case VTableComponent::CK_RTTI:\n      Component.getRTTIDecl()->printQualifiedName(Out);\n      Out << \" RTTI\";\n      break;\n\n    case VTableComponent::CK_FunctionPointer: {\n      const CXXMethodDecl *MD = Component.getFunctionDecl();\n\n      std::string Str =\n        PredefinedExpr::ComputeName(PredefinedExpr::PrettyFunctionNoVirtual,\n                                    MD);\n      Out << Str;\n      if (MD->isPure())\n        Out << \" [pure]\";\n\n      if (MD->isDeleted())\n        Out << \" [deleted]\";\n\n      ThunkInfo Thunk = VTableThunks.lookup(I);\n      if (!Thunk.isEmpty()) {\n        // If this function pointer has a return adjustment, dump it.\n        if (!Thunk.Return.isEmpty()) {\n          Out << \"\\n       [return adjustment: \";\n          Out << Thunk.Return.NonVirtual << \" non-virtual\";\n\n          if (Thunk.Return.Virtual.Itanium.VBaseOffsetOffset) {\n            Out << \", \" << Thunk.Return.Virtual.Itanium.VBaseOffsetOffset;\n            Out << \" vbase offset offset\";\n          }\n\n          Out << ']';\n        }\n\n        // If this function pointer has a 'this' pointer adjustment, dump it.\n        if (!Thunk.This.isEmpty()) {\n          Out << \"\\n       [this adjustment: \";\n          Out << Thunk.This.NonVirtual << \" non-virtual\";\n\n          if (Thunk.This.Virtual.Itanium.VCallOffsetOffset) {\n            Out << \", \" << Thunk.This.Virtual.Itanium.VCallOffsetOffset;\n            Out << \" vcall offset offset\";\n          }\n\n          Out << ']';\n        }\n      }\n\n      break;\n    }\n\n    case VTableComponent::CK_CompleteDtorPointer:\n    case VTableComponent::CK_DeletingDtorPointer: {\n      bool IsComplete =\n        Component.getKind() == VTableComponent::CK_CompleteDtorPointer;\n\n      const CXXDestructorDecl *DD = Component.getDestructorDecl();\n\n      DD->printQualifiedName(Out);\n      if (IsComplete)\n        Out << \"() [complete]\";\n      else\n        Out << \"() [deleting]\";\n\n      if (DD->isPure())\n        Out << \" [pure]\";\n\n      ThunkInfo Thunk = VTableThunks.lookup(I);\n      if (!Thunk.isEmpty()) {\n        // If this destructor has a 'this' pointer adjustment, dump it.\n        if (!Thunk.This.isEmpty()) {\n          Out << \"\\n       [this adjustment: \";\n          Out << Thunk.This.NonVirtual << \" non-virtual\";\n\n          if (Thunk.This.Virtual.Itanium.VCallOffsetOffset) {\n            Out << \", \" << Thunk.This.Virtual.Itanium.VCallOffsetOffset;\n            Out << \" vcall offset offset\";\n          }\n\n          Out << ']';\n        }\n      }\n\n      break;\n    }\n\n    case VTableComponent::CK_UnusedFunctionPointer: {\n      const CXXMethodDecl *MD = Component.getUnusedFunctionDecl();\n\n      std::string Str =\n        PredefinedExpr::ComputeName(PredefinedExpr::PrettyFunctionNoVirtual,\n                                    MD);\n      Out << \"[unused] \" << Str;\n      if (MD->isPure())\n        Out << \" [pure]\";\n    }\n\n    }\n\n    Out << '\\n';\n\n    // Dump the next address point.\n    uint64_t NextIndex = Index + 1;\n    if (AddressPointsByIndex.count(NextIndex)) {\n      if (AddressPointsByIndex.count(NextIndex) == 1) {\n        const BaseSubobject &Base =\n          AddressPointsByIndex.find(NextIndex)->second;\n\n        Out << \"       -- (\";\n        Base.getBase()->printQualifiedName(Out);\n        Out << \", \" << Base.getBaseOffset().getQuantity();\n        Out << \") vtable address --\\n\";\n      } else {\n        CharUnits BaseOffset =\n          AddressPointsByIndex.lower_bound(NextIndex)->second.getBaseOffset();\n\n        // We store the class names in a set to get a stable order.\n        std::set<std::string> ClassNames;\n        for (const auto &I :\n             llvm::make_range(AddressPointsByIndex.equal_range(NextIndex))) {\n          assert(I.second.getBaseOffset() == BaseOffset &&\n                 \"Invalid base offset!\");\n          const CXXRecordDecl *RD = I.second.getBase();\n          ClassNames.insert(RD->getQualifiedNameAsString());\n        }\n\n        for (const std::string &Name : ClassNames) {\n          Out << \"       -- (\" << Name;\n          Out << \", \" << BaseOffset.getQuantity() << \") vtable address --\\n\";\n        }\n      }\n    }\n  }\n\n  Out << '\\n';\n\n  if (isBuildingConstructorVTable())\n    return;\n\n  if (MostDerivedClass->getNumVBases()) {\n    // We store the virtual base class names and their offsets in a map to get\n    // a stable order.\n\n    std::map<std::string, CharUnits> ClassNamesAndOffsets;\n    for (const auto &I : VBaseOffsetOffsets) {\n      std::string ClassName = I.first->getQualifiedNameAsString();\n      CharUnits OffsetOffset = I.second;\n      ClassNamesAndOffsets.insert(std::make_pair(ClassName, OffsetOffset));\n    }\n\n    Out << \"Virtual base offset offsets for '\";\n    MostDerivedClass->printQualifiedName(Out);\n    Out << \"' (\";\n    Out << ClassNamesAndOffsets.size();\n    Out << (ClassNamesAndOffsets.size() == 1 ? \" entry\" : \" entries\") << \").\\n\";\n\n    for (const auto &I : ClassNamesAndOffsets)\n      Out << \"   \" << I.first << \" | \" << I.second.getQuantity() << '\\n';\n\n    Out << \"\\n\";\n  }\n\n  if (!Thunks.empty()) {\n    // We store the method names in a map to get a stable order.\n    std::map<std::string, const CXXMethodDecl *> MethodNamesAndDecls;\n\n    for (const auto &I : Thunks) {\n      const CXXMethodDecl *MD = I.first;\n      std::string MethodName =\n        PredefinedExpr::ComputeName(PredefinedExpr::PrettyFunctionNoVirtual,\n                                    MD);\n\n      MethodNamesAndDecls.insert(std::make_pair(MethodName, MD));\n    }\n\n    for (const auto &I : MethodNamesAndDecls) {\n      const std::string &MethodName = I.first;\n      const CXXMethodDecl *MD = I.second;\n\n      ThunkInfoVectorTy ThunksVector = Thunks[MD];\n      llvm::sort(ThunksVector, [](const ThunkInfo &LHS, const ThunkInfo &RHS) {\n        assert(LHS.Method == nullptr && RHS.Method == nullptr);\n        return std::tie(LHS.This, LHS.Return) < std::tie(RHS.This, RHS.Return);\n      });\n\n      Out << \"Thunks for '\" << MethodName << \"' (\" << ThunksVector.size();\n      Out << (ThunksVector.size() == 1 ? \" entry\" : \" entries\") << \").\\n\";\n\n      for (unsigned I = 0, E = ThunksVector.size(); I != E; ++I) {\n        const ThunkInfo &Thunk = ThunksVector[I];\n\n        Out << llvm::format(\"%4d | \", I);\n\n        // If this function pointer has a return pointer adjustment, dump it.\n        if (!Thunk.Return.isEmpty()) {\n          Out << \"return adjustment: \" << Thunk.Return.NonVirtual;\n          Out << \" non-virtual\";\n          if (Thunk.Return.Virtual.Itanium.VBaseOffsetOffset) {\n            Out << \", \" << Thunk.Return.Virtual.Itanium.VBaseOffsetOffset;\n            Out << \" vbase offset offset\";\n          }\n\n          if (!Thunk.This.isEmpty())\n            Out << \"\\n       \";\n        }\n\n        // If this function pointer has a 'this' pointer adjustment, dump it.\n        if (!Thunk.This.isEmpty()) {\n          Out << \"this adjustment: \";\n          Out << Thunk.This.NonVirtual << \" non-virtual\";\n\n          if (Thunk.This.Virtual.Itanium.VCallOffsetOffset) {\n            Out << \", \" << Thunk.This.Virtual.Itanium.VCallOffsetOffset;\n            Out << \" vcall offset offset\";\n          }\n        }\n\n        Out << '\\n';\n      }\n\n      Out << '\\n';\n    }\n  }\n\n  // Compute the vtable indices for all the member functions.\n  // Store them in a map keyed by the index so we'll get a sorted table.\n  std::map<uint64_t, std::string> IndicesMap;\n\n  for (const auto *MD : MostDerivedClass->methods()) {\n    // We only want virtual member functions.\n    if (!ItaniumVTableContext::hasVtableSlot(MD))\n      continue;\n    MD = MD->getCanonicalDecl();\n\n    std::string MethodName =\n      PredefinedExpr::ComputeName(PredefinedExpr::PrettyFunctionNoVirtual,\n                                  MD);\n\n    if (const CXXDestructorDecl *DD = dyn_cast<CXXDestructorDecl>(MD)) {\n      GlobalDecl GD(DD, Dtor_Complete);\n      assert(MethodVTableIndices.count(GD));\n      uint64_t VTableIndex = MethodVTableIndices[GD];\n      IndicesMap[VTableIndex] = MethodName + \" [complete]\";\n      IndicesMap[VTableIndex + 1] = MethodName + \" [deleting]\";\n    } else {\n      assert(MethodVTableIndices.count(MD));\n      IndicesMap[MethodVTableIndices[MD]] = MethodName;\n    }\n  }\n\n  // Print the vtable indices for all the member functions.\n  if (!IndicesMap.empty()) {\n    Out << \"VTable indices for '\";\n    MostDerivedClass->printQualifiedName(Out);\n    Out << \"' (\" << IndicesMap.size() << \" entries).\\n\";\n\n    for (const auto &I : IndicesMap) {\n      uint64_t VTableIndex = I.first;\n      const std::string &MethodName = I.second;\n\n      Out << llvm::format(\"%4\" PRIu64 \" | \", VTableIndex) << MethodName\n          << '\\n';\n    }\n  }\n\n  Out << '\\n';\n}\n}\n\nstatic VTableLayout::AddressPointsIndexMapTy\nMakeAddressPointIndices(const VTableLayout::AddressPointsMapTy &addressPoints,\n                        unsigned numVTables) {\n  VTableLayout::AddressPointsIndexMapTy indexMap(numVTables);\n\n  for (auto it = addressPoints.begin(); it != addressPoints.end(); ++it) {\n    const auto &addressPointLoc = it->second;\n    unsigned vtableIndex = addressPointLoc.VTableIndex;\n    unsigned addressPoint = addressPointLoc.AddressPointIndex;\n    if (indexMap[vtableIndex]) {\n      // Multiple BaseSubobjects can map to the same AddressPointLocation, but\n      // every vtable index should have a unique address point.\n      assert(indexMap[vtableIndex] == addressPoint &&\n             \"Every vtable index should have a unique address point. Found a \"\n             \"vtable that has two different address points.\");\n    } else {\n      indexMap[vtableIndex] = addressPoint;\n    }\n  }\n\n  // Note that by this point, not all the address may be initialized if the\n  // AddressPoints map is empty. This is ok if the map isn't needed. See\n  // MicrosoftVTableContext::computeVTableRelatedInformation() which uses an\n  // emprt map.\n  return indexMap;\n}\n\nVTableLayout::VTableLayout(ArrayRef<size_t> VTableIndices,\n                           ArrayRef<VTableComponent> VTableComponents,\n                           ArrayRef<VTableThunkTy> VTableThunks,\n                           const AddressPointsMapTy &AddressPoints)\n    : VTableComponents(VTableComponents), VTableThunks(VTableThunks),\n      AddressPoints(AddressPoints), AddressPointIndices(MakeAddressPointIndices(\n                                        AddressPoints, VTableIndices.size())) {\n  if (VTableIndices.size() <= 1)\n    assert(VTableIndices.size() == 1 && VTableIndices[0] == 0);\n  else\n    this->VTableIndices = OwningArrayRef<size_t>(VTableIndices);\n\n  llvm::sort(this->VTableThunks, [](const VTableLayout::VTableThunkTy &LHS,\n                                    const VTableLayout::VTableThunkTy &RHS) {\n    assert((LHS.first != RHS.first || LHS.second == RHS.second) &&\n           \"Different thunks should have unique indices!\");\n    return LHS.first < RHS.first;\n  });\n}\n\nVTableLayout::~VTableLayout() { }\n\nbool VTableContextBase::hasVtableSlot(const CXXMethodDecl *MD) {\n  return MD->isVirtual() && !MD->isConsteval();\n}\n\nItaniumVTableContext::ItaniumVTableContext(\n    ASTContext &Context, VTableComponentLayout ComponentLayout)\n    : VTableContextBase(/*MS=*/false), ComponentLayout(ComponentLayout) {}\n\nItaniumVTableContext::~ItaniumVTableContext() {}\n\nuint64_t ItaniumVTableContext::getMethodVTableIndex(GlobalDecl GD) {\n  GD = GD.getCanonicalDecl();\n  MethodVTableIndicesTy::iterator I = MethodVTableIndices.find(GD);\n  if (I != MethodVTableIndices.end())\n    return I->second;\n\n  const CXXRecordDecl *RD = cast<CXXMethodDecl>(GD.getDecl())->getParent();\n\n  computeVTableRelatedInformation(RD);\n\n  I = MethodVTableIndices.find(GD);\n  assert(I != MethodVTableIndices.end() && \"Did not find index!\");\n  return I->second;\n}\n\nCharUnits\nItaniumVTableContext::getVirtualBaseOffsetOffset(const CXXRecordDecl *RD,\n                                                 const CXXRecordDecl *VBase) {\n  ClassPairTy ClassPair(RD, VBase);\n\n  VirtualBaseClassOffsetOffsetsMapTy::iterator I =\n    VirtualBaseClassOffsetOffsets.find(ClassPair);\n  if (I != VirtualBaseClassOffsetOffsets.end())\n    return I->second;\n\n  VCallAndVBaseOffsetBuilder Builder(*this, RD, RD, /*Overriders=*/nullptr,\n                                     BaseSubobject(RD, CharUnits::Zero()),\n                                     /*BaseIsVirtual=*/false,\n                                     /*OffsetInLayoutClass=*/CharUnits::Zero());\n\n  for (const auto &I : Builder.getVBaseOffsetOffsets()) {\n    // Insert all types.\n    ClassPairTy ClassPair(RD, I.first);\n\n    VirtualBaseClassOffsetOffsets.insert(std::make_pair(ClassPair, I.second));\n  }\n\n  I = VirtualBaseClassOffsetOffsets.find(ClassPair);\n  assert(I != VirtualBaseClassOffsetOffsets.end() && \"Did not find index!\");\n\n  return I->second;\n}\n\nstatic std::unique_ptr<VTableLayout>\nCreateVTableLayout(const ItaniumVTableBuilder &Builder) {\n  SmallVector<VTableLayout::VTableThunkTy, 1>\n    VTableThunks(Builder.vtable_thunks_begin(), Builder.vtable_thunks_end());\n\n  return std::make_unique<VTableLayout>(\n      Builder.VTableIndices, Builder.vtable_components(), VTableThunks,\n      Builder.getAddressPoints());\n}\n\nvoid\nItaniumVTableContext::computeVTableRelatedInformation(const CXXRecordDecl *RD) {\n  std::unique_ptr<const VTableLayout> &Entry = VTableLayouts[RD];\n\n  // Check if we've computed this information before.\n  if (Entry)\n    return;\n\n  ItaniumVTableBuilder Builder(*this, RD, CharUnits::Zero(),\n                               /*MostDerivedClassIsVirtual=*/0, RD);\n  Entry = CreateVTableLayout(Builder);\n\n  MethodVTableIndices.insert(Builder.vtable_indices_begin(),\n                             Builder.vtable_indices_end());\n\n  // Add the known thunks.\n  Thunks.insert(Builder.thunks_begin(), Builder.thunks_end());\n\n  // If we don't have the vbase information for this class, insert it.\n  // getVirtualBaseOffsetOffset will compute it separately without computing\n  // the rest of the vtable related information.\n  if (!RD->getNumVBases())\n    return;\n\n  const CXXRecordDecl *VBase =\n    RD->vbases_begin()->getType()->getAsCXXRecordDecl();\n\n  if (VirtualBaseClassOffsetOffsets.count(std::make_pair(RD, VBase)))\n    return;\n\n  for (const auto &I : Builder.getVBaseOffsetOffsets()) {\n    // Insert all types.\n    ClassPairTy ClassPair(RD, I.first);\n\n    VirtualBaseClassOffsetOffsets.insert(std::make_pair(ClassPair, I.second));\n  }\n}\n\nstd::unique_ptr<VTableLayout>\nItaniumVTableContext::createConstructionVTableLayout(\n    const CXXRecordDecl *MostDerivedClass, CharUnits MostDerivedClassOffset,\n    bool MostDerivedClassIsVirtual, const CXXRecordDecl *LayoutClass) {\n  ItaniumVTableBuilder Builder(*this, MostDerivedClass, MostDerivedClassOffset,\n                               MostDerivedClassIsVirtual, LayoutClass);\n  return CreateVTableLayout(Builder);\n}\n\nnamespace {\n\n// Vtables in the Microsoft ABI are different from the Itanium ABI.\n//\n// The main differences are:\n//  1. Separate vftable and vbtable.\n//\n//  2. Each subobject with a vfptr gets its own vftable rather than an address\n//     point in a single vtable shared between all the subobjects.\n//     Each vftable is represented by a separate section and virtual calls\n//     must be done using the vftable which has a slot for the function to be\n//     called.\n//\n//  3. Virtual method definitions expect their 'this' parameter to point to the\n//     first vfptr whose table provides a compatible overridden method.  In many\n//     cases, this permits the original vf-table entry to directly call\n//     the method instead of passing through a thunk.\n//     See example before VFTableBuilder::ComputeThisOffset below.\n//\n//     A compatible overridden method is one which does not have a non-trivial\n//     covariant-return adjustment.\n//\n//     The first vfptr is the one with the lowest offset in the complete-object\n//     layout of the defining class, and the method definition will subtract\n//     that constant offset from the parameter value to get the real 'this'\n//     value.  Therefore, if the offset isn't really constant (e.g. if a virtual\n//     function defined in a virtual base is overridden in a more derived\n//     virtual base and these bases have a reverse order in the complete\n//     object), the vf-table may require a this-adjustment thunk.\n//\n//  4. vftables do not contain new entries for overrides that merely require\n//     this-adjustment.  Together with #3, this keeps vf-tables smaller and\n//     eliminates the need for this-adjustment thunks in many cases, at the cost\n//     of often requiring redundant work to adjust the \"this\" pointer.\n//\n//  5. Instead of VTT and constructor vtables, vbtables and vtordisps are used.\n//     Vtordisps are emitted into the class layout if a class has\n//      a) a user-defined ctor/dtor\n//     and\n//      b) a method overriding a method in a virtual base.\n//\n//  To get a better understanding of this code,\n//  you might want to see examples in test/CodeGenCXX/microsoft-abi-vtables-*.cpp\n\nclass VFTableBuilder {\npublic:\n  typedef llvm::DenseMap<GlobalDecl, MethodVFTableLocation>\n    MethodVFTableLocationsTy;\n\n  typedef llvm::iterator_range<MethodVFTableLocationsTy::const_iterator>\n    method_locations_range;\n\nprivate:\n  /// VTables - Global vtable information.\n  MicrosoftVTableContext &VTables;\n\n  /// Context - The ASTContext which we will use for layout information.\n  ASTContext &Context;\n\n  /// MostDerivedClass - The most derived class for which we're building this\n  /// vtable.\n  const CXXRecordDecl *MostDerivedClass;\n\n  const ASTRecordLayout &MostDerivedClassLayout;\n\n  const VPtrInfo &WhichVFPtr;\n\n  /// FinalOverriders - The final overriders of the most derived class.\n  const FinalOverriders Overriders;\n\n  /// Components - The components of the vftable being built.\n  SmallVector<VTableComponent, 64> Components;\n\n  MethodVFTableLocationsTy MethodVFTableLocations;\n\n  /// Does this class have an RTTI component?\n  bool HasRTTIComponent = false;\n\n  /// MethodInfo - Contains information about a method in a vtable.\n  /// (Used for computing 'this' pointer adjustment thunks.\n  struct MethodInfo {\n    /// VBTableIndex - The nonzero index in the vbtable that\n    /// this method's base has, or zero.\n    const uint64_t VBTableIndex;\n\n    /// VFTableIndex - The index in the vftable that this method has.\n    const uint64_t VFTableIndex;\n\n    /// Shadowed - Indicates if this vftable slot is shadowed by\n    /// a slot for a covariant-return override. If so, it shouldn't be printed\n    /// or used for vcalls in the most derived class.\n    bool Shadowed;\n\n    /// UsesExtraSlot - Indicates if this vftable slot was created because\n    /// any of the overridden slots required a return adjusting thunk.\n    bool UsesExtraSlot;\n\n    MethodInfo(uint64_t VBTableIndex, uint64_t VFTableIndex,\n               bool UsesExtraSlot = false)\n        : VBTableIndex(VBTableIndex), VFTableIndex(VFTableIndex),\n          Shadowed(false), UsesExtraSlot(UsesExtraSlot) {}\n\n    MethodInfo()\n        : VBTableIndex(0), VFTableIndex(0), Shadowed(false),\n          UsesExtraSlot(false) {}\n  };\n\n  typedef llvm::DenseMap<const CXXMethodDecl *, MethodInfo> MethodInfoMapTy;\n\n  /// MethodInfoMap - The information for all methods in the vftable we're\n  /// currently building.\n  MethodInfoMapTy MethodInfoMap;\n\n  typedef llvm::DenseMap<uint64_t, ThunkInfo> VTableThunksMapTy;\n\n  /// VTableThunks - The thunks by vftable index in the vftable currently being\n  /// built.\n  VTableThunksMapTy VTableThunks;\n\n  typedef SmallVector<ThunkInfo, 1> ThunkInfoVectorTy;\n  typedef llvm::DenseMap<const CXXMethodDecl *, ThunkInfoVectorTy> ThunksMapTy;\n\n  /// Thunks - A map that contains all the thunks needed for all methods in the\n  /// most derived class for which the vftable is currently being built.\n  ThunksMapTy Thunks;\n\n  /// AddThunk - Add a thunk for the given method.\n  void AddThunk(const CXXMethodDecl *MD, const ThunkInfo &Thunk) {\n    SmallVector<ThunkInfo, 1> &ThunksVector = Thunks[MD];\n\n    // Check if we have this thunk already.\n    if (llvm::find(ThunksVector, Thunk) != ThunksVector.end())\n      return;\n\n    ThunksVector.push_back(Thunk);\n  }\n\n  /// ComputeThisOffset - Returns the 'this' argument offset for the given\n  /// method, relative to the beginning of the MostDerivedClass.\n  CharUnits ComputeThisOffset(FinalOverriders::OverriderInfo Overrider);\n\n  void CalculateVtordispAdjustment(FinalOverriders::OverriderInfo Overrider,\n                                   CharUnits ThisOffset, ThisAdjustment &TA);\n\n  /// AddMethod - Add a single virtual member function to the vftable\n  /// components vector.\n  void AddMethod(const CXXMethodDecl *MD, ThunkInfo TI) {\n    if (!TI.isEmpty()) {\n      VTableThunks[Components.size()] = TI;\n      AddThunk(MD, TI);\n    }\n    if (const CXXDestructorDecl *DD = dyn_cast<CXXDestructorDecl>(MD)) {\n      assert(TI.Return.isEmpty() &&\n             \"Destructor can't have return adjustment!\");\n      Components.push_back(VTableComponent::MakeDeletingDtor(DD));\n    } else {\n      Components.push_back(VTableComponent::MakeFunction(MD));\n    }\n  }\n\n  /// AddMethods - Add the methods of this base subobject and the relevant\n  /// subbases to the vftable we're currently laying out.\n  void AddMethods(BaseSubobject Base, unsigned BaseDepth,\n                  const CXXRecordDecl *LastVBase,\n                  BasesSetVectorTy &VisitedBases);\n\n  void LayoutVFTable() {\n    // RTTI data goes before all other entries.\n    if (HasRTTIComponent)\n      Components.push_back(VTableComponent::MakeRTTI(MostDerivedClass));\n\n    BasesSetVectorTy VisitedBases;\n    AddMethods(BaseSubobject(MostDerivedClass, CharUnits::Zero()), 0, nullptr,\n               VisitedBases);\n    // Note that it is possible for the vftable to contain only an RTTI\n    // pointer, if all virtual functions are constewval.\n    assert(!Components.empty() && \"vftable can't be empty\");\n\n    assert(MethodVFTableLocations.empty());\n    for (const auto &I : MethodInfoMap) {\n      const CXXMethodDecl *MD = I.first;\n      const MethodInfo &MI = I.second;\n      assert(MD == MD->getCanonicalDecl());\n\n      // Skip the methods that the MostDerivedClass didn't override\n      // and the entries shadowed by return adjusting thunks.\n      if (MD->getParent() != MostDerivedClass || MI.Shadowed)\n        continue;\n      MethodVFTableLocation Loc(MI.VBTableIndex, WhichVFPtr.getVBaseWithVPtr(),\n                                WhichVFPtr.NonVirtualOffset, MI.VFTableIndex);\n      if (const CXXDestructorDecl *DD = dyn_cast<CXXDestructorDecl>(MD)) {\n        MethodVFTableLocations[GlobalDecl(DD, Dtor_Deleting)] = Loc;\n      } else {\n        MethodVFTableLocations[MD] = Loc;\n      }\n    }\n  }\n\npublic:\n  VFTableBuilder(MicrosoftVTableContext &VTables,\n                 const CXXRecordDecl *MostDerivedClass, const VPtrInfo &Which)\n      : VTables(VTables),\n        Context(MostDerivedClass->getASTContext()),\n        MostDerivedClass(MostDerivedClass),\n        MostDerivedClassLayout(Context.getASTRecordLayout(MostDerivedClass)),\n        WhichVFPtr(Which),\n        Overriders(MostDerivedClass, CharUnits(), MostDerivedClass) {\n    // Provide the RTTI component if RTTIData is enabled. If the vftable would\n    // be available externally, we should not provide the RTTI componenent. It\n    // is currently impossible to get available externally vftables with either\n    // dllimport or extern template instantiations, but eventually we may add a\n    // flag to support additional devirtualization that needs this.\n    if (Context.getLangOpts().RTTIData)\n      HasRTTIComponent = true;\n\n    LayoutVFTable();\n\n    if (Context.getLangOpts().DumpVTableLayouts)\n      dumpLayout(llvm::outs());\n  }\n\n  uint64_t getNumThunks() const { return Thunks.size(); }\n\n  ThunksMapTy::const_iterator thunks_begin() const { return Thunks.begin(); }\n\n  ThunksMapTy::const_iterator thunks_end() const { return Thunks.end(); }\n\n  method_locations_range vtable_locations() const {\n    return method_locations_range(MethodVFTableLocations.begin(),\n                                  MethodVFTableLocations.end());\n  }\n\n  ArrayRef<VTableComponent> vtable_components() const { return Components; }\n\n  VTableThunksMapTy::const_iterator vtable_thunks_begin() const {\n    return VTableThunks.begin();\n  }\n\n  VTableThunksMapTy::const_iterator vtable_thunks_end() const {\n    return VTableThunks.end();\n  }\n\n  void dumpLayout(raw_ostream &);\n};\n\n} // end namespace\n\n// Let's study one class hierarchy as an example:\n//   struct A {\n//     virtual void f();\n//     int x;\n//   };\n//\n//   struct B : virtual A {\n//     virtual void f();\n//   };\n//\n// Record layouts:\n//   struct A:\n//   0 |   (A vftable pointer)\n//   4 |   int x\n//\n//   struct B:\n//   0 |   (B vbtable pointer)\n//   4 |   struct A (virtual base)\n//   4 |     (A vftable pointer)\n//   8 |     int x\n//\n// Let's assume we have a pointer to the A part of an object of dynamic type B:\n//   B b;\n//   A *a = (A*)&b;\n//   a->f();\n//\n// In this hierarchy, f() belongs to the vftable of A, so B::f() expects\n// \"this\" parameter to point at the A subobject, which is B+4.\n// In the B::f() prologue, it adjusts \"this\" back to B by subtracting 4,\n// performed as a *static* adjustment.\n//\n// Interesting thing happens when we alter the relative placement of A and B\n// subobjects in a class:\n//   struct C : virtual B { };\n//\n//   C c;\n//   A *a = (A*)&c;\n//   a->f();\n//\n// Respective record layout is:\n//   0 |   (C vbtable pointer)\n//   4 |   struct A (virtual base)\n//   4 |     (A vftable pointer)\n//   8 |     int x\n//  12 |   struct B (virtual base)\n//  12 |     (B vbtable pointer)\n//\n// The final overrider of f() in class C is still B::f(), so B+4 should be\n// passed as \"this\" to that code.  However, \"a\" points at B-8, so the respective\n// vftable entry should hold a thunk that adds 12 to the \"this\" argument before\n// performing a tail call to B::f().\n//\n// With this example in mind, we can now calculate the 'this' argument offset\n// for the given method, relative to the beginning of the MostDerivedClass.\nCharUnits\nVFTableBuilder::ComputeThisOffset(FinalOverriders::OverriderInfo Overrider) {\n  BasesSetVectorTy Bases;\n\n  {\n    // Find the set of least derived bases that define the given method.\n    OverriddenMethodsSetTy VisitedOverriddenMethods;\n    auto InitialOverriddenDefinitionCollector = [&](\n        const CXXMethodDecl *OverriddenMD) {\n      if (OverriddenMD->size_overridden_methods() == 0)\n        Bases.insert(OverriddenMD->getParent());\n      // Don't recurse on this method if we've already collected it.\n      return VisitedOverriddenMethods.insert(OverriddenMD).second;\n    };\n    visitAllOverriddenMethods(Overrider.Method,\n                              InitialOverriddenDefinitionCollector);\n  }\n\n  // If there are no overrides then 'this' is located\n  // in the base that defines the method.\n  if (Bases.size() == 0)\n    return Overrider.Offset;\n\n  CXXBasePaths Paths;\n  Overrider.Method->getParent()->lookupInBases(\n      [&Bases](const CXXBaseSpecifier *Specifier, CXXBasePath &) {\n        return Bases.count(Specifier->getType()->getAsCXXRecordDecl());\n      },\n      Paths);\n\n  // This will hold the smallest this offset among overridees of MD.\n  // This implies that an offset of a non-virtual base will dominate an offset\n  // of a virtual base to potentially reduce the number of thunks required\n  // in the derived classes that inherit this method.\n  CharUnits Ret;\n  bool First = true;\n\n  const ASTRecordLayout &OverriderRDLayout =\n      Context.getASTRecordLayout(Overrider.Method->getParent());\n  for (const CXXBasePath &Path : Paths) {\n    CharUnits ThisOffset = Overrider.Offset;\n    CharUnits LastVBaseOffset;\n\n    // For each path from the overrider to the parents of the overridden\n    // methods, traverse the path, calculating the this offset in the most\n    // derived class.\n    for (const CXXBasePathElement &Element : Path) {\n      QualType CurTy = Element.Base->getType();\n      const CXXRecordDecl *PrevRD = Element.Class,\n                          *CurRD = CurTy->getAsCXXRecordDecl();\n      const ASTRecordLayout &Layout = Context.getASTRecordLayout(PrevRD);\n\n      if (Element.Base->isVirtual()) {\n        // The interesting things begin when you have virtual inheritance.\n        // The final overrider will use a static adjustment equal to the offset\n        // of the vbase in the final overrider class.\n        // For example, if the final overrider is in a vbase B of the most\n        // derived class and it overrides a method of the B's own vbase A,\n        // it uses A* as \"this\".  In its prologue, it can cast A* to B* with\n        // a static offset.  This offset is used regardless of the actual\n        // offset of A from B in the most derived class, requiring an\n        // this-adjusting thunk in the vftable if A and B are laid out\n        // differently in the most derived class.\n        LastVBaseOffset = ThisOffset =\n            Overrider.Offset + OverriderRDLayout.getVBaseClassOffset(CurRD);\n      } else {\n        ThisOffset += Layout.getBaseClassOffset(CurRD);\n      }\n    }\n\n    if (isa<CXXDestructorDecl>(Overrider.Method)) {\n      if (LastVBaseOffset.isZero()) {\n        // If a \"Base\" class has at least one non-virtual base with a virtual\n        // destructor, the \"Base\" virtual destructor will take the address\n        // of the \"Base\" subobject as the \"this\" argument.\n        ThisOffset = Overrider.Offset;\n      } else {\n        // A virtual destructor of a virtual base takes the address of the\n        // virtual base subobject as the \"this\" argument.\n        ThisOffset = LastVBaseOffset;\n      }\n    }\n\n    if (Ret > ThisOffset || First) {\n      First = false;\n      Ret = ThisOffset;\n    }\n  }\n\n  assert(!First && \"Method not found in the given subobject?\");\n  return Ret;\n}\n\n// Things are getting even more complex when the \"this\" adjustment has to\n// use a dynamic offset instead of a static one, or even two dynamic offsets.\n// This is sometimes required when a virtual call happens in the middle of\n// a non-most-derived class construction or destruction.\n//\n// Let's take a look at the following example:\n//   struct A {\n//     virtual void f();\n//   };\n//\n//   void foo(A *a) { a->f(); }  // Knows nothing about siblings of A.\n//\n//   struct B : virtual A {\n//     virtual void f();\n//     B() {\n//       foo(this);\n//     }\n//   };\n//\n//   struct C : virtual B {\n//     virtual void f();\n//   };\n//\n// Record layouts for these classes are:\n//   struct A\n//   0 |   (A vftable pointer)\n//\n//   struct B\n//   0 |   (B vbtable pointer)\n//   4 |   (vtordisp for vbase A)\n//   8 |   struct A (virtual base)\n//   8 |     (A vftable pointer)\n//\n//   struct C\n//   0 |   (C vbtable pointer)\n//   4 |   (vtordisp for vbase A)\n//   8 |   struct A (virtual base)  // A precedes B!\n//   8 |     (A vftable pointer)\n//  12 |   struct B (virtual base)\n//  12 |     (B vbtable pointer)\n//\n// When one creates an object of type C, the C constructor:\n// - initializes all the vbptrs, then\n// - calls the A subobject constructor\n//   (initializes A's vfptr with an address of A vftable), then\n// - calls the B subobject constructor\n//   (initializes A's vfptr with an address of B vftable and vtordisp for A),\n//   that in turn calls foo(), then\n// - initializes A's vfptr with an address of C vftable and zeroes out the\n//   vtordisp\n//   FIXME: if a structor knows it belongs to MDC, why doesn't it use a vftable\n//   without vtordisp thunks?\n//   FIXME: how are vtordisp handled in the presence of nooverride/final?\n//\n// When foo() is called, an object with a layout of class C has a vftable\n// referencing B::f() that assumes a B layout, so the \"this\" adjustments are\n// incorrect, unless an extra adjustment is done.  This adjustment is called\n// \"vtordisp adjustment\".  Vtordisp basically holds the difference between the\n// actual location of a vbase in the layout class and the location assumed by\n// the vftable of the class being constructed/destructed.  Vtordisp is only\n// needed if \"this\" escapes a\n// structor (or we can't prove otherwise).\n// [i.e. vtordisp is a dynamic adjustment for a static adjustment, which is an\n// estimation of a dynamic adjustment]\n//\n// foo() gets a pointer to the A vbase and doesn't know anything about B or C,\n// so it just passes that pointer as \"this\" in a virtual call.\n// If there was no vtordisp, that would just dispatch to B::f().\n// However, B::f() assumes B+8 is passed as \"this\",\n// yet the pointer foo() passes along is B-4 (i.e. C+8).\n// An extra adjustment is needed, so we emit a thunk into the B vftable.\n// This vtordisp thunk subtracts the value of vtordisp\n// from the \"this\" argument (-12) before making a tailcall to B::f().\n//\n// Let's consider an even more complex example:\n//   struct D : virtual B, virtual C {\n//     D() {\n//       foo(this);\n//     }\n//   };\n//\n//   struct D\n//   0 |   (D vbtable pointer)\n//   4 |   (vtordisp for vbase A)\n//   8 |   struct A (virtual base)  // A precedes both B and C!\n//   8 |     (A vftable pointer)\n//  12 |   struct B (virtual base)  // B precedes C!\n//  12 |     (B vbtable pointer)\n//  16 |   struct C (virtual base)\n//  16 |     (C vbtable pointer)\n//\n// When D::D() calls foo(), we find ourselves in a thunk that should tailcall\n// to C::f(), which assumes C+8 as its \"this\" parameter.  This time, foo()\n// passes along A, which is C-8.  The A vtordisp holds\n//   \"D.vbptr[index_of_A] - offset_of_A_in_D\"\n// and we statically know offset_of_A_in_D, so can get a pointer to D.\n// When we know it, we can make an extra vbtable lookup to locate the C vbase\n// and one extra static adjustment to calculate the expected value of C+8.\nvoid VFTableBuilder::CalculateVtordispAdjustment(\n    FinalOverriders::OverriderInfo Overrider, CharUnits ThisOffset,\n    ThisAdjustment &TA) {\n  const ASTRecordLayout::VBaseOffsetsMapTy &VBaseMap =\n      MostDerivedClassLayout.getVBaseOffsetsMap();\n  const ASTRecordLayout::VBaseOffsetsMapTy::const_iterator &VBaseMapEntry =\n      VBaseMap.find(WhichVFPtr.getVBaseWithVPtr());\n  assert(VBaseMapEntry != VBaseMap.end());\n\n  // If there's no vtordisp or the final overrider is defined in the same vbase\n  // as the initial declaration, we don't need any vtordisp adjustment.\n  if (!VBaseMapEntry->second.hasVtorDisp() ||\n      Overrider.VirtualBase == WhichVFPtr.getVBaseWithVPtr())\n    return;\n\n  // OK, now we know we need to use a vtordisp thunk.\n  // The implicit vtordisp field is located right before the vbase.\n  CharUnits OffsetOfVBaseWithVFPtr = VBaseMapEntry->second.VBaseOffset;\n  TA.Virtual.Microsoft.VtordispOffset =\n      (OffsetOfVBaseWithVFPtr - WhichVFPtr.FullOffsetInMDC).getQuantity() - 4;\n\n  // A simple vtordisp thunk will suffice if the final overrider is defined\n  // in either the most derived class or its non-virtual base.\n  if (Overrider.Method->getParent() == MostDerivedClass ||\n      !Overrider.VirtualBase)\n    return;\n\n  // Otherwise, we need to do use the dynamic offset of the final overrider\n  // in order to get \"this\" adjustment right.\n  TA.Virtual.Microsoft.VBPtrOffset =\n      (OffsetOfVBaseWithVFPtr + WhichVFPtr.NonVirtualOffset -\n       MostDerivedClassLayout.getVBPtrOffset()).getQuantity();\n  TA.Virtual.Microsoft.VBOffsetOffset =\n      Context.getTypeSizeInChars(Context.IntTy).getQuantity() *\n      VTables.getVBTableIndex(MostDerivedClass, Overrider.VirtualBase);\n\n  TA.NonVirtual = (ThisOffset - Overrider.Offset).getQuantity();\n}\n\nstatic void GroupNewVirtualOverloads(\n    const CXXRecordDecl *RD,\n    SmallVector<const CXXMethodDecl *, 10> &VirtualMethods) {\n  // Put the virtual methods into VirtualMethods in the proper order:\n  // 1) Group overloads by declaration name. New groups are added to the\n  //    vftable in the order of their first declarations in this class\n  //    (including overrides, non-virtual methods and any other named decl that\n  //    might be nested within the class).\n  // 2) In each group, new overloads appear in the reverse order of declaration.\n  typedef SmallVector<const CXXMethodDecl *, 1> MethodGroup;\n  SmallVector<MethodGroup, 10> Groups;\n  typedef llvm::DenseMap<DeclarationName, unsigned> VisitedGroupIndicesTy;\n  VisitedGroupIndicesTy VisitedGroupIndices;\n  for (const auto *D : RD->decls()) {\n    const auto *ND = dyn_cast<NamedDecl>(D);\n    if (!ND)\n      continue;\n    VisitedGroupIndicesTy::iterator J;\n    bool Inserted;\n    std::tie(J, Inserted) = VisitedGroupIndices.insert(\n        std::make_pair(ND->getDeclName(), Groups.size()));\n    if (Inserted)\n      Groups.push_back(MethodGroup());\n    if (const auto *MD = dyn_cast<CXXMethodDecl>(ND))\n      if (MicrosoftVTableContext::hasVtableSlot(MD))\n        Groups[J->second].push_back(MD->getCanonicalDecl());\n  }\n\n  for (const MethodGroup &Group : Groups)\n    VirtualMethods.append(Group.rbegin(), Group.rend());\n}\n\nstatic bool isDirectVBase(const CXXRecordDecl *Base, const CXXRecordDecl *RD) {\n  for (const auto &B : RD->bases()) {\n    if (B.isVirtual() && B.getType()->getAsCXXRecordDecl() == Base)\n      return true;\n  }\n  return false;\n}\n\nvoid VFTableBuilder::AddMethods(BaseSubobject Base, unsigned BaseDepth,\n                                const CXXRecordDecl *LastVBase,\n                                BasesSetVectorTy &VisitedBases) {\n  const CXXRecordDecl *RD = Base.getBase();\n  if (!RD->isPolymorphic())\n    return;\n\n  const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n\n  // See if this class expands a vftable of the base we look at, which is either\n  // the one defined by the vfptr base path or the primary base of the current\n  // class.\n  const CXXRecordDecl *NextBase = nullptr, *NextLastVBase = LastVBase;\n  CharUnits NextBaseOffset;\n  if (BaseDepth < WhichVFPtr.PathToIntroducingObject.size()) {\n    NextBase = WhichVFPtr.PathToIntroducingObject[BaseDepth];\n    if (isDirectVBase(NextBase, RD)) {\n      NextLastVBase = NextBase;\n      NextBaseOffset = MostDerivedClassLayout.getVBaseClassOffset(NextBase);\n    } else {\n      NextBaseOffset =\n          Base.getBaseOffset() + Layout.getBaseClassOffset(NextBase);\n    }\n  } else if (const CXXRecordDecl *PrimaryBase = Layout.getPrimaryBase()) {\n    assert(!Layout.isPrimaryBaseVirtual() &&\n           \"No primary virtual bases in this ABI\");\n    NextBase = PrimaryBase;\n    NextBaseOffset = Base.getBaseOffset();\n  }\n\n  if (NextBase) {\n    AddMethods(BaseSubobject(NextBase, NextBaseOffset), BaseDepth + 1,\n               NextLastVBase, VisitedBases);\n    if (!VisitedBases.insert(NextBase))\n      llvm_unreachable(\"Found a duplicate primary base!\");\n  }\n\n  SmallVector<const CXXMethodDecl*, 10> VirtualMethods;\n  // Put virtual methods in the proper order.\n  GroupNewVirtualOverloads(RD, VirtualMethods);\n\n  // Now go through all virtual member functions and add them to the current\n  // vftable. This is done by\n  //  - replacing overridden methods in their existing slots, as long as they\n  //    don't require return adjustment; calculating This adjustment if needed.\n  //  - adding new slots for methods of the current base not present in any\n  //    sub-bases;\n  //  - adding new slots for methods that require Return adjustment.\n  // We keep track of the methods visited in the sub-bases in MethodInfoMap.\n  for (const CXXMethodDecl *MD : VirtualMethods) {\n    FinalOverriders::OverriderInfo FinalOverrider =\n        Overriders.getOverrider(MD, Base.getBaseOffset());\n    const CXXMethodDecl *FinalOverriderMD = FinalOverrider.Method;\n    const CXXMethodDecl *OverriddenMD =\n        FindNearestOverriddenMethod(MD, VisitedBases);\n\n    ThisAdjustment ThisAdjustmentOffset;\n    bool ReturnAdjustingThunk = false, ForceReturnAdjustmentMangling = false;\n    CharUnits ThisOffset = ComputeThisOffset(FinalOverrider);\n    ThisAdjustmentOffset.NonVirtual =\n        (ThisOffset - WhichVFPtr.FullOffsetInMDC).getQuantity();\n    if ((OverriddenMD || FinalOverriderMD != MD) &&\n        WhichVFPtr.getVBaseWithVPtr())\n      CalculateVtordispAdjustment(FinalOverrider, ThisOffset,\n                                  ThisAdjustmentOffset);\n\n    unsigned VBIndex =\n        LastVBase ? VTables.getVBTableIndex(MostDerivedClass, LastVBase) : 0;\n\n    if (OverriddenMD) {\n      // If MD overrides anything in this vftable, we need to update the\n      // entries.\n      MethodInfoMapTy::iterator OverriddenMDIterator =\n          MethodInfoMap.find(OverriddenMD);\n\n      // If the overridden method went to a different vftable, skip it.\n      if (OverriddenMDIterator == MethodInfoMap.end())\n        continue;\n\n      MethodInfo &OverriddenMethodInfo = OverriddenMDIterator->second;\n\n      VBIndex = OverriddenMethodInfo.VBTableIndex;\n\n      // Let's check if the overrider requires any return adjustments.\n      // We must create a new slot if the MD's return type is not trivially\n      // convertible to the OverriddenMD's one.\n      // Once a chain of method overrides adds a return adjusting vftable slot,\n      // all subsequent overrides will also use an extra method slot.\n      ReturnAdjustingThunk = !ComputeReturnAdjustmentBaseOffset(\n                                  Context, MD, OverriddenMD).isEmpty() ||\n                             OverriddenMethodInfo.UsesExtraSlot;\n\n      if (!ReturnAdjustingThunk) {\n        // No return adjustment needed - just replace the overridden method info\n        // with the current info.\n        MethodInfo MI(VBIndex, OverriddenMethodInfo.VFTableIndex);\n        MethodInfoMap.erase(OverriddenMDIterator);\n\n        assert(!MethodInfoMap.count(MD) &&\n               \"Should not have method info for this method yet!\");\n        MethodInfoMap.insert(std::make_pair(MD, MI));\n        continue;\n      }\n\n      // In case we need a return adjustment, we'll add a new slot for\n      // the overrider. Mark the overridden method as shadowed by the new slot.\n      OverriddenMethodInfo.Shadowed = true;\n\n      // Force a special name mangling for a return-adjusting thunk\n      // unless the method is the final overrider without this adjustment.\n      ForceReturnAdjustmentMangling =\n          !(MD == FinalOverriderMD && ThisAdjustmentOffset.isEmpty());\n    } else if (Base.getBaseOffset() != WhichVFPtr.FullOffsetInMDC ||\n               MD->size_overridden_methods()) {\n      // Skip methods that don't belong to the vftable of the current class,\n      // e.g. each method that wasn't seen in any of the visited sub-bases\n      // but overrides multiple methods of other sub-bases.\n      continue;\n    }\n\n    // If we got here, MD is a method not seen in any of the sub-bases or\n    // it requires return adjustment. Insert the method info for this method.\n    MethodInfo MI(VBIndex,\n                  HasRTTIComponent ? Components.size() - 1 : Components.size(),\n                  ReturnAdjustingThunk);\n\n    assert(!MethodInfoMap.count(MD) &&\n           \"Should not have method info for this method yet!\");\n    MethodInfoMap.insert(std::make_pair(MD, MI));\n\n    // Check if this overrider needs a return adjustment.\n    // We don't want to do this for pure virtual member functions.\n    BaseOffset ReturnAdjustmentOffset;\n    ReturnAdjustment ReturnAdjustment;\n    if (!FinalOverriderMD->isPure()) {\n      ReturnAdjustmentOffset =\n          ComputeReturnAdjustmentBaseOffset(Context, FinalOverriderMD, MD);\n    }\n    if (!ReturnAdjustmentOffset.isEmpty()) {\n      ForceReturnAdjustmentMangling = true;\n      ReturnAdjustment.NonVirtual =\n          ReturnAdjustmentOffset.NonVirtualOffset.getQuantity();\n      if (ReturnAdjustmentOffset.VirtualBase) {\n        const ASTRecordLayout &DerivedLayout =\n            Context.getASTRecordLayout(ReturnAdjustmentOffset.DerivedClass);\n        ReturnAdjustment.Virtual.Microsoft.VBPtrOffset =\n            DerivedLayout.getVBPtrOffset().getQuantity();\n        ReturnAdjustment.Virtual.Microsoft.VBIndex =\n            VTables.getVBTableIndex(ReturnAdjustmentOffset.DerivedClass,\n                                    ReturnAdjustmentOffset.VirtualBase);\n      }\n    }\n\n    AddMethod(FinalOverriderMD,\n              ThunkInfo(ThisAdjustmentOffset, ReturnAdjustment,\n                        ForceReturnAdjustmentMangling ? MD : nullptr));\n  }\n}\n\nstatic void PrintBasePath(const VPtrInfo::BasePath &Path, raw_ostream &Out) {\n  for (const CXXRecordDecl *Elem :\n       llvm::make_range(Path.rbegin(), Path.rend())) {\n    Out << \"'\";\n    Elem->printQualifiedName(Out);\n    Out << \"' in \";\n  }\n}\n\nstatic void dumpMicrosoftThunkAdjustment(const ThunkInfo &TI, raw_ostream &Out,\n                                         bool ContinueFirstLine) {\n  const ReturnAdjustment &R = TI.Return;\n  bool Multiline = false;\n  const char *LinePrefix = \"\\n       \";\n  if (!R.isEmpty() || TI.Method) {\n    if (!ContinueFirstLine)\n      Out << LinePrefix;\n    Out << \"[return adjustment (to type '\"\n        << TI.Method->getReturnType().getCanonicalType().getAsString()\n        << \"'): \";\n    if (R.Virtual.Microsoft.VBPtrOffset)\n      Out << \"vbptr at offset \" << R.Virtual.Microsoft.VBPtrOffset << \", \";\n    if (R.Virtual.Microsoft.VBIndex)\n      Out << \"vbase #\" << R.Virtual.Microsoft.VBIndex << \", \";\n    Out << R.NonVirtual << \" non-virtual]\";\n    Multiline = true;\n  }\n\n  const ThisAdjustment &T = TI.This;\n  if (!T.isEmpty()) {\n    if (Multiline || !ContinueFirstLine)\n      Out << LinePrefix;\n    Out << \"[this adjustment: \";\n    if (!TI.This.Virtual.isEmpty()) {\n      assert(T.Virtual.Microsoft.VtordispOffset < 0);\n      Out << \"vtordisp at \" << T.Virtual.Microsoft.VtordispOffset << \", \";\n      if (T.Virtual.Microsoft.VBPtrOffset) {\n        Out << \"vbptr at \" << T.Virtual.Microsoft.VBPtrOffset\n            << \" to the left,\";\n        assert(T.Virtual.Microsoft.VBOffsetOffset > 0);\n        Out << LinePrefix << \" vboffset at \"\n            << T.Virtual.Microsoft.VBOffsetOffset << \" in the vbtable, \";\n      }\n    }\n    Out << T.NonVirtual << \" non-virtual]\";\n  }\n}\n\nvoid VFTableBuilder::dumpLayout(raw_ostream &Out) {\n  Out << \"VFTable for \";\n  PrintBasePath(WhichVFPtr.PathToIntroducingObject, Out);\n  Out << \"'\";\n  MostDerivedClass->printQualifiedName(Out);\n  Out << \"' (\" << Components.size()\n      << (Components.size() == 1 ? \" entry\" : \" entries\") << \").\\n\";\n\n  for (unsigned I = 0, E = Components.size(); I != E; ++I) {\n    Out << llvm::format(\"%4d | \", I);\n\n    const VTableComponent &Component = Components[I];\n\n    // Dump the component.\n    switch (Component.getKind()) {\n    case VTableComponent::CK_RTTI:\n      Component.getRTTIDecl()->printQualifiedName(Out);\n      Out << \" RTTI\";\n      break;\n\n    case VTableComponent::CK_FunctionPointer: {\n      const CXXMethodDecl *MD = Component.getFunctionDecl();\n\n      // FIXME: Figure out how to print the real thunk type, since they can\n      // differ in the return type.\n      std::string Str = PredefinedExpr::ComputeName(\n          PredefinedExpr::PrettyFunctionNoVirtual, MD);\n      Out << Str;\n      if (MD->isPure())\n        Out << \" [pure]\";\n\n      if (MD->isDeleted())\n        Out << \" [deleted]\";\n\n      ThunkInfo Thunk = VTableThunks.lookup(I);\n      if (!Thunk.isEmpty())\n        dumpMicrosoftThunkAdjustment(Thunk, Out, /*ContinueFirstLine=*/false);\n\n      break;\n    }\n\n    case VTableComponent::CK_DeletingDtorPointer: {\n      const CXXDestructorDecl *DD = Component.getDestructorDecl();\n\n      DD->printQualifiedName(Out);\n      Out << \"() [scalar deleting]\";\n\n      if (DD->isPure())\n        Out << \" [pure]\";\n\n      ThunkInfo Thunk = VTableThunks.lookup(I);\n      if (!Thunk.isEmpty()) {\n        assert(Thunk.Return.isEmpty() &&\n               \"No return adjustment needed for destructors!\");\n        dumpMicrosoftThunkAdjustment(Thunk, Out, /*ContinueFirstLine=*/false);\n      }\n\n      break;\n    }\n\n    default:\n      DiagnosticsEngine &Diags = Context.getDiagnostics();\n      unsigned DiagID = Diags.getCustomDiagID(\n          DiagnosticsEngine::Error,\n          \"Unexpected vftable component type %0 for component number %1\");\n      Diags.Report(MostDerivedClass->getLocation(), DiagID)\n          << I << Component.getKind();\n    }\n\n    Out << '\\n';\n  }\n\n  Out << '\\n';\n\n  if (!Thunks.empty()) {\n    // We store the method names in a map to get a stable order.\n    std::map<std::string, const CXXMethodDecl *> MethodNamesAndDecls;\n\n    for (const auto &I : Thunks) {\n      const CXXMethodDecl *MD = I.first;\n      std::string MethodName = PredefinedExpr::ComputeName(\n          PredefinedExpr::PrettyFunctionNoVirtual, MD);\n\n      MethodNamesAndDecls.insert(std::make_pair(MethodName, MD));\n    }\n\n    for (const auto &MethodNameAndDecl : MethodNamesAndDecls) {\n      const std::string &MethodName = MethodNameAndDecl.first;\n      const CXXMethodDecl *MD = MethodNameAndDecl.second;\n\n      ThunkInfoVectorTy ThunksVector = Thunks[MD];\n      llvm::stable_sort(ThunksVector, [](const ThunkInfo &LHS,\n                                         const ThunkInfo &RHS) {\n        // Keep different thunks with the same adjustments in the order they\n        // were put into the vector.\n        return std::tie(LHS.This, LHS.Return) < std::tie(RHS.This, RHS.Return);\n      });\n\n      Out << \"Thunks for '\" << MethodName << \"' (\" << ThunksVector.size();\n      Out << (ThunksVector.size() == 1 ? \" entry\" : \" entries\") << \").\\n\";\n\n      for (unsigned I = 0, E = ThunksVector.size(); I != E; ++I) {\n        const ThunkInfo &Thunk = ThunksVector[I];\n\n        Out << llvm::format(\"%4d | \", I);\n        dumpMicrosoftThunkAdjustment(Thunk, Out, /*ContinueFirstLine=*/true);\n        Out << '\\n';\n      }\n\n      Out << '\\n';\n    }\n  }\n\n  Out.flush();\n}\n\nstatic bool setsIntersect(const llvm::SmallPtrSet<const CXXRecordDecl *, 4> &A,\n                          ArrayRef<const CXXRecordDecl *> B) {\n  for (const CXXRecordDecl *Decl : B) {\n    if (A.count(Decl))\n      return true;\n  }\n  return false;\n}\n\nstatic bool rebucketPaths(VPtrInfoVector &Paths);\n\n/// Produces MSVC-compatible vbtable data.  The symbols produced by this\n/// algorithm match those produced by MSVC 2012 and newer, which is different\n/// from MSVC 2010.\n///\n/// MSVC 2012 appears to minimize the vbtable names using the following\n/// algorithm.  First, walk the class hierarchy in the usual order, depth first,\n/// left to right, to find all of the subobjects which contain a vbptr field.\n/// Visiting each class node yields a list of inheritance paths to vbptrs.  Each\n/// record with a vbptr creates an initially empty path.\n///\n/// To combine paths from child nodes, the paths are compared to check for\n/// ambiguity.  Paths are \"ambiguous\" if multiple paths have the same set of\n/// components in the same order.  Each group of ambiguous paths is extended by\n/// appending the class of the base from which it came.  If the current class\n/// node produced an ambiguous path, its path is extended with the current class.\n/// After extending paths, MSVC again checks for ambiguity, and extends any\n/// ambiguous path which wasn't already extended.  Because each node yields an\n/// unambiguous set of paths, MSVC doesn't need to extend any path more than once\n/// to produce an unambiguous set of paths.\n///\n/// TODO: Presumably vftables use the same algorithm.\nvoid MicrosoftVTableContext::computeVTablePaths(bool ForVBTables,\n                                                const CXXRecordDecl *RD,\n                                                VPtrInfoVector &Paths) {\n  assert(Paths.empty());\n  const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n\n  // Base case: this subobject has its own vptr.\n  if (ForVBTables ? Layout.hasOwnVBPtr() : Layout.hasOwnVFPtr())\n    Paths.push_back(std::make_unique<VPtrInfo>(RD));\n\n  // Recursive case: get all the vbtables from our bases and remove anything\n  // that shares a virtual base.\n  llvm::SmallPtrSet<const CXXRecordDecl*, 4> VBasesSeen;\n  for (const auto &B : RD->bases()) {\n    const CXXRecordDecl *Base = B.getType()->getAsCXXRecordDecl();\n    if (B.isVirtual() && VBasesSeen.count(Base))\n      continue;\n\n    if (!Base->isDynamicClass())\n      continue;\n\n    const VPtrInfoVector &BasePaths =\n        ForVBTables ? enumerateVBTables(Base) : getVFPtrOffsets(Base);\n\n    for (const std::unique_ptr<VPtrInfo> &BaseInfo : BasePaths) {\n      // Don't include the path if it goes through a virtual base that we've\n      // already included.\n      if (setsIntersect(VBasesSeen, BaseInfo->ContainingVBases))\n        continue;\n\n      // Copy the path and adjust it as necessary.\n      auto P = std::make_unique<VPtrInfo>(*BaseInfo);\n\n      // We mangle Base into the path if the path would've been ambiguous and it\n      // wasn't already extended with Base.\n      if (P->MangledPath.empty() || P->MangledPath.back() != Base)\n        P->NextBaseToMangle = Base;\n\n      // Keep track of which vtable the derived class is going to extend with\n      // new methods or bases.  We append to either the vftable of our primary\n      // base, or the first non-virtual base that has a vbtable.\n      if (P->ObjectWithVPtr == Base &&\n          Base == (ForVBTables ? Layout.getBaseSharingVBPtr()\n                               : Layout.getPrimaryBase()))\n        P->ObjectWithVPtr = RD;\n\n      // Keep track of the full adjustment from the MDC to this vtable.  The\n      // adjustment is captured by an optional vbase and a non-virtual offset.\n      if (B.isVirtual())\n        P->ContainingVBases.push_back(Base);\n      else if (P->ContainingVBases.empty())\n        P->NonVirtualOffset += Layout.getBaseClassOffset(Base);\n\n      // Update the full offset in the MDC.\n      P->FullOffsetInMDC = P->NonVirtualOffset;\n      if (const CXXRecordDecl *VB = P->getVBaseWithVPtr())\n        P->FullOffsetInMDC += Layout.getVBaseClassOffset(VB);\n\n      Paths.push_back(std::move(P));\n    }\n\n    if (B.isVirtual())\n      VBasesSeen.insert(Base);\n\n    // After visiting any direct base, we've transitively visited all of its\n    // morally virtual bases.\n    for (const auto &VB : Base->vbases())\n      VBasesSeen.insert(VB.getType()->getAsCXXRecordDecl());\n  }\n\n  // Sort the paths into buckets, and if any of them are ambiguous, extend all\n  // paths in ambiguous buckets.\n  bool Changed = true;\n  while (Changed)\n    Changed = rebucketPaths(Paths);\n}\n\nstatic bool extendPath(VPtrInfo &P) {\n  if (P.NextBaseToMangle) {\n    P.MangledPath.push_back(P.NextBaseToMangle);\n    P.NextBaseToMangle = nullptr;// Prevent the path from being extended twice.\n    return true;\n  }\n  return false;\n}\n\nstatic bool rebucketPaths(VPtrInfoVector &Paths) {\n  // What we're essentially doing here is bucketing together ambiguous paths.\n  // Any bucket with more than one path in it gets extended by NextBase, which\n  // is usually the direct base of the inherited the vbptr.  This code uses a\n  // sorted vector to implement a multiset to form the buckets.  Note that the\n  // ordering is based on pointers, but it doesn't change our output order.  The\n  // current algorithm is designed to match MSVC 2012's names.\n  llvm::SmallVector<std::reference_wrapper<VPtrInfo>, 2> PathsSorted;\n  PathsSorted.reserve(Paths.size());\n  for (auto& P : Paths)\n    PathsSorted.push_back(*P);\n  llvm::sort(PathsSorted, [](const VPtrInfo &LHS, const VPtrInfo &RHS) {\n    return LHS.MangledPath < RHS.MangledPath;\n  });\n  bool Changed = false;\n  for (size_t I = 0, E = PathsSorted.size(); I != E;) {\n    // Scan forward to find the end of the bucket.\n    size_t BucketStart = I;\n    do {\n      ++I;\n    } while (I != E &&\n             PathsSorted[BucketStart].get().MangledPath ==\n                 PathsSorted[I].get().MangledPath);\n\n    // If this bucket has multiple paths, extend them all.\n    if (I - BucketStart > 1) {\n      for (size_t II = BucketStart; II != I; ++II)\n        Changed |= extendPath(PathsSorted[II]);\n      assert(Changed && \"no paths were extended to fix ambiguity\");\n    }\n  }\n  return Changed;\n}\n\nMicrosoftVTableContext::~MicrosoftVTableContext() {}\n\nnamespace {\ntypedef llvm::SetVector<BaseSubobject, std::vector<BaseSubobject>,\n                        llvm::DenseSet<BaseSubobject>> FullPathTy;\n}\n\n// This recursive function finds all paths from a subobject centered at\n// (RD, Offset) to the subobject located at IntroducingObject.\nstatic void findPathsToSubobject(ASTContext &Context,\n                                 const ASTRecordLayout &MostDerivedLayout,\n                                 const CXXRecordDecl *RD, CharUnits Offset,\n                                 BaseSubobject IntroducingObject,\n                                 FullPathTy &FullPath,\n                                 std::list<FullPathTy> &Paths) {\n  if (BaseSubobject(RD, Offset) == IntroducingObject) {\n    Paths.push_back(FullPath);\n    return;\n  }\n\n  const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n\n  for (const CXXBaseSpecifier &BS : RD->bases()) {\n    const CXXRecordDecl *Base = BS.getType()->getAsCXXRecordDecl();\n    CharUnits NewOffset = BS.isVirtual()\n                              ? MostDerivedLayout.getVBaseClassOffset(Base)\n                              : Offset + Layout.getBaseClassOffset(Base);\n    FullPath.insert(BaseSubobject(Base, NewOffset));\n    findPathsToSubobject(Context, MostDerivedLayout, Base, NewOffset,\n                         IntroducingObject, FullPath, Paths);\n    FullPath.pop_back();\n  }\n}\n\n// Return the paths which are not subsets of other paths.\nstatic void removeRedundantPaths(std::list<FullPathTy> &FullPaths) {\n  FullPaths.remove_if([&](const FullPathTy &SpecificPath) {\n    for (const FullPathTy &OtherPath : FullPaths) {\n      if (&SpecificPath == &OtherPath)\n        continue;\n      if (llvm::all_of(SpecificPath, [&](const BaseSubobject &BSO) {\n            return OtherPath.count(BSO) != 0;\n          })) {\n        return true;\n      }\n    }\n    return false;\n  });\n}\n\nstatic CharUnits getOffsetOfFullPath(ASTContext &Context,\n                                     const CXXRecordDecl *RD,\n                                     const FullPathTy &FullPath) {\n  const ASTRecordLayout &MostDerivedLayout =\n      Context.getASTRecordLayout(RD);\n  CharUnits Offset = CharUnits::fromQuantity(-1);\n  for (const BaseSubobject &BSO : FullPath) {\n    const CXXRecordDecl *Base = BSO.getBase();\n    // The first entry in the path is always the most derived record, skip it.\n    if (Base == RD) {\n      assert(Offset.getQuantity() == -1);\n      Offset = CharUnits::Zero();\n      continue;\n    }\n    assert(Offset.getQuantity() != -1);\n    const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n    // While we know which base has to be traversed, we don't know if that base\n    // was a virtual base.\n    const CXXBaseSpecifier *BaseBS = std::find_if(\n        RD->bases_begin(), RD->bases_end(), [&](const CXXBaseSpecifier &BS) {\n          return BS.getType()->getAsCXXRecordDecl() == Base;\n        });\n    Offset = BaseBS->isVirtual() ? MostDerivedLayout.getVBaseClassOffset(Base)\n                                 : Offset + Layout.getBaseClassOffset(Base);\n    RD = Base;\n  }\n  return Offset;\n}\n\n// We want to select the path which introduces the most covariant overrides.  If\n// two paths introduce overrides which the other path doesn't contain, issue a\n// diagnostic.\nstatic const FullPathTy *selectBestPath(ASTContext &Context,\n                                        const CXXRecordDecl *RD,\n                                        const VPtrInfo &Info,\n                                        std::list<FullPathTy> &FullPaths) {\n  // Handle some easy cases first.\n  if (FullPaths.empty())\n    return nullptr;\n  if (FullPaths.size() == 1)\n    return &FullPaths.front();\n\n  const FullPathTy *BestPath = nullptr;\n  typedef std::set<const CXXMethodDecl *> OverriderSetTy;\n  OverriderSetTy LastOverrides;\n  for (const FullPathTy &SpecificPath : FullPaths) {\n    assert(!SpecificPath.empty());\n    OverriderSetTy CurrentOverrides;\n    const CXXRecordDecl *TopLevelRD = SpecificPath.begin()->getBase();\n    // Find the distance from the start of the path to the subobject with the\n    // VPtr.\n    CharUnits BaseOffset =\n        getOffsetOfFullPath(Context, TopLevelRD, SpecificPath);\n    FinalOverriders Overriders(TopLevelRD, CharUnits::Zero(), TopLevelRD);\n    for (const CXXMethodDecl *MD : Info.IntroducingObject->methods()) {\n      if (!MicrosoftVTableContext::hasVtableSlot(MD))\n        continue;\n      FinalOverriders::OverriderInfo OI =\n          Overriders.getOverrider(MD->getCanonicalDecl(), BaseOffset);\n      const CXXMethodDecl *OverridingMethod = OI.Method;\n      // Only overriders which have a return adjustment introduce problematic\n      // thunks.\n      if (ComputeReturnAdjustmentBaseOffset(Context, OverridingMethod, MD)\n              .isEmpty())\n        continue;\n      // It's possible that the overrider isn't in this path.  If so, skip it\n      // because this path didn't introduce it.\n      const CXXRecordDecl *OverridingParent = OverridingMethod->getParent();\n      if (llvm::none_of(SpecificPath, [&](const BaseSubobject &BSO) {\n            return BSO.getBase() == OverridingParent;\n          }))\n        continue;\n      CurrentOverrides.insert(OverridingMethod);\n    }\n    OverriderSetTy NewOverrides =\n        llvm::set_difference(CurrentOverrides, LastOverrides);\n    if (NewOverrides.empty())\n      continue;\n    OverriderSetTy MissingOverrides =\n        llvm::set_difference(LastOverrides, CurrentOverrides);\n    if (MissingOverrides.empty()) {\n      // This path is a strict improvement over the last path, let's use it.\n      BestPath = &SpecificPath;\n      std::swap(CurrentOverrides, LastOverrides);\n    } else {\n      // This path introduces an overrider with a conflicting covariant thunk.\n      DiagnosticsEngine &Diags = Context.getDiagnostics();\n      const CXXMethodDecl *CovariantMD = *NewOverrides.begin();\n      const CXXMethodDecl *ConflictMD = *MissingOverrides.begin();\n      Diags.Report(RD->getLocation(), diag::err_vftable_ambiguous_component)\n          << RD;\n      Diags.Report(CovariantMD->getLocation(), diag::note_covariant_thunk)\n          << CovariantMD;\n      Diags.Report(ConflictMD->getLocation(), diag::note_covariant_thunk)\n          << ConflictMD;\n    }\n  }\n  // Go with the path that introduced the most covariant overrides.  If there is\n  // no such path, pick the first path.\n  return BestPath ? BestPath : &FullPaths.front();\n}\n\nstatic void computeFullPathsForVFTables(ASTContext &Context,\n                                        const CXXRecordDecl *RD,\n                                        VPtrInfoVector &Paths) {\n  const ASTRecordLayout &MostDerivedLayout = Context.getASTRecordLayout(RD);\n  FullPathTy FullPath;\n  std::list<FullPathTy> FullPaths;\n  for (const std::unique_ptr<VPtrInfo>& Info : Paths) {\n    findPathsToSubobject(\n        Context, MostDerivedLayout, RD, CharUnits::Zero(),\n        BaseSubobject(Info->IntroducingObject, Info->FullOffsetInMDC), FullPath,\n        FullPaths);\n    FullPath.clear();\n    removeRedundantPaths(FullPaths);\n    Info->PathToIntroducingObject.clear();\n    if (const FullPathTy *BestPath =\n            selectBestPath(Context, RD, *Info, FullPaths))\n      for (const BaseSubobject &BSO : *BestPath)\n        Info->PathToIntroducingObject.push_back(BSO.getBase());\n    FullPaths.clear();\n  }\n}\n\nstatic bool vfptrIsEarlierInMDC(const ASTRecordLayout &Layout,\n                                const MethodVFTableLocation &LHS,\n                                const MethodVFTableLocation &RHS) {\n  CharUnits L = LHS.VFPtrOffset;\n  CharUnits R = RHS.VFPtrOffset;\n  if (LHS.VBase)\n    L += Layout.getVBaseClassOffset(LHS.VBase);\n  if (RHS.VBase)\n    R += Layout.getVBaseClassOffset(RHS.VBase);\n  return L < R;\n}\n\nvoid MicrosoftVTableContext::computeVTableRelatedInformation(\n    const CXXRecordDecl *RD) {\n  assert(RD->isDynamicClass());\n\n  // Check if we've computed this information before.\n  if (VFPtrLocations.count(RD))\n    return;\n\n  const VTableLayout::AddressPointsMapTy EmptyAddressPointsMap;\n\n  {\n    auto VFPtrs = std::make_unique<VPtrInfoVector>();\n    computeVTablePaths(/*ForVBTables=*/false, RD, *VFPtrs);\n    computeFullPathsForVFTables(Context, RD, *VFPtrs);\n    VFPtrLocations[RD] = std::move(VFPtrs);\n  }\n\n  MethodVFTableLocationsTy NewMethodLocations;\n  for (const std::unique_ptr<VPtrInfo> &VFPtr : *VFPtrLocations[RD]) {\n    VFTableBuilder Builder(*this, RD, *VFPtr);\n\n    VFTableIdTy id(RD, VFPtr->FullOffsetInMDC);\n    assert(VFTableLayouts.count(id) == 0);\n    SmallVector<VTableLayout::VTableThunkTy, 1> VTableThunks(\n        Builder.vtable_thunks_begin(), Builder.vtable_thunks_end());\n    VFTableLayouts[id] = std::make_unique<VTableLayout>(\n        ArrayRef<size_t>{0}, Builder.vtable_components(), VTableThunks,\n        EmptyAddressPointsMap);\n    Thunks.insert(Builder.thunks_begin(), Builder.thunks_end());\n\n    const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n    for (const auto &Loc : Builder.vtable_locations()) {\n      auto Insert = NewMethodLocations.insert(Loc);\n      if (!Insert.second) {\n        const MethodVFTableLocation &NewLoc = Loc.second;\n        MethodVFTableLocation &OldLoc = Insert.first->second;\n        if (vfptrIsEarlierInMDC(Layout, NewLoc, OldLoc))\n          OldLoc = NewLoc;\n      }\n    }\n  }\n\n  MethodVFTableLocations.insert(NewMethodLocations.begin(),\n                                NewMethodLocations.end());\n  if (Context.getLangOpts().DumpVTableLayouts)\n    dumpMethodLocations(RD, NewMethodLocations, llvm::outs());\n}\n\nvoid MicrosoftVTableContext::dumpMethodLocations(\n    const CXXRecordDecl *RD, const MethodVFTableLocationsTy &NewMethods,\n    raw_ostream &Out) {\n  // Compute the vtable indices for all the member functions.\n  // Store them in a map keyed by the location so we'll get a sorted table.\n  std::map<MethodVFTableLocation, std::string> IndicesMap;\n  bool HasNonzeroOffset = false;\n\n  for (const auto &I : NewMethods) {\n    const CXXMethodDecl *MD = cast<const CXXMethodDecl>(I.first.getDecl());\n    assert(hasVtableSlot(MD));\n\n    std::string MethodName = PredefinedExpr::ComputeName(\n        PredefinedExpr::PrettyFunctionNoVirtual, MD);\n\n    if (isa<CXXDestructorDecl>(MD)) {\n      IndicesMap[I.second] = MethodName + \" [scalar deleting]\";\n    } else {\n      IndicesMap[I.second] = MethodName;\n    }\n\n    if (!I.second.VFPtrOffset.isZero() || I.second.VBTableIndex != 0)\n      HasNonzeroOffset = true;\n  }\n\n  // Print the vtable indices for all the member functions.\n  if (!IndicesMap.empty()) {\n    Out << \"VFTable indices for \";\n    Out << \"'\";\n    RD->printQualifiedName(Out);\n    Out << \"' (\" << IndicesMap.size()\n        << (IndicesMap.size() == 1 ? \" entry\" : \" entries\") << \").\\n\";\n\n    CharUnits LastVFPtrOffset = CharUnits::fromQuantity(-1);\n    uint64_t LastVBIndex = 0;\n    for (const auto &I : IndicesMap) {\n      CharUnits VFPtrOffset = I.first.VFPtrOffset;\n      uint64_t VBIndex = I.first.VBTableIndex;\n      if (HasNonzeroOffset &&\n          (VFPtrOffset != LastVFPtrOffset || VBIndex != LastVBIndex)) {\n        assert(VBIndex > LastVBIndex || VFPtrOffset > LastVFPtrOffset);\n        Out << \" -- accessible via \";\n        if (VBIndex)\n          Out << \"vbtable index \" << VBIndex << \", \";\n        Out << \"vfptr at offset \" << VFPtrOffset.getQuantity() << \" --\\n\";\n        LastVFPtrOffset = VFPtrOffset;\n        LastVBIndex = VBIndex;\n      }\n\n      uint64_t VTableIndex = I.first.Index;\n      const std::string &MethodName = I.second;\n      Out << llvm::format(\"%4\" PRIu64 \" | \", VTableIndex) << MethodName << '\\n';\n    }\n    Out << '\\n';\n  }\n\n  Out.flush();\n}\n\nconst VirtualBaseInfo &MicrosoftVTableContext::computeVBTableRelatedInformation(\n    const CXXRecordDecl *RD) {\n  VirtualBaseInfo *VBI;\n\n  {\n    // Get or create a VBI for RD.  Don't hold a reference to the DenseMap cell,\n    // as it may be modified and rehashed under us.\n    std::unique_ptr<VirtualBaseInfo> &Entry = VBaseInfo[RD];\n    if (Entry)\n      return *Entry;\n    Entry = std::make_unique<VirtualBaseInfo>();\n    VBI = Entry.get();\n  }\n\n  computeVTablePaths(/*ForVBTables=*/true, RD, VBI->VBPtrPaths);\n\n  // First, see if the Derived class shared the vbptr with a non-virtual base.\n  const ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);\n  if (const CXXRecordDecl *VBPtrBase = Layout.getBaseSharingVBPtr()) {\n    // If the Derived class shares the vbptr with a non-virtual base, the shared\n    // virtual bases come first so that the layout is the same.\n    const VirtualBaseInfo &BaseInfo =\n        computeVBTableRelatedInformation(VBPtrBase);\n    VBI->VBTableIndices.insert(BaseInfo.VBTableIndices.begin(),\n                               BaseInfo.VBTableIndices.end());\n  }\n\n  // New vbases are added to the end of the vbtable.\n  // Skip the self entry and vbases visited in the non-virtual base, if any.\n  unsigned VBTableIndex = 1 + VBI->VBTableIndices.size();\n  for (const auto &VB : RD->vbases()) {\n    const CXXRecordDecl *CurVBase = VB.getType()->getAsCXXRecordDecl();\n    if (!VBI->VBTableIndices.count(CurVBase))\n      VBI->VBTableIndices[CurVBase] = VBTableIndex++;\n  }\n\n  return *VBI;\n}\n\nunsigned MicrosoftVTableContext::getVBTableIndex(const CXXRecordDecl *Derived,\n                                                 const CXXRecordDecl *VBase) {\n  const VirtualBaseInfo &VBInfo = computeVBTableRelatedInformation(Derived);\n  assert(VBInfo.VBTableIndices.count(VBase));\n  return VBInfo.VBTableIndices.find(VBase)->second;\n}\n\nconst VPtrInfoVector &\nMicrosoftVTableContext::enumerateVBTables(const CXXRecordDecl *RD) {\n  return computeVBTableRelatedInformation(RD).VBPtrPaths;\n}\n\nconst VPtrInfoVector &\nMicrosoftVTableContext::getVFPtrOffsets(const CXXRecordDecl *RD) {\n  computeVTableRelatedInformation(RD);\n\n  assert(VFPtrLocations.count(RD) && \"Couldn't find vfptr locations\");\n  return *VFPtrLocations[RD];\n}\n\nconst VTableLayout &\nMicrosoftVTableContext::getVFTableLayout(const CXXRecordDecl *RD,\n                                         CharUnits VFPtrOffset) {\n  computeVTableRelatedInformation(RD);\n\n  VFTableIdTy id(RD, VFPtrOffset);\n  assert(VFTableLayouts.count(id) && \"Couldn't find a VFTable at this offset\");\n  return *VFTableLayouts[id];\n}\n\nMethodVFTableLocation\nMicrosoftVTableContext::getMethodVFTableLocation(GlobalDecl GD) {\n  assert(hasVtableSlot(cast<CXXMethodDecl>(GD.getDecl())) &&\n         \"Only use this method for virtual methods or dtors\");\n  if (isa<CXXDestructorDecl>(GD.getDecl()))\n    assert(GD.getDtorType() == Dtor_Deleting);\n\n  GD = GD.getCanonicalDecl();\n\n  MethodVFTableLocationsTy::iterator I = MethodVFTableLocations.find(GD);\n  if (I != MethodVFTableLocations.end())\n    return I->second;\n\n  const CXXRecordDecl *RD = cast<CXXMethodDecl>(GD.getDecl())->getParent();\n\n  computeVTableRelatedInformation(RD);\n\n  I = MethodVFTableLocations.find(GD);\n  assert(I != MethodVFTableLocations.end() && \"Did not find index!\");\n  return I->second;\n}\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 27, "line": 61}, "message": "'FinalOverriders' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/VTableBuilder.cpp", "reportHash": "d9f3dd4ac29ca0dd4831d1bd677cb731", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 27, "line": 2450}, "message": "'MethodInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/AST/VTableBuilder.cpp", "reportHash": "3a20a956bedb9075ad3f220de9f9d599", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
