<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"97": {"id": 97, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/Local.cpp", "content": "//===- Local.cpp - Functions to perform local transformations -------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This family of functions perform various local transformations to the\n// program.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/Transforms/Utils/Local.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/Analysis/AssumeBundleQueries.h\"\n#include \"llvm/Analysis/ConstantFolding.h\"\n#include \"llvm/Analysis/DomTreeUpdater.h\"\n#include \"llvm/Analysis/EHPersonalities.h\"\n#include \"llvm/Analysis/InstructionSimplify.h\"\n#include \"llvm/Analysis/LazyValueInfo.h\"\n#include \"llvm/Analysis/MemoryBuiltins.h\"\n#include \"llvm/Analysis/MemorySSAUpdater.h\"\n#include \"llvm/Analysis/TargetLibraryInfo.h\"\n#include \"llvm/Analysis/ValueTracking.h\"\n#include \"llvm/Analysis/VectorUtils.h\"\n#include \"llvm/BinaryFormat/Dwarf.h\"\n#include \"llvm/IR/Argument.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/CFG.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/ConstantRange.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DIBuilder.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/GetElementPtrTypeIterator.h\"\n#include \"llvm/IR/GlobalObject.h\"\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/MDBuilder.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/PatternMatch.h\"\n#include \"llvm/IR/PseudoProbe.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/KnownBits.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Transforms/Utils/BasicBlockUtils.h\"\n#include \"llvm/Transforms/Utils/ValueMapper.h\"\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cstdint>\n#include <iterator>\n#include <map>\n#include <utility>\n\nusing namespace llvm;\nusing namespace llvm::PatternMatch;\n\n#define DEBUG_TYPE \"local\"\n\nSTATISTIC(NumRemoved, \"Number of unreachable basic blocks removed\");\nSTATISTIC(NumPHICSEs, \"Number of PHI's that got CSE'd\");\n\nstatic cl::opt<bool> PHICSEDebugHash(\n    \"phicse-debug-hash\",\n#ifdef EXPENSIVE_CHECKS\n    cl::init(true),\n#else\n    cl::init(false),\n#endif\n    cl::Hidden,\n    cl::desc(\"Perform extra assertion checking to verify that PHINodes's hash \"\n             \"function is well-behaved w.r.t. its isEqual predicate\"));\n\nstatic cl::opt<unsigned> PHICSENumPHISmallSize(\n    \"phicse-num-phi-smallsize\", cl::init(32), cl::Hidden,\n    cl::desc(\n        \"When the basic block contains not more than this number of PHI nodes, \"\n        \"perform a (faster!) exhaustive search instead of set-driven one.\"));\n\n// Max recursion depth for collectBitParts used when detecting bswap and\n// bitreverse idioms\nstatic const unsigned BitPartRecursionMaxDepth = 64;\n\n//===----------------------------------------------------------------------===//\n//  Local constant propagation.\n//\n\n/// ConstantFoldTerminator - If a terminator instruction is predicated on a\n/// constant value, convert it into an unconditional branch to the constant\n/// destination.  This is a nontrivial operation because the successors of this\n/// basic block must have their PHI nodes updated.\n/// Also calls RecursivelyDeleteTriviallyDeadInstructions() on any branch/switch\n/// conditions and indirectbr addresses this might make dead if\n/// DeleteDeadConditions is true.\nbool llvm::ConstantFoldTerminator(BasicBlock *BB, bool DeleteDeadConditions,\n                                  const TargetLibraryInfo *TLI,\n                                  DomTreeUpdater *DTU) {\n  Instruction *T = BB->getTerminator();\n  IRBuilder<> Builder(T);\n\n  // Branch - See if we are conditional jumping on constant\n  if (auto *BI = dyn_cast<BranchInst>(T)) {\n    if (BI->isUnconditional()) return false;  // Can't optimize uncond branch\n\n    BasicBlock *Dest1 = BI->getSuccessor(0);\n    BasicBlock *Dest2 = BI->getSuccessor(1);\n\n    if (Dest2 == Dest1) {       // Conditional branch to same location?\n      // This branch matches something like this:\n      //     br bool %cond, label %Dest, label %Dest\n      // and changes it into:  br label %Dest\n\n      // Let the basic block know that we are letting go of one copy of it.\n      assert(BI->getParent() && \"Terminator not inserted in block!\");\n      Dest1->removePredecessor(BI->getParent());\n\n      // Replace the conditional branch with an unconditional one.\n      Builder.CreateBr(Dest1);\n      Value *Cond = BI->getCondition();\n      BI->eraseFromParent();\n      if (DeleteDeadConditions)\n        RecursivelyDeleteTriviallyDeadInstructions(Cond, TLI);\n      return true;\n    }\n\n    if (auto *Cond = dyn_cast<ConstantInt>(BI->getCondition())) {\n      // Are we branching on constant?\n      // YES.  Change to unconditional branch...\n      BasicBlock *Destination = Cond->getZExtValue() ? Dest1 : Dest2;\n      BasicBlock *OldDest = Cond->getZExtValue() ? Dest2 : Dest1;\n\n      // Let the basic block know that we are letting go of it.  Based on this,\n      // it will adjust it's PHI nodes.\n      OldDest->removePredecessor(BB);\n\n      // Replace the conditional branch with an unconditional one.\n      Builder.CreateBr(Destination);\n      BI->eraseFromParent();\n      if (DTU)\n        DTU->applyUpdates({{DominatorTree::Delete, BB, OldDest}});\n      return true;\n    }\n\n    return false;\n  }\n\n  if (auto *SI = dyn_cast<SwitchInst>(T)) {\n    // If we are switching on a constant, we can convert the switch to an\n    // unconditional branch.\n    auto *CI = dyn_cast<ConstantInt>(SI->getCondition());\n    BasicBlock *DefaultDest = SI->getDefaultDest();\n    BasicBlock *TheOnlyDest = DefaultDest;\n\n    // If the default is unreachable, ignore it when searching for TheOnlyDest.\n    if (isa<UnreachableInst>(DefaultDest->getFirstNonPHIOrDbg()) &&\n        SI->getNumCases() > 0) {\n      TheOnlyDest = SI->case_begin()->getCaseSuccessor();\n    }\n\n    bool Changed = false;\n\n    // Figure out which case it goes to.\n    for (auto i = SI->case_begin(), e = SI->case_end(); i != e;) {\n      // Found case matching a constant operand?\n      if (i->getCaseValue() == CI) {\n        TheOnlyDest = i->getCaseSuccessor();\n        break;\n      }\n\n      // Check to see if this branch is going to the same place as the default\n      // dest.  If so, eliminate it as an explicit compare.\n      if (i->getCaseSuccessor() == DefaultDest) {\n        MDNode *MD = SI->getMetadata(LLVMContext::MD_prof);\n        unsigned NCases = SI->getNumCases();\n        // Fold the case metadata into the default if there will be any branches\n        // left, unless the metadata doesn't match the switch.\n        if (NCases > 1 && MD && MD->getNumOperands() == 2 + NCases) {\n          // Collect branch weights into a vector.\n          SmallVector<uint32_t, 8> Weights;\n          for (unsigned MD_i = 1, MD_e = MD->getNumOperands(); MD_i < MD_e;\n               ++MD_i) {\n            auto *CI = mdconst::extract<ConstantInt>(MD->getOperand(MD_i));\n            Weights.push_back(CI->getValue().getZExtValue());\n          }\n          // Merge weight of this case to the default weight.\n          unsigned idx = i->getCaseIndex();\n          Weights[0] += Weights[idx+1];\n          // Remove weight for this case.\n          std::swap(Weights[idx+1], Weights.back());\n          Weights.pop_back();\n          SI->setMetadata(LLVMContext::MD_prof,\n                          MDBuilder(BB->getContext()).\n                          createBranchWeights(Weights));\n        }\n        // Remove this entry.\n        BasicBlock *ParentBB = SI->getParent();\n        DefaultDest->removePredecessor(ParentBB);\n        i = SI->removeCase(i);\n        e = SI->case_end();\n        Changed = true;\n        continue;\n      }\n\n      // Otherwise, check to see if the switch only branches to one destination.\n      // We do this by reseting \"TheOnlyDest\" to null when we find two non-equal\n      // destinations.\n      if (i->getCaseSuccessor() != TheOnlyDest)\n        TheOnlyDest = nullptr;\n\n      // Increment this iterator as we haven't removed the case.\n      ++i;\n    }\n\n    if (CI && !TheOnlyDest) {\n      // Branching on a constant, but not any of the cases, go to the default\n      // successor.\n      TheOnlyDest = SI->getDefaultDest();\n    }\n\n    // If we found a single destination that we can fold the switch into, do so\n    // now.\n    if (TheOnlyDest) {\n      // Insert the new branch.\n      Builder.CreateBr(TheOnlyDest);\n      BasicBlock *BB = SI->getParent();\n\n      SmallSetVector<BasicBlock *, 8> RemovedSuccessors;\n\n      // Remove entries from PHI nodes which we no longer branch to...\n      BasicBlock *SuccToKeep = TheOnlyDest;\n      for (BasicBlock *Succ : successors(SI)) {\n        if (DTU && Succ != TheOnlyDest)\n          RemovedSuccessors.insert(Succ);\n        // Found case matching a constant operand?\n        if (Succ == SuccToKeep) {\n          SuccToKeep = nullptr; // Don't modify the first branch to TheOnlyDest\n        } else {\n          Succ->removePredecessor(BB);\n        }\n      }\n\n      // Delete the old switch.\n      Value *Cond = SI->getCondition();\n      SI->eraseFromParent();\n      if (DeleteDeadConditions)\n        RecursivelyDeleteTriviallyDeadInstructions(Cond, TLI);\n      if (DTU) {\n        std::vector<DominatorTree::UpdateType> Updates;\n        Updates.reserve(RemovedSuccessors.size());\n        for (auto *RemovedSuccessor : RemovedSuccessors)\n          Updates.push_back({DominatorTree::Delete, BB, RemovedSuccessor});\n        DTU->applyUpdates(Updates);\n      }\n      return true;\n    }\n\n    if (SI->getNumCases() == 1) {\n      // Otherwise, we can fold this switch into a conditional branch\n      // instruction if it has only one non-default destination.\n      auto FirstCase = *SI->case_begin();\n      Value *Cond = Builder.CreateICmpEQ(SI->getCondition(),\n          FirstCase.getCaseValue(), \"cond\");\n\n      // Insert the new branch.\n      BranchInst *NewBr = Builder.CreateCondBr(Cond,\n                                               FirstCase.getCaseSuccessor(),\n                                               SI->getDefaultDest());\n      MDNode *MD = SI->getMetadata(LLVMContext::MD_prof);\n      if (MD && MD->getNumOperands() == 3) {\n        ConstantInt *SICase =\n            mdconst::dyn_extract<ConstantInt>(MD->getOperand(2));\n        ConstantInt *SIDef =\n            mdconst::dyn_extract<ConstantInt>(MD->getOperand(1));\n        assert(SICase && SIDef);\n        // The TrueWeight should be the weight for the single case of SI.\n        NewBr->setMetadata(LLVMContext::MD_prof,\n                        MDBuilder(BB->getContext()).\n                        createBranchWeights(SICase->getValue().getZExtValue(),\n                                            SIDef->getValue().getZExtValue()));\n      }\n\n      // Update make.implicit metadata to the newly-created conditional branch.\n      MDNode *MakeImplicitMD = SI->getMetadata(LLVMContext::MD_make_implicit);\n      if (MakeImplicitMD)\n        NewBr->setMetadata(LLVMContext::MD_make_implicit, MakeImplicitMD);\n\n      // Delete the old switch.\n      SI->eraseFromParent();\n      return true;\n    }\n    return Changed;\n  }\n\n  if (auto *IBI = dyn_cast<IndirectBrInst>(T)) {\n    // indirectbr blockaddress(@F, @BB) -> br label @BB\n    if (auto *BA =\n          dyn_cast<BlockAddress>(IBI->getAddress()->stripPointerCasts())) {\n      BasicBlock *TheOnlyDest = BA->getBasicBlock();\n      SmallSetVector<BasicBlock *, 8> RemovedSuccessors;\n\n      // Insert the new branch.\n      Builder.CreateBr(TheOnlyDest);\n\n      BasicBlock *SuccToKeep = TheOnlyDest;\n      for (unsigned i = 0, e = IBI->getNumDestinations(); i != e; ++i) {\n        BasicBlock *DestBB = IBI->getDestination(i);\n        if (DTU && DestBB != TheOnlyDest)\n          RemovedSuccessors.insert(DestBB);\n        if (IBI->getDestination(i) == SuccToKeep) {\n          SuccToKeep = nullptr;\n        } else {\n          DestBB->removePredecessor(BB);\n        }\n      }\n      Value *Address = IBI->getAddress();\n      IBI->eraseFromParent();\n      if (DeleteDeadConditions)\n        // Delete pointer cast instructions.\n        RecursivelyDeleteTriviallyDeadInstructions(Address, TLI);\n\n      // Also zap the blockaddress constant if there are no users remaining,\n      // otherwise the destination is still marked as having its address taken.\n      if (BA->use_empty())\n        BA->destroyConstant();\n\n      // If we didn't find our destination in the IBI successor list, then we\n      // have undefined behavior.  Replace the unconditional branch with an\n      // 'unreachable' instruction.\n      if (SuccToKeep) {\n        BB->getTerminator()->eraseFromParent();\n        new UnreachableInst(BB->getContext(), BB);\n      }\n\n      if (DTU) {\n        std::vector<DominatorTree::UpdateType> Updates;\n        Updates.reserve(RemovedSuccessors.size());\n        for (auto *RemovedSuccessor : RemovedSuccessors)\n          Updates.push_back({DominatorTree::Delete, BB, RemovedSuccessor});\n        DTU->applyUpdates(Updates);\n      }\n      return true;\n    }\n  }\n\n  return false;\n}\n\n//===----------------------------------------------------------------------===//\n//  Local dead code elimination.\n//\n\n/// isInstructionTriviallyDead - Return true if the result produced by the\n/// instruction is not used, and the instruction has no side effects.\n///\nbool llvm::isInstructionTriviallyDead(Instruction *I,\n                                      const TargetLibraryInfo *TLI) {\n  if (!I->use_empty())\n    return false;\n  return wouldInstructionBeTriviallyDead(I, TLI);\n}\n\nbool llvm::wouldInstructionBeTriviallyDead(Instruction *I,\n                                           const TargetLibraryInfo *TLI) {\n  if (I->isTerminator())\n    return false;\n\n  // We don't want the landingpad-like instructions removed by anything this\n  // general.\n  if (I->isEHPad())\n    return false;\n\n  // We don't want debug info removed by anything this general, unless\n  // debug info is empty.\n  if (DbgDeclareInst *DDI = dyn_cast<DbgDeclareInst>(I)) {\n    if (DDI->getAddress())\n      return false;\n    return true;\n  }\n  if (DbgValueInst *DVI = dyn_cast<DbgValueInst>(I)) {\n    if (DVI->hasArgList() || DVI->getValue(0))\n      return false;\n    return true;\n  }\n  if (DbgLabelInst *DLI = dyn_cast<DbgLabelInst>(I)) {\n    if (DLI->getLabel())\n      return false;\n    return true;\n  }\n\n  if (!I->willReturn())\n    return false;\n\n  if (!I->mayHaveSideEffects())\n    return true;\n\n  // Special case intrinsics that \"may have side effects\" but can be deleted\n  // when dead.\n  if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(I)) {\n    // Safe to delete llvm.stacksave and launder.invariant.group if dead.\n    if (II->getIntrinsicID() == Intrinsic::stacksave ||\n        II->getIntrinsicID() == Intrinsic::launder_invariant_group)\n      return true;\n\n    if (II->isLifetimeStartOrEnd()) {\n      auto *Arg = II->getArgOperand(1);\n      // Lifetime intrinsics are dead when their right-hand is undef.\n      if (isa<UndefValue>(Arg))\n        return true;\n      // If the right-hand is an alloc, global, or argument and the only uses\n      // are lifetime intrinsics then the intrinsics are dead.\n      if (isa<AllocaInst>(Arg) || isa<GlobalValue>(Arg) || isa<Argument>(Arg))\n        return llvm::all_of(Arg->uses(), [](Use &Use) {\n          if (IntrinsicInst *IntrinsicUse =\n                  dyn_cast<IntrinsicInst>(Use.getUser()))\n            return IntrinsicUse->isLifetimeStartOrEnd();\n          return false;\n        });\n      return false;\n    }\n\n    // Assumptions are dead if their condition is trivially true.  Guards on\n    // true are operationally no-ops.  In the future we can consider more\n    // sophisticated tradeoffs for guards considering potential for check\n    // widening, but for now we keep things simple.\n    if ((II->getIntrinsicID() == Intrinsic::assume &&\n         isAssumeWithEmptyBundle(*II)) ||\n        II->getIntrinsicID() == Intrinsic::experimental_guard) {\n      if (ConstantInt *Cond = dyn_cast<ConstantInt>(II->getArgOperand(0)))\n        return !Cond->isZero();\n\n      return false;\n    }\n  }\n\n  if (isAllocLikeFn(I, TLI))\n    return true;\n\n  if (CallInst *CI = isFreeCall(I, TLI))\n    if (Constant *C = dyn_cast<Constant>(CI->getArgOperand(0)))\n      return C->isNullValue() || isa<UndefValue>(C);\n\n  if (auto *Call = dyn_cast<CallBase>(I))\n    if (isMathLibCallNoop(Call, TLI))\n      return true;\n\n  return false;\n}\n\n/// RecursivelyDeleteTriviallyDeadInstructions - If the specified value is a\n/// trivially dead instruction, delete it.  If that makes any of its operands\n/// trivially dead, delete them too, recursively.  Return true if any\n/// instructions were deleted.\nbool llvm::RecursivelyDeleteTriviallyDeadInstructions(\n    Value *V, const TargetLibraryInfo *TLI, MemorySSAUpdater *MSSAU,\n    std::function<void(Value *)> AboutToDeleteCallback) {\n  Instruction *I = dyn_cast<Instruction>(V);\n  if (!I || !isInstructionTriviallyDead(I, TLI))\n    return false;\n\n  SmallVector<WeakTrackingVH, 16> DeadInsts;\n  DeadInsts.push_back(I);\n  RecursivelyDeleteTriviallyDeadInstructions(DeadInsts, TLI, MSSAU,\n                                             AboutToDeleteCallback);\n\n  return true;\n}\n\nbool llvm::RecursivelyDeleteTriviallyDeadInstructionsPermissive(\n    SmallVectorImpl<WeakTrackingVH> &DeadInsts, const TargetLibraryInfo *TLI,\n    MemorySSAUpdater *MSSAU,\n    std::function<void(Value *)> AboutToDeleteCallback) {\n  unsigned S = 0, E = DeadInsts.size(), Alive = 0;\n  for (; S != E; ++S) {\n    auto *I = cast<Instruction>(DeadInsts[S]);\n    if (!isInstructionTriviallyDead(I)) {\n      DeadInsts[S] = nullptr;\n      ++Alive;\n    }\n  }\n  if (Alive == E)\n    return false;\n  RecursivelyDeleteTriviallyDeadInstructions(DeadInsts, TLI, MSSAU,\n                                             AboutToDeleteCallback);\n  return true;\n}\n\nvoid llvm::RecursivelyDeleteTriviallyDeadInstructions(\n    SmallVectorImpl<WeakTrackingVH> &DeadInsts, const TargetLibraryInfo *TLI,\n    MemorySSAUpdater *MSSAU,\n    std::function<void(Value *)> AboutToDeleteCallback) {\n  // Process the dead instruction list until empty.\n  while (!DeadInsts.empty()) {\n    Value *V = DeadInsts.pop_back_val();\n    Instruction *I = cast_or_null<Instruction>(V);\n    if (!I)\n      continue;\n    assert(isInstructionTriviallyDead(I, TLI) &&\n           \"Live instruction found in dead worklist!\");\n    assert(I->use_empty() && \"Instructions with uses are not dead.\");\n\n    // Don't lose the debug info while deleting the instructions.\n    salvageDebugInfo(*I);\n\n    if (AboutToDeleteCallback)\n      AboutToDeleteCallback(I);\n\n    // Null out all of the instruction's operands to see if any operand becomes\n    // dead as we go.\n    for (Use &OpU : I->operands()) {\n      Value *OpV = OpU.get();\n      OpU.set(nullptr);\n\n      if (!OpV->use_empty())\n        continue;\n\n      // If the operand is an instruction that became dead as we nulled out the\n      // operand, and if it is 'trivially' dead, delete it in a future loop\n      // iteration.\n      if (Instruction *OpI = dyn_cast<Instruction>(OpV))\n        if (isInstructionTriviallyDead(OpI, TLI))\n          DeadInsts.push_back(OpI);\n    }\n    if (MSSAU)\n      MSSAU->removeMemoryAccess(I);\n\n    I->eraseFromParent();\n  }\n}\n\nbool llvm::replaceDbgUsesWithUndef(Instruction *I) {\n  SmallVector<DbgVariableIntrinsic *, 1> DbgUsers;\n  findDbgUsers(DbgUsers, I);\n  for (auto *DII : DbgUsers) {\n    Value *Undef = UndefValue::get(I->getType());\n    DII->replaceVariableLocationOp(I, Undef);\n  }\n  return !DbgUsers.empty();\n}\n\n/// areAllUsesEqual - Check whether the uses of a value are all the same.\n/// This is similar to Instruction::hasOneUse() except this will also return\n/// true when there are no uses or multiple uses that all refer to the same\n/// value.\nstatic bool areAllUsesEqual(Instruction *I) {\n  Value::user_iterator UI = I->user_begin();\n  Value::user_iterator UE = I->user_end();\n  if (UI == UE)\n    return true;\n\n  User *TheUse = *UI;\n  for (++UI; UI != UE; ++UI) {\n    if (*UI != TheUse)\n      return false;\n  }\n  return true;\n}\n\n/// RecursivelyDeleteDeadPHINode - If the specified value is an effectively\n/// dead PHI node, due to being a def-use chain of single-use nodes that\n/// either forms a cycle or is terminated by a trivially dead instruction,\n/// delete it.  If that makes any of its operands trivially dead, delete them\n/// too, recursively.  Return true if a change was made.\nbool llvm::RecursivelyDeleteDeadPHINode(PHINode *PN,\n                                        const TargetLibraryInfo *TLI,\n                                        llvm::MemorySSAUpdater *MSSAU) {\n  SmallPtrSet<Instruction*, 4> Visited;\n  for (Instruction *I = PN; areAllUsesEqual(I) && !I->mayHaveSideEffects();\n       I = cast<Instruction>(*I->user_begin())) {\n    if (I->use_empty())\n      return RecursivelyDeleteTriviallyDeadInstructions(I, TLI, MSSAU);\n\n    // If we find an instruction more than once, we're on a cycle that\n    // won't prove fruitful.\n    if (!Visited.insert(I).second) {\n      // Break the cycle and delete the instruction and its operands.\n      I->replaceAllUsesWith(UndefValue::get(I->getType()));\n      (void)RecursivelyDeleteTriviallyDeadInstructions(I, TLI, MSSAU);\n      return true;\n    }\n  }\n  return false;\n}\n\nstatic bool\nsimplifyAndDCEInstruction(Instruction *I,\n                          SmallSetVector<Instruction *, 16> &WorkList,\n                          const DataLayout &DL,\n                          const TargetLibraryInfo *TLI) {\n  if (isInstructionTriviallyDead(I, TLI)) {\n    salvageDebugInfo(*I);\n\n    // Null out all of the instruction's operands to see if any operand becomes\n    // dead as we go.\n    for (unsigned i = 0, e = I->getNumOperands(); i != e; ++i) {\n      Value *OpV = I->getOperand(i);\n      I->setOperand(i, nullptr);\n\n      if (!OpV->use_empty() || I == OpV)\n        continue;\n\n      // If the operand is an instruction that became dead as we nulled out the\n      // operand, and if it is 'trivially' dead, delete it in a future loop\n      // iteration.\n      if (Instruction *OpI = dyn_cast<Instruction>(OpV))\n        if (isInstructionTriviallyDead(OpI, TLI))\n          WorkList.insert(OpI);\n    }\n\n    I->eraseFromParent();\n\n    return true;\n  }\n\n  if (Value *SimpleV = SimplifyInstruction(I, DL)) {\n    // Add the users to the worklist. CAREFUL: an instruction can use itself,\n    // in the case of a phi node.\n    for (User *U : I->users()) {\n      if (U != I) {\n        WorkList.insert(cast<Instruction>(U));\n      }\n    }\n\n    // Replace the instruction with its simplified value.\n    bool Changed = false;\n    if (!I->use_empty()) {\n      I->replaceAllUsesWith(SimpleV);\n      Changed = true;\n    }\n    if (isInstructionTriviallyDead(I, TLI)) {\n      I->eraseFromParent();\n      Changed = true;\n    }\n    return Changed;\n  }\n  return false;\n}\n\n/// SimplifyInstructionsInBlock - Scan the specified basic block and try to\n/// simplify any instructions in it and recursively delete dead instructions.\n///\n/// This returns true if it changed the code, note that it can delete\n/// instructions in other blocks as well in this block.\nbool llvm::SimplifyInstructionsInBlock(BasicBlock *BB,\n                                       const TargetLibraryInfo *TLI) {\n  bool MadeChange = false;\n  const DataLayout &DL = BB->getModule()->getDataLayout();\n\n#ifndef NDEBUG\n  // In debug builds, ensure that the terminator of the block is never replaced\n  // or deleted by these simplifications. The idea of simplification is that it\n  // cannot introduce new instructions, and there is no way to replace the\n  // terminator of a block without introducing a new instruction.\n  AssertingVH<Instruction> TerminatorVH(&BB->back());\n#endif\n\n  SmallSetVector<Instruction *, 16> WorkList;\n  // Iterate over the original function, only adding insts to the worklist\n  // if they actually need to be revisited. This avoids having to pre-init\n  // the worklist with the entire function's worth of instructions.\n  for (BasicBlock::iterator BI = BB->begin(), E = std::prev(BB->end());\n       BI != E;) {\n    assert(!BI->isTerminator());\n    Instruction *I = &*BI;\n    ++BI;\n\n    // We're visiting this instruction now, so make sure it's not in the\n    // worklist from an earlier visit.\n    if (!WorkList.count(I))\n      MadeChange |= simplifyAndDCEInstruction(I, WorkList, DL, TLI);\n  }\n\n  while (!WorkList.empty()) {\n    Instruction *I = WorkList.pop_back_val();\n    MadeChange |= simplifyAndDCEInstruction(I, WorkList, DL, TLI);\n  }\n  return MadeChange;\n}\n\n//===----------------------------------------------------------------------===//\n//  Control Flow Graph Restructuring.\n//\n\nvoid llvm::MergeBasicBlockIntoOnlyPred(BasicBlock *DestBB,\n                                       DomTreeUpdater *DTU) {\n\n  // If BB has single-entry PHI nodes, fold them.\n  while (PHINode *PN = dyn_cast<PHINode>(DestBB->begin())) {\n    Value *NewVal = PN->getIncomingValue(0);\n    // Replace self referencing PHI with undef, it must be dead.\n    if (NewVal == PN) NewVal = UndefValue::get(PN->getType());\n    PN->replaceAllUsesWith(NewVal);\n    PN->eraseFromParent();\n  }\n\n  BasicBlock *PredBB = DestBB->getSinglePredecessor();\n  assert(PredBB && \"Block doesn't have a single predecessor!\");\n\n  bool ReplaceEntryBB = false;\n  if (PredBB == &DestBB->getParent()->getEntryBlock())\n    ReplaceEntryBB = true;\n\n  // DTU updates: Collect all the edges that enter\n  // PredBB. These dominator edges will be redirected to DestBB.\n  SmallVector<DominatorTree::UpdateType, 32> Updates;\n\n  if (DTU) {\n    for (BasicBlock *PredPredBB : predecessors(PredBB)) {\n      // This predecessor of PredBB may already have DestBB as a successor.\n      if (!llvm::is_contained(successors(PredPredBB), DestBB))\n        Updates.push_back({DominatorTree::Insert, PredPredBB, DestBB});\n      Updates.push_back({DominatorTree::Delete, PredPredBB, PredBB});\n    }\n    Updates.push_back({DominatorTree::Delete, PredBB, DestBB});\n  }\n\n  // Zap anything that took the address of DestBB.  Not doing this will give the\n  // address an invalid value.\n  if (DestBB->hasAddressTaken()) {\n    BlockAddress *BA = BlockAddress::get(DestBB);\n    Constant *Replacement =\n      ConstantInt::get(Type::getInt32Ty(BA->getContext()), 1);\n    BA->replaceAllUsesWith(ConstantExpr::getIntToPtr(Replacement,\n                                                     BA->getType()));\n    BA->destroyConstant();\n  }\n\n  // Anything that branched to PredBB now branches to DestBB.\n  PredBB->replaceAllUsesWith(DestBB);\n\n  // Splice all the instructions from PredBB to DestBB.\n  PredBB->getTerminator()->eraseFromParent();\n  DestBB->getInstList().splice(DestBB->begin(), PredBB->getInstList());\n  new UnreachableInst(PredBB->getContext(), PredBB);\n\n  // If the PredBB is the entry block of the function, move DestBB up to\n  // become the entry block after we erase PredBB.\n  if (ReplaceEntryBB)\n    DestBB->moveAfter(PredBB);\n\n  if (DTU) {\n    assert(PredBB->getInstList().size() == 1 &&\n           isa<UnreachableInst>(PredBB->getTerminator()) &&\n           \"The successor list of PredBB isn't empty before \"\n           \"applying corresponding DTU updates.\");\n    DTU->applyUpdatesPermissive(Updates);\n    DTU->deleteBB(PredBB);\n    // Recalculation of DomTree is needed when updating a forward DomTree and\n    // the Entry BB is replaced.\n    if (ReplaceEntryBB && DTU->hasDomTree()) {\n      // The entry block was removed and there is no external interface for\n      // the dominator tree to be notified of this change. In this corner-case\n      // we recalculate the entire tree.\n      DTU->recalculate(*(DestBB->getParent()));\n    }\n  }\n\n  else {\n    PredBB->eraseFromParent(); // Nuke BB if DTU is nullptr.\n  }\n}\n\n/// Return true if we can choose one of these values to use in place of the\n/// other. Note that we will always choose the non-undef value to keep.\nstatic bool CanMergeValues(Value *First, Value *Second) {\n  return First == Second || isa<UndefValue>(First) || isa<UndefValue>(Second);\n}\n\n/// Return true if we can fold BB, an almost-empty BB ending in an unconditional\n/// branch to Succ, into Succ.\n///\n/// Assumption: Succ is the single successor for BB.\nstatic bool CanPropagatePredecessorsForPHIs(BasicBlock *BB, BasicBlock *Succ) {\n  assert(*succ_begin(BB) == Succ && \"Succ is not successor of BB!\");\n\n  LLVM_DEBUG(dbgs() << \"Looking to fold \" << BB->getName() << \" into \"\n                    << Succ->getName() << \"\\n\");\n  // Shortcut, if there is only a single predecessor it must be BB and merging\n  // is always safe\n  if (Succ->getSinglePredecessor()) return true;\n\n  // Make a list of the predecessors of BB\n  SmallPtrSet<BasicBlock*, 16> BBPreds(pred_begin(BB), pred_end(BB));\n\n  // Look at all the phi nodes in Succ, to see if they present a conflict when\n  // merging these blocks\n  for (BasicBlock::iterator I = Succ->begin(); isa<PHINode>(I); ++I) {\n    PHINode *PN = cast<PHINode>(I);\n\n    // If the incoming value from BB is again a PHINode in\n    // BB which has the same incoming value for *PI as PN does, we can\n    // merge the phi nodes and then the blocks can still be merged\n    PHINode *BBPN = dyn_cast<PHINode>(PN->getIncomingValueForBlock(BB));\n    if (BBPN && BBPN->getParent() == BB) {\n      for (unsigned PI = 0, PE = PN->getNumIncomingValues(); PI != PE; ++PI) {\n        BasicBlock *IBB = PN->getIncomingBlock(PI);\n        if (BBPreds.count(IBB) &&\n            !CanMergeValues(BBPN->getIncomingValueForBlock(IBB),\n                            PN->getIncomingValue(PI))) {\n          LLVM_DEBUG(dbgs()\n                     << \"Can't fold, phi node \" << PN->getName() << \" in \"\n                     << Succ->getName() << \" is conflicting with \"\n                     << BBPN->getName() << \" with regard to common predecessor \"\n                     << IBB->getName() << \"\\n\");\n          return false;\n        }\n      }\n    } else {\n      Value* Val = PN->getIncomingValueForBlock(BB);\n      for (unsigned PI = 0, PE = PN->getNumIncomingValues(); PI != PE; ++PI) {\n        // See if the incoming value for the common predecessor is equal to the\n        // one for BB, in which case this phi node will not prevent the merging\n        // of the block.\n        BasicBlock *IBB = PN->getIncomingBlock(PI);\n        if (BBPreds.count(IBB) &&\n            !CanMergeValues(Val, PN->getIncomingValue(PI))) {\n          LLVM_DEBUG(dbgs() << \"Can't fold, phi node \" << PN->getName()\n                            << \" in \" << Succ->getName()\n                            << \" is conflicting with regard to common \"\n                            << \"predecessor \" << IBB->getName() << \"\\n\");\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nusing PredBlockVector = SmallVector<BasicBlock *, 16>;\nusing IncomingValueMap = DenseMap<BasicBlock *, Value *>;\n\n/// Determines the value to use as the phi node input for a block.\n///\n/// Select between \\p OldVal any value that we know flows from \\p BB\n/// to a particular phi on the basis of which one (if either) is not\n/// undef. Update IncomingValues based on the selected value.\n///\n/// \\param OldVal The value we are considering selecting.\n/// \\param BB The block that the value flows in from.\n/// \\param IncomingValues A map from block-to-value for other phi inputs\n/// that we have examined.\n///\n/// \\returns the selected value.\nstatic Value *selectIncomingValueForBlock(Value *OldVal, BasicBlock *BB,\n                                          IncomingValueMap &IncomingValues) {\n  if (!isa<UndefValue>(OldVal)) {\n    assert((!IncomingValues.count(BB) ||\n            IncomingValues.find(BB)->second == OldVal) &&\n           \"Expected OldVal to match incoming value from BB!\");\n\n    IncomingValues.insert(std::make_pair(BB, OldVal));\n    return OldVal;\n  }\n\n  IncomingValueMap::const_iterator It = IncomingValues.find(BB);\n  if (It != IncomingValues.end()) return It->second;\n\n  return OldVal;\n}\n\n/// Create a map from block to value for the operands of a\n/// given phi.\n///\n/// Create a map from block to value for each non-undef value flowing\n/// into \\p PN.\n///\n/// \\param PN The phi we are collecting the map for.\n/// \\param IncomingValues [out] The map from block to value for this phi.\nstatic void gatherIncomingValuesToPhi(PHINode *PN,\n                                      IncomingValueMap &IncomingValues) {\n  for (unsigned i = 0, e = PN->getNumIncomingValues(); i != e; ++i) {\n    BasicBlock *BB = PN->getIncomingBlock(i);\n    Value *V = PN->getIncomingValue(i);\n\n    if (!isa<UndefValue>(V))\n      IncomingValues.insert(std::make_pair(BB, V));\n  }\n}\n\n/// Replace the incoming undef values to a phi with the values\n/// from a block-to-value map.\n///\n/// \\param PN The phi we are replacing the undefs in.\n/// \\param IncomingValues A map from block to value.\nstatic void replaceUndefValuesInPhi(PHINode *PN,\n                                    const IncomingValueMap &IncomingValues) {\n  SmallVector<unsigned> TrueUndefOps;\n  for (unsigned i = 0, e = PN->getNumIncomingValues(); i != e; ++i) {\n    Value *V = PN->getIncomingValue(i);\n\n    if (!isa<UndefValue>(V)) continue;\n\n    BasicBlock *BB = PN->getIncomingBlock(i);\n    IncomingValueMap::const_iterator It = IncomingValues.find(BB);\n\n    // Keep track of undef/poison incoming values. Those must match, so we fix\n    // them up below if needed.\n    // Note: this is conservatively correct, but we could try harder and group\n    // the undef values per incoming basic block.\n    if (It == IncomingValues.end()) {\n      TrueUndefOps.push_back(i);\n      continue;\n    }\n\n    // There is a defined value for this incoming block, so map this undef\n    // incoming value to the defined value.\n    PN->setIncomingValue(i, It->second);\n  }\n\n  // If there are both undef and poison values incoming, then convert those\n  // values to undef. It is invalid to have different values for the same\n  // incoming block.\n  unsigned PoisonCount = count_if(TrueUndefOps, [&](unsigned i) {\n    return isa<PoisonValue>(PN->getIncomingValue(i));\n  });\n  if (PoisonCount != 0 && PoisonCount != TrueUndefOps.size()) {\n    for (unsigned i : TrueUndefOps)\n      PN->setIncomingValue(i, UndefValue::get(PN->getType()));\n  }\n}\n\n/// Replace a value flowing from a block to a phi with\n/// potentially multiple instances of that value flowing from the\n/// block's predecessors to the phi.\n///\n/// \\param BB The block with the value flowing into the phi.\n/// \\param BBPreds The predecessors of BB.\n/// \\param PN The phi that we are updating.\nstatic void redirectValuesFromPredecessorsToPhi(BasicBlock *BB,\n                                                const PredBlockVector &BBPreds,\n                                                PHINode *PN) {\n  Value *OldVal = PN->removeIncomingValue(BB, false);\n  assert(OldVal && \"No entry in PHI for Pred BB!\");\n\n  IncomingValueMap IncomingValues;\n\n  // We are merging two blocks - BB, and the block containing PN - and\n  // as a result we need to redirect edges from the predecessors of BB\n  // to go to the block containing PN, and update PN\n  // accordingly. Since we allow merging blocks in the case where the\n  // predecessor and successor blocks both share some predecessors,\n  // and where some of those common predecessors might have undef\n  // values flowing into PN, we want to rewrite those values to be\n  // consistent with the non-undef values.\n\n  gatherIncomingValuesToPhi(PN, IncomingValues);\n\n  // If this incoming value is one of the PHI nodes in BB, the new entries\n  // in the PHI node are the entries from the old PHI.\n  if (isa<PHINode>(OldVal) && cast<PHINode>(OldVal)->getParent() == BB) {\n    PHINode *OldValPN = cast<PHINode>(OldVal);\n    for (unsigned i = 0, e = OldValPN->getNumIncomingValues(); i != e; ++i) {\n      // Note that, since we are merging phi nodes and BB and Succ might\n      // have common predecessors, we could end up with a phi node with\n      // identical incoming branches. This will be cleaned up later (and\n      // will trigger asserts if we try to clean it up now, without also\n      // simplifying the corresponding conditional branch).\n      BasicBlock *PredBB = OldValPN->getIncomingBlock(i);\n      Value *PredVal = OldValPN->getIncomingValue(i);\n      Value *Selected = selectIncomingValueForBlock(PredVal, PredBB,\n                                                    IncomingValues);\n\n      // And add a new incoming value for this predecessor for the\n      // newly retargeted branch.\n      PN->addIncoming(Selected, PredBB);\n    }\n  } else {\n    for (unsigned i = 0, e = BBPreds.size(); i != e; ++i) {\n      // Update existing incoming values in PN for this\n      // predecessor of BB.\n      BasicBlock *PredBB = BBPreds[i];\n      Value *Selected = selectIncomingValueForBlock(OldVal, PredBB,\n                                                    IncomingValues);\n\n      // And add a new incoming value for this predecessor for the\n      // newly retargeted branch.\n      PN->addIncoming(Selected, PredBB);\n    }\n  }\n\n  replaceUndefValuesInPhi(PN, IncomingValues);\n}\n\nbool llvm::TryToSimplifyUncondBranchFromEmptyBlock(BasicBlock *BB,\n                                                   DomTreeUpdater *DTU) {\n  assert(BB != &BB->getParent()->getEntryBlock() &&\n         \"TryToSimplifyUncondBranchFromEmptyBlock called on entry block!\");\n\n  // We can't eliminate infinite loops.\n  BasicBlock *Succ = cast<BranchInst>(BB->getTerminator())->getSuccessor(0);\n  if (BB == Succ) return false;\n\n  // Check to see if merging these blocks would cause conflicts for any of the\n  // phi nodes in BB or Succ. If not, we can safely merge.\n  if (!CanPropagatePredecessorsForPHIs(BB, Succ)) return false;\n\n  // Check for cases where Succ has multiple predecessors and a PHI node in BB\n  // has uses which will not disappear when the PHI nodes are merged.  It is\n  // possible to handle such cases, but difficult: it requires checking whether\n  // BB dominates Succ, which is non-trivial to calculate in the case where\n  // Succ has multiple predecessors.  Also, it requires checking whether\n  // constructing the necessary self-referential PHI node doesn't introduce any\n  // conflicts; this isn't too difficult, but the previous code for doing this\n  // was incorrect.\n  //\n  // Note that if this check finds a live use, BB dominates Succ, so BB is\n  // something like a loop pre-header (or rarely, a part of an irreducible CFG);\n  // folding the branch isn't profitable in that case anyway.\n  if (!Succ->getSinglePredecessor()) {\n    BasicBlock::iterator BBI = BB->begin();\n    while (isa<PHINode>(*BBI)) {\n      for (Use &U : BBI->uses()) {\n        if (PHINode* PN = dyn_cast<PHINode>(U.getUser())) {\n          if (PN->getIncomingBlock(U) != BB)\n            return false;\n        } else {\n          return false;\n        }\n      }\n      ++BBI;\n    }\n  }\n\n  // We cannot fold the block if it's a branch to an already present callbr\n  // successor because that creates duplicate successors.\n  for (BasicBlock *PredBB : predecessors(BB)) {\n    if (auto *CBI = dyn_cast<CallBrInst>(PredBB->getTerminator())) {\n      if (Succ == CBI->getDefaultDest())\n        return false;\n      for (unsigned i = 0, e = CBI->getNumIndirectDests(); i != e; ++i)\n        if (Succ == CBI->getIndirectDest(i))\n          return false;\n    }\n  }\n\n  LLVM_DEBUG(dbgs() << \"Killing Trivial BB: \\n\" << *BB);\n\n  SmallVector<DominatorTree::UpdateType, 32> Updates;\n  if (DTU) {\n    // All predecessors of BB will be moved to Succ.\n    SmallSetVector<BasicBlock *, 8> Predecessors(pred_begin(BB), pred_end(BB));\n    Updates.reserve(Updates.size() + 2 * Predecessors.size());\n    for (auto *Predecessor : Predecessors) {\n      // This predecessor of BB may already have Succ as a successor.\n      if (!llvm::is_contained(successors(Predecessor), Succ))\n        Updates.push_back({DominatorTree::Insert, Predecessor, Succ});\n      Updates.push_back({DominatorTree::Delete, Predecessor, BB});\n    }\n    Updates.push_back({DominatorTree::Delete, BB, Succ});\n  }\n\n  if (isa<PHINode>(Succ->begin())) {\n    // If there is more than one pred of succ, and there are PHI nodes in\n    // the successor, then we need to add incoming edges for the PHI nodes\n    //\n    const PredBlockVector BBPreds(pred_begin(BB), pred_end(BB));\n\n    // Loop over all of the PHI nodes in the successor of BB.\n    for (BasicBlock::iterator I = Succ->begin(); isa<PHINode>(I); ++I) {\n      PHINode *PN = cast<PHINode>(I);\n\n      redirectValuesFromPredecessorsToPhi(BB, BBPreds, PN);\n    }\n  }\n\n  if (Succ->getSinglePredecessor()) {\n    // BB is the only predecessor of Succ, so Succ will end up with exactly\n    // the same predecessors BB had.\n\n    // Copy over any phi, debug or lifetime instruction.\n    BB->getTerminator()->eraseFromParent();\n    Succ->getInstList().splice(Succ->getFirstNonPHI()->getIterator(),\n                               BB->getInstList());\n  } else {\n    while (PHINode *PN = dyn_cast<PHINode>(&BB->front())) {\n      // We explicitly check for such uses in CanPropagatePredecessorsForPHIs.\n      assert(PN->use_empty() && \"There shouldn't be any uses here!\");\n      PN->eraseFromParent();\n    }\n  }\n\n  // If the unconditional branch we replaced contains llvm.loop metadata, we\n  // add the metadata to the branch instructions in the predecessors.\n  unsigned LoopMDKind = BB->getContext().getMDKindID(\"llvm.loop\");\n  Instruction *TI = BB->getTerminator();\n  if (TI)\n    if (MDNode *LoopMD = TI->getMetadata(LoopMDKind))\n      for (BasicBlock *Pred : predecessors(BB))\n        Pred->getTerminator()->setMetadata(LoopMDKind, LoopMD);\n\n  // For AutoFDO, since BB is going to be removed, we won't be able to sample\n  // it. To avoid assigning a zero weight for BB, move all its pseudo probes\n  // into Succ and mark them dangling. This should allow the counts inference a\n  // chance to get a more reasonable weight for BB.\n  moveAndDanglePseudoProbes(BB, &*Succ->getFirstInsertionPt());\n\n  // Everything that jumped to BB now goes to Succ.\n  BB->replaceAllUsesWith(Succ);\n  if (!Succ->hasName()) Succ->takeName(BB);\n\n  // Clear the successor list of BB to match updates applying to DTU later.\n  if (BB->getTerminator())\n    BB->getInstList().pop_back();\n  new UnreachableInst(BB->getContext(), BB);\n  assert(succ_empty(BB) && \"The successor list of BB isn't empty before \"\n                           \"applying corresponding DTU updates.\");\n\n  if (DTU) {\n    DTU->applyUpdates(Updates);\n    DTU->deleteBB(BB);\n  } else {\n    BB->eraseFromParent(); // Delete the old basic block.\n  }\n  return true;\n}\n\nstatic bool EliminateDuplicatePHINodesNaiveImpl(BasicBlock *BB) {\n  // This implementation doesn't currently consider undef operands\n  // specially. Theoretically, two phis which are identical except for\n  // one having an undef where the other doesn't could be collapsed.\n\n  bool Changed = false;\n\n  // Examine each PHI.\n  // Note that increment of I must *NOT* be in the iteration_expression, since\n  // we don't want to immediately advance when we restart from the beginning.\n  for (auto I = BB->begin(); PHINode *PN = dyn_cast<PHINode>(I);) {\n    ++I;\n    // Is there an identical PHI node in this basic block?\n    // Note that we only look in the upper square's triangle,\n    // we already checked that the lower triangle PHI's aren't identical.\n    for (auto J = I; PHINode *DuplicatePN = dyn_cast<PHINode>(J); ++J) {\n      if (!DuplicatePN->isIdenticalToWhenDefined(PN))\n        continue;\n      // A duplicate. Replace this PHI with the base PHI.\n      ++NumPHICSEs;\n      DuplicatePN->replaceAllUsesWith(PN);\n      DuplicatePN->eraseFromParent();\n      Changed = true;\n\n      // The RAUW can change PHIs that we already visited.\n      I = BB->begin();\n      break; // Start over from the beginning.\n    }\n  }\n  return Changed;\n}\n\nstatic bool EliminateDuplicatePHINodesSetBasedImpl(BasicBlock *BB) {\n  // This implementation doesn't currently consider undef operands\n  // specially. Theoretically, two phis which are identical except for\n  // one having an undef where the other doesn't could be collapsed.\n\n  struct PHIDenseMapInfo {\n    static PHINode *getEmptyKey() {\n      return DenseMapInfo<PHINode *>::getEmptyKey();\n    }\n\n    static PHINode *getTombstoneKey() {\n      return DenseMapInfo<PHINode *>::getTombstoneKey();\n    }\n\n    static bool isSentinel(PHINode *PN) {\n      return PN == getEmptyKey() || PN == getTombstoneKey();\n    }\n\n    // WARNING: this logic must be kept in sync with\n    //          Instruction::isIdenticalToWhenDefined()!\n    static unsigned getHashValueImpl(PHINode *PN) {\n      // Compute a hash value on the operands. Instcombine will likely have\n      // sorted them, which helps expose duplicates, but we have to check all\n      // the operands to be safe in case instcombine hasn't run.\n      return static_cast<unsigned>(hash_combine(\n          hash_combine_range(PN->value_op_begin(), PN->value_op_end()),\n          hash_combine_range(PN->block_begin(), PN->block_end())));\n    }\n\n    static unsigned getHashValue(PHINode *PN) {\n#ifndef NDEBUG\n      // If -phicse-debug-hash was specified, return a constant -- this\n      // will force all hashing to collide, so we'll exhaustively search\n      // the table for a match, and the assertion in isEqual will fire if\n      // there's a bug causing equal keys to hash differently.\n      if (PHICSEDebugHash)\n        return 0;\n#endif\n      return getHashValueImpl(PN);\n    }\n\n    static bool isEqualImpl(PHINode *LHS, PHINode *RHS) {\n      if (isSentinel(LHS) || isSentinel(RHS))\n        return LHS == RHS;\n      return LHS->isIdenticalTo(RHS);\n    }\n\n    static bool isEqual(PHINode *LHS, PHINode *RHS) {\n      // These comparisons are nontrivial, so assert that equality implies\n      // hash equality (DenseMap demands this as an invariant).\n      bool Result = isEqualImpl(LHS, RHS);\n      assert(!Result || (isSentinel(LHS) && LHS == RHS) ||\n             getHashValueImpl(LHS) == getHashValueImpl(RHS));\n      return Result;\n    }\n  };\n\n  // Set of unique PHINodes.\n  DenseSet<PHINode *, PHIDenseMapInfo> PHISet;\n  PHISet.reserve(4 * PHICSENumPHISmallSize);\n\n  // Examine each PHI.\n  bool Changed = false;\n  for (auto I = BB->begin(); PHINode *PN = dyn_cast<PHINode>(I++);) {\n    auto Inserted = PHISet.insert(PN);\n    if (!Inserted.second) {\n      // A duplicate. Replace this PHI with its duplicate.\n      ++NumPHICSEs;\n      PN->replaceAllUsesWith(*Inserted.first);\n      PN->eraseFromParent();\n      Changed = true;\n\n      // The RAUW can change PHIs that we already visited. Start over from the\n      // beginning.\n      PHISet.clear();\n      I = BB->begin();\n    }\n  }\n\n  return Changed;\n}\n\nbool llvm::EliminateDuplicatePHINodes(BasicBlock *BB) {\n  if (\n#ifndef NDEBUG\n      !PHICSEDebugHash &&\n#endif\n      hasNItemsOrLess(BB->phis(), PHICSENumPHISmallSize))\n    return EliminateDuplicatePHINodesNaiveImpl(BB);\n  return EliminateDuplicatePHINodesSetBasedImpl(BB);\n}\n\n/// If the specified pointer points to an object that we control, try to modify\n/// the object's alignment to PrefAlign. Returns a minimum known alignment of\n/// the value after the operation, which may be lower than PrefAlign.\n///\n/// Increating value alignment isn't often possible though. If alignment is\n/// important, a more reliable approach is to simply align all global variables\n/// and allocation instructions to their preferred alignment from the beginning.\nstatic Align tryEnforceAlignment(Value *V, Align PrefAlign,\n                                 const DataLayout &DL) {\n  V = V->stripPointerCasts();\n\n  if (AllocaInst *AI = dyn_cast<AllocaInst>(V)) {\n    // TODO: Ideally, this function would not be called if PrefAlign is smaller\n    // than the current alignment, as the known bits calculation should have\n    // already taken it into account. However, this is not always the case,\n    // as computeKnownBits() has a depth limit, while stripPointerCasts()\n    // doesn't.\n    Align CurrentAlign = AI->getAlign();\n    if (PrefAlign <= CurrentAlign)\n      return CurrentAlign;\n\n    // If the preferred alignment is greater than the natural stack alignment\n    // then don't round up. This avoids dynamic stack realignment.\n    if (DL.exceedsNaturalStackAlignment(PrefAlign))\n      return CurrentAlign;\n    AI->setAlignment(PrefAlign);\n    return PrefAlign;\n  }\n\n  if (auto *GO = dyn_cast<GlobalObject>(V)) {\n    // TODO: as above, this shouldn't be necessary.\n    Align CurrentAlign = GO->getPointerAlignment(DL);\n    if (PrefAlign <= CurrentAlign)\n      return CurrentAlign;\n\n    // If there is a large requested alignment and we can, bump up the alignment\n    // of the global.  If the memory we set aside for the global may not be the\n    // memory used by the final program then it is impossible for us to reliably\n    // enforce the preferred alignment.\n    if (!GO->canIncreaseAlignment())\n      return CurrentAlign;\n\n    GO->setAlignment(PrefAlign);\n    return PrefAlign;\n  }\n\n  return Align(1);\n}\n\nAlign llvm::getOrEnforceKnownAlignment(Value *V, MaybeAlign PrefAlign,\n                                       const DataLayout &DL,\n                                       const Instruction *CxtI,\n                                       AssumptionCache *AC,\n                                       const DominatorTree *DT) {\n  assert(V->getType()->isPointerTy() &&\n         \"getOrEnforceKnownAlignment expects a pointer!\");\n\n  KnownBits Known = computeKnownBits(V, DL, 0, AC, CxtI, DT);\n  unsigned TrailZ = Known.countMinTrailingZeros();\n\n  // Avoid trouble with ridiculously large TrailZ values, such as\n  // those computed from a null pointer.\n  // LLVM doesn't support alignments larger than (1 << MaxAlignmentExponent).\n  TrailZ = std::min(TrailZ, +Value::MaxAlignmentExponent);\n\n  Align Alignment = Align(1ull << std::min(Known.getBitWidth() - 1, TrailZ));\n\n  if (PrefAlign && *PrefAlign > Alignment)\n    Alignment = std::max(Alignment, tryEnforceAlignment(V, *PrefAlign, DL));\n\n  // We don't need to make any adjustment.\n  return Alignment;\n}\n\n///===---------------------------------------------------------------------===//\n///  Dbg Intrinsic utilities\n///\n\n/// See if there is a dbg.value intrinsic for DIVar for the PHI node.\nstatic bool PhiHasDebugValue(DILocalVariable *DIVar,\n                             DIExpression *DIExpr,\n                             PHINode *APN) {\n  // Since we can't guarantee that the original dbg.declare instrinsic\n  // is removed by LowerDbgDeclare(), we need to make sure that we are\n  // not inserting the same dbg.value intrinsic over and over.\n  SmallVector<DbgValueInst *, 1> DbgValues;\n  findDbgValues(DbgValues, APN);\n  for (auto *DVI : DbgValues) {\n    assert(is_contained(DVI->getValues(), APN));\n    if ((DVI->getVariable() == DIVar) && (DVI->getExpression() == DIExpr))\n      return true;\n  }\n  return false;\n}\n\n/// Check if the alloc size of \\p ValTy is large enough to cover the variable\n/// (or fragment of the variable) described by \\p DII.\n///\n/// This is primarily intended as a helper for the different\n/// ConvertDebugDeclareToDebugValue functions. The dbg.declare/dbg.addr that is\n/// converted describes an alloca'd variable, so we need to use the\n/// alloc size of the value when doing the comparison. E.g. an i1 value will be\n/// identified as covering an n-bit fragment, if the store size of i1 is at\n/// least n bits.\nstatic bool valueCoversEntireFragment(Type *ValTy, DbgVariableIntrinsic *DII) {\n  const DataLayout &DL = DII->getModule()->getDataLayout();\n  TypeSize ValueSize = DL.getTypeAllocSizeInBits(ValTy);\n  if (Optional<uint64_t> FragmentSize = DII->getFragmentSizeInBits()) {\n    assert(!ValueSize.isScalable() &&\n           \"Fragments don't work on scalable types.\");\n    return ValueSize.getFixedSize() >= *FragmentSize;\n  }\n  // We can't always calculate the size of the DI variable (e.g. if it is a\n  // VLA). Try to use the size of the alloca that the dbg intrinsic describes\n  // intead.\n  if (DII->isAddressOfVariable()) {\n    // DII should have exactly 1 location when it is an address.\n    assert(DII->getNumVariableLocationOps() == 1 &&\n           \"address of variable must have exactly 1 location operand.\");\n    if (auto *AI =\n            dyn_cast_or_null<AllocaInst>(DII->getVariableLocationOp(0))) {\n      if (Optional<TypeSize> FragmentSize = AI->getAllocationSizeInBits(DL)) {\n        assert(ValueSize.isScalable() == FragmentSize->isScalable() &&\n               \"Both sizes should agree on the scalable flag.\");\n        return TypeSize::isKnownGE(ValueSize, *FragmentSize);\n      }\n    }\n  }\n  // Could not determine size of variable. Conservatively return false.\n  return false;\n}\n\n/// Produce a DebugLoc to use for each dbg.declare/inst pair that are promoted\n/// to a dbg.value. Because no machine insts can come from debug intrinsics,\n/// only the scope and inlinedAt is significant. Zero line numbers are used in\n/// case this DebugLoc leaks into any adjacent instructions.\nstatic DebugLoc getDebugValueLoc(DbgVariableIntrinsic *DII, Instruction *Src) {\n  // Original dbg.declare must have a location.\n  DebugLoc DeclareLoc = DII->getDebugLoc();\n  MDNode *Scope = DeclareLoc.getScope();\n  DILocation *InlinedAt = DeclareLoc.getInlinedAt();\n  // Produce an unknown location with the correct scope / inlinedAt fields.\n  return DILocation::get(DII->getContext(), 0, 0, Scope, InlinedAt);\n}\n\n/// Inserts a llvm.dbg.value intrinsic before a store to an alloca'd value\n/// that has an associated llvm.dbg.declare or llvm.dbg.addr intrinsic.\nvoid llvm::ConvertDebugDeclareToDebugValue(DbgVariableIntrinsic *DII,\n                                           StoreInst *SI, DIBuilder &Builder) {\n  assert(DII->isAddressOfVariable());\n  auto *DIVar = DII->getVariable();\n  assert(DIVar && \"Missing variable\");\n  auto *DIExpr = DII->getExpression();\n  Value *DV = SI->getValueOperand();\n\n  DebugLoc NewLoc = getDebugValueLoc(DII, SI);\n\n  if (!valueCoversEntireFragment(DV->getType(), DII)) {\n    // FIXME: If storing to a part of the variable described by the dbg.declare,\n    // then we want to insert a dbg.value for the corresponding fragment.\n    LLVM_DEBUG(dbgs() << \"Failed to convert dbg.declare to dbg.value: \"\n                      << *DII << '\\n');\n    // For now, when there is a store to parts of the variable (but we do not\n    // know which part) we insert an dbg.value instrinsic to indicate that we\n    // know nothing about the variable's content.\n    DV = UndefValue::get(DV->getType());\n    Builder.insertDbgValueIntrinsic(DV, DIVar, DIExpr, NewLoc, SI);\n    return;\n  }\n\n  Builder.insertDbgValueIntrinsic(DV, DIVar, DIExpr, NewLoc, SI);\n}\n\n/// Inserts a llvm.dbg.value intrinsic before a load of an alloca'd value\n/// that has an associated llvm.dbg.declare or llvm.dbg.addr intrinsic.\nvoid llvm::ConvertDebugDeclareToDebugValue(DbgVariableIntrinsic *DII,\n                                           LoadInst *LI, DIBuilder &Builder) {\n  auto *DIVar = DII->getVariable();\n  auto *DIExpr = DII->getExpression();\n  assert(DIVar && \"Missing variable\");\n\n  if (!valueCoversEntireFragment(LI->getType(), DII)) {\n    // FIXME: If only referring to a part of the variable described by the\n    // dbg.declare, then we want to insert a dbg.value for the corresponding\n    // fragment.\n    LLVM_DEBUG(dbgs() << \"Failed to convert dbg.declare to dbg.value: \"\n                      << *DII << '\\n');\n    return;\n  }\n\n  DebugLoc NewLoc = getDebugValueLoc(DII, nullptr);\n\n  // We are now tracking the loaded value instead of the address. In the\n  // future if multi-location support is added to the IR, it might be\n  // preferable to keep tracking both the loaded value and the original\n  // address in case the alloca can not be elided.\n  Instruction *DbgValue = Builder.insertDbgValueIntrinsic(\n      LI, DIVar, DIExpr, NewLoc, (Instruction *)nullptr);\n  DbgValue->insertAfter(LI);\n}\n\n/// Inserts a llvm.dbg.value intrinsic after a phi that has an associated\n/// llvm.dbg.declare or llvm.dbg.addr intrinsic.\nvoid llvm::ConvertDebugDeclareToDebugValue(DbgVariableIntrinsic *DII,\n                                           PHINode *APN, DIBuilder &Builder) {\n  auto *DIVar = DII->getVariable();\n  auto *DIExpr = DII->getExpression();\n  assert(DIVar && \"Missing variable\");\n\n  if (PhiHasDebugValue(DIVar, DIExpr, APN))\n    return;\n\n  if (!valueCoversEntireFragment(APN->getType(), DII)) {\n    // FIXME: If only referring to a part of the variable described by the\n    // dbg.declare, then we want to insert a dbg.value for the corresponding\n    // fragment.\n    LLVM_DEBUG(dbgs() << \"Failed to convert dbg.declare to dbg.value: \"\n                      << *DII << '\\n');\n    return;\n  }\n\n  BasicBlock *BB = APN->getParent();\n  auto InsertionPt = BB->getFirstInsertionPt();\n\n  DebugLoc NewLoc = getDebugValueLoc(DII, nullptr);\n\n  // The block may be a catchswitch block, which does not have a valid\n  // insertion point.\n  // FIXME: Insert dbg.value markers in the successors when appropriate.\n  if (InsertionPt != BB->end())\n    Builder.insertDbgValueIntrinsic(APN, DIVar, DIExpr, NewLoc, &*InsertionPt);\n}\n\n/// Determine whether this alloca is either a VLA or an array.\nstatic bool isArray(AllocaInst *AI) {\n  return AI->isArrayAllocation() ||\n         (AI->getAllocatedType() && AI->getAllocatedType()->isArrayTy());\n}\n\n/// Determine whether this alloca is a structure.\nstatic bool isStructure(AllocaInst *AI) {\n  return AI->getAllocatedType() && AI->getAllocatedType()->isStructTy();\n}\n\n/// LowerDbgDeclare - Lowers llvm.dbg.declare intrinsics into appropriate set\n/// of llvm.dbg.value intrinsics.\nbool llvm::LowerDbgDeclare(Function &F) {\n  bool Changed = false;\n  DIBuilder DIB(*F.getParent(), /*AllowUnresolved*/ false);\n  SmallVector<DbgDeclareInst *, 4> Dbgs;\n  for (auto &FI : F)\n    for (Instruction &BI : FI)\n      if (auto DDI = dyn_cast<DbgDeclareInst>(&BI))\n        Dbgs.push_back(DDI);\n\n  if (Dbgs.empty())\n    return Changed;\n\n  for (auto &I : Dbgs) {\n    DbgDeclareInst *DDI = I;\n    AllocaInst *AI = dyn_cast_or_null<AllocaInst>(DDI->getAddress());\n    // If this is an alloca for a scalar variable, insert a dbg.value\n    // at each load and store to the alloca and erase the dbg.declare.\n    // The dbg.values allow tracking a variable even if it is not\n    // stored on the stack, while the dbg.declare can only describe\n    // the stack slot (and at a lexical-scope granularity). Later\n    // passes will attempt to elide the stack slot.\n    if (!AI || isArray(AI) || isStructure(AI))\n      continue;\n\n    // A volatile load/store means that the alloca can't be elided anyway.\n    if (llvm::any_of(AI->users(), [](User *U) -> bool {\n          if (LoadInst *LI = dyn_cast<LoadInst>(U))\n            return LI->isVolatile();\n          if (StoreInst *SI = dyn_cast<StoreInst>(U))\n            return SI->isVolatile();\n          return false;\n        }))\n      continue;\n\n    SmallVector<const Value *, 8> WorkList;\n    WorkList.push_back(AI);\n    while (!WorkList.empty()) {\n      const Value *V = WorkList.pop_back_val();\n      for (auto &AIUse : V->uses()) {\n        User *U = AIUse.getUser();\n        if (StoreInst *SI = dyn_cast<StoreInst>(U)) {\n          if (AIUse.getOperandNo() == 1)\n            ConvertDebugDeclareToDebugValue(DDI, SI, DIB);\n        } else if (LoadInst *LI = dyn_cast<LoadInst>(U)) {\n          ConvertDebugDeclareToDebugValue(DDI, LI, DIB);\n        } else if (CallInst *CI = dyn_cast<CallInst>(U)) {\n          // This is a call by-value or some other instruction that takes a\n          // pointer to the variable. Insert a *value* intrinsic that describes\n          // the variable by dereferencing the alloca.\n          if (!CI->isLifetimeStartOrEnd()) {\n            DebugLoc NewLoc = getDebugValueLoc(DDI, nullptr);\n            auto *DerefExpr =\n                DIExpression::append(DDI->getExpression(), dwarf::DW_OP_deref);\n            DIB.insertDbgValueIntrinsic(AI, DDI->getVariable(), DerefExpr,\n                                        NewLoc, CI);\n          }\n        } else if (BitCastInst *BI = dyn_cast<BitCastInst>(U)) {\n          if (BI->getType()->isPointerTy())\n            WorkList.push_back(BI);\n        }\n      }\n    }\n    DDI->eraseFromParent();\n    Changed = true;\n  }\n\n  if (Changed)\n  for (BasicBlock &BB : F)\n    RemoveRedundantDbgInstrs(&BB);\n\n  return Changed;\n}\n\n/// Propagate dbg.value intrinsics through the newly inserted PHIs.\nvoid llvm::insertDebugValuesForPHIs(BasicBlock *BB,\n                                    SmallVectorImpl<PHINode *> &InsertedPHIs) {\n  assert(BB && \"No BasicBlock to clone dbg.value(s) from.\");\n  if (InsertedPHIs.size() == 0)\n    return;\n\n  // Map existing PHI nodes to their dbg.values.\n  ValueToValueMapTy DbgValueMap;\n  for (auto &I : *BB) {\n    if (auto DbgII = dyn_cast<DbgVariableIntrinsic>(&I)) {\n      for (Value *V : DbgII->location_ops())\n        if (auto *Loc = dyn_cast_or_null<PHINode>(V))\n          DbgValueMap.insert({Loc, DbgII});\n    }\n  }\n  if (DbgValueMap.size() == 0)\n    return;\n\n  // Map a pair of the destination BB and old dbg.value to the new dbg.value,\n  // so that if a dbg.value is being rewritten to use more than one of the\n  // inserted PHIs in the same destination BB, we can update the same dbg.value\n  // with all the new PHIs instead of creating one copy for each.\n  SmallDenseMap<std::pair<BasicBlock *, DbgVariableIntrinsic *>,\n                DbgVariableIntrinsic *>\n      NewDbgValueMap;\n  // Then iterate through the new PHIs and look to see if they use one of the\n  // previously mapped PHIs. If so, create a new dbg.value intrinsic that will\n  // propagate the info through the new PHI. If we use more than one new PHI in\n  // a single destination BB with the same old dbg.value, merge the updates so\n  // that we get a single new dbg.value with all the new PHIs.\n  for (auto PHI : InsertedPHIs) {\n    BasicBlock *Parent = PHI->getParent();\n    // Avoid inserting an intrinsic into an EH block.\n    if (Parent->getFirstNonPHI()->isEHPad())\n      continue;\n    for (auto VI : PHI->operand_values()) {\n      auto V = DbgValueMap.find(VI);\n      if (V != DbgValueMap.end()) {\n        auto *DbgII = cast<DbgVariableIntrinsic>(V->second);\n        auto NewDI = NewDbgValueMap.find({Parent, DbgII});\n        if (NewDI == NewDbgValueMap.end()) {\n          auto *NewDbgII = cast<DbgVariableIntrinsic>(DbgII->clone());\n          NewDI = NewDbgValueMap.insert({{Parent, DbgII}, NewDbgII}).first;\n        }\n        DbgVariableIntrinsic *NewDbgII = NewDI->second;\n        // If PHI contains VI as an operand more than once, we may\n        // replaced it in NewDbgII; confirm that it is present.\n        if (is_contained(NewDbgII->location_ops(), VI))\n          NewDbgII->replaceVariableLocationOp(VI, PHI);\n      }\n    }\n  }\n  // Insert thew new dbg.values into their destination blocks.\n  for (auto DI : NewDbgValueMap) {\n    BasicBlock *Parent = DI.first.first;\n    auto *NewDbgII = DI.second;\n    auto InsertionPt = Parent->getFirstInsertionPt();\n    assert(InsertionPt != Parent->end() && \"Ill-formed basic block\");\n    NewDbgII->insertBefore(&*InsertionPt);\n  }\n}\n\n/// Finds all intrinsics declaring local variables as living in the memory that\n/// 'V' points to. This may include a mix of dbg.declare and\n/// dbg.addr intrinsics.\nTinyPtrVector<DbgVariableIntrinsic *> llvm::FindDbgAddrUses(Value *V) {\n  // This function is hot. Check whether the value has any metadata to avoid a\n  // DenseMap lookup.\n  if (!V->isUsedByMetadata())\n    return {};\n  auto *L = LocalAsMetadata::getIfExists(V);\n  if (!L)\n    return {};\n  auto *MDV = MetadataAsValue::getIfExists(V->getContext(), L);\n  if (!MDV)\n    return {};\n\n  TinyPtrVector<DbgVariableIntrinsic *> Declares;\n  for (User *U : MDV->users()) {\n    if (auto *DII = dyn_cast<DbgVariableIntrinsic>(U))\n      if (DII->isAddressOfVariable())\n        Declares.push_back(DII);\n  }\n\n  return Declares;\n}\n\nTinyPtrVector<DbgDeclareInst *> llvm::FindDbgDeclareUses(Value *V) {\n  TinyPtrVector<DbgDeclareInst *> DDIs;\n  for (DbgVariableIntrinsic *DVI : FindDbgAddrUses(V))\n    if (auto *DDI = dyn_cast<DbgDeclareInst>(DVI))\n      DDIs.push_back(DDI);\n  return DDIs;\n}\n\nvoid llvm::findDbgValues(SmallVectorImpl<DbgValueInst *> &DbgValues, Value *V) {\n  // This function is hot. Check whether the value has any metadata to avoid a\n  // DenseMap lookup.\n  if (!V->isUsedByMetadata())\n    return;\n  // TODO: If this value appears multiple times in a DIArgList, we should still\n  // only add the owning DbgValueInst once; use this set to track ArgListUsers.\n  // This behaviour can be removed when we can automatically remove duplicates.\n  SmallPtrSet<DbgValueInst *, 4> EncounteredDbgValues;\n  if (auto *L = LocalAsMetadata::getIfExists(V)) {\n    if (auto *MDV = MetadataAsValue::getIfExists(V->getContext(), L)) {\n      for (User *U : MDV->users())\n        if (DbgValueInst *DVI = dyn_cast<DbgValueInst>(U))\n          DbgValues.push_back(DVI);\n    }\n    for (Metadata *AL : L->getAllArgListUsers()) {\n      if (auto *MDV = MetadataAsValue::getIfExists(V->getContext(), AL)) {\n        for (User *U : MDV->users())\n          if (DbgValueInst *DVI = dyn_cast<DbgValueInst>(U))\n            if (EncounteredDbgValues.insert(DVI).second)\n              DbgValues.push_back(DVI);\n      }\n    }\n  }\n}\n\nvoid llvm::findDbgUsers(SmallVectorImpl<DbgVariableIntrinsic *> &DbgUsers,\n                        Value *V) {\n  // This function is hot. Check whether the value has any metadata to avoid a\n  // DenseMap lookup.\n  if (!V->isUsedByMetadata())\n    return;\n  // TODO: If this value appears multiple times in a DIArgList, we should still\n  // only add the owning DbgValueInst once; use this set to track ArgListUsers.\n  // This behaviour can be removed when we can automatically remove duplicates.\n  SmallPtrSet<DbgVariableIntrinsic *, 4> EncounteredDbgValues;\n  if (auto *L = LocalAsMetadata::getIfExists(V)) {\n    if (auto *MDV = MetadataAsValue::getIfExists(V->getContext(), L)) {\n      for (User *U : MDV->users())\n        if (DbgVariableIntrinsic *DII = dyn_cast<DbgVariableIntrinsic>(U))\n          DbgUsers.push_back(DII);\n    }\n    for (Metadata *AL : L->getAllArgListUsers()) {\n      if (auto *MDV = MetadataAsValue::getIfExists(V->getContext(), AL)) {\n        for (User *U : MDV->users())\n          if (DbgVariableIntrinsic *DII = dyn_cast<DbgVariableIntrinsic>(U))\n            if (EncounteredDbgValues.insert(DII).second)\n              DbgUsers.push_back(DII);\n      }\n    }\n  }\n}\n\nbool llvm::replaceDbgDeclare(Value *Address, Value *NewAddress,\n                             DIBuilder &Builder, uint8_t DIExprFlags,\n                             int Offset) {\n  auto DbgAddrs = FindDbgAddrUses(Address);\n  for (DbgVariableIntrinsic *DII : DbgAddrs) {\n    DebugLoc Loc = DII->getDebugLoc();\n    auto *DIVar = DII->getVariable();\n    auto *DIExpr = DII->getExpression();\n    assert(DIVar && \"Missing variable\");\n    DIExpr = DIExpression::prepend(DIExpr, DIExprFlags, Offset);\n    // Insert llvm.dbg.declare immediately before DII, and remove old\n    // llvm.dbg.declare.\n    Builder.insertDeclare(NewAddress, DIVar, DIExpr, Loc, DII);\n    DII->eraseFromParent();\n  }\n  return !DbgAddrs.empty();\n}\n\nstatic void replaceOneDbgValueForAlloca(DbgValueInst *DVI, Value *NewAddress,\n                                        DIBuilder &Builder, int Offset) {\n  DebugLoc Loc = DVI->getDebugLoc();\n  auto *DIVar = DVI->getVariable();\n  auto *DIExpr = DVI->getExpression();\n  assert(DIVar && \"Missing variable\");\n\n  // This is an alloca-based llvm.dbg.value. The first thing it should do with\n  // the alloca pointer is dereference it. Otherwise we don't know how to handle\n  // it and give up.\n  if (!DIExpr || DIExpr->getNumElements() < 1 ||\n      DIExpr->getElement(0) != dwarf::DW_OP_deref)\n    return;\n\n  // Insert the offset before the first deref.\n  // We could just change the offset argument of dbg.value, but it's unsigned...\n  if (Offset)\n    DIExpr = DIExpression::prepend(DIExpr, 0, Offset);\n\n  Builder.insertDbgValueIntrinsic(NewAddress, DIVar, DIExpr, Loc, DVI);\n  DVI->eraseFromParent();\n}\n\nvoid llvm::replaceDbgValueForAlloca(AllocaInst *AI, Value *NewAllocaAddress,\n                                    DIBuilder &Builder, int Offset) {\n  if (auto *L = LocalAsMetadata::getIfExists(AI))\n    if (auto *MDV = MetadataAsValue::getIfExists(AI->getContext(), L))\n      for (Use &U : llvm::make_early_inc_range(MDV->uses()))\n        if (auto *DVI = dyn_cast<DbgValueInst>(U.getUser()))\n          replaceOneDbgValueForAlloca(DVI, NewAllocaAddress, Builder, Offset);\n}\n\n/// Where possible to salvage debug information for \\p I do so\n/// and return True. If not possible mark undef and return False.\nvoid llvm::salvageDebugInfo(Instruction &I) {\n  SmallVector<DbgVariableIntrinsic *, 1> DbgUsers;\n  findDbgUsers(DbgUsers, &I);\n  salvageDebugInfoForDbgValues(I, DbgUsers);\n}\n\nvoid llvm::salvageDebugInfoForDbgValues(\n    Instruction &I, ArrayRef<DbgVariableIntrinsic *> DbgUsers) {\n  bool Salvaged = false;\n\n  for (auto *DII : DbgUsers) {\n    // Do not add DW_OP_stack_value for DbgDeclare and DbgAddr, because they\n    // are implicitly pointing out the value as a DWARF memory location\n    // description.\n    bool StackValue = isa<DbgValueInst>(DII);\n    auto DIILocation = DII->location_ops();\n    assert(\n        is_contained(DIILocation, &I) &&\n        \"DbgVariableIntrinsic must use salvaged instruction as its location\");\n    unsigned LocNo = std::distance(DIILocation.begin(), find(DIILocation, &I));\n\n    DIExpression *DIExpr =\n        salvageDebugInfoImpl(I, DII->getExpression(), StackValue, LocNo);\n\n    // salvageDebugInfoImpl should fail on examining the first element of\n    // DbgUsers, or none of them.\n    if (!DIExpr)\n      break;\n\n    DII->replaceVariableLocationOp(&I, I.getOperand(0));\n    DII->setExpression(DIExpr);\n    LLVM_DEBUG(dbgs() << \"SALVAGE: \" << *DII << '\\n');\n    Salvaged = true;\n  }\n\n  if (Salvaged)\n    return;\n\n  for (auto *DII : DbgUsers) {\n    Value *Undef = UndefValue::get(I.getType());\n    DII->replaceVariableLocationOp(&I, Undef);\n  }\n}\n\nbool getSalvageOpsForGEP(GetElementPtrInst *GEP, const DataLayout &DL,\n                         SmallVectorImpl<uint64_t> &Opcodes) {\n  unsigned BitWidth = DL.getIndexSizeInBits(GEP->getPointerAddressSpace());\n  // Rewrite a constant GEP into a DIExpression.\n  APInt ConstantOffset(BitWidth, 0);\n  if (!GEP->accumulateConstantOffset(DL, ConstantOffset))\n    return false;\n  DIExpression::appendOffset(Opcodes, ConstantOffset.getSExtValue());\n  return true;\n}\n\nuint64_t getDwarfOpForBinOp(Instruction::BinaryOps Opcode) {\n  switch (Opcode) {\n  case Instruction::Add:\n    return dwarf::DW_OP_plus;\n  case Instruction::Sub:\n    return dwarf::DW_OP_minus;\n  case Instruction::Mul:\n    return dwarf::DW_OP_mul;\n  case Instruction::SDiv:\n    return dwarf::DW_OP_div;\n  case Instruction::SRem:\n    return dwarf::DW_OP_mod;\n  case Instruction::Or:\n    return dwarf::DW_OP_or;\n  case Instruction::And:\n    return dwarf::DW_OP_and;\n  case Instruction::Xor:\n    return dwarf::DW_OP_xor;\n  case Instruction::Shl:\n    return dwarf::DW_OP_shl;\n  case Instruction::LShr:\n    return dwarf::DW_OP_shr;\n  case Instruction::AShr:\n    return dwarf::DW_OP_shra;\n  default:\n    // TODO: Salvage from each kind of binop we know about.\n    return 0;\n  }\n}\n\nbool getSalvageOpsForBinOp(BinaryOperator *BI,\n                           SmallVectorImpl<uint64_t> &Opcodes) {\n  // Rewrite binary operations with constant integer operands.\n  auto *ConstInt = dyn_cast<ConstantInt>(BI->getOperand(1));\n  if (!ConstInt || ConstInt->getBitWidth() > 64)\n    return false;\n  uint64_t Val = ConstInt->getSExtValue();\n  Instruction::BinaryOps BinOpcode = BI->getOpcode();\n  // Add or Sub Instructions with a constant operand can potentially be\n  // simplified.\n  if (BinOpcode == Instruction::Add || BinOpcode == Instruction::Sub) {\n    uint64_t Offset = BinOpcode == Instruction::Add ? Val : -int64_t(Val);\n    DIExpression::appendOffset(Opcodes, Offset);\n    return true;\n  }\n  // Add constant int operand to expression stack.\n  Opcodes.append({dwarf::DW_OP_constu, Val});\n\n  // Add salvaged binary operator to expression stack, if it has a valid\n  // representation in a DIExpression.\n  uint64_t DwarfBinOp = getDwarfOpForBinOp(BinOpcode);\n  if (!DwarfBinOp)\n    return false;\n  Opcodes.push_back(DwarfBinOp);\n\n  return true;\n}\n\nDIExpression *llvm::salvageDebugInfoImpl(Instruction &I,\n                                         DIExpression *SrcDIExpr,\n                                         bool WithStackValue, unsigned LocNo) {\n  auto &M = *I.getModule();\n  auto &DL = M.getDataLayout();\n\n  // Apply a vector of opcodes to the source DIExpression.\n  auto doSalvage = [&](SmallVectorImpl<uint64_t> &Ops) -> DIExpression * {\n    DIExpression *DIExpr = SrcDIExpr;\n    if (!Ops.empty()) {\n      DIExpr = DIExpression::appendOpsToArg(DIExpr, Ops, LocNo, WithStackValue);\n    }\n    return DIExpr;\n  };\n\n  // initializer-list helper for applying operators to the source DIExpression.\n  auto applyOps = [&](ArrayRef<uint64_t> Opcodes) -> DIExpression * {\n    SmallVector<uint64_t, 8> Ops(Opcodes.begin(), Opcodes.end());\n    return doSalvage(Ops);\n  };\n\n  if (auto *CI = dyn_cast<CastInst>(&I)) {\n    // No-op casts are irrelevant for debug info.\n    if (CI->isNoopCast(DL))\n      return SrcDIExpr;\n\n    Type *Type = CI->getType();\n    // Casts other than Trunc, SExt, or ZExt to scalar types cannot be salvaged.\n    if (Type->isVectorTy() ||\n        !(isa<TruncInst>(&I) || isa<SExtInst>(&I) || isa<ZExtInst>(&I)))\n      return nullptr;\n\n    Value *FromValue = CI->getOperand(0);\n    unsigned FromTypeBitSize = FromValue->getType()->getScalarSizeInBits();\n    unsigned ToTypeBitSize = Type->getScalarSizeInBits();\n\n    return applyOps(DIExpression::getExtOps(FromTypeBitSize, ToTypeBitSize,\n                                            isa<SExtInst>(&I)));\n  }\n\n  SmallVector<uint64_t, 8> Ops;\n  if (auto *GEP = dyn_cast<GetElementPtrInst>(&I)) {\n    if (getSalvageOpsForGEP(GEP, DL, Ops))\n      return doSalvage(Ops);\n  } else if (auto *BI = dyn_cast<BinaryOperator>(&I)) {\n    if (getSalvageOpsForBinOp(BI, Ops))\n      return doSalvage(Ops);\n  }\n    // *Not* to do: we should not attempt to salvage load instructions,\n    // because the validity and lifetime of a dbg.value containing\n    // DW_OP_deref becomes difficult to analyze. See PR40628 for examples.\n  return nullptr;\n}\n\n/// A replacement for a dbg.value expression.\nusing DbgValReplacement = Optional<DIExpression *>;\n\n/// Point debug users of \\p From to \\p To using exprs given by \\p RewriteExpr,\n/// possibly moving/undefing users to prevent use-before-def. Returns true if\n/// changes are made.\nstatic bool rewriteDebugUsers(\n    Instruction &From, Value &To, Instruction &DomPoint, DominatorTree &DT,\n    function_ref<DbgValReplacement(DbgVariableIntrinsic &DII)> RewriteExpr) {\n  // Find debug users of From.\n  SmallVector<DbgVariableIntrinsic *, 1> Users;\n  findDbgUsers(Users, &From);\n  if (Users.empty())\n    return false;\n\n  // Prevent use-before-def of To.\n  bool Changed = false;\n  SmallPtrSet<DbgVariableIntrinsic *, 1> UndefOrSalvage;\n  if (isa<Instruction>(&To)) {\n    bool DomPointAfterFrom = From.getNextNonDebugInstruction() == &DomPoint;\n\n    for (auto *DII : Users) {\n      // It's common to see a debug user between From and DomPoint. Move it\n      // after DomPoint to preserve the variable update without any reordering.\n      if (DomPointAfterFrom && DII->getNextNonDebugInstruction() == &DomPoint) {\n        LLVM_DEBUG(dbgs() << \"MOVE:  \" << *DII << '\\n');\n        DII->moveAfter(&DomPoint);\n        Changed = true;\n\n      // Users which otherwise aren't dominated by the replacement value must\n      // be salvaged or deleted.\n      } else if (!DT.dominates(&DomPoint, DII)) {\n        UndefOrSalvage.insert(DII);\n      }\n    }\n  }\n\n  // Update debug users without use-before-def risk.\n  for (auto *DII : Users) {\n    if (UndefOrSalvage.count(DII))\n      continue;\n\n    DbgValReplacement DVR = RewriteExpr(*DII);\n    if (!DVR)\n      continue;\n\n    DII->replaceVariableLocationOp(&From, &To);\n    DII->setExpression(*DVR);\n    LLVM_DEBUG(dbgs() << \"REWRITE:  \" << *DII << '\\n');\n    Changed = true;\n  }\n\n  if (!UndefOrSalvage.empty()) {\n    // Try to salvage the remaining debug users.\n    salvageDebugInfo(From);\n    Changed = true;\n  }\n\n  return Changed;\n}\n\n/// Check if a bitcast between a value of type \\p FromTy to type \\p ToTy would\n/// losslessly preserve the bits and semantics of the value. This predicate is\n/// symmetric, i.e swapping \\p FromTy and \\p ToTy should give the same result.\n///\n/// Note that Type::canLosslesslyBitCastTo is not suitable here because it\n/// allows semantically unequivalent bitcasts, such as <2 x i64> -> <4 x i32>,\n/// and also does not allow lossless pointer <-> integer conversions.\nstatic bool isBitCastSemanticsPreserving(const DataLayout &DL, Type *FromTy,\n                                         Type *ToTy) {\n  // Trivially compatible types.\n  if (FromTy == ToTy)\n    return true;\n\n  // Handle compatible pointer <-> integer conversions.\n  if (FromTy->isIntOrPtrTy() && ToTy->isIntOrPtrTy()) {\n    bool SameSize = DL.getTypeSizeInBits(FromTy) == DL.getTypeSizeInBits(ToTy);\n    bool LosslessConversion = !DL.isNonIntegralPointerType(FromTy) &&\n                              !DL.isNonIntegralPointerType(ToTy);\n    return SameSize && LosslessConversion;\n  }\n\n  // TODO: This is not exhaustive.\n  return false;\n}\n\nbool llvm::replaceAllDbgUsesWith(Instruction &From, Value &To,\n                                 Instruction &DomPoint, DominatorTree &DT) {\n  // Exit early if From has no debug users.\n  if (!From.isUsedByMetadata())\n    return false;\n\n  assert(&From != &To && \"Can't replace something with itself\");\n\n  Type *FromTy = From.getType();\n  Type *ToTy = To.getType();\n\n  auto Identity = [&](DbgVariableIntrinsic &DII) -> DbgValReplacement {\n    return DII.getExpression();\n  };\n\n  // Handle no-op conversions.\n  Module &M = *From.getModule();\n  const DataLayout &DL = M.getDataLayout();\n  if (isBitCastSemanticsPreserving(DL, FromTy, ToTy))\n    return rewriteDebugUsers(From, To, DomPoint, DT, Identity);\n\n  // Handle integer-to-integer widening and narrowing.\n  // FIXME: Use DW_OP_convert when it's available everywhere.\n  if (FromTy->isIntegerTy() && ToTy->isIntegerTy()) {\n    uint64_t FromBits = FromTy->getPrimitiveSizeInBits();\n    uint64_t ToBits = ToTy->getPrimitiveSizeInBits();\n    assert(FromBits != ToBits && \"Unexpected no-op conversion\");\n\n    // When the width of the result grows, assume that a debugger will only\n    // access the low `FromBits` bits when inspecting the source variable.\n    if (FromBits < ToBits)\n      return rewriteDebugUsers(From, To, DomPoint, DT, Identity);\n\n    // The width of the result has shrunk. Use sign/zero extension to describe\n    // the source variable's high bits.\n    auto SignOrZeroExt = [&](DbgVariableIntrinsic &DII) -> DbgValReplacement {\n      DILocalVariable *Var = DII.getVariable();\n\n      // Without knowing signedness, sign/zero extension isn't possible.\n      auto Signedness = Var->getSignedness();\n      if (!Signedness)\n        return None;\n\n      bool Signed = *Signedness == DIBasicType::Signedness::Signed;\n      return DIExpression::appendExt(DII.getExpression(), ToBits, FromBits,\n                                     Signed);\n    };\n    return rewriteDebugUsers(From, To, DomPoint, DT, SignOrZeroExt);\n  }\n\n  // TODO: Floating-point conversions, vectors.\n  return false;\n}\n\nstd::pair<unsigned, unsigned>\nllvm::removeAllNonTerminatorAndEHPadInstructions(BasicBlock *BB) {\n  unsigned NumDeadInst = 0;\n  unsigned NumDeadDbgInst = 0;\n  // Delete the instructions backwards, as it has a reduced likelihood of\n  // having to update as many def-use and use-def chains.\n  Instruction *EndInst = BB->getTerminator(); // Last not to be deleted.\n  while (EndInst != &BB->front()) {\n    // Delete the next to last instruction.\n    Instruction *Inst = &*--EndInst->getIterator();\n    if (!Inst->use_empty() && !Inst->getType()->isTokenTy())\n      Inst->replaceAllUsesWith(UndefValue::get(Inst->getType()));\n    if (Inst->isEHPad() || Inst->getType()->isTokenTy()) {\n      EndInst = Inst;\n      continue;\n    }\n    if (isa<DbgInfoIntrinsic>(Inst))\n      ++NumDeadDbgInst;\n    else\n      ++NumDeadInst;\n    Inst->eraseFromParent();\n  }\n  return {NumDeadInst, NumDeadDbgInst};\n}\n\nunsigned llvm::changeToUnreachable(Instruction *I, bool UseLLVMTrap,\n                                   bool PreserveLCSSA, DomTreeUpdater *DTU,\n                                   MemorySSAUpdater *MSSAU) {\n  BasicBlock *BB = I->getParent();\n\n  if (MSSAU)\n    MSSAU->changeToUnreachable(I);\n\n  SmallSetVector<BasicBlock *, 8> UniqueSuccessors;\n\n  // Loop over all of the successors, removing BB's entry from any PHI\n  // nodes.\n  for (BasicBlock *Successor : successors(BB)) {\n    Successor->removePredecessor(BB, PreserveLCSSA);\n    if (DTU)\n      UniqueSuccessors.insert(Successor);\n  }\n  // Insert a call to llvm.trap right before this.  This turns the undefined\n  // behavior into a hard fail instead of falling through into random code.\n  if (UseLLVMTrap) {\n    Function *TrapFn =\n      Intrinsic::getDeclaration(BB->getParent()->getParent(), Intrinsic::trap);\n    CallInst *CallTrap = CallInst::Create(TrapFn, \"\", I);\n    CallTrap->setDebugLoc(I->getDebugLoc());\n  }\n  auto *UI = new UnreachableInst(I->getContext(), I);\n  UI->setDebugLoc(I->getDebugLoc());\n\n  // All instructions after this are dead.\n  unsigned NumInstrsRemoved = 0;\n  BasicBlock::iterator BBI = I->getIterator(), BBE = BB->end();\n  while (BBI != BBE) {\n    if (!BBI->use_empty())\n      BBI->replaceAllUsesWith(UndefValue::get(BBI->getType()));\n    BB->getInstList().erase(BBI++);\n    ++NumInstrsRemoved;\n  }\n  if (DTU) {\n    SmallVector<DominatorTree::UpdateType, 8> Updates;\n    Updates.reserve(UniqueSuccessors.size());\n    for (BasicBlock *UniqueSuccessor : UniqueSuccessors)\n      Updates.push_back({DominatorTree::Delete, BB, UniqueSuccessor});\n    DTU->applyUpdates(Updates);\n  }\n  return NumInstrsRemoved;\n}\n\nCallInst *llvm::createCallMatchingInvoke(InvokeInst *II) {\n  SmallVector<Value *, 8> Args(II->args());\n  SmallVector<OperandBundleDef, 1> OpBundles;\n  II->getOperandBundlesAsDefs(OpBundles);\n  CallInst *NewCall = CallInst::Create(II->getFunctionType(),\n                                       II->getCalledOperand(), Args, OpBundles);\n  NewCall->setCallingConv(II->getCallingConv());\n  NewCall->setAttributes(II->getAttributes());\n  NewCall->setDebugLoc(II->getDebugLoc());\n  NewCall->copyMetadata(*II);\n\n  // If the invoke had profile metadata, try converting them for CallInst.\n  uint64_t TotalWeight;\n  if (NewCall->extractProfTotalWeight(TotalWeight)) {\n    // Set the total weight if it fits into i32, otherwise reset.\n    MDBuilder MDB(NewCall->getContext());\n    auto NewWeights = uint32_t(TotalWeight) != TotalWeight\n                          ? nullptr\n                          : MDB.createBranchWeights({uint32_t(TotalWeight)});\n    NewCall->setMetadata(LLVMContext::MD_prof, NewWeights);\n  }\n\n  return NewCall;\n}\n\n/// changeToCall - Convert the specified invoke into a normal call.\nvoid llvm::changeToCall(InvokeInst *II, DomTreeUpdater *DTU) {\n  CallInst *NewCall = createCallMatchingInvoke(II);\n  NewCall->takeName(II);\n  NewCall->insertBefore(II);\n  II->replaceAllUsesWith(NewCall);\n\n  // Follow the call by a branch to the normal destination.\n  BasicBlock *NormalDestBB = II->getNormalDest();\n  BranchInst::Create(NormalDestBB, II);\n\n  // Update PHI nodes in the unwind destination\n  BasicBlock *BB = II->getParent();\n  BasicBlock *UnwindDestBB = II->getUnwindDest();\n  UnwindDestBB->removePredecessor(BB);\n  II->eraseFromParent();\n  if (DTU)\n    DTU->applyUpdates({{DominatorTree::Delete, BB, UnwindDestBB}});\n}\n\nBasicBlock *llvm::changeToInvokeAndSplitBasicBlock(CallInst *CI,\n                                                   BasicBlock *UnwindEdge,\n                                                   DomTreeUpdater *DTU) {\n  BasicBlock *BB = CI->getParent();\n\n  // Convert this function call into an invoke instruction.  First, split the\n  // basic block.\n  BasicBlock *Split = SplitBlock(BB, CI, DTU, /*LI=*/nullptr, /*MSSAU*/ nullptr,\n                                 CI->getName() + \".noexc\");\n\n  // Delete the unconditional branch inserted by SplitBlock\n  BB->getInstList().pop_back();\n\n  // Create the new invoke instruction.\n  SmallVector<Value *, 8> InvokeArgs(CI->args());\n  SmallVector<OperandBundleDef, 1> OpBundles;\n\n  CI->getOperandBundlesAsDefs(OpBundles);\n\n  // Note: we're round tripping operand bundles through memory here, and that\n  // can potentially be avoided with a cleverer API design that we do not have\n  // as of this time.\n\n  InvokeInst *II =\n      InvokeInst::Create(CI->getFunctionType(), CI->getCalledOperand(), Split,\n                         UnwindEdge, InvokeArgs, OpBundles, CI->getName(), BB);\n  II->setDebugLoc(CI->getDebugLoc());\n  II->setCallingConv(CI->getCallingConv());\n  II->setAttributes(CI->getAttributes());\n\n  if (DTU)\n    DTU->applyUpdates({{DominatorTree::Insert, BB, UnwindEdge}});\n\n  // Make sure that anything using the call now uses the invoke!  This also\n  // updates the CallGraph if present, because it uses a WeakTrackingVH.\n  CI->replaceAllUsesWith(II);\n\n  // Delete the original call\n  Split->getInstList().pop_front();\n  return Split;\n}\n\nstatic bool markAliveBlocks(Function &F,\n                            SmallPtrSetImpl<BasicBlock *> &Reachable,\n                            DomTreeUpdater *DTU = nullptr) {\n  SmallVector<BasicBlock*, 128> Worklist;\n  BasicBlock *BB = &F.front();\n  Worklist.push_back(BB);\n  Reachable.insert(BB);\n  bool Changed = false;\n  do {\n    BB = Worklist.pop_back_val();\n\n    // Do a quick scan of the basic block, turning any obviously unreachable\n    // instructions into LLVM unreachable insts.  The instruction combining pass\n    // canonicalizes unreachable insts into stores to null or undef.\n    for (Instruction &I : *BB) {\n      if (auto *CI = dyn_cast<CallInst>(&I)) {\n        Value *Callee = CI->getCalledOperand();\n        // Handle intrinsic calls.\n        if (Function *F = dyn_cast<Function>(Callee)) {\n          auto IntrinsicID = F->getIntrinsicID();\n          // Assumptions that are known to be false are equivalent to\n          // unreachable. Also, if the condition is undefined, then we make the\n          // choice most beneficial to the optimizer, and choose that to also be\n          // unreachable.\n          if (IntrinsicID == Intrinsic::assume) {\n            if (match(CI->getArgOperand(0), m_CombineOr(m_Zero(), m_Undef()))) {\n              // Don't insert a call to llvm.trap right before the unreachable.\n              changeToUnreachable(CI, false, false, DTU);\n              Changed = true;\n              break;\n            }\n          } else if (IntrinsicID == Intrinsic::experimental_guard) {\n            // A call to the guard intrinsic bails out of the current\n            // compilation unit if the predicate passed to it is false. If the\n            // predicate is a constant false, then we know the guard will bail\n            // out of the current compile unconditionally, so all code following\n            // it is dead.\n            //\n            // Note: unlike in llvm.assume, it is not \"obviously profitable\" for\n            // guards to treat `undef` as `false` since a guard on `undef` can\n            // still be useful for widening.\n            if (match(CI->getArgOperand(0), m_Zero()))\n              if (!isa<UnreachableInst>(CI->getNextNode())) {\n                changeToUnreachable(CI->getNextNode(), /*UseLLVMTrap=*/false,\n                                    false, DTU);\n                Changed = true;\n                break;\n              }\n          }\n        } else if ((isa<ConstantPointerNull>(Callee) &&\n                    !NullPointerIsDefined(CI->getFunction())) ||\n                   isa<UndefValue>(Callee)) {\n          changeToUnreachable(CI, /*UseLLVMTrap=*/false, false, DTU);\n          Changed = true;\n          break;\n        }\n        if (CI->doesNotReturn() && !CI->isMustTailCall()) {\n          // If we found a call to a no-return function, insert an unreachable\n          // instruction after it.  Make sure there isn't *already* one there\n          // though.\n          if (!isa<UnreachableInst>(CI->getNextNode())) {\n            // Don't insert a call to llvm.trap right before the unreachable.\n            changeToUnreachable(CI->getNextNode(), false, false, DTU);\n            Changed = true;\n          }\n          break;\n        }\n      } else if (auto *SI = dyn_cast<StoreInst>(&I)) {\n        // Store to undef and store to null are undefined and used to signal\n        // that they should be changed to unreachable by passes that can't\n        // modify the CFG.\n\n        // Don't touch volatile stores.\n        if (SI->isVolatile()) continue;\n\n        Value *Ptr = SI->getOperand(1);\n\n        if (isa<UndefValue>(Ptr) ||\n            (isa<ConstantPointerNull>(Ptr) &&\n             !NullPointerIsDefined(SI->getFunction(),\n                                   SI->getPointerAddressSpace()))) {\n          changeToUnreachable(SI, true, false, DTU);\n          Changed = true;\n          break;\n        }\n      }\n    }\n\n    Instruction *Terminator = BB->getTerminator();\n    if (auto *II = dyn_cast<InvokeInst>(Terminator)) {\n      // Turn invokes that call 'nounwind' functions into ordinary calls.\n      Value *Callee = II->getCalledOperand();\n      if ((isa<ConstantPointerNull>(Callee) &&\n           !NullPointerIsDefined(BB->getParent())) ||\n          isa<UndefValue>(Callee)) {\n        changeToUnreachable(II, true, false, DTU);\n        Changed = true;\n      } else if (II->doesNotThrow() && canSimplifyInvokeNoUnwind(&F)) {\n        if (II->use_empty() && II->onlyReadsMemory()) {\n          // jump to the normal destination branch.\n          BasicBlock *NormalDestBB = II->getNormalDest();\n          BasicBlock *UnwindDestBB = II->getUnwindDest();\n          BranchInst::Create(NormalDestBB, II);\n          UnwindDestBB->removePredecessor(II->getParent());\n          II->eraseFromParent();\n          if (DTU)\n            DTU->applyUpdates({{DominatorTree::Delete, BB, UnwindDestBB}});\n        } else\n          changeToCall(II, DTU);\n        Changed = true;\n      }\n    } else if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(Terminator)) {\n      // Remove catchpads which cannot be reached.\n      struct CatchPadDenseMapInfo {\n        static CatchPadInst *getEmptyKey() {\n          return DenseMapInfo<CatchPadInst *>::getEmptyKey();\n        }\n\n        static CatchPadInst *getTombstoneKey() {\n          return DenseMapInfo<CatchPadInst *>::getTombstoneKey();\n        }\n\n        static unsigned getHashValue(CatchPadInst *CatchPad) {\n          return static_cast<unsigned>(hash_combine_range(\n              CatchPad->value_op_begin(), CatchPad->value_op_end()));\n        }\n\n        static bool isEqual(CatchPadInst *LHS, CatchPadInst *RHS) {\n          if (LHS == getEmptyKey() || LHS == getTombstoneKey() ||\n              RHS == getEmptyKey() || RHS == getTombstoneKey())\n            return LHS == RHS;\n          return LHS->isIdenticalTo(RHS);\n        }\n      };\n\n      SmallMapVector<BasicBlock *, int, 8> NumPerSuccessorCases;\n      // Set of unique CatchPads.\n      SmallDenseMap<CatchPadInst *, detail::DenseSetEmpty, 4,\n                    CatchPadDenseMapInfo, detail::DenseSetPair<CatchPadInst *>>\n          HandlerSet;\n      detail::DenseSetEmpty Empty;\n      for (CatchSwitchInst::handler_iterator I = CatchSwitch->handler_begin(),\n                                             E = CatchSwitch->handler_end();\n           I != E; ++I) {\n        BasicBlock *HandlerBB = *I;\n        ++NumPerSuccessorCases[HandlerBB];\n        auto *CatchPad = cast<CatchPadInst>(HandlerBB->getFirstNonPHI());\n        if (!HandlerSet.insert({CatchPad, Empty}).second) {\n          --NumPerSuccessorCases[HandlerBB];\n          CatchSwitch->removeHandler(I);\n          --I;\n          --E;\n          Changed = true;\n        }\n      }\n      std::vector<DominatorTree::UpdateType> Updates;\n      for (const std::pair<BasicBlock *, int> &I : NumPerSuccessorCases)\n        if (I.second == 0)\n          Updates.push_back({DominatorTree::Delete, BB, I.first});\n      if (DTU)\n        DTU->applyUpdates(Updates);\n    }\n\n    Changed |= ConstantFoldTerminator(BB, true, nullptr, DTU);\n    for (BasicBlock *Successor : successors(BB))\n      if (Reachable.insert(Successor).second)\n        Worklist.push_back(Successor);\n  } while (!Worklist.empty());\n  return Changed;\n}\n\nvoid llvm::removeUnwindEdge(BasicBlock *BB, DomTreeUpdater *DTU) {\n  Instruction *TI = BB->getTerminator();\n\n  if (auto *II = dyn_cast<InvokeInst>(TI)) {\n    changeToCall(II, DTU);\n    return;\n  }\n\n  Instruction *NewTI;\n  BasicBlock *UnwindDest;\n\n  if (auto *CRI = dyn_cast<CleanupReturnInst>(TI)) {\n    NewTI = CleanupReturnInst::Create(CRI->getCleanupPad(), nullptr, CRI);\n    UnwindDest = CRI->getUnwindDest();\n  } else if (auto *CatchSwitch = dyn_cast<CatchSwitchInst>(TI)) {\n    auto *NewCatchSwitch = CatchSwitchInst::Create(\n        CatchSwitch->getParentPad(), nullptr, CatchSwitch->getNumHandlers(),\n        CatchSwitch->getName(), CatchSwitch);\n    for (BasicBlock *PadBB : CatchSwitch->handlers())\n      NewCatchSwitch->addHandler(PadBB);\n\n    NewTI = NewCatchSwitch;\n    UnwindDest = CatchSwitch->getUnwindDest();\n  } else {\n    llvm_unreachable(\"Could not find unwind successor\");\n  }\n\n  NewTI->takeName(TI);\n  NewTI->setDebugLoc(TI->getDebugLoc());\n  UnwindDest->removePredecessor(BB);\n  TI->replaceAllUsesWith(NewTI);\n  TI->eraseFromParent();\n  if (DTU)\n    DTU->applyUpdates({{DominatorTree::Delete, BB, UnwindDest}});\n}\n\n/// removeUnreachableBlocks - Remove blocks that are not reachable, even\n/// if they are in a dead cycle.  Return true if a change was made, false\n/// otherwise.\nbool llvm::removeUnreachableBlocks(Function &F, DomTreeUpdater *DTU,\n                                   MemorySSAUpdater *MSSAU) {\n  SmallPtrSet<BasicBlock *, 16> Reachable;\n  bool Changed = markAliveBlocks(F, Reachable, DTU);\n\n  // If there are unreachable blocks in the CFG...\n  if (Reachable.size() == F.size())\n    return Changed;\n\n  assert(Reachable.size() < F.size());\n\n  // Are there any blocks left to actually delete?\n  SmallSetVector<BasicBlock *, 8> BlocksToRemove;\n  for (BasicBlock &BB : F) {\n    // Skip reachable basic blocks\n    if (Reachable.count(&BB))\n      continue;\n    // Skip already-deleted blocks\n    if (DTU && DTU->isBBPendingDeletion(&BB))\n      continue;\n    BlocksToRemove.insert(&BB);\n  }\n\n  if (BlocksToRemove.empty())\n    return Changed;\n\n  Changed = true;\n  NumRemoved += BlocksToRemove.size();\n\n  if (MSSAU)\n    MSSAU->removeBlocks(BlocksToRemove);\n\n  // Loop over all of the basic blocks that are up for removal, dropping all of\n  // their internal references. Update DTU if available.\n  std::vector<DominatorTree::UpdateType> Updates;\n  for (auto *BB : BlocksToRemove) {\n    SmallSetVector<BasicBlock *, 8> UniqueSuccessors;\n    for (BasicBlock *Successor : successors(BB)) {\n      // Only remove references to BB in reachable successors of BB.\n      if (Reachable.count(Successor))\n        Successor->removePredecessor(BB);\n      if (DTU)\n        UniqueSuccessors.insert(Successor);\n    }\n    BB->dropAllReferences();\n    if (DTU) {\n      Instruction *TI = BB->getTerminator();\n      assert(TI && \"Basic block should have a terminator\");\n      // Terminators like invoke can have users. We have to replace their users,\n      // before removing them.\n      if (!TI->use_empty())\n        TI->replaceAllUsesWith(UndefValue::get(TI->getType()));\n      TI->eraseFromParent();\n      new UnreachableInst(BB->getContext(), BB);\n      assert(succ_empty(BB) && \"The successor list of BB isn't empty before \"\n                               \"applying corresponding DTU updates.\");\n      Updates.reserve(Updates.size() + UniqueSuccessors.size());\n      for (auto *UniqueSuccessor : UniqueSuccessors)\n        Updates.push_back({DominatorTree::Delete, BB, UniqueSuccessor});\n    }\n  }\n\n  if (DTU) {\n    DTU->applyUpdates(Updates);\n    for (auto *BB : BlocksToRemove)\n      DTU->deleteBB(BB);\n  } else {\n    for (auto *BB : BlocksToRemove)\n      BB->eraseFromParent();\n  }\n\n  return Changed;\n}\n\nvoid llvm::combineMetadata(Instruction *K, const Instruction *J,\n                           ArrayRef<unsigned> KnownIDs, bool DoesKMove) {\n  SmallVector<std::pair<unsigned, MDNode *>, 4> Metadata;\n  K->dropUnknownNonDebugMetadata(KnownIDs);\n  K->getAllMetadataOtherThanDebugLoc(Metadata);\n  for (const auto &MD : Metadata) {\n    unsigned Kind = MD.first;\n    MDNode *JMD = J->getMetadata(Kind);\n    MDNode *KMD = MD.second;\n\n    switch (Kind) {\n      default:\n        K->setMetadata(Kind, nullptr); // Remove unknown metadata\n        break;\n      case LLVMContext::MD_dbg:\n        llvm_unreachable(\"getAllMetadataOtherThanDebugLoc returned a MD_dbg\");\n      case LLVMContext::MD_tbaa:\n        K->setMetadata(Kind, MDNode::getMostGenericTBAA(JMD, KMD));\n        break;\n      case LLVMContext::MD_alias_scope:\n        K->setMetadata(Kind, MDNode::getMostGenericAliasScope(JMD, KMD));\n        break;\n      case LLVMContext::MD_noalias:\n      case LLVMContext::MD_mem_parallel_loop_access:\n        K->setMetadata(Kind, MDNode::intersect(JMD, KMD));\n        break;\n      case LLVMContext::MD_access_group:\n        K->setMetadata(LLVMContext::MD_access_group,\n                       intersectAccessGroups(K, J));\n        break;\n      case LLVMContext::MD_range:\n\n        // If K does move, use most generic range. Otherwise keep the range of\n        // K.\n        if (DoesKMove)\n          // FIXME: If K does move, we should drop the range info and nonnull.\n          //        Currently this function is used with DoesKMove in passes\n          //        doing hoisting/sinking and the current behavior of using the\n          //        most generic range is correct in those cases.\n          K->setMetadata(Kind, MDNode::getMostGenericRange(JMD, KMD));\n        break;\n      case LLVMContext::MD_fpmath:\n        K->setMetadata(Kind, MDNode::getMostGenericFPMath(JMD, KMD));\n        break;\n      case LLVMContext::MD_invariant_load:\n        // Only set the !invariant.load if it is present in both instructions.\n        K->setMetadata(Kind, JMD);\n        break;\n      case LLVMContext::MD_nonnull:\n        // If K does move, keep nonull if it is present in both instructions.\n        if (DoesKMove)\n          K->setMetadata(Kind, JMD);\n        break;\n      case LLVMContext::MD_invariant_group:\n        // Preserve !invariant.group in K.\n        break;\n      case LLVMContext::MD_align:\n        K->setMetadata(Kind,\n          MDNode::getMostGenericAlignmentOrDereferenceable(JMD, KMD));\n        break;\n      case LLVMContext::MD_dereferenceable:\n      case LLVMContext::MD_dereferenceable_or_null:\n        K->setMetadata(Kind,\n          MDNode::getMostGenericAlignmentOrDereferenceable(JMD, KMD));\n        break;\n      case LLVMContext::MD_preserve_access_index:\n        // Preserve !preserve.access.index in K.\n        break;\n    }\n  }\n  // Set !invariant.group from J if J has it. If both instructions have it\n  // then we will just pick it from J - even when they are different.\n  // Also make sure that K is load or store - f.e. combining bitcast with load\n  // could produce bitcast with invariant.group metadata, which is invalid.\n  // FIXME: we should try to preserve both invariant.group md if they are\n  // different, but right now instruction can only have one invariant.group.\n  if (auto *JMD = J->getMetadata(LLVMContext::MD_invariant_group))\n    if (isa<LoadInst>(K) || isa<StoreInst>(K))\n      K->setMetadata(LLVMContext::MD_invariant_group, JMD);\n}\n\nvoid llvm::combineMetadataForCSE(Instruction *K, const Instruction *J,\n                                 bool KDominatesJ) {\n  unsigned KnownIDs[] = {\n      LLVMContext::MD_tbaa,            LLVMContext::MD_alias_scope,\n      LLVMContext::MD_noalias,         LLVMContext::MD_range,\n      LLVMContext::MD_invariant_load,  LLVMContext::MD_nonnull,\n      LLVMContext::MD_invariant_group, LLVMContext::MD_align,\n      LLVMContext::MD_dereferenceable,\n      LLVMContext::MD_dereferenceable_or_null,\n      LLVMContext::MD_access_group,    LLVMContext::MD_preserve_access_index};\n  combineMetadata(K, J, KnownIDs, KDominatesJ);\n}\n\nvoid llvm::copyMetadataForLoad(LoadInst &Dest, const LoadInst &Source) {\n  SmallVector<std::pair<unsigned, MDNode *>, 8> MD;\n  Source.getAllMetadata(MD);\n  MDBuilder MDB(Dest.getContext());\n  Type *NewType = Dest.getType();\n  const DataLayout &DL = Source.getModule()->getDataLayout();\n  for (const auto &MDPair : MD) {\n    unsigned ID = MDPair.first;\n    MDNode *N = MDPair.second;\n    // Note, essentially every kind of metadata should be preserved here! This\n    // routine is supposed to clone a load instruction changing *only its type*.\n    // The only metadata it makes sense to drop is metadata which is invalidated\n    // when the pointer type changes. This should essentially never be the case\n    // in LLVM, but we explicitly switch over only known metadata to be\n    // conservatively correct. If you are adding metadata to LLVM which pertains\n    // to loads, you almost certainly want to add it here.\n    switch (ID) {\n    case LLVMContext::MD_dbg:\n    case LLVMContext::MD_tbaa:\n    case LLVMContext::MD_prof:\n    case LLVMContext::MD_fpmath:\n    case LLVMContext::MD_tbaa_struct:\n    case LLVMContext::MD_invariant_load:\n    case LLVMContext::MD_alias_scope:\n    case LLVMContext::MD_noalias:\n    case LLVMContext::MD_nontemporal:\n    case LLVMContext::MD_mem_parallel_loop_access:\n    case LLVMContext::MD_access_group:\n      // All of these directly apply.\n      Dest.setMetadata(ID, N);\n      break;\n\n    case LLVMContext::MD_nonnull:\n      copyNonnullMetadata(Source, N, Dest);\n      break;\n\n    case LLVMContext::MD_align:\n    case LLVMContext::MD_dereferenceable:\n    case LLVMContext::MD_dereferenceable_or_null:\n      // These only directly apply if the new type is also a pointer.\n      if (NewType->isPointerTy())\n        Dest.setMetadata(ID, N);\n      break;\n\n    case LLVMContext::MD_range:\n      copyRangeMetadata(DL, Source, N, Dest);\n      break;\n    }\n  }\n}\n\nvoid llvm::patchReplacementInstruction(Instruction *I, Value *Repl) {\n  auto *ReplInst = dyn_cast<Instruction>(Repl);\n  if (!ReplInst)\n    return;\n\n  // Patch the replacement so that it is not more restrictive than the value\n  // being replaced.\n  // Note that if 'I' is a load being replaced by some operation,\n  // for example, by an arithmetic operation, then andIRFlags()\n  // would just erase all math flags from the original arithmetic\n  // operation, which is clearly not wanted and not needed.\n  if (!isa<LoadInst>(I))\n    ReplInst->andIRFlags(I);\n\n  // FIXME: If both the original and replacement value are part of the\n  // same control-flow region (meaning that the execution of one\n  // guarantees the execution of the other), then we can combine the\n  // noalias scopes here and do better than the general conservative\n  // answer used in combineMetadata().\n\n  // In general, GVN unifies expressions over different control-flow\n  // regions, and so we need a conservative combination of the noalias\n  // scopes.\n  static const unsigned KnownIDs[] = {\n      LLVMContext::MD_tbaa,            LLVMContext::MD_alias_scope,\n      LLVMContext::MD_noalias,         LLVMContext::MD_range,\n      LLVMContext::MD_fpmath,          LLVMContext::MD_invariant_load,\n      LLVMContext::MD_invariant_group, LLVMContext::MD_nonnull,\n      LLVMContext::MD_access_group,    LLVMContext::MD_preserve_access_index};\n  combineMetadata(ReplInst, I, KnownIDs, false);\n}\n\ntemplate <typename RootType, typename DominatesFn>\nstatic unsigned replaceDominatedUsesWith(Value *From, Value *To,\n                                         const RootType &Root,\n                                         const DominatesFn &Dominates) {\n  assert(From->getType() == To->getType());\n\n  unsigned Count = 0;\n  for (Value::use_iterator UI = From->use_begin(), UE = From->use_end();\n       UI != UE;) {\n    Use &U = *UI++;\n    if (!Dominates(Root, U))\n      continue;\n    U.set(To);\n    LLVM_DEBUG(dbgs() << \"Replace dominated use of '\" << From->getName()\n                      << \"' as \" << *To << \" in \" << *U << \"\\n\");\n    ++Count;\n  }\n  return Count;\n}\n\nunsigned llvm::replaceNonLocalUsesWith(Instruction *From, Value *To) {\n   assert(From->getType() == To->getType());\n   auto *BB = From->getParent();\n   unsigned Count = 0;\n\n  for (Value::use_iterator UI = From->use_begin(), UE = From->use_end();\n       UI != UE;) {\n    Use &U = *UI++;\n    auto *I = cast<Instruction>(U.getUser());\n    if (I->getParent() == BB)\n      continue;\n    U.set(To);\n    ++Count;\n  }\n  return Count;\n}\n\nunsigned llvm::replaceDominatedUsesWith(Value *From, Value *To,\n                                        DominatorTree &DT,\n                                        const BasicBlockEdge &Root) {\n  auto Dominates = [&DT](const BasicBlockEdge &Root, const Use &U) {\n    return DT.dominates(Root, U);\n  };\n  return ::replaceDominatedUsesWith(From, To, Root, Dominates);\n}\n\nunsigned llvm::replaceDominatedUsesWith(Value *From, Value *To,\n                                        DominatorTree &DT,\n                                        const BasicBlock *BB) {\n  auto Dominates = [&DT](const BasicBlock *BB, const Use &U) {\n    return DT.dominates(BB, U);\n  };\n  return ::replaceDominatedUsesWith(From, To, BB, Dominates);\n}\n\nbool llvm::callsGCLeafFunction(const CallBase *Call,\n                               const TargetLibraryInfo &TLI) {\n  // Check if the function is specifically marked as a gc leaf function.\n  if (Call->hasFnAttr(\"gc-leaf-function\"))\n    return true;\n  if (const Function *F = Call->getCalledFunction()) {\n    if (F->hasFnAttribute(\"gc-leaf-function\"))\n      return true;\n\n    if (auto IID = F->getIntrinsicID()) {\n      // Most LLVM intrinsics do not take safepoints.\n      return IID != Intrinsic::experimental_gc_statepoint &&\n             IID != Intrinsic::experimental_deoptimize &&\n             IID != Intrinsic::memcpy_element_unordered_atomic &&\n             IID != Intrinsic::memmove_element_unordered_atomic;\n    }\n  }\n\n  // Lib calls can be materialized by some passes, and won't be\n  // marked as 'gc-leaf-function.' All available Libcalls are\n  // GC-leaf.\n  LibFunc LF;\n  if (TLI.getLibFunc(*Call, LF)) {\n    return TLI.has(LF);\n  }\n\n  return false;\n}\n\nvoid llvm::copyNonnullMetadata(const LoadInst &OldLI, MDNode *N,\n                               LoadInst &NewLI) {\n  auto *NewTy = NewLI.getType();\n\n  // This only directly applies if the new type is also a pointer.\n  if (NewTy->isPointerTy()) {\n    NewLI.setMetadata(LLVMContext::MD_nonnull, N);\n    return;\n  }\n\n  // The only other translation we can do is to integral loads with !range\n  // metadata.\n  if (!NewTy->isIntegerTy())\n    return;\n\n  MDBuilder MDB(NewLI.getContext());\n  const Value *Ptr = OldLI.getPointerOperand();\n  auto *ITy = cast<IntegerType>(NewTy);\n  auto *NullInt = ConstantExpr::getPtrToInt(\n      ConstantPointerNull::get(cast<PointerType>(Ptr->getType())), ITy);\n  auto *NonNullInt = ConstantExpr::getAdd(NullInt, ConstantInt::get(ITy, 1));\n  NewLI.setMetadata(LLVMContext::MD_range,\n                    MDB.createRange(NonNullInt, NullInt));\n}\n\nvoid llvm::copyRangeMetadata(const DataLayout &DL, const LoadInst &OldLI,\n                             MDNode *N, LoadInst &NewLI) {\n  auto *NewTy = NewLI.getType();\n\n  // Give up unless it is converted to a pointer where there is a single very\n  // valuable mapping we can do reliably.\n  // FIXME: It would be nice to propagate this in more ways, but the type\n  // conversions make it hard.\n  if (!NewTy->isPointerTy())\n    return;\n\n  unsigned BitWidth = DL.getPointerTypeSizeInBits(NewTy);\n  if (!getConstantRangeFromMetadata(*N).contains(APInt(BitWidth, 0))) {\n    MDNode *NN = MDNode::get(OldLI.getContext(), None);\n    NewLI.setMetadata(LLVMContext::MD_nonnull, NN);\n  }\n}\n\nvoid llvm::dropDebugUsers(Instruction &I) {\n  SmallVector<DbgVariableIntrinsic *, 1> DbgUsers;\n  findDbgUsers(DbgUsers, &I);\n  for (auto *DII : DbgUsers)\n    DII->eraseFromParent();\n}\n\nvoid llvm::hoistAllInstructionsInto(BasicBlock *DomBlock, Instruction *InsertPt,\n                                    BasicBlock *BB) {\n  // Since we are moving the instructions out of its basic block, we do not\n  // retain their original debug locations (DILocations) and debug intrinsic\n  // instructions.\n  //\n  // Doing so would degrade the debugging experience and adversely affect the\n  // accuracy of profiling information.\n  //\n  // Currently, when hoisting the instructions, we take the following actions:\n  // - Remove their debug intrinsic instructions.\n  // - Set their debug locations to the values from the insertion point.\n  //\n  // As per PR39141 (comment #8), the more fundamental reason why the dbg.values\n  // need to be deleted, is because there will not be any instructions with a\n  // DILocation in either branch left after performing the transformation. We\n  // can only insert a dbg.value after the two branches are joined again.\n  //\n  // See PR38762, PR39243 for more details.\n  //\n  // TODO: Extend llvm.dbg.value to take more than one SSA Value (PR39141) to\n  // encode predicated DIExpressions that yield different results on different\n  // code paths.\n\n  // A hoisted conditional probe should be treated as dangling so that it will\n  // not be over-counted when the samples collected on the non-conditional path\n  // are counted towards the conditional path. We leave it for the counts\n  // inference algorithm to figure out a proper count for a danglng probe.\n  moveAndDanglePseudoProbes(BB, InsertPt);\n\n  for (BasicBlock::iterator II = BB->begin(), IE = BB->end(); II != IE;) {\n    Instruction *I = &*II;\n    I->dropUnknownNonDebugMetadata();\n    if (I->isUsedByMetadata())\n      dropDebugUsers(*I);\n    if (isa<DbgInfoIntrinsic>(I)) {\n      // Remove DbgInfo Intrinsics.\n      II = I->eraseFromParent();\n      continue;\n    }\n    I->setDebugLoc(InsertPt->getDebugLoc());\n    ++II;\n  }\n  DomBlock->getInstList().splice(InsertPt->getIterator(), BB->getInstList(),\n                                 BB->begin(),\n                                 BB->getTerminator()->getIterator());\n}\n\nnamespace {\n\n/// A potential constituent of a bitreverse or bswap expression. See\n/// collectBitParts for a fuller explanation.\nstruct BitPart {\n  BitPart(Value *P, unsigned BW) : Provider(P) {\n    Provenance.resize(BW);\n  }\n\n  /// The Value that this is a bitreverse/bswap of.\n  Value *Provider;\n\n  /// The \"provenance\" of each bit. Provenance[A] = B means that bit A\n  /// in Provider becomes bit B in the result of this expression.\n  SmallVector<int8_t, 32> Provenance; // int8_t means max size is i128.\n\n  enum { Unset = -1 };\n};\n\n} // end anonymous namespace\n\n/// Analyze the specified subexpression and see if it is capable of providing\n/// pieces of a bswap or bitreverse. The subexpression provides a potential\n/// piece of a bswap or bitreverse if it can be proved that each non-zero bit in\n/// the output of the expression came from a corresponding bit in some other\n/// value. This function is recursive, and the end result is a mapping of\n/// bitnumber to bitnumber. It is the caller's responsibility to validate that\n/// the bitnumber to bitnumber mapping is correct for a bswap or bitreverse.\n///\n/// For example, if the current subexpression if \"(shl i32 %X, 24)\" then we know\n/// that the expression deposits the low byte of %X into the high byte of the\n/// result and that all other bits are zero. This expression is accepted and a\n/// BitPart is returned with Provider set to %X and Provenance[24-31] set to\n/// [0-7].\n///\n/// For vector types, all analysis is performed at the per-element level. No\n/// cross-element analysis is supported (shuffle/insertion/reduction), and all\n/// constant masks must be splatted across all elements.\n///\n/// To avoid revisiting values, the BitPart results are memoized into the\n/// provided map. To avoid unnecessary copying of BitParts, BitParts are\n/// constructed in-place in the \\c BPS map. Because of this \\c BPS needs to\n/// store BitParts objects, not pointers. As we need the concept of a nullptr\n/// BitParts (Value has been analyzed and the analysis failed), we an Optional\n/// type instead to provide the same functionality.\n///\n/// Because we pass around references into \\c BPS, we must use a container that\n/// does not invalidate internal references (std::map instead of DenseMap).\nstatic const Optional<BitPart> &\ncollectBitParts(Value *V, bool MatchBSwaps, bool MatchBitReversals,\n                std::map<Value *, Optional<BitPart>> &BPS, int Depth) {\n  auto I = BPS.find(V);\n  if (I != BPS.end())\n    return I->second;\n\n  auto &Result = BPS[V] = None;\n  auto BitWidth = V->getType()->getScalarSizeInBits();\n\n  // Can't do integer/elements > 128 bits.\n  if (BitWidth > 128)\n    return Result;\n\n  // Prevent stack overflow by limiting the recursion depth\n  if (Depth == BitPartRecursionMaxDepth) {\n    LLVM_DEBUG(dbgs() << \"collectBitParts max recursion depth reached.\\n\");\n    return Result;\n  }\n\n  if (auto *I = dyn_cast<Instruction>(V)) {\n    Value *X, *Y;\n    const APInt *C;\n\n    // If this is an or instruction, it may be an inner node of the bswap.\n    if (match(V, m_Or(m_Value(X), m_Value(Y)))) {\n      const auto &A =\n          collectBitParts(X, MatchBSwaps, MatchBitReversals, BPS, Depth + 1);\n      const auto &B =\n          collectBitParts(Y, MatchBSwaps, MatchBitReversals, BPS, Depth + 1);\n      if (!A || !B)\n        return Result;\n\n      // Try and merge the two together.\n      if (!A->Provider || A->Provider != B->Provider)\n        return Result;\n\n      Result = BitPart(A->Provider, BitWidth);\n      for (unsigned BitIdx = 0; BitIdx < BitWidth; ++BitIdx) {\n        if (A->Provenance[BitIdx] != BitPart::Unset &&\n            B->Provenance[BitIdx] != BitPart::Unset &&\n            A->Provenance[BitIdx] != B->Provenance[BitIdx])\n          return Result = None;\n\n        if (A->Provenance[BitIdx] == BitPart::Unset)\n          Result->Provenance[BitIdx] = B->Provenance[BitIdx];\n        else\n          Result->Provenance[BitIdx] = A->Provenance[BitIdx];\n      }\n\n      return Result;\n    }\n\n    // If this is a logical shift by a constant, recurse then shift the result.\n    if (match(V, m_LogicalShift(m_Value(X), m_APInt(C)))) {\n      const APInt &BitShift = *C;\n\n      // Ensure the shift amount is defined.\n      if (BitShift.uge(BitWidth))\n        return Result;\n\n      const auto &Res =\n          collectBitParts(X, MatchBSwaps, MatchBitReversals, BPS, Depth + 1);\n      if (!Res)\n        return Result;\n      Result = Res;\n\n      // Perform the \"shift\" on BitProvenance.\n      auto &P = Result->Provenance;\n      if (I->getOpcode() == Instruction::Shl) {\n        P.erase(std::prev(P.end(), BitShift.getZExtValue()), P.end());\n        P.insert(P.begin(), BitShift.getZExtValue(), BitPart::Unset);\n      } else {\n        P.erase(P.begin(), std::next(P.begin(), BitShift.getZExtValue()));\n        P.insert(P.end(), BitShift.getZExtValue(), BitPart::Unset);\n      }\n\n      return Result;\n    }\n\n    // If this is a logical 'and' with a mask that clears bits, recurse then\n    // unset the appropriate bits.\n    if (match(V, m_And(m_Value(X), m_APInt(C)))) {\n      const APInt &AndMask = *C;\n\n      // Check that the mask allows a multiple of 8 bits for a bswap, for an\n      // early exit.\n      unsigned NumMaskedBits = AndMask.countPopulation();\n      if (!MatchBitReversals && (NumMaskedBits % 8) != 0)\n        return Result;\n\n      const auto &Res =\n          collectBitParts(X, MatchBSwaps, MatchBitReversals, BPS, Depth + 1);\n      if (!Res)\n        return Result;\n      Result = Res;\n\n      for (unsigned BitIdx = 0; BitIdx < BitWidth; ++BitIdx)\n        // If the AndMask is zero for this bit, clear the bit.\n        if (AndMask[BitIdx] == 0)\n          Result->Provenance[BitIdx] = BitPart::Unset;\n      return Result;\n    }\n\n    // If this is a zext instruction zero extend the result.\n    if (match(V, m_ZExt(m_Value(X)))) {\n      const auto &Res =\n          collectBitParts(X, MatchBSwaps, MatchBitReversals, BPS, Depth + 1);\n      if (!Res)\n        return Result;\n\n      Result = BitPart(Res->Provider, BitWidth);\n      auto NarrowBitWidth = X->getType()->getScalarSizeInBits();\n      for (unsigned BitIdx = 0; BitIdx < NarrowBitWidth; ++BitIdx)\n        Result->Provenance[BitIdx] = Res->Provenance[BitIdx];\n      for (unsigned BitIdx = NarrowBitWidth; BitIdx < BitWidth; ++BitIdx)\n        Result->Provenance[BitIdx] = BitPart::Unset;\n      return Result;\n    }\n\n    // If this is a truncate instruction, extract the lower bits.\n    if (match(V, m_Trunc(m_Value(X)))) {\n      const auto &Res =\n          collectBitParts(X, MatchBSwaps, MatchBitReversals, BPS, Depth + 1);\n      if (!Res)\n        return Result;\n\n      Result = BitPart(Res->Provider, BitWidth);\n      for (unsigned BitIdx = 0; BitIdx < BitWidth; ++BitIdx)\n        Result->Provenance[BitIdx] = Res->Provenance[BitIdx];\n      return Result;\n    }\n\n    // BITREVERSE - most likely due to us previous matching a partial\n    // bitreverse.\n    if (match(V, m_BitReverse(m_Value(X)))) {\n      const auto &Res =\n          collectBitParts(X, MatchBSwaps, MatchBitReversals, BPS, Depth + 1);\n      if (!Res)\n        return Result;\n\n      Result = BitPart(Res->Provider, BitWidth);\n      for (unsigned BitIdx = 0; BitIdx < BitWidth; ++BitIdx)\n        Result->Provenance[(BitWidth - 1) - BitIdx] = Res->Provenance[BitIdx];\n      return Result;\n    }\n\n    // BSWAP - most likely due to us previous matching a partial bswap.\n    if (match(V, m_BSwap(m_Value(X)))) {\n      const auto &Res =\n          collectBitParts(X, MatchBSwaps, MatchBitReversals, BPS, Depth + 1);\n      if (!Res)\n        return Result;\n\n      unsigned ByteWidth = BitWidth / 8;\n      Result = BitPart(Res->Provider, BitWidth);\n      for (unsigned ByteIdx = 0; ByteIdx < ByteWidth; ++ByteIdx) {\n        unsigned ByteBitOfs = ByteIdx * 8;\n        for (unsigned BitIdx = 0; BitIdx < 8; ++BitIdx)\n          Result->Provenance[(BitWidth - 8 - ByteBitOfs) + BitIdx] =\n              Res->Provenance[ByteBitOfs + BitIdx];\n      }\n      return Result;\n    }\n\n    // Funnel 'double' shifts take 3 operands, 2 inputs and the shift\n    // amount (modulo).\n    // fshl(X,Y,Z): (X << (Z % BW)) | (Y >> (BW - (Z % BW)))\n    // fshr(X,Y,Z): (X << (BW - (Z % BW))) | (Y >> (Z % BW))\n    if (match(V, m_FShl(m_Value(X), m_Value(Y), m_APInt(C))) ||\n        match(V, m_FShr(m_Value(X), m_Value(Y), m_APInt(C)))) {\n      // We can treat fshr as a fshl by flipping the modulo amount.\n      unsigned ModAmt = C->urem(BitWidth);\n      if (cast<IntrinsicInst>(I)->getIntrinsicID() == Intrinsic::fshr)\n        ModAmt = BitWidth - ModAmt;\n\n      const auto &LHS =\n          collectBitParts(X, MatchBSwaps, MatchBitReversals, BPS, Depth + 1);\n      const auto &RHS =\n          collectBitParts(Y, MatchBSwaps, MatchBitReversals, BPS, Depth + 1);\n\n      // Check we have both sources and they are from the same provider.\n      if (!LHS || !RHS || !LHS->Provider || LHS->Provider != RHS->Provider)\n        return Result;\n\n      unsigned StartBitRHS = BitWidth - ModAmt;\n      Result = BitPart(LHS->Provider, BitWidth);\n      for (unsigned BitIdx = 0; BitIdx < StartBitRHS; ++BitIdx)\n        Result->Provenance[BitIdx + ModAmt] = LHS->Provenance[BitIdx];\n      for (unsigned BitIdx = 0; BitIdx < ModAmt; ++BitIdx)\n        Result->Provenance[BitIdx] = RHS->Provenance[BitIdx + StartBitRHS];\n      return Result;\n    }\n  }\n\n  // Okay, we got to something that isn't a shift, 'or' or 'and'.  This must be\n  // the input value to the bswap/bitreverse.\n  Result = BitPart(V, BitWidth);\n  for (unsigned BitIdx = 0; BitIdx < BitWidth; ++BitIdx)\n    Result->Provenance[BitIdx] = BitIdx;\n  return Result;\n}\n\nstatic bool bitTransformIsCorrectForBSwap(unsigned From, unsigned To,\n                                          unsigned BitWidth) {\n  if (From % 8 != To % 8)\n    return false;\n  // Convert from bit indices to byte indices and check for a byte reversal.\n  From >>= 3;\n  To >>= 3;\n  BitWidth >>= 3;\n  return From == BitWidth - To - 1;\n}\n\nstatic bool bitTransformIsCorrectForBitReverse(unsigned From, unsigned To,\n                                               unsigned BitWidth) {\n  return From == BitWidth - To - 1;\n}\n\nbool llvm::recognizeBSwapOrBitReverseIdiom(\n    Instruction *I, bool MatchBSwaps, bool MatchBitReversals,\n    SmallVectorImpl<Instruction *> &InsertedInsts) {\n  if (Operator::getOpcode(I) != Instruction::Or)\n    return false;\n  if (!MatchBSwaps && !MatchBitReversals)\n    return false;\n  Type *ITy = I->getType();\n  if (!ITy->isIntOrIntVectorTy() || ITy->getScalarSizeInBits() > 128)\n    return false;  // Can't do integer/elements > 128 bits.\n\n  Type *DemandedTy = ITy;\n  if (I->hasOneUse())\n    if (auto *Trunc = dyn_cast<TruncInst>(I->user_back()))\n      DemandedTy = Trunc->getType();\n\n  // Try to find all the pieces corresponding to the bswap.\n  std::map<Value *, Optional<BitPart>> BPS;\n  auto Res = collectBitParts(I, MatchBSwaps, MatchBitReversals, BPS, 0);\n  if (!Res)\n    return false;\n  ArrayRef<int8_t> BitProvenance = Res->Provenance;\n  assert(all_of(BitProvenance,\n                [](int8_t I) { return I == BitPart::Unset || 0 <= I; }) &&\n         \"Illegal bit provenance index\");\n\n  // If the upper bits are zero, then attempt to perform as a truncated op.\n  if (BitProvenance.back() == BitPart::Unset) {\n    while (!BitProvenance.empty() && BitProvenance.back() == BitPart::Unset)\n      BitProvenance = BitProvenance.drop_back();\n    if (BitProvenance.empty())\n      return false; // TODO - handle null value?\n    DemandedTy = Type::getIntNTy(I->getContext(), BitProvenance.size());\n    if (auto *IVecTy = dyn_cast<VectorType>(ITy))\n      DemandedTy = VectorType::get(DemandedTy, IVecTy);\n  }\n\n  // Check BitProvenance hasn't found a source larger than the result type.\n  unsigned DemandedBW = DemandedTy->getScalarSizeInBits();\n  if (DemandedBW > ITy->getScalarSizeInBits())\n    return false;\n\n  // Now, is the bit permutation correct for a bswap or a bitreverse? We can\n  // only byteswap values with an even number of bytes.\n  APInt DemandedMask = APInt::getAllOnesValue(DemandedBW);\n  bool OKForBSwap = MatchBSwaps && (DemandedBW % 16) == 0;\n  bool OKForBitReverse = MatchBitReversals;\n  for (unsigned BitIdx = 0;\n       (BitIdx < DemandedBW) && (OKForBSwap || OKForBitReverse); ++BitIdx) {\n    if (BitProvenance[BitIdx] == BitPart::Unset) {\n      DemandedMask.clearBit(BitIdx);\n      continue;\n    }\n    OKForBSwap &= bitTransformIsCorrectForBSwap(BitProvenance[BitIdx], BitIdx,\n                                                DemandedBW);\n    OKForBitReverse &= bitTransformIsCorrectForBitReverse(BitProvenance[BitIdx],\n                                                          BitIdx, DemandedBW);\n  }\n\n  Intrinsic::ID Intrin;\n  if (OKForBSwap)\n    Intrin = Intrinsic::bswap;\n  else if (OKForBitReverse)\n    Intrin = Intrinsic::bitreverse;\n  else\n    return false;\n\n  Function *F = Intrinsic::getDeclaration(I->getModule(), Intrin, DemandedTy);\n  Value *Provider = Res->Provider;\n\n  // We may need to truncate the provider.\n  if (DemandedTy != Provider->getType()) {\n    auto *Trunc =\n        CastInst::CreateIntegerCast(Provider, DemandedTy, false, \"trunc\", I);\n    InsertedInsts.push_back(Trunc);\n    Provider = Trunc;\n  }\n\n  Instruction *Result = CallInst::Create(F, Provider, \"rev\", I);\n  InsertedInsts.push_back(Result);\n\n  if (!DemandedMask.isAllOnesValue()) {\n    auto *Mask = ConstantInt::get(DemandedTy, DemandedMask);\n    Result = BinaryOperator::Create(Instruction::And, Result, Mask, \"mask\", I);\n    InsertedInsts.push_back(Result);\n  }\n\n  // We may need to zeroextend back to the result type.\n  if (ITy != Result->getType()) {\n    auto *ExtInst = CastInst::CreateIntegerCast(Result, ITy, false, \"zext\", I);\n    InsertedInsts.push_back(ExtInst);\n  }\n\n  return true;\n}\n\n// CodeGen has special handling for some string functions that may replace\n// them with target-specific intrinsics.  Since that'd skip our interceptors\n// in ASan/MSan/TSan/DFSan, and thus make us miss some memory accesses,\n// we mark affected calls as NoBuiltin, which will disable optimization\n// in CodeGen.\nvoid llvm::maybeMarkSanitizerLibraryCallNoBuiltin(\n    CallInst *CI, const TargetLibraryInfo *TLI) {\n  Function *F = CI->getCalledFunction();\n  LibFunc Func;\n  if (F && !F->hasLocalLinkage() && F->hasName() &&\n      TLI->getLibFunc(F->getName(), Func) && TLI->hasOptimizedCodeGen(Func) &&\n      !F->doesNotAccessMemory())\n    CI->addAttribute(AttributeList::FunctionIndex, Attribute::NoBuiltin);\n}\n\nbool llvm::canReplaceOperandWithVariable(const Instruction *I, unsigned OpIdx) {\n  // We can't have a PHI with a metadata type.\n  if (I->getOperand(OpIdx)->getType()->isMetadataTy())\n    return false;\n\n  // Early exit.\n  if (!isa<Constant>(I->getOperand(OpIdx)))\n    return true;\n\n  switch (I->getOpcode()) {\n  default:\n    return true;\n  case Instruction::Call:\n  case Instruction::Invoke: {\n    const auto &CB = cast<CallBase>(*I);\n\n    // Can't handle inline asm. Skip it.\n    if (CB.isInlineAsm())\n      return false;\n\n    // Constant bundle operands may need to retain their constant-ness for\n    // correctness.\n    if (CB.isBundleOperand(OpIdx))\n      return false;\n\n    if (OpIdx < CB.getNumArgOperands()) {\n      // Some variadic intrinsics require constants in the variadic arguments,\n      // which currently aren't markable as immarg.\n      if (isa<IntrinsicInst>(CB) &&\n          OpIdx >= CB.getFunctionType()->getNumParams()) {\n        // This is known to be OK for stackmap.\n        return CB.getIntrinsicID() == Intrinsic::experimental_stackmap;\n      }\n\n      // gcroot is a special case, since it requires a constant argument which\n      // isn't also required to be a simple ConstantInt.\n      if (CB.getIntrinsicID() == Intrinsic::gcroot)\n        return false;\n\n      // Some intrinsic operands are required to be immediates.\n      return !CB.paramHasAttr(OpIdx, Attribute::ImmArg);\n    }\n\n    // It is never allowed to replace the call argument to an intrinsic, but it\n    // may be possible for a call.\n    return !isa<IntrinsicInst>(CB);\n  }\n  case Instruction::ShuffleVector:\n    // Shufflevector masks are constant.\n    return OpIdx != 2;\n  case Instruction::Switch:\n  case Instruction::ExtractValue:\n    // All operands apart from the first are constant.\n    return OpIdx == 0;\n  case Instruction::InsertValue:\n    // All operands apart from the first and the second are constant.\n    return OpIdx < 2;\n  case Instruction::Alloca:\n    // Static allocas (constant size in the entry block) are handled by\n    // prologue/epilogue insertion so they're free anyway. We definitely don't\n    // want to make them non-constant.\n    return !cast<AllocaInst>(I)->isStaticAlloca();\n  case Instruction::GetElementPtr:\n    if (OpIdx == 0)\n      return true;\n    gep_type_iterator It = gep_type_begin(I);\n    for (auto E = std::next(It, OpIdx); It != E; ++It)\n      if (It.isStruct())\n        return false;\n    return true;\n  }\n}\n\nValue *llvm::invertCondition(Value *Condition) {\n  // First: Check if it's a constant\n  if (Constant *C = dyn_cast<Constant>(Condition))\n    return ConstantExpr::getNot(C);\n\n  // Second: If the condition is already inverted, return the original value\n  Value *NotCondition;\n  if (match(Condition, m_Not(m_Value(NotCondition))))\n    return NotCondition;\n\n  BasicBlock *Parent = nullptr;\n  Instruction *Inst = dyn_cast<Instruction>(Condition);\n  if (Inst)\n    Parent = Inst->getParent();\n  else if (Argument *Arg = dyn_cast<Argument>(Condition))\n    Parent = &Arg->getParent()->getEntryBlock();\n  assert(Parent && \"Unsupported condition to invert\");\n\n  // Third: Check all the users for an invert\n  for (User *U : Condition->users())\n    if (Instruction *I = dyn_cast<Instruction>(U))\n      if (I->getParent() == Parent && match(I, m_Not(m_Specific(Condition))))\n        return I;\n\n  // Last option: Create a new instruction\n  auto *Inverted =\n      BinaryOperator::CreateNot(Condition, Condition->getName() + \".inv\");\n  if (Inst && !isa<PHINode>(Inst))\n    Inverted->insertAfter(Inst);\n  else\n    Inverted->insertBefore(&*Parent->getFirstInsertionPt());\n  return Inverted;\n}\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 97, "line": 2908}, "message": "'BitPart' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Utils/Local.cpp", "reportHash": "9ff4f72169f72ef2de168837894b4f73", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
