<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/clang/unittests/Format/FormatTest.cpp", "content": "//===- unittest/Format/FormatTest.cpp - Formatting unit tests -------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/Format/Format.h\"\n\n#include \"../Tooling/ReplacementTest.h\"\n#include \"FormatTestUtils.h\"\n\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"gtest/gtest.h\"\n\n#define DEBUG_TYPE \"format-test\"\n\nusing clang::tooling::ReplacementTest;\nusing clang::tooling::toReplacements;\nusing testing::internal::ScopedTrace;\n\nnamespace clang {\nnamespace format {\nnamespace {\n\nFormatStyle getGoogleStyle() { return getGoogleStyle(FormatStyle::LK_Cpp); }\n\nclass FormatTest : public ::testing::Test {\nprotected:\n  enum StatusCheck { SC_ExpectComplete, SC_ExpectIncomplete, SC_DoNotCheck };\n\n  std::string format(llvm::StringRef Code,\n                     const FormatStyle &Style = getLLVMStyle(),\n                     StatusCheck CheckComplete = SC_ExpectComplete) {\n    LLVM_DEBUG(llvm::errs() << \"---\\n\");\n    LLVM_DEBUG(llvm::errs() << Code << \"\\n\\n\");\n    std::vector<tooling::Range> Ranges(1, tooling::Range(0, Code.size()));\n    FormattingAttemptStatus Status;\n    tooling::Replacements Replaces =\n        reformat(Style, Code, Ranges, \"<stdin>\", &Status);\n    if (CheckComplete != SC_DoNotCheck) {\n      bool ExpectedCompleteFormat = CheckComplete == SC_ExpectComplete;\n      EXPECT_EQ(ExpectedCompleteFormat, Status.FormatComplete)\n          << Code << \"\\n\\n\";\n    }\n    ReplacementCount = Replaces.size();\n    auto Result = applyAllReplacements(Code, Replaces);\n    EXPECT_TRUE(static_cast<bool>(Result));\n    LLVM_DEBUG(llvm::errs() << \"\\n\" << *Result << \"\\n\\n\");\n    return *Result;\n  }\n\n  FormatStyle getStyleWithColumns(FormatStyle Style, unsigned ColumnLimit) {\n    Style.ColumnLimit = ColumnLimit;\n    return Style;\n  }\n\n  FormatStyle getLLVMStyleWithColumns(unsigned ColumnLimit) {\n    return getStyleWithColumns(getLLVMStyle(), ColumnLimit);\n  }\n\n  FormatStyle getGoogleStyleWithColumns(unsigned ColumnLimit) {\n    return getStyleWithColumns(getGoogleStyle(), ColumnLimit);\n  }\n\n  void _verifyFormat(const char *File, int Line, llvm::StringRef Expected,\n                     llvm::StringRef Code,\n                     const FormatStyle &Style = getLLVMStyle()) {\n    ScopedTrace t(File, Line, ::testing::Message() << Code.str());\n    EXPECT_EQ(Expected.str(), format(Expected, Style))\n        << \"Expected code is not stable\";\n    EXPECT_EQ(Expected.str(), format(Code, Style));\n    if (Style.Language == FormatStyle::LK_Cpp) {\n      // Objective-C++ is a superset of C++, so everything checked for C++\n      // needs to be checked for Objective-C++ as well.\n      FormatStyle ObjCStyle = Style;\n      ObjCStyle.Language = FormatStyle::LK_ObjC;\n      EXPECT_EQ(Expected.str(), format(test::messUp(Code), ObjCStyle));\n    }\n  }\n\n  void _verifyFormat(const char *File, int Line, llvm::StringRef Code,\n                     const FormatStyle &Style = getLLVMStyle()) {\n    _verifyFormat(File, Line, Code, test::messUp(Code), Style);\n  }\n\n  void _verifyIncompleteFormat(const char *File, int Line, llvm::StringRef Code,\n                               const FormatStyle &Style = getLLVMStyle()) {\n    ScopedTrace t(File, Line, ::testing::Message() << Code.str());\n    EXPECT_EQ(Code.str(),\n              format(test::messUp(Code), Style, SC_ExpectIncomplete));\n  }\n\n  void _verifyIndependentOfContext(const char *File, int Line,\n                                   llvm::StringRef Text,\n                                   const FormatStyle &Style = getLLVMStyle()) {\n    _verifyFormat(File, Line, Text, Style);\n    _verifyFormat(File, Line, llvm::Twine(\"void f() { \" + Text + \" }\").str(),\n                  Style);\n  }\n\n  /// \\brief Verify that clang-format does not crash on the given input.\n  void verifyNoCrash(llvm::StringRef Code,\n                     const FormatStyle &Style = getLLVMStyle()) {\n    format(Code, Style, SC_DoNotCheck);\n  }\n\n  int ReplacementCount;\n};\n\n#define verifyIndependentOfContext(...)                                        \\\n  _verifyIndependentOfContext(__FILE__, __LINE__, __VA_ARGS__)\n#define verifyIncompleteFormat(...)                                            \\\n  _verifyIncompleteFormat(__FILE__, __LINE__, __VA_ARGS__)\n#define verifyFormat(...) _verifyFormat(__FILE__, __LINE__, __VA_ARGS__)\n#define verifyGoogleFormat(Code) verifyFormat(Code, getGoogleStyle())\n\nTEST_F(FormatTest, MessUp) {\n  EXPECT_EQ(\"1 2 3\", test::messUp(\"1 2 3\"));\n  EXPECT_EQ(\"1 2 3\\n\", test::messUp(\"1\\n2\\n3\\n\"));\n  EXPECT_EQ(\"a\\n//b\\nc\", test::messUp(\"a\\n//b\\nc\"));\n  EXPECT_EQ(\"a\\n#b\\nc\", test::messUp(\"a\\n#b\\nc\"));\n  EXPECT_EQ(\"a\\n#b c d\\ne\", test::messUp(\"a\\n#b\\\\\\nc\\\\\\nd\\ne\"));\n}\n\nTEST_F(FormatTest, DefaultLLVMStyleIsCpp) {\n  EXPECT_EQ(FormatStyle::LK_Cpp, getLLVMStyle().Language);\n}\n\nTEST_F(FormatTest, LLVMStyleOverride) {\n  EXPECT_EQ(FormatStyle::LK_Proto,\n            getLLVMStyle(FormatStyle::LK_Proto).Language);\n}\n\n//===----------------------------------------------------------------------===//\n// Basic function tests.\n//===----------------------------------------------------------------------===//\n\nTEST_F(FormatTest, DoesNotChangeCorrectlyFormattedCode) {\n  EXPECT_EQ(\";\", format(\";\"));\n}\n\nTEST_F(FormatTest, FormatsGlobalStatementsAt0) {\n  EXPECT_EQ(\"int i;\", format(\"  int i;\"));\n  EXPECT_EQ(\"\\nint i;\", format(\" \\n\\t \\v \\f  int i;\"));\n  EXPECT_EQ(\"int i;\\nint j;\", format(\"    int i; int j;\"));\n  EXPECT_EQ(\"int i;\\nint j;\", format(\"    int i;\\n  int j;\"));\n}\n\nTEST_F(FormatTest, FormatsUnwrappedLinesAtFirstFormat) {\n  EXPECT_EQ(\"int i;\", format(\"int\\ni;\"));\n}\n\nTEST_F(FormatTest, FormatsNestedBlockStatements) {\n  EXPECT_EQ(\"{\\n  {\\n    {}\\n  }\\n}\", format(\"{{{}}}\"));\n}\n\nTEST_F(FormatTest, FormatsNestedCall) {\n  verifyFormat(\"Method(f1, f2(f3));\");\n  verifyFormat(\"Method(f1(f2, f3()));\");\n  verifyFormat(\"Method(f1(f2, (f3())));\");\n}\n\nTEST_F(FormatTest, NestedNameSpecifiers) {\n  verifyFormat(\"vector<::Type> v;\");\n  verifyFormat(\"::ns::SomeFunction(::ns::SomeOtherFunction())\");\n  verifyFormat(\"static constexpr bool Bar = decltype(bar())::value;\");\n  verifyFormat(\"static constexpr bool Bar = typeof(bar())::value;\");\n  verifyFormat(\"static constexpr bool Bar = __underlying_type(bar())::value;\");\n  verifyFormat(\"static constexpr bool Bar = _Atomic(bar())::value;\");\n  verifyFormat(\"bool a = 2 < ::SomeFunction();\");\n  verifyFormat(\"ALWAYS_INLINE ::std::string getName();\");\n  verifyFormat(\"some::string getName();\");\n}\n\nTEST_F(FormatTest, OnlyGeneratesNecessaryReplacements) {\n  EXPECT_EQ(\"if (a) {\\n\"\n            \"  f();\\n\"\n            \"}\",\n            format(\"if(a){f();}\"));\n  EXPECT_EQ(4, ReplacementCount);\n  EXPECT_EQ(\"if (a) {\\n\"\n            \"  f();\\n\"\n            \"}\",\n            format(\"if (a) {\\n\"\n                   \"  f();\\n\"\n                   \"}\"));\n  EXPECT_EQ(0, ReplacementCount);\n  EXPECT_EQ(\"/*\\r\\n\"\n            \"\\r\\n\"\n            \"*/\\r\\n\",\n            format(\"/*\\r\\n\"\n                   \"\\r\\n\"\n                   \"*/\\r\\n\"));\n  EXPECT_EQ(0, ReplacementCount);\n}\n\nTEST_F(FormatTest, RemovesEmptyLines) {\n  EXPECT_EQ(\"class C {\\n\"\n            \"  int i;\\n\"\n            \"};\",\n            format(\"class C {\\n\"\n                   \" int i;\\n\"\n                   \"\\n\"\n                   \"};\"));\n\n  // Don't remove empty lines at the start of namespaces or extern \"C\" blocks.\n  EXPECT_EQ(\"namespace N {\\n\"\n            \"\\n\"\n            \"int i;\\n\"\n            \"}\",\n            format(\"namespace N {\\n\"\n                   \"\\n\"\n                   \"int    i;\\n\"\n                   \"}\",\n                   getGoogleStyle()));\n  EXPECT_EQ(\"/* something */ namespace N {\\n\"\n            \"\\n\"\n            \"int i;\\n\"\n            \"}\",\n            format(\"/* something */ namespace N {\\n\"\n                   \"\\n\"\n                   \"int    i;\\n\"\n                   \"}\",\n                   getGoogleStyle()));\n  EXPECT_EQ(\"inline namespace N {\\n\"\n            \"\\n\"\n            \"int i;\\n\"\n            \"}\",\n            format(\"inline namespace N {\\n\"\n                   \"\\n\"\n                   \"int    i;\\n\"\n                   \"}\",\n                   getGoogleStyle()));\n  EXPECT_EQ(\"/* something */ inline namespace N {\\n\"\n            \"\\n\"\n            \"int i;\\n\"\n            \"}\",\n            format(\"/* something */ inline namespace N {\\n\"\n                   \"\\n\"\n                   \"int    i;\\n\"\n                   \"}\",\n                   getGoogleStyle()));\n  EXPECT_EQ(\"export namespace N {\\n\"\n            \"\\n\"\n            \"int i;\\n\"\n            \"}\",\n            format(\"export namespace N {\\n\"\n                   \"\\n\"\n                   \"int    i;\\n\"\n                   \"}\",\n                   getGoogleStyle()));\n  EXPECT_EQ(\"extern /**/ \\\"C\\\" /**/ {\\n\"\n            \"\\n\"\n            \"int i;\\n\"\n            \"}\",\n            format(\"extern /**/ \\\"C\\\" /**/ {\\n\"\n                   \"\\n\"\n                   \"int    i;\\n\"\n                   \"}\",\n                   getGoogleStyle()));\n\n  // ...but do keep inlining and removing empty lines for non-block extern \"C\"\n  // functions.\n  verifyFormat(\"extern \\\"C\\\" int f() { return 42; }\", getGoogleStyle());\n  EXPECT_EQ(\"extern \\\"C\\\" int f() {\\n\"\n            \"  int i = 42;\\n\"\n            \"  return i;\\n\"\n            \"}\",\n            format(\"extern \\\"C\\\" int f() {\\n\"\n                   \"\\n\"\n                   \"  int i = 42;\\n\"\n                   \"  return i;\\n\"\n                   \"}\",\n                   getGoogleStyle()));\n\n  // Remove empty lines at the beginning and end of blocks.\n  EXPECT_EQ(\"void f() {\\n\"\n            \"\\n\"\n            \"  if (a) {\\n\"\n            \"\\n\"\n            \"    f();\\n\"\n            \"  }\\n\"\n            \"}\",\n            format(\"void f() {\\n\"\n                   \"\\n\"\n                   \"  if (a) {\\n\"\n                   \"\\n\"\n                   \"    f();\\n\"\n                   \"\\n\"\n                   \"  }\\n\"\n                   \"\\n\"\n                   \"}\",\n                   getLLVMStyle()));\n  EXPECT_EQ(\"void f() {\\n\"\n            \"  if (a) {\\n\"\n            \"    f();\\n\"\n            \"  }\\n\"\n            \"}\",\n            format(\"void f() {\\n\"\n                   \"\\n\"\n                   \"  if (a) {\\n\"\n                   \"\\n\"\n                   \"    f();\\n\"\n                   \"\\n\"\n                   \"  }\\n\"\n                   \"\\n\"\n                   \"}\",\n                   getGoogleStyle()));\n\n  // Don't remove empty lines in more complex control statements.\n  EXPECT_EQ(\"void f() {\\n\"\n            \"  if (a) {\\n\"\n            \"    f();\\n\"\n            \"\\n\"\n            \"  } else if (b) {\\n\"\n            \"    f();\\n\"\n            \"  }\\n\"\n            \"}\",\n            format(\"void f() {\\n\"\n                   \"  if (a) {\\n\"\n                   \"    f();\\n\"\n                   \"\\n\"\n                   \"  } else if (b) {\\n\"\n                   \"    f();\\n\"\n                   \"\\n\"\n                   \"  }\\n\"\n                   \"\\n\"\n                   \"}\"));\n\n  // Don't remove empty lines before namespace endings.\n  FormatStyle LLVMWithNoNamespaceFix = getLLVMStyle();\n  LLVMWithNoNamespaceFix.FixNamespaceComments = false;\n  EXPECT_EQ(\"namespace {\\n\"\n            \"int i;\\n\"\n            \"\\n\"\n            \"}\",\n            format(\"namespace {\\n\"\n                   \"int i;\\n\"\n                   \"\\n\"\n                   \"}\",\n                   LLVMWithNoNamespaceFix));\n  EXPECT_EQ(\"namespace {\\n\"\n            \"int i;\\n\"\n            \"}\",\n            format(\"namespace {\\n\"\n                   \"int i;\\n\"\n                   \"}\",\n                   LLVMWithNoNamespaceFix));\n  EXPECT_EQ(\"namespace {\\n\"\n            \"int i;\\n\"\n            \"\\n\"\n            \"};\",\n            format(\"namespace {\\n\"\n                   \"int i;\\n\"\n                   \"\\n\"\n                   \"};\",\n                   LLVMWithNoNamespaceFix));\n  EXPECT_EQ(\"namespace {\\n\"\n            \"int i;\\n\"\n            \"};\",\n            format(\"namespace {\\n\"\n                   \"int i;\\n\"\n                   \"};\",\n                   LLVMWithNoNamespaceFix));\n  EXPECT_EQ(\"namespace {\\n\"\n            \"int i;\\n\"\n            \"\\n\"\n            \"}\",\n            format(\"namespace {\\n\"\n                   \"int i;\\n\"\n                   \"\\n\"\n                   \"}\"));\n  EXPECT_EQ(\"namespace {\\n\"\n            \"int i;\\n\"\n            \"\\n\"\n            \"} // namespace\",\n            format(\"namespace {\\n\"\n                   \"int i;\\n\"\n                   \"\\n\"\n                   \"}  // namespace\"));\n\n  FormatStyle Style = getLLVMStyle();\n  Style.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_All;\n  Style.MaxEmptyLinesToKeep = 2;\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.AfterClass = true;\n  Style.BraceWrapping.AfterFunction = true;\n  Style.KeepEmptyLinesAtTheStartOfBlocks = false;\n\n  EXPECT_EQ(\"class Foo\\n\"\n            \"{\\n\"\n            \"  Foo() {}\\n\"\n            \"\\n\"\n            \"  void funk() {}\\n\"\n            \"};\",\n            format(\"class Foo\\n\"\n                   \"{\\n\"\n                   \"  Foo()\\n\"\n                   \"  {\\n\"\n                   \"  }\\n\"\n                   \"\\n\"\n                   \"  void funk() {}\\n\"\n                   \"};\",\n                   Style));\n}\n\nTEST_F(FormatTest, RecognizesBinaryOperatorKeywords) {\n  verifyFormat(\"x = (a) and (b);\");\n  verifyFormat(\"x = (a) or (b);\");\n  verifyFormat(\"x = (a) bitand (b);\");\n  verifyFormat(\"x = (a) bitor (b);\");\n  verifyFormat(\"x = (a) not_eq (b);\");\n  verifyFormat(\"x = (a) and_eq (b);\");\n  verifyFormat(\"x = (a) or_eq (b);\");\n  verifyFormat(\"x = (a) xor (b);\");\n}\n\nTEST_F(FormatTest, RecognizesUnaryOperatorKeywords) {\n  verifyFormat(\"x = compl(a);\");\n  verifyFormat(\"x = not(a);\");\n  verifyFormat(\"x = bitand(a);\");\n  // Unary operator must not be merged with the next identifier\n  verifyFormat(\"x = compl a;\");\n  verifyFormat(\"x = not a;\");\n  verifyFormat(\"x = bitand a;\");\n}\n\n//===----------------------------------------------------------------------===//\n// Tests for control statements.\n//===----------------------------------------------------------------------===//\n\nTEST_F(FormatTest, FormatIfWithoutCompoundStatement) {\n  verifyFormat(\"if (true)\\n  f();\\ng();\");\n  verifyFormat(\"if (a)\\n  if (b)\\n    if (c)\\n      g();\\nh();\");\n  verifyFormat(\"if (a)\\n  if (b) {\\n    f();\\n  }\\ng();\");\n  verifyFormat(\"if constexpr (true)\\n\"\n               \"  f();\\ng();\");\n  verifyFormat(\"if CONSTEXPR (true)\\n\"\n               \"  f();\\ng();\");\n  verifyFormat(\"if constexpr (a)\\n\"\n               \"  if constexpr (b)\\n\"\n               \"    if constexpr (c)\\n\"\n               \"      g();\\n\"\n               \"h();\");\n  verifyFormat(\"if CONSTEXPR (a)\\n\"\n               \"  if CONSTEXPR (b)\\n\"\n               \"    if CONSTEXPR (c)\\n\"\n               \"      g();\\n\"\n               \"h();\");\n  verifyFormat(\"if constexpr (a)\\n\"\n               \"  if constexpr (b) {\\n\"\n               \"    f();\\n\"\n               \"  }\\n\"\n               \"g();\");\n  verifyFormat(\"if CONSTEXPR (a)\\n\"\n               \"  if CONSTEXPR (b) {\\n\"\n               \"    f();\\n\"\n               \"  }\\n\"\n               \"g();\");\n\n  FormatStyle AllowsMergedIf = getLLVMStyle();\n  AllowsMergedIf.AlignEscapedNewlines = FormatStyle::ENAS_Left;\n  AllowsMergedIf.AllowShortIfStatementsOnASingleLine =\n      FormatStyle::SIS_WithoutElse;\n  verifyFormat(\"if (a)\\n\"\n               \"  // comment\\n\"\n               \"  f();\",\n               AllowsMergedIf);\n  verifyFormat(\"{\\n\"\n               \"  if (a)\\n\"\n               \"  label:\\n\"\n               \"    f();\\n\"\n               \"}\",\n               AllowsMergedIf);\n  verifyFormat(\"#define A \\\\\\n\"\n               \"  if (a)  \\\\\\n\"\n               \"  label:  \\\\\\n\"\n               \"    f()\",\n               AllowsMergedIf);\n  verifyFormat(\"if (a)\\n\"\n               \"  ;\",\n               AllowsMergedIf);\n  verifyFormat(\"if (a)\\n\"\n               \"  if (b) return;\",\n               AllowsMergedIf);\n\n  verifyFormat(\"if (a) // Can't merge this\\n\"\n               \"  f();\\n\",\n               AllowsMergedIf);\n  verifyFormat(\"if (a) /* still don't merge */\\n\"\n               \"  f();\",\n               AllowsMergedIf);\n  verifyFormat(\"if (a) { // Never merge this\\n\"\n               \"  f();\\n\"\n               \"}\",\n               AllowsMergedIf);\n  verifyFormat(\"if (a) { /* Never merge this */\\n\"\n               \"  f();\\n\"\n               \"}\",\n               AllowsMergedIf);\n\n  AllowsMergedIf.ColumnLimit = 14;\n  verifyFormat(\"if (a) return;\", AllowsMergedIf);\n  verifyFormat(\"if (aaaaaaaaa)\\n\"\n               \"  return;\",\n               AllowsMergedIf);\n\n  AllowsMergedIf.ColumnLimit = 13;\n  verifyFormat(\"if (a)\\n  return;\", AllowsMergedIf);\n}\n\nTEST_F(FormatTest, FormatIfWithoutCompoundStatementButElseWith) {\n  FormatStyle AllowsMergedIf = getLLVMStyle();\n  AllowsMergedIf.AlignEscapedNewlines = FormatStyle::ENAS_Left;\n  AllowsMergedIf.AllowShortIfStatementsOnASingleLine =\n      FormatStyle::SIS_WithoutElse;\n  verifyFormat(\"if (a)\\n\"\n               \"  f();\\n\"\n               \"else {\\n\"\n               \"  g();\\n\"\n               \"}\",\n               AllowsMergedIf);\n  verifyFormat(\"if (a)\\n\"\n               \"  f();\\n\"\n               \"else\\n\"\n               \"  g();\\n\",\n               AllowsMergedIf);\n\n  AllowsMergedIf.AllowShortIfStatementsOnASingleLine = FormatStyle::SIS_Always;\n\n  verifyFormat(\"if (a) f();\\n\"\n               \"else {\\n\"\n               \"  g();\\n\"\n               \"}\",\n               AllowsMergedIf);\n  verifyFormat(\"if (a) f();\\n\"\n               \"else {\\n\"\n               \"  if (a) f();\\n\"\n               \"  else {\\n\"\n               \"    g();\\n\"\n               \"  }\\n\"\n               \"  g();\\n\"\n               \"}\",\n               AllowsMergedIf);\n}\n\nTEST_F(FormatTest, FormatLoopsWithoutCompoundStatement) {\n  FormatStyle AllowsMergedLoops = getLLVMStyle();\n  AllowsMergedLoops.AllowShortLoopsOnASingleLine = true;\n  verifyFormat(\"while (true) continue;\", AllowsMergedLoops);\n  verifyFormat(\"for (;;) continue;\", AllowsMergedLoops);\n  verifyFormat(\"for (int &v : vec) v *= 2;\", AllowsMergedLoops);\n  verifyFormat(\"while (true)\\n\"\n               \"  ;\",\n               AllowsMergedLoops);\n  verifyFormat(\"for (;;)\\n\"\n               \"  ;\",\n               AllowsMergedLoops);\n  verifyFormat(\"for (;;)\\n\"\n               \"  for (;;) continue;\",\n               AllowsMergedLoops);\n  verifyFormat(\"for (;;) // Can't merge this\\n\"\n               \"  continue;\",\n               AllowsMergedLoops);\n  verifyFormat(\"for (;;) /* still don't merge */\\n\"\n               \"  continue;\",\n               AllowsMergedLoops);\n  verifyFormat(\"do a++;\\n\"\n               \"while (true);\",\n               AllowsMergedLoops);\n  verifyFormat(\"do /* Don't merge */\\n\"\n               \"  a++;\\n\"\n               \"while (true);\",\n               AllowsMergedLoops);\n  verifyFormat(\"do // Don't merge\\n\"\n               \"  a++;\\n\"\n               \"while (true);\",\n               AllowsMergedLoops);\n  verifyFormat(\"do\\n\"\n               \"  // Don't merge\\n\"\n               \"  a++;\\n\"\n               \"while (true);\",\n               AllowsMergedLoops);\n  // Without braces labels are interpreted differently.\n  verifyFormat(\"{\\n\"\n               \"  do\\n\"\n               \"  label:\\n\"\n               \"    a++;\\n\"\n               \"  while (true);\\n\"\n               \"}\",\n               AllowsMergedLoops);\n}\n\nTEST_F(FormatTest, FormatShortBracedStatements) {\n  FormatStyle AllowSimpleBracedStatements = getLLVMStyle();\n  AllowSimpleBracedStatements.ColumnLimit = 40;\n  AllowSimpleBracedStatements.AllowShortBlocksOnASingleLine =\n      FormatStyle::SBS_Always;\n\n  AllowSimpleBracedStatements.AllowShortIfStatementsOnASingleLine =\n      FormatStyle::SIS_WithoutElse;\n  AllowSimpleBracedStatements.AllowShortLoopsOnASingleLine = true;\n\n  AllowSimpleBracedStatements.BreakBeforeBraces = FormatStyle::BS_Custom;\n  AllowSimpleBracedStatements.BraceWrapping.AfterFunction = true;\n  AllowSimpleBracedStatements.BraceWrapping.SplitEmptyRecord = false;\n\n  verifyFormat(\"if (true) {}\", AllowSimpleBracedStatements);\n  verifyFormat(\"if constexpr (true) {}\", AllowSimpleBracedStatements);\n  verifyFormat(\"if CONSTEXPR (true) {}\", AllowSimpleBracedStatements);\n  verifyFormat(\"while (true) {}\", AllowSimpleBracedStatements);\n  verifyFormat(\"for (;;) {}\", AllowSimpleBracedStatements);\n  verifyFormat(\"if (true) { f(); }\", AllowSimpleBracedStatements);\n  verifyFormat(\"if constexpr (true) { f(); }\", AllowSimpleBracedStatements);\n  verifyFormat(\"if CONSTEXPR (true) { f(); }\", AllowSimpleBracedStatements);\n  verifyFormat(\"while (true) { f(); }\", AllowSimpleBracedStatements);\n  verifyFormat(\"for (;;) { f(); }\", AllowSimpleBracedStatements);\n  verifyFormat(\"if (true) { fffffffffffffffffffffff(); }\",\n               AllowSimpleBracedStatements);\n  verifyFormat(\"if (true) {\\n\"\n               \"  ffffffffffffffffffffffff();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n  verifyFormat(\"if (true) {\\n\"\n               \"  ffffffffffffffffffffffffffffffffffffffffffffffffffffff();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n  verifyFormat(\"if (true) { //\\n\"\n               \"  f();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n  verifyFormat(\"if (true) {\\n\"\n               \"  f();\\n\"\n               \"  f();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n  verifyFormat(\"if (true) {\\n\"\n               \"  f();\\n\"\n               \"} else {\\n\"\n               \"  f();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n\n  verifyFormat(\"struct A2 {\\n\"\n               \"  int X;\\n\"\n               \"};\",\n               AllowSimpleBracedStatements);\n  verifyFormat(\"typedef struct A2 {\\n\"\n               \"  int X;\\n\"\n               \"} A2_t;\",\n               AllowSimpleBracedStatements);\n  verifyFormat(\"template <int> struct A2 {\\n\"\n               \"  struct B {};\\n\"\n               \"};\",\n               AllowSimpleBracedStatements);\n\n  AllowSimpleBracedStatements.AllowShortIfStatementsOnASingleLine =\n      FormatStyle::SIS_Never;\n  verifyFormat(\"if (true) {}\", AllowSimpleBracedStatements);\n  verifyFormat(\"if (true) {\\n\"\n               \"  f();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n  verifyFormat(\"if (true) {\\n\"\n               \"  f();\\n\"\n               \"} else {\\n\"\n               \"  f();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n\n  AllowSimpleBracedStatements.AllowShortLoopsOnASingleLine = false;\n  verifyFormat(\"while (true) {}\", AllowSimpleBracedStatements);\n  verifyFormat(\"while (true) {\\n\"\n               \"  f();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n  verifyFormat(\"for (;;) {}\", AllowSimpleBracedStatements);\n  verifyFormat(\"for (;;) {\\n\"\n               \"  f();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n\n  AllowSimpleBracedStatements.AllowShortIfStatementsOnASingleLine =\n      FormatStyle::SIS_WithoutElse;\n  AllowSimpleBracedStatements.AllowShortLoopsOnASingleLine = true;\n  AllowSimpleBracedStatements.BraceWrapping.AfterControlStatement =\n      FormatStyle::BWACS_Always;\n\n  verifyFormat(\"if (true) {}\", AllowSimpleBracedStatements);\n  verifyFormat(\"if constexpr (true) {}\", AllowSimpleBracedStatements);\n  verifyFormat(\"if CONSTEXPR (true) {}\", AllowSimpleBracedStatements);\n  verifyFormat(\"while (true) {}\", AllowSimpleBracedStatements);\n  verifyFormat(\"for (;;) {}\", AllowSimpleBracedStatements);\n  verifyFormat(\"if (true) { f(); }\", AllowSimpleBracedStatements);\n  verifyFormat(\"if constexpr (true) { f(); }\", AllowSimpleBracedStatements);\n  verifyFormat(\"if CONSTEXPR (true) { f(); }\", AllowSimpleBracedStatements);\n  verifyFormat(\"while (true) { f(); }\", AllowSimpleBracedStatements);\n  verifyFormat(\"for (;;) { f(); }\", AllowSimpleBracedStatements);\n  verifyFormat(\"if (true) { fffffffffffffffffffffff(); }\",\n               AllowSimpleBracedStatements);\n  verifyFormat(\"if (true)\\n\"\n               \"{\\n\"\n               \"  ffffffffffffffffffffffff();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n  verifyFormat(\"if (true)\\n\"\n               \"{\\n\"\n               \"  ffffffffffffffffffffffffffffffffffffffffffffffffffffff();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n  verifyFormat(\"if (true)\\n\"\n               \"{ //\\n\"\n               \"  f();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n  verifyFormat(\"if (true)\\n\"\n               \"{\\n\"\n               \"  f();\\n\"\n               \"  f();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n  verifyFormat(\"if (true)\\n\"\n               \"{\\n\"\n               \"  f();\\n\"\n               \"} else\\n\"\n               \"{\\n\"\n               \"  f();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n\n  AllowSimpleBracedStatements.AllowShortIfStatementsOnASingleLine =\n      FormatStyle::SIS_Never;\n  verifyFormat(\"if (true) {}\", AllowSimpleBracedStatements);\n  verifyFormat(\"if (true)\\n\"\n               \"{\\n\"\n               \"  f();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n  verifyFormat(\"if (true)\\n\"\n               \"{\\n\"\n               \"  f();\\n\"\n               \"} else\\n\"\n               \"{\\n\"\n               \"  f();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n\n  AllowSimpleBracedStatements.AllowShortLoopsOnASingleLine = false;\n  verifyFormat(\"while (true) {}\", AllowSimpleBracedStatements);\n  verifyFormat(\"while (true)\\n\"\n               \"{\\n\"\n               \"  f();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n  verifyFormat(\"for (;;) {}\", AllowSimpleBracedStatements);\n  verifyFormat(\"for (;;)\\n\"\n               \"{\\n\"\n               \"  f();\\n\"\n               \"}\",\n               AllowSimpleBracedStatements);\n}\n\nTEST_F(FormatTest, ShortBlocksInMacrosDontMergeWithCodeAfterMacro) {\n  FormatStyle Style = getLLVMStyleWithColumns(60);\n  Style.AllowShortBlocksOnASingleLine = FormatStyle::SBS_Always;\n  Style.AllowShortIfStatementsOnASingleLine = FormatStyle::SIS_WithoutElse;\n  Style.BreakBeforeBraces = FormatStyle::BS_Allman;\n  EXPECT_EQ(\"#define A                                                  \\\\\\n\"\n            \"  if (HANDLEwernufrnuLwrmviferuvnierv)                     \\\\\\n\"\n            \"  {                                                        \\\\\\n\"\n            \"    RET_ERR1_ANUIREUINERUIFNIOAerwfwrvnuier;               \\\\\\n\"\n            \"  }\\n\"\n            \"X;\",\n            format(\"#define A \\\\\\n\"\n                   \"   if (HANDLEwernufrnuLwrmviferuvnierv) { \\\\\\n\"\n                   \"      RET_ERR1_ANUIREUINERUIFNIOAerwfwrvnuier; \\\\\\n\"\n                   \"   }\\n\"\n                   \"X;\",\n                   Style));\n}\n\nTEST_F(FormatTest, ParseIfElse) {\n  verifyFormat(\"if (true)\\n\"\n               \"  if (true)\\n\"\n               \"    if (true)\\n\"\n               \"      f();\\n\"\n               \"    else\\n\"\n               \"      g();\\n\"\n               \"  else\\n\"\n               \"    h();\\n\"\n               \"else\\n\"\n               \"  i();\");\n  verifyFormat(\"if (true)\\n\"\n               \"  if (true)\\n\"\n               \"    if (true) {\\n\"\n               \"      if (true)\\n\"\n               \"        f();\\n\"\n               \"    } else {\\n\"\n               \"      g();\\n\"\n               \"    }\\n\"\n               \"  else\\n\"\n               \"    h();\\n\"\n               \"else {\\n\"\n               \"  i();\\n\"\n               \"}\");\n  verifyFormat(\"if (true)\\n\"\n               \"  if constexpr (true)\\n\"\n               \"    if (true) {\\n\"\n               \"      if constexpr (true)\\n\"\n               \"        f();\\n\"\n               \"    } else {\\n\"\n               \"      g();\\n\"\n               \"    }\\n\"\n               \"  else\\n\"\n               \"    h();\\n\"\n               \"else {\\n\"\n               \"  i();\\n\"\n               \"}\");\n  verifyFormat(\"if (true)\\n\"\n               \"  if CONSTEXPR (true)\\n\"\n               \"    if (true) {\\n\"\n               \"      if CONSTEXPR (true)\\n\"\n               \"        f();\\n\"\n               \"    } else {\\n\"\n               \"      g();\\n\"\n               \"    }\\n\"\n               \"  else\\n\"\n               \"    h();\\n\"\n               \"else {\\n\"\n               \"  i();\\n\"\n               \"}\");\n  verifyFormat(\"void f() {\\n\"\n               \"  if (a) {\\n\"\n               \"  } else {\\n\"\n               \"  }\\n\"\n               \"}\");\n}\n\nTEST_F(FormatTest, ElseIf) {\n  verifyFormat(\"if (a) {\\n} else if (b) {\\n}\");\n  verifyFormat(\"if (a)\\n\"\n               \"  f();\\n\"\n               \"else if (b)\\n\"\n               \"  g();\\n\"\n               \"else\\n\"\n               \"  h();\");\n  verifyFormat(\"if constexpr (a)\\n\"\n               \"  f();\\n\"\n               \"else if constexpr (b)\\n\"\n               \"  g();\\n\"\n               \"else\\n\"\n               \"  h();\");\n  verifyFormat(\"if CONSTEXPR (a)\\n\"\n               \"  f();\\n\"\n               \"else if CONSTEXPR (b)\\n\"\n               \"  g();\\n\"\n               \"else\\n\"\n               \"  h();\");\n  verifyFormat(\"if (a) {\\n\"\n               \"  f();\\n\"\n               \"}\\n\"\n               \"// or else ..\\n\"\n               \"else {\\n\"\n               \"  g()\\n\"\n               \"}\");\n\n  verifyFormat(\"if (a) {\\n\"\n               \"} else if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"               aaaaaaaaaaaaaaaaaaaaaaaaaaaa)) {\\n\"\n               \"}\");\n  verifyFormat(\"if (a) {\\n\"\n               \"} else if constexpr (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"                         aaaaaaaaaaaaaaaaaaaaaaaaaaaa)) {\\n\"\n               \"}\");\n  verifyFormat(\"if (a) {\\n\"\n               \"} else if CONSTEXPR (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"                         aaaaaaaaaaaaaaaaaaaaaaaaaaaa)) {\\n\"\n               \"}\");\n  verifyFormat(\"if (a) {\\n\"\n               \"} else if (\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {\\n\"\n               \"}\",\n               getLLVMStyleWithColumns(62));\n  verifyFormat(\"if (a) {\\n\"\n               \"} else if constexpr (\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {\\n\"\n               \"}\",\n               getLLVMStyleWithColumns(62));\n  verifyFormat(\"if (a) {\\n\"\n               \"} else if CONSTEXPR (\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {\\n\"\n               \"}\",\n               getLLVMStyleWithColumns(62));\n}\n\nTEST_F(FormatTest, FormatsForLoop) {\n  verifyFormat(\n      \"for (int VeryVeryLongLoopVariable = 0; VeryVeryLongLoopVariable < 10;\\n\"\n      \"     ++VeryVeryLongLoopVariable)\\n\"\n      \"  ;\");\n  verifyFormat(\"for (;;)\\n\"\n               \"  f();\");\n  verifyFormat(\"for (;;) {\\n}\");\n  verifyFormat(\"for (;;) {\\n\"\n               \"  f();\\n\"\n               \"}\");\n  verifyFormat(\"for (int i = 0; (i < 10); ++i) {\\n}\");\n\n  verifyFormat(\n      \"for (std::vector<UnwrappedLine>::iterator I = UnwrappedLines.begin(),\\n\"\n      \"                                          E = UnwrappedLines.end();\\n\"\n      \"     I != E; ++I) {\\n}\");\n\n  verifyFormat(\n      \"for (MachineFun::iterator IIII = PrevIt, EEEE = F.end(); IIII != EEEE;\\n\"\n      \"     ++IIIII) {\\n}\");\n  verifyFormat(\"for (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaa =\\n\"\n               \"         aaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaa;\\n\"\n               \"     aaaaaaaaaaa != aaaaaaaaaaaaaaaaaaa; ++aaaaaaaaaaa) {\\n}\");\n  verifyFormat(\"for (llvm::ArrayRef<NamedDecl *>::iterator\\n\"\n               \"         I = FD->getDeclsInPrototypeScope().begin(),\\n\"\n               \"         E = FD->getDeclsInPrototypeScope().end();\\n\"\n               \"     I != E; ++I) {\\n}\");\n  verifyFormat(\"for (SmallVectorImpl<TemplateIdAnnotationn *>::iterator\\n\"\n               \"         I = Container.begin(),\\n\"\n               \"         E = Container.end();\\n\"\n               \"     I != E; ++I) {\\n}\",\n               getLLVMStyleWithColumns(76));\n\n  verifyFormat(\n      \"for (aaaaaaaaaaaaaaaaa aaaaaaaaaaa = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\\n\"\n      \"     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa !=\\n\"\n      \"     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"         aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\\n\"\n      \"     ++aaaaaaaaaaa) {\\n}\");\n  verifyFormat(\"for (int i = 0; i < aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ||\\n\"\n               \"                bbbbbbbbbbbbbbbbbbbb < ccccccccccccccc;\\n\"\n               \"     ++i) {\\n}\");\n  verifyFormat(\"for (int aaaaaaaaaaa = 1; aaaaaaaaaaa <= bbbbbbbbbbbbbbb;\\n\"\n               \"     aaaaaaaaaaa++, bbbbbbbbbbbbbbbbb++) {\\n\"\n               \"}\");\n  verifyFormat(\"for (some_namespace::SomeIterator iter( // force break\\n\"\n               \"         aaaaaaaaaa);\\n\"\n               \"     iter; ++iter) {\\n\"\n               \"}\");\n  verifyFormat(\"for (auto aaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"         aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\\n\"\n               \"     aaaaaaaaaaaaaaaaaaaaaaaaaaa != bbbbbbbbbbbbbbbbbbbbbbb;\\n\"\n               \"     ++aaaaaaaaaaaaaaaaaaaaaaaaaaa) {\");\n\n  // These should not be formatted as Objective-C for-in loops.\n  verifyFormat(\"for (Foo *x = 0; x != in; x++) {\\n}\");\n  verifyFormat(\"Foo *x;\\nfor (x = 0; x != in; x++) {\\n}\");\n  verifyFormat(\"Foo *x;\\nfor (x in y) {\\n}\");\n  verifyFormat(\n      \"for (const Foo<Bar> &baz = in.value(); !baz.at_end(); ++baz) {\\n}\");\n\n  FormatStyle NoBinPacking = getLLVMStyle();\n  NoBinPacking.BinPackParameters = false;\n  verifyFormat(\"for (int aaaaaaaaaaa = 1;\\n\"\n               \"     aaaaaaaaaaa <= aaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaa,\\n\"\n               \"                                           aaaaaaaaaaaaaaaa,\\n\"\n               \"                                           aaaaaaaaaaaaaaaa,\\n\"\n               \"                                           aaaaaaaaaaaaaaaa);\\n\"\n               \"     aaaaaaaaaaa++, bbbbbbbbbbbbbbbbb++) {\\n\"\n               \"}\",\n               NoBinPacking);\n  verifyFormat(\n      \"for (std::vector<UnwrappedLine>::iterator I = UnwrappedLines.begin(),\\n\"\n      \"                                          E = UnwrappedLines.end();\\n\"\n      \"     I != E;\\n\"\n      \"     ++I) {\\n}\",\n      NoBinPacking);\n\n  FormatStyle AlignLeft = getLLVMStyle();\n  AlignLeft.PointerAlignment = FormatStyle::PAS_Left;\n  verifyFormat(\"for (A* a = start; a < end; ++a, ++value) {\\n}\", AlignLeft);\n}\n\nTEST_F(FormatTest, RangeBasedForLoops) {\n  verifyFormat(\"for (auto aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa :\\n\"\n               \"     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {\\n}\");\n  verifyFormat(\"for (auto aaaaaaaaaaaaaaaaaaaaa :\\n\"\n               \"     aaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaa, aaaaaaaaaaaaa)) {\\n}\");\n  verifyFormat(\"for (const aaaaaaaaaaaaaaaaaaaaa &aaaaaaaaa :\\n\"\n               \"     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {\\n}\");\n  verifyFormat(\"for (aaaaaaaaa aaaaaaaaaaaaaaaaaaaaa :\\n\"\n               \"     aaaaaaaaaaaa.aaaaaaaaaaaa().aaaaaaaaa().a()) {\\n}\");\n}\n\nTEST_F(FormatTest, ForEachLoops) {\n  verifyFormat(\"void f() {\\n\"\n               \"  foreach (Item *item, itemlist) {}\\n\"\n               \"  Q_FOREACH (Item *item, itemlist) {}\\n\"\n               \"  BOOST_FOREACH (Item *item, itemlist) {}\\n\"\n               \"  UNKNOWN_FORACH(Item * item, itemlist) {}\\n\"\n               \"}\");\n\n  FormatStyle Style = getLLVMStyle();\n  Style.SpaceBeforeParens =\n      FormatStyle::SBPO_ControlStatementsExceptForEachMacros;\n  verifyFormat(\"void f() {\\n\"\n               \"  foreach(Item *item, itemlist) {}\\n\"\n               \"  Q_FOREACH(Item *item, itemlist) {}\\n\"\n               \"  BOOST_FOREACH(Item *item, itemlist) {}\\n\"\n               \"  UNKNOWN_FORACH(Item * item, itemlist) {}\\n\"\n               \"}\",\n               Style);\n\n  // As function-like macros.\n  verifyFormat(\"#define foreach(x, y)\\n\"\n               \"#define Q_FOREACH(x, y)\\n\"\n               \"#define BOOST_FOREACH(x, y)\\n\"\n               \"#define UNKNOWN_FOREACH(x, y)\\n\");\n\n  // Not as function-like macros.\n  verifyFormat(\"#define foreach (x, y)\\n\"\n               \"#define Q_FOREACH (x, y)\\n\"\n               \"#define BOOST_FOREACH (x, y)\\n\"\n               \"#define UNKNOWN_FOREACH (x, y)\\n\");\n\n  // handle microsoft non standard extension\n  verifyFormat(\"for each (char c in x->MyStringProperty)\");\n}\n\nTEST_F(FormatTest, FormatsWhileLoop) {\n  verifyFormat(\"while (true) {\\n}\");\n  verifyFormat(\"while (true)\\n\"\n               \"  f();\");\n  verifyFormat(\"while () {\\n}\");\n  verifyFormat(\"while () {\\n\"\n               \"  f();\\n\"\n               \"}\");\n}\n\nTEST_F(FormatTest, FormatsDoWhile) {\n  verifyFormat(\"do {\\n\"\n               \"  do_something();\\n\"\n               \"} while (something());\");\n  verifyFormat(\"do\\n\"\n               \"  do_something();\\n\"\n               \"while (something());\");\n}\n\nTEST_F(FormatTest, FormatsSwitchStatement) {\n  verifyFormat(\"switch (x) {\\n\"\n               \"case 1:\\n\"\n               \"  f();\\n\"\n               \"  break;\\n\"\n               \"case kFoo:\\n\"\n               \"case ns::kBar:\\n\"\n               \"case kBaz:\\n\"\n               \"  break;\\n\"\n               \"default:\\n\"\n               \"  g();\\n\"\n               \"  break;\\n\"\n               \"}\");\n  verifyFormat(\"switch (x) {\\n\"\n               \"case 1: {\\n\"\n               \"  f();\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"case 2: {\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"}\");\n  verifyFormat(\"switch (x) {\\n\"\n               \"case 1: {\\n\"\n               \"  f();\\n\"\n               \"  {\\n\"\n               \"    g();\\n\"\n               \"    h();\\n\"\n               \"  }\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"}\");\n  verifyFormat(\"switch (x) {\\n\"\n               \"case 1: {\\n\"\n               \"  f();\\n\"\n               \"  if (foo) {\\n\"\n               \"    g();\\n\"\n               \"    h();\\n\"\n               \"  }\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"}\");\n  verifyFormat(\"switch (x) {\\n\"\n               \"case 1: {\\n\"\n               \"  f();\\n\"\n               \"  g();\\n\"\n               \"} break;\\n\"\n               \"}\");\n  verifyFormat(\"switch (test)\\n\"\n               \"  ;\");\n  verifyFormat(\"switch (x) {\\n\"\n               \"default: {\\n\"\n               \"  // Do nothing.\\n\"\n               \"}\\n\"\n               \"}\");\n  verifyFormat(\"switch (x) {\\n\"\n               \"// comment\\n\"\n               \"// if 1, do f()\\n\"\n               \"case 1:\\n\"\n               \"  f();\\n\"\n               \"}\");\n  verifyFormat(\"switch (x) {\\n\"\n               \"case 1:\\n\"\n               \"  // Do amazing stuff\\n\"\n               \"  {\\n\"\n               \"    f();\\n\"\n               \"    g();\\n\"\n               \"  }\\n\"\n               \"  break;\\n\"\n               \"}\");\n  verifyFormat(\"#define A          \\\\\\n\"\n               \"  switch (x) {     \\\\\\n\"\n               \"  case a:          \\\\\\n\"\n               \"    foo = b;       \\\\\\n\"\n               \"  }\",\n               getLLVMStyleWithColumns(20));\n  verifyFormat(\"#define OPERATION_CASE(name)           \\\\\\n\"\n               \"  case OP_name:                        \\\\\\n\"\n               \"    return operations::Operation##name\\n\",\n               getLLVMStyleWithColumns(40));\n  verifyFormat(\"switch (x) {\\n\"\n               \"case 1:;\\n\"\n               \"default:;\\n\"\n               \"  int i;\\n\"\n               \"}\");\n\n  verifyGoogleFormat(\"switch (x) {\\n\"\n                     \"  case 1:\\n\"\n                     \"    f();\\n\"\n                     \"    break;\\n\"\n                     \"  case kFoo:\\n\"\n                     \"  case ns::kBar:\\n\"\n                     \"  case kBaz:\\n\"\n                     \"    break;\\n\"\n                     \"  default:\\n\"\n                     \"    g();\\n\"\n                     \"    break;\\n\"\n                     \"}\");\n  verifyGoogleFormat(\"switch (x) {\\n\"\n                     \"  case 1: {\\n\"\n                     \"    f();\\n\"\n                     \"    break;\\n\"\n                     \"  }\\n\"\n                     \"}\");\n  verifyGoogleFormat(\"switch (test)\\n\"\n                     \"  ;\");\n\n  verifyGoogleFormat(\"#define OPERATION_CASE(name) \\\\\\n\"\n                     \"  case OP_name:              \\\\\\n\"\n                     \"    return operations::Operation##name\\n\");\n  verifyGoogleFormat(\"Operation codeToOperation(OperationCode OpCode) {\\n\"\n                     \"  // Get the correction operation class.\\n\"\n                     \"  switch (OpCode) {\\n\"\n                     \"    CASE(Add);\\n\"\n                     \"    CASE(Subtract);\\n\"\n                     \"    default:\\n\"\n                     \"      return operations::Unknown;\\n\"\n                     \"  }\\n\"\n                     \"#undef OPERATION_CASE\\n\"\n                     \"}\");\n  verifyFormat(\"DEBUG({\\n\"\n               \"  switch (x) {\\n\"\n               \"  case A:\\n\"\n               \"    f();\\n\"\n               \"    break;\\n\"\n               \"    // fallthrough\\n\"\n               \"  case B:\\n\"\n               \"    g();\\n\"\n               \"    break;\\n\"\n               \"  }\\n\"\n               \"});\");\n  EXPECT_EQ(\"DEBUG({\\n\"\n            \"  switch (x) {\\n\"\n            \"  case A:\\n\"\n            \"    f();\\n\"\n            \"    break;\\n\"\n            \"  // On B:\\n\"\n            \"  case B:\\n\"\n            \"    g();\\n\"\n            \"    break;\\n\"\n            \"  }\\n\"\n            \"});\",\n            format(\"DEBUG({\\n\"\n                   \"  switch (x) {\\n\"\n                   \"  case A:\\n\"\n                   \"    f();\\n\"\n                   \"    break;\\n\"\n                   \"  // On B:\\n\"\n                   \"  case B:\\n\"\n                   \"    g();\\n\"\n                   \"    break;\\n\"\n                   \"  }\\n\"\n                   \"});\",\n                   getLLVMStyle()));\n  EXPECT_EQ(\"switch (n) {\\n\"\n            \"case 0: {\\n\"\n            \"  return false;\\n\"\n            \"}\\n\"\n            \"default: {\\n\"\n            \"  return true;\\n\"\n            \"}\\n\"\n            \"}\",\n            format(\"switch (n)\\n\"\n                   \"{\\n\"\n                   \"case 0: {\\n\"\n                   \"  return false;\\n\"\n                   \"}\\n\"\n                   \"default: {\\n\"\n                   \"  return true;\\n\"\n                   \"}\\n\"\n                   \"}\",\n                   getLLVMStyle()));\n  verifyFormat(\"switch (a) {\\n\"\n               \"case (b):\\n\"\n               \"  return;\\n\"\n               \"}\");\n\n  verifyFormat(\"switch (a) {\\n\"\n               \"case some_namespace::\\n\"\n               \"    some_constant:\\n\"\n               \"  return;\\n\"\n               \"}\",\n               getLLVMStyleWithColumns(34));\n\n  FormatStyle Style = getLLVMStyle();\n  Style.IndentCaseLabels = true;\n  Style.AllowShortBlocksOnASingleLine = FormatStyle::SBS_Never;\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.AfterCaseLabel = true;\n  Style.BraceWrapping.AfterControlStatement = FormatStyle::BWACS_Always;\n  EXPECT_EQ(\"switch (n)\\n\"\n            \"{\\n\"\n            \"  case 0:\\n\"\n            \"  {\\n\"\n            \"    return false;\\n\"\n            \"  }\\n\"\n            \"  default:\\n\"\n            \"  {\\n\"\n            \"    return true;\\n\"\n            \"  }\\n\"\n            \"}\",\n            format(\"switch (n) {\\n\"\n                   \"  case 0: {\\n\"\n                   \"    return false;\\n\"\n                   \"  }\\n\"\n                   \"  default: {\\n\"\n                   \"    return true;\\n\"\n                   \"  }\\n\"\n                   \"}\",\n                   Style));\n  Style.BraceWrapping.AfterCaseLabel = false;\n  EXPECT_EQ(\"switch (n)\\n\"\n            \"{\\n\"\n            \"  case 0: {\\n\"\n            \"    return false;\\n\"\n            \"  }\\n\"\n            \"  default: {\\n\"\n            \"    return true;\\n\"\n            \"  }\\n\"\n            \"}\",\n            format(\"switch (n) {\\n\"\n                   \"  case 0:\\n\"\n                   \"  {\\n\"\n                   \"    return false;\\n\"\n                   \"  }\\n\"\n                   \"  default:\\n\"\n                   \"  {\\n\"\n                   \"    return true;\\n\"\n                   \"  }\\n\"\n                   \"}\",\n                   Style));\n  Style.IndentCaseLabels = false;\n  Style.IndentCaseBlocks = true;\n  EXPECT_EQ(\"switch (n)\\n\"\n            \"{\\n\"\n            \"case 0:\\n\"\n            \"  {\\n\"\n            \"    return false;\\n\"\n            \"  }\\n\"\n            \"case 1:\\n\"\n            \"  break;\\n\"\n            \"default:\\n\"\n            \"  {\\n\"\n            \"    return true;\\n\"\n            \"  }\\n\"\n            \"}\",\n            format(\"switch (n) {\\n\"\n                   \"case 0: {\\n\"\n                   \"  return false;\\n\"\n                   \"}\\n\"\n                   \"case 1:\\n\"\n                   \"  break;\\n\"\n                   \"default: {\\n\"\n                   \"  return true;\\n\"\n                   \"}\\n\"\n                   \"}\",\n                   Style));\n  Style.IndentCaseLabels = true;\n  Style.IndentCaseBlocks = true;\n  EXPECT_EQ(\"switch (n)\\n\"\n            \"{\\n\"\n            \"  case 0:\\n\"\n            \"    {\\n\"\n            \"      return false;\\n\"\n            \"    }\\n\"\n            \"  case 1:\\n\"\n            \"    break;\\n\"\n            \"  default:\\n\"\n            \"    {\\n\"\n            \"      return true;\\n\"\n            \"    }\\n\"\n            \"}\",\n            format(\"switch (n) {\\n\"\n                   \"case 0: {\\n\"\n                   \"  return false;\\n\"\n                   \"}\\n\"\n                   \"case 1:\\n\"\n                   \"  break;\\n\"\n                   \"default: {\\n\"\n                   \"  return true;\\n\"\n                   \"}\\n\"\n                   \"}\",\n                   Style));\n}\n\nTEST_F(FormatTest, CaseRanges) {\n  verifyFormat(\"switch (x) {\\n\"\n               \"case 'A' ... 'Z':\\n\"\n               \"case 1 ... 5:\\n\"\n               \"case a ... b:\\n\"\n               \"  break;\\n\"\n               \"}\");\n}\n\nTEST_F(FormatTest, ShortEnums) {\n  FormatStyle Style = getLLVMStyle();\n  Style.AllowShortEnumsOnASingleLine = true;\n  verifyFormat(\"enum { A, B, C } ShortEnum1, ShortEnum2;\", Style);\n  Style.AllowShortEnumsOnASingleLine = false;\n  verifyFormat(\"enum\\n\"\n               \"{\\n\"\n               \"  A,\\n\"\n               \"  B,\\n\"\n               \"  C\\n\"\n               \"} ShortEnum1, ShortEnum2;\",\n               Style);\n}\n\nTEST_F(FormatTest, ShortCaseLabels) {\n  FormatStyle Style = getLLVMStyle();\n  Style.AllowShortCaseLabelsOnASingleLine = true;\n  verifyFormat(\"switch (a) {\\n\"\n               \"case 1: x = 1; break;\\n\"\n               \"case 2: return;\\n\"\n               \"case 3:\\n\"\n               \"case 4:\\n\"\n               \"case 5: return;\\n\"\n               \"case 6: // comment\\n\"\n               \"  return;\\n\"\n               \"case 7:\\n\"\n               \"  // comment\\n\"\n               \"  return;\\n\"\n               \"case 8:\\n\"\n               \"  x = 8; // comment\\n\"\n               \"  break;\\n\"\n               \"default: y = 1; break;\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"switch (a) {\\n\"\n               \"case 0: return; // comment\\n\"\n               \"case 1: break;  // comment\\n\"\n               \"case 2: return;\\n\"\n               \"// comment\\n\"\n               \"case 3: return;\\n\"\n               \"// comment 1\\n\"\n               \"// comment 2\\n\"\n               \"// comment 3\\n\"\n               \"case 4: break; /* comment */\\n\"\n               \"case 5:\\n\"\n               \"  // comment\\n\"\n               \"  break;\\n\"\n               \"case 6: /* comment */ x = 1; break;\\n\"\n               \"case 7: x = /* comment */ 1; break;\\n\"\n               \"case 8:\\n\"\n               \"  x = 1; /* comment */\\n\"\n               \"  break;\\n\"\n               \"case 9:\\n\"\n               \"  break; // comment line 1\\n\"\n               \"         // comment line 2\\n\"\n               \"}\",\n               Style);\n  EXPECT_EQ(\"switch (a) {\\n\"\n            \"case 1:\\n\"\n            \"  x = 8;\\n\"\n            \"  // fall through\\n\"\n            \"case 2: x = 8;\\n\"\n            \"// comment\\n\"\n            \"case 3:\\n\"\n            \"  return; /* comment line 1\\n\"\n            \"           * comment line 2 */\\n\"\n            \"case 4: i = 8;\\n\"\n            \"// something else\\n\"\n            \"#if FOO\\n\"\n            \"case 5: break;\\n\"\n            \"#endif\\n\"\n            \"}\",\n            format(\"switch (a) {\\n\"\n                   \"case 1: x = 8;\\n\"\n                   \"  // fall through\\n\"\n                   \"case 2:\\n\"\n                   \"  x = 8;\\n\"\n                   \"// comment\\n\"\n                   \"case 3:\\n\"\n                   \"  return; /* comment line 1\\n\"\n                   \"           * comment line 2 */\\n\"\n                   \"case 4:\\n\"\n                   \"  i = 8;\\n\"\n                   \"// something else\\n\"\n                   \"#if FOO\\n\"\n                   \"case 5: break;\\n\"\n                   \"#endif\\n\"\n                   \"}\",\n                   Style));\n  EXPECT_EQ(\"switch (a) {\\n\"\n            \"case 0:\\n\"\n            \"  return; // long long long long long long long long long long \"\n            \"long long comment\\n\"\n            \"          // line\\n\"\n            \"}\",\n            format(\"switch (a) {\\n\"\n                   \"case 0: return; // long long long long long long long long \"\n                   \"long long long long comment line\\n\"\n                   \"}\",\n                   Style));\n  EXPECT_EQ(\"switch (a) {\\n\"\n            \"case 0:\\n\"\n            \"  return; /* long long long long long long long long long long \"\n            \"long long comment\\n\"\n            \"             line */\\n\"\n            \"}\",\n            format(\"switch (a) {\\n\"\n                   \"case 0: return; /* long long long long long long long long \"\n                   \"long long long long comment line */\\n\"\n                   \"}\",\n                   Style));\n  verifyFormat(\"switch (a) {\\n\"\n               \"#if FOO\\n\"\n               \"case 0: return 0;\\n\"\n               \"#endif\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"switch (a) {\\n\"\n               \"case 1: {\\n\"\n               \"}\\n\"\n               \"case 2: {\\n\"\n               \"  return;\\n\"\n               \"}\\n\"\n               \"case 3: {\\n\"\n               \"  x = 1;\\n\"\n               \"  return;\\n\"\n               \"}\\n\"\n               \"case 4:\\n\"\n               \"  if (x)\\n\"\n               \"    return;\\n\"\n               \"}\",\n               Style);\n  Style.ColumnLimit = 21;\n  verifyFormat(\"switch (a) {\\n\"\n               \"case 1: x = 1; break;\\n\"\n               \"case 2: return;\\n\"\n               \"case 3:\\n\"\n               \"case 4:\\n\"\n               \"case 5: return;\\n\"\n               \"default:\\n\"\n               \"  y = 1;\\n\"\n               \"  break;\\n\"\n               \"}\",\n               Style);\n  Style.ColumnLimit = 80;\n  Style.AllowShortCaseLabelsOnASingleLine = false;\n  Style.IndentCaseLabels = true;\n  EXPECT_EQ(\"switch (n) {\\n\"\n            \"  default /*comments*/:\\n\"\n            \"    return true;\\n\"\n            \"  case 0:\\n\"\n            \"    return false;\\n\"\n            \"}\",\n            format(\"switch (n) {\\n\"\n                   \"default/*comments*/:\\n\"\n                   \"  return true;\\n\"\n                   \"case 0:\\n\"\n                   \"  return false;\\n\"\n                   \"}\",\n                   Style));\n  Style.AllowShortCaseLabelsOnASingleLine = true;\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.AfterCaseLabel = true;\n  Style.BraceWrapping.AfterControlStatement = FormatStyle::BWACS_Always;\n  EXPECT_EQ(\"switch (n)\\n\"\n            \"{\\n\"\n            \"  case 0:\\n\"\n            \"  {\\n\"\n            \"    return false;\\n\"\n            \"  }\\n\"\n            \"  default:\\n\"\n            \"  {\\n\"\n            \"    return true;\\n\"\n            \"  }\\n\"\n            \"}\",\n            format(\"switch (n) {\\n\"\n                   \"  case 0: {\\n\"\n                   \"    return false;\\n\"\n                   \"  }\\n\"\n                   \"  default:\\n\"\n                   \"  {\\n\"\n                   \"    return true;\\n\"\n                   \"  }\\n\"\n                   \"}\",\n                   Style));\n}\n\nTEST_F(FormatTest, FormatsLabels) {\n  verifyFormat(\"void f() {\\n\"\n               \"  some_code();\\n\"\n               \"test_label:\\n\"\n               \"  some_other_code();\\n\"\n               \"  {\\n\"\n               \"    some_more_code();\\n\"\n               \"  another_label:\\n\"\n               \"    some_more_code();\\n\"\n               \"  }\\n\"\n               \"}\");\n  verifyFormat(\"{\\n\"\n               \"  some_code();\\n\"\n               \"test_label:\\n\"\n               \"  some_other_code();\\n\"\n               \"}\");\n  verifyFormat(\"{\\n\"\n               \"  some_code();\\n\"\n               \"test_label:;\\n\"\n               \"  int i = 0;\\n\"\n               \"}\");\n  FormatStyle Style = getLLVMStyle();\n  Style.IndentGotoLabels = false;\n  verifyFormat(\"void f() {\\n\"\n               \"  some_code();\\n\"\n               \"test_label:\\n\"\n               \"  some_other_code();\\n\"\n               \"  {\\n\"\n               \"    some_more_code();\\n\"\n               \"another_label:\\n\"\n               \"    some_more_code();\\n\"\n               \"  }\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"{\\n\"\n               \"  some_code();\\n\"\n               \"test_label:\\n\"\n               \"  some_other_code();\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"{\\n\"\n               \"  some_code();\\n\"\n               \"test_label:;\\n\"\n               \"  int i = 0;\\n\"\n               \"}\");\n}\n\nTEST_F(FormatTest, MultiLineControlStatements) {\n  FormatStyle Style = getLLVMStyle();\n  Style.BreakBeforeBraces = FormatStyle::BraceBreakingStyle::BS_Custom;\n  Style.BraceWrapping.AfterControlStatement = FormatStyle::BWACS_MultiLine;\n  Style.ColumnLimit = 20;\n  // Short lines should keep opening brace on same line.\n  EXPECT_EQ(\"if (foo) {\\n\"\n            \"  bar();\\n\"\n            \"}\",\n            format(\"if(foo){bar();}\", Style));\n  EXPECT_EQ(\"if (foo) {\\n\"\n            \"  bar();\\n\"\n            \"} else {\\n\"\n            \"  baz();\\n\"\n            \"}\",\n            format(\"if(foo){bar();}else{baz();}\", Style));\n  EXPECT_EQ(\"if (foo && bar) {\\n\"\n            \"  baz();\\n\"\n            \"}\",\n            format(\"if(foo&&bar){baz();}\", Style));\n  EXPECT_EQ(\"if (foo) {\\n\"\n            \"  bar();\\n\"\n            \"} else if (baz) {\\n\"\n            \"  quux();\\n\"\n            \"}\",\n            format(\"if(foo){bar();}else if(baz){quux();}\", Style));\n  EXPECT_EQ(\n      \"if (foo) {\\n\"\n      \"  bar();\\n\"\n      \"} else if (baz) {\\n\"\n      \"  quux();\\n\"\n      \"} else {\\n\"\n      \"  foobar();\\n\"\n      \"}\",\n      format(\"if(foo){bar();}else if(baz){quux();}else{foobar();}\", Style));\n  EXPECT_EQ(\"for (;;) {\\n\"\n            \"  foo();\\n\"\n            \"}\",\n            format(\"for(;;){foo();}\"));\n  EXPECT_EQ(\"while (1) {\\n\"\n            \"  foo();\\n\"\n            \"}\",\n            format(\"while(1){foo();}\", Style));\n  EXPECT_EQ(\"switch (foo) {\\n\"\n            \"case bar:\\n\"\n            \"  return;\\n\"\n            \"}\",\n            format(\"switch(foo){case bar:return;}\", Style));\n  EXPECT_EQ(\"try {\\n\"\n            \"  foo();\\n\"\n            \"} catch (...) {\\n\"\n            \"  bar();\\n\"\n            \"}\",\n            format(\"try{foo();}catch(...){bar();}\", Style));\n  EXPECT_EQ(\"do {\\n\"\n            \"  foo();\\n\"\n            \"} while (bar &&\\n\"\n            \"         baz);\",\n            format(\"do{foo();}while(bar&&baz);\", Style));\n  // Long lines should put opening brace on new line.\n  EXPECT_EQ(\"if (foo && bar &&\\n\"\n            \"    baz)\\n\"\n            \"{\\n\"\n            \"  quux();\\n\"\n            \"}\",\n            format(\"if(foo&&bar&&baz){quux();}\", Style));\n  EXPECT_EQ(\"if (foo && bar &&\\n\"\n            \"    baz)\\n\"\n            \"{\\n\"\n            \"  quux();\\n\"\n            \"}\",\n            format(\"if (foo && bar &&\\n\"\n                   \"    baz) {\\n\"\n                   \"  quux();\\n\"\n                   \"}\",\n                   Style));\n  EXPECT_EQ(\"if (foo) {\\n\"\n            \"  bar();\\n\"\n            \"} else if (baz ||\\n\"\n            \"           quux)\\n\"\n            \"{\\n\"\n            \"  foobar();\\n\"\n            \"}\",\n            format(\"if(foo){bar();}else if(baz||quux){foobar();}\", Style));\n  EXPECT_EQ(\n      \"if (foo) {\\n\"\n      \"  bar();\\n\"\n      \"} else if (baz ||\\n\"\n      \"           quux)\\n\"\n      \"{\\n\"\n      \"  foobar();\\n\"\n      \"} else {\\n\"\n      \"  barbaz();\\n\"\n      \"}\",\n      format(\"if(foo){bar();}else if(baz||quux){foobar();}else{barbaz();}\",\n             Style));\n  EXPECT_EQ(\"for (int i = 0;\\n\"\n            \"     i < 10; ++i)\\n\"\n            \"{\\n\"\n            \"  foo();\\n\"\n            \"}\",\n            format(\"for(int i=0;i<10;++i){foo();}\", Style));\n  EXPECT_EQ(\"foreach (int i,\\n\"\n            \"         list)\\n\"\n            \"{\\n\"\n            \"  foo();\\n\"\n            \"}\",\n            format(\"foreach(int i, list){foo();}\", Style));\n  Style.ColumnLimit =\n      40; // to concentrate at brace wrapping, not line wrap due to column limit\n  EXPECT_EQ(\"foreach (int i, list) {\\n\"\n            \"  foo();\\n\"\n            \"}\",\n            format(\"foreach(int i, list){foo();}\", Style));\n  Style.ColumnLimit =\n      20; // to concentrate at brace wrapping, not line wrap due to column limit\n  EXPECT_EQ(\"while (foo || bar ||\\n\"\n            \"       baz)\\n\"\n            \"{\\n\"\n            \"  quux();\\n\"\n            \"}\",\n            format(\"while(foo||bar||baz){quux();}\", Style));\n  EXPECT_EQ(\"switch (\\n\"\n            \"    foo = barbaz)\\n\"\n            \"{\\n\"\n            \"case quux:\\n\"\n            \"  return;\\n\"\n            \"}\",\n            format(\"switch(foo=barbaz){case quux:return;}\", Style));\n  EXPECT_EQ(\"try {\\n\"\n            \"  foo();\\n\"\n            \"} catch (\\n\"\n            \"    Exception &bar)\\n\"\n            \"{\\n\"\n            \"  baz();\\n\"\n            \"}\",\n            format(\"try{foo();}catch(Exception&bar){baz();}\", Style));\n  Style.ColumnLimit =\n      40; // to concentrate at brace wrapping, not line wrap due to column limit\n  EXPECT_EQ(\"try {\\n\"\n            \"  foo();\\n\"\n            \"} catch (Exception &bar) {\\n\"\n            \"  baz();\\n\"\n            \"}\",\n            format(\"try{foo();}catch(Exception&bar){baz();}\", Style));\n  Style.ColumnLimit =\n      20; // to concentrate at brace wrapping, not line wrap due to column limit\n\n  Style.BraceWrapping.BeforeElse = true;\n  EXPECT_EQ(\n      \"if (foo) {\\n\"\n      \"  bar();\\n\"\n      \"}\\n\"\n      \"else if (baz ||\\n\"\n      \"         quux)\\n\"\n      \"{\\n\"\n      \"  foobar();\\n\"\n      \"}\\n\"\n      \"else {\\n\"\n      \"  barbaz();\\n\"\n      \"}\",\n      format(\"if(foo){bar();}else if(baz||quux){foobar();}else{barbaz();}\",\n             Style));\n\n  Style.BraceWrapping.BeforeCatch = true;\n  EXPECT_EQ(\"try {\\n\"\n            \"  foo();\\n\"\n            \"}\\n\"\n            \"catch (...) {\\n\"\n            \"  baz();\\n\"\n            \"}\",\n            format(\"try{foo();}catch(...){baz();}\", Style));\n}\n\nTEST_F(FormatTest, BeforeWhile) {\n  FormatStyle Style = getLLVMStyle();\n  Style.BreakBeforeBraces = FormatStyle::BraceBreakingStyle::BS_Custom;\n\n  verifyFormat(\"do {\\n\"\n               \"  foo();\\n\"\n               \"} while (1);\",\n               Style);\n  Style.BraceWrapping.BeforeWhile = true;\n  verifyFormat(\"do {\\n\"\n               \"  foo();\\n\"\n               \"}\\n\"\n               \"while (1);\",\n               Style);\n}\n\n//===----------------------------------------------------------------------===//\n// Tests for classes, namespaces, etc.\n//===----------------------------------------------------------------------===//\n\nTEST_F(FormatTest, DoesNotBreakSemiAfterClassDecl) {\n  verifyFormat(\"class A {};\");\n}\n\nTEST_F(FormatTest, UnderstandsAccessSpecifiers) {\n  verifyFormat(\"class A {\\n\"\n               \"public:\\n\"\n               \"public: // comment\\n\"\n               \"protected:\\n\"\n               \"private:\\n\"\n               \"  void f() {}\\n\"\n               \"};\");\n  verifyFormat(\"export class A {\\n\"\n               \"public:\\n\"\n               \"public: // comment\\n\"\n               \"protected:\\n\"\n               \"private:\\n\"\n               \"  void f() {}\\n\"\n               \"};\");\n  verifyGoogleFormat(\"class A {\\n\"\n                     \" public:\\n\"\n                     \" protected:\\n\"\n                     \" private:\\n\"\n                     \"  void f() {}\\n\"\n                     \"};\");\n  verifyGoogleFormat(\"export class A {\\n\"\n                     \" public:\\n\"\n                     \" protected:\\n\"\n                     \" private:\\n\"\n                     \"  void f() {}\\n\"\n                     \"};\");\n  verifyFormat(\"class A {\\n\"\n               \"public slots:\\n\"\n               \"  void f1() {}\\n\"\n               \"public Q_SLOTS:\\n\"\n               \"  void f2() {}\\n\"\n               \"protected slots:\\n\"\n               \"  void f3() {}\\n\"\n               \"protected Q_SLOTS:\\n\"\n               \"  void f4() {}\\n\"\n               \"private slots:\\n\"\n               \"  void f5() {}\\n\"\n               \"private Q_SLOTS:\\n\"\n               \"  void f6() {}\\n\"\n               \"signals:\\n\"\n               \"  void g1();\\n\"\n               \"Q_SIGNALS:\\n\"\n               \"  void g2();\\n\"\n               \"};\");\n\n  // Don't interpret 'signals' the wrong way.\n  verifyFormat(\"signals.set();\");\n  verifyFormat(\"for (Signals signals : f()) {\\n}\");\n  verifyFormat(\"{\\n\"\n               \"  signals.set(); // This needs indentation.\\n\"\n               \"}\");\n  verifyFormat(\"void f() {\\n\"\n               \"label:\\n\"\n               \"  signals.baz();\\n\"\n               \"}\");\n}\n\nTEST_F(FormatTest, SeparatesLogicalBlocks) {\n  EXPECT_EQ(\"class A {\\n\"\n            \"public:\\n\"\n            \"  void f();\\n\"\n            \"\\n\"\n            \"private:\\n\"\n            \"  void g() {}\\n\"\n            \"  // test\\n\"\n            \"protected:\\n\"\n            \"  int h;\\n\"\n            \"};\",\n            format(\"class A {\\n\"\n                   \"public:\\n\"\n                   \"void f();\\n\"\n                   \"private:\\n\"\n                   \"void g() {}\\n\"\n                   \"// test\\n\"\n                   \"protected:\\n\"\n                   \"int h;\\n\"\n                   \"};\"));\n  EXPECT_EQ(\"class A {\\n\"\n            \"protected:\\n\"\n            \"public:\\n\"\n            \"  void f();\\n\"\n            \"};\",\n            format(\"class A {\\n\"\n                   \"protected:\\n\"\n                   \"\\n\"\n                   \"public:\\n\"\n                   \"\\n\"\n                   \"  void f();\\n\"\n                   \"};\"));\n\n  // Even ensure proper spacing inside macros.\n  EXPECT_EQ(\"#define B     \\\\\\n\"\n            \"  class A {   \\\\\\n\"\n            \"   protected: \\\\\\n\"\n            \"   public:    \\\\\\n\"\n            \"    void f(); \\\\\\n\"\n            \"  };\",\n            format(\"#define B     \\\\\\n\"\n                   \"  class A {   \\\\\\n\"\n                   \"   protected: \\\\\\n\"\n                   \"              \\\\\\n\"\n                   \"   public:    \\\\\\n\"\n                   \"              \\\\\\n\"\n                   \"    void f(); \\\\\\n\"\n                   \"  };\",\n                   getGoogleStyle()));\n  // But don't remove empty lines after macros ending in access specifiers.\n  EXPECT_EQ(\"#define A private:\\n\"\n            \"\\n\"\n            \"int i;\",\n            format(\"#define A         private:\\n\"\n                   \"\\n\"\n                   \"int              i;\"));\n}\n\nTEST_F(FormatTest, FormatsClasses) {\n  verifyFormat(\"class A : public B {};\");\n  verifyFormat(\"class A : public ::B {};\");\n\n  verifyFormat(\n      \"class AAAAAAAAAAAAAAAAAAAA : public BBBBBBBBBBBBBBBBBBBBBBBBBBBBBB,\\n\"\n      \"                             public CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC {};\");\n  verifyFormat(\"class AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\n\"\n               \"    : public BBBBBBBBBBBBBBBBBBBBBBBBBBBBBB,\\n\"\n               \"      public CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC {};\");\n  verifyFormat(\n      \"class A : public B, public C, public D, public E, public F {};\");\n  verifyFormat(\"class AAAAAAAAAAAA : public B,\\n\"\n               \"                     public C,\\n\"\n               \"                     public D,\\n\"\n               \"                     public E,\\n\"\n               \"                     public F,\\n\"\n               \"                     public G {};\");\n\n  verifyFormat(\"class\\n\"\n               \"    ReallyReallyLongClassName {\\n\"\n               \"  int i;\\n\"\n               \"};\",\n               getLLVMStyleWithColumns(32));\n  verifyFormat(\"struct aaaaaaaaaaaaa : public aaaaaaaaaaaaaaaaaaa< // break\\n\"\n               \"                           aaaaaaaaaaaaaaaa> {};\");\n  verifyFormat(\"struct aaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    : public aaaaaaaaaaaaaaaaaaa<aaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                                 aaaaaaaaaaaaaaaaaaaaaa> {};\");\n  verifyFormat(\"template <class R, class C>\\n\"\n               \"struct Aaaaaaaaaaaaaaaaa<R (C::*)(int) const>\\n\"\n               \"    : Aaaaaaaaaaaaaaaaa<R (C::*)(int)> {};\");\n  verifyFormat(\"class ::A::B {};\");\n}\n\nTEST_F(FormatTest, BreakInheritanceStyle) {\n  FormatStyle StyleWithInheritanceBreakBeforeComma = getLLVMStyle();\n  StyleWithInheritanceBreakBeforeComma.BreakInheritanceList =\n      FormatStyle::BILS_BeforeComma;\n  verifyFormat(\"class MyClass : public X {};\",\n               StyleWithInheritanceBreakBeforeComma);\n  verifyFormat(\"class MyClass\\n\"\n               \"    : public X\\n\"\n               \"    , public Y {};\",\n               StyleWithInheritanceBreakBeforeComma);\n  verifyFormat(\"class AAAAAAAAAAAAAAAAAAAAAA\\n\"\n               \"    : public BBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\\n\"\n               \"    , public CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC {};\",\n               StyleWithInheritanceBreakBeforeComma);\n  verifyFormat(\"struct aaaaaaaaaaaaa\\n\"\n               \"    : public aaaaaaaaaaaaaaaaaaa< // break\\n\"\n               \"          aaaaaaaaaaaaaaaa> {};\",\n               StyleWithInheritanceBreakBeforeComma);\n\n  FormatStyle StyleWithInheritanceBreakAfterColon = getLLVMStyle();\n  StyleWithInheritanceBreakAfterColon.BreakInheritanceList =\n      FormatStyle::BILS_AfterColon;\n  verifyFormat(\"class MyClass : public X {};\",\n               StyleWithInheritanceBreakAfterColon);\n  verifyFormat(\"class MyClass : public X, public Y {};\",\n               StyleWithInheritanceBreakAfterColon);\n  verifyFormat(\"class AAAAAAAAAAAAAAAAAAAAAA :\\n\"\n               \"    public BBBBBBBBBBBBBBBBBBBBBBBBBBBBBB,\\n\"\n               \"    public CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC {};\",\n               StyleWithInheritanceBreakAfterColon);\n  verifyFormat(\"struct aaaaaaaaaaaaa :\\n\"\n               \"    public aaaaaaaaaaaaaaaaaaa< // break\\n\"\n               \"        aaaaaaaaaaaaaaaa> {};\",\n               StyleWithInheritanceBreakAfterColon);\n}\n\nTEST_F(FormatTest, FormatsVariableDeclarationsAfterStructOrClass) {\n  verifyFormat(\"class A {\\n} a, b;\");\n  verifyFormat(\"struct A {\\n} a, b;\");\n  verifyFormat(\"union A {\\n} a;\");\n}\n\nTEST_F(FormatTest, FormatsEnum) {\n  verifyFormat(\"enum {\\n\"\n               \"  Zero,\\n\"\n               \"  One = 1,\\n\"\n               \"  Two = One + 1,\\n\"\n               \"  Three = (One + Two),\\n\"\n               \"  Four = (Zero && (One ^ Two)) | (One << Two),\\n\"\n               \"  Five = (One, Two, Three, Four, 5)\\n\"\n               \"};\");\n  verifyGoogleFormat(\"enum {\\n\"\n                     \"  Zero,\\n\"\n                     \"  One = 1,\\n\"\n                     \"  Two = One + 1,\\n\"\n                     \"  Three = (One + Two),\\n\"\n                     \"  Four = (Zero && (One ^ Two)) | (One << Two),\\n\"\n                     \"  Five = (One, Two, Three, Four, 5)\\n\"\n                     \"};\");\n  verifyFormat(\"enum Enum {};\");\n  verifyFormat(\"enum {};\");\n  verifyFormat(\"enum X E {} d;\");\n  verifyFormat(\"enum __attribute__((...)) E {} d;\");\n  verifyFormat(\"enum __declspec__((...)) E {} d;\");\n  verifyFormat(\"enum {\\n\"\n               \"  Bar = Foo<int, int>::value\\n\"\n               \"};\",\n               getLLVMStyleWithColumns(30));\n\n  verifyFormat(\"enum ShortEnum { A, B, C };\");\n  verifyGoogleFormat(\"enum ShortEnum { A, B, C };\");\n\n  EXPECT_EQ(\"enum KeepEmptyLines {\\n\"\n            \"  ONE,\\n\"\n            \"\\n\"\n            \"  TWO,\\n\"\n            \"\\n\"\n            \"  THREE\\n\"\n            \"}\",\n            format(\"enum KeepEmptyLines {\\n\"\n                   \"  ONE,\\n\"\n                   \"\\n\"\n                   \"  TWO,\\n\"\n                   \"\\n\"\n                   \"\\n\"\n                   \"  THREE\\n\"\n                   \"}\"));\n  verifyFormat(\"enum E { // comment\\n\"\n               \"  ONE,\\n\"\n               \"  TWO\\n\"\n               \"};\\n\"\n               \"int i;\");\n\n  FormatStyle EightIndent = getLLVMStyle();\n  EightIndent.IndentWidth = 8;\n  verifyFormat(\"enum {\\n\"\n               \"        VOID,\\n\"\n               \"        CHAR,\\n\"\n               \"        SHORT,\\n\"\n               \"        INT,\\n\"\n               \"        LONG,\\n\"\n               \"        SIGNED,\\n\"\n               \"        UNSIGNED,\\n\"\n               \"        BOOL,\\n\"\n               \"        FLOAT,\\n\"\n               \"        DOUBLE,\\n\"\n               \"        COMPLEX\\n\"\n               \"};\",\n               EightIndent);\n\n  // Not enums.\n  verifyFormat(\"enum X f() {\\n\"\n               \"  a();\\n\"\n               \"  return 42;\\n\"\n               \"}\");\n  verifyFormat(\"enum X Type::f() {\\n\"\n               \"  a();\\n\"\n               \"  return 42;\\n\"\n               \"}\");\n  verifyFormat(\"enum ::X f() {\\n\"\n               \"  a();\\n\"\n               \"  return 42;\\n\"\n               \"}\");\n  verifyFormat(\"enum ns::X f() {\\n\"\n               \"  a();\\n\"\n               \"  return 42;\\n\"\n               \"}\");\n}\n\nTEST_F(FormatTest, FormatsEnumsWithErrors) {\n  verifyFormat(\"enum Type {\\n\"\n               \"  One = 0; // These semicolons should be commas.\\n\"\n               \"  Two = 1;\\n\"\n               \"};\");\n  verifyFormat(\"namespace n {\\n\"\n               \"enum Type {\\n\"\n               \"  One,\\n\"\n               \"  Two, // missing };\\n\"\n               \"  int i;\\n\"\n               \"}\\n\"\n               \"void g() {}\");\n}\n\nTEST_F(FormatTest, FormatsEnumStruct) {\n  verifyFormat(\"enum struct {\\n\"\n               \"  Zero,\\n\"\n               \"  One = 1,\\n\"\n               \"  Two = One + 1,\\n\"\n               \"  Three = (One + Two),\\n\"\n               \"  Four = (Zero && (One ^ Two)) | (One << Two),\\n\"\n               \"  Five = (One, Two, Three, Four, 5)\\n\"\n               \"};\");\n  verifyFormat(\"enum struct Enum {};\");\n  verifyFormat(\"enum struct {};\");\n  verifyFormat(\"enum struct X E {} d;\");\n  verifyFormat(\"enum struct __attribute__((...)) E {} d;\");\n  verifyFormat(\"enum struct __declspec__((...)) E {} d;\");\n  verifyFormat(\"enum struct X f() {\\n  a();\\n  return 42;\\n}\");\n}\n\nTEST_F(FormatTest, FormatsEnumClass) {\n  verifyFormat(\"enum class {\\n\"\n               \"  Zero,\\n\"\n               \"  One = 1,\\n\"\n               \"  Two = One + 1,\\n\"\n               \"  Three = (One + Two),\\n\"\n               \"  Four = (Zero && (One ^ Two)) | (One << Two),\\n\"\n               \"  Five = (One, Two, Three, Four, 5)\\n\"\n               \"};\");\n  verifyFormat(\"enum class Enum {};\");\n  verifyFormat(\"enum class {};\");\n  verifyFormat(\"enum class X E {} d;\");\n  verifyFormat(\"enum class __attribute__((...)) E {} d;\");\n  verifyFormat(\"enum class __declspec__((...)) E {} d;\");\n  verifyFormat(\"enum class X f() {\\n  a();\\n  return 42;\\n}\");\n}\n\nTEST_F(FormatTest, FormatsEnumTypes) {\n  verifyFormat(\"enum X : int {\\n\"\n               \"  A, // Force multiple lines.\\n\"\n               \"  B\\n\"\n               \"};\");\n  verifyFormat(\"enum X : int { A, B };\");\n  verifyFormat(\"enum X : std::uint32_t { A, B };\");\n}\n\nTEST_F(FormatTest, FormatsTypedefEnum) {\n  FormatStyle Style = getLLVMStyle();\n  Style.ColumnLimit = 40;\n  verifyFormat(\"typedef enum {} EmptyEnum;\");\n  verifyFormat(\"typedef enum { A, B, C } ShortEnum;\");\n  verifyFormat(\"typedef enum {\\n\"\n               \"  ZERO = 0,\\n\"\n               \"  ONE = 1,\\n\"\n               \"  TWO = 2,\\n\"\n               \"  THREE = 3\\n\"\n               \"} LongEnum;\",\n               Style);\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.AfterEnum = true;\n  verifyFormat(\"typedef enum {} EmptyEnum;\");\n  verifyFormat(\"typedef enum { A, B, C } ShortEnum;\");\n  verifyFormat(\"typedef enum\\n\"\n               \"{\\n\"\n               \"  ZERO = 0,\\n\"\n               \"  ONE = 1,\\n\"\n               \"  TWO = 2,\\n\"\n               \"  THREE = 3\\n\"\n               \"} LongEnum;\",\n               Style);\n}\n\nTEST_F(FormatTest, FormatsNSEnums) {\n  verifyGoogleFormat(\"typedef NS_ENUM(NSInteger, SomeName) { AAA, BBB }\");\n  verifyGoogleFormat(\n      \"typedef NS_CLOSED_ENUM(NSInteger, SomeName) { AAA, BBB }\");\n  verifyGoogleFormat(\"typedef NS_ENUM(NSInteger, MyType) {\\n\"\n                     \"  // Information about someDecentlyLongValue.\\n\"\n                     \"  someDecentlyLongValue,\\n\"\n                     \"  // Information about anotherDecentlyLongValue.\\n\"\n                     \"  anotherDecentlyLongValue,\\n\"\n                     \"  // Information about aThirdDecentlyLongValue.\\n\"\n                     \"  aThirdDecentlyLongValue\\n\"\n                     \"};\");\n  verifyGoogleFormat(\"typedef NS_CLOSED_ENUM(NSInteger, MyType) {\\n\"\n                     \"  // Information about someDecentlyLongValue.\\n\"\n                     \"  someDecentlyLongValue,\\n\"\n                     \"  // Information about anotherDecentlyLongValue.\\n\"\n                     \"  anotherDecentlyLongValue,\\n\"\n                     \"  // Information about aThirdDecentlyLongValue.\\n\"\n                     \"  aThirdDecentlyLongValue\\n\"\n                     \"};\");\n  verifyGoogleFormat(\"typedef NS_OPTIONS(NSInteger, MyType) {\\n\"\n                     \"  a = 1,\\n\"\n                     \"  b = 2,\\n\"\n                     \"  c = 3,\\n\"\n                     \"};\");\n  verifyGoogleFormat(\"typedef CF_ENUM(NSInteger, MyType) {\\n\"\n                     \"  a = 1,\\n\"\n                     \"  b = 2,\\n\"\n                     \"  c = 3,\\n\"\n                     \"};\");\n  verifyGoogleFormat(\"typedef CF_CLOSED_ENUM(NSInteger, MyType) {\\n\"\n                     \"  a = 1,\\n\"\n                     \"  b = 2,\\n\"\n                     \"  c = 3,\\n\"\n                     \"};\");\n  verifyGoogleFormat(\"typedef CF_OPTIONS(NSInteger, MyType) {\\n\"\n                     \"  a = 1,\\n\"\n                     \"  b = 2,\\n\"\n                     \"  c = 3,\\n\"\n                     \"};\");\n}\n\nTEST_F(FormatTest, FormatsBitfields) {\n  verifyFormat(\"struct Bitfields {\\n\"\n               \"  unsigned sClass : 8;\\n\"\n               \"  unsigned ValueKind : 2;\\n\"\n               \"};\");\n  verifyFormat(\"struct A {\\n\"\n               \"  int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa : 1,\\n\"\n               \"      bbbbbbbbbbbbbbbbbbbbbbbbb;\\n\"\n               \"};\");\n  verifyFormat(\"struct MyStruct {\\n\"\n               \"  uchar data;\\n\"\n               \"  uchar : 8;\\n\"\n               \"  uchar : 8;\\n\"\n               \"  uchar other;\\n\"\n               \"};\");\n  FormatStyle Style = getLLVMStyle();\n  Style.BitFieldColonSpacing = FormatStyle::BFCS_None;\n  verifyFormat(\"struct Bitfields {\\n\"\n               \"  unsigned sClass:8;\\n\"\n               \"  unsigned ValueKind:2;\\n\"\n               \"  uchar other;\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"struct A {\\n\"\n               \"  int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:1,\\n\"\n               \"      bbbbbbbbbbbbbbbbbbbbbbbbb:2;\\n\"\n               \"};\",\n               Style);\n  Style.BitFieldColonSpacing = FormatStyle::BFCS_Before;\n  verifyFormat(\"struct Bitfields {\\n\"\n               \"  unsigned sClass :8;\\n\"\n               \"  unsigned ValueKind :2;\\n\"\n               \"  uchar other;\\n\"\n               \"};\",\n               Style);\n  Style.BitFieldColonSpacing = FormatStyle::BFCS_After;\n  verifyFormat(\"struct Bitfields {\\n\"\n               \"  unsigned sClass: 8;\\n\"\n               \"  unsigned ValueKind: 2;\\n\"\n               \"  uchar other;\\n\"\n               \"};\",\n               Style);\n}\n\nTEST_F(FormatTest, FormatsNamespaces) {\n  FormatStyle LLVMWithNoNamespaceFix = getLLVMStyle();\n  LLVMWithNoNamespaceFix.FixNamespaceComments = false;\n\n  verifyFormat(\"namespace some_namespace {\\n\"\n               \"class A {};\\n\"\n               \"void f() { f(); }\\n\"\n               \"}\",\n               LLVMWithNoNamespaceFix);\n  verifyFormat(\"namespace N::inline D {\\n\"\n               \"class A {};\\n\"\n               \"void f() { f(); }\\n\"\n               \"}\",\n               LLVMWithNoNamespaceFix);\n  verifyFormat(\"namespace N::inline D::E {\\n\"\n               \"class A {};\\n\"\n               \"void f() { f(); }\\n\"\n               \"}\",\n               LLVMWithNoNamespaceFix);\n  verifyFormat(\"namespace [[deprecated(\\\"foo[bar\\\")]] some_namespace {\\n\"\n               \"class A {};\\n\"\n               \"void f() { f(); }\\n\"\n               \"}\",\n               LLVMWithNoNamespaceFix);\n  verifyFormat(\"/* something */ namespace some_namespace {\\n\"\n               \"class A {};\\n\"\n               \"void f() { f(); }\\n\"\n               \"}\",\n               LLVMWithNoNamespaceFix);\n  verifyFormat(\"namespace {\\n\"\n               \"class A {};\\n\"\n               \"void f() { f(); }\\n\"\n               \"}\",\n               LLVMWithNoNamespaceFix);\n  verifyFormat(\"/* something */ namespace {\\n\"\n               \"class A {};\\n\"\n               \"void f() { f(); }\\n\"\n               \"}\",\n               LLVMWithNoNamespaceFix);\n  verifyFormat(\"inline namespace X {\\n\"\n               \"class A {};\\n\"\n               \"void f() { f(); }\\n\"\n               \"}\",\n               LLVMWithNoNamespaceFix);\n  verifyFormat(\"/* something */ inline namespace X {\\n\"\n               \"class A {};\\n\"\n               \"void f() { f(); }\\n\"\n               \"}\",\n               LLVMWithNoNamespaceFix);\n  verifyFormat(\"export namespace X {\\n\"\n               \"class A {};\\n\"\n               \"void f() { f(); }\\n\"\n               \"}\",\n               LLVMWithNoNamespaceFix);\n  verifyFormat(\"using namespace some_namespace;\\n\"\n               \"class A {};\\n\"\n               \"void f() { f(); }\",\n               LLVMWithNoNamespaceFix);\n\n  // This code is more common than we thought; if we\n  // layout this correctly the semicolon will go into\n  // its own line, which is undesirable.\n  verifyFormat(\"namespace {};\", LLVMWithNoNamespaceFix);\n  verifyFormat(\"namespace {\\n\"\n               \"class A {};\\n\"\n               \"};\",\n               LLVMWithNoNamespaceFix);\n\n  verifyFormat(\"namespace {\\n\"\n               \"int SomeVariable = 0; // comment\\n\"\n               \"} // namespace\",\n               LLVMWithNoNamespaceFix);\n  EXPECT_EQ(\"#ifndef HEADER_GUARD\\n\"\n            \"#define HEADER_GUARD\\n\"\n            \"namespace my_namespace {\\n\"\n            \"int i;\\n\"\n            \"} // my_namespace\\n\"\n            \"#endif // HEADER_GUARD\",\n            format(\"#ifndef HEADER_GUARD\\n\"\n                   \" #define HEADER_GUARD\\n\"\n                   \"   namespace my_namespace {\\n\"\n                   \"int i;\\n\"\n                   \"}    // my_namespace\\n\"\n                   \"#endif    // HEADER_GUARD\",\n                   LLVMWithNoNamespaceFix));\n\n  EXPECT_EQ(\"namespace A::B {\\n\"\n            \"class C {};\\n\"\n            \"}\",\n            format(\"namespace A::B {\\n\"\n                   \"class C {};\\n\"\n                   \"}\",\n                   LLVMWithNoNamespaceFix));\n\n  FormatStyle Style = getLLVMStyle();\n  Style.NamespaceIndentation = FormatStyle::NI_All;\n  EXPECT_EQ(\"namespace out {\\n\"\n            \"  int i;\\n\"\n            \"  namespace in {\\n\"\n            \"    int i;\\n\"\n            \"  } // namespace in\\n\"\n            \"} // namespace out\",\n            format(\"namespace out {\\n\"\n                   \"int i;\\n\"\n                   \"namespace in {\\n\"\n                   \"int i;\\n\"\n                   \"} // namespace in\\n\"\n                   \"} // namespace out\",\n                   Style));\n\n  Style.NamespaceIndentation = FormatStyle::NI_Inner;\n  EXPECT_EQ(\"namespace out {\\n\"\n            \"int i;\\n\"\n            \"namespace in {\\n\"\n            \"  int i;\\n\"\n            \"} // namespace in\\n\"\n            \"} // namespace out\",\n            format(\"namespace out {\\n\"\n                   \"int i;\\n\"\n                   \"namespace in {\\n\"\n                   \"int i;\\n\"\n                   \"} // namespace in\\n\"\n                   \"} // namespace out\",\n                   Style));\n}\n\nTEST_F(FormatTest, NamespaceMacros) {\n  FormatStyle Style = getLLVMStyle();\n  Style.NamespaceMacros.push_back(\"TESTSUITE\");\n\n  verifyFormat(\"TESTSUITE(A) {\\n\"\n               \"int foo();\\n\"\n               \"} // TESTSUITE(A)\",\n               Style);\n\n  verifyFormat(\"TESTSUITE(A, B) {\\n\"\n               \"int foo();\\n\"\n               \"} // TESTSUITE(A)\",\n               Style);\n\n  // Properly indent according to NamespaceIndentation style\n  Style.NamespaceIndentation = FormatStyle::NI_All;\n  verifyFormat(\"TESTSUITE(A) {\\n\"\n               \"  int foo();\\n\"\n               \"} // TESTSUITE(A)\",\n               Style);\n  verifyFormat(\"TESTSUITE(A) {\\n\"\n               \"  namespace B {\\n\"\n               \"    int foo();\\n\"\n               \"  } // namespace B\\n\"\n               \"} // TESTSUITE(A)\",\n               Style);\n  verifyFormat(\"namespace A {\\n\"\n               \"  TESTSUITE(B) {\\n\"\n               \"    int foo();\\n\"\n               \"  } // TESTSUITE(B)\\n\"\n               \"} // namespace A\",\n               Style);\n\n  Style.NamespaceIndentation = FormatStyle::NI_Inner;\n  verifyFormat(\"TESTSUITE(A) {\\n\"\n               \"TESTSUITE(B) {\\n\"\n               \"  int foo();\\n\"\n               \"} // TESTSUITE(B)\\n\"\n               \"} // TESTSUITE(A)\",\n               Style);\n  verifyFormat(\"TESTSUITE(A) {\\n\"\n               \"namespace B {\\n\"\n               \"  int foo();\\n\"\n               \"} // namespace B\\n\"\n               \"} // TESTSUITE(A)\",\n               Style);\n  verifyFormat(\"namespace A {\\n\"\n               \"TESTSUITE(B) {\\n\"\n               \"  int foo();\\n\"\n               \"} // TESTSUITE(B)\\n\"\n               \"} // namespace A\",\n               Style);\n\n  // Properly merge namespace-macros blocks in CompactNamespaces mode\n  Style.NamespaceIndentation = FormatStyle::NI_None;\n  Style.CompactNamespaces = true;\n  verifyFormat(\"TESTSUITE(A) { TESTSUITE(B) {\\n\"\n               \"}} // TESTSUITE(A::B)\",\n               Style);\n\n  EXPECT_EQ(\"TESTSUITE(out) { TESTSUITE(in) {\\n\"\n            \"}} // TESTSUITE(out::in)\",\n            format(\"TESTSUITE(out) {\\n\"\n                   \"TESTSUITE(in) {\\n\"\n                   \"} // TESTSUITE(in)\\n\"\n                   \"} // TESTSUITE(out)\",\n                   Style));\n\n  EXPECT_EQ(\"TESTSUITE(out) { TESTSUITE(in) {\\n\"\n            \"}} // TESTSUITE(out::in)\",\n            format(\"TESTSUITE(out) {\\n\"\n                   \"TESTSUITE(in) {\\n\"\n                   \"} // TESTSUITE(in)\\n\"\n                   \"} // TESTSUITE(out)\",\n                   Style));\n\n  // Do not merge different namespaces/macros\n  EXPECT_EQ(\"namespace out {\\n\"\n            \"TESTSUITE(in) {\\n\"\n            \"} // TESTSUITE(in)\\n\"\n            \"} // namespace out\",\n            format(\"namespace out {\\n\"\n                   \"TESTSUITE(in) {\\n\"\n                   \"} // TESTSUITE(in)\\n\"\n                   \"} // namespace out\",\n                   Style));\n  EXPECT_EQ(\"TESTSUITE(out) {\\n\"\n            \"namespace in {\\n\"\n            \"} // namespace in\\n\"\n            \"} // TESTSUITE(out)\",\n            format(\"TESTSUITE(out) {\\n\"\n                   \"namespace in {\\n\"\n                   \"} // namespace in\\n\"\n                   \"} // TESTSUITE(out)\",\n                   Style));\n  Style.NamespaceMacros.push_back(\"FOOBAR\");\n  EXPECT_EQ(\"TESTSUITE(out) {\\n\"\n            \"FOOBAR(in) {\\n\"\n            \"} // FOOBAR(in)\\n\"\n            \"} // TESTSUITE(out)\",\n            format(\"TESTSUITE(out) {\\n\"\n                   \"FOOBAR(in) {\\n\"\n                   \"} // FOOBAR(in)\\n\"\n                   \"} // TESTSUITE(out)\",\n                   Style));\n}\n\nTEST_F(FormatTest, FormatsCompactNamespaces) {\n  FormatStyle Style = getLLVMStyle();\n  Style.CompactNamespaces = true;\n  Style.NamespaceMacros.push_back(\"TESTSUITE\");\n\n  verifyFormat(\"namespace A { namespace B {\\n\"\n               \"}} // namespace A::B\",\n               Style);\n\n  EXPECT_EQ(\"namespace out { namespace in {\\n\"\n            \"}} // namespace out::in\",\n            format(\"namespace out {\\n\"\n                   \"namespace in {\\n\"\n                   \"} // namespace in\\n\"\n                   \"} // namespace out\",\n                   Style));\n\n  // Only namespaces which have both consecutive opening and end get compacted\n  EXPECT_EQ(\"namespace out {\\n\"\n            \"namespace in1 {\\n\"\n            \"} // namespace in1\\n\"\n            \"namespace in2 {\\n\"\n            \"} // namespace in2\\n\"\n            \"} // namespace out\",\n            format(\"namespace out {\\n\"\n                   \"namespace in1 {\\n\"\n                   \"} // namespace in1\\n\"\n                   \"namespace in2 {\\n\"\n                   \"} // namespace in2\\n\"\n                   \"} // namespace out\",\n                   Style));\n\n  EXPECT_EQ(\"namespace out {\\n\"\n            \"int i;\\n\"\n            \"namespace in {\\n\"\n            \"int j;\\n\"\n            \"} // namespace in\\n\"\n            \"int k;\\n\"\n            \"} // namespace out\",\n            format(\"namespace out { int i;\\n\"\n                   \"namespace in { int j; } // namespace in\\n\"\n                   \"int k; } // namespace out\",\n                   Style));\n\n  EXPECT_EQ(\"namespace A { namespace B { namespace C {\\n\"\n            \"}}} // namespace A::B::C\\n\",\n            format(\"namespace A { namespace B {\\n\"\n                   \"namespace C {\\n\"\n                   \"}} // namespace B::C\\n\"\n                   \"} // namespace A\\n\",\n                   Style));\n\n  Style.ColumnLimit = 40;\n  EXPECT_EQ(\"namespace aaaaaaaaaa {\\n\"\n            \"namespace bbbbbbbbbb {\\n\"\n            \"}} // namespace aaaaaaaaaa::bbbbbbbbbb\",\n            format(\"namespace aaaaaaaaaa {\\n\"\n                   \"namespace bbbbbbbbbb {\\n\"\n                   \"} // namespace bbbbbbbbbb\\n\"\n                   \"} // namespace aaaaaaaaaa\",\n                   Style));\n\n  EXPECT_EQ(\"namespace aaaaaa { namespace bbbbbb {\\n\"\n            \"namespace cccccc {\\n\"\n            \"}}} // namespace aaaaaa::bbbbbb::cccccc\",\n            format(\"namespace aaaaaa {\\n\"\n                   \"namespace bbbbbb {\\n\"\n                   \"namespace cccccc {\\n\"\n                   \"} // namespace cccccc\\n\"\n                   \"} // namespace bbbbbb\\n\"\n                   \"} // namespace aaaaaa\",\n                   Style));\n  Style.ColumnLimit = 80;\n\n  // Extra semicolon after 'inner' closing brace prevents merging\n  EXPECT_EQ(\"namespace out { namespace in {\\n\"\n            \"}; } // namespace out::in\",\n            format(\"namespace out {\\n\"\n                   \"namespace in {\\n\"\n                   \"}; // namespace in\\n\"\n                   \"} // namespace out\",\n                   Style));\n\n  // Extra semicolon after 'outer' closing brace is conserved\n  EXPECT_EQ(\"namespace out { namespace in {\\n\"\n            \"}}; // namespace out::in\",\n            format(\"namespace out {\\n\"\n                   \"namespace in {\\n\"\n                   \"} // namespace in\\n\"\n                   \"}; // namespace out\",\n                   Style));\n\n  Style.NamespaceIndentation = FormatStyle::NI_All;\n  EXPECT_EQ(\"namespace out { namespace in {\\n\"\n            \"  int i;\\n\"\n            \"}} // namespace out::in\",\n            format(\"namespace out {\\n\"\n                   \"namespace in {\\n\"\n                   \"int i;\\n\"\n                   \"} // namespace in\\n\"\n                   \"} // namespace out\",\n                   Style));\n  EXPECT_EQ(\"namespace out { namespace mid {\\n\"\n            \"  namespace in {\\n\"\n            \"    int j;\\n\"\n            \"  } // namespace in\\n\"\n            \"  int k;\\n\"\n            \"}} // namespace out::mid\",\n            format(\"namespace out { namespace mid {\\n\"\n                   \"namespace in { int j; } // namespace in\\n\"\n                   \"int k; }} // namespace out::mid\",\n                   Style));\n\n  Style.NamespaceIndentation = FormatStyle::NI_Inner;\n  EXPECT_EQ(\"namespace out { namespace in {\\n\"\n            \"  int i;\\n\"\n            \"}} // namespace out::in\",\n            format(\"namespace out {\\n\"\n                   \"namespace in {\\n\"\n                   \"int i;\\n\"\n                   \"} // namespace in\\n\"\n                   \"} // namespace out\",\n                   Style));\n  EXPECT_EQ(\"namespace out { namespace mid { namespace in {\\n\"\n            \"  int i;\\n\"\n            \"}}} // namespace out::mid::in\",\n            format(\"namespace out {\\n\"\n                   \"namespace mid {\\n\"\n                   \"namespace in {\\n\"\n                   \"int i;\\n\"\n                   \"} // namespace in\\n\"\n                   \"} // namespace mid\\n\"\n                   \"} // namespace out\",\n                   Style));\n}\n\nTEST_F(FormatTest, FormatsExternC) {\n  verifyFormat(\"extern \\\"C\\\" {\\nint a;\");\n  verifyFormat(\"extern \\\"C\\\" {}\");\n  verifyFormat(\"extern \\\"C\\\" {\\n\"\n               \"int foo();\\n\"\n               \"}\");\n  verifyFormat(\"extern \\\"C\\\" int foo() {}\");\n  verifyFormat(\"extern \\\"C\\\" int foo();\");\n  verifyFormat(\"extern \\\"C\\\" int foo() {\\n\"\n               \"  int i = 42;\\n\"\n               \"  return i;\\n\"\n               \"}\");\n\n  FormatStyle Style = getLLVMStyle();\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.AfterFunction = true;\n  verifyFormat(\"extern \\\"C\\\" int foo() {}\", Style);\n  verifyFormat(\"extern \\\"C\\\" int foo();\", Style);\n  verifyFormat(\"extern \\\"C\\\" int foo()\\n\"\n               \"{\\n\"\n               \"  int i = 42;\\n\"\n               \"  return i;\\n\"\n               \"}\",\n               Style);\n\n  Style.BraceWrapping.AfterExternBlock = true;\n  Style.BraceWrapping.SplitEmptyRecord = false;\n  verifyFormat(\"extern \\\"C\\\"\\n\"\n               \"{}\",\n               Style);\n  verifyFormat(\"extern \\\"C\\\"\\n\"\n               \"{\\n\"\n               \"  int foo();\\n\"\n               \"}\",\n               Style);\n}\n\nTEST_F(FormatTest, IndentExternBlockStyle) {\n  FormatStyle Style = getLLVMStyle();\n  Style.IndentWidth = 2;\n\n  Style.IndentExternBlock = FormatStyle::IEBS_Indent;\n  verifyFormat(\"extern \\\"C\\\" { /*9*/\\n}\", Style);\n  verifyFormat(\"extern \\\"C\\\" {\\n\"\n               \"  int foo10();\\n\"\n               \"}\",\n               Style);\n\n  Style.IndentExternBlock = FormatStyle::IEBS_NoIndent;\n  verifyFormat(\"extern \\\"C\\\" { /*11*/\\n}\", Style);\n  verifyFormat(\"extern \\\"C\\\" {\\n\"\n               \"int foo12();\\n\"\n               \"}\",\n               Style);\n\n  Style.IndentExternBlock = FormatStyle::IEBS_AfterExternBlock;\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.AfterExternBlock = true;\n  verifyFormat(\"extern \\\"C\\\"\\n{ /*13*/\\n}\", Style);\n  verifyFormat(\"extern \\\"C\\\"\\n{\\n\"\n               \"  int foo14();\\n\"\n               \"}\",\n               Style);\n\n  Style.IndentExternBlock = FormatStyle::IEBS_AfterExternBlock;\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.AfterExternBlock = false;\n  verifyFormat(\"extern \\\"C\\\" { /*15*/\\n}\", Style);\n  verifyFormat(\"extern \\\"C\\\" {\\n\"\n               \"int foo16();\\n\"\n               \"}\",\n               Style);\n}\n\nTEST_F(FormatTest, FormatsInlineASM) {\n  verifyFormat(\"asm(\\\"xyz\\\" : \\\"=a\\\"(a), \\\"=d\\\"(b) : \\\"a\\\"(data));\");\n  verifyFormat(\"asm(\\\"nop\\\" ::: \\\"memory\\\");\");\n  verifyFormat(\n      \"asm(\\\"movq\\\\t%%rbx, %%rsi\\\\n\\\\t\\\"\\n\"\n      \"    \\\"cpuid\\\\n\\\\t\\\"\\n\"\n      \"    \\\"xchgq\\\\t%%rbx, %%rsi\\\\n\\\\t\\\"\\n\"\n      \"    : \\\"=a\\\"(*rEAX), \\\"=S\\\"(*rEBX), \\\"=c\\\"(*rECX), \\\"=d\\\"(*rEDX)\\n\"\n      \"    : \\\"a\\\"(value));\");\n  EXPECT_EQ(\n      \"void NS_InvokeByIndex(void *that, unsigned int methodIndex) {\\n\"\n      \"  __asm {\\n\"\n      \"        mov     edx,[that] // vtable in edx\\n\"\n      \"        mov     eax,methodIndex\\n\"\n      \"        call    [edx][eax*4] // stdcall\\n\"\n      \"  }\\n\"\n      \"}\",\n      format(\"void NS_InvokeByIndex(void *that,   unsigned int methodIndex) {\\n\"\n             \"    __asm {\\n\"\n             \"        mov     edx,[that] // vtable in edx\\n\"\n             \"        mov     eax,methodIndex\\n\"\n             \"        call    [edx][eax*4] // stdcall\\n\"\n             \"    }\\n\"\n             \"}\"));\n  EXPECT_EQ(\"_asm {\\n\"\n            \"  xor eax, eax;\\n\"\n            \"  cpuid;\\n\"\n            \"}\",\n            format(\"_asm {\\n\"\n                   \"  xor eax, eax;\\n\"\n                   \"  cpuid;\\n\"\n                   \"}\"));\n  verifyFormat(\"void function() {\\n\"\n               \"  // comment\\n\"\n               \"  asm(\\\"\\\");\\n\"\n               \"}\");\n  EXPECT_EQ(\"__asm {\\n\"\n            \"}\\n\"\n            \"int i;\",\n            format(\"__asm   {\\n\"\n                   \"}\\n\"\n                   \"int   i;\"));\n}\n\nTEST_F(FormatTest, FormatTryCatch) {\n  verifyFormat(\"try {\\n\"\n               \"  throw a * b;\\n\"\n               \"} catch (int a) {\\n\"\n               \"  // Do nothing.\\n\"\n               \"} catch (...) {\\n\"\n               \"  exit(42);\\n\"\n               \"}\");\n\n  // Function-level try statements.\n  verifyFormat(\"int f() try { return 4; } catch (...) {\\n\"\n               \"  return 5;\\n\"\n               \"}\");\n  verifyFormat(\"class A {\\n\"\n               \"  int a;\\n\"\n               \"  A() try : a(0) {\\n\"\n               \"  } catch (...) {\\n\"\n               \"    throw;\\n\"\n               \"  }\\n\"\n               \"};\\n\");\n  verifyFormat(\"class A {\\n\"\n               \"  int a;\\n\"\n               \"  A() try : a(0), b{1} {\\n\"\n               \"  } catch (...) {\\n\"\n               \"    throw;\\n\"\n               \"  }\\n\"\n               \"};\\n\");\n  verifyFormat(\"class A {\\n\"\n               \"  int a;\\n\"\n               \"  A() try : a(0), b{1}, c{2} {\\n\"\n               \"  } catch (...) {\\n\"\n               \"    throw;\\n\"\n               \"  }\\n\"\n               \"};\\n\");\n  verifyFormat(\"class A {\\n\"\n               \"  int a;\\n\"\n               \"  A() try : a(0), b{1}, c{2} {\\n\"\n               \"    { // New scope.\\n\"\n               \"    }\\n\"\n               \"  } catch (...) {\\n\"\n               \"    throw;\\n\"\n               \"  }\\n\"\n               \"};\\n\");\n\n  // Incomplete try-catch blocks.\n  verifyIncompleteFormat(\"try {} catch (\");\n}\n\nTEST_F(FormatTest, FormatTryAsAVariable) {\n  verifyFormat(\"int try;\");\n  verifyFormat(\"int try, size;\");\n  verifyFormat(\"try = foo();\");\n  verifyFormat(\"if (try < size) {\\n  return true;\\n}\");\n\n  verifyFormat(\"int catch;\");\n  verifyFormat(\"int catch, size;\");\n  verifyFormat(\"catch = foo();\");\n  verifyFormat(\"if (catch < size) {\\n  return true;\\n}\");\n\n  FormatStyle Style = getLLVMStyle();\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.AfterFunction = true;\n  Style.BraceWrapping.BeforeCatch = true;\n  verifyFormat(\"try {\\n\"\n               \"  int bar = 1;\\n\"\n               \"}\\n\"\n               \"catch (...) {\\n\"\n               \"  int bar = 1;\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"#if NO_EX\\n\"\n               \"try\\n\"\n               \"#endif\\n\"\n               \"{\\n\"\n               \"}\\n\"\n               \"#if NO_EX\\n\"\n               \"catch (...) {\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"try /* abc */ {\\n\"\n               \"  int bar = 1;\\n\"\n               \"}\\n\"\n               \"catch (...) {\\n\"\n               \"  int bar = 1;\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"try\\n\"\n               \"// abc\\n\"\n               \"{\\n\"\n               \"  int bar = 1;\\n\"\n               \"}\\n\"\n               \"catch (...) {\\n\"\n               \"  int bar = 1;\\n\"\n               \"}\",\n               Style);\n}\n\nTEST_F(FormatTest, FormatSEHTryCatch) {\n  verifyFormat(\"__try {\\n\"\n               \"  int a = b * c;\\n\"\n               \"} __except (EXCEPTION_EXECUTE_HANDLER) {\\n\"\n               \"  // Do nothing.\\n\"\n               \"}\");\n\n  verifyFormat(\"__try {\\n\"\n               \"  int a = b * c;\\n\"\n               \"} __finally {\\n\"\n               \"  // Do nothing.\\n\"\n               \"}\");\n\n  verifyFormat(\"DEBUG({\\n\"\n               \"  __try {\\n\"\n               \"  } __finally {\\n\"\n               \"  }\\n\"\n               \"});\\n\");\n}\n\nTEST_F(FormatTest, IncompleteTryCatchBlocks) {\n  verifyFormat(\"try {\\n\"\n               \"  f();\\n\"\n               \"} catch {\\n\"\n               \"  g();\\n\"\n               \"}\");\n  verifyFormat(\"try {\\n\"\n               \"  f();\\n\"\n               \"} catch (A a) MACRO(x) {\\n\"\n               \"  g();\\n\"\n               \"} catch (B b) MACRO(x) {\\n\"\n               \"  g();\\n\"\n               \"}\");\n}\n\nTEST_F(FormatTest, FormatTryCatchBraceStyles) {\n  FormatStyle Style = getLLVMStyle();\n  for (auto BraceStyle : {FormatStyle::BS_Attach, FormatStyle::BS_Mozilla,\n                          FormatStyle::BS_WebKit}) {\n    Style.BreakBeforeBraces = BraceStyle;\n    verifyFormat(\"try {\\n\"\n                 \"  // something\\n\"\n                 \"} catch (...) {\\n\"\n                 \"  // something\\n\"\n                 \"}\",\n                 Style);\n  }\n  Style.BreakBeforeBraces = FormatStyle::BS_Stroustrup;\n  verifyFormat(\"try {\\n\"\n               \"  // something\\n\"\n               \"}\\n\"\n               \"catch (...) {\\n\"\n               \"  // something\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"__try {\\n\"\n               \"  // something\\n\"\n               \"}\\n\"\n               \"__finally {\\n\"\n               \"  // something\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"@try {\\n\"\n               \"  // something\\n\"\n               \"}\\n\"\n               \"@finally {\\n\"\n               \"  // something\\n\"\n               \"}\",\n               Style);\n  Style.BreakBeforeBraces = FormatStyle::BS_Allman;\n  verifyFormat(\"try\\n\"\n               \"{\\n\"\n               \"  // something\\n\"\n               \"}\\n\"\n               \"catch (...)\\n\"\n               \"{\\n\"\n               \"  // something\\n\"\n               \"}\",\n               Style);\n  Style.BreakBeforeBraces = FormatStyle::BS_Whitesmiths;\n  verifyFormat(\"try\\n\"\n               \"  {\\n\"\n               \"  // something white\\n\"\n               \"  }\\n\"\n               \"catch (...)\\n\"\n               \"  {\\n\"\n               \"  // something white\\n\"\n               \"  }\",\n               Style);\n  Style.BreakBeforeBraces = FormatStyle::BS_GNU;\n  verifyFormat(\"try\\n\"\n               \"  {\\n\"\n               \"    // something\\n\"\n               \"  }\\n\"\n               \"catch (...)\\n\"\n               \"  {\\n\"\n               \"    // something\\n\"\n               \"  }\",\n               Style);\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.BeforeCatch = true;\n  verifyFormat(\"try {\\n\"\n               \"  // something\\n\"\n               \"}\\n\"\n               \"catch (...) {\\n\"\n               \"  // something\\n\"\n               \"}\",\n               Style);\n}\n\nTEST_F(FormatTest, StaticInitializers) {\n  verifyFormat(\"static SomeClass SC = {1, 'a'};\");\n\n  verifyFormat(\"static SomeClass WithALoooooooooooooooooooongName = {\\n\"\n               \"    100000000, \"\n               \"\\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\"};\");\n\n  // Here, everything other than the \"}\" would fit on a line.\n  verifyFormat(\"static int LooooooooooooooooooooooooongVariable[1] = {\\n\"\n               \"    10000000000000000000000000};\");\n  EXPECT_EQ(\"S s = {a,\\n\"\n            \"\\n\"\n            \"       b};\",\n            format(\"S s = {\\n\"\n                   \"  a,\\n\"\n                   \"\\n\"\n                   \"  b\\n\"\n                   \"};\"));\n\n  // FIXME: This would fit into the column limit if we'd fit \"{ {\" on the first\n  // line. However, the formatting looks a bit off and this probably doesn't\n  // happen often in practice.\n  verifyFormat(\"static int Variable[1] = {\\n\"\n               \"    {1000000000000000000000000000000000000}};\",\n               getLLVMStyleWithColumns(40));\n}\n\nTEST_F(FormatTest, DesignatedInitializers) {\n  verifyFormat(\"const struct A a = {.a = 1, .b = 2};\");\n  verifyFormat(\"const struct A a = {.aaaaaaaaaa = 1,\\n\"\n               \"                    .bbbbbbbbbb = 2,\\n\"\n               \"                    .cccccccccc = 3,\\n\"\n               \"                    .dddddddddd = 4,\\n\"\n               \"                    .eeeeeeeeee = 5};\");\n  verifyFormat(\"const struct Aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaa = {\\n\"\n               \"    .aaaaaaaaaaaaaaaaaaaaaaaaaaa = 1,\\n\"\n               \"    .bbbbbbbbbbbbbbbbbbbbbbbbbbb = 2,\\n\"\n               \"    .ccccccccccccccccccccccccccc = 3,\\n\"\n               \"    .ddddddddddddddddddddddddddd = 4,\\n\"\n               \"    .eeeeeeeeeeeeeeeeeeeeeeeeeee = 5};\");\n\n  verifyGoogleFormat(\"const struct A a = {.a = 1, .b = 2};\");\n\n  verifyFormat(\"const struct A a = {[0] = 1, [1] = 2};\");\n  verifyFormat(\"const struct A a = {[1] = aaaaaaaaaa,\\n\"\n               \"                    [2] = bbbbbbbbbb,\\n\"\n               \"                    [3] = cccccccccc,\\n\"\n               \"                    [4] = dddddddddd,\\n\"\n               \"                    [5] = eeeeeeeeee};\");\n  verifyFormat(\"const struct Aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaa = {\\n\"\n               \"    [1] = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    [2] = bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\\n\"\n               \"    [3] = cccccccccccccccccccccccccccccccccccccc,\\n\"\n               \"    [4] = dddddddddddddddddddddddddddddddddddddd,\\n\"\n               \"    [5] = eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee};\");\n}\n\nTEST_F(FormatTest, NestedStaticInitializers) {\n  verifyFormat(\"static A x = {{{}}};\\n\");\n  verifyFormat(\"static A x = {{{init1, init2, init3, init4},\\n\"\n               \"               {init1, init2, init3, init4}}};\",\n               getLLVMStyleWithColumns(50));\n\n  verifyFormat(\"somes Status::global_reps[3] = {\\n\"\n               \"    {kGlobalRef, OK_CODE, NULL, NULL, NULL},\\n\"\n               \"    {kGlobalRef, CANCELLED_CODE, NULL, NULL, NULL},\\n\"\n               \"    {kGlobalRef, UNKNOWN_CODE, NULL, NULL, NULL}};\",\n               getLLVMStyleWithColumns(60));\n  verifyGoogleFormat(\"SomeType Status::global_reps[3] = {\\n\"\n                     \"    {kGlobalRef, OK_CODE, NULL, NULL, NULL},\\n\"\n                     \"    {kGlobalRef, CANCELLED_CODE, NULL, NULL, NULL},\\n\"\n                     \"    {kGlobalRef, UNKNOWN_CODE, NULL, NULL, NULL}};\");\n  verifyFormat(\"CGRect cg_rect = {{rect.fLeft, rect.fTop},\\n\"\n               \"                  {rect.fRight - rect.fLeft, rect.fBottom - \"\n               \"rect.fTop}};\");\n\n  verifyFormat(\n      \"SomeArrayOfSomeType a = {\\n\"\n      \"    {{1, 2, 3},\\n\"\n      \"     {1, 2, 3},\\n\"\n      \"     {111111111111111111111111111111, 222222222222222222222222222222,\\n\"\n      \"      333333333333333333333333333333},\\n\"\n      \"     {1, 2, 3},\\n\"\n      \"     {1, 2, 3}}};\");\n  verifyFormat(\n      \"SomeArrayOfSomeType a = {\\n\"\n      \"    {{1, 2, 3}},\\n\"\n      \"    {{1, 2, 3}},\\n\"\n      \"    {{111111111111111111111111111111, 222222222222222222222222222222,\\n\"\n      \"      333333333333333333333333333333}},\\n\"\n      \"    {{1, 2, 3}},\\n\"\n      \"    {{1, 2, 3}}};\");\n\n  verifyFormat(\"struct {\\n\"\n               \"  unsigned bit;\\n\"\n               \"  const char *const name;\\n\"\n               \"} kBitsToOs[] = {{kOsMac, \\\"Mac\\\"},\\n\"\n               \"                 {kOsWin, \\\"Windows\\\"},\\n\"\n               \"                 {kOsLinux, \\\"Linux\\\"},\\n\"\n               \"                 {kOsCrOS, \\\"Chrome OS\\\"}};\");\n  verifyFormat(\"struct {\\n\"\n               \"  unsigned bit;\\n\"\n               \"  const char *const name;\\n\"\n               \"} kBitsToOs[] = {\\n\"\n               \"    {kOsMac, \\\"Mac\\\"},\\n\"\n               \"    {kOsWin, \\\"Windows\\\"},\\n\"\n               \"    {kOsLinux, \\\"Linux\\\"},\\n\"\n               \"    {kOsCrOS, \\\"Chrome OS\\\"},\\n\"\n               \"};\");\n}\n\nTEST_F(FormatTest, FormatsSmallMacroDefinitionsInSingleLine) {\n  verifyFormat(\"#define ALooooooooooooooooooooooooooooooooooooooongMacro(\"\n               \"                      \\\\\\n\"\n               \"    aLoooooooooooooooooooooooongFuuuuuuuuuuuuuunctiooooooooo)\");\n}\n\nTEST_F(FormatTest, DoesNotBreakPureVirtualFunctionDefinition) {\n  verifyFormat(\"virtual void write(ELFWriter *writerrr,\\n\"\n               \"                   OwningPtr<FileOutputBuffer> &buffer) = 0;\");\n\n  // Do break defaulted and deleted functions.\n  verifyFormat(\"virtual void ~Deeeeeeeestructor() =\\n\"\n               \"    default;\",\n               getLLVMStyleWithColumns(40));\n  verifyFormat(\"virtual void ~Deeeeeeeestructor() =\\n\"\n               \"    delete;\",\n               getLLVMStyleWithColumns(40));\n}\n\nTEST_F(FormatTest, BreaksStringLiteralsOnlyInDefine) {\n  verifyFormat(\"# 1111 \\\"/aaaaaaaaa/aaaaaaaaaaaaaaaaaaa/aaaaaaaa.cpp\\\" 2 3\",\n               getLLVMStyleWithColumns(40));\n  verifyFormat(\"#line 11111 \\\"/aaaaaaaaa/aaaaaaaaaaaaaaaaaaa/aaaaaaaa.cpp\\\"\",\n               getLLVMStyleWithColumns(40));\n  EXPECT_EQ(\"#define Q                              \\\\\\n\"\n            \"  \\\"/aaaaaaaaa/aaaaaaaaaaaaaaaaaaa/\\\"    \\\\\\n\"\n            \"  \\\"aaaaaaaa.cpp\\\"\",\n            format(\"#define Q \\\"/aaaaaaaaa/aaaaaaaaaaaaaaaaaaa/aaaaaaaa.cpp\\\"\",\n                   getLLVMStyleWithColumns(40)));\n}\n\nTEST_F(FormatTest, UnderstandsLinePPDirective) {\n  EXPECT_EQ(\"# 123 \\\"A string literal\\\"\",\n            format(\"   #     123    \\\"A string literal\\\"\"));\n}\n\nTEST_F(FormatTest, LayoutUnknownPPDirective) {\n  EXPECT_EQ(\"#;\", format(\"#;\"));\n  verifyFormat(\"#\\n;\\n;\\n;\");\n}\n\nTEST_F(FormatTest, UnescapedEndOfLineEndsPPDirective) {\n  EXPECT_EQ(\"#line 42 \\\"test\\\"\\n\",\n            format(\"#  \\\\\\n  line  \\\\\\n  42  \\\\\\n  \\\"test\\\"\\n\"));\n  EXPECT_EQ(\"#define A B\\n\", format(\"#  \\\\\\n define  \\\\\\n    A  \\\\\\n       B\\n\",\n                                    getLLVMStyleWithColumns(12)));\n}\n\nTEST_F(FormatTest, EndOfFileEndsPPDirective) {\n  EXPECT_EQ(\"#line 42 \\\"test\\\"\",\n            format(\"#  \\\\\\n  line  \\\\\\n  42  \\\\\\n  \\\"test\\\"\"));\n  EXPECT_EQ(\"#define A B\", format(\"#  \\\\\\n define  \\\\\\n    A  \\\\\\n       B\"));\n}\n\nTEST_F(FormatTest, DoesntRemoveUnknownTokens) {\n  verifyFormat(\"#define A \\\\x20\");\n  verifyFormat(\"#define A \\\\ x20\");\n  EXPECT_EQ(\"#define A \\\\ x20\", format(\"#define A \\\\   x20\"));\n  verifyFormat(\"#define A ''\");\n  verifyFormat(\"#define A ''qqq\");\n  verifyFormat(\"#define A `qqq\");\n  verifyFormat(\"f(\\\"aaaa, bbbb, \\\"\\\\\\\"ccccc\\\\\\\"\\\");\");\n  EXPECT_EQ(\"const char *c = STRINGIFY(\\n\"\n            \"\\\\na : b);\",\n            format(\"const char * c = STRINGIFY(\\n\"\n                   \"\\\\na : b);\"));\n\n  verifyFormat(\"a\\r\\\\\");\n  verifyFormat(\"a\\v\\\\\");\n  verifyFormat(\"a\\f\\\\\");\n}\n\nTEST_F(FormatTest, IndentsPPDirectiveInReducedSpace) {\n  verifyFormat(\"#define A(BB)\", getLLVMStyleWithColumns(13));\n  verifyFormat(\"#define A( \\\\\\n    BB)\", getLLVMStyleWithColumns(12));\n  verifyFormat(\"#define A( \\\\\\n    A, B)\", getLLVMStyleWithColumns(12));\n  // FIXME: We never break before the macro name.\n  verifyFormat(\"#define AA( \\\\\\n    B)\", getLLVMStyleWithColumns(12));\n\n  verifyFormat(\"#define A A\\n#define A A\");\n  verifyFormat(\"#define A(X) A\\n#define A A\");\n\n  verifyFormat(\"#define Something Other\", getLLVMStyleWithColumns(23));\n  verifyFormat(\"#define Something    \\\\\\n  Other\", getLLVMStyleWithColumns(22));\n}\n\nTEST_F(FormatTest, HandlePreprocessorDirectiveContext) {\n  EXPECT_EQ(\"// somecomment\\n\"\n            \"#include \\\"a.h\\\"\\n\"\n            \"#define A(  \\\\\\n\"\n            \"    A, B)\\n\"\n            \"#include \\\"b.h\\\"\\n\"\n            \"// somecomment\\n\",\n            format(\"  // somecomment\\n\"\n                   \"  #include \\\"a.h\\\"\\n\"\n                   \"#define A(A,\\\\\\n\"\n                   \"    B)\\n\"\n                   \"    #include \\\"b.h\\\"\\n\"\n                   \" // somecomment\\n\",\n                   getLLVMStyleWithColumns(13)));\n}\n\nTEST_F(FormatTest, LayoutSingleHash) { EXPECT_EQ(\"#\\na;\", format(\"#\\na;\")); }\n\nTEST_F(FormatTest, LayoutCodeInMacroDefinitions) {\n  EXPECT_EQ(\"#define A    \\\\\\n\"\n            \"  c;         \\\\\\n\"\n            \"  e;\\n\"\n            \"f;\",\n            format(\"#define A c; e;\\n\"\n                   \"f;\",\n                   getLLVMStyleWithColumns(14)));\n}\n\nTEST_F(FormatTest, LayoutRemainingTokens) { EXPECT_EQ(\"{}\", format(\"{}\")); }\n\nTEST_F(FormatTest, MacroDefinitionInsideStatement) {\n  EXPECT_EQ(\"int x,\\n\"\n            \"#define A\\n\"\n            \"    y;\",\n            format(\"int x,\\n#define A\\ny;\"));\n}\n\nTEST_F(FormatTest, HashInMacroDefinition) {\n  EXPECT_EQ(\"#define A(c) L#c\", format(\"#define A(c) L#c\", getLLVMStyle()));\n  verifyFormat(\"#define A \\\\\\n  b #c;\", getLLVMStyleWithColumns(11));\n  verifyFormat(\"#define A  \\\\\\n\"\n               \"  {        \\\\\\n\"\n               \"    f(#c); \\\\\\n\"\n               \"  }\",\n               getLLVMStyleWithColumns(11));\n\n  verifyFormat(\"#define A(X)         \\\\\\n\"\n               \"  void function##X()\",\n               getLLVMStyleWithColumns(22));\n\n  verifyFormat(\"#define A(a, b, c)   \\\\\\n\"\n               \"  void a##b##c()\",\n               getLLVMStyleWithColumns(22));\n\n  verifyFormat(\"#define A void # ## #\", getLLVMStyleWithColumns(22));\n}\n\nTEST_F(FormatTest, RespectWhitespaceInMacroDefinitions) {\n  EXPECT_EQ(\"#define A (x)\", format(\"#define A (x)\"));\n  EXPECT_EQ(\"#define A(x)\", format(\"#define A(x)\"));\n\n  FormatStyle Style = getLLVMStyle();\n  Style.SpaceBeforeParens = FormatStyle::SBPO_Never;\n  verifyFormat(\"#define true ((foo)1)\", Style);\n  Style.SpaceBeforeParens = FormatStyle::SBPO_Always;\n  verifyFormat(\"#define false((foo)0)\", Style);\n}\n\nTEST_F(FormatTest, EmptyLinesInMacroDefinitions) {\n  EXPECT_EQ(\"#define A b;\", format(\"#define A \\\\\\n\"\n                                   \"          \\\\\\n\"\n                                   \"  b;\",\n                                   getLLVMStyleWithColumns(25)));\n  EXPECT_EQ(\"#define A \\\\\\n\"\n            \"          \\\\\\n\"\n            \"  a;      \\\\\\n\"\n            \"  b;\",\n            format(\"#define A \\\\\\n\"\n                   \"          \\\\\\n\"\n                   \"  a;      \\\\\\n\"\n                   \"  b;\",\n                   getLLVMStyleWithColumns(11)));\n  EXPECT_EQ(\"#define A \\\\\\n\"\n            \"  a;      \\\\\\n\"\n            \"          \\\\\\n\"\n            \"  b;\",\n            format(\"#define A \\\\\\n\"\n                   \"  a;      \\\\\\n\"\n                   \"          \\\\\\n\"\n                   \"  b;\",\n                   getLLVMStyleWithColumns(11)));\n}\n\nTEST_F(FormatTest, MacroDefinitionsWithIncompleteCode) {\n  verifyIncompleteFormat(\"#define A :\");\n  verifyFormat(\"#define SOMECASES  \\\\\\n\"\n               \"  case 1:          \\\\\\n\"\n               \"  case 2\\n\",\n               getLLVMStyleWithColumns(20));\n  verifyFormat(\"#define MACRO(a) \\\\\\n\"\n               \"  if (a)         \\\\\\n\"\n               \"    f();         \\\\\\n\"\n               \"  else           \\\\\\n\"\n               \"    g()\",\n               getLLVMStyleWithColumns(18));\n  verifyFormat(\"#define A template <typename T>\");\n  verifyIncompleteFormat(\"#define STR(x) #x\\n\"\n                         \"f(STR(this_is_a_string_literal{));\");\n  verifyFormat(\"#pragma omp threadprivate( \\\\\\n\"\n               \"    y)), // expected-warning\",\n               getLLVMStyleWithColumns(28));\n  verifyFormat(\"#d, = };\");\n  verifyFormat(\"#if \\\"a\");\n  verifyIncompleteFormat(\"({\\n\"\n                         \"#define b     \\\\\\n\"\n                         \"  }           \\\\\\n\"\n                         \"  a\\n\"\n                         \"a\",\n                         getLLVMStyleWithColumns(15));\n  verifyFormat(\"#define A     \\\\\\n\"\n               \"  {           \\\\\\n\"\n               \"    {\\n\"\n               \"#define B     \\\\\\n\"\n               \"  }           \\\\\\n\"\n               \"  }\",\n               getLLVMStyleWithColumns(15));\n  verifyNoCrash(\"#if a\\na(\\n#else\\n#endif\\n{a\");\n  verifyNoCrash(\"a={0,1\\n#if a\\n#else\\n;\\n#endif\\n}\");\n  verifyNoCrash(\"#if a\\na(\\n#else\\n#endif\\n) a {a,b,c,d,f,g};\");\n  verifyNoCrash(\"#ifdef A\\n a(\\n #else\\n #endif\\n) = []() {      \\n)}\");\n}\n\nTEST_F(FormatTest, MacrosWithoutTrailingSemicolon) {\n  verifyFormat(\"SOME_TYPE_NAME abc;\"); // Gated on the newline.\n  EXPECT_EQ(\"class A : public QObject {\\n\"\n            \"  Q_OBJECT\\n\"\n            \"\\n\"\n            \"  A() {}\\n\"\n            \"};\",\n            format(\"class A  :  public QObject {\\n\"\n                   \"     Q_OBJECT\\n\"\n                   \"\\n\"\n                   \"  A() {\\n}\\n\"\n                   \"}  ;\"));\n  EXPECT_EQ(\"MACRO\\n\"\n            \"/*static*/ int i;\",\n            format(\"MACRO\\n\"\n                   \" /*static*/ int   i;\"));\n  EXPECT_EQ(\"SOME_MACRO\\n\"\n            \"namespace {\\n\"\n            \"void f();\\n\"\n            \"} // namespace\",\n            format(\"SOME_MACRO\\n\"\n                   \"  namespace    {\\n\"\n                   \"void   f(  );\\n\"\n                   \"} // namespace\"));\n  // Only if the identifier contains at least 5 characters.\n  EXPECT_EQ(\"HTTP f();\", format(\"HTTP\\nf();\"));\n  EXPECT_EQ(\"MACRO\\nf();\", format(\"MACRO\\nf();\"));\n  // Only if everything is upper case.\n  EXPECT_EQ(\"class A : public QObject {\\n\"\n            \"  Q_Object A() {}\\n\"\n            \"};\",\n            format(\"class A  :  public QObject {\\n\"\n                   \"     Q_Object\\n\"\n                   \"  A() {\\n}\\n\"\n                   \"}  ;\"));\n\n  // Only if the next line can actually start an unwrapped line.\n  EXPECT_EQ(\"SOME_WEIRD_LOG_MACRO << SomeThing;\",\n            format(\"SOME_WEIRD_LOG_MACRO\\n\"\n                   \"<< SomeThing;\"));\n\n  verifyFormat(\"VISIT_GL_CALL(GenBuffers, void, (GLsizei n, GLuint* buffers), \"\n               \"(n, buffers))\\n\",\n               getChromiumStyle(FormatStyle::LK_Cpp));\n\n  // See PR41483\n  EXPECT_EQ(\"/**/ FOO(a)\\n\"\n            \"FOO(b)\",\n            format(\"/**/ FOO(a)\\n\"\n                   \"FOO(b)\"));\n}\n\nTEST_F(FormatTest, MacroCallsWithoutTrailingSemicolon) {\n  EXPECT_EQ(\"INITIALIZE_PASS_BEGIN(ScopDetection, \\\"polly-detect\\\")\\n\"\n            \"INITIALIZE_AG_DEPENDENCY(AliasAnalysis)\\n\"\n            \"INITIALIZE_PASS_DEPENDENCY(DominatorTree)\\n\"\n            \"class X {};\\n\"\n            \"INITIALIZE_PASS_END(ScopDetection, \\\"polly-detect\\\")\\n\"\n            \"int *createScopDetectionPass() { return 0; }\",\n            format(\"  INITIALIZE_PASS_BEGIN(ScopDetection, \\\"polly-detect\\\")\\n\"\n                   \"  INITIALIZE_AG_DEPENDENCY(AliasAnalysis)\\n\"\n                   \"  INITIALIZE_PASS_DEPENDENCY(DominatorTree)\\n\"\n                   \"  class X {};\\n\"\n                   \"  INITIALIZE_PASS_END(ScopDetection, \\\"polly-detect\\\")\\n\"\n                   \"  int *createScopDetectionPass() { return 0; }\"));\n  // FIXME: We could probably treat IPC_BEGIN_MESSAGE_MAP/IPC_END_MESSAGE_MAP as\n  // braces, so that inner block is indented one level more.\n  EXPECT_EQ(\"int q() {\\n\"\n            \"  IPC_BEGIN_MESSAGE_MAP(WebKitTestController, message)\\n\"\n            \"  IPC_MESSAGE_HANDLER(xxx, qqq)\\n\"\n            \"  IPC_END_MESSAGE_MAP()\\n\"\n            \"}\",\n            format(\"int q() {\\n\"\n                   \"  IPC_BEGIN_MESSAGE_MAP(WebKitTestController, message)\\n\"\n                   \"    IPC_MESSAGE_HANDLER(xxx, qqq)\\n\"\n                   \"  IPC_END_MESSAGE_MAP()\\n\"\n                   \"}\"));\n\n  // Same inside macros.\n  EXPECT_EQ(\"#define LIST(L) \\\\\\n\"\n            \"  L(A)          \\\\\\n\"\n            \"  L(B)          \\\\\\n\"\n            \"  L(C)\",\n            format(\"#define LIST(L) \\\\\\n\"\n                   \"  L(A) \\\\\\n\"\n                   \"  L(B) \\\\\\n\"\n                   \"  L(C)\",\n                   getGoogleStyle()));\n\n  // These must not be recognized as macros.\n  EXPECT_EQ(\"int q() {\\n\"\n            \"  f(x);\\n\"\n            \"  f(x) {}\\n\"\n            \"  f(x)->g();\\n\"\n            \"  f(x)->*g();\\n\"\n            \"  f(x).g();\\n\"\n            \"  f(x) = x;\\n\"\n            \"  f(x) += x;\\n\"\n            \"  f(x) -= x;\\n\"\n            \"  f(x) *= x;\\n\"\n            \"  f(x) /= x;\\n\"\n            \"  f(x) %= x;\\n\"\n            \"  f(x) &= x;\\n\"\n            \"  f(x) |= x;\\n\"\n            \"  f(x) ^= x;\\n\"\n            \"  f(x) >>= x;\\n\"\n            \"  f(x) <<= x;\\n\"\n            \"  f(x)[y].z();\\n\"\n            \"  LOG(INFO) << x;\\n\"\n            \"  ifstream(x) >> x;\\n\"\n            \"}\\n\",\n            format(\"int q() {\\n\"\n                   \"  f(x)\\n;\\n\"\n                   \"  f(x)\\n {}\\n\"\n                   \"  f(x)\\n->g();\\n\"\n                   \"  f(x)\\n->*g();\\n\"\n                   \"  f(x)\\n.g();\\n\"\n                   \"  f(x)\\n = x;\\n\"\n                   \"  f(x)\\n += x;\\n\"\n                   \"  f(x)\\n -= x;\\n\"\n                   \"  f(x)\\n *= x;\\n\"\n                   \"  f(x)\\n /= x;\\n\"\n                   \"  f(x)\\n %= x;\\n\"\n                   \"  f(x)\\n &= x;\\n\"\n                   \"  f(x)\\n |= x;\\n\"\n                   \"  f(x)\\n ^= x;\\n\"\n                   \"  f(x)\\n >>= x;\\n\"\n                   \"  f(x)\\n <<= x;\\n\"\n                   \"  f(x)\\n[y].z();\\n\"\n                   \"  LOG(INFO)\\n << x;\\n\"\n                   \"  ifstream(x)\\n >> x;\\n\"\n                   \"}\\n\"));\n  EXPECT_EQ(\"int q() {\\n\"\n            \"  F(x)\\n\"\n            \"  if (1) {\\n\"\n            \"  }\\n\"\n            \"  F(x)\\n\"\n            \"  while (1) {\\n\"\n            \"  }\\n\"\n            \"  F(x)\\n\"\n            \"  G(x);\\n\"\n            \"  F(x)\\n\"\n            \"  try {\\n\"\n            \"    Q();\\n\"\n            \"  } catch (...) {\\n\"\n            \"  }\\n\"\n            \"}\\n\",\n            format(\"int q() {\\n\"\n                   \"F(x)\\n\"\n                   \"if (1) {}\\n\"\n                   \"F(x)\\n\"\n                   \"while (1) {}\\n\"\n                   \"F(x)\\n\"\n                   \"G(x);\\n\"\n                   \"F(x)\\n\"\n                   \"try { Q(); } catch (...) {}\\n\"\n                   \"}\\n\"));\n  EXPECT_EQ(\"class A {\\n\"\n            \"  A() : t(0) {}\\n\"\n            \"  A(int i) noexcept() : {}\\n\"\n            \"  A(X x)\\n\" // FIXME: function-level try blocks are broken.\n            \"  try : t(0) {\\n\"\n            \"  } catch (...) {\\n\"\n            \"  }\\n\"\n            \"};\",\n            format(\"class A {\\n\"\n                   \"  A()\\n : t(0) {}\\n\"\n                   \"  A(int i)\\n noexcept() : {}\\n\"\n                   \"  A(X x)\\n\"\n                   \"  try : t(0) {} catch (...) {}\\n\"\n                   \"};\"));\n  FormatStyle Style = getLLVMStyle();\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.AfterControlStatement = FormatStyle::BWACS_Always;\n  Style.BraceWrapping.AfterFunction = true;\n  EXPECT_EQ(\"void f()\\n\"\n            \"try\\n\"\n            \"{\\n\"\n            \"}\",\n            format(\"void f() try {\\n\"\n                   \"}\",\n                   Style));\n  EXPECT_EQ(\"class SomeClass {\\n\"\n            \"public:\\n\"\n            \"  SomeClass() EXCLUSIVE_LOCK_FUNCTION(mu_);\\n\"\n            \"};\",\n            format(\"class SomeClass {\\n\"\n                   \"public:\\n\"\n                   \"  SomeClass()\\n\"\n                   \"  EXCLUSIVE_LOCK_FUNCTION(mu_);\\n\"\n                   \"};\"));\n  EXPECT_EQ(\"class SomeClass {\\n\"\n            \"public:\\n\"\n            \"  SomeClass()\\n\"\n            \"      EXCLUSIVE_LOCK_FUNCTION(mu_);\\n\"\n            \"};\",\n            format(\"class SomeClass {\\n\"\n                   \"public:\\n\"\n                   \"  SomeClass()\\n\"\n                   \"  EXCLUSIVE_LOCK_FUNCTION(mu_);\\n\"\n                   \"};\",\n                   getLLVMStyleWithColumns(40)));\n\n  verifyFormat(\"MACRO(>)\");\n\n  // Some macros contain an implicit semicolon.\n  Style = getLLVMStyle();\n  Style.StatementMacros.push_back(\"FOO\");\n  verifyFormat(\"FOO(a) int b = 0;\");\n  verifyFormat(\"FOO(a)\\n\"\n               \"int b = 0;\",\n               Style);\n  verifyFormat(\"FOO(a);\\n\"\n               \"int b = 0;\",\n               Style);\n  verifyFormat(\"FOO(argc, argv, \\\"4.0.2\\\")\\n\"\n               \"int b = 0;\",\n               Style);\n  verifyFormat(\"FOO()\\n\"\n               \"int b = 0;\",\n               Style);\n  verifyFormat(\"FOO\\n\"\n               \"int b = 0;\",\n               Style);\n  verifyFormat(\"void f() {\\n\"\n               \"  FOO(a)\\n\"\n               \"  return a;\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"FOO(a)\\n\"\n               \"FOO(b)\",\n               Style);\n  verifyFormat(\"int a = 0;\\n\"\n               \"FOO(b)\\n\"\n               \"int c = 0;\",\n               Style);\n  verifyFormat(\"int a = 0;\\n\"\n               \"int x = FOO(a)\\n\"\n               \"int b = 0;\",\n               Style);\n  verifyFormat(\"void foo(int a) { FOO(a) }\\n\"\n               \"uint32_t bar() {}\",\n               Style);\n}\n\nTEST_F(FormatTest, LayoutMacroDefinitionsStatementsSpanningBlocks) {\n  verifyFormat(\"#define A \\\\\\n\"\n               \"  f({     \\\\\\n\"\n               \"    g();  \\\\\\n\"\n               \"  });\",\n               getLLVMStyleWithColumns(11));\n}\n\nTEST_F(FormatTest, IndentPreprocessorDirectives) {\n  FormatStyle Style = getLLVMStyle();\n  Style.IndentPPDirectives = FormatStyle::PPDIS_None;\n  Style.ColumnLimit = 40;\n  verifyFormat(\"#ifdef _WIN32\\n\"\n               \"#define A 0\\n\"\n               \"#ifdef VAR2\\n\"\n               \"#define B 1\\n\"\n               \"#include <someheader.h>\\n\"\n               \"#define MACRO                          \\\\\\n\"\n               \"  some_very_long_func_aaaaaaaaaa();\\n\"\n               \"#endif\\n\"\n               \"#else\\n\"\n               \"#define A 1\\n\"\n               \"#endif\",\n               Style);\n  Style.IndentPPDirectives = FormatStyle::PPDIS_AfterHash;\n  verifyFormat(\"#ifdef _WIN32\\n\"\n               \"#  define A 0\\n\"\n               \"#  ifdef VAR2\\n\"\n               \"#    define B 1\\n\"\n               \"#    include <someheader.h>\\n\"\n               \"#    define MACRO                      \\\\\\n\"\n               \"      some_very_long_func_aaaaaaaaaa();\\n\"\n               \"#  endif\\n\"\n               \"#else\\n\"\n               \"#  define A 1\\n\"\n               \"#endif\",\n               Style);\n  verifyFormat(\"#if A\\n\"\n               \"#  define MACRO                        \\\\\\n\"\n               \"    void a(int x) {                    \\\\\\n\"\n               \"      b();                             \\\\\\n\"\n               \"      c();                             \\\\\\n\"\n               \"      d();                             \\\\\\n\"\n               \"      e();                             \\\\\\n\"\n               \"      f();                             \\\\\\n\"\n               \"    }\\n\"\n               \"#endif\",\n               Style);\n  // Comments before include guard.\n  verifyFormat(\"// file comment\\n\"\n               \"// file comment\\n\"\n               \"#ifndef HEADER_H\\n\"\n               \"#define HEADER_H\\n\"\n               \"code();\\n\"\n               \"#endif\",\n               Style);\n  // Test with include guards.\n  verifyFormat(\"#ifndef HEADER_H\\n\"\n               \"#define HEADER_H\\n\"\n               \"code();\\n\"\n               \"#endif\",\n               Style);\n  // Include guards must have a #define with the same variable immediately\n  // after #ifndef.\n  verifyFormat(\"#ifndef NOT_GUARD\\n\"\n               \"#  define FOO\\n\"\n               \"code();\\n\"\n               \"#endif\",\n               Style);\n\n  // Include guards must cover the entire file.\n  verifyFormat(\"code();\\n\"\n               \"code();\\n\"\n               \"#ifndef NOT_GUARD\\n\"\n               \"#  define NOT_GUARD\\n\"\n               \"code();\\n\"\n               \"#endif\",\n               Style);\n  verifyFormat(\"#ifndef NOT_GUARD\\n\"\n               \"#  define NOT_GUARD\\n\"\n               \"code();\\n\"\n               \"#endif\\n\"\n               \"code();\",\n               Style);\n  // Test with trailing blank lines.\n  verifyFormat(\"#ifndef HEADER_H\\n\"\n               \"#define HEADER_H\\n\"\n               \"code();\\n\"\n               \"#endif\\n\",\n               Style);\n  // Include guards don't have #else.\n  verifyFormat(\"#ifndef NOT_GUARD\\n\"\n               \"#  define NOT_GUARD\\n\"\n               \"code();\\n\"\n               \"#else\\n\"\n               \"#endif\",\n               Style);\n  verifyFormat(\"#ifndef NOT_GUARD\\n\"\n               \"#  define NOT_GUARD\\n\"\n               \"code();\\n\"\n               \"#elif FOO\\n\"\n               \"#endif\",\n               Style);\n  // Non-identifier #define after potential include guard.\n  verifyFormat(\"#ifndef FOO\\n\"\n               \"#  define 1\\n\"\n               \"#endif\\n\",\n               Style);\n  // #if closes past last non-preprocessor line.\n  verifyFormat(\"#ifndef FOO\\n\"\n               \"#define FOO\\n\"\n               \"#if 1\\n\"\n               \"int i;\\n\"\n               \"#  define A 0\\n\"\n               \"#endif\\n\"\n               \"#endif\\n\",\n               Style);\n  // Don't crash if there is an #elif directive without a condition.\n  verifyFormat(\"#if 1\\n\"\n               \"int x;\\n\"\n               \"#elif\\n\"\n               \"int y;\\n\"\n               \"#else\\n\"\n               \"int z;\\n\"\n               \"#endif\",\n               Style);\n  // FIXME: This doesn't handle the case where there's code between the\n  // #ifndef and #define but all other conditions hold. This is because when\n  // the #define line is parsed, UnwrappedLineParser::Lines doesn't hold the\n  // previous code line yet, so we can't detect it.\n  EXPECT_EQ(\"#ifndef NOT_GUARD\\n\"\n            \"code();\\n\"\n            \"#define NOT_GUARD\\n\"\n            \"code();\\n\"\n            \"#endif\",\n            format(\"#ifndef NOT_GUARD\\n\"\n                   \"code();\\n\"\n                   \"#  define NOT_GUARD\\n\"\n                   \"code();\\n\"\n                   \"#endif\",\n                   Style));\n  // FIXME: This doesn't handle cases where legitimate preprocessor lines may\n  // be outside an include guard. Examples are #pragma once and\n  // #pragma GCC diagnostic, or anything else that does not change the meaning\n  // of the file if it's included multiple times.\n  EXPECT_EQ(\"#ifdef WIN32\\n\"\n            \"#  pragma once\\n\"\n            \"#endif\\n\"\n            \"#ifndef HEADER_H\\n\"\n            \"#  define HEADER_H\\n\"\n            \"code();\\n\"\n            \"#endif\",\n            format(\"#ifdef WIN32\\n\"\n                   \"#  pragma once\\n\"\n                   \"#endif\\n\"\n                   \"#ifndef HEADER_H\\n\"\n                   \"#define HEADER_H\\n\"\n                   \"code();\\n\"\n                   \"#endif\",\n                   Style));\n  // FIXME: This does not detect when there is a single non-preprocessor line\n  // in front of an include-guard-like structure where other conditions hold\n  // because ScopedLineState hides the line.\n  EXPECT_EQ(\"code();\\n\"\n            \"#ifndef HEADER_H\\n\"\n            \"#define HEADER_H\\n\"\n            \"code();\\n\"\n            \"#endif\",\n            format(\"code();\\n\"\n                   \"#ifndef HEADER_H\\n\"\n                   \"#  define HEADER_H\\n\"\n                   \"code();\\n\"\n                   \"#endif\",\n                   Style));\n  // Keep comments aligned with #, otherwise indent comments normally. These\n  // tests cannot use verifyFormat because messUp manipulates leading\n  // whitespace.\n  {\n    const char *Expected = \"\"\n                           \"void f() {\\n\"\n                           \"#if 1\\n\"\n                           \"// Preprocessor aligned.\\n\"\n                           \"#  define A 0\\n\"\n                           \"  // Code. Separated by blank line.\\n\"\n                           \"\\n\"\n                           \"#  define B 0\\n\"\n                           \"  // Code. Not aligned with #\\n\"\n                           \"#  define C 0\\n\"\n                           \"#endif\";\n    const char *ToFormat = \"\"\n                           \"void f() {\\n\"\n                           \"#if 1\\n\"\n                           \"// Preprocessor aligned.\\n\"\n                           \"#  define A 0\\n\"\n                           \"// Code. Separated by blank line.\\n\"\n                           \"\\n\"\n                           \"#  define B 0\\n\"\n                           \"   // Code. Not aligned with #\\n\"\n                           \"#  define C 0\\n\"\n                           \"#endif\";\n    EXPECT_EQ(Expected, format(ToFormat, Style));\n    EXPECT_EQ(Expected, format(Expected, Style));\n  }\n  // Keep block quotes aligned.\n  {\n    const char *Expected = \"\"\n                           \"void f() {\\n\"\n                           \"#if 1\\n\"\n                           \"/* Preprocessor aligned. */\\n\"\n                           \"#  define A 0\\n\"\n                           \"  /* Code. Separated by blank line. */\\n\"\n                           \"\\n\"\n                           \"#  define B 0\\n\"\n                           \"  /* Code. Not aligned with # */\\n\"\n                           \"#  define C 0\\n\"\n                           \"#endif\";\n    const char *ToFormat = \"\"\n                           \"void f() {\\n\"\n                           \"#if 1\\n\"\n                           \"/* Preprocessor aligned. */\\n\"\n                           \"#  define A 0\\n\"\n                           \"/* Code. Separated by blank line. */\\n\"\n                           \"\\n\"\n                           \"#  define B 0\\n\"\n                           \"   /* Code. Not aligned with # */\\n\"\n                           \"#  define C 0\\n\"\n                           \"#endif\";\n    EXPECT_EQ(Expected, format(ToFormat, Style));\n    EXPECT_EQ(Expected, format(Expected, Style));\n  }\n  // Keep comments aligned with un-indented directives.\n  {\n    const char *Expected = \"\"\n                           \"void f() {\\n\"\n                           \"// Preprocessor aligned.\\n\"\n                           \"#define A 0\\n\"\n                           \"  // Code. Separated by blank line.\\n\"\n                           \"\\n\"\n                           \"#define B 0\\n\"\n                           \"  // Code. Not aligned with #\\n\"\n                           \"#define C 0\\n\";\n    const char *ToFormat = \"\"\n                           \"void f() {\\n\"\n                           \"// Preprocessor aligned.\\n\"\n                           \"#define A 0\\n\"\n                           \"// Code. Separated by blank line.\\n\"\n                           \"\\n\"\n                           \"#define B 0\\n\"\n                           \"   // Code. Not aligned with #\\n\"\n                           \"#define C 0\\n\";\n    EXPECT_EQ(Expected, format(ToFormat, Style));\n    EXPECT_EQ(Expected, format(Expected, Style));\n  }\n  // Test AfterHash with tabs.\n  {\n    FormatStyle Tabbed = Style;\n    Tabbed.UseTab = FormatStyle::UT_Always;\n    Tabbed.IndentWidth = 8;\n    Tabbed.TabWidth = 8;\n    verifyFormat(\"#ifdef _WIN32\\n\"\n                 \"#\\tdefine A 0\\n\"\n                 \"#\\tifdef VAR2\\n\"\n                 \"#\\t\\tdefine B 1\\n\"\n                 \"#\\t\\tinclude <someheader.h>\\n\"\n                 \"#\\t\\tdefine MACRO          \\\\\\n\"\n                 \"\\t\\t\\tsome_very_long_func_aaaaaaaaaa();\\n\"\n                 \"#\\tendif\\n\"\n                 \"#else\\n\"\n                 \"#\\tdefine A 1\\n\"\n                 \"#endif\",\n                 Tabbed);\n  }\n\n  // Regression test: Multiline-macro inside include guards.\n  verifyFormat(\"#ifndef HEADER_H\\n\"\n               \"#define HEADER_H\\n\"\n               \"#define A()        \\\\\\n\"\n               \"  int i;           \\\\\\n\"\n               \"  int j;\\n\"\n               \"#endif // HEADER_H\",\n               getLLVMStyleWithColumns(20));\n\n  Style.IndentPPDirectives = FormatStyle::PPDIS_BeforeHash;\n  // Basic before hash indent tests\n  verifyFormat(\"#ifdef _WIN32\\n\"\n               \"  #define A 0\\n\"\n               \"  #ifdef VAR2\\n\"\n               \"    #define B 1\\n\"\n               \"    #include <someheader.h>\\n\"\n               \"    #define MACRO                      \\\\\\n\"\n               \"      some_very_long_func_aaaaaaaaaa();\\n\"\n               \"  #endif\\n\"\n               \"#else\\n\"\n               \"  #define A 1\\n\"\n               \"#endif\",\n               Style);\n  verifyFormat(\"#if A\\n\"\n               \"  #define MACRO                        \\\\\\n\"\n               \"    void a(int x) {                    \\\\\\n\"\n               \"      b();                             \\\\\\n\"\n               \"      c();                             \\\\\\n\"\n               \"      d();                             \\\\\\n\"\n               \"      e();                             \\\\\\n\"\n               \"      f();                             \\\\\\n\"\n               \"    }\\n\"\n               \"#endif\",\n               Style);\n  // Keep comments aligned with indented directives. These\n  // tests cannot use verifyFormat because messUp manipulates leading\n  // whitespace.\n  {\n    const char *Expected = \"void f() {\\n\"\n                           \"// Aligned to preprocessor.\\n\"\n                           \"#if 1\\n\"\n                           \"  // Aligned to code.\\n\"\n                           \"  int a;\\n\"\n                           \"  #if 1\\n\"\n                           \"    // Aligned to preprocessor.\\n\"\n                           \"    #define A 0\\n\"\n                           \"  // Aligned to code.\\n\"\n                           \"  int b;\\n\"\n                           \"  #endif\\n\"\n                           \"#endif\\n\"\n                           \"}\";\n    const char *ToFormat = \"void f() {\\n\"\n                           \"// Aligned to preprocessor.\\n\"\n                           \"#if 1\\n\"\n                           \"// Aligned to code.\\n\"\n                           \"int a;\\n\"\n                           \"#if 1\\n\"\n                           \"// Aligned to preprocessor.\\n\"\n                           \"#define A 0\\n\"\n                           \"// Aligned to code.\\n\"\n                           \"int b;\\n\"\n                           \"#endif\\n\"\n                           \"#endif\\n\"\n                           \"}\";\n    EXPECT_EQ(Expected, format(ToFormat, Style));\n    EXPECT_EQ(Expected, format(Expected, Style));\n  }\n  {\n    const char *Expected = \"void f() {\\n\"\n                           \"/* Aligned to preprocessor. */\\n\"\n                           \"#if 1\\n\"\n                           \"  /* Aligned to code. */\\n\"\n                           \"  int a;\\n\"\n                           \"  #if 1\\n\"\n                           \"    /* Aligned to preprocessor. */\\n\"\n                           \"    #define A 0\\n\"\n                           \"  /* Aligned to code. */\\n\"\n                           \"  int b;\\n\"\n                           \"  #endif\\n\"\n                           \"#endif\\n\"\n                           \"}\";\n    const char *ToFormat = \"void f() {\\n\"\n                           \"/* Aligned to preprocessor. */\\n\"\n                           \"#if 1\\n\"\n                           \"/* Aligned to code. */\\n\"\n                           \"int a;\\n\"\n                           \"#if 1\\n\"\n                           \"/* Aligned to preprocessor. */\\n\"\n                           \"#define A 0\\n\"\n                           \"/* Aligned to code. */\\n\"\n                           \"int b;\\n\"\n                           \"#endif\\n\"\n                           \"#endif\\n\"\n                           \"}\";\n    EXPECT_EQ(Expected, format(ToFormat, Style));\n    EXPECT_EQ(Expected, format(Expected, Style));\n  }\n\n  // Test single comment before preprocessor\n  verifyFormat(\"// Comment\\n\"\n               \"\\n\"\n               \"#if 1\\n\"\n               \"#endif\",\n               Style);\n}\n\nTEST_F(FormatTest, FormatHashIfNotAtStartOfLine) {\n  verifyFormat(\"{\\n  { a #c; }\\n}\");\n}\n\nTEST_F(FormatTest, FormatUnbalancedStructuralElements) {\n  EXPECT_EQ(\"#define A \\\\\\n  {       \\\\\\n    {\\nint i;\",\n            format(\"#define A { {\\nint i;\", getLLVMStyleWithColumns(11)));\n  EXPECT_EQ(\"#define A \\\\\\n  }       \\\\\\n  }\\nint i;\",\n            format(\"#define A } }\\nint i;\", getLLVMStyleWithColumns(11)));\n}\n\nTEST_F(FormatTest, EscapedNewlines) {\n  FormatStyle Narrow = getLLVMStyleWithColumns(11);\n  EXPECT_EQ(\"#define A \\\\\\n  int i;  \\\\\\n  int j;\",\n            format(\"#define A \\\\\\nint i;\\\\\\n  int j;\", Narrow));\n  EXPECT_EQ(\"#define A\\n\\nint i;\", format(\"#define A \\\\\\n\\n int i;\"));\n  EXPECT_EQ(\"template <class T> f();\", format(\"\\\\\\ntemplate <class T> f();\"));\n  EXPECT_EQ(\"/* \\\\  \\\\  \\\\\\n */\", format(\"\\\\\\n/* \\\\  \\\\  \\\\\\n */\"));\n  EXPECT_EQ(\"<a\\n\\\\\\\\\\n>\", format(\"<a\\n\\\\\\\\\\n>\"));\n\n  FormatStyle AlignLeft = getLLVMStyle();\n  AlignLeft.AlignEscapedNewlines = FormatStyle::ENAS_Left;\n  EXPECT_EQ(\"#define MACRO(x) \\\\\\n\"\n            \"private:         \\\\\\n\"\n            \"  int x(int a);\\n\",\n            format(\"#define MACRO(x) \\\\\\n\"\n                   \"private:         \\\\\\n\"\n                   \"  int x(int a);\\n\",\n                   AlignLeft));\n\n  // CRLF line endings\n  EXPECT_EQ(\"#define A \\\\\\r\\n  int i;  \\\\\\r\\n  int j;\",\n            format(\"#define A \\\\\\r\\nint i;\\\\\\r\\n  int j;\", Narrow));\n  EXPECT_EQ(\"#define A\\r\\n\\r\\nint i;\", format(\"#define A \\\\\\r\\n\\r\\n int i;\"));\n  EXPECT_EQ(\"template <class T> f();\", format(\"\\\\\\ntemplate <class T> f();\"));\n  EXPECT_EQ(\"/* \\\\  \\\\  \\\\\\r\\n */\", format(\"\\\\\\r\\n/* \\\\  \\\\  \\\\\\r\\n */\"));\n  EXPECT_EQ(\"<a\\r\\n\\\\\\\\\\r\\n>\", format(\"<a\\r\\n\\\\\\\\\\r\\n>\"));\n  EXPECT_EQ(\"#define MACRO(x) \\\\\\r\\n\"\n            \"private:         \\\\\\r\\n\"\n            \"  int x(int a);\\r\\n\",\n            format(\"#define MACRO(x) \\\\\\r\\n\"\n                   \"private:         \\\\\\r\\n\"\n                   \"  int x(int a);\\r\\n\",\n                   AlignLeft));\n\n  FormatStyle DontAlign = getLLVMStyle();\n  DontAlign.AlignEscapedNewlines = FormatStyle::ENAS_DontAlign;\n  DontAlign.MaxEmptyLinesToKeep = 3;\n  // FIXME: can't use verifyFormat here because the newline before\n  // \"public:\" is not inserted the first time it's reformatted\n  EXPECT_EQ(\"#define A \\\\\\n\"\n            \"  class Foo { \\\\\\n\"\n            \"    void bar(); \\\\\\n\"\n            \"\\\\\\n\"\n            \"\\\\\\n\"\n            \"\\\\\\n\"\n            \"  public: \\\\\\n\"\n            \"    void baz(); \\\\\\n\"\n            \"  };\",\n            format(\"#define A \\\\\\n\"\n                   \"  class Foo { \\\\\\n\"\n                   \"    void bar(); \\\\\\n\"\n                   \"\\\\\\n\"\n                   \"\\\\\\n\"\n                   \"\\\\\\n\"\n                   \"  public: \\\\\\n\"\n                   \"    void baz(); \\\\\\n\"\n                   \"  };\",\n                   DontAlign));\n}\n\nTEST_F(FormatTest, CalculateSpaceOnConsecutiveLinesInMacro) {\n  verifyFormat(\"#define A \\\\\\n\"\n               \"  int v(  \\\\\\n\"\n               \"      a); \\\\\\n\"\n               \"  int i;\",\n               getLLVMStyleWithColumns(11));\n}\n\nTEST_F(FormatTest, MixingPreprocessorDirectivesAndNormalCode) {\n  EXPECT_EQ(\n      \"#define ALooooooooooooooooooooooooooooooooooooooongMacro(\"\n      \"                      \\\\\\n\"\n      \"    aLoooooooooooooooooooooooongFuuuuuuuuuuuuuunctiooooooooo)\\n\"\n      \"\\n\"\n      \"AlooooooooooooooooooooooooooooooooooooooongCaaaaaaaaaal(\\n\"\n      \"    aLooooooooooooooooooooooonPaaaaaaaaaaaaaaaaaaaaarmmmm);\\n\",\n      format(\"  #define   ALooooooooooooooooooooooooooooooooooooooongMacro(\"\n             \"\\\\\\n\"\n             \"aLoooooooooooooooooooooooongFuuuuuuuuuuuuuunctiooooooooo)\\n\"\n             \"  \\n\"\n             \"   AlooooooooooooooooooooooooooooooooooooooongCaaaaaaaaaal(\\n\"\n             \"  aLooooooooooooooooooooooonPaaaaaaaaaaaaaaaaaaaaarmmmm);\\n\"));\n}\n\nTEST_F(FormatTest, LayoutStatementsAroundPreprocessorDirectives) {\n  EXPECT_EQ(\"int\\n\"\n            \"#define A\\n\"\n            \"    a;\",\n            format(\"int\\n#define A\\na;\"));\n  verifyFormat(\"functionCallTo(\\n\"\n               \"    someOtherFunction(\\n\"\n               \"        withSomeParameters, whichInSequence,\\n\"\n               \"        areLongerThanALine(andAnotherCall,\\n\"\n               \"#define A B\\n\"\n               \"                           withMoreParamters,\\n\"\n               \"                           whichStronglyInfluenceTheLayout),\\n\"\n               \"        andMoreParameters),\\n\"\n               \"    trailing);\",\n               getLLVMStyleWithColumns(69));\n  verifyFormat(\"Foo::Foo()\\n\"\n               \"#ifdef BAR\\n\"\n               \"    : baz(0)\\n\"\n               \"#endif\\n\"\n               \"{\\n\"\n               \"}\");\n  verifyFormat(\"void f() {\\n\"\n               \"  if (true)\\n\"\n               \"#ifdef A\\n\"\n               \"    f(42);\\n\"\n               \"  x();\\n\"\n               \"#else\\n\"\n               \"    g();\\n\"\n               \"  x();\\n\"\n               \"#endif\\n\"\n               \"}\");\n  verifyFormat(\"void f(param1, param2,\\n\"\n               \"       param3,\\n\"\n               \"#ifdef A\\n\"\n               \"       param4(param5,\\n\"\n               \"#ifdef A1\\n\"\n               \"              param6,\\n\"\n               \"#ifdef A2\\n\"\n               \"              param7),\\n\"\n               \"#else\\n\"\n               \"              param8),\\n\"\n               \"       param9,\\n\"\n               \"#endif\\n\"\n               \"       param10,\\n\"\n               \"#endif\\n\"\n               \"       param11)\\n\"\n               \"#else\\n\"\n               \"       param12)\\n\"\n               \"#endif\\n\"\n               \"{\\n\"\n               \"  x();\\n\"\n               \"}\",\n               getLLVMStyleWithColumns(28));\n  verifyFormat(\"#if 1\\n\"\n               \"int i;\");\n  verifyFormat(\"#if 1\\n\"\n               \"#endif\\n\"\n               \"#if 1\\n\"\n               \"#else\\n\"\n               \"#endif\\n\");\n  verifyFormat(\"DEBUG({\\n\"\n               \"  return aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n               \"         aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\\n\"\n               \"});\\n\"\n               \"#if a\\n\"\n               \"#else\\n\"\n               \"#endif\");\n\n  verifyIncompleteFormat(\"void f(\\n\"\n                         \"#if A\\n\"\n                         \");\\n\"\n                         \"#else\\n\"\n                         \"#endif\");\n}\n\nTEST_F(FormatTest, GraciouslyHandleIncorrectPreprocessorConditions) {\n  verifyFormat(\"#endif\\n\"\n               \"#if B\");\n}\n\nTEST_F(FormatTest, FormatsJoinedLinesOnSubsequentRuns) {\n  FormatStyle SingleLine = getLLVMStyle();\n  SingleLine.AllowShortIfStatementsOnASingleLine = FormatStyle::SIS_WithoutElse;\n  verifyFormat(\"#if 0\\n\"\n               \"#elif 1\\n\"\n               \"#endif\\n\"\n               \"void foo() {\\n\"\n               \"  if (test) foo2();\\n\"\n               \"}\",\n               SingleLine);\n}\n\nTEST_F(FormatTest, LayoutBlockInsideParens) {\n  verifyFormat(\"functionCall({ int i; });\");\n  verifyFormat(\"functionCall({\\n\"\n               \"  int i;\\n\"\n               \"  int j;\\n\"\n               \"});\");\n  verifyFormat(\"functionCall(\\n\"\n               \"    {\\n\"\n               \"      int i;\\n\"\n               \"      int j;\\n\"\n               \"    },\\n\"\n               \"    aaaa, bbbb, cccc);\");\n  verifyFormat(\"functionA(functionB({\\n\"\n               \"            int i;\\n\"\n               \"            int j;\\n\"\n               \"          }),\\n\"\n               \"          aaaa, bbbb, cccc);\");\n  verifyFormat(\"functionCall(\\n\"\n               \"    {\\n\"\n               \"      int i;\\n\"\n               \"      int j;\\n\"\n               \"    },\\n\"\n               \"    aaaa, bbbb, // comment\\n\"\n               \"    cccc);\");\n  verifyFormat(\"functionA(functionB({\\n\"\n               \"            int i;\\n\"\n               \"            int j;\\n\"\n               \"          }),\\n\"\n               \"          aaaa, bbbb, // comment\\n\"\n               \"          cccc);\");\n  verifyFormat(\"functionCall(aaaa, bbbb, { int i; });\");\n  verifyFormat(\"functionCall(aaaa, bbbb, {\\n\"\n               \"  int i;\\n\"\n               \"  int j;\\n\"\n               \"});\");\n  verifyFormat(\n      \"Aaa(\\n\" // FIXME: There shouldn't be a linebreak here.\n      \"    {\\n\"\n      \"      int i; // break\\n\"\n      \"    },\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,\\n\"\n      \"                                     ccccccccccccccccc));\");\n  verifyFormat(\"DEBUG({\\n\"\n               \"  if (a)\\n\"\n               \"    f();\\n\"\n               \"});\");\n}\n\nTEST_F(FormatTest, LayoutBlockInsideStatement) {\n  EXPECT_EQ(\"SOME_MACRO { int i; }\\n\"\n            \"int i;\",\n            format(\"  SOME_MACRO  {int i;}  int i;\"));\n}\n\nTEST_F(FormatTest, LayoutNestedBlocks) {\n  verifyFormat(\"void AddOsStrings(unsigned bitmask) {\\n\"\n               \"  struct s {\\n\"\n               \"    int i;\\n\"\n               \"  };\\n\"\n               \"  s kBitsToOs[] = {{10}};\\n\"\n               \"  for (int i = 0; i < 10; ++i)\\n\"\n               \"    return;\\n\"\n               \"}\");\n  verifyFormat(\"call(parameter, {\\n\"\n               \"  something();\\n\"\n               \"  // Comment using all columns.\\n\"\n               \"  somethingelse();\\n\"\n               \"});\",\n               getLLVMStyleWithColumns(40));\n  verifyFormat(\"DEBUG( //\\n\"\n               \"    { f(); }, a);\");\n  verifyFormat(\"DEBUG( //\\n\"\n               \"    {\\n\"\n               \"      f(); //\\n\"\n               \"    },\\n\"\n               \"    a);\");\n\n  EXPECT_EQ(\"call(parameter, {\\n\"\n            \"  something();\\n\"\n            \"  // Comment too\\n\"\n            \"  // looooooooooong.\\n\"\n            \"  somethingElse();\\n\"\n            \"});\",\n            format(\"call(parameter, {\\n\"\n                   \"  something();\\n\"\n                   \"  // Comment too looooooooooong.\\n\"\n                   \"  somethingElse();\\n\"\n                   \"});\",\n                   getLLVMStyleWithColumns(29)));\n  EXPECT_EQ(\"DEBUG({ int i; });\", format(\"DEBUG({ int   i; });\"));\n  EXPECT_EQ(\"DEBUG({ // comment\\n\"\n            \"  int i;\\n\"\n            \"});\",\n            format(\"DEBUG({ // comment\\n\"\n                   \"int  i;\\n\"\n                   \"});\"));\n  EXPECT_EQ(\"DEBUG({\\n\"\n            \"  int i;\\n\"\n            \"\\n\"\n            \"  // comment\\n\"\n            \"  int j;\\n\"\n            \"});\",\n            format(\"DEBUG({\\n\"\n                   \"  int  i;\\n\"\n                   \"\\n\"\n                   \"  // comment\\n\"\n                   \"  int  j;\\n\"\n                   \"});\"));\n\n  verifyFormat(\"DEBUG({\\n\"\n               \"  if (a)\\n\"\n               \"    return;\\n\"\n               \"});\");\n  verifyGoogleFormat(\"DEBUG({\\n\"\n                     \"  if (a) return;\\n\"\n                     \"});\");\n  FormatStyle Style = getGoogleStyle();\n  Style.ColumnLimit = 45;\n  verifyFormat(\"Debug(\\n\"\n               \"    aaaaa,\\n\"\n               \"    {\\n\"\n               \"      if (aaaaaaaaaaaaaaaaaaaaaaaa) return;\\n\"\n               \"    },\\n\"\n               \"    a);\",\n               Style);\n\n  verifyFormat(\"SomeFunction({MACRO({ return output; }), b});\");\n\n  verifyNoCrash(\"^{v^{a}}\");\n}\n\nTEST_F(FormatTest, FormatNestedBlocksInMacros) {\n  EXPECT_EQ(\"#define MACRO()                     \\\\\\n\"\n            \"  Debug(aaa, /* force line break */ \\\\\\n\"\n            \"        {                           \\\\\\n\"\n            \"          int i;                    \\\\\\n\"\n            \"          int j;                    \\\\\\n\"\n            \"        })\",\n            format(\"#define   MACRO()   Debug(aaa,  /* force line break */ \\\\\\n\"\n                   \"          {  int   i;  int  j;   })\",\n                   getGoogleStyle()));\n\n  EXPECT_EQ(\"#define A                                       \\\\\\n\"\n            \"  [] {                                          \\\\\\n\"\n            \"    xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx(        \\\\\\n\"\n            \"        xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx); \\\\\\n\"\n            \"  }\",\n            format(\"#define A [] { xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx( \\\\\\n\"\n                   \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx); }\",\n                   getGoogleStyle()));\n}\n\nTEST_F(FormatTest, PutEmptyBlocksIntoOneLine) {\n  EXPECT_EQ(\"{}\", format(\"{}\"));\n  verifyFormat(\"enum E {};\");\n  verifyFormat(\"enum E {}\");\n  FormatStyle Style = getLLVMStyle();\n  Style.SpaceInEmptyBlock = true;\n  EXPECT_EQ(\"void f() { }\", format(\"void f() {}\", Style));\n  Style.AllowShortBlocksOnASingleLine = FormatStyle::SBS_Empty;\n  EXPECT_EQ(\"while (true) { }\", format(\"while (true) {}\", Style));\n}\n\nTEST_F(FormatTest, FormatBeginBlockEndMacros) {\n  FormatStyle Style = getLLVMStyle();\n  Style.MacroBlockBegin = \"^[A-Z_]+_BEGIN$\";\n  Style.MacroBlockEnd = \"^[A-Z_]+_END$\";\n  verifyFormat(\"FOO_BEGIN\\n\"\n               \"  FOO_ENTRY\\n\"\n               \"FOO_END\",\n               Style);\n  verifyFormat(\"FOO_BEGIN\\n\"\n               \"  NESTED_FOO_BEGIN\\n\"\n               \"    NESTED_FOO_ENTRY\\n\"\n               \"  NESTED_FOO_END\\n\"\n               \"FOO_END\",\n               Style);\n  verifyFormat(\"FOO_BEGIN(Foo, Bar)\\n\"\n               \"  int x;\\n\"\n               \"  x = 1;\\n\"\n               \"FOO_END(Baz)\",\n               Style);\n}\n\n//===----------------------------------------------------------------------===//\n// Line break tests.\n//===----------------------------------------------------------------------===//\n\nTEST_F(FormatTest, PreventConfusingIndents) {\n  verifyFormat(\n      \"void f() {\\n\"\n      \"  SomeLongMethodName(SomeReallyLongMethod(CallOtherReallyLongMethod(\\n\"\n      \"                         parameter, parameter, parameter)),\\n\"\n      \"                     SecondLongCall(parameter));\\n\"\n      \"}\");\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa),\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"    [aaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"         [aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa]\\n\"\n      \"         [aaaaaaaaaaaaaaaaaaaaaaaa]];\");\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaa<\\n\"\n      \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa>,\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaa>;\");\n  verifyFormat(\"int a = bbbb && ccc &&\\n\"\n               \"        fffff(\\n\"\n               \"#define A Just forcing a new line\\n\"\n               \"            ddd);\");\n}\n\nTEST_F(FormatTest, LineBreakingInBinaryExpressions) {\n  verifyFormat(\n      \"bool aaaaaaa =\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(aaa).aaaaaaaaaaaaaaaaaaa() ||\\n\"\n      \"    bbbbbbbb();\");\n  verifyFormat(\n      \"bool aaaaaaa =\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(aaa).aaaaaaaaaaaaaaaaaaa() or\\n\"\n      \"    bbbbbbbb();\");\n\n  verifyFormat(\"bool aaaaaaaaaaaaaaaaaaaaa =\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa != bbbbbbbbbbbbbbbbbb &&\\n\"\n               \"    ccccccccc == ddddddddddd;\");\n  verifyFormat(\"bool aaaaaaaaaaaaaaaaaaaaa =\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa != bbbbbbbbbbbbbbbbbb and\\n\"\n               \"    ccccccccc == ddddddddddd;\");\n  verifyFormat(\n      \"bool aaaaaaaaaaaaaaaaaaaaa =\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa not_eq bbbbbbbbbbbbbbbbbb and\\n\"\n      \"    ccccccccc == ddddddddddd;\");\n\n  verifyFormat(\"aaaaaa = aaaaaaa(aaaaaaa, // break\\n\"\n               \"                 aaaaaa) &&\\n\"\n               \"         bbbbbb && cccccc;\");\n  verifyFormat(\"aaaaaa = aaaaaaa(aaaaaaa, // break\\n\"\n               \"                 aaaaaa) >>\\n\"\n               \"         bbbbbb;\");\n  verifyFormat(\"aa = Whitespaces.addUntouchableComment(\\n\"\n               \"    SourceMgr.getSpellingColumnNumber(\\n\"\n               \"        TheLine.Last->FormatTok.Tok.getLocation()) -\\n\"\n               \"    1);\");\n\n  verifyFormat(\"if ((aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ||\\n\"\n               \"     bbbbbbbbbbbbbbbbbb) && // aaaaaaaaaaaaaaaa\\n\"\n               \"    cccccc) {\\n}\");\n  verifyFormat(\"if constexpr ((aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ||\\n\"\n               \"               bbbbbbbbbbbbbbbbbb) && // aaaaaaaaaaa\\n\"\n               \"              cccccc) {\\n}\");\n  verifyFormat(\"if CONSTEXPR ((aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ||\\n\"\n               \"               bbbbbbbbbbbbbbbbbb) && // aaaaaaaaaaa\\n\"\n               \"              cccccc) {\\n}\");\n  verifyFormat(\"b = a &&\\n\"\n               \"    // Comment\\n\"\n               \"    b.c && d;\");\n\n  // If the LHS of a comparison is not a binary expression itself, the\n  // additional linebreak confuses many people.\n  verifyFormat(\n      \"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) > 5) {\\n\"\n      \"}\");\n  verifyFormat(\n      \"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) == 5) {\\n\"\n      \"}\");\n  verifyFormat(\n      \"if (aaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) == 5) {\\n\"\n      \"}\");\n  verifyFormat(\n      \"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) <=> 5) {\\n\"\n      \"}\");\n  // Even explicit parentheses stress the precedence enough to make the\n  // additional break unnecessary.\n  verifyFormat(\"if ((aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n               \"     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) == 5) {\\n\"\n               \"}\");\n  // This cases is borderline, but with the indentation it is still readable.\n  verifyFormat(\n      \"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"        aaaaaaaaaaaaaaa) > aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n      \"                               aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {\\n\"\n      \"}\",\n      getLLVMStyleWithColumns(75));\n\n  // If the LHS is a binary expression, we should still use the additional break\n  // as otherwise the formatting hides the operator precedence.\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==\\n\"\n               \"    5) {\\n\"\n               \"}\");\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa <=>\\n\"\n               \"    5) {\\n\"\n               \"}\");\n\n  FormatStyle OnePerLine = getLLVMStyle();\n  OnePerLine.BinPackParameters = false;\n  verifyFormat(\n      \"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaa || aaaaaaaaaaaaaaaaaaaaaaaaaaaa ||\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaa || aaaaaaaaaaaaaaaaaaaaaaaaaaaa ||\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaa) {\\n}\",\n      OnePerLine);\n\n  verifyFormat(\"int i = someFunction(aaaaaaa, 0)\\n\"\n               \"                .aaa(aaaaaaaaaaaaa) *\\n\"\n               \"            aaaaaaa +\\n\"\n               \"        aaaaaaa;\",\n               getLLVMStyleWithColumns(40));\n}\n\nTEST_F(FormatTest, ExpressionIndentation) {\n  verifyFormat(\"bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n               \"                     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n               \"                     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==\\n\"\n               \"                 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa *\\n\"\n               \"                         bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb +\\n\"\n               \"                     bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb &&\\n\"\n               \"             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa *\\n\"\n               \"                     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >\\n\"\n               \"                 ccccccccccccccccccccccccccccccccccccccccc;\");\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa *\\n\"\n               \"            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==\\n\"\n               \"    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb) {\\n}\");\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa *\\n\"\n               \"            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==\\n\"\n               \"    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb) {\\n}\");\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa *\\n\"\n               \"            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n               \"        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb) {\\n}\");\n  verifyFormat(\"if () {\\n\"\n               \"} else if (aaaaa && bbbbb > // break\\n\"\n               \"                        ccccc) {\\n\"\n               \"}\");\n  verifyFormat(\"if () {\\n\"\n               \"} else if constexpr (aaaaa && bbbbb > // break\\n\"\n               \"                                  ccccc) {\\n\"\n               \"}\");\n  verifyFormat(\"if () {\\n\"\n               \"} else if CONSTEXPR (aaaaa && bbbbb > // break\\n\"\n               \"                                  ccccc) {\\n\"\n               \"}\");\n  verifyFormat(\"if () {\\n\"\n               \"} else if (aaaaa &&\\n\"\n               \"           bbbbb > // break\\n\"\n               \"               ccccc &&\\n\"\n               \"           ddddd) {\\n\"\n               \"}\");\n\n  // Presence of a trailing comment used to change indentation of b.\n  verifyFormat(\"return aaaaaaaaaaaaaaaaaaa +\\n\"\n               \"       b;\\n\"\n               \"return aaaaaaaaaaaaaaaaaaa +\\n\"\n               \"       b; //\",\n               getLLVMStyleWithColumns(30));\n}\n\nTEST_F(FormatTest, ExpressionIndentationBreakingBeforeOperators) {\n  // Not sure what the best system is here. Like this, the LHS can be found\n  // immediately above an operator (everything with the same or a higher\n  // indent). The RHS is aligned right of the operator and so compasses\n  // everything until something with the same indent as the operator is found.\n  // FIXME: Is this a good system?\n  FormatStyle Style = getLLVMStyle();\n  Style.BreakBeforeBinaryOperators = FormatStyle::BOS_All;\n  verifyFormat(\n      \"bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                     + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                     + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                 == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                            * bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\n\"\n      \"                        + bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\n\"\n      \"             && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                        * aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                    > ccccccccccccccccccccccccccccccccccccccccc;\",\n      Style);\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"            * aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"        + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    == bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb) {\\n}\",\n               Style);\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"        + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"              * aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    == bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb) {\\n}\",\n               Style);\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"               * aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"           + bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb) {\\n}\",\n               Style);\n  verifyFormat(\"if () {\\n\"\n               \"} else if (aaaaa\\n\"\n               \"           && bbbbb // break\\n\"\n               \"                  > ccccc) {\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"       && bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\",\n               Style);\n  verifyFormat(\"return (a)\\n\"\n               \"       // comment\\n\"\n               \"       + b;\",\n               Style);\n  verifyFormat(\n      \"int aaaaaa = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                 * bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\n\"\n      \"             + cc;\",\n      Style);\n\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    = aaaaaaaaaaaaaaaaaaaa + aaaaaaaaaaaaaaaaaaaaaaaaaaaa;\",\n               Style);\n\n  // Forced by comments.\n  verifyFormat(\n      \"unsigned ContentSize =\\n\"\n      \"    sizeof(int16_t)   // DWARF ARange version number\\n\"\n      \"    + sizeof(int32_t) // Offset of CU in the .debug_info section\\n\"\n      \"    + sizeof(int8_t)  // Pointer Size (in bytes)\\n\"\n      \"    + sizeof(int8_t); // Segment Size (in bytes)\");\n\n  verifyFormat(\"return boost::fusion::at_c<0>(iiii).second\\n\"\n               \"       == boost::fusion::at_c<1>(iiii).second;\",\n               Style);\n\n  Style.ColumnLimit = 60;\n  verifyFormat(\"zzzzzzzzzz\\n\"\n               \"    = bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\n\"\n               \"      >> aaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaa);\",\n               Style);\n\n  Style.ColumnLimit = 80;\n  Style.IndentWidth = 4;\n  Style.TabWidth = 4;\n  Style.UseTab = FormatStyle::UT_Always;\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_DontAlign;\n  Style.AlignOperands = FormatStyle::OAS_DontAlign;\n  EXPECT_EQ(\"return someVeryVeryLongConditionThatBarelyFitsOnALine\\n\"\n            \"\\t&& (someOtherLongishConditionPart1\\n\"\n            \"\\t\\t|| someOtherEvenLongerNestedConditionPart2);\",\n            format(\"return someVeryVeryLongConditionThatBarelyFitsOnALine && \"\n                   \"(someOtherLongishConditionPart1 || \"\n                   \"someOtherEvenLongerNestedConditionPart2);\",\n                   Style));\n}\n\nTEST_F(FormatTest, ExpressionIndentationStrictAlign) {\n  FormatStyle Style = getLLVMStyle();\n  Style.BreakBeforeBinaryOperators = FormatStyle::BOS_All;\n  Style.AlignOperands = FormatStyle::OAS_AlignAfterOperator;\n\n  verifyFormat(\"bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"                   + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"                   + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"              == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"                         * bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\n\"\n               \"                     + bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\n\"\n               \"          && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"                     * aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"                 > ccccccccccccccccccccccccccccccccccccccccc;\",\n               Style);\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"            * aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"        + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    == bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb) {\\n}\",\n               Style);\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"        + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"              * aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    == bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb) {\\n}\",\n               Style);\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"               * aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"           + bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb) {\\n}\",\n               Style);\n  verifyFormat(\"if () {\\n\"\n               \"} else if (aaaaa\\n\"\n               \"           && bbbbb // break\\n\"\n               \"                  > ccccc) {\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    && bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\",\n               Style);\n  verifyFormat(\"return (a)\\n\"\n               \"     // comment\\n\"\n               \"     + b;\",\n               Style);\n  verifyFormat(\n      \"int aaaaaa = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"               * bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\n\"\n      \"           + cc;\",\n      Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaa ? 1111111111111111\\n\"\n               \"     : bbbbbbbbbbbbbbbb ? 2222222222222222\\n\"\n               \"                        : 3333333333333333;\",\n               Style);\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaa ? (aaaaaaaaaaaaaa    ? bbbbbbbbbbbbbbbbbb\\n\"\n      \"                           : ccccccccccccccc ? dddddddddddddddddd\\n\"\n      \"                                             : eeeeeeeeeeeeeeeeee)\\n\"\n      \"     : bbbbbbbbbbbbbbbb ? 2222222222222222\\n\"\n      \"                        : 3333333333333333;\",\n      Style);\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    = aaaaaaaaaaaaaaaaaaaa + aaaaaaaaaaaaaaaaaaaaaaaaaaaa;\",\n               Style);\n\n  verifyFormat(\"return boost::fusion::at_c<0>(iiii).second\\n\"\n               \"    == boost::fusion::at_c<1>(iiii).second;\",\n               Style);\n\n  Style.ColumnLimit = 60;\n  verifyFormat(\"zzzzzzzzzzzzz\\n\"\n               \"    = bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\n\"\n               \"   >> aaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaa);\",\n               Style);\n\n  // Forced by comments.\n  Style.ColumnLimit = 80;\n  verifyFormat(\n      \"unsigned ContentSize\\n\"\n      \"    = sizeof(int16_t) // DWARF ARange version number\\n\"\n      \"    + sizeof(int32_t) // Offset of CU in the .debug_info section\\n\"\n      \"    + sizeof(int8_t)  // Pointer Size (in bytes)\\n\"\n      \"    + sizeof(int8_t); // Segment Size (in bytes)\",\n      Style);\n\n  Style.BreakBeforeBinaryOperators = FormatStyle::BOS_NonAssignment;\n  verifyFormat(\n      \"unsigned ContentSize =\\n\"\n      \"    sizeof(int16_t)   // DWARF ARange version number\\n\"\n      \"    + sizeof(int32_t) // Offset of CU in the .debug_info section\\n\"\n      \"    + sizeof(int8_t)  // Pointer Size (in bytes)\\n\"\n      \"    + sizeof(int8_t); // Segment Size (in bytes)\",\n      Style);\n\n  Style.BreakBeforeBinaryOperators = FormatStyle::BOS_None;\n  verifyFormat(\n      \"unsigned ContentSize =\\n\"\n      \"    sizeof(int16_t)   // DWARF ARange version number\\n\"\n      \"    + sizeof(int32_t) // Offset of CU in the .debug_info section\\n\"\n      \"    + sizeof(int8_t)  // Pointer Size (in bytes)\\n\"\n      \"    + sizeof(int8_t); // Segment Size (in bytes)\",\n      Style);\n}\n\nTEST_F(FormatTest, EnforcedOperatorWraps) {\n  // Here we'd like to wrap after the || operators, but a comment is forcing an\n  // earlier wrap.\n  verifyFormat(\"bool x = aaaaa //\\n\"\n               \"         || bbbbb\\n\"\n               \"         //\\n\"\n               \"         || cccc;\");\n}\n\nTEST_F(FormatTest, NoOperandAlignment) {\n  FormatStyle Style = getLLVMStyle();\n  Style.AlignOperands = FormatStyle::OAS_DontAlign;\n  verifyFormat(\"aaaaaaaaaaaaaa(aaaaaaaaaaaa,\\n\"\n               \"               aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n               \"                   aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\",\n               Style);\n  Style.BreakBeforeBinaryOperators = FormatStyle::BOS_NonAssignment;\n  verifyFormat(\"bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"            + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"            + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"        == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"                * bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\n\"\n               \"            + bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\n\"\n               \"    && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"            * aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"        > ccccccccccccccccccccccccccccccccccccccccc;\",\n               Style);\n\n  verifyFormat(\"int aaaaaa = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"        * bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\n\"\n               \"    + cc;\",\n               Style);\n  verifyFormat(\"int a = aa\\n\"\n               \"    + bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\n\"\n               \"        * cccccccccccccccccccccccccccccccccccc;\\n\",\n               Style);\n\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_DontAlign;\n  verifyFormat(\"return (a > b\\n\"\n               \"    // comment1\\n\"\n               \"    // comment2\\n\"\n               \"    || c);\",\n               Style);\n}\n\nTEST_F(FormatTest, BreakingBeforeNonAssigmentOperators) {\n  FormatStyle Style = getLLVMStyle();\n  Style.BreakBeforeBinaryOperators = FormatStyle::BOS_NonAssignment;\n  verifyFormat(\"int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa =\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    + bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\",\n               Style);\n}\n\nTEST_F(FormatTest, AllowBinPackingInsideArguments) {\n  FormatStyle Style = getLLVMStyle();\n  Style.BreakBeforeBinaryOperators = FormatStyle::BOS_NonAssignment;\n  Style.BinPackArguments = false;\n  Style.ColumnLimit = 40;\n  verifyFormat(\"void test() {\\n\"\n               \"  someFunction(\\n\"\n               \"      this + argument + is + quite\\n\"\n               \"      + long + so + it + gets + wrapped\\n\"\n               \"      + but + remains + bin - packed);\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"void test() {\\n\"\n               \"  someFunction(arg1,\\n\"\n               \"               this + argument + is\\n\"\n               \"                   + quite + long + so\\n\"\n               \"                   + it + gets + wrapped\\n\"\n               \"                   + but + remains + bin\\n\"\n               \"                   - packed,\\n\"\n               \"               arg3);\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"void test() {\\n\"\n               \"  someFunction(\\n\"\n               \"      arg1,\\n\"\n               \"      this + argument + has\\n\"\n               \"          + anotherFunc(nested,\\n\"\n               \"                        calls + whose\\n\"\n               \"                            + arguments\\n\"\n               \"                            + are + also\\n\"\n               \"                            + wrapped,\\n\"\n               \"                        in + addition)\\n\"\n               \"          + to + being + bin - packed,\\n\"\n               \"      arg3);\\n\"\n               \"}\",\n               Style);\n\n  Style.BreakBeforeBinaryOperators = FormatStyle::BOS_None;\n  verifyFormat(\"void test() {\\n\"\n               \"  someFunction(\\n\"\n               \"      arg1,\\n\"\n               \"      this + argument + has +\\n\"\n               \"          anotherFunc(nested,\\n\"\n               \"                      calls + whose +\\n\"\n               \"                          arguments +\\n\"\n               \"                          are + also +\\n\"\n               \"                          wrapped,\\n\"\n               \"                      in + addition) +\\n\"\n               \"          to + being + bin - packed,\\n\"\n               \"      arg3);\\n\"\n               \"}\",\n               Style);\n}\n\nTEST_F(FormatTest, ConstructorInitializers) {\n  verifyFormat(\"Constructor() : Initializer(FitsOnTheLine) {}\");\n  verifyFormat(\"Constructor() : Inttializer(FitsOnTheLine) {}\",\n               getLLVMStyleWithColumns(45));\n  verifyFormat(\"Constructor()\\n\"\n               \"    : Inttializer(FitsOnTheLine) {}\",\n               getLLVMStyleWithColumns(44));\n  verifyFormat(\"Constructor()\\n\"\n               \"    : Inttializer(FitsOnTheLine) {}\",\n               getLLVMStyleWithColumns(43));\n\n  verifyFormat(\"template <typename T>\\n\"\n               \"Constructor() : Initializer(FitsOnTheLine) {}\",\n               getLLVMStyleWithColumns(45));\n\n  verifyFormat(\n      \"SomeClass::Constructor()\\n\"\n      \"    : aaaaaaaaaaaaa(aaaaaaaaaaaaaa), aaaaaaaaaaaaaaa(aaaaaaaaaaaa) {}\");\n\n  verifyFormat(\n      \"SomeClass::Constructor()\\n\"\n      \"    : aaaaaaaaaaaaa(aaaaaaaaaaaaaa), aaaaaaaaaaaaa(aaaaaaaaaaaaaa),\\n\"\n      \"      aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}\");\n  verifyFormat(\n      \"SomeClass::Constructor()\\n\"\n      \"    : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa),\\n\"\n      \"      aaaaaaaaaaaaaaa(aaaaaaaaaaaa) {}\");\n  verifyFormat(\"Constructor(aaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"            aaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"    : aaaaaaaaaa(aaaaaa) {}\");\n\n  verifyFormat(\"Constructor()\\n\"\n               \"    : aaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaa),\\n\"\n               \"      aaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                               aaaaaaaaaaaaaaaaaaaaaaaaaaa),\\n\"\n               \"      aaaaaaaaaaaaaaaaaaaaaaa() {}\");\n\n  verifyFormat(\"Constructor()\\n\"\n               \"    : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"          aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\");\n\n  verifyFormat(\"Constructor(int Parameter = 0)\\n\"\n               \"    : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaa),\\n\"\n               \"      aaaaaaaaaaaa(aaaaaaaaaaaaaaaaa) {}\");\n  verifyFormat(\"Constructor()\\n\"\n               \"    : aaaaaaaaaaaaaaaaaaaa(a), bbbbbbbbbbbbbbbbbbbbbbbb(b) {\\n\"\n               \"}\",\n               getLLVMStyleWithColumns(60));\n  verifyFormat(\"Constructor()\\n\"\n               \"    : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"          aaaaaaaaaaaaaaaaaaaaaaaaa(aaaa, aaaa)) {}\");\n\n  // Here a line could be saved by splitting the second initializer onto two\n  // lines, but that is not desirable.\n  verifyFormat(\"Constructor()\\n\"\n               \"    : aaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaa),\\n\"\n               \"      aaaaaaaaaaa(aaaaaaaaaaa),\\n\"\n               \"      aaaaaaaaaaaaaaaaaaaaat(aaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\");\n\n  FormatStyle OnePerLine = getLLVMStyle();\n  OnePerLine.ConstructorInitializerAllOnOneLineOrOnePerLine = true;\n  OnePerLine.AllowAllParametersOfDeclarationOnNextLine = false;\n  verifyFormat(\"SomeClass::Constructor()\\n\"\n               \"    : aaaaaaaaaaaaa(aaaaaaaaaaaaaa),\\n\"\n               \"      aaaaaaaaaaaaa(aaaaaaaaaaaaaa),\\n\"\n               \"      aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}\",\n               OnePerLine);\n  verifyFormat(\"SomeClass::Constructor()\\n\"\n               \"    : aaaaaaaaaaaaa(aaaaaaaaaaaaaa), // Some comment\\n\"\n               \"      aaaaaaaaaaaaa(aaaaaaaaaaaaaa),\\n\"\n               \"      aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}\",\n               OnePerLine);\n  verifyFormat(\"MyClass::MyClass(int var)\\n\"\n               \"    : some_var_(var),            // 4 space indent\\n\"\n               \"      some_other_var_(var + 1) { // lined up\\n\"\n               \"}\",\n               OnePerLine);\n  verifyFormat(\"Constructor()\\n\"\n               \"    : aaaaa(aaaaaa),\\n\"\n               \"      aaaaa(aaaaaa),\\n\"\n               \"      aaaaa(aaaaaa),\\n\"\n               \"      aaaaa(aaaaaa),\\n\"\n               \"      aaaaa(aaaaaa) {}\",\n               OnePerLine);\n  verifyFormat(\"Constructor()\\n\"\n               \"    : aaaaa(aaaaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"            aaaaaaaaaaaaaaaaaaaaaa) {}\",\n               OnePerLine);\n  OnePerLine.BinPackParameters = false;\n  verifyFormat(\n      \"Constructor()\\n\"\n      \"    : aaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"          aaaaaaaaaaa().aaa(),\\n\"\n      \"          aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\",\n      OnePerLine);\n  OnePerLine.ColumnLimit = 60;\n  verifyFormat(\"Constructor()\\n\"\n               \"    : aaaaaaaaaaaaaaaaaaaa(a),\\n\"\n               \"      bbbbbbbbbbbbbbbbbbbbbbbb(b) {}\",\n               OnePerLine);\n\n  EXPECT_EQ(\"Constructor()\\n\"\n            \"    : // Comment forcing unwanted break.\\n\"\n            \"      aaaa(aaaa) {}\",\n            format(\"Constructor() :\\n\"\n                   \"    // Comment forcing unwanted break.\\n\"\n                   \"    aaaa(aaaa) {}\"));\n}\n\nTEST_F(FormatTest, AllowAllConstructorInitializersOnNextLine) {\n  FormatStyle Style = getLLVMStyle();\n  Style.BreakConstructorInitializers = FormatStyle::BCIS_BeforeComma;\n  Style.ColumnLimit = 60;\n  Style.ConstructorInitializerAllOnOneLineOrOnePerLine = true;\n  Style.AllowAllConstructorInitializersOnNextLine = true;\n  Style.BinPackParameters = false;\n\n  for (int i = 0; i < 4; ++i) {\n    // Test all combinations of parameters that should not have an effect.\n    Style.AllowAllParametersOfDeclarationOnNextLine = i & 1;\n    Style.AllowAllArgumentsOnNextLine = i & 2;\n\n    Style.AllowAllConstructorInitializersOnNextLine = true;\n    Style.BreakConstructorInitializers = FormatStyle::BCIS_BeforeComma;\n    verifyFormat(\"Constructor()\\n\"\n                 \"    : aaaaaaaaaaaaaaaaaaaa(a), bbbbbbbbbbbbbbbbbbbbb(b) {}\",\n                 Style);\n    verifyFormat(\"Constructor() : a(a), b(b) {}\", Style);\n\n    Style.AllowAllConstructorInitializersOnNextLine = false;\n    verifyFormat(\"Constructor()\\n\"\n                 \"    : aaaaaaaaaaaaaaaaaaaa(a)\\n\"\n                 \"    , bbbbbbbbbbbbbbbbbbbbb(b) {}\",\n                 Style);\n    verifyFormat(\"Constructor() : a(a), b(b) {}\", Style);\n\n    Style.BreakConstructorInitializers = FormatStyle::BCIS_BeforeColon;\n    Style.AllowAllConstructorInitializersOnNextLine = true;\n    verifyFormat(\"Constructor()\\n\"\n                 \"    : aaaaaaaaaaaaaaaaaaaa(a), bbbbbbbbbbbbbbbbbbbbb(b) {}\",\n                 Style);\n\n    Style.AllowAllConstructorInitializersOnNextLine = false;\n    verifyFormat(\"Constructor()\\n\"\n                 \"    : aaaaaaaaaaaaaaaaaaaa(a),\\n\"\n                 \"      bbbbbbbbbbbbbbbbbbbbb(b) {}\",\n                 Style);\n\n    Style.BreakConstructorInitializers = FormatStyle::BCIS_AfterColon;\n    Style.AllowAllConstructorInitializersOnNextLine = true;\n    verifyFormat(\"Constructor() :\\n\"\n                 \"    aaaaaaaaaaaaaaaaaa(a), bbbbbbbbbbbbbbbbbbbbb(b) {}\",\n                 Style);\n\n    Style.AllowAllConstructorInitializersOnNextLine = false;\n    verifyFormat(\"Constructor() :\\n\"\n                 \"    aaaaaaaaaaaaaaaaaa(a),\\n\"\n                 \"    bbbbbbbbbbbbbbbbbbbbb(b) {}\",\n                 Style);\n  }\n\n  // Test interactions between AllowAllParametersOfDeclarationOnNextLine and\n  // AllowAllConstructorInitializersOnNextLine in all\n  // BreakConstructorInitializers modes\n  Style.BreakConstructorInitializers = FormatStyle::BCIS_BeforeComma;\n  Style.AllowAllParametersOfDeclarationOnNextLine = true;\n  Style.AllowAllConstructorInitializersOnNextLine = false;\n  verifyFormat(\"SomeClassWithALongName::Constructor(\\n\"\n               \"    int aaaaaaaaaaaaaaaaaaaaaaaa, int bbbbbbbbbbbbb)\\n\"\n               \"    : aaaaaaaaaaaaaaaaaaaa(a)\\n\"\n               \"    , bbbbbbbbbbbbbbbbbbbbb(b) {}\",\n               Style);\n\n  Style.AllowAllConstructorInitializersOnNextLine = true;\n  verifyFormat(\"SomeClassWithALongName::Constructor(\\n\"\n               \"    int aaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    int bbbbbbbbbbbbb,\\n\"\n               \"    int cccccccccccccccc)\\n\"\n               \"    : aaaaaaaaaaaaaaaaaaaa(a), bbbbbbbbbbbbbbbbbbbbb(b) {}\",\n               Style);\n\n  Style.AllowAllParametersOfDeclarationOnNextLine = false;\n  Style.AllowAllConstructorInitializersOnNextLine = false;\n  verifyFormat(\"SomeClassWithALongName::Constructor(\\n\"\n               \"    int aaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    int bbbbbbbbbbbbb)\\n\"\n               \"    : aaaaaaaaaaaaaaaaaaaa(a)\\n\"\n               \"    , bbbbbbbbbbbbbbbbbbbbb(b) {}\",\n               Style);\n\n  Style.BreakConstructorInitializers = FormatStyle::BCIS_BeforeColon;\n\n  Style.AllowAllParametersOfDeclarationOnNextLine = true;\n  verifyFormat(\"SomeClassWithALongName::Constructor(\\n\"\n               \"    int aaaaaaaaaaaaaaaaaaaaaaaa, int bbbbbbbbbbbbb)\\n\"\n               \"    : aaaaaaaaaaaaaaaaaaaa(a),\\n\"\n               \"      bbbbbbbbbbbbbbbbbbbbb(b) {}\",\n               Style);\n\n  Style.AllowAllConstructorInitializersOnNextLine = true;\n  verifyFormat(\"SomeClassWithALongName::Constructor(\\n\"\n               \"    int aaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    int bbbbbbbbbbbbb,\\n\"\n               \"    int cccccccccccccccc)\\n\"\n               \"    : aaaaaaaaaaaaaaaaaaaa(a), bbbbbbbbbbbbbbbbbbbbb(b) {}\",\n               Style);\n\n  Style.AllowAllParametersOfDeclarationOnNextLine = false;\n  Style.AllowAllConstructorInitializersOnNextLine = false;\n  verifyFormat(\"SomeClassWithALongName::Constructor(\\n\"\n               \"    int aaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    int bbbbbbbbbbbbb)\\n\"\n               \"    : aaaaaaaaaaaaaaaaaaaa(a),\\n\"\n               \"      bbbbbbbbbbbbbbbbbbbbb(b) {}\",\n               Style);\n\n  Style.BreakConstructorInitializers = FormatStyle::BCIS_AfterColon;\n  Style.AllowAllParametersOfDeclarationOnNextLine = true;\n  verifyFormat(\"SomeClassWithALongName::Constructor(\\n\"\n               \"    int aaaaaaaaaaaaaaaaaaaaaaaa, int bbbbbbbbbbbbb) :\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaa(a),\\n\"\n               \"    bbbbbbbbbbbbbbbbbbbbb(b) {}\",\n               Style);\n\n  Style.AllowAllConstructorInitializersOnNextLine = true;\n  verifyFormat(\"SomeClassWithALongName::Constructor(\\n\"\n               \"    int aaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    int bbbbbbbbbbbbb,\\n\"\n               \"    int cccccccccccccccc) :\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaa(a), bbbbbbbbbbbbbbbbbbbbb(b) {}\",\n               Style);\n\n  Style.AllowAllParametersOfDeclarationOnNextLine = false;\n  Style.AllowAllConstructorInitializersOnNextLine = false;\n  verifyFormat(\"SomeClassWithALongName::Constructor(\\n\"\n               \"    int aaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    int bbbbbbbbbbbbb) :\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaa(a),\\n\"\n               \"    bbbbbbbbbbbbbbbbbbbbb(b) {}\",\n               Style);\n}\n\nTEST_F(FormatTest, AllowAllArgumentsOnNextLine) {\n  FormatStyle Style = getLLVMStyle();\n  Style.ColumnLimit = 60;\n  Style.BinPackArguments = false;\n  for (int i = 0; i < 4; ++i) {\n    // Test all combinations of parameters that should not have an effect.\n    Style.AllowAllParametersOfDeclarationOnNextLine = i & 1;\n    Style.AllowAllConstructorInitializersOnNextLine = i & 2;\n\n    Style.AllowAllArgumentsOnNextLine = true;\n    verifyFormat(\"void foo() {\\n\"\n                 \"  FunctionCallWithReallyLongName(\\n\"\n                 \"      aaaaaaaaaaaaaaaaaaaaaaaaaaa, bbbbbbbbbbbb);\\n\"\n                 \"}\",\n                 Style);\n    Style.AllowAllArgumentsOnNextLine = false;\n    verifyFormat(\"void foo() {\\n\"\n                 \"  FunctionCallWithReallyLongName(\\n\"\n                 \"      aaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n                 \"      bbbbbbbbbbbb);\\n\"\n                 \"}\",\n                 Style);\n\n    Style.AllowAllArgumentsOnNextLine = true;\n    verifyFormat(\"void foo() {\\n\"\n                 \"  auto VariableWithReallyLongName = {\\n\"\n                 \"      aaaaaaaaaaaaaaaaaaaaaaaaaaa, bbbbbbbbbbbb};\\n\"\n                 \"}\",\n                 Style);\n    Style.AllowAllArgumentsOnNextLine = false;\n    verifyFormat(\"void foo() {\\n\"\n                 \"  auto VariableWithReallyLongName = {\\n\"\n                 \"      aaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n                 \"      bbbbbbbbbbbb};\\n\"\n                 \"}\",\n                 Style);\n  }\n\n  // This parameter should not affect declarations.\n  Style.BinPackParameters = false;\n  Style.AllowAllArgumentsOnNextLine = false;\n  Style.AllowAllParametersOfDeclarationOnNextLine = true;\n  verifyFormat(\"void FunctionCallWithReallyLongName(\\n\"\n               \"    int aaaaaaaaaaaaaaaaaaaaaaa, int bbbbbbbbbbbb);\",\n               Style);\n  Style.AllowAllParametersOfDeclarationOnNextLine = false;\n  verifyFormat(\"void FunctionCallWithReallyLongName(\\n\"\n               \"    int aaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    int bbbbbbbbbbbb);\",\n               Style);\n}\n\nTEST_F(FormatTest, AllowAllArgumentsOnNextLineDontAlign) {\n  // Check that AllowAllArgumentsOnNextLine is respected for both BAS_DontAlign\n  // and BAS_Align.\n  auto Style = getLLVMStyle();\n  Style.ColumnLimit = 35;\n  StringRef Input = \"functionCall(paramA, paramB, paramC);\\n\"\n                    \"void functionDecl(int A, int B, int C);\";\n  Style.AllowAllArgumentsOnNextLine = false;\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_DontAlign;\n  EXPECT_EQ(StringRef(\"functionCall(paramA, paramB,\\n\"\n                      \"    paramC);\\n\"\n                      \"void functionDecl(int A, int B,\\n\"\n                      \"    int C);\"),\n            format(Input, Style));\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_Align;\n  EXPECT_EQ(StringRef(\"functionCall(paramA, paramB,\\n\"\n                      \"             paramC);\\n\"\n                      \"void functionDecl(int A, int B,\\n\"\n                      \"                  int C);\"),\n            format(Input, Style));\n  // However, BAS_AlwaysBreak should take precedence over\n  // AllowAllArgumentsOnNextLine.\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_AlwaysBreak;\n  EXPECT_EQ(StringRef(\"functionCall(\\n\"\n                      \"    paramA, paramB, paramC);\\n\"\n                      \"void functionDecl(\\n\"\n                      \"    int A, int B, int C);\"),\n            format(Input, Style));\n\n  // When AllowAllArgumentsOnNextLine is set, we prefer breaking before the\n  // first argument.\n  Style.AllowAllArgumentsOnNextLine = true;\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_AlwaysBreak;\n  EXPECT_EQ(StringRef(\"functionCall(\\n\"\n                      \"    paramA, paramB, paramC);\\n\"\n                      \"void functionDecl(\\n\"\n                      \"    int A, int B, int C);\"),\n            format(Input, Style));\n  // It wouldn't fit on one line with aligned parameters so this setting\n  // doesn't change anything for BAS_Align.\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_Align;\n  EXPECT_EQ(StringRef(\"functionCall(paramA, paramB,\\n\"\n                      \"             paramC);\\n\"\n                      \"void functionDecl(int A, int B,\\n\"\n                      \"                  int C);\"),\n            format(Input, Style));\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_DontAlign;\n  EXPECT_EQ(StringRef(\"functionCall(\\n\"\n                      \"    paramA, paramB, paramC);\\n\"\n                      \"void functionDecl(\\n\"\n                      \"    int A, int B, int C);\"),\n            format(Input, Style));\n}\n\nTEST_F(FormatTest, BreakConstructorInitializersAfterColon) {\n  FormatStyle Style = getLLVMStyle();\n  Style.BreakConstructorInitializers = FormatStyle::BCIS_AfterColon;\n\n  verifyFormat(\"Constructor() : Initializer(FitsOnTheLine) {}\");\n  verifyFormat(\"Constructor() : Initializer(FitsOnTheLine) {}\",\n               getStyleWithColumns(Style, 45));\n  verifyFormat(\"Constructor() :\\n\"\n               \"    Initializer(FitsOnTheLine) {}\",\n               getStyleWithColumns(Style, 44));\n  verifyFormat(\"Constructor() :\\n\"\n               \"    Initializer(FitsOnTheLine) {}\",\n               getStyleWithColumns(Style, 43));\n\n  verifyFormat(\"template <typename T>\\n\"\n               \"Constructor() : Initializer(FitsOnTheLine) {}\",\n               getStyleWithColumns(Style, 50));\n  Style.ConstructorInitializerAllOnOneLineOrOnePerLine = true;\n  verifyFormat(\n      \"SomeClass::Constructor() :\\n\"\n      \"    aaaaaaaaaaaaa(aaaaaaaaaaaaaa), aaaaaaaaaaaaaaa(aaaaaaaaaaaa) {}\",\n      Style);\n\n  Style.ConstructorInitializerAllOnOneLineOrOnePerLine = false;\n  verifyFormat(\n      \"SomeClass::Constructor() :\\n\"\n      \"    aaaaaaaaaaaaa(aaaaaaaaaaaaaa), aaaaaaaaaaaaaaa(aaaaaaaaaaaa) {}\",\n      Style);\n\n  verifyFormat(\n      \"SomeClass::Constructor() :\\n\"\n      \"    aaaaaaaaaaaaa(aaaaaaaaaaaaaa), aaaaaaaaaaaaa(aaaaaaaaaaaaaa),\\n\"\n      \"    aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}\",\n      Style);\n  verifyFormat(\n      \"SomeClass::Constructor() :\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa),\\n\"\n      \"    aaaaaaaaaaaaaaa(aaaaaaaaaaaa) {}\",\n      Style);\n  verifyFormat(\"Constructor(aaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"            aaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) :\\n\"\n               \"    aaaaaaaaaa(aaaaaa) {}\",\n               Style);\n\n  verifyFormat(\"Constructor() :\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaa),\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                             aaaaaaaaaaaaaaaaaaaaaaaaaaa),\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaa() {}\",\n               Style);\n\n  verifyFormat(\"Constructor() :\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\",\n               Style);\n\n  verifyFormat(\"Constructor(int Parameter = 0) :\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaa),\\n\"\n               \"    aaaaaaaaaaaa(aaaaaaaaaaaaaaaaa) {}\",\n               Style);\n  verifyFormat(\"Constructor() :\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaa(a), bbbbbbbbbbbbbbbbbbbbbbbb(b) {\\n\"\n               \"}\",\n               getStyleWithColumns(Style, 60));\n  verifyFormat(\"Constructor() :\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaa(aaaa, aaaa)) {}\",\n               Style);\n\n  // Here a line could be saved by splitting the second initializer onto two\n  // lines, but that is not desirable.\n  verifyFormat(\"Constructor() :\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaa),\\n\"\n               \"    aaaaaaaaaaa(aaaaaaaaaaa),\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaat(aaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\",\n               Style);\n\n  FormatStyle OnePerLine = Style;\n  OnePerLine.ConstructorInitializerAllOnOneLineOrOnePerLine = true;\n  OnePerLine.AllowAllConstructorInitializersOnNextLine = false;\n  verifyFormat(\"SomeClass::Constructor() :\\n\"\n               \"    aaaaaaaaaaaaa(aaaaaaaaaaaaaa),\\n\"\n               \"    aaaaaaaaaaaaa(aaaaaaaaaaaaaa),\\n\"\n               \"    aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}\",\n               OnePerLine);\n  verifyFormat(\"SomeClass::Constructor() :\\n\"\n               \"    aaaaaaaaaaaaa(aaaaaaaaaaaaaa), // Some comment\\n\"\n               \"    aaaaaaaaaaaaa(aaaaaaaaaaaaaa),\\n\"\n               \"    aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}\",\n               OnePerLine);\n  verifyFormat(\"MyClass::MyClass(int var) :\\n\"\n               \"    some_var_(var),            // 4 space indent\\n\"\n               \"    some_other_var_(var + 1) { // lined up\\n\"\n               \"}\",\n               OnePerLine);\n  verifyFormat(\"Constructor() :\\n\"\n               \"    aaaaa(aaaaaa),\\n\"\n               \"    aaaaa(aaaaaa),\\n\"\n               \"    aaaaa(aaaaaa),\\n\"\n               \"    aaaaa(aaaaaa),\\n\"\n               \"    aaaaa(aaaaaa) {}\",\n               OnePerLine);\n  verifyFormat(\"Constructor() :\\n\"\n               \"    aaaaa(aaaaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"          aaaaaaaaaaaaaaaaaaaaaa) {}\",\n               OnePerLine);\n  OnePerLine.BinPackParameters = false;\n  verifyFormat(\"Constructor() :\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"        aaaaaaaaaaa().aaa(),\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\",\n               OnePerLine);\n  OnePerLine.ColumnLimit = 60;\n  verifyFormat(\"Constructor() :\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaa(a),\\n\"\n               \"    bbbbbbbbbbbbbbbbbbbbbbbb(b) {}\",\n               OnePerLine);\n\n  EXPECT_EQ(\"Constructor() :\\n\"\n            \"    // Comment forcing unwanted break.\\n\"\n            \"    aaaa(aaaa) {}\",\n            format(\"Constructor() :\\n\"\n                   \"    // Comment forcing unwanted break.\\n\"\n                   \"    aaaa(aaaa) {}\",\n                   Style));\n\n  Style.ColumnLimit = 0;\n  verifyFormat(\"SomeClass::Constructor() :\\n\"\n               \"    a(a) {}\",\n               Style);\n  verifyFormat(\"SomeClass::Constructor() noexcept :\\n\"\n               \"    a(a) {}\",\n               Style);\n  verifyFormat(\"SomeClass::Constructor() :\\n\"\n               \"    a(a), b(b), c(c) {}\",\n               Style);\n  verifyFormat(\"SomeClass::Constructor() :\\n\"\n               \"    a(a) {\\n\"\n               \"  foo();\\n\"\n               \"  bar();\\n\"\n               \"}\",\n               Style);\n\n  Style.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_None;\n  verifyFormat(\"SomeClass::Constructor() :\\n\"\n               \"    a(a), b(b), c(c) {\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"SomeClass::Constructor() :\\n\"\n               \"    a(a) {\\n\"\n               \"}\",\n               Style);\n\n  Style.ColumnLimit = 80;\n  Style.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_All;\n  Style.ConstructorInitializerIndentWidth = 2;\n  verifyFormat(\"SomeClass::Constructor() : a(a), b(b), c(c) {}\", Style);\n  verifyFormat(\"SomeClass::Constructor() :\\n\"\n               \"  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"  bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb {}\",\n               Style);\n\n  // `ConstructorInitializerIndentWidth` actually applies to InheritanceList as\n  // well\n  Style.BreakInheritanceList = FormatStyle::BILS_BeforeColon;\n  verifyFormat(\n      \"class SomeClass\\n\"\n      \"  : public aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"    public bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb {};\",\n      Style);\n  Style.BreakInheritanceList = FormatStyle::BILS_BeforeComma;\n  verifyFormat(\n      \"class SomeClass\\n\"\n      \"  : public aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"  , public bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb {};\",\n      Style);\n  Style.BreakInheritanceList = FormatStyle::BILS_AfterColon;\n  verifyFormat(\n      \"class SomeClass :\\n\"\n      \"  public aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"  public bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb {};\",\n      Style);\n}\n\n#ifndef EXPENSIVE_CHECKS\n// Expensive checks enables libstdc++ checking which includes validating the\n// state of ranges used in std::priority_queue - this blows out the\n// runtime/scalability of the function and makes this test unacceptably slow.\nTEST_F(FormatTest, MemoizationTests) {\n  // This breaks if the memoization lookup does not take \\c Indent and\n  // \\c LastSpace into account.\n  verifyFormat(\n      \"extern CFRunLoopTimerRef\\n\"\n      \"CFRunLoopTimerCreate(CFAllocatorRef allocato, CFAbsoluteTime fireDate,\\n\"\n      \"                     CFTimeInterval interval, CFOptionFlags flags,\\n\"\n      \"                     CFIndex order, CFRunLoopTimerCallBack callout,\\n\"\n      \"                     CFRunLoopTimerContext *context) {}\");\n\n  // Deep nesting somewhat works around our memoization.\n  verifyFormat(\n      \"aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(\\n\"\n      \"    aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(\\n\"\n      \"        aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(\\n\"\n      \"            aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(aaaaa(\\n\"\n      \"                aaaaa())))))))))))))))))))))))))))))))))))))));\",\n      getLLVMStyleWithColumns(65));\n  verifyFormat(\n      \"aaaaa(\\n\"\n      \"    aaaaa,\\n\"\n      \"    aaaaa(\\n\"\n      \"        aaaaa,\\n\"\n      \"        aaaaa(\\n\"\n      \"            aaaaa,\\n\"\n      \"            aaaaa(\\n\"\n      \"                aaaaa,\\n\"\n      \"                aaaaa(\\n\"\n      \"                    aaaaa,\\n\"\n      \"                    aaaaa(\\n\"\n      \"                        aaaaa,\\n\"\n      \"                        aaaaa(\\n\"\n      \"                            aaaaa,\\n\"\n      \"                            aaaaa(\\n\"\n      \"                                aaaaa,\\n\"\n      \"                                aaaaa(\\n\"\n      \"                                    aaaaa,\\n\"\n      \"                                    aaaaa(\\n\"\n      \"                                        aaaaa,\\n\"\n      \"                                        aaaaa(\\n\"\n      \"                                            aaaaa,\\n\"\n      \"                                            aaaaa(\\n\"\n      \"                                                aaaaa,\\n\"\n      \"                                                aaaaa))))))))))));\",\n      getLLVMStyleWithColumns(65));\n  verifyFormat(\n      \"a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(a(), a), a), a), a),\\n\"\n      \"                                  a),\\n\"\n      \"                                a),\\n\"\n      \"                              a),\\n\"\n      \"                            a),\\n\"\n      \"                          a),\\n\"\n      \"                        a),\\n\"\n      \"                      a),\\n\"\n      \"                    a),\\n\"\n      \"                  a),\\n\"\n      \"                a),\\n\"\n      \"              a),\\n\"\n      \"            a),\\n\"\n      \"          a),\\n\"\n      \"        a),\\n\"\n      \"      a),\\n\"\n      \"    a),\\n\"\n      \"  a)\",\n      getLLVMStyleWithColumns(65));\n\n  // This test takes VERY long when memoization is broken.\n  FormatStyle OnePerLine = getLLVMStyle();\n  OnePerLine.ConstructorInitializerAllOnOneLineOrOnePerLine = true;\n  OnePerLine.BinPackParameters = false;\n  std::string input = \"Constructor()\\n\"\n                      \"    : aaaa(a,\\n\";\n  for (unsigned i = 0, e = 80; i != e; ++i) {\n    input += \"           a,\\n\";\n  }\n  input += \"           a) {}\";\n  verifyFormat(input, OnePerLine);\n}\n#endif\n\nTEST_F(FormatTest, BreaksAsHighAsPossible) {\n  verifyFormat(\n      \"void f() {\\n\"\n      \"  if ((aaaaaaaaaaaaaaaaaaaaaaaaaaaaa && aaaaaaaaaaaaaaaaaaaaaaaaaa) ||\\n\"\n      \"      (bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb && bbbbbbbbbbbbbbbbbbbbbbbbbb))\\n\"\n      \"    f();\\n\"\n      \"}\");\n  verifyFormat(\"if (Intervals[i].getRange().getFirst() <\\n\"\n               \"    Intervals[i - 1].getRange().getLast()) {\\n}\");\n}\n\nTEST_F(FormatTest, BreaksFunctionDeclarations) {\n  // Principially, we break function declarations in a certain order:\n  // 1) break amongst arguments.\n  verifyFormat(\"Aaaaaaaaaaaaaa bbbbbbbbbbbbbb(Cccccccccccccc cccccccccccccc,\\n\"\n               \"                              Cccccccccccccc cccccccccccccc);\");\n  verifyFormat(\"template <class TemplateIt>\\n\"\n               \"SomeReturnType SomeFunction(TemplateIt begin, TemplateIt end,\\n\"\n               \"                            TemplateIt *stop) {}\");\n\n  // 2) break after return type.\n  verifyFormat(\n      \"Aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"bbbbbbbbbbbbbb(Cccccccccccccc cccccccccccccccccccccccccc);\",\n      getGoogleStyle());\n\n  // 3) break after (.\n  verifyFormat(\n      \"Aaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbb(\\n\"\n      \"    Cccccccccccccccccccccccccccccc cccccccccccccccccccccccccccccccc);\",\n      getGoogleStyle());\n\n  // 4) break before after nested name specifiers.\n  verifyFormat(\n      \"Aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"SomeClasssssssssssssssssssssssssssssssssssssss::\\n\"\n      \"    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb(Cccccccccccccc cccccccccc);\",\n      getGoogleStyle());\n\n  // However, there are exceptions, if a sufficient amount of lines can be\n  // saved.\n  // FIXME: The precise cut-offs wrt. the number of saved lines might need some\n  // more adjusting.\n  verifyFormat(\"Aaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbb(Cccccccccccccc cccccccccc,\\n\"\n               \"                                  Cccccccccccccc cccccccccc,\\n\"\n               \"                                  Cccccccccccccc cccccccccc,\\n\"\n               \"                                  Cccccccccccccc cccccccccc,\\n\"\n               \"                                  Cccccccccccccc cccccccccc);\");\n  verifyFormat(\n      \"Aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"bbbbbbbbbbb(Cccccccccccccc cccccccccc, Cccccccccccccc cccccccccc,\\n\"\n      \"            Cccccccccccccc cccccccccc, Cccccccccccccc cccccccccc,\\n\"\n      \"            Cccccccccccccc cccccccccc, Cccccccccccccc cccccccccc);\",\n      getGoogleStyle());\n  verifyFormat(\n      \"Aaaaaaaaaa bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb(Cccccccccccccc cccccccccc,\\n\"\n      \"                                          Cccccccccccccc cccccccccc,\\n\"\n      \"                                          Cccccccccccccc cccccccccc,\\n\"\n      \"                                          Cccccccccccccc cccccccccc,\\n\"\n      \"                                          Cccccccccccccc cccccccccc,\\n\"\n      \"                                          Cccccccccccccc cccccccccc,\\n\"\n      \"                                          Cccccccccccccc cccccccccc);\");\n  verifyFormat(\"Aaaaaaaaaa bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb(\\n\"\n               \"    Cccccccccccccc cccccccccc, Cccccccccccccc cccccccccc,\\n\"\n               \"    Cccccccccccccc cccccccccc, Cccccccccccccc cccccccccc,\\n\"\n               \"    Cccccccccccccc cccccccccc, Cccccccccccccc cccccccccc,\\n\"\n               \"    Cccccccccccccc cccccccccc, Cccccccccccccc cccccccccc);\");\n\n  // Break after multi-line parameters.\n  verifyFormat(\"void aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    bbbb bbbb);\");\n  verifyFormat(\"void SomeLoooooooooooongFunction(\\n\"\n               \"    std::unique_ptr<aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa>\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    int bbbbbbbbbbbbb);\");\n\n  // Treat overloaded operators like other functions.\n  verifyFormat(\"SomeLoooooooooooooooooooooooooogType\\n\"\n               \"operator>(const SomeLoooooooooooooooooooooooooogType &other);\");\n  verifyFormat(\"SomeLoooooooooooooooooooooooooogType\\n\"\n               \"operator>>(const SomeLooooooooooooooooooooooooogType &other);\");\n  verifyFormat(\"SomeLoooooooooooooooooooooooooogType\\n\"\n               \"operator<<(const SomeLooooooooooooooooooooooooogType &other);\");\n  verifyGoogleFormat(\n      \"SomeLoooooooooooooooooooooooooooooogType operator>>(\\n\"\n      \"    const SomeLooooooooogType &a, const SomeLooooooooogType &b);\");\n  verifyGoogleFormat(\n      \"SomeLoooooooooooooooooooooooooooooogType operator<<(\\n\"\n      \"    const SomeLooooooooogType &a, const SomeLooooooooogType &b);\");\n  verifyFormat(\"void aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"    int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa = 1);\");\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"aaaaaaaaaaaaaaaaaaaaaaaaa(int aaaaaaaaaaaaaaaaaaaaaaaa = 1);\");\n  verifyGoogleFormat(\n      \"typename aaaaaaaaaa<aaaaaa>::aaaaaaaaaaa\\n\"\n      \"aaaaaaaaaa<aaaaaa>::aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"    bool *aaaaaaaaaaaaaaaaaa, bool *aa) {}\");\n  verifyGoogleFormat(\"template <typename T>\\n\"\n                     \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n                     \"aaaaaaaaaaaaaaaaaaaaaaa<T>::aaaaaaaaaaaaa(\\n\"\n                     \"    aaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaa);\");\n\n  FormatStyle Style = getLLVMStyle();\n  Style.PointerAlignment = FormatStyle::PAS_Left;\n  verifyFormat(\"void aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaa* const aaaaaaaaaaaa) {}\",\n               Style);\n  verifyFormat(\"void aaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa*\\n\"\n               \"                 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\",\n               Style);\n}\n\nTEST_F(FormatTest, DontBreakBeforeQualifiedOperator) {\n  // Regression test for https://bugs.llvm.org/show_bug.cgi?id=40516:\n  // Prefer keeping `::` followed by `operator` together.\n  EXPECT_EQ(\"const aaaa::bbbbbbb &\\n\"\n            \"ccccccccc::operator++() {\\n\"\n            \"  stuff();\\n\"\n            \"}\",\n            format(\"const aaaa::bbbbbbb\\n\"\n                   \"&ccccccccc::operator++() { stuff(); }\",\n                   getLLVMStyleWithColumns(40)));\n}\n\nTEST_F(FormatTest, TrailingReturnType) {\n  verifyFormat(\"auto foo() -> int;\\n\");\n  // correct trailing return type spacing\n  verifyFormat(\"auto operator->() -> int;\\n\");\n  verifyFormat(\"auto operator++(int) -> int;\\n\");\n\n  verifyFormat(\"struct S {\\n\"\n               \"  auto bar() const -> int;\\n\"\n               \"};\");\n  verifyFormat(\"template <size_t Order, typename T>\\n\"\n               \"auto load_img(const std::string &filename)\\n\"\n               \"    -> alias::tensor<Order, T, mem::tag::cpu> {}\");\n  verifyFormat(\"auto SomeFunction(A aaaaaaaaaaaaaaaaaaaaa) const\\n\"\n               \"    -> decltype(f(aaaaaaaaaaaaaaaaaaaaa)) {}\");\n  verifyFormat(\"auto doSomething(Aaaaaa *aaaaaa) -> decltype(aaaaaa->f()) {}\");\n  verifyFormat(\"template <typename T>\\n\"\n               \"auto aaaaaaaaaaaaaaaaaaaaaa(T t)\\n\"\n               \"    -> decltype(eaaaaaaaaaaaaaaa<T>(t.a).aaaaaaaa());\");\n\n  // Not trailing return types.\n  verifyFormat(\"void f() { auto a = b->c(); }\");\n}\n\nTEST_F(FormatTest, DeductionGuides) {\n  verifyFormat(\"template <class T> A(const T &, const T &) -> A<T &>;\");\n  verifyFormat(\"template <class T> explicit A(T &, T &&) -> A<T>;\");\n  verifyFormat(\"template <class... Ts> S(Ts...) -> S<Ts...>;\");\n  verifyFormat(\n      \"template <class... T>\\n\"\n      \"array(T &&...t) -> array<std::common_type_t<T...>, sizeof...(T)>;\");\n  verifyFormat(\"template <class T> A() -> A<decltype(p->foo<3>())>;\");\n  verifyFormat(\"template <class T> A() -> A<decltype(foo<traits<1>>)>;\");\n  verifyFormat(\"template <class T> A() -> A<sizeof(p->foo<1>)>;\");\n  verifyFormat(\"template <class T> A() -> A<(3 < 2)>;\");\n  verifyFormat(\"template <class T> A() -> A<((3) < (2))>;\");\n  verifyFormat(\"template <class T> x() -> x<1>;\");\n  verifyFormat(\"template <class T> explicit x(T &) -> x<1>;\");\n\n  // Ensure not deduction guides.\n  verifyFormat(\"c()->f<int>();\");\n  verifyFormat(\"x()->foo<1>;\");\n  verifyFormat(\"x = p->foo<3>();\");\n  verifyFormat(\"x()->x<1>();\");\n  verifyFormat(\"x()->x<1>;\");\n}\n\nTEST_F(FormatTest, BreaksFunctionDeclarationsWithTrailingTokens) {\n  // Avoid breaking before trailing 'const' or other trailing annotations, if\n  // they are not function-like.\n  FormatStyle Style = getGoogleStyle();\n  Style.ColumnLimit = 47;\n  verifyFormat(\"void someLongFunction(\\n\"\n               \"    int someLoooooooooooooongParameter) const {\\n}\",\n               getLLVMStyleWithColumns(47));\n  verifyFormat(\"LoooooongReturnType\\n\"\n               \"someLoooooooongFunction() const {}\",\n               getLLVMStyleWithColumns(47));\n  verifyFormat(\"LoooooongReturnType someLoooooooongFunction()\\n\"\n               \"    const {}\",\n               Style);\n  verifyFormat(\"void SomeFunction(aaaaa aaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                  aaaaa aaaaaaaaaaaaaaaaaaaa) OVERRIDE;\");\n  verifyFormat(\"void SomeFunction(aaaaa aaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                  aaaaa aaaaaaaaaaaaaaaaaaaa) OVERRIDE FINAL;\");\n  verifyFormat(\"void SomeFunction(aaaaa aaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                  aaaaa aaaaaaaaaaaaaaaaaaaa) override final;\");\n  verifyFormat(\"virtual void aaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaa aaaa,\\n\"\n               \"                   aaaaaaaaaaa aaaaa) const override;\");\n  verifyGoogleFormat(\n      \"virtual void aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()\\n\"\n      \"    const override;\");\n\n  // Even if the first parameter has to be wrapped.\n  verifyFormat(\"void someLongFunction(\\n\"\n               \"    int someLongParameter) const {}\",\n               getLLVMStyleWithColumns(46));\n  verifyFormat(\"void someLongFunction(\\n\"\n               \"    int someLongParameter) const {}\",\n               Style);\n  verifyFormat(\"void someLongFunction(\\n\"\n               \"    int someLongParameter) override {}\",\n               Style);\n  verifyFormat(\"void someLongFunction(\\n\"\n               \"    int someLongParameter) OVERRIDE {}\",\n               Style);\n  verifyFormat(\"void someLongFunction(\\n\"\n               \"    int someLongParameter) final {}\",\n               Style);\n  verifyFormat(\"void someLongFunction(\\n\"\n               \"    int someLongParameter) FINAL {}\",\n               Style);\n  verifyFormat(\"void someLongFunction(\\n\"\n               \"    int parameter) const override {}\",\n               Style);\n\n  Style.BreakBeforeBraces = FormatStyle::BS_Allman;\n  verifyFormat(\"void someLongFunction(\\n\"\n               \"    int someLongParameter) const\\n\"\n               \"{\\n\"\n               \"}\",\n               Style);\n\n  Style.BreakBeforeBraces = FormatStyle::BS_Whitesmiths;\n  verifyFormat(\"void someLongFunction(\\n\"\n               \"    int someLongParameter) const\\n\"\n               \"  {\\n\"\n               \"  }\",\n               Style);\n\n  // Unless these are unknown annotations.\n  verifyFormat(\"void SomeFunction(aaaaaaaaaa aaaaaaaaaaaaaaa,\\n\"\n               \"                  aaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"    LONG_AND_UGLY_ANNOTATION;\");\n\n  // Breaking before function-like trailing annotations is fine to keep them\n  // close to their arguments.\n  verifyFormat(\"void aaaaaaaaaaaa(int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"    LOCKS_EXCLUDED(aaaaaaaaaaaaa);\");\n  verifyFormat(\"void aaaaaaaaaaaa(int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) const\\n\"\n               \"    LOCKS_EXCLUDED(aaaaaaaaaaaaa);\");\n  verifyFormat(\"void aaaaaaaaaaaa(int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) const\\n\"\n               \"    LOCKS_EXCLUDED(aaaaaaaaaaaaa) {}\");\n  verifyGoogleFormat(\"void aaaaaaaaaaaaaa(aaaaaaaa aaa) override\\n\"\n                     \"    AAAAAAAAAAAAAAAAAAAAAAAA(aaaaaaaaaaaaaaa);\");\n  verifyFormat(\"SomeFunction([](int i) LOCKS_EXCLUDED(a) {});\");\n\n  verifyFormat(\n      \"void aaaaaaaaaaaaaaaaaa()\\n\"\n      \"    __attribute__((aaaaaaaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"                   aaaaaaaaaaaaaaaaaaaaaaaaa));\");\n  verifyFormat(\"bool aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    __attribute__((unused));\");\n  verifyGoogleFormat(\n      \"bool aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"    GUARDED_BY(aaaaaaaaaaaa);\");\n  verifyGoogleFormat(\n      \"bool aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"    GUARDED_BY(aaaaaaaaaaaa);\");\n  verifyGoogleFormat(\n      \"bool aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa GUARDED_BY(aaaaaaaaaaaa) =\\n\"\n      \"    aaaaaaaa::aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\");\n  verifyGoogleFormat(\n      \"bool aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa GUARDED_BY(aaaaaaaaaaaa) =\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaa;\");\n}\n\nTEST_F(FormatTest, FunctionAnnotations) {\n  verifyFormat(\"DEPRECATED(\\\"Use NewClass::NewFunction instead.\\\")\\n\"\n               \"int OldFunction(const string &parameter) {}\");\n  verifyFormat(\"DEPRECATED(\\\"Use NewClass::NewFunction instead.\\\")\\n\"\n               \"string OldFunction(const string &parameter) {}\");\n  verifyFormat(\"template <typename T>\\n\"\n               \"DEPRECATED(\\\"Use NewClass::NewFunction instead.\\\")\\n\"\n               \"string OldFunction(const string &parameter) {}\");\n\n  // Not function annotations.\n  verifyFormat(\"ASSERT(\\\"aaaaa\\\") << aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"                << bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\");\n  verifyFormat(\"TEST_F(ThisIsATestFixtureeeeeeeeeeeee,\\n\"\n               \"       ThisIsATestWithAReallyReallyReallyReallyLongName) {}\");\n  verifyFormat(\"MACRO(abc).function() // wrap\\n\"\n               \"    << abc;\");\n  verifyFormat(\"MACRO(abc)->function() // wrap\\n\"\n               \"    << abc;\");\n  verifyFormat(\"MACRO(abc)::function() // wrap\\n\"\n               \"    << abc;\");\n}\n\nTEST_F(FormatTest, BreaksDesireably) {\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaa) ||\\n\"\n               \"    aaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaa) ||\\n\"\n               \"    aaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaa)) {\\n}\");\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)) {\\n\"\n               \"}\");\n\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"                      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\");\n\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa));\");\n\n  verifyFormat(\n      \"aaaaaaaa(aaaaaaaaaaaaa,\\n\"\n      \"         aaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)),\\n\"\n      \"         aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)));\");\n\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ||\\n\"\n               \"    (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n\n  verifyFormat(\n      \"void f() {\\n\"\n      \"  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&\\n\"\n      \"                                 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\\n\"\n      \"}\");\n  verifyFormat(\n      \"aaaaaa(new Aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaa));\");\n  verifyFormat(\n      \"aaaaaa(aaa, new Aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"                aaaaaaaaaaaaaaaaaaaaaaaaaaaaa));\");\n  verifyFormat(\n      \"aaaaaa(aaa,\\n\"\n      \"       new Aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"           aaaaaaaaaaaaaaaaaaaaaaaaaaaaa),\\n\"\n      \"       aaaa);\");\n  verifyFormat(\"aaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n               \"                      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n\n  // Indent consistently independent of call expression and unary operator.\n  verifyFormat(\"aaaaaaaaaaa(bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb(\\n\"\n               \"    dddddddddddddddddddddddddddddd));\");\n  verifyFormat(\"aaaaaaaaaaa(!bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb(\\n\"\n               \"    dddddddddddddddddddddddddddddd));\");\n  verifyFormat(\"aaaaaaaaaaa(bbbbbbbbbbbbbbbbbbbbbbbbb.ccccccccccccccccc(\\n\"\n               \"    dddddddddddddddddddddddddddddd));\");\n\n  // This test case breaks on an incorrect memoization, i.e. an optimization not\n  // taking into account the StopAt value.\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaaaaaaaaaa || aaaaaaaaaaaaaaaaaaaaaaa ||\\n\"\n      \"       aaaaaaaaaaa(aaaaaaaaa) || aaaaaaaaaaaaaaaaaaaaaaa ||\\n\"\n      \"       aaaaaaaaaaaaaaaaaaaaaaaaa || aaaaaaaaaaaaaaaaaaaaaaa ||\\n\"\n      \"       (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n\n  verifyFormat(\"{\\n  {\\n    {\\n\"\n               \"      Annotation.SpaceRequiredBefore =\\n\"\n               \"          Line.Tokens[i - 1].Tok.isNot(tok::l_paren) &&\\n\"\n               \"          Line.Tokens[i - 1].Tok.isNot(tok::l_square);\\n\"\n               \"    }\\n  }\\n}\");\n\n  // Break on an outer level if there was a break on an inner level.\n  EXPECT_EQ(\"f(g(h(a, // comment\\n\"\n            \"      b, c),\\n\"\n            \"    d, e),\\n\"\n            \"  x, y);\",\n            format(\"f(g(h(a, // comment\\n\"\n                   \"    b, c), d, e), x, y);\"));\n\n  // Prefer breaking similar line breaks.\n  verifyFormat(\n      \"const int kTrackingOptions = NSTrackingMouseMoved |\\n\"\n      \"                             NSTrackingMouseEnteredAndExited |\\n\"\n      \"                             NSTrackingActiveAlways;\");\n}\n\nTEST_F(FormatTest, FormatsDeclarationsOnePerLine) {\n  FormatStyle NoBinPacking = getGoogleStyle();\n  NoBinPacking.BinPackParameters = false;\n  NoBinPacking.BinPackArguments = true;\n  verifyFormat(\"void f() {\\n\"\n               \"  f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\\n\"\n               \"}\",\n               NoBinPacking);\n  verifyFormat(\"void f(int aaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"       int aaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"       int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\",\n               NoBinPacking);\n\n  NoBinPacking.AllowAllParametersOfDeclarationOnNextLine = false;\n  verifyFormat(\"void aaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                        vector<int> bbbbbbbbbbbbbbb);\",\n               NoBinPacking);\n  // FIXME: This behavior difference is probably not wanted. However, currently\n  // we cannot distinguish BreakBeforeParameter being set because of the wrapped\n  // template arguments from BreakBeforeParameter being set because of the\n  // one-per-line formatting.\n  verifyFormat(\n      \"void fffffffffff(aaaaaaaaaaaaaaaaaaaaaaaaaaa<aaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"                                             aaaaaaaaaa> aaaaaaaaaa);\",\n      NoBinPacking);\n  verifyFormat(\n      \"void fffffffffff(\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaa<aaaaaaaaaaaaaaaaaaaaaaa, aaaaaaaaaa>\\n\"\n      \"        aaaaaaaaaa);\");\n}\n\nTEST_F(FormatTest, FormatsOneParameterPerLineIfNecessary) {\n  FormatStyle NoBinPacking = getGoogleStyle();\n  NoBinPacking.BinPackParameters = false;\n  NoBinPacking.BinPackArguments = false;\n  verifyFormat(\"f(aaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"  aaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"  aaaaaaaaaaaaaaaaaaaa + aaaaaaaaaaaaaaaaaaaa);\",\n               NoBinPacking);\n  verifyFormat(\"aaaaaaa(aaaaaaaaaaaaa,\\n\"\n               \"        aaaaaaaaaaaaa,\\n\"\n               \"        aaaaaaaaaaaaa(aaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaa));\",\n               NoBinPacking);\n  verifyFormat(\n      \"aaaaaaaa(aaaaaaaaaaaaa,\\n\"\n      \"         aaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)),\\n\"\n      \"         aaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)));\",\n      NoBinPacking);\n  verifyFormat(\"aaaaaaaaaaaaaaa(aaaaaaaaa, aaaaaaaaa, aaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"    .aaaaaaaaaaaaaaaaaa();\",\n               NoBinPacking);\n  verifyFormat(\"void f() {\\n\"\n               \"  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"      aaaaaaaaaa, aaaaaaaaaa, aaaaaaaaaa, aaaaaaaaaaa);\\n\"\n               \"}\",\n               NoBinPacking);\n\n  verifyFormat(\n      \"aaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaa + aaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"             aaaaaaaaaaaa,\\n\"\n      \"             aaaaaaaaaaaa);\",\n      NoBinPacking);\n  verifyFormat(\n      \"somefunction(someotherFunction(ddddddddddddddddddddddddddddddddddd,\\n\"\n      \"                               ddddddddddddddddddddddddddddd),\\n\"\n      \"             test);\",\n      NoBinPacking);\n\n  verifyFormat(\"std::vector<aaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"            aaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"            aaaaaaaaaaaaaaaaaaaaaaa>\\n\"\n               \"    aaaaaaaaaaaaaaaaaa;\",\n               NoBinPacking);\n  verifyFormat(\"a(\\\"a\\\"\\n\"\n               \"  \\\"a\\\",\\n\"\n               \"  a);\");\n\n  NoBinPacking.AllowAllParametersOfDeclarationOnNextLine = false;\n  verifyFormat(\"void aaaaaaaaaa(aaaaaaaaa,\\n\"\n               \"                aaaaaaaaa,\\n\"\n               \"                aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\",\n               NoBinPacking);\n  verifyFormat(\n      \"void f() {\\n\"\n      \"  aaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaa, aaaaaaaaa, aaaaaaaaaaaaaaaaaaaaa)\\n\"\n      \"      .aaaaaaa();\\n\"\n      \"}\",\n      NoBinPacking);\n  verifyFormat(\n      \"template <class SomeType, class SomeOtherType>\\n\"\n      \"SomeType SomeFunction(SomeType Type, SomeOtherType OtherType) {}\",\n      NoBinPacking);\n}\n\nTEST_F(FormatTest, AdaptiveOnePerLineFormatting) {\n  FormatStyle Style = getLLVMStyleWithColumns(15);\n  Style.ExperimentalAutoDetectBinPacking = true;\n  EXPECT_EQ(\"aaa(aaaa,\\n\"\n            \"    aaaa,\\n\"\n            \"    aaaa);\\n\"\n            \"aaa(aaaa,\\n\"\n            \"    aaaa,\\n\"\n            \"    aaaa);\",\n            format(\"aaa(aaaa,\\n\" // one-per-line\n                   \"  aaaa,\\n\"\n                   \"    aaaa  );\\n\"\n                   \"aaa(aaaa,  aaaa,  aaaa);\", // inconclusive\n                   Style));\n  EXPECT_EQ(\"aaa(aaaa, aaaa,\\n\"\n            \"    aaaa);\\n\"\n            \"aaa(aaaa, aaaa,\\n\"\n            \"    aaaa);\",\n            format(\"aaa(aaaa,  aaaa,\\n\" // bin-packed\n                   \"    aaaa  );\\n\"\n                   \"aaa(aaaa,  aaaa,  aaaa);\", // inconclusive\n                   Style));\n}\n\nTEST_F(FormatTest, FormatsBuilderPattern) {\n  verifyFormat(\"return llvm::StringSwitch<Reference::Kind>(name)\\n\"\n               \"    .StartsWith(\\\".eh_frame_hdr\\\", ORDER_EH_FRAMEHDR)\\n\"\n               \"    .StartsWith(\\\".eh_frame\\\", ORDER_EH_FRAME)\\n\"\n               \"    .StartsWith(\\\".init\\\", ORDER_INIT)\\n\"\n               \"    .StartsWith(\\\".fini\\\", ORDER_FINI)\\n\"\n               \"    .StartsWith(\\\".hash\\\", ORDER_HASH)\\n\"\n               \"    .Default(ORDER_TEXT);\\n\");\n\n  verifyFormat(\"return aaaaaaaaaaaaaaaaa->aaaaa().aaaaaaaaaaaaa().aaaaaa() <\\n\"\n               \"       aaaaaaaaaaaaaaa->aaaaa().aaaaaaaaaaaaa().aaaaaa();\");\n  verifyFormat(\"aaaaaaa->aaaaaaa\\n\"\n               \"    ->aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"    ->aaaaaaaa(aaaaaaaaaaaaaaa);\");\n  verifyFormat(\n      \"aaaaaaa->aaaaaaa\\n\"\n      \"    ->aaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n      \"    ->aaaaaaaa(aaaaaaaaaaaaaaa);\");\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaa()->aaaaaa(bbbbb)->aaaaaaaaaaaaaaaaaaa( // break\\n\"\n      \"    aaaaaaaaaaaaaa);\");\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaa *aaaaaaaaa =\\n\"\n      \"    aaaaaa->aaaaaaaaaaaa()\\n\"\n      \"        ->aaaaaaaaaaaaaaaa(\\n\"\n      \"            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n      \"        ->aaaaaaaaaaaaaaaaa();\");\n  verifyGoogleFormat(\n      \"void f() {\\n\"\n      \"  someo->Add((new util::filetools::Handler(dir))\\n\"\n      \"                 ->OnEvent1(NewPermanentCallback(\\n\"\n      \"                     this, &HandlerHolderClass::EventHandlerCBA))\\n\"\n      \"                 ->OnEvent2(NewPermanentCallback(\\n\"\n      \"                     this, &HandlerHolderClass::EventHandlerCBB))\\n\"\n      \"                 ->OnEvent3(NewPermanentCallback(\\n\"\n      \"                     this, &HandlerHolderClass::EventHandlerCBC))\\n\"\n      \"                 ->OnEvent5(NewPermanentCallback(\\n\"\n      \"                     this, &HandlerHolderClass::EventHandlerCBD))\\n\"\n      \"                 ->OnEvent6(NewPermanentCallback(\\n\"\n      \"                     this, &HandlerHolderClass::EventHandlerCBE)));\\n\"\n      \"}\");\n\n  verifyFormat(\n      \"aaaaaaaaaaa().aaaaaaaaaaa().aaaaaaaaaaa().aaaaaaaaaaa().aaaaaaaaaaa();\");\n  verifyFormat(\"aaaaaaaaaaaaaaa()\\n\"\n               \"    .aaaaaaaaaaaaaaa()\\n\"\n               \"    .aaaaaaaaaaaaaaa()\\n\"\n               \"    .aaaaaaaaaaaaaaa()\\n\"\n               \"    .aaaaaaaaaaaaaaa();\");\n  verifyFormat(\"aaaaaaaaaaaaaaa.aaaaaaaaaaaaaaa()\\n\"\n               \"    .aaaaaaaaaaaaaaa()\\n\"\n               \"    .aaaaaaaaaaaaaaa()\\n\"\n               \"    .aaaaaaaaaaaaaaa();\");\n  verifyFormat(\"aaaaaaaaaaaaaaa.aaaaaaaaaaaaaaa()\\n\"\n               \"    .aaaaaaaaaaaaaaa.aaaaaaaaaaaaaaa()\\n\"\n               \"    .aaaaaaaaaaaaaaa();\");\n  verifyFormat(\"aaaaaaaaaaaaa->aaaaaaaaaaaaaaaaaaaaaaaa()\\n\"\n               \"    ->aaaaaaaaaaaaaae(0)\\n\"\n               \"    ->aaaaaaaaaaaaaaa();\");\n\n  // Don't linewrap after very short segments.\n  verifyFormat(\"a().aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()\\n\"\n               \"    .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()\\n\"\n               \"    .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa();\");\n  verifyFormat(\"aa().aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()\\n\"\n               \"    .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()\\n\"\n               \"    .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa();\");\n  verifyFormat(\"aaa()\\n\"\n               \"    .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()\\n\"\n               \"    .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()\\n\"\n               \"    .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa();\");\n\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaa()\\n\"\n               \"    .aaaaaaaaaaaaaaaaaaaaaaaaaa()\\n\"\n               \"    .has<bbbbbbbbbbbbbbbbbbbbb>();\");\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaa()\\n\"\n               \"    .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa>();\");\n\n  // Prefer not to break after empty parentheses.\n  verifyFormat(\"FirstToken->WhitespaceRange.getBegin().getLocWithOffset(\\n\"\n               \"    First->LastNewlineOffset);\");\n\n  // Prefer not to create \"hanging\" indents.\n  verifyFormat(\n      \"return !soooooooooooooome_map\\n\"\n      \"            .insert(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n      \"            .second;\");\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaa\\n\"\n      \"    .aaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaa)\\n\"\n      \"    .aaaa(aaaaaaaaaaaaaa);\");\n  // No hanging indent here.\n  verifyFormat(\"aaaaaaaaaaaaaaaa.aaaaaaaaaaaaaa.aaaaaaaaaaaaaaa(\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\"aaaaaaaaaaaaaaaa.aaaaaaaaaaaaaa().aaaaaaaaaaaaaaa(\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\"aaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"    .aaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\",\n               getLLVMStyleWithColumns(60));\n  verifyFormat(\"aaaaaaaaaaaaaaaaaa\\n\"\n               \"    .aaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"    .aaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\",\n               getLLVMStyleWithColumns(59));\n  verifyFormat(\"aaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"    .aaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n\n  // Dont break if only closing statements before member call\n  verifyFormat(\"test() {\\n\"\n               \"  ([]() -> {\\n\"\n               \"    int b = 32;\\n\"\n               \"    return 3;\\n\"\n               \"  }).foo();\\n\"\n               \"}\");\n  verifyFormat(\"test() {\\n\"\n               \"  (\\n\"\n               \"      []() -> {\\n\"\n               \"        int b = 32;\\n\"\n               \"        return 3;\\n\"\n               \"      },\\n\"\n               \"      foo, bar)\\n\"\n               \"      .foo();\\n\"\n               \"}\");\n  verifyFormat(\"test() {\\n\"\n               \"  ([]() -> {\\n\"\n               \"    int b = 32;\\n\"\n               \"    return 3;\\n\"\n               \"  })\\n\"\n               \"      .foo()\\n\"\n               \"      .bar();\\n\"\n               \"}\");\n  verifyFormat(\"test() {\\n\"\n               \"  ([]() -> {\\n\"\n               \"    int b = 32;\\n\"\n               \"    return 3;\\n\"\n               \"  })\\n\"\n               \"      .foo(\\\"aaaaaaaaaaaaaaaaa\\\"\\n\"\n               \"           \\\"bbbb\\\");\\n\"\n               \"}\",\n               getLLVMStyleWithColumns(30));\n}\n\nTEST_F(FormatTest, BreaksAccordingToOperatorPrecedence) {\n  verifyFormat(\n      \"if (aaaaaaaaaaaaaaaaaaaaaaaaa ||\\n\"\n      \"    bbbbbbbbbbbbbbbbbbbbbbbbb && ccccccccccccccccccccccccc) {\\n}\");\n  verifyFormat(\n      \"if (aaaaaaaaaaaaaaaaaaaaaaaaa or\\n\"\n      \"    bbbbbbbbbbbbbbbbbbbbbbbbb and cccccccccccccccccccccccc) {\\n}\");\n\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaa && bbbbbbbbbbbbbbbbbbbbbbbbb ||\\n\"\n               \"    ccccccccccccccccccccccccc) {\\n}\");\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaa and bbbbbbbbbbbbbbbbbbbbbbbb or\\n\"\n               \"    ccccccccccccccccccccccccc) {\\n}\");\n\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaa || bbbbbbbbbbbbbbbbbbbbbbbbb ||\\n\"\n               \"    ccccccccccccccccccccccccc) {\\n}\");\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaa or bbbbbbbbbbbbbbbbbbbbbbbbb or\\n\"\n               \"    ccccccccccccccccccccccccc) {\\n}\");\n\n  verifyFormat(\n      \"if ((aaaaaaaaaaaaaaaaaaaaaaaaa || bbbbbbbbbbbbbbbbbbbbbbbbb) &&\\n\"\n      \"    ccccccccccccccccccccccccc) {\\n}\");\n  verifyFormat(\n      \"if ((aaaaaaaaaaaaaaaaaaaaaaaaa or bbbbbbbbbbbbbbbbbbbbbbbbb) and\\n\"\n      \"    ccccccccccccccccccccccccc) {\\n}\");\n\n  verifyFormat(\"return aaaa & AAAAAAAAAAAAAAAAAAAAAAAAAAAAA ||\\n\"\n               \"       bbbb & BBBBBBBBBBBBBBBBBBBBBBBBBBBBB ||\\n\"\n               \"       cccc & CCCCCCCCCCCCCCCCCCCCCCCCCC ||\\n\"\n               \"       dddd & DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD;\");\n  verifyFormat(\"return aaaa & AAAAAAAAAAAAAAAAAAAAAAAAAAAAA or\\n\"\n               \"       bbbb & BBBBBBBBBBBBBBBBBBBBBBBBBBBBB or\\n\"\n               \"       cccc & CCCCCCCCCCCCCCCCCCCCCCCCCC or\\n\"\n               \"       dddd & DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD;\");\n\n  verifyFormat(\"if ((aaaaaaaaaa != aaaaaaaaaaaaaaa ||\\n\"\n               \"     aaaaaaaaaaaaaaaaaaaaaaaa() >= aaaaaaaaaaaaaaaaaaaa) &&\\n\"\n               \"    aaaaaaaaaaaaaaa != aa) {\\n}\");\n  verifyFormat(\"if ((aaaaaaaaaa != aaaaaaaaaaaaaaa or\\n\"\n               \"     aaaaaaaaaaaaaaaaaaaaaaaa() >= aaaaaaaaaaaaaaaaaaaa) and\\n\"\n               \"    aaaaaaaaaaaaaaa != aa) {\\n}\");\n}\n\nTEST_F(FormatTest, BreaksAfterAssignments) {\n  verifyFormat(\n      \"unsigned Cost =\\n\"\n      \"    TTI.getMemoryOpCost(I->getOpcode(), VectorTy, SI->getAlignment(),\\n\"\n      \"                        SI->getPointerAddressSpaceee());\\n\");\n  verifyFormat(\n      \"CharSourceRange LineRange = CharSourceRange::getTokenRange(\\n\"\n      \"    Line.Tokens.front().Tok.getLo(), Line.Tokens.back().Tok.getLoc());\");\n\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaa aaaa = aaaaaaaaaaaaaa(0).aaaa().aaaaaaaaa(\\n\"\n      \"    aaaaaaaaaaaaaaaaaaa::aaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\"unsigned OriginalStartColumn =\\n\"\n               \"    SourceMgr.getSpellingColumnNumber(\\n\"\n               \"        Current.FormatTok.getStartOfNonWhitespace()) -\\n\"\n               \"    1;\");\n}\n\nTEST_F(FormatTest, ConfigurableBreakAssignmentPenalty) {\n  FormatStyle Style = getLLVMStyle();\n  verifyFormat(\"int aaaaaaaaaaaaaaaaaaaaaaaaaa =\\n\"\n               \"    bbbbbbbbbbbbbbbbbbbbbbbbbb + cccccccccccccccccccccccccc;\",\n               Style);\n\n  Style.PenaltyBreakAssignment = 20;\n  verifyFormat(\"int aaaaaaaaaaaaaaaaaaaaaaaaaa = bbbbbbbbbbbbbbbbbbbbbbbbbb +\\n\"\n               \"                                 cccccccccccccccccccccccccc;\",\n               Style);\n}\n\nTEST_F(FormatTest, AlignsAfterAssignments) {\n  verifyFormat(\n      \"int Result = aaaaaaaaaaaaaaaaaaaaaaaaa + aaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n      \"             aaaaaaaaaaaaaaaaaaaaaaaaa;\");\n  verifyFormat(\n      \"Result += aaaaaaaaaaaaaaaaaaaaaaaaa + aaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n      \"          aaaaaaaaaaaaaaaaaaaaaaaaa;\");\n  verifyFormat(\n      \"Result >>= aaaaaaaaaaaaaaaaaaaaaaaaa + aaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n      \"           aaaaaaaaaaaaaaaaaaaaaaaaa;\");\n  verifyFormat(\n      \"int Result = (aaaaaaaaaaaaaaaaaaaaaaaaa + aaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n      \"              aaaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\n      \"double LooooooooooooooooooooooooongResult = aaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n      \"                                            aaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n      \"                                            aaaaaaaaaaaaaaaaaaaaaaaa;\");\n}\n\nTEST_F(FormatTest, AlignsAfterReturn) {\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaaaaaaaaaaa + aaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n      \"       aaaaaaaaaaaaaaaaaaaaaaaaa;\");\n  verifyFormat(\n      \"return (aaaaaaaaaaaaaaaaaaaaaaaaa + aaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n      \"        aaaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaaaaaaaa + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >=\\n\"\n      \"       aaaaaaaaaaaaaaaaaaaaaa();\");\n  verifyFormat(\n      \"return (aaaaaaaaaaaaaaaaaaaaaa + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >=\\n\"\n      \"        aaaaaaaaaaaaaaaaaaaaaa());\");\n  verifyFormat(\"return aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\"return aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"           aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) &&\\n\"\n               \"       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\");\n  verifyFormat(\"return\\n\"\n               \"    // true if code is one of a or b.\\n\"\n               \"    code == a || code == b;\");\n}\n\nTEST_F(FormatTest, AlignsAfterOpenBracket) {\n  verifyFormat(\n      \"void aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaa aaaaaaaa,\\n\"\n      \"                                                aaaaaaaaa aaaaaaa) {}\");\n  verifyFormat(\n      \"SomeLongVariableName->someVeryLongFunctionName(aaaaaaaaaaa aaaaaaaaa,\\n\"\n      \"                                               aaaaaaaaaaa aaaaaaaaa);\");\n  verifyFormat(\n      \"SomeLongVariableName->someFunction(foooooooo(aaaaaaaaaaaaaaa,\\n\"\n      \"                                             aaaaaaaaaaaaaaaaaaaaa));\");\n  FormatStyle Style = getLLVMStyle();\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_DontAlign;\n  verifyFormat(\"void aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"    aaaaaaaaaaa aaaaaaaa, aaaaaaaaa aaaaaaa) {}\",\n               Style);\n  verifyFormat(\"SomeLongVariableName->someVeryLongFunctionName(\\n\"\n               \"    aaaaaaaaaaa aaaaaaaaa, aaaaaaaaaaa aaaaaaaaa);\",\n               Style);\n  verifyFormat(\"SomeLongVariableName->someFunction(\\n\"\n               \"    foooooooo(aaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaaa));\",\n               Style);\n  verifyFormat(\n      \"void aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaa aaaaaaaa,\\n\"\n      \"    aaaaaaaaa aaaaaaa, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\",\n      Style);\n  verifyFormat(\n      \"SomeLongVariableName->someVeryLongFunctionName(aaaaaaaaaaa aaaaaaaaa,\\n\"\n      \"    aaaaaaaaaaa aaaaaaaaa, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\",\n      Style);\n  verifyFormat(\n      \"SomeLongVariableName->someFunction(foooooooo(aaaaaaaaaaaaaaa,\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa));\",\n      Style);\n\n  verifyFormat(\"bbbbbbbbbbbb(aaaaaaaaaaaaaaaaaaaaaaaa, //\\n\"\n               \"    ccccccc(aaaaaaaaaaaaaaaaa,         //\\n\"\n               \"        b));\",\n               Style);\n\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_AlwaysBreak;\n  Style.BinPackArguments = false;\n  Style.BinPackParameters = false;\n  verifyFormat(\"void aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"    aaaaaaaaaaa aaaaaaaa,\\n\"\n               \"    aaaaaaaaa aaaaaaa,\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}\",\n               Style);\n  verifyFormat(\"SomeLongVariableName->someVeryLongFunctionName(\\n\"\n               \"    aaaaaaaaaaa aaaaaaaaa,\\n\"\n               \"    aaaaaaaaaaa aaaaaaaaa,\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\",\n               Style);\n  verifyFormat(\"SomeLongVariableName->someFunction(foooooooo(\\n\"\n               \"    aaaaaaaaaaaaaaa,\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa));\",\n               Style);\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaa)));\",\n      Style);\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaa.aaaaaaaaaa(\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaa)));\",\n      Style);\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"        aaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaa)),\\n\"\n      \"    aaaaaaaaaaaaaaaa);\",\n      Style);\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"        aaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaa)) &&\\n\"\n      \"    aaaaaaaaaaaaaaaa);\",\n      Style);\n}\n\nTEST_F(FormatTest, ParenthesesAndOperandAlignment) {\n  FormatStyle Style = getLLVMStyleWithColumns(40);\n  verifyFormat(\"int a = f(aaaaaaaaaaaaaaaaaaaaaa &&\\n\"\n               \"          bbbbbbbbbbbbbbbbbbbbbb);\",\n               Style);\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_Align;\n  Style.AlignOperands = FormatStyle::OAS_DontAlign;\n  verifyFormat(\"int a = f(aaaaaaaaaaaaaaaaaaaaaa &&\\n\"\n               \"          bbbbbbbbbbbbbbbbbbbbbb);\",\n               Style);\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_DontAlign;\n  Style.AlignOperands = FormatStyle::OAS_Align;\n  verifyFormat(\"int a = f(aaaaaaaaaaaaaaaaaaaaaa &&\\n\"\n               \"          bbbbbbbbbbbbbbbbbbbbbb);\",\n               Style);\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_DontAlign;\n  Style.AlignOperands = FormatStyle::OAS_DontAlign;\n  verifyFormat(\"int a = f(aaaaaaaaaaaaaaaaaaaaaa &&\\n\"\n               \"    bbbbbbbbbbbbbbbbbbbbbb);\",\n               Style);\n}\n\nTEST_F(FormatTest, BreaksConditionalExpressions) {\n  verifyFormat(\n      \"aaaa(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                               ? aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                               : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\n      \"aaaa(aaaaaaaaaa, aaaaaaaa,\\n\"\n      \"     aaaaaaaaaaaaaaaaaaaaaaaaaa ? aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                                : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\n      \"aaaa(aaaaaaaaaaaaaaaaaaaa, aaaaaaa ? aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                                   : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\"aaaa(aaaaaaaaa, aaaaaaaaa,\\n\"\n               \"     aaaaaaa ? aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"             : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaa ? aaaa(aaaaaa)\\n\"\n      \"                                                    : aaaaaaaaaaaaa);\");\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"                   aaaaaaaaaaaaaaaa ? aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                                    : aaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"                   aaaaaaaaaaaaa);\");\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"                   aaaaaaaaaaaaaaaa ?: aaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"                   aaaaaaaaaaaaa);\");\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    ? aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"          aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"    : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"          aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\"aaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"           ? aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"                 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"           : aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"                 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa),\\n\"\n               \"       aaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\"aaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"           ?: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa),\\n\"\n               \"       aaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    ? aaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    : aaaaaaaaaaaaaaaaaaaaaaaaaaa;\");\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaa =\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"        ? aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"        : aaaaaaaaaaaaaaaa;\");\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"    ? aaaaaaaaaaaaaaa\\n\"\n      \"    : aaaaaaaaaaaaaaa;\");\n  verifyFormat(\"f(aaaaaaaaaaaaaaaa == // force break\\n\"\n               \"          aaaaaaaaa\\n\"\n               \"      ? b\\n\"\n               \"      : c);\");\n  verifyFormat(\"return aaaa == bbbb\\n\"\n               \"           // comment\\n\"\n               \"           ? aaaa\\n\"\n               \"           : bbbb;\");\n  verifyFormat(\"unsigned Indent =\\n\"\n               \"    format(TheLine.First,\\n\"\n               \"           IndentForLevel[TheLine.Level] >= 0\\n\"\n               \"               ? IndentForLevel[TheLine.Level]\\n\"\n               \"               : TheLine * 2,\\n\"\n               \"           TheLine.InPPDirective, PreviousEndOfLineColumn);\",\n               getLLVMStyleWithColumns(60));\n  verifyFormat(\"bool aaaaaa = aaaaaaaaaaaaa //\\n\"\n               \"                  ? aaaaaaaaaaaaaaa\\n\"\n               \"                  : bbbbbbbbbbbbbbb //\\n\"\n               \"                        ? ccccccccccccccc\\n\"\n               \"                        : ddddddddddddddd;\");\n  verifyFormat(\"bool aaaaaa = aaaaaaaaaaaaa //\\n\"\n               \"                  ? aaaaaaaaaaaaaaa\\n\"\n               \"                  : (bbbbbbbbbbbbbbb //\\n\"\n               \"                         ? ccccccccccccccc\\n\"\n               \"                         : ddddddddddddddd);\");\n  verifyFormat(\n      \"int aaaaaaaaaaaaaaaaaaaaaaaaaaa = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                                      ? aaaaaaaaaaaaaaaaaaaaaaaaa +\\n\"\n      \"                                            aaaaaaaaaaaaaaaaaaaaa +\\n\"\n      \"                                            aaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                                      : aaaaaaaaaa;\");\n  verifyFormat(\n      \"aaaaaa = aaaaaaaaaaaa ? aaaaaaaaaa ? aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                                   : aaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                      : aaaaaaaaaaaaaaaaaaaaaaaaaaaa;\");\n\n  FormatStyle NoBinPacking = getLLVMStyle();\n  NoBinPacking.BinPackArguments = false;\n  verifyFormat(\n      \"void f() {\\n\"\n      \"  g(aaa,\\n\"\n      \"    aaaaaaaaaa == aaaaaaaaaa ? aaaa : aaaaa,\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"        ? aaaaaaaaaaaaaaa\\n\"\n      \"        : aaaaaaaaaaaaaaa);\\n\"\n      \"}\",\n      NoBinPacking);\n  verifyFormat(\n      \"void f() {\\n\"\n      \"  g(aaa,\\n\"\n      \"    aaaaaaaaaa == aaaaaaaaaa ? aaaa : aaaaa,\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"        ?: aaaaaaaaaaaaaaa);\\n\"\n      \"}\",\n      NoBinPacking);\n\n  verifyFormat(\"SomeFunction(aaaaaaaaaaaaaaaaa,\\n\"\n               \"             // comment.\\n\"\n               \"             ccccccccccccccccccccccccccccccccccccccc\\n\"\n               \"                 ? aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"                 : bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);\");\n\n  // Assignments in conditional expressions. Apparently not uncommon :-(.\n  verifyFormat(\"return a != b\\n\"\n               \"           // comment\\n\"\n               \"           ? a = b\\n\"\n               \"           : a = b;\");\n  verifyFormat(\"return a != b\\n\"\n               \"           // comment\\n\"\n               \"           ? a = a != b\\n\"\n               \"                     // comment\\n\"\n               \"                     ? a = b\\n\"\n               \"                     : a\\n\"\n               \"           : a;\\n\");\n  verifyFormat(\"return a != b\\n\"\n               \"           // comment\\n\"\n               \"           ? a\\n\"\n               \"           : a = a != b\\n\"\n               \"                     // comment\\n\"\n               \"                     ? a = b\\n\"\n               \"                     : a;\");\n\n  // Chained conditionals\n  FormatStyle Style = getLLVMStyle();\n  Style.ColumnLimit = 70;\n  Style.AlignOperands = FormatStyle::OAS_Align;\n  verifyFormat(\"return aaaaaaaaaaaaaaaa ? 1111111111111111\\n\"\n               \"       : bbbbbbbbbbbbbb ? 2222222222222222\\n\"\n               \"                        : 3333333333333333;\",\n               Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaa ? 1111111111111111\\n\"\n               \"       : bbbbbbbbbb     ? 2222222222222222\\n\"\n               \"                        : 3333333333333333;\",\n               Style);\n  verifyFormat(\"return aaaaaaaaaa         ? 1111111111111111\\n\"\n               \"       : bbbbbbbbbbbbbbbb ? 2222222222222222\\n\"\n               \"                          : 3333333333333333;\",\n               Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaa ? 1111111111111111\\n\"\n               \"       : bbbbbbbbbbbbbb ? 222222\\n\"\n               \"                        : 333333;\",\n               Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaa ? 1111111111111111\\n\"\n               \"       : bbbbbbbbbbbbbb ? 2222222222222222\\n\"\n               \"       : cccccccccccccc ? 3333333333333333\\n\"\n               \"                        : 4444444444444444;\",\n               Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaa ? (aaa ? bbb : ccc)\\n\"\n               \"       : bbbbbbbbbbbbbb ? 2222222222222222\\n\"\n               \"                        : 3333333333333333;\",\n               Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaa ? 1111111111111111\\n\"\n               \"       : bbbbbbbbbbbbbb ? 2222222222222222\\n\"\n               \"                        : (aaa ? bbb : ccc);\",\n               Style);\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaa ? (aaaaaaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb\\n\"\n      \"                                             : cccccccccccccccccc)\\n\"\n      \"       : bbbbbbbbbbbbbb ? 2222222222222222\\n\"\n      \"                        : 3333333333333333;\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaa        ? (aaaaaaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb\\n\"\n      \"                                             : cccccccccccccccccc)\\n\"\n      \"       : bbbbbbbbbbbbbb ? 2222222222222222\\n\"\n      \"                        : 3333333333333333;\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaa        ? a = (aaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb\\n\"\n      \"                                             : dddddddddddddddddd)\\n\"\n      \"       : bbbbbbbbbbbbbb ? 2222222222222222\\n\"\n      \"                        : 3333333333333333;\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaa        ? a + (aaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb\\n\"\n      \"                                             : dddddddddddddddddd)\\n\"\n      \"       : bbbbbbbbbbbbbb ? 2222222222222222\\n\"\n      \"                        : 3333333333333333;\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaa        ? 1111111111111111\\n\"\n      \"       : bbbbbbbbbbbbbb ? 2222222222222222\\n\"\n      \"                        : a + (aaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb\\n\"\n      \"                                             : dddddddddddddddddd)\\n\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaa ? 1111111111111111\\n\"\n      \"       : bbbbbbbbbbbbbb ? 2222222222222222\\n\"\n      \"                        : (aaaaaaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb\\n\"\n      \"                                             : cccccccccccccccccc);\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaa ? (aaaaaaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb\\n\"\n      \"                           : ccccccccccccccc ? dddddddddddddddddd\\n\"\n      \"                                             : eeeeeeeeeeeeeeeeee)\\n\"\n      \"       : bbbbbbbbbbbbbb ? 2222222222222222\\n\"\n      \"                        : 3333333333333333;\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaa ? (aaaaaaaaaaaaaa    ? bbbbbbbbbbbbbbbbbb\\n\"\n      \"                           : ccccccccccccccc ? dddddddddddddddddd\\n\"\n      \"                                             : eeeeeeeeeeeeeeeeee)\\n\"\n      \"       : bbbbbbbbbbbbbb ? 2222222222222222\\n\"\n      \"                        : 3333333333333333;\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaa ? (aaaaaaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb\\n\"\n      \"                           : cccccccccccc    ? dddddddddddddddddd\\n\"\n      \"                                             : eeeeeeeeeeeeeeeeee)\\n\"\n      \"       : bbbbbbbbbbbbbb ? 2222222222222222\\n\"\n      \"                        : 3333333333333333;\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaa ? aaaaaaaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb\\n\"\n      \"                                             : cccccccccccccccccc\\n\"\n      \"       : bbbbbbbbbbbbbb ? 2222222222222222\\n\"\n      \"                        : 3333333333333333;\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaa ? aaaaaaaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb\\n\"\n      \"                          : cccccccccccccccc ? dddddddddddddddddd\\n\"\n      \"                                             : eeeeeeeeeeeeeeeeee\\n\"\n      \"       : bbbbbbbbbbbbbb ? 2222222222222222\\n\"\n      \"                        : 3333333333333333;\",\n      Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"           ? (aaaaaaaaaaaaaaaaaa   ? bbbbbbbbbbbbbbbbbb\\n\"\n               \"              : cccccccccccccccccc ? dddddddddddddddddd\\n\"\n               \"                                   : eeeeeeeeeeeeeeeeee)\\n\"\n               \"       : bbbbbbbbbbbbbbbbbbb ? 2222222222222222\\n\"\n               \"                             : 3333333333333333;\",\n               Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"           ? aaaaaaaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb\\n\"\n               \"             : cccccccccccccccc ? dddddddddddddddddd\\n\"\n               \"                                : eeeeeeeeeeeeeeeeee\\n\"\n               \"       : bbbbbbbbbbbbbbbbbbbbbbb ? 2222222222222222\\n\"\n               \"                                 : 3333333333333333;\",\n               Style);\n\n  Style.AlignOperands = FormatStyle::OAS_DontAlign;\n  Style.BreakBeforeTernaryOperators = false;\n  // FIXME: Aligning the question marks is weird given DontAlign.\n  // Consider disabling this alignment in this case. Also check whether this\n  // will render the adjustment from https://reviews.llvm.org/D82199\n  // unnecessary.\n  verifyFormat(\"int x = aaaaaaaaaaaaaaa ? aaaaaaaaaaaaaaaaaa :\\n\"\n               \"    bbbb                ? cccccccccccccccccc :\\n\"\n               \"                          ddddd;\\n\",\n               Style);\n}\n\nTEST_F(FormatTest, BreaksConditionalExpressionsAfterOperator) {\n  FormatStyle Style = getLLVMStyle();\n  Style.BreakBeforeTernaryOperators = false;\n  Style.ColumnLimit = 70;\n  verifyFormat(\n      \"aaaa(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaaaaaaaa ?\\n\"\n      \"                               aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa :\\n\"\n      \"                               aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\",\n      Style);\n  verifyFormat(\n      \"aaaa(aaaaaaaaaa, aaaaaaaa,\\n\"\n      \"     aaaaaaaaaaaaaaaaaaaaaaaaaa ? aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa :\\n\"\n      \"                                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\",\n      Style);\n  verifyFormat(\n      \"aaaa(aaaaaaaaaaaaaaaaaaaa, aaaaaaa ? aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa :\\n\"\n      \"                                     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\",\n      Style);\n  verifyFormat(\"aaaa(aaaaaaaa, aaaaaaaaaa,\\n\"\n               \"     aaaaaaa ? aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa :\\n\"\n               \"               aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\",\n               Style);\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaa ? aaaa(aaaaaa) :\\n\"\n      \"                                                      aaaaaaaaaaaaa);\",\n      Style);\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"                   aaaaaaaaaaaaaaaa ? aaaaaaaaaaaaaaaaaaaaaaaaaaaaa :\\n\"\n      \"                                      aaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"                   aaaaaaaaaaaaa);\",\n      Style);\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"                   aaaaaaaaaaaaaaaa ?: aaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"                   aaaaaaaaaaaaa);\",\n      Style);\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ?\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) :\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\",\n               Style);\n  verifyFormat(\"aaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ?\\n\"\n               \"           aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"               aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) :\\n\"\n               \"           aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"               aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa),\\n\"\n               \"       aaaaaaaaaaaaaaaaaaaaaaaaaaa);\",\n               Style);\n  verifyFormat(\"aaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ?:\\n\"\n               \"           aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"               aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa),\\n\"\n               \"       aaaaaaaaaaaaaaaaaaaaaaaaaaa);\",\n               Style);\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ?\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaa :\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaa;\",\n               Style);\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaa =\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ?\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa :\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\",\n               Style);\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ?\\n\"\n      \"    aaaaaaaaaaaaaaa :\\n\"\n      \"    aaaaaaaaaaaaaaa;\",\n      Style);\n  verifyFormat(\"f(aaaaaaaaaaaaaaaa == // force break\\n\"\n               \"          aaaaaaaaa ?\\n\"\n               \"      b :\\n\"\n               \"      c);\",\n               Style);\n  verifyFormat(\"unsigned Indent =\\n\"\n               \"    format(TheLine.First,\\n\"\n               \"           IndentForLevel[TheLine.Level] >= 0 ?\\n\"\n               \"               IndentForLevel[TheLine.Level] :\\n\"\n               \"               TheLine * 2,\\n\"\n               \"           TheLine.InPPDirective, PreviousEndOfLineColumn);\",\n               Style);\n  verifyFormat(\"bool aaaaaa = aaaaaaaaaaaaa ? //\\n\"\n               \"                  aaaaaaaaaaaaaaa :\\n\"\n               \"                  bbbbbbbbbbbbbbb ? //\\n\"\n               \"                      ccccccccccccccc :\\n\"\n               \"                      ddddddddddddddd;\",\n               Style);\n  verifyFormat(\"bool aaaaaa = aaaaaaaaaaaaa ? //\\n\"\n               \"                  aaaaaaaaaaaaaaa :\\n\"\n               \"                  (bbbbbbbbbbbbbbb ? //\\n\"\n               \"                       ccccccccccccccc :\\n\"\n               \"                       ddddddddddddddd);\",\n               Style);\n  verifyFormat(\"int i = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ?\\n\"\n               \"            /*bbbbbbbbbbbbbbb=*/bbbbbbbbbbbbbbbbbbbbbbbbb :\\n\"\n               \"            ccccccccccccccccccccccccccc;\",\n               Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ?\\n\"\n               \"           aaaaa :\\n\"\n               \"           bbbbbbbbbbbbbbb + cccccccccccccccc;\",\n               Style);\n\n  // Chained conditionals\n  verifyFormat(\"return aaaaaaaaaaaaaaaa ? 1111111111111111 :\\n\"\n               \"       bbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n               \"                          3333333333333333;\",\n               Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaa ? 1111111111111111 :\\n\"\n               \"       bbbbbbbbbb       ? 2222222222222222 :\\n\"\n               \"                          3333333333333333;\",\n               Style);\n  verifyFormat(\"return aaaaaaaaaa       ? 1111111111111111 :\\n\"\n               \"       bbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n               \"                          3333333333333333;\",\n               Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaa ? 1111111111111111 :\\n\"\n               \"       bbbbbbbbbbbbbbbb ? 222222 :\\n\"\n               \"                          333333;\",\n               Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaa ? 1111111111111111 :\\n\"\n               \"       bbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n               \"       cccccccccccccccc ? 3333333333333333 :\\n\"\n               \"                          4444444444444444;\",\n               Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaa ? (aaa ? bbb : ccc) :\\n\"\n               \"       bbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n               \"                          3333333333333333;\",\n               Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaa ? 1111111111111111 :\\n\"\n               \"       bbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n               \"                          (aaa ? bbb : ccc);\",\n               Style);\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaa ? (aaaaaaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb :\\n\"\n      \"                                               cccccccccccccccccc) :\\n\"\n      \"       bbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n      \"                          3333333333333333;\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaa        ? (aaaaaaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb :\\n\"\n      \"                                               cccccccccccccccccc) :\\n\"\n      \"       bbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n      \"                          3333333333333333;\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaa        ? a = (aaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb :\\n\"\n      \"                                               dddddddddddddddddd) :\\n\"\n      \"       bbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n      \"                          3333333333333333;\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaa        ? a + (aaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb :\\n\"\n      \"                                               dddddddddddddddddd) :\\n\"\n      \"       bbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n      \"                          3333333333333333;\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaa        ? 1111111111111111 :\\n\"\n      \"       bbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n      \"                          a + (aaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb :\\n\"\n      \"                                               dddddddddddddddddd)\\n\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaa ? 1111111111111111 :\\n\"\n      \"       bbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n      \"                          (aaaaaaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb :\\n\"\n      \"                                               cccccccccccccccccc);\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaa ? (aaaaaaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb :\\n\"\n      \"                           ccccccccccccccccc ? dddddddddddddddddd :\\n\"\n      \"                                               eeeeeeeeeeeeeeeeee) :\\n\"\n      \"       bbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n      \"                          3333333333333333;\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaa ? (aaaaaaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb :\\n\"\n      \"                           ccccccccccccc     ? dddddddddddddddddd :\\n\"\n      \"                                               eeeeeeeeeeeeeeeeee) :\\n\"\n      \"       bbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n      \"                          3333333333333333;\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaa ? (aaaaaaaaaaaaa     ? bbbbbbbbbbbbbbbbbb :\\n\"\n      \"                           ccccccccccccccccc ? dddddddddddddddddd :\\n\"\n      \"                                               eeeeeeeeeeeeeeeeee) :\\n\"\n      \"       bbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n      \"                          3333333333333333;\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaa ? aaaaaaaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb :\\n\"\n      \"                                               cccccccccccccccccc :\\n\"\n      \"       bbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n      \"                          3333333333333333;\",\n      Style);\n  verifyFormat(\n      \"return aaaaaaaaaaaaaaaa ? aaaaaaaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb :\\n\"\n      \"                          cccccccccccccccccc ? dddddddddddddddddd :\\n\"\n      \"                                               eeeeeeeeeeeeeeeeee :\\n\"\n      \"       bbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n      \"                          3333333333333333;\",\n      Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaaaaaaa ?\\n\"\n               \"           (aaaaaaaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb :\\n\"\n               \"            cccccccccccccccccc ? dddddddddddddddddd :\\n\"\n               \"                                 eeeeeeeeeeeeeeeeee) :\\n\"\n               \"       bbbbbbbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n               \"                               3333333333333333;\",\n               Style);\n  verifyFormat(\"return aaaaaaaaaaaaaaaaaaaaa ?\\n\"\n               \"           aaaaaaaaaaaaaaaaaaaa ? bbbbbbbbbbbbbbbbbb :\\n\"\n               \"           cccccccccccccccccccc ? dddddddddddddddddd :\\n\"\n               \"                                  eeeeeeeeeeeeeeeeee :\\n\"\n               \"       bbbbbbbbbbbbbbbbbbbbb ? 2222222222222222 :\\n\"\n               \"                               3333333333333333;\",\n               Style);\n}\n\nTEST_F(FormatTest, DeclarationsOfMultipleVariables) {\n  verifyFormat(\"bool aaaaaaaaaaaaaaaaa = aaaaaa->aaaaaaaaaaaaaaaaa(),\\n\"\n               \"     aaaaaaaaaaa = aaaaaa->aaaaaaaaaaa();\");\n  verifyFormat(\"bool a = true, b = false;\");\n\n  verifyFormat(\"bool aaaaaaaaaaaaaaaaaaaaaaaaa =\\n\"\n               \"         aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaa),\\n\"\n               \"     bbbbbbbbbbbbbbbbbbbbbbbbb =\\n\"\n               \"         bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb(bbbbbbbbbbbbbbbb);\");\n  verifyFormat(\n      \"bool aaaaaaaaaaaaaaaaaaaaa =\\n\"\n      \"         bbbbbbbbbbbbbbbbbbbbbbbbbbbb && cccccccccccccccccccccccccccc,\\n\"\n      \"     d = e && f;\");\n  verifyFormat(\"aaaaaaaaa a = aaaaaaaaaaaaaaaaaaaa, b = bbbbbbbbbbbbbbbbbbbb,\\n\"\n               \"          c = cccccccccccccccccccc, d = dddddddddddddddddddd;\");\n  verifyFormat(\"aaaaaaaaa *a = aaaaaaaaaaaaaaaaaaa, *b = bbbbbbbbbbbbbbbbbbb,\\n\"\n               \"          *c = ccccccccccccccccccc, *d = ddddddddddddddddddd;\");\n  verifyFormat(\"aaaaaaaaa ***a = aaaaaaaaaaaaaaaaaaa, ***b = bbbbbbbbbbbbbbb,\\n\"\n               \"          ***c = ccccccccccccccccccc, ***d = ddddddddddddddd;\");\n\n  FormatStyle Style = getGoogleStyle();\n  Style.PointerAlignment = FormatStyle::PAS_Left;\n  Style.DerivePointerAlignment = false;\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    *aaaaaaaaaaaaaaaaaaaaaaaaaaaaa = aaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    *b = bbbbbbbbbbbbbbbbbbb;\",\n               Style);\n  verifyFormat(\"aaaaaaaaa *a = aaaaaaaaaaaaaaaaaaa, *b = bbbbbbbbbbbbbbbbbbb,\\n\"\n               \"          *b = bbbbbbbbbbbbbbbbbbb, *d = ddddddddddddddddddd;\",\n               Style);\n  verifyFormat(\"vector<int*> a, b;\", Style);\n  verifyFormat(\"for (int *p, *q; p != q; p = p->next) {\\n}\", Style);\n}\n\nTEST_F(FormatTest, ConditionalExpressionsInBrackets) {\n  verifyFormat(\"arr[foo ? bar : baz];\");\n  verifyFormat(\"f()[foo ? bar : baz];\");\n  verifyFormat(\"(a + b)[foo ? bar : baz];\");\n  verifyFormat(\"arr[foo ? (4 > 5 ? 4 : 5) : 5 < 5 ? 5 : 7];\");\n}\n\nTEST_F(FormatTest, AlignsStringLiterals) {\n  verifyFormat(\"loooooooooooooooooooooooooongFunction(\\\"short literal \\\"\\n\"\n               \"                                      \\\"short literal\\\");\");\n  verifyFormat(\n      \"looooooooooooooooooooooooongFunction(\\n\"\n      \"    \\\"short literal\\\"\\n\"\n      \"    \\\"looooooooooooooooooooooooooooooooooooooooooooooooong literal\\\");\");\n  verifyFormat(\"someFunction(\\\"Always break between multi-line\\\"\\n\"\n               \"             \\\" string literals\\\",\\n\"\n               \"             and, other, parameters);\");\n  EXPECT_EQ(\"fun + \\\"1243\\\" /* comment */\\n\"\n            \"      \\\"5678\\\";\",\n            format(\"fun + \\\"1243\\\" /* comment */\\n\"\n                   \"    \\\"5678\\\";\",\n                   getLLVMStyleWithColumns(28)));\n  EXPECT_EQ(\n      \"aaaaaa = \\\"aaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaa \\\"\\n\"\n      \"         \\\"aaaaaaaaaaaaaaaaaaaaa\\\"\\n\"\n      \"         \\\"aaaaaaaaaaaaaaaa\\\";\",\n      format(\"aaaaaa =\"\n             \"\\\"aaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaa \"\n             \"aaaaaaaaaaaaaaaaaaaaa\\\" \"\n             \"\\\"aaaaaaaaaaaaaaaa\\\";\"));\n  verifyFormat(\"a = a + \\\"a\\\"\\n\"\n               \"        \\\"a\\\"\\n\"\n               \"        \\\"a\\\";\");\n  verifyFormat(\"f(\\\"a\\\", \\\"b\\\"\\n\"\n               \"       \\\"c\\\");\");\n\n  verifyFormat(\n      \"#define LL_FORMAT \\\"ll\\\"\\n\"\n      \"printf(\\\"aaaaa: %d, bbbbbb: %\\\" LL_FORMAT \\\"d, cccccccc: %\\\" LL_FORMAT\\n\"\n      \"       \\\"d, ddddddddd: %\\\" LL_FORMAT \\\"d\\\");\");\n\n  verifyFormat(\"#define A(X)          \\\\\\n\"\n               \"  \\\"aaaaa\\\" #X \\\"bbbbbb\\\" \\\\\\n\"\n               \"  \\\"ccccc\\\"\",\n               getLLVMStyleWithColumns(23));\n  verifyFormat(\"#define A \\\"def\\\"\\n\"\n               \"f(\\\"abc\\\" A \\\"ghi\\\"\\n\"\n               \"  \\\"jkl\\\");\");\n\n  verifyFormat(\"f(L\\\"a\\\"\\n\"\n               \"  L\\\"b\\\");\");\n  verifyFormat(\"#define A(X)            \\\\\\n\"\n               \"  L\\\"aaaaa\\\" #X L\\\"bbbbbb\\\" \\\\\\n\"\n               \"  L\\\"ccccc\\\"\",\n               getLLVMStyleWithColumns(25));\n\n  verifyFormat(\"f(@\\\"a\\\"\\n\"\n               \"  @\\\"b\\\");\");\n  verifyFormat(\"NSString s = @\\\"a\\\"\\n\"\n               \"             @\\\"b\\\"\\n\"\n               \"             @\\\"c\\\";\");\n  verifyFormat(\"NSString s = @\\\"a\\\"\\n\"\n               \"              \\\"b\\\"\\n\"\n               \"              \\\"c\\\";\");\n}\n\nTEST_F(FormatTest, ReturnTypeBreakingStyle) {\n  FormatStyle Style = getLLVMStyle();\n  // No declarations or definitions should be moved to own line.\n  Style.AlwaysBreakAfterReturnType = FormatStyle::RTBS_None;\n  verifyFormat(\"class A {\\n\"\n               \"  int f() { return 1; }\\n\"\n               \"  int g();\\n\"\n               \"};\\n\"\n               \"int f() { return 1; }\\n\"\n               \"int g();\\n\",\n               Style);\n\n  // All declarations and definitions should have the return type moved to its\n  // own line.\n  Style.AlwaysBreakAfterReturnType = FormatStyle::RTBS_All;\n  Style.TypenameMacros = {\"LIST\"};\n  verifyFormat(\"SomeType\\n\"\n               \"funcdecl(LIST(uint64_t));\",\n               Style);\n  verifyFormat(\"class E {\\n\"\n               \"  int\\n\"\n               \"  f() {\\n\"\n               \"    return 1;\\n\"\n               \"  }\\n\"\n               \"  int\\n\"\n               \"  g();\\n\"\n               \"};\\n\"\n               \"int\\n\"\n               \"f() {\\n\"\n               \"  return 1;\\n\"\n               \"}\\n\"\n               \"int\\n\"\n               \"g();\\n\",\n               Style);\n\n  // Top-level definitions, and no kinds of declarations should have the\n  // return type moved to its own line.\n  Style.AlwaysBreakAfterReturnType = FormatStyle::RTBS_TopLevelDefinitions;\n  verifyFormat(\"class B {\\n\"\n               \"  int f() { return 1; }\\n\"\n               \"  int g();\\n\"\n               \"};\\n\"\n               \"int\\n\"\n               \"f() {\\n\"\n               \"  return 1;\\n\"\n               \"}\\n\"\n               \"int g();\\n\",\n               Style);\n\n  // Top-level definitions and declarations should have the return type moved\n  // to its own line.\n  Style.AlwaysBreakAfterReturnType = FormatStyle::RTBS_TopLevel;\n  verifyFormat(\"class C {\\n\"\n               \"  int f() { return 1; }\\n\"\n               \"  int g();\\n\"\n               \"};\\n\"\n               \"int\\n\"\n               \"f() {\\n\"\n               \"  return 1;\\n\"\n               \"}\\n\"\n               \"int\\n\"\n               \"g();\\n\",\n               Style);\n\n  // All definitions should have the return type moved to its own line, but no\n  // kinds of declarations.\n  Style.AlwaysBreakAfterReturnType = FormatStyle::RTBS_AllDefinitions;\n  verifyFormat(\"class D {\\n\"\n               \"  int\\n\"\n               \"  f() {\\n\"\n               \"    return 1;\\n\"\n               \"  }\\n\"\n               \"  int g();\\n\"\n               \"};\\n\"\n               \"int\\n\"\n               \"f() {\\n\"\n               \"  return 1;\\n\"\n               \"}\\n\"\n               \"int g();\\n\",\n               Style);\n  verifyFormat(\"const char *\\n\"\n               \"f(void) {\\n\" // Break here.\n               \"  return \\\"\\\";\\n\"\n               \"}\\n\"\n               \"const char *bar(void);\\n\", // No break here.\n               Style);\n  verifyFormat(\"template <class T>\\n\"\n               \"T *\\n\"\n               \"f(T &c) {\\n\" // Break here.\n               \"  return NULL;\\n\"\n               \"}\\n\"\n               \"template <class T> T *f(T &c);\\n\", // No break here.\n               Style);\n  verifyFormat(\"class C {\\n\"\n               \"  int\\n\"\n               \"  operator+() {\\n\"\n               \"    return 1;\\n\"\n               \"  }\\n\"\n               \"  int\\n\"\n               \"  operator()() {\\n\"\n               \"    return 1;\\n\"\n               \"  }\\n\"\n               \"};\\n\",\n               Style);\n  verifyFormat(\"void\\n\"\n               \"A::operator()() {}\\n\"\n               \"void\\n\"\n               \"A::operator>>() {}\\n\"\n               \"void\\n\"\n               \"A::operator+() {}\\n\"\n               \"void\\n\"\n               \"A::operator*() {}\\n\"\n               \"void\\n\"\n               \"A::operator->() {}\\n\"\n               \"void\\n\"\n               \"A::operator void *() {}\\n\"\n               \"void\\n\"\n               \"A::operator void &() {}\\n\"\n               \"void\\n\"\n               \"A::operator void &&() {}\\n\"\n               \"void\\n\"\n               \"A::operator char *() {}\\n\"\n               \"void\\n\"\n               \"A::operator[]() {}\\n\"\n               \"void\\n\"\n               \"A::operator!() {}\\n\"\n               \"void\\n\"\n               \"A::operator**() {}\\n\"\n               \"void\\n\"\n               \"A::operator<Foo> *() {}\\n\"\n               \"void\\n\"\n               \"A::operator<Foo> **() {}\\n\"\n               \"void\\n\"\n               \"A::operator<Foo> &() {}\\n\"\n               \"void\\n\"\n               \"A::operator void **() {}\\n\",\n               Style);\n  verifyFormat(\"constexpr auto\\n\"\n               \"operator()() const -> reference {}\\n\"\n               \"constexpr auto\\n\"\n               \"operator>>() const -> reference {}\\n\"\n               \"constexpr auto\\n\"\n               \"operator+() const -> reference {}\\n\"\n               \"constexpr auto\\n\"\n               \"operator*() const -> reference {}\\n\"\n               \"constexpr auto\\n\"\n               \"operator->() const -> reference {}\\n\"\n               \"constexpr auto\\n\"\n               \"operator++() const -> reference {}\\n\"\n               \"constexpr auto\\n\"\n               \"operator void *() const -> reference {}\\n\"\n               \"constexpr auto\\n\"\n               \"operator void **() const -> reference {}\\n\"\n               \"constexpr auto\\n\"\n               \"operator void *() const -> reference {}\\n\"\n               \"constexpr auto\\n\"\n               \"operator void &() const -> reference {}\\n\"\n               \"constexpr auto\\n\"\n               \"operator void &&() const -> reference {}\\n\"\n               \"constexpr auto\\n\"\n               \"operator char *() const -> reference {}\\n\"\n               \"constexpr auto\\n\"\n               \"operator!() const -> reference {}\\n\"\n               \"constexpr auto\\n\"\n               \"operator[]() const -> reference {}\\n\",\n               Style);\n  verifyFormat(\"void *operator new(std::size_t s);\", // No break here.\n               Style);\n  verifyFormat(\"void *\\n\"\n               \"operator new(std::size_t s) {}\",\n               Style);\n  verifyFormat(\"void *\\n\"\n               \"operator delete[](void *ptr) {}\",\n               Style);\n  Style.BreakBeforeBraces = FormatStyle::BS_Stroustrup;\n  verifyFormat(\"const char *\\n\"\n               \"f(void)\\n\" // Break here.\n               \"{\\n\"\n               \"  return \\\"\\\";\\n\"\n               \"}\\n\"\n               \"const char *bar(void);\\n\", // No break here.\n               Style);\n  verifyFormat(\"template <class T>\\n\"\n               \"T *\\n\"     // Problem here: no line break\n               \"f(T &c)\\n\" // Break here.\n               \"{\\n\"\n               \"  return NULL;\\n\"\n               \"}\\n\"\n               \"template <class T> T *f(T &c);\\n\", // No break here.\n               Style);\n  verifyFormat(\"int\\n\"\n               \"foo(A<bool> a)\\n\"\n               \"{\\n\"\n               \"  return a;\\n\"\n               \"}\\n\",\n               Style);\n  verifyFormat(\"int\\n\"\n               \"foo(A<8> a)\\n\"\n               \"{\\n\"\n               \"  return a;\\n\"\n               \"}\\n\",\n               Style);\n  verifyFormat(\"int\\n\"\n               \"foo(A<B<bool>, 8> a)\\n\"\n               \"{\\n\"\n               \"  return a;\\n\"\n               \"}\\n\",\n               Style);\n  verifyFormat(\"int\\n\"\n               \"foo(A<B<8>, bool> a)\\n\"\n               \"{\\n\"\n               \"  return a;\\n\"\n               \"}\\n\",\n               Style);\n  verifyFormat(\"int\\n\"\n               \"foo(A<B<bool>, bool> a)\\n\"\n               \"{\\n\"\n               \"  return a;\\n\"\n               \"}\\n\",\n               Style);\n  verifyFormat(\"int\\n\"\n               \"foo(A<B<8>, 8> a)\\n\"\n               \"{\\n\"\n               \"  return a;\\n\"\n               \"}\\n\",\n               Style);\n\n  Style = getGNUStyle();\n\n  // Test for comments at the end of function declarations.\n  verifyFormat(\"void\\n\"\n               \"foo (int a, /*abc*/ int b) // def\\n\"\n               \"{\\n\"\n               \"}\\n\",\n               Style);\n\n  verifyFormat(\"void\\n\"\n               \"foo (int a, /* abc */ int b) /* def */\\n\"\n               \"{\\n\"\n               \"}\\n\",\n               Style);\n\n  // Definitions that should not break after return type\n  verifyFormat(\"void foo (int a, int b); // def\\n\", Style);\n  verifyFormat(\"void foo (int a, int b); /* def */\\n\", Style);\n  verifyFormat(\"void foo (int a, int b);\\n\", Style);\n}\n\nTEST_F(FormatTest, AlwaysBreakBeforeMultilineStrings) {\n  FormatStyle NoBreak = getLLVMStyle();\n  NoBreak.AlwaysBreakBeforeMultilineStrings = false;\n  FormatStyle Break = getLLVMStyle();\n  Break.AlwaysBreakBeforeMultilineStrings = true;\n  verifyFormat(\"aaaa = \\\"bbbb\\\"\\n\"\n               \"       \\\"cccc\\\";\",\n               NoBreak);\n  verifyFormat(\"aaaa =\\n\"\n               \"    \\\"bbbb\\\"\\n\"\n               \"    \\\"cccc\\\";\",\n               Break);\n  verifyFormat(\"aaaa(\\\"bbbb\\\"\\n\"\n               \"     \\\"cccc\\\");\",\n               NoBreak);\n  verifyFormat(\"aaaa(\\n\"\n               \"    \\\"bbbb\\\"\\n\"\n               \"    \\\"cccc\\\");\",\n               Break);\n  verifyFormat(\"aaaa(qqq, \\\"bbbb\\\"\\n\"\n               \"          \\\"cccc\\\");\",\n               NoBreak);\n  verifyFormat(\"aaaa(qqq,\\n\"\n               \"     \\\"bbbb\\\"\\n\"\n               \"     \\\"cccc\\\");\",\n               Break);\n  verifyFormat(\"aaaa(qqq,\\n\"\n               \"     L\\\"bbbb\\\"\\n\"\n               \"     L\\\"cccc\\\");\",\n               Break);\n  verifyFormat(\"aaaaa(aaaaaa, aaaaaaa(\\\"aaaa\\\"\\n\"\n               \"                      \\\"bbbb\\\"));\",\n               Break);\n  verifyFormat(\"string s = someFunction(\\n\"\n               \"    \\\"abc\\\"\\n\"\n               \"    \\\"abc\\\");\",\n               Break);\n\n  // As we break before unary operators, breaking right after them is bad.\n  verifyFormat(\"string foo = abc ? \\\"x\\\"\\n\"\n               \"                   \\\"blah blah blah blah blah blah\\\"\\n\"\n               \"                 : \\\"y\\\";\",\n               Break);\n\n  // Don't break if there is no column gain.\n  verifyFormat(\"f(\\\"aaaa\\\"\\n\"\n               \"  \\\"bbbb\\\");\",\n               Break);\n\n  // Treat literals with escaped newlines like multi-line string literals.\n  EXPECT_EQ(\"x = \\\"a\\\\\\n\"\n            \"b\\\\\\n\"\n            \"c\\\";\",\n            format(\"x = \\\"a\\\\\\n\"\n                   \"b\\\\\\n\"\n                   \"c\\\";\",\n                   NoBreak));\n  EXPECT_EQ(\"xxxx =\\n\"\n            \"    \\\"a\\\\\\n\"\n            \"b\\\\\\n\"\n            \"c\\\";\",\n            format(\"xxxx = \\\"a\\\\\\n\"\n                   \"b\\\\\\n\"\n                   \"c\\\";\",\n                   Break));\n\n  EXPECT_EQ(\"NSString *const kString =\\n\"\n            \"    @\\\"aaaa\\\"\\n\"\n            \"    @\\\"bbbb\\\";\",\n            format(\"NSString *const kString = @\\\"aaaa\\\"\\n\"\n                   \"@\\\"bbbb\\\";\",\n                   Break));\n\n  Break.ColumnLimit = 0;\n  verifyFormat(\"const char *hello = \\\"hello llvm\\\";\", Break);\n}\n\nTEST_F(FormatTest, AlignsPipes) {\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"    << aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"    << aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\");\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaa << aaaaaaaaaaaaaaaaaaaa << aaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                     << aaaaaaaaaaaaaaaaaaaa;\");\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa << aaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                                 << aaaaaaaaaaaaaaaaaaaaaaaaaaaa;\");\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()\\n\"\n      \"    << aaaaaaaaaaaaaaaaaaaaaaaaaaaa << aaaaaaaaaaaaaaaaaaaaaaaaaaaa;\");\n  verifyFormat(\n      \"llvm::outs() << \\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\"\\n\"\n      \"                \\\"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\\"\\n\"\n      \"             << \\\"ccccccccccccccccccccccccccccccccccccccccccccccccc\\\";\");\n  verifyFormat(\n      \"aaaaaaaa << (aaaaaaaaaaaaaaaaaaa << aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                                 << aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n      \"         << aaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\");\n  verifyFormat(\"llvm::errs() << aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"                    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"             << bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\");\n  verifyFormat(\"llvm::errs() << \\\"aaaaaaaaaaaaaaaaaaaaaaa: \\\"\\n\"\n               \"             << aaaaaaaaaaaaaaaaa(aaaaaaaa, aaaaaaaaaaa);\");\n  verifyFormat(\n      \"llvm::errs() << aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\n      \"auto Diag = diag() << aaaaaaaaaaaaaaaa(aaaaaaaaaaaa, aaaaaaaaaaaaa,\\n\"\n      \"                                       aaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n\n  verifyFormat(\"llvm::outs() << \\\"aaaaaaaaaaaaaaaa: \\\"\\n\"\n               \"             << aaaaaaaa.aaaaaaaaaaaa(aaa)->aaaaaaaaaaaaaa();\");\n  verifyFormat(\"llvm::errs() << aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"                    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                    aaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"             << aaaaaaaaaaaaaaaaaaaaaaaaaa;\");\n  verifyFormat(\"LOG_IF(aaa == //\\n\"\n               \"       bbb)\\n\"\n               \"    << a << b;\");\n\n  // But sometimes, breaking before the first \"<<\" is desirable.\n  verifyFormat(\"Diag(aaaaaaaaaaaaaaaaaaaa, aaaaaaaa)\\n\"\n               \"    << aaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaa);\");\n  verifyFormat(\"Diag(aaaaaaaaaaaaaaaaaaaaaaaaaaaaa, bbbbbbbbb)\\n\"\n               \"    << aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    << aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\");\n  verifyFormat(\"SemaRef.Diag(Loc, diag::note_for_range_begin_end)\\n\"\n               \"    << BEF << IsTemplate << Description << E->getType();\");\n  verifyFormat(\"Diag(aaaaaaaaaaaaaaaaaaaa, aaaaaaaa)\\n\"\n               \"    << aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"           aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\"Diag(aaaaaaaaaaaaaaaaaaaa, aaaaaaaa)\\n\"\n               \"    << aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"           aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"    << aaa;\");\n\n  verifyFormat(\n      \"llvm::errs() << aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"                    .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa();\");\n\n  // Incomplete string literal.\n  EXPECT_EQ(\"llvm::errs() << \\\"\\n\"\n            \"             << a;\",\n            format(\"llvm::errs() << \\\"\\n<<a;\"));\n\n  verifyFormat(\"void f() {\\n\"\n               \"  CHECK_EQ(aaaa, (*bbbbbbbbb)->cccccc)\\n\"\n               \"      << \\\"qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\\\";\\n\"\n               \"}\");\n\n  // Handle 'endl'.\n  verifyFormat(\"llvm::errs() << aaaaaaaaaaaaaaaaaaaaaa << endl\\n\"\n               \"             << bbbbbbbbbbbbbbbbbbbbbb << endl;\");\n  verifyFormat(\"llvm::errs() << endl << bbbbbbbbbbbbbbbbbbbbbb << endl;\");\n\n  // Handle '\\n'.\n  verifyFormat(\"llvm::errs() << aaaaaaaaaaaaaaaaaaaaaa << \\\"\\\\n\\\"\\n\"\n               \"             << bbbbbbbbbbbbbbbbbbbbbb << \\\"\\\\n\\\";\");\n  verifyFormat(\"llvm::errs() << aaaaaaaaaaaaaaaaaaaaaa << \\'\\\\n\\'\\n\"\n               \"             << bbbbbbbbbbbbbbbbbbbbbb << \\'\\\\n\\';\");\n  verifyFormat(\"llvm::errs() << aaaa << \\\"aaaaaaaaaaaaaaaaaa\\\\n\\\"\\n\"\n               \"             << bbbb << \\\"bbbbbbbbbbbbbbbbbb\\\\n\\\";\");\n  verifyFormat(\"llvm::errs() << \\\"\\\\n\\\" << bbbbbbbbbbbbbbbbbbbbbb << \\\"\\\\n\\\";\");\n}\n\nTEST_F(FormatTest, KeepStringLabelValuePairsOnALine) {\n  verifyFormat(\"return out << \\\"somepacket = {\\\\n\\\"\\n\"\n               \"           << \\\" aaaaaa = \\\" << pkt.aaaaaa << \\\"\\\\n\\\"\\n\"\n               \"           << \\\" bbbb = \\\" << pkt.bbbb << \\\"\\\\n\\\"\\n\"\n               \"           << \\\" cccccc = \\\" << pkt.cccccc << \\\"\\\\n\\\"\\n\"\n               \"           << \\\" ddd = [\\\" << pkt.ddd << \\\"]\\\\n\\\"\\n\"\n               \"           << \\\"}\\\";\");\n\n  verifyFormat(\"llvm::outs() << \\\"aaaaaaaaaaaaaaaa: \\\" << aaaaaaaaaaaaaaaa\\n\"\n               \"             << \\\"aaaaaaaaaaaaaaaa: \\\" << aaaaaaaaaaaaaaaa\\n\"\n               \"             << \\\"aaaaaaaaaaaaaaaa: \\\" << aaaaaaaaaaaaaaaa;\");\n  verifyFormat(\n      \"llvm::outs() << \\\"aaaaaaaaaaaaaaaaa = \\\" << aaaaaaaaaaaaaaaaa\\n\"\n      \"             << \\\"bbbbbbbbbbbbbbbbb = \\\" << bbbbbbbbbbbbbbbbb\\n\"\n      \"             << \\\"ccccccccccccccccc = \\\" << ccccccccccccccccc\\n\"\n      \"             << \\\"ddddddddddddddddd = \\\" << ddddddddddddddddd\\n\"\n      \"             << \\\"eeeeeeeeeeeeeeeee = \\\" << eeeeeeeeeeeeeeeee;\");\n  verifyFormat(\"llvm::outs() << aaaaaaaaaaaaaaaaaaaaaaaa << \\\"=\\\"\\n\"\n               \"             << bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\");\n  verifyFormat(\n      \"void f() {\\n\"\n      \"  llvm::outs() << \\\"aaaaaaaaaaaaaaaaaaaa: \\\"\\n\"\n      \"               << aaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaa);\\n\"\n      \"}\");\n\n  // Breaking before the first \"<<\" is generally not desirable.\n  verifyFormat(\n      \"llvm::errs()\\n\"\n      \"    << \\\"aaaaaaaaaaaaaaaaaaa: \\\" << aaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"    << \\\"aaaaaaaaaaaaaaaaaaa: \\\" << aaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"    << \\\"aaaaaaaaaaaaaaaaaaa: \\\" << aaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"    << \\\"aaaaaaaaaaaaaaaaaaa: \\\" << aaaaaaaaaaaaaaaaaaaaaaaaaaaa;\",\n      getLLVMStyleWithColumns(70));\n  verifyFormat(\"llvm::errs() << \\\"aaaaaaaaaaaaaaaaaaa: \\\"\\n\"\n               \"             << aaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"             << \\\"aaaaaaaaaaaaaaaaaaa: \\\"\\n\"\n               \"             << aaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"             << \\\"aaaaaaaaaaaaaaaaaaa: \\\"\\n\"\n               \"             << aaaaaaaaaaaaaaaaaaaaaaaaaaaa;\",\n               getLLVMStyleWithColumns(70));\n\n  verifyFormat(\"string v = \\\"aaaaaaaaaaaaaaaa: \\\" + aaaaaaaaaaaaaaaa +\\n\"\n               \"           \\\"aaaaaaaaaaaaaaaa: \\\" + aaaaaaaaaaaaaaaa +\\n\"\n               \"           \\\"aaaaaaaaaaaaaaaa: \\\" + aaaaaaaaaaaaaaaa;\");\n  verifyFormat(\"string v = StrCat(\\\"aaaaaaaaaaaaaaaa: \\\", aaaaaaaaaaaaaaaa,\\n\"\n               \"                  \\\"aaaaaaaaaaaaaaaa: \\\", aaaaaaaaaaaaaaaa,\\n\"\n               \"                  \\\"aaaaaaaaaaaaaaaa: \\\", aaaaaaaaaaaaaaaa);\");\n  verifyFormat(\"string v = \\\"aaaaaaaaaaaaaaaa: \\\" +\\n\"\n               \"           (aaaa + aaaa);\",\n               getLLVMStyleWithColumns(40));\n  verifyFormat(\"string v = StrCat(\\\"aaaaaaaaaaaa: \\\" +\\n\"\n               \"                  (aaaaaaa + aaaaa));\",\n               getLLVMStyleWithColumns(40));\n  verifyFormat(\n      \"string v = StrCat(\\\"aaaaaaaaaaaaaaaaaaaaaaaaaaa: \\\",\\n\"\n      \"                  SomeFunction(aaaaaaaaaaaa, aaaaaaaa.aaaaaaa),\\n\"\n      \"                  bbbbbbbbbbbbbbbbbbbbbbb);\");\n}\n\nTEST_F(FormatTest, UnderstandsEquals) {\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaa =\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\");\n  verifyFormat(\n      \"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa =\\n\"\n      \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {\\n}\");\n  verifyFormat(\n      \"if (a) {\\n\"\n      \"  f();\\n\"\n      \"} else if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa =\\n\"\n      \"               aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {\\n\"\n      \"}\");\n\n  verifyFormat(\"if (int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa =\\n\"\n               \"        100000000 + 10000000) {\\n}\");\n}\n\nTEST_F(FormatTest, WrapsAtFunctionCallsIfNecessary) {\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooongObject\\n\"\n               \"    .looooooooooooooooooooooooooooooooooooooongFunction();\");\n\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooongObject\\n\"\n               \"    ->looooooooooooooooooooooooooooooooooooooongFunction();\");\n\n  verifyFormat(\n      \"LooooooooooooooooooooooooooooooooongObject->shortFunction(Parameter1,\\n\"\n      \"                                                          Parameter2);\");\n\n  verifyFormat(\n      \"ShortObject->shortFunction(\\n\"\n      \"    LooooooooooooooooooooooooooooooooooooooooooooooongParameter1,\\n\"\n      \"    LooooooooooooooooooooooooooooooooooooooooooooooongParameter2);\");\n\n  verifyFormat(\"loooooooooooooongFunction(\\n\"\n               \"    LoooooooooooooongObject->looooooooooooooooongFunction());\");\n\n  verifyFormat(\n      \"function(LoooooooooooooooooooooooooooooooooooongObject\\n\"\n      \"             ->loooooooooooooooooooooooooooooooooooooooongFunction());\");\n\n  verifyFormat(\"EXPECT_CALL(SomeObject, SomeFunction(Parameter))\\n\"\n               \"    .WillRepeatedly(Return(SomeValue));\");\n  verifyFormat(\"void f() {\\n\"\n               \"  EXPECT_CALL(SomeObject, SomeFunction(Parameter))\\n\"\n               \"      .Times(2)\\n\"\n               \"      .WillRepeatedly(Return(SomeValue));\\n\"\n               \"}\");\n  verifyFormat(\"SomeMap[std::pair(aaaaaaaaaaaa, bbbbbbbbbbbbbbb)].insert(\\n\"\n               \"    ccccccccccccccccccccccc);\");\n  verifyFormat(\"aaaaa(aaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"          .aaaaa(aaaaa),\\n\"\n               \"      aaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\"void f() {\\n\"\n               \"  aaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"      aaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa)->aaaaaaaaa());\\n\"\n               \"}\");\n  verifyFormat(\"aaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"    .aaaaaaaaaaaaaaa(aa(aaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                        aaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                        aaaaaaaaaaaaaaaaaaaaaaaaaaa));\");\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"        .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"        .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"        .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()) {\\n\"\n               \"}\");\n\n  // Here, it is not necessary to wrap at \".\" or \"->\".\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaa) ||\\n\"\n               \"    aaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {\\n}\");\n  verifyFormat(\n      \"aaaaaaaaaaa->aaaaaaaaa(\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"    aaaaaaaaaaaaaaaaaa->aaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaa));\\n\");\n\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa().aaaaaaaaaaaaaaaaa());\");\n  verifyFormat(\"a->aaaaaa()->aaaaaaaaaaa(aaaaaaaa()->aaaaaa()->aaaaa() *\\n\"\n               \"                         aaaaaaaaa()->aaaaaa()->aaaaa());\");\n  verifyFormat(\"a->aaaaaa()->aaaaaaaaaaa(aaaaaaaa()->aaaaaa()->aaaaa() ||\\n\"\n               \"                         aaaaaaaaa()->aaaaaa()->aaaaa());\");\n\n  verifyFormat(\"aaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"    .a();\");\n\n  FormatStyle NoBinPacking = getLLVMStyle();\n  NoBinPacking.BinPackParameters = false;\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"    .aaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"    .aaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                         aaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                         aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\",\n               NoBinPacking);\n\n  // If there is a subsequent call, change to hanging indentation.\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"                         aaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaa))\\n\"\n      \"    .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa();\");\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"    aaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaa));\");\n  verifyFormat(\"aaaaaaaaaa = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"                 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"                 .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa();\");\n  verifyFormat(\"aaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"               aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"               .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa());\");\n}\n\nTEST_F(FormatTest, WrapsTemplateDeclarations) {\n  verifyFormat(\"template <typename T>\\n\"\n               \"virtual void loooooooooooongFunction(int Param1, int Param2);\");\n  verifyFormat(\"template <typename T>\\n\"\n               \"// T should be one of {A, B}.\\n\"\n               \"virtual void loooooooooooongFunction(int Param1, int Param2);\");\n  verifyFormat(\n      \"template <typename T>\\n\"\n      \"using comment_to_xml_conversion = comment_to_xml_conversion<T, int>;\");\n  verifyFormat(\"template <typename T>\\n\"\n               \"void f(int Paaaaaaaaaaaaaaaaaaaaaaaaaaaaaaram1,\\n\"\n               \"       int Paaaaaaaaaaaaaaaaaaaaaaaaaaaaaaram2);\");\n  verifyFormat(\n      \"template <typename T>\\n\"\n      \"void looooooooooooooooooooongFunction(int Paaaaaaaaaaaaaaaaaaaaram1,\\n\"\n      \"                                      int Paaaaaaaaaaaaaaaaaaaaram2);\");\n  verifyFormat(\n      \"template <typename T>\\n\"\n      \"aaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaa,\\n\"\n      \"                    aaaaaaaaaaaaaaaaaaaaaaaaaa<T>::aaaaaaaaaa,\\n\"\n      \"                    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\"template <typename T>\\n\"\n               \"void aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"    int aaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\n      \"template <typename T1, typename T2 = char, typename T3 = char,\\n\"\n      \"          typename T4 = char>\\n\"\n      \"void f();\");\n  verifyFormat(\"template <typename aaaaaaaaaaa, typename bbbbbbbbbbbbb,\\n\"\n               \"          template <typename> class cccccccccccccccccccccc,\\n\"\n               \"          typename ddddddddddddd>\\n\"\n               \"class C {};\");\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaa<aaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaa>(\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n\n  verifyFormat(\"void f() {\\n\"\n               \"  a<aaaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaa>(\\n\"\n               \"      a(aaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaa));\\n\"\n               \"}\");\n\n  verifyFormat(\"template <typename T> class C {};\");\n  verifyFormat(\"template <typename T> void f();\");\n  verifyFormat(\"template <typename T> void f() {}\");\n  verifyFormat(\n      \"aaaaaaaaaaaaa<aaaaaaaaaa, aaaaaaaaaaa,\\n\"\n      \"              aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"              aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa> *aaaa =\\n\"\n      \"    new aaaaaaaaaaaaa<aaaaaaaaaa, aaaaaaaaaaa,\\n\"\n      \"                      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"                      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa>(\\n\"\n      \"        bbbbbbbbbbbbbbbbbbbbbbbb);\",\n      getLLVMStyleWithColumns(72));\n  EXPECT_EQ(\"static_cast<A< //\\n\"\n            \"    B> *>(\\n\"\n            \"\\n\"\n            \");\",\n            format(\"static_cast<A<//\\n\"\n                   \"    B>*>(\\n\"\n                   \"\\n\"\n                   \"    );\"));\n  verifyFormat(\"int aaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"    const typename aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaa);\");\n\n  FormatStyle AlwaysBreak = getLLVMStyle();\n  AlwaysBreak.AlwaysBreakTemplateDeclarations = FormatStyle::BTDS_Yes;\n  verifyFormat(\"template <typename T>\\nclass C {};\", AlwaysBreak);\n  verifyFormat(\"template <typename T>\\nvoid f();\", AlwaysBreak);\n  verifyFormat(\"template <typename T>\\nvoid f() {}\", AlwaysBreak);\n  verifyFormat(\"void aaaaaaaaaaaaaaaaaaa<aaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                         bbbbbbbbbbbbbbbbbbbbbbbbbbbb>(\\n\"\n               \"    ccccccccccccccccccccccccccccccccccccccccccccccc);\");\n  verifyFormat(\"template <template <typename> class Fooooooo,\\n\"\n               \"          template <typename> class Baaaaaaar>\\n\"\n               \"struct C {};\",\n               AlwaysBreak);\n  verifyFormat(\"template <typename T> // T can be A, B or C.\\n\"\n               \"struct C {};\",\n               AlwaysBreak);\n  verifyFormat(\"template <enum E> class A {\\n\"\n               \"public:\\n\"\n               \"  E *f();\\n\"\n               \"};\");\n\n  FormatStyle NeverBreak = getLLVMStyle();\n  NeverBreak.AlwaysBreakTemplateDeclarations = FormatStyle::BTDS_No;\n  verifyFormat(\"template <typename T> class C {};\", NeverBreak);\n  verifyFormat(\"template <typename T> void f();\", NeverBreak);\n  verifyFormat(\"template <typename T> void f() {}\", NeverBreak);\n  verifyFormat(\"template <typename T>\\nvoid foo(aaaaaaaaaaaaaaaaaaaaaaaaaa \"\n               \"bbbbbbbbbbbbbbbbbbbb) {}\",\n               NeverBreak);\n  verifyFormat(\"void aaaaaaaaaaaaaaaaaaa<aaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                         bbbbbbbbbbbbbbbbbbbbbbbbbbbb>(\\n\"\n               \"    ccccccccccccccccccccccccccccccccccccccccccccccc);\",\n               NeverBreak);\n  verifyFormat(\"template <template <typename> class Fooooooo,\\n\"\n               \"          template <typename> class Baaaaaaar>\\n\"\n               \"struct C {};\",\n               NeverBreak);\n  verifyFormat(\"template <typename T> // T can be A, B or C.\\n\"\n               \"struct C {};\",\n               NeverBreak);\n  verifyFormat(\"template <enum E> class A {\\n\"\n               \"public:\\n\"\n               \"  E *f();\\n\"\n               \"};\",\n               NeverBreak);\n  NeverBreak.PenaltyBreakTemplateDeclaration = 100;\n  verifyFormat(\"template <typename T> void\\nfoo(aaaaaaaaaaaaaaaaaaaaaaaaaa \"\n               \"bbbbbbbbbbbbbbbbbbbb) {}\",\n               NeverBreak);\n}\n\nTEST_F(FormatTest, WrapsTemplateDeclarationsWithComments) {\n  FormatStyle Style = getGoogleStyle(FormatStyle::LK_Cpp);\n  Style.ColumnLimit = 60;\n  EXPECT_EQ(\"// Baseline - no comments.\\n\"\n            \"template <\\n\"\n            \"    typename aaaaaaaaaaaaaaaaaaaaaa<bbbbbbbbbbbb>::value>\\n\"\n            \"void f() {}\",\n            format(\"// Baseline - no comments.\\n\"\n                   \"template <\\n\"\n                   \"    typename aaaaaaaaaaaaaaaaaaaaaa<bbbbbbbbbbbb>::value>\\n\"\n                   \"void f() {}\",\n                   Style));\n\n  EXPECT_EQ(\"template <\\n\"\n            \"    typename aaaaaaaaaa<bbbbbbbbbbbb>::value>  // trailing\\n\"\n            \"void f() {}\",\n            format(\"template <\\n\"\n                   \"    typename aaaaaaaaaa<bbbbbbbbbbbb>::value> // trailing\\n\"\n                   \"void f() {}\",\n                   Style));\n\n  EXPECT_EQ(\n      \"template <\\n\"\n      \"    typename aaaaaaaaaa<bbbbbbbbbbbb>::value> /* line */\\n\"\n      \"void f() {}\",\n      format(\"template <typename aaaaaaaaaa<bbbbbbbbbbbb>::value>  /* line */\\n\"\n             \"void f() {}\",\n             Style));\n\n  EXPECT_EQ(\n      \"template <\\n\"\n      \"    typename aaaaaaaaaa<bbbbbbbbbbbb>::value>  // trailing\\n\"\n      \"                                               // multiline\\n\"\n      \"void f() {}\",\n      format(\"template <\\n\"\n             \"    typename aaaaaaaaaa<bbbbbbbbbbbb>::value> // trailing\\n\"\n             \"                                              // multiline\\n\"\n             \"void f() {}\",\n             Style));\n\n  EXPECT_EQ(\n      \"template <typename aaaaaaaaaa<\\n\"\n      \"    bbbbbbbbbbbb>::value>  // trailing loooong\\n\"\n      \"void f() {}\",\n      format(\n          \"template <\\n\"\n          \"    typename aaaaaaaaaa<bbbbbbbbbbbb>::value> // trailing loooong\\n\"\n          \"void f() {}\",\n          Style));\n}\n\nTEST_F(FormatTest, WrapsTemplateParameters) {\n  FormatStyle Style = getLLVMStyle();\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_DontAlign;\n  Style.BreakBeforeBinaryOperators = FormatStyle::BOS_None;\n  verifyFormat(\n      \"template <typename... a> struct q {};\\n\"\n      \"extern q<aaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaa,\\n\"\n      \"    aaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaa>\\n\"\n      \"    y;\",\n      Style);\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_DontAlign;\n  Style.BreakBeforeBinaryOperators = FormatStyle::BOS_All;\n  verifyFormat(\n      \"template <typename... a> struct r {};\\n\"\n      \"extern r<aaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaa,\\n\"\n      \"    aaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaa>\\n\"\n      \"    y;\",\n      Style);\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_AlwaysBreak;\n  Style.BreakBeforeBinaryOperators = FormatStyle::BOS_None;\n  verifyFormat(\"template <typename... a> struct s {};\\n\"\n               \"extern s<\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaaaa, \"\n               \"aaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaaaa, \"\n               \"aaaaaaaaaaaaaaaaaaaaaa>\\n\"\n               \"    y;\",\n               Style);\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_AlwaysBreak;\n  Style.BreakBeforeBinaryOperators = FormatStyle::BOS_All;\n  verifyFormat(\"template <typename... a> struct t {};\\n\"\n               \"extern t<\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaaaa, \"\n               \"aaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaaaa, \"\n               \"aaaaaaaaaaaaaaaaaaaaaa>\\n\"\n               \"    y;\",\n               Style);\n}\n\nTEST_F(FormatTest, WrapsAtNestedNameSpecifiers) {\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa::\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa();\");\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa::\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa());\");\n\n  // FIXME: Should we have the extra indent after the second break?\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa::\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa::\\n\"\n      \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa();\");\n\n  verifyFormat(\n      \"aaaaaaaaaaaaaaa(bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb::\\n\"\n      \"                    cccccccccccccccccccccccccccccccccccccccccccccc());\");\n\n  // Breaking at nested name specifiers is generally not desirable.\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa::aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaa);\");\n\n  verifyFormat(\"aaaaaaaaaaaaaaaaaa(aaaaaaaa,\\n\"\n               \"                   aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa::\\n\"\n               \"                       aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                   aaaaaaaaaaaaaaaaaaaaa);\",\n               getLLVMStyleWithColumns(74));\n\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa::\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"        .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa();\");\n}\n\nTEST_F(FormatTest, UnderstandsTemplateParameters) {\n  verifyFormat(\"A<int> a;\");\n  verifyFormat(\"A<A<A<int>>> a;\");\n  verifyFormat(\"A<A<A<int, 2>, 3>, 4> a;\");\n  verifyFormat(\"bool x = a < 1 || 2 > a;\");\n  verifyFormat(\"bool x = 5 < f<int>();\");\n  verifyFormat(\"bool x = f<int>() > 5;\");\n  verifyFormat(\"bool x = 5 < a<int>::x;\");\n  verifyFormat(\"bool x = a < 4 ? a > 2 : false;\");\n  verifyFormat(\"bool x = f() ? a < 2 : a > 2;\");\n\n  verifyGoogleFormat(\"A<A<int>> a;\");\n  verifyGoogleFormat(\"A<A<A<int>>> a;\");\n  verifyGoogleFormat(\"A<A<A<A<int>>>> a;\");\n  verifyGoogleFormat(\"A<A<int> > a;\");\n  verifyGoogleFormat(\"A<A<A<int> > > a;\");\n  verifyGoogleFormat(\"A<A<A<A<int> > > > a;\");\n  verifyGoogleFormat(\"A<::A<int>> a;\");\n  verifyGoogleFormat(\"A<::A> a;\");\n  verifyGoogleFormat(\"A< ::A> a;\");\n  verifyGoogleFormat(\"A< ::A<int> > a;\");\n  EXPECT_EQ(\"A<A<A<A>>> a;\", format(\"A<A<A<A> >> a;\", getGoogleStyle()));\n  EXPECT_EQ(\"A<A<A<A>>> a;\", format(\"A<A<A<A>> > a;\", getGoogleStyle()));\n  EXPECT_EQ(\"A<::A<int>> a;\", format(\"A< ::A<int>> a;\", getGoogleStyle()));\n  EXPECT_EQ(\"A<::A<int>> a;\", format(\"A<::A<int> > a;\", getGoogleStyle()));\n  EXPECT_EQ(\"auto x = [] { A<A<A<A>>> a; };\",\n            format(\"auto x=[]{A<A<A<A> >> a;};\", getGoogleStyle()));\n\n  verifyFormat(\"A<A<int>> a;\", getChromiumStyle(FormatStyle::LK_Cpp));\n\n  // template closer followed by a token that starts with > or =\n  verifyFormat(\"bool b = a<1> > 1;\");\n  verifyFormat(\"bool b = a<1> >= 1;\");\n  verifyFormat(\"int i = a<1> >> 1;\");\n  FormatStyle Style = getLLVMStyle();\n  Style.SpaceBeforeAssignmentOperators = false;\n  verifyFormat(\"bool b= a<1> == 1;\", Style);\n  verifyFormat(\"a<int> = 1;\", Style);\n  verifyFormat(\"a<int> >>= 1;\", Style);\n\n  verifyFormat(\"test >> a >> b;\");\n  verifyFormat(\"test << a >> b;\");\n\n  verifyFormat(\"f<int>();\");\n  verifyFormat(\"template <typename T> void f() {}\");\n  verifyFormat(\"struct A<std::enable_if<sizeof(T2) < sizeof(int32)>::type>;\");\n  verifyFormat(\"struct A<std::enable_if<sizeof(T2) ? sizeof(int32) : \"\n               \"sizeof(char)>::type>;\");\n  verifyFormat(\"template <class T> struct S<std::is_arithmetic<T>{}> {};\");\n  verifyFormat(\"f(a.operator()<A>());\");\n  verifyFormat(\"f(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"      .template operator()<A>());\",\n               getLLVMStyleWithColumns(35));\n\n  // Not template parameters.\n  verifyFormat(\"return a < b && c > d;\");\n  verifyFormat(\"void f() {\\n\"\n               \"  while (a < b && c > d) {\\n\"\n               \"  }\\n\"\n               \"}\");\n  verifyFormat(\"template <typename... Types>\\n\"\n               \"typename enable_if<0 < sizeof...(Types)>::type Foo() {}\");\n\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaa >> aaaaa);\",\n               getLLVMStyleWithColumns(60));\n  verifyFormat(\"static_assert(is_convertible<A &&, B>::value, \\\"AAA\\\");\");\n  verifyFormat(\"Constructor(A... a) : a_(X<A>{std::forward<A>(a)}...) {}\");\n  verifyFormat(\"< < < < < < < < < < < < < < < < < < < < < < < < < < < < < <\");\n  verifyFormat(\"some_templated_type<decltype([](int i) { return i; })>\");\n}\n\nTEST_F(FormatTest, UnderstandsShiftOperators) {\n  verifyFormat(\"if (i < x >> 1)\");\n  verifyFormat(\"while (i < x >> 1)\");\n  verifyFormat(\"for (unsigned i = 0; i < i; ++i, v = v >> 1)\");\n  verifyFormat(\"for (unsigned i = 0; i < x >> 1; ++i, v = v >> 1)\");\n  verifyFormat(\n      \"for (std::vector<int>::iterator i = 0; i < x >> 1; ++i, v = v >> 1)\");\n  verifyFormat(\"Foo.call<Bar<Function>>()\");\n  verifyFormat(\"if (Foo.call<Bar<Function>>() == 0)\");\n  verifyFormat(\"for (std::vector<std::pair<int>>::iterator i = 0; i < x >> 1; \"\n               \"++i, v = v >> 1)\");\n  verifyFormat(\"if (w<u<v<x>>, 1>::t)\");\n}\n\nTEST_F(FormatTest, BitshiftOperatorWidth) {\n  EXPECT_EQ(\"int a = 1 << 2; /* foo\\n\"\n            \"                   bar */\",\n            format(\"int    a=1<<2;  /* foo\\n\"\n                   \"                   bar */\"));\n\n  EXPECT_EQ(\"int b = 256 >> 1; /* foo\\n\"\n            \"                     bar */\",\n            format(\"int  b  =256>>1 ;  /* foo\\n\"\n                   \"                      bar */\"));\n}\n\nTEST_F(FormatTest, UnderstandsBinaryOperators) {\n  verifyFormat(\"COMPARE(a, ==, b);\");\n  verifyFormat(\"auto s = sizeof...(Ts) - 1;\");\n}\n\nTEST_F(FormatTest, UnderstandsPointersToMembers) {\n  verifyFormat(\"int A::*x;\");\n  verifyFormat(\"int (S::*func)(void *);\");\n  verifyFormat(\"void f() { int (S::*func)(void *); }\");\n  verifyFormat(\"typedef bool *(Class::*Member)() const;\");\n  verifyFormat(\"void f() {\\n\"\n               \"  (a->*f)();\\n\"\n               \"  a->*x;\\n\"\n               \"  (a.*f)();\\n\"\n               \"  ((*a).*f)();\\n\"\n               \"  a.*x;\\n\"\n               \"}\");\n  verifyFormat(\"void f() {\\n\"\n               \"  (a->*aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)(\\n\"\n               \"      aaaa, bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);\\n\"\n               \"}\");\n  verifyFormat(\n      \"(aaaaaaaaaa->*bbbbbbb)(\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaa));\");\n  FormatStyle Style = getLLVMStyle();\n  Style.PointerAlignment = FormatStyle::PAS_Left;\n  verifyFormat(\"typedef bool* (Class::*Member)() const;\", Style);\n}\n\nTEST_F(FormatTest, UnderstandsUnaryOperators) {\n  verifyFormat(\"int a = -2;\");\n  verifyFormat(\"f(-1, -2, -3);\");\n  verifyFormat(\"a[-1] = 5;\");\n  verifyFormat(\"int a = 5 + -2;\");\n  verifyFormat(\"if (i == -1) {\\n}\");\n  verifyFormat(\"if (i != -1) {\\n}\");\n  verifyFormat(\"if (i > -1) {\\n}\");\n  verifyFormat(\"if (i < -1) {\\n}\");\n  verifyFormat(\"++(a->f());\");\n  verifyFormat(\"--(a->f());\");\n  verifyFormat(\"(a->f())++;\");\n  verifyFormat(\"a[42]++;\");\n  verifyFormat(\"if (!(a->f())) {\\n}\");\n  verifyFormat(\"if (!+i) {\\n}\");\n  verifyFormat(\"~&a;\");\n\n  verifyFormat(\"a-- > b;\");\n  verifyFormat(\"b ? -a : c;\");\n  verifyFormat(\"n * sizeof char16;\");\n  verifyFormat(\"n * alignof char16;\", getGoogleStyle());\n  verifyFormat(\"sizeof(char);\");\n  verifyFormat(\"alignof(char);\", getGoogleStyle());\n\n  verifyFormat(\"return -1;\");\n  verifyFormat(\"throw -1;\");\n  verifyFormat(\"switch (a) {\\n\"\n               \"case -1:\\n\"\n               \"  break;\\n\"\n               \"}\");\n  verifyFormat(\"#define X -1\");\n  verifyFormat(\"#define X -kConstant\");\n\n  verifyFormat(\"const NSPoint kBrowserFrameViewPatternOffset = {-5, +3};\");\n  verifyFormat(\"const NSPoint kBrowserFrameViewPatternOffset = {+5, -3};\");\n\n  verifyFormat(\"int a = /* confusing comment */ -1;\");\n  // FIXME: The space after 'i' is wrong, but hopefully, this is a rare case.\n  verifyFormat(\"int a = i /* confusing comment */++;\");\n\n  verifyFormat(\"co_yield -1;\");\n  verifyFormat(\"co_return -1;\");\n\n  // Check that * is not treated as a binary operator when we set\n  // PointerAlignment as PAS_Left after a keyword and not a declaration.\n  FormatStyle PASLeftStyle = getLLVMStyle();\n  PASLeftStyle.PointerAlignment = FormatStyle::PAS_Left;\n  verifyFormat(\"co_return *a;\", PASLeftStyle);\n  verifyFormat(\"co_await *a;\", PASLeftStyle);\n  verifyFormat(\"co_yield *a\", PASLeftStyle);\n  verifyFormat(\"return *a;\", PASLeftStyle);\n}\n\nTEST_F(FormatTest, DoesNotIndentRelativeToUnaryOperators) {\n  verifyFormat(\"if (!aaaaaaaaaa( // break\\n\"\n               \"        aaaaa)) {\\n\"\n               \"}\");\n  verifyFormat(\"aaaaaaaaaa(!aaaaaaaaaa( // break\\n\"\n               \"    aaaaa));\");\n  verifyFormat(\"*aaa = aaaaaaa( // break\\n\"\n               \"    bbbbbb);\");\n}\n\nTEST_F(FormatTest, UnderstandsOverloadedOperators) {\n  verifyFormat(\"bool operator<();\");\n  verifyFormat(\"bool operator>();\");\n  verifyFormat(\"bool operator=();\");\n  verifyFormat(\"bool operator==();\");\n  verifyFormat(\"bool operator!=();\");\n  verifyFormat(\"int operator+();\");\n  verifyFormat(\"int operator++();\");\n  verifyFormat(\"int operator++(int) volatile noexcept;\");\n  verifyFormat(\"bool operator,();\");\n  verifyFormat(\"bool operator();\");\n  verifyFormat(\"bool operator()();\");\n  verifyFormat(\"bool operator[]();\");\n  verifyFormat(\"operator bool();\");\n  verifyFormat(\"operator int();\");\n  verifyFormat(\"operator void *();\");\n  verifyFormat(\"operator SomeType<int>();\");\n  verifyFormat(\"operator SomeType<int, int>();\");\n  verifyFormat(\"operator SomeType<SomeType<int>>();\");\n  verifyFormat(\"void *operator new(std::size_t size);\");\n  verifyFormat(\"void *operator new[](std::size_t size);\");\n  verifyFormat(\"void operator delete(void *ptr);\");\n  verifyFormat(\"void operator delete[](void *ptr);\");\n  verifyFormat(\"template <typename AAAAAAA, typename BBBBBBB>\\n\"\n               \"AAAAAAA operator/(const AAAAAAA &a, BBBBBBB &b);\");\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaa operator,(\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaa &aaaaaaaaaaaaaaaaaaaaaaaaaa) const;\");\n\n  verifyFormat(\n      \"ostream &operator<<(ostream &OutputStream,\\n\"\n      \"                    SomeReallyLongType WithSomeReallyLongValue);\");\n  verifyFormat(\"bool operator<(const aaaaaaaaaaaaaaaaaaaaa &left,\\n\"\n               \"               const aaaaaaaaaaaaaaaaaaaaa &right) {\\n\"\n               \"  return left.group < right.group;\\n\"\n               \"}\");\n  verifyFormat(\"SomeType &operator=(const SomeType &S);\");\n  verifyFormat(\"f.template operator()<int>();\");\n\n  verifyGoogleFormat(\"operator void*();\");\n  verifyGoogleFormat(\"operator SomeType<SomeType<int>>();\");\n  verifyGoogleFormat(\"operator ::A();\");\n\n  verifyFormat(\"using A::operator+;\");\n  verifyFormat(\"inline A operator^(const A &lhs, const A &rhs) {}\\n\"\n               \"int i;\");\n}\n\nTEST_F(FormatTest, UnderstandsFunctionRefQualification) {\n  verifyFormat(\"Deleted &operator=(const Deleted &) & = default;\");\n  verifyFormat(\"Deleted &operator=(const Deleted &) && = delete;\");\n  verifyFormat(\"SomeType MemberFunction(const Deleted &) & = delete;\");\n  verifyFormat(\"SomeType MemberFunction(const Deleted &) && = delete;\");\n  verifyFormat(\"Deleted &operator=(const Deleted &) &;\");\n  verifyFormat(\"Deleted &operator=(const Deleted &) &&;\");\n  verifyFormat(\"SomeType MemberFunction(const Deleted &) &;\");\n  verifyFormat(\"SomeType MemberFunction(const Deleted &) &&;\");\n  verifyFormat(\"SomeType MemberFunction(const Deleted &) && {}\");\n  verifyFormat(\"SomeType MemberFunction(const Deleted &) && final {}\");\n  verifyFormat(\"SomeType MemberFunction(const Deleted &) && override {}\");\n  verifyFormat(\"void Fn(T const &) const &;\");\n  verifyFormat(\"void Fn(T const volatile &&) const volatile &&;\");\n  verifyFormat(\"template <typename T>\\n\"\n               \"void F(T) && = delete;\",\n               getGoogleStyle());\n\n  FormatStyle AlignLeft = getLLVMStyle();\n  AlignLeft.PointerAlignment = FormatStyle::PAS_Left;\n  verifyFormat(\"void A::b() && {}\", AlignLeft);\n  verifyFormat(\"Deleted& operator=(const Deleted&) & = default;\", AlignLeft);\n  verifyFormat(\"SomeType MemberFunction(const Deleted&) & = delete;\",\n               AlignLeft);\n  verifyFormat(\"Deleted& operator=(const Deleted&) &;\", AlignLeft);\n  verifyFormat(\"SomeType MemberFunction(const Deleted&) &;\", AlignLeft);\n  verifyFormat(\"auto Function(T t) & -> void {}\", AlignLeft);\n  verifyFormat(\"auto Function(T... t) & -> void {}\", AlignLeft);\n  verifyFormat(\"auto Function(T) & -> void {}\", AlignLeft);\n  verifyFormat(\"auto Function(T) & -> void;\", AlignLeft);\n  verifyFormat(\"void Fn(T const&) const&;\", AlignLeft);\n  verifyFormat(\"void Fn(T const volatile&&) const volatile&&;\", AlignLeft);\n\n  FormatStyle Spaces = getLLVMStyle();\n  Spaces.SpacesInCStyleCastParentheses = true;\n  verifyFormat(\"Deleted &operator=(const Deleted &) & = default;\", Spaces);\n  verifyFormat(\"SomeType MemberFunction(const Deleted &) & = delete;\", Spaces);\n  verifyFormat(\"Deleted &operator=(const Deleted &) &;\", Spaces);\n  verifyFormat(\"SomeType MemberFunction(const Deleted &) &;\", Spaces);\n\n  Spaces.SpacesInCStyleCastParentheses = false;\n  Spaces.SpacesInParentheses = true;\n  verifyFormat(\"Deleted &operator=( const Deleted & ) & = default;\", Spaces);\n  verifyFormat(\"SomeType MemberFunction( const Deleted & ) & = delete;\",\n               Spaces);\n  verifyFormat(\"Deleted &operator=( const Deleted & ) &;\", Spaces);\n  verifyFormat(\"SomeType MemberFunction( const Deleted & ) &;\", Spaces);\n\n  FormatStyle BreakTemplate = getLLVMStyle();\n  BreakTemplate.AlwaysBreakTemplateDeclarations = FormatStyle::BTDS_Yes;\n\n  verifyFormat(\"struct f {\\n\"\n               \"  template <class T>\\n\"\n               \"  int &foo(const std::string &str) &noexcept {}\\n\"\n               \"};\",\n               BreakTemplate);\n\n  verifyFormat(\"struct f {\\n\"\n               \"  template <class T>\\n\"\n               \"  int &foo(const std::string &str) &&noexcept {}\\n\"\n               \"};\",\n               BreakTemplate);\n\n  verifyFormat(\"struct f {\\n\"\n               \"  template <class T>\\n\"\n               \"  int &foo(const std::string &str) const &noexcept {}\\n\"\n               \"};\",\n               BreakTemplate);\n\n  verifyFormat(\"struct f {\\n\"\n               \"  template <class T>\\n\"\n               \"  int &foo(const std::string &str) const &noexcept {}\\n\"\n               \"};\",\n               BreakTemplate);\n\n  verifyFormat(\"struct f {\\n\"\n               \"  template <class T>\\n\"\n               \"  auto foo(const std::string &str) &&noexcept -> int & {}\\n\"\n               \"};\",\n               BreakTemplate);\n\n  FormatStyle AlignLeftBreakTemplate = getLLVMStyle();\n  AlignLeftBreakTemplate.AlwaysBreakTemplateDeclarations =\n      FormatStyle::BTDS_Yes;\n  AlignLeftBreakTemplate.PointerAlignment = FormatStyle::PAS_Left;\n\n  verifyFormat(\"struct f {\\n\"\n               \"  template <class T>\\n\"\n               \"  int& foo(const std::string& str) & noexcept {}\\n\"\n               \"};\",\n               AlignLeftBreakTemplate);\n\n  verifyFormat(\"struct f {\\n\"\n               \"  template <class T>\\n\"\n               \"  int& foo(const std::string& str) && noexcept {}\\n\"\n               \"};\",\n               AlignLeftBreakTemplate);\n\n  verifyFormat(\"struct f {\\n\"\n               \"  template <class T>\\n\"\n               \"  int& foo(const std::string& str) const& noexcept {}\\n\"\n               \"};\",\n               AlignLeftBreakTemplate);\n\n  verifyFormat(\"struct f {\\n\"\n               \"  template <class T>\\n\"\n               \"  int& foo(const std::string& str) const&& noexcept {}\\n\"\n               \"};\",\n               AlignLeftBreakTemplate);\n\n  verifyFormat(\"struct f {\\n\"\n               \"  template <class T>\\n\"\n               \"  auto foo(const std::string& str) && noexcept -> int& {}\\n\"\n               \"};\",\n               AlignLeftBreakTemplate);\n\n  // The `&` in `Type&` should not be confused with a trailing `&` of\n  // DEPRECATED(reason) member function.\n  verifyFormat(\"struct f {\\n\"\n               \"  template <class T>\\n\"\n               \"  DEPRECATED(reason)\\n\"\n               \"  Type &foo(arguments) {}\\n\"\n               \"};\",\n               BreakTemplate);\n\n  verifyFormat(\"struct f {\\n\"\n               \"  template <class T>\\n\"\n               \"  DEPRECATED(reason)\\n\"\n               \"  Type& foo(arguments) {}\\n\"\n               \"};\",\n               AlignLeftBreakTemplate);\n\n  verifyFormat(\"void (*foopt)(int) = &func;\");\n}\n\nTEST_F(FormatTest, UnderstandsNewAndDelete) {\n  verifyFormat(\"void f() {\\n\"\n               \"  A *a = new A;\\n\"\n               \"  A *a = new (placement) A;\\n\"\n               \"  delete a;\\n\"\n               \"  delete (A *)a;\\n\"\n               \"}\");\n  verifyFormat(\"new (aaaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaa))\\n\"\n               \"    typename aaaaaaaaaaaaaaaaaaaaaaaa();\");\n  verifyFormat(\"auto aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa =\\n\"\n               \"    new (aaaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaa))\\n\"\n               \"        typename aaaaaaaaaaaaaaaaaaaaaaaa();\");\n  verifyFormat(\"delete[] h->p;\");\n}\n\nTEST_F(FormatTest, UnderstandsUsesOfStarAndAmp) {\n  verifyFormat(\"int *f(int *a) {}\");\n  verifyFormat(\"int main(int argc, char **argv) {}\");\n  verifyFormat(\"Test::Test(int b) : a(b * b) {}\");\n  verifyIndependentOfContext(\"f(a, *a);\");\n  verifyFormat(\"void g() { f(*a); }\");\n  verifyIndependentOfContext(\"int a = b * 10;\");\n  verifyIndependentOfContext(\"int a = 10 * b;\");\n  verifyIndependentOfContext(\"int a = b * c;\");\n  verifyIndependentOfContext(\"int a += b * c;\");\n  verifyIndependentOfContext(\"int a -= b * c;\");\n  verifyIndependentOfContext(\"int a *= b * c;\");\n  verifyIndependentOfContext(\"int a /= b * c;\");\n  verifyIndependentOfContext(\"int a = *b;\");\n  verifyIndependentOfContext(\"int a = *b * c;\");\n  verifyIndependentOfContext(\"int a = b * *c;\");\n  verifyIndependentOfContext(\"int a = b * (10);\");\n  verifyIndependentOfContext(\"S << b * (10);\");\n  verifyIndependentOfContext(\"return 10 * b;\");\n  verifyIndependentOfContext(\"return *b * *c;\");\n  verifyIndependentOfContext(\"return a & ~b;\");\n  verifyIndependentOfContext(\"f(b ? *c : *d);\");\n  verifyIndependentOfContext(\"int a = b ? *c : *d;\");\n  verifyIndependentOfContext(\"*b = a;\");\n  verifyIndependentOfContext(\"a * ~b;\");\n  verifyIndependentOfContext(\"a * !b;\");\n  verifyIndependentOfContext(\"a * +b;\");\n  verifyIndependentOfContext(\"a * -b;\");\n  verifyIndependentOfContext(\"a * ++b;\");\n  verifyIndependentOfContext(\"a * --b;\");\n  verifyIndependentOfContext(\"a[4] * b;\");\n  verifyIndependentOfContext(\"a[a * a] = 1;\");\n  verifyIndependentOfContext(\"f() * b;\");\n  verifyIndependentOfContext(\"a * [self dostuff];\");\n  verifyIndependentOfContext(\"int x = a * (a + b);\");\n  verifyIndependentOfContext(\"(a *)(a + b);\");\n  verifyIndependentOfContext(\"*(int *)(p & ~3UL) = 0;\");\n  verifyIndependentOfContext(\"int *pa = (int *)&a;\");\n  verifyIndependentOfContext(\"return sizeof(int **);\");\n  verifyIndependentOfContext(\"return sizeof(int ******);\");\n  verifyIndependentOfContext(\"return (int **&)a;\");\n  verifyIndependentOfContext(\"f((*PointerToArray)[10]);\");\n  verifyFormat(\"void f(Type (*parameter)[10]) {}\");\n  verifyFormat(\"void f(Type (&parameter)[10]) {}\");\n  verifyGoogleFormat(\"return sizeof(int**);\");\n  verifyIndependentOfContext(\"Type **A = static_cast<Type **>(P);\");\n  verifyGoogleFormat(\"Type** A = static_cast<Type**>(P);\");\n  verifyFormat(\"auto a = [](int **&, int ***) {};\");\n  verifyFormat(\"auto PointerBinding = [](const char *S) {};\");\n  verifyFormat(\"typedef typeof(int(int, int)) *MyFunc;\");\n  verifyFormat(\"[](const decltype(*a) &value) {}\");\n  verifyFormat(\"[](const typeof(*a) &value) {}\");\n  verifyFormat(\"[](const _Atomic(a *) &value) {}\");\n  verifyFormat(\"[](const __underlying_type(a) &value) {}\");\n  verifyFormat(\"decltype(a * b) F();\");\n  verifyFormat(\"typeof(a * b) F();\");\n  verifyFormat(\"#define MACRO() [](A *a) { return 1; }\");\n  verifyFormat(\"Constructor() : member([](A *a, B *b) {}) {}\");\n  verifyIndependentOfContext(\"typedef void (*f)(int *a);\");\n  verifyIndependentOfContext(\"int i{a * b};\");\n  verifyIndependentOfContext(\"aaa && aaa->f();\");\n  verifyIndependentOfContext(\"int x = ~*p;\");\n  verifyFormat(\"Constructor() : a(a), area(width * height) {}\");\n  verifyFormat(\"Constructor() : a(a), area(a, width * height) {}\");\n  verifyGoogleFormat(\"MACRO Constructor(const int& i) : a(a), b(b) {}\");\n  verifyFormat(\"void f() { f(a, c * d); }\");\n  verifyFormat(\"void f() { f(new a(), c * d); }\");\n  verifyFormat(\"void f(const MyOverride &override);\");\n  verifyFormat(\"void f(const MyFinal &final);\");\n  verifyIndependentOfContext(\"bool a = f() && override.f();\");\n  verifyIndependentOfContext(\"bool a = f() && final.f();\");\n\n  verifyIndependentOfContext(\"InvalidRegions[*R] = 0;\");\n\n  verifyIndependentOfContext(\"A<int *> a;\");\n  verifyIndependentOfContext(\"A<int **> a;\");\n  verifyIndependentOfContext(\"A<int *, int *> a;\");\n  verifyIndependentOfContext(\"A<int *[]> a;\");\n  verifyIndependentOfContext(\n      \"const char *const p = reinterpret_cast<const char *const>(q);\");\n  verifyIndependentOfContext(\"A<int **, int **> a;\");\n  verifyIndependentOfContext(\"void f(int *a = d * e, int *b = c * d);\");\n  verifyFormat(\"for (char **a = b; *a; ++a) {\\n}\");\n  verifyFormat(\"for (; a && b;) {\\n}\");\n  verifyFormat(\"bool foo = true && [] { return false; }();\");\n\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaa, *aaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n\n  verifyGoogleFormat(\"int const* a = &b;\");\n  verifyGoogleFormat(\"**outparam = 1;\");\n  verifyGoogleFormat(\"*outparam = a * b;\");\n  verifyGoogleFormat(\"int main(int argc, char** argv) {}\");\n  verifyGoogleFormat(\"A<int*> a;\");\n  verifyGoogleFormat(\"A<int**> a;\");\n  verifyGoogleFormat(\"A<int*, int*> a;\");\n  verifyGoogleFormat(\"A<int**, int**> a;\");\n  verifyGoogleFormat(\"f(b ? *c : *d);\");\n  verifyGoogleFormat(\"int a = b ? *c : *d;\");\n  verifyGoogleFormat(\"Type* t = **x;\");\n  verifyGoogleFormat(\"Type* t = *++*x;\");\n  verifyGoogleFormat(\"*++*x;\");\n  verifyGoogleFormat(\"Type* t = const_cast<T*>(&*x);\");\n  verifyGoogleFormat(\"Type* t = x++ * y;\");\n  verifyGoogleFormat(\n      \"const char* const p = reinterpret_cast<const char* const>(q);\");\n  verifyGoogleFormat(\"void f(int i = 0, SomeType** temps = NULL);\");\n  verifyGoogleFormat(\"void f(Bar* a = nullptr, Bar* b);\");\n  verifyGoogleFormat(\"template <typename T>\\n\"\n                     \"void f(int i = 0, SomeType** temps = NULL);\");\n\n  FormatStyle Left = getLLVMStyle();\n  Left.PointerAlignment = FormatStyle::PAS_Left;\n  verifyFormat(\"x = *a(x) = *a(y);\", Left);\n  verifyFormat(\"for (;; *a = b) {\\n}\", Left);\n  verifyFormat(\"return *this += 1;\", Left);\n  verifyFormat(\"throw *x;\", Left);\n  verifyFormat(\"delete *x;\", Left);\n  verifyFormat(\"typedef typeof(int(int, int))* MyFuncPtr;\", Left);\n  verifyFormat(\"[](const decltype(*a)* ptr) {}\", Left);\n  verifyFormat(\"[](const typeof(*a)* ptr) {}\", Left);\n  verifyFormat(\"[](const _Atomic(a*)* ptr) {}\", Left);\n  verifyFormat(\"[](const __underlying_type(a)* ptr) {}\", Left);\n  verifyFormat(\"typedef typeof /*comment*/ (int(int, int))* MyFuncPtr;\", Left);\n  verifyFormat(\"auto x(A&&, B&&, C&&) -> D;\", Left);\n  verifyFormat(\"auto x = [](A&&, B&&, C&&) -> D {};\", Left);\n  verifyFormat(\"template <class T> X(T&&, T&&, T&&) -> X<T>;\", Left);\n\n  verifyIndependentOfContext(\"a = *(x + y);\");\n  verifyIndependentOfContext(\"a = &(x + y);\");\n  verifyIndependentOfContext(\"*(x + y).call();\");\n  verifyIndependentOfContext(\"&(x + y)->call();\");\n  verifyFormat(\"void f() { &(*I).first; }\");\n\n  verifyIndependentOfContext(\"f(b * /* confusing comment */ ++c);\");\n  verifyFormat(\n      \"int *MyValues = {\\n\"\n      \"    *A, // Operator detection might be confused by the '{'\\n\"\n      \"    *BB // Operator detection might be confused by previous comment\\n\"\n      \"};\");\n\n  verifyIndependentOfContext(\"if (int *a = &b)\");\n  verifyIndependentOfContext(\"if (int &a = *b)\");\n  verifyIndependentOfContext(\"if (a & b[i])\");\n  verifyIndependentOfContext(\"if constexpr (a & b[i])\");\n  verifyIndependentOfContext(\"if CONSTEXPR (a & b[i])\");\n  verifyIndependentOfContext(\"if (a * (b * c))\");\n  verifyIndependentOfContext(\"if constexpr (a * (b * c))\");\n  verifyIndependentOfContext(\"if CONSTEXPR (a * (b * c))\");\n  verifyIndependentOfContext(\"if (a::b::c::d & b[i])\");\n  verifyIndependentOfContext(\"if (*b[i])\");\n  verifyIndependentOfContext(\"if (int *a = (&b))\");\n  verifyIndependentOfContext(\"while (int *a = &b)\");\n  verifyIndependentOfContext(\"while (a * (b * c))\");\n  verifyIndependentOfContext(\"size = sizeof *a;\");\n  verifyIndependentOfContext(\"if (a && (b = c))\");\n  verifyFormat(\"void f() {\\n\"\n               \"  for (const int &v : Values) {\\n\"\n               \"  }\\n\"\n               \"}\");\n  verifyFormat(\"for (int i = a * a; i < 10; ++i) {\\n}\");\n  verifyFormat(\"for (int i = 0; i < a * a; ++i) {\\n}\");\n  verifyGoogleFormat(\"for (int i = 0; i * 2 < z; i *= 2) {\\n}\");\n\n  verifyFormat(\"#define A (!a * b)\");\n  verifyFormat(\"#define MACRO     \\\\\\n\"\n               \"  int *i = a * b; \\\\\\n\"\n               \"  void f(a *b);\",\n               getLLVMStyleWithColumns(19));\n\n  verifyIndependentOfContext(\"A = new SomeType *[Length];\");\n  verifyIndependentOfContext(\"A = new SomeType *[Length]();\");\n  verifyIndependentOfContext(\"T **t = new T *;\");\n  verifyIndependentOfContext(\"T **t = new T *();\");\n  verifyGoogleFormat(\"A = new SomeType*[Length]();\");\n  verifyGoogleFormat(\"A = new SomeType*[Length];\");\n  verifyGoogleFormat(\"T** t = new T*;\");\n  verifyGoogleFormat(\"T** t = new T*();\");\n\n  verifyFormat(\"STATIC_ASSERT((a & b) == 0);\");\n  verifyFormat(\"STATIC_ASSERT(0 == (a & b));\");\n  verifyFormat(\"template <bool a, bool b> \"\n               \"typename t::if<x && y>::type f() {}\");\n  verifyFormat(\"template <int *y> f() {}\");\n  verifyFormat(\"vector<int *> v;\");\n  verifyFormat(\"vector<int *const> v;\");\n  verifyFormat(\"vector<int *const **const *> v;\");\n  verifyFormat(\"vector<int *volatile> v;\");\n  verifyFormat(\"vector<a *_Nonnull> v;\");\n  verifyFormat(\"vector<a *_Nullable> v;\");\n  verifyFormat(\"vector<a *_Null_unspecified> v;\");\n  verifyFormat(\"vector<a *__ptr32> v;\");\n  verifyFormat(\"vector<a *__ptr64> v;\");\n  verifyFormat(\"vector<a *__capability> v;\");\n  FormatStyle TypeMacros = getLLVMStyle();\n  TypeMacros.TypenameMacros = {\"LIST\"};\n  verifyFormat(\"vector<LIST(uint64_t)> v;\", TypeMacros);\n  verifyFormat(\"vector<LIST(uint64_t) *> v;\", TypeMacros);\n  verifyFormat(\"vector<LIST(uint64_t) **> v;\", TypeMacros);\n  verifyFormat(\"vector<LIST(uint64_t) *attr> v;\", TypeMacros);\n  verifyFormat(\"vector<A(uint64_t) * attr> v;\", TypeMacros); // multiplication\n\n  FormatStyle CustomQualifier = getLLVMStyle();\n  // Add indentifers that should not be parsed as a qualifier by default.\n  CustomQualifier.AttributeMacros.push_back(\"__my_qualifier\");\n  CustomQualifier.AttributeMacros.push_back(\"_My_qualifier\");\n  CustomQualifier.AttributeMacros.push_back(\"my_other_qualifier\");\n  verifyFormat(\"vector<a * __my_qualifier> parse_as_multiply;\");\n  verifyFormat(\"vector<a *__my_qualifier> v;\", CustomQualifier);\n  verifyFormat(\"vector<a * _My_qualifier> parse_as_multiply;\");\n  verifyFormat(\"vector<a *_My_qualifier> v;\", CustomQualifier);\n  verifyFormat(\"vector<a * my_other_qualifier> parse_as_multiply;\");\n  verifyFormat(\"vector<a *my_other_qualifier> v;\", CustomQualifier);\n  verifyFormat(\"vector<a * _NotAQualifier> v;\");\n  verifyFormat(\"vector<a * __not_a_qualifier> v;\");\n  verifyFormat(\"vector<a * b> v;\");\n  verifyFormat(\"foo<b && false>();\");\n  verifyFormat(\"foo<b & 1>();\");\n  verifyFormat(\"decltype(*::std::declval<const T &>()) void F();\");\n  verifyFormat(\"typeof(*::std::declval<const T &>()) void F();\");\n  verifyFormat(\"_Atomic(*::std::declval<const T &>()) void F();\");\n  verifyFormat(\"__underlying_type(*::std::declval<const T &>()) void F();\");\n  verifyFormat(\n      \"template <class T, class = typename std::enable_if<\\n\"\n      \"                       std::is_integral<T>::value &&\\n\"\n      \"                       (sizeof(T) > 1 || sizeof(T) < 8)>::type>\\n\"\n      \"void F();\",\n      getLLVMStyleWithColumns(70));\n  verifyFormat(\"template <class T,\\n\"\n               \"          class = typename std::enable_if<\\n\"\n               \"              std::is_integral<T>::value &&\\n\"\n               \"              (sizeof(T) > 1 || sizeof(T) < 8)>::type,\\n\"\n               \"          class U>\\n\"\n               \"void F();\",\n               getLLVMStyleWithColumns(70));\n  verifyFormat(\n      \"template <class T,\\n\"\n      \"          class = typename ::std::enable_if<\\n\"\n      \"              ::std::is_array<T>{} && ::std::is_array<T>{}>::type>\\n\"\n      \"void F();\",\n      getGoogleStyleWithColumns(68));\n\n  verifyIndependentOfContext(\"MACRO(int *i);\");\n  verifyIndependentOfContext(\"MACRO(auto *a);\");\n  verifyIndependentOfContext(\"MACRO(const A *a);\");\n  verifyIndependentOfContext(\"MACRO(_Atomic(A) *a);\");\n  verifyIndependentOfContext(\"MACRO(decltype(A) *a);\");\n  verifyIndependentOfContext(\"MACRO(typeof(A) *a);\");\n  verifyIndependentOfContext(\"MACRO(__underlying_type(A) *a);\");\n  verifyIndependentOfContext(\"MACRO(A *const a);\");\n  verifyIndependentOfContext(\"MACRO(A *restrict a);\");\n  verifyIndependentOfContext(\"MACRO(A *__restrict__ a);\");\n  verifyIndependentOfContext(\"MACRO(A *__restrict a);\");\n  verifyIndependentOfContext(\"MACRO(A *volatile a);\");\n  verifyIndependentOfContext(\"MACRO(A *__volatile a);\");\n  verifyIndependentOfContext(\"MACRO(A *__volatile__ a);\");\n  verifyIndependentOfContext(\"MACRO(A *_Nonnull a);\");\n  verifyIndependentOfContext(\"MACRO(A *_Nullable a);\");\n  verifyIndependentOfContext(\"MACRO(A *_Null_unspecified a);\");\n  verifyIndependentOfContext(\"MACRO(A *__attribute__((foo)) a);\");\n  verifyIndependentOfContext(\"MACRO(A *__attribute((foo)) a);\");\n  verifyIndependentOfContext(\"MACRO(A *[[clang::attr]] a);\");\n  verifyIndependentOfContext(\"MACRO(A *[[clang::attr(\\\"foo\\\")]] a);\");\n  verifyIndependentOfContext(\"MACRO(A *__ptr32 a);\");\n  verifyIndependentOfContext(\"MACRO(A *__ptr64 a);\");\n  verifyIndependentOfContext(\"MACRO(A *__capability);\");\n  verifyIndependentOfContext(\"MACRO(A &__capability);\");\n  verifyFormat(\"MACRO(A *__my_qualifier);\");               // type declaration\n  verifyFormat(\"void f() { MACRO(A * __my_qualifier); }\"); // multiplication\n  // If we add __my_qualifier to AttributeMacros it should always be parsed as\n  // a type declaration:\n  verifyFormat(\"MACRO(A *__my_qualifier);\", CustomQualifier);\n  verifyFormat(\"void f() { MACRO(A *__my_qualifier); }\", CustomQualifier);\n  // Also check that TypenameMacros prevents parsing it as multiplication:\n  verifyIndependentOfContext(\"MACRO(LIST(uint64_t) * a);\"); // multiplication\n  verifyIndependentOfContext(\"MACRO(LIST(uint64_t) *a);\", TypeMacros); // type\n\n  verifyIndependentOfContext(\"MACRO('0' <= c && c <= '9');\");\n  verifyFormat(\"void f() { f(float{1}, a * a); }\");\n  // FIXME: Is there a way to make this work?\n  // verifyIndependentOfContext(\"MACRO(A *a);\");\n  verifyFormat(\"MACRO(A &B);\");\n  verifyFormat(\"MACRO(A *B);\");\n  verifyFormat(\"void f() { MACRO(A * B); }\");\n  verifyFormat(\"void f() { MACRO(A & B); }\");\n\n  // This lambda was mis-formatted after D88956 (treating it as a binop):\n  verifyFormat(\"auto x = [](const decltype(x) &ptr) {};\");\n  verifyFormat(\"auto x = [](const decltype(x) *ptr) {};\");\n  verifyFormat(\"#define lambda [](const decltype(x) &ptr) {}\");\n  verifyFormat(\"#define lambda [](const decltype(x) *ptr) {}\");\n\n  verifyFormat(\"DatumHandle const *operator->() const { return input_; }\");\n  verifyFormat(\"return options != nullptr && operator==(*options);\");\n\n  EXPECT_EQ(\"#define OP(x)                                    \\\\\\n\"\n            \"  ostream &operator<<(ostream &s, const A &a) {  \\\\\\n\"\n            \"    return s << a.DebugString();                 \\\\\\n\"\n            \"  }\",\n            format(\"#define OP(x) \\\\\\n\"\n                   \"  ostream &operator<<(ostream &s, const A &a) { \\\\\\n\"\n                   \"    return s << a.DebugString(); \\\\\\n\"\n                   \"  }\",\n                   getLLVMStyleWithColumns(50)));\n\n  // FIXME: We cannot handle this case yet; we might be able to figure out that\n  // foo<x> d > v; doesn't make sense.\n  verifyFormat(\"foo<a<b && c> d> v;\");\n\n  FormatStyle PointerMiddle = getLLVMStyle();\n  PointerMiddle.PointerAlignment = FormatStyle::PAS_Middle;\n  verifyFormat(\"delete *x;\", PointerMiddle);\n  verifyFormat(\"int * x;\", PointerMiddle);\n  verifyFormat(\"int *[] x;\", PointerMiddle);\n  verifyFormat(\"template <int * y> f() {}\", PointerMiddle);\n  verifyFormat(\"int * f(int * a) {}\", PointerMiddle);\n  verifyFormat(\"int main(int argc, char ** argv) {}\", PointerMiddle);\n  verifyFormat(\"Test::Test(int b) : a(b * b) {}\", PointerMiddle);\n  verifyFormat(\"A<int *> a;\", PointerMiddle);\n  verifyFormat(\"A<int **> a;\", PointerMiddle);\n  verifyFormat(\"A<int *, int *> a;\", PointerMiddle);\n  verifyFormat(\"A<int *[]> a;\", PointerMiddle);\n  verifyFormat(\"A = new SomeType *[Length]();\", PointerMiddle);\n  verifyFormat(\"A = new SomeType *[Length];\", PointerMiddle);\n  verifyFormat(\"T ** t = new T *;\", PointerMiddle);\n\n  // Member function reference qualifiers aren't binary operators.\n  verifyFormat(\"string // break\\n\"\n               \"operator()() & {}\");\n  verifyFormat(\"string // break\\n\"\n               \"operator()() && {}\");\n  verifyGoogleFormat(\"template <typename T>\\n\"\n                     \"auto x() & -> int {}\");\n}\n\nTEST_F(FormatTest, UnderstandsAttributes) {\n  verifyFormat(\"SomeType s __attribute__((unused)) (InitValue);\");\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa __attribute__((unused))\\n\"\n               \"aaaaaaaaaaaaaaaaaaaaaaa(int i);\");\n  FormatStyle AfterType = getLLVMStyle();\n  AfterType.AlwaysBreakAfterReturnType = FormatStyle::RTBS_All;\n  verifyFormat(\"__attribute__((nodebug)) void\\n\"\n               \"foo() {}\\n\",\n               AfterType);\n  verifyFormat(\"__unused void\\n\"\n               \"foo() {}\",\n               AfterType);\n\n  FormatStyle CustomAttrs = getLLVMStyle();\n  CustomAttrs.AttributeMacros.push_back(\"__unused\");\n  CustomAttrs.AttributeMacros.push_back(\"__attr1\");\n  CustomAttrs.AttributeMacros.push_back(\"__attr2\");\n  CustomAttrs.AttributeMacros.push_back(\"no_underscore_attr\");\n  verifyFormat(\"vector<SomeType *__attribute((foo))> v;\");\n  verifyFormat(\"vector<SomeType *__attribute__((foo))> v;\");\n  verifyFormat(\"vector<SomeType * __not_attribute__((foo))> v;\");\n  // Check that it is parsed as a multiplication without AttributeMacros and\n  // as a pointer qualifier when we add __attr1/__attr2 to AttributeMacros.\n  verifyFormat(\"vector<SomeType * __attr1> v;\");\n  verifyFormat(\"vector<SomeType __attr1 *> v;\");\n  verifyFormat(\"vector<SomeType __attr1 *const> v;\");\n  verifyFormat(\"vector<SomeType __attr1 * __attr2> v;\");\n  verifyFormat(\"vector<SomeType *__attr1> v;\", CustomAttrs);\n  verifyFormat(\"vector<SomeType *__attr2> v;\", CustomAttrs);\n  verifyFormat(\"vector<SomeType *no_underscore_attr> v;\", CustomAttrs);\n  verifyFormat(\"vector<SomeType __attr1 *> v;\", CustomAttrs);\n  verifyFormat(\"vector<SomeType __attr1 *const> v;\", CustomAttrs);\n  verifyFormat(\"vector<SomeType __attr1 *__attr2> v;\", CustomAttrs);\n  verifyFormat(\"vector<SomeType __attr1 *no_underscore_attr> v;\", CustomAttrs);\n\n  // Check that these are not parsed as function declarations:\n  CustomAttrs.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_None;\n  CustomAttrs.BreakBeforeBraces = FormatStyle::BS_Allman;\n  verifyFormat(\"SomeType s(InitValue);\", CustomAttrs);\n  verifyFormat(\"SomeType s{InitValue};\", CustomAttrs);\n  verifyFormat(\"SomeType *__unused s(InitValue);\", CustomAttrs);\n  verifyFormat(\"SomeType *__unused s{InitValue};\", CustomAttrs);\n  verifyFormat(\"SomeType s __unused(InitValue);\", CustomAttrs);\n  verifyFormat(\"SomeType s __unused{InitValue};\", CustomAttrs);\n  verifyFormat(\"SomeType *__capability s(InitValue);\", CustomAttrs);\n  verifyFormat(\"SomeType *__capability s{InitValue};\", CustomAttrs);\n}\n\nTEST_F(FormatTest, UnderstandsPointerQualifiersInCast) {\n  // Check that qualifiers on pointers don't break parsing of casts.\n  verifyFormat(\"x = (foo *const)*v;\");\n  verifyFormat(\"x = (foo *volatile)*v;\");\n  verifyFormat(\"x = (foo *restrict)*v;\");\n  verifyFormat(\"x = (foo *__attribute__((foo)))*v;\");\n  verifyFormat(\"x = (foo *_Nonnull)*v;\");\n  verifyFormat(\"x = (foo *_Nullable)*v;\");\n  verifyFormat(\"x = (foo *_Null_unspecified)*v;\");\n  verifyFormat(\"x = (foo *_Nonnull)*v;\");\n  verifyFormat(\"x = (foo *[[clang::attr]])*v;\");\n  verifyFormat(\"x = (foo *[[clang::attr(\\\"foo\\\")]])*v;\");\n  verifyFormat(\"x = (foo *__ptr32)*v;\");\n  verifyFormat(\"x = (foo *__ptr64)*v;\");\n  verifyFormat(\"x = (foo *__capability)*v;\");\n\n  // Check that we handle multiple trailing qualifiers and skip them all to\n  // determine that the expression is a cast to a pointer type.\n  FormatStyle LongPointerRight = getLLVMStyleWithColumns(999);\n  FormatStyle LongPointerLeft = getLLVMStyleWithColumns(999);\n  LongPointerLeft.PointerAlignment = FormatStyle::PAS_Left;\n  StringRef AllQualifiers =\n      \"const volatile restrict __attribute__((foo)) _Nonnull _Null_unspecified \"\n      \"_Nonnull [[clang::attr]] __ptr32 __ptr64 __capability\";\n  verifyFormat((\"x = (foo *\" + AllQualifiers + \")*v;\").str(), LongPointerRight);\n  verifyFormat((\"x = (foo* \" + AllQualifiers + \")*v;\").str(), LongPointerLeft);\n\n  // Also check that address-of is not parsed as a binary bitwise-and:\n  verifyFormat(\"x = (foo *const)&v;\");\n  verifyFormat((\"x = (foo *\" + AllQualifiers + \")&v;\").str(), LongPointerRight);\n  verifyFormat((\"x = (foo* \" + AllQualifiers + \")&v;\").str(), LongPointerLeft);\n\n  // Check custom qualifiers:\n  FormatStyle CustomQualifier = getLLVMStyleWithColumns(999);\n  CustomQualifier.AttributeMacros.push_back(\"__my_qualifier\");\n  verifyFormat(\"x = (foo * __my_qualifier) * v;\"); // not parsed as qualifier.\n  verifyFormat(\"x = (foo *__my_qualifier)*v;\", CustomQualifier);\n  verifyFormat((\"x = (foo *\" + AllQualifiers + \" __my_qualifier)*v;\").str(),\n               CustomQualifier);\n  verifyFormat((\"x = (foo *\" + AllQualifiers + \" __my_qualifier)&v;\").str(),\n               CustomQualifier);\n\n  // Check that unknown identifiers result in binary operator parsing:\n  verifyFormat(\"x = (foo * __unknown_qualifier) * v;\");\n  verifyFormat(\"x = (foo * __unknown_qualifier) & v;\");\n}\n\nTEST_F(FormatTest, UnderstandsSquareAttributes) {\n  verifyFormat(\"SomeType s [[unused]] (InitValue);\");\n  verifyFormat(\"SomeType s [[gnu::unused]] (InitValue);\");\n  verifyFormat(\"SomeType s [[using gnu: unused]] (InitValue);\");\n  verifyFormat(\"[[gsl::suppress(\\\"clang-tidy-check-name\\\")]] void f() {}\");\n  verifyFormat(\"void f() [[deprecated(\\\"so sorry\\\")]];\");\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    [[unused]] aaaaaaaaaaaaaaaaaaaaaaa(int i);\");\n  verifyFormat(\"[[nodiscard]] bool f() { return false; }\");\n  verifyFormat(\"class [[nodiscard]] f {\\npublic:\\n  f() {}\\n}\");\n  verifyFormat(\"class [[deprecated(\\\"so sorry\\\")]] f {\\npublic:\\n  f() {}\\n}\");\n  verifyFormat(\"class [[gnu::unused]] f {\\npublic:\\n  f() {}\\n}\");\n\n  // Make sure we do not mistake attributes for array subscripts.\n  verifyFormat(\"int a() {}\\n\"\n               \"[[unused]] int b() {}\\n\");\n  verifyFormat(\"NSArray *arr;\\n\"\n               \"arr[[Foo() bar]];\");\n\n  // On the other hand, we still need to correctly find array subscripts.\n  verifyFormat(\"int a = std::vector<int>{1, 2, 3}[0];\");\n\n  // Make sure that we do not mistake Objective-C method inside array literals\n  // as attributes, even if those method names are also keywords.\n  verifyFormat(\"@[ [foo bar] ];\");\n  verifyFormat(\"@[ [NSArray class] ];\");\n  verifyFormat(\"@[ [foo enum] ];\");\n\n  verifyFormat(\"template <typename T> [[nodiscard]] int a() { return 1; }\");\n\n  // Make sure we do not parse attributes as lambda introducers.\n  FormatStyle MultiLineFunctions = getLLVMStyle();\n  MultiLineFunctions.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_None;\n  verifyFormat(\"[[unused]] int b() {\\n\"\n               \"  return 42;\\n\"\n               \"}\\n\",\n               MultiLineFunctions);\n}\n\nTEST_F(FormatTest, AttributeClass) {\n  FormatStyle Style = getChromiumStyle(FormatStyle::LK_Cpp);\n  verifyFormat(\"class S {\\n\"\n               \"  S(S&&) = default;\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"class [[nodiscard]] S {\\n\"\n               \"  S(S&&) = default;\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"class __attribute((maybeunused)) S {\\n\"\n               \"  S(S&&) = default;\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"struct S {\\n\"\n               \"  S(S&&) = default;\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"struct [[nodiscard]] S {\\n\"\n               \"  S(S&&) = default;\\n\"\n               \"};\",\n               Style);\n}\n\nTEST_F(FormatTest, AttributesAfterMacro) {\n  FormatStyle Style = getLLVMStyle();\n  verifyFormat(\"MACRO;\\n\"\n               \"__attribute__((maybe_unused)) int foo() {\\n\"\n               \"  //...\\n\"\n               \"}\");\n\n  verifyFormat(\"MACRO;\\n\"\n               \"[[nodiscard]] int foo() {\\n\"\n               \"  //...\\n\"\n               \"}\");\n\n  EXPECT_EQ(\"MACRO\\n\\n\"\n            \"__attribute__((maybe_unused)) int foo() {\\n\"\n            \"  //...\\n\"\n            \"}\",\n            format(\"MACRO\\n\\n\"\n                   \"__attribute__((maybe_unused)) int foo() {\\n\"\n                   \"  //...\\n\"\n                   \"}\"));\n\n  EXPECT_EQ(\"MACRO\\n\\n\"\n            \"[[nodiscard]] int foo() {\\n\"\n            \"  //...\\n\"\n            \"}\",\n            format(\"MACRO\\n\\n\"\n                   \"[[nodiscard]] int foo() {\\n\"\n                   \"  //...\\n\"\n                   \"}\"));\n}\n\nTEST_F(FormatTest, AttributePenaltyBreaking) {\n  FormatStyle Style = getLLVMStyle();\n  verifyFormat(\"void ABCDEFGH::ABCDEFGHIJKLMN(\\n\"\n               \"    [[maybe_unused]] const shared_ptr<ALongTypeName> &C d) {}\",\n               Style);\n  verifyFormat(\"void ABCDEFGH::ABCDEFGHIJK(\\n\"\n               \"    [[maybe_unused]] const shared_ptr<ALongTypeName> &C d) {}\",\n               Style);\n  verifyFormat(\"void ABCDEFGH::ABCDEFGH([[maybe_unused]] const \"\n               \"shared_ptr<ALongTypeName> &C d) {\\n}\",\n               Style);\n}\n\nTEST_F(FormatTest, UnderstandsEllipsis) {\n  FormatStyle Style = getLLVMStyle();\n  verifyFormat(\"int printf(const char *fmt, ...);\");\n  verifyFormat(\"template <class... Ts> void Foo(Ts... ts) { Foo(ts...); }\");\n  verifyFormat(\"template <class... Ts> void Foo(Ts *...ts) {}\");\n\n  verifyFormat(\"template <int *...PP> a;\", Style);\n\n  Style.PointerAlignment = FormatStyle::PAS_Left;\n  verifyFormat(\"template <class... Ts> void Foo(Ts*... ts) {}\", Style);\n\n  verifyFormat(\"template <int*... PP> a;\", Style);\n\n  Style.PointerAlignment = FormatStyle::PAS_Middle;\n  verifyFormat(\"template <int *... PP> a;\", Style);\n}\n\nTEST_F(FormatTest, AdaptivelyFormatsPointersAndReferences) {\n  EXPECT_EQ(\"int *a;\\n\"\n            \"int *a;\\n\"\n            \"int *a;\",\n            format(\"int *a;\\n\"\n                   \"int* a;\\n\"\n                   \"int *a;\",\n                   getGoogleStyle()));\n  EXPECT_EQ(\"int* a;\\n\"\n            \"int* a;\\n\"\n            \"int* a;\",\n            format(\"int* a;\\n\"\n                   \"int* a;\\n\"\n                   \"int *a;\",\n                   getGoogleStyle()));\n  EXPECT_EQ(\"int *a;\\n\"\n            \"int *a;\\n\"\n            \"int *a;\",\n            format(\"int *a;\\n\"\n                   \"int * a;\\n\"\n                   \"int *  a;\",\n                   getGoogleStyle()));\n  EXPECT_EQ(\"auto x = [] {\\n\"\n            \"  int *a;\\n\"\n            \"  int *a;\\n\"\n            \"  int *a;\\n\"\n            \"};\",\n            format(\"auto x=[]{int *a;\\n\"\n                   \"int * a;\\n\"\n                   \"int *  a;};\",\n                   getGoogleStyle()));\n}\n\nTEST_F(FormatTest, UnderstandsRvalueReferences) {\n  verifyFormat(\"int f(int &&a) {}\");\n  verifyFormat(\"int f(int a, char &&b) {}\");\n  verifyFormat(\"void f() { int &&a = b; }\");\n  verifyGoogleFormat(\"int f(int a, char&& b) {}\");\n  verifyGoogleFormat(\"void f() { int&& a = b; }\");\n\n  verifyIndependentOfContext(\"A<int &&> a;\");\n  verifyIndependentOfContext(\"A<int &&, int &&> a;\");\n  verifyGoogleFormat(\"A<int&&> a;\");\n  verifyGoogleFormat(\"A<int&&, int&&> a;\");\n\n  // Not rvalue references:\n  verifyFormat(\"template <bool B, bool C> class A {\\n\"\n               \"  static_assert(B && C, \\\"Something is wrong\\\");\\n\"\n               \"};\");\n  verifyGoogleFormat(\"#define IF(a, b, c) if (a && (b == c))\");\n  verifyGoogleFormat(\"#define WHILE(a, b, c) while (a && (b == c))\");\n  verifyFormat(\"#define A(a, b) (a && b)\");\n}\n\nTEST_F(FormatTest, FormatsBinaryOperatorsPrecedingEquals) {\n  verifyFormat(\"void f() {\\n\"\n               \"  x[aaaaaaaaa -\\n\"\n               \"    b] = 23;\\n\"\n               \"}\",\n               getLLVMStyleWithColumns(15));\n}\n\nTEST_F(FormatTest, FormatsCasts) {\n  verifyFormat(\"Type *A = static_cast<Type *>(P);\");\n  verifyFormat(\"Type *A = (Type *)P;\");\n  verifyFormat(\"Type *A = (vector<Type *, int *>)P;\");\n  verifyFormat(\"int a = (int)(2.0f);\");\n  verifyFormat(\"int a = (int)2.0f;\");\n  verifyFormat(\"x[(int32)y];\");\n  verifyFormat(\"x = (int32)y;\");\n  verifyFormat(\"#define AA(X) sizeof(((X *)NULL)->a)\");\n  verifyFormat(\"int a = (int)*b;\");\n  verifyFormat(\"int a = (int)2.0f;\");\n  verifyFormat(\"int a = (int)~0;\");\n  verifyFormat(\"int a = (int)++a;\");\n  verifyFormat(\"int a = (int)sizeof(int);\");\n  verifyFormat(\"int a = (int)+2;\");\n  verifyFormat(\"my_int a = (my_int)2.0f;\");\n  verifyFormat(\"my_int a = (my_int)sizeof(int);\");\n  verifyFormat(\"return (my_int)aaa;\");\n  verifyFormat(\"#define x ((int)-1)\");\n  verifyFormat(\"#define LENGTH(x, y) (x) - (y) + 1\");\n  verifyFormat(\"#define p(q) ((int *)&q)\");\n  verifyFormat(\"fn(a)(b) + 1;\");\n\n  verifyFormat(\"void f() { my_int a = (my_int)*b; }\");\n  verifyFormat(\"void f() { return P ? (my_int)*P : (my_int)0; }\");\n  verifyFormat(\"my_int a = (my_int)~0;\");\n  verifyFormat(\"my_int a = (my_int)++a;\");\n  verifyFormat(\"my_int a = (my_int)-2;\");\n  verifyFormat(\"my_int a = (my_int)1;\");\n  verifyFormat(\"my_int a = (my_int *)1;\");\n  verifyFormat(\"my_int a = (const my_int)-1;\");\n  verifyFormat(\"my_int a = (const my_int *)-1;\");\n  verifyFormat(\"my_int a = (my_int)(my_int)-1;\");\n  verifyFormat(\"my_int a = (ns::my_int)-2;\");\n  verifyFormat(\"case (my_int)ONE:\");\n  verifyFormat(\"auto x = (X)this;\");\n  // Casts in Obj-C style calls used to not be recognized as such.\n  verifyFormat(\"int a = [(type*)[((type*)val) arg] arg];\", getGoogleStyle());\n\n  // FIXME: single value wrapped with paren will be treated as cast.\n  verifyFormat(\"void f(int i = (kValue)*kMask) {}\");\n\n  verifyFormat(\"{ (void)F; }\");\n\n  // Don't break after a cast's\n  verifyFormat(\"int aaaaaaaaaaaaaaaaaaaaaaaaaaa =\\n\"\n               \"    (aaaaaaaaaaaaaaaaaaaaaaaaaa *)(aaaaaaaaaaaaaaaaaaaaaa +\\n\"\n               \"                                   bbbbbbbbbbbbbbbbbbbbbb);\");\n\n  // These are not casts.\n  verifyFormat(\"void f(int *) {}\");\n  verifyFormat(\"f(foo)->b;\");\n  verifyFormat(\"f(foo).b;\");\n  verifyFormat(\"f(foo)(b);\");\n  verifyFormat(\"f(foo)[b];\");\n  verifyFormat(\"[](foo) { return 4; }(bar);\");\n  verifyFormat(\"(*funptr)(foo)[4];\");\n  verifyFormat(\"funptrs[4](foo)[4];\");\n  verifyFormat(\"void f(int *);\");\n  verifyFormat(\"void f(int *) = 0;\");\n  verifyFormat(\"void f(SmallVector<int>) {}\");\n  verifyFormat(\"void f(SmallVector<int>);\");\n  verifyFormat(\"void f(SmallVector<int>) = 0;\");\n  verifyFormat(\"void f(int i = (kA * kB) & kMask) {}\");\n  verifyFormat(\"int a = sizeof(int) * b;\");\n  verifyFormat(\"int a = alignof(int) * b;\", getGoogleStyle());\n  verifyFormat(\"template <> void f<int>(int i) SOME_ANNOTATION;\");\n  verifyFormat(\"f(\\\"%\\\" SOME_MACRO(ll) \\\"d\\\");\");\n  verifyFormat(\"aaaaa &operator=(const aaaaa &) LLVM_DELETED_FUNCTION;\");\n\n  // These are not casts, but at some point were confused with casts.\n  verifyFormat(\"virtual void foo(int *) override;\");\n  verifyFormat(\"virtual void foo(char &) const;\");\n  verifyFormat(\"virtual void foo(int *a, char *) const;\");\n  verifyFormat(\"int a = sizeof(int *) + b;\");\n  verifyFormat(\"int a = alignof(int *) + b;\", getGoogleStyle());\n  verifyFormat(\"bool b = f(g<int>) && c;\");\n  verifyFormat(\"typedef void (*f)(int i) func;\");\n  verifyFormat(\"void operator++(int) noexcept;\");\n  verifyFormat(\"void operator++(int &) noexcept;\");\n  verifyFormat(\"void operator delete(void *, std::size_t, const std::nothrow_t \"\n               \"&) noexcept;\");\n  verifyFormat(\n      \"void operator delete(std::size_t, const std::nothrow_t &) noexcept;\");\n  verifyFormat(\"void operator delete(const std::nothrow_t &) noexcept;\");\n  verifyFormat(\"void operator delete(std::nothrow_t &) noexcept;\");\n  verifyFormat(\"void operator delete(nothrow_t &) noexcept;\");\n  verifyFormat(\"void operator delete(foo &) noexcept;\");\n  verifyFormat(\"void operator delete(foo) noexcept;\");\n  verifyFormat(\"void operator delete(int) noexcept;\");\n  verifyFormat(\"void operator delete(int &) noexcept;\");\n  verifyFormat(\"void operator delete(int &) volatile noexcept;\");\n  verifyFormat(\"void operator delete(int &) const\");\n  verifyFormat(\"void operator delete(int &) = default\");\n  verifyFormat(\"void operator delete(int &) = delete\");\n  verifyFormat(\"void operator delete(int &) [[noreturn]]\");\n  verifyFormat(\"void operator delete(int &) throw();\");\n  verifyFormat(\"void operator delete(int &) throw(int);\");\n  verifyFormat(\"auto operator delete(int &) -> int;\");\n  verifyFormat(\"auto operator delete(int &) override\");\n  verifyFormat(\"auto operator delete(int &) final\");\n\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa *foo = (aaaaaaaaaaaaaaaaa *)\\n\"\n               \"    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\");\n  // FIXME: The indentation here is not ideal.\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n      \"    [bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb] = (*cccccccccccccccc)\\n\"\n      \"        [dddddddddddddddddddddddddddddddddddddddddddddddddddddddd];\");\n}\n\nTEST_F(FormatTest, FormatsFunctionTypes) {\n  verifyFormat(\"A<bool()> a;\");\n  verifyFormat(\"A<SomeType()> a;\");\n  verifyFormat(\"A<void (*)(int, std::string)> a;\");\n  verifyFormat(\"A<void *(int)>;\");\n  verifyFormat(\"void *(*a)(int *, SomeType *);\");\n  verifyFormat(\"int (*func)(void *);\");\n  verifyFormat(\"void f() { int (*func)(void *); }\");\n  verifyFormat(\"template <class CallbackClass>\\n\"\n               \"using MyCallback = void (CallbackClass::*)(SomeObject *Data);\");\n\n  verifyGoogleFormat(\"A<void*(int*, SomeType*)>;\");\n  verifyGoogleFormat(\"void* (*a)(int);\");\n  verifyGoogleFormat(\n      \"template <class CallbackClass>\\n\"\n      \"using MyCallback = void (CallbackClass::*)(SomeObject* Data);\");\n\n  // Other constructs can look somewhat like function types:\n  verifyFormat(\"A<sizeof(*x)> a;\");\n  verifyFormat(\"#define DEREF_AND_CALL_F(x) f(*x)\");\n  verifyFormat(\"some_var = function(*some_pointer_var)[0];\");\n  verifyFormat(\"void f() { function(*some_pointer_var)[0] = 10; }\");\n  verifyFormat(\"int x = f(&h)();\");\n  verifyFormat(\"returnsFunction(&param1, &param2)(param);\");\n  verifyFormat(\"std::function<\\n\"\n               \"    LooooooooooongTemplatedType<\\n\"\n               \"        SomeType>*(\\n\"\n               \"        LooooooooooooooooongType type)>\\n\"\n               \"    function;\",\n               getGoogleStyleWithColumns(40));\n}\n\nTEST_F(FormatTest, FormatsPointersToArrayTypes) {\n  verifyFormat(\"A (*foo_)[6];\");\n  verifyFormat(\"vector<int> (*foo_)[6];\");\n}\n\nTEST_F(FormatTest, BreaksLongVariableDeclarations) {\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooooongType\\n\"\n               \"    LoooooooooooooooooooooooooooooooooooooooongVariable;\");\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooooongType const\\n\"\n               \"    LoooooooooooooooooooooooooooooooooooooooongVariable;\");\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooooongType\\n\"\n               \"    *LoooooooooooooooooooooooooooooooooooooooongVariable;\");\n\n  // Different ways of ()-initializiation.\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooooongType\\n\"\n               \"    LoooooooooooooooooooooooooooooooooooooooongVariable(1);\");\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooooongType\\n\"\n               \"    LoooooooooooooooooooooooooooooooooooooooongVariable(a);\");\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooooongType\\n\"\n               \"    LoooooooooooooooooooooooooooooooooooooooongVariable({});\");\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooooongType\\n\"\n               \"    LoooooooooooooooooooooooooooooooooooooongVariable([A a]);\");\n\n  // Lambdas should not confuse the variable declaration heuristic.\n  verifyFormat(\"LooooooooooooooooongType\\n\"\n               \"    variable(nullptr, [](A *a) {});\",\n               getLLVMStyleWithColumns(40));\n}\n\nTEST_F(FormatTest, BreaksLongDeclarations) {\n  verifyFormat(\"typedef LoooooooooooooooooooooooooooooooooooooooongType\\n\"\n               \"    AnotherNameForTheLongType;\");\n  verifyFormat(\"typedef LongTemplateType<aaaaaaaaaaaaaaaaaaa()>\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\");\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooooongReturnType\\n\"\n               \"LoooooooooooooooooooooooooooooooongFunctionDeclaration();\");\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooooongReturnType *\\n\"\n               \"LoooooooooooooooooooooooooooooooongFunctionDeclaration();\");\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooooongReturnType\\n\"\n               \"LooooooooooooooooooooooooooooooooooongFunctionDefinition() {}\");\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooooongReturnType MACRO\\n\"\n               \"LooooooooooooooooooooooooooooooooooongFunctionDefinition() {}\");\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooooongReturnType const\\n\"\n               \"LooooooooooooooooooooooooooooooooooongFunctionDefinition() {}\");\n  verifyFormat(\"decltype(LoooooooooooooooooooooooooooooooooooooooongName)\\n\"\n               \"LooooooooooooooooooooooooooooooooooongFunctionDefinition() {}\");\n  verifyFormat(\"typeof(LoooooooooooooooooooooooooooooooooooooooooongName)\\n\"\n               \"LooooooooooooooooooooooooooooooooooongFunctionDefinition() {}\");\n  verifyFormat(\"_Atomic(LooooooooooooooooooooooooooooooooooooooooongName)\\n\"\n               \"LooooooooooooooooooooooooooooooooooongFunctionDefinition() {}\");\n  verifyFormat(\"__underlying_type(LooooooooooooooooooooooooooooooongName)\\n\"\n               \"LooooooooooooooooooooooooooooooooooongFunctionDefinition() {}\");\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooooongReturnType\\n\"\n               \"LooooooooooooooooooooooooooongFunctionDeclaration(T... t);\");\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooooongReturnType\\n\"\n               \"LooooooooooooooooooooooooooongFunctionDeclaration(T /*t*/) {}\");\n  FormatStyle Indented = getLLVMStyle();\n  Indented.IndentWrappedFunctionNames = true;\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooooongReturnType\\n\"\n               \"    LoooooooooooooooooooooooooooooooongFunctionDeclaration();\",\n               Indented);\n  verifyFormat(\n      \"LoooooooooooooooooooooooooooooooooooooooongReturnType\\n\"\n      \"    LooooooooooooooooooooooooooooooooooongFunctionDefinition() {}\",\n      Indented);\n  verifyFormat(\n      \"LoooooooooooooooooooooooooooooooooooooooongReturnType const\\n\"\n      \"    LooooooooooooooooooooooooooooooooooongFunctionDefinition() {}\",\n      Indented);\n  verifyFormat(\n      \"decltype(LoooooooooooooooooooooooooooooooooooooooongName)\\n\"\n      \"    LooooooooooooooooooooooooooooooooooongFunctionDefinition() {}\",\n      Indented);\n\n  // FIXME: Without the comment, this breaks after \"(\".\n  verifyFormat(\"LoooooooooooooooooooooooooooooooooooooooongType  // break\\n\"\n               \"    (*LoooooooooooooooooooooooooooongFunctionTypeVarialbe)();\",\n               getGoogleStyle());\n\n  verifyFormat(\"int *someFunction(int LoooooooooooooooooooongParam1,\\n\"\n               \"                  int LoooooooooooooooooooongParam2) {}\");\n  verifyFormat(\n      \"TypeSpecDecl *TypeSpecDecl::Create(ASTContext &C, DeclContext *DC,\\n\"\n      \"                                   SourceLocation L, IdentifierIn *II,\\n\"\n      \"                                   Type *T) {}\");\n  verifyFormat(\"ReallyLongReturnType<TemplateParam1, TemplateParam2>\\n\"\n               \"ReallyReaaallyLongFunctionName(\\n\"\n               \"    const std::string &SomeParameter,\\n\"\n               \"    const SomeType<string, SomeOtherTemplateParameter>\\n\"\n               \"        &ReallyReallyLongParameterName,\\n\"\n               \"    const SomeType<string, SomeOtherTemplateParameter>\\n\"\n               \"        &AnotherLongParameterName) {}\");\n  verifyFormat(\"template <typename A>\\n\"\n               \"SomeLoooooooooooooooooooooongType<\\n\"\n               \"    typename some_namespace::SomeOtherType<A>::Type>\\n\"\n               \"Function() {}\");\n\n  verifyGoogleFormat(\n      \"aaaaaaaaaaaaaaaa::aaaaaaaaaaaaaaaa<aaaaaaaaaaaaa, aaaaaaaaaaaa>\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaa;\");\n  verifyGoogleFormat(\n      \"TypeSpecDecl* TypeSpecDecl::Create(ASTContext& C, DeclContext* DC,\\n\"\n      \"                                   SourceLocation L) {}\");\n  verifyGoogleFormat(\n      \"some_namespace::LongReturnType\\n\"\n      \"long_namespace::SomeVeryLongClass::SomeVeryLongFunction(\\n\"\n      \"    int first_long_parameter, int second_parameter) {}\");\n\n  verifyGoogleFormat(\"template <typename T>\\n\"\n                     \"aaaaaaaa::aaaaa::aaaaaa<T, aaaaaaaaaaaaaaaaaaaaaaaaa>\\n\"\n                     \"aaaaaaaaaaaaaaaaaaaaaaaa<T>::aaaaaaa() {}\");\n  verifyGoogleFormat(\"A<A<A>> aaaaaaaaaa(int aaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n                     \"                   int aaaaaaaaaaaaaaaaaaaaaaa);\");\n\n  verifyFormat(\"typedef size_t (*aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)(\\n\"\n               \"    const aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"        *aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\"void aaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"    vector<aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa>\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaa);\");\n  verifyFormat(\"void aaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"    vector<aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa>>\\n\"\n               \"        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n\n  verifyFormat(\"template <typename T> // Templates on own line.\\n\"\n               \"static int            // Some comment.\\n\"\n               \"MyFunction(int a);\",\n               getLLVMStyle());\n}\n\nTEST_F(FormatTest, FormatsAccessModifiers) {\n  FormatStyle Style = getLLVMStyle();\n  EXPECT_EQ(Style.EmptyLineBeforeAccessModifier,\n            FormatStyle::ELBAMS_LogicalBlock);\n  verifyFormat(\"struct foo {\\n\"\n               \"private:\\n\"\n               \"  void f() {}\\n\"\n               \"\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"\\n\"\n               \"protected:\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               Style);\n  verifyFormat(\"struct foo {\\n\"\n               \"private:\\n\"\n               \"  void f() {}\\n\"\n               \"\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"\\n\"\n               \"protected:\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               \"struct foo {\\n\"\n               \"private:\\n\"\n               \"  void f() {}\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"protected:\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               Style);\n  verifyFormat(\"struct foo { /* comment */\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"  // comment\\n\"\n               \"private:\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               Style);\n  verifyFormat(\"struct foo {\\n\"\n               \"#ifdef FOO\\n\"\n               \"#endif\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"#ifdef FOO\\n\"\n               \"private:\\n\"\n               \"#endif\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               Style);\n  Style.EmptyLineBeforeAccessModifier = FormatStyle::ELBAMS_Never;\n  verifyFormat(\"struct foo {\\n\"\n               \"private:\\n\"\n               \"  void f() {}\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"protected:\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               Style);\n  verifyFormat(\"struct foo {\\n\"\n               \"private:\\n\"\n               \"  void f() {}\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"protected:\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               \"struct foo {\\n\"\n               \"\\n\"\n               \"private:\\n\"\n               \"  void f() {}\\n\"\n               \"\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"\\n\"\n               \"protected:\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               Style);\n  verifyFormat(\"struct foo { /* comment */\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"  // comment\\n\"\n               \"private:\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               \"struct foo { /* comment */\\n\"\n               \"\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"  // comment\\n\"\n               \"\\n\"\n               \"private:\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               Style);\n  verifyFormat(\"struct foo {\\n\"\n               \"#ifdef FOO\\n\"\n               \"#endif\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"#ifdef FOO\\n\"\n               \"private:\\n\"\n               \"#endif\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               \"struct foo {\\n\"\n               \"#ifdef FOO\\n\"\n               \"#endif\\n\"\n               \"\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"#ifdef FOO\\n\"\n               \"\\n\"\n               \"private:\\n\"\n               \"#endif\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               Style);\n  Style.EmptyLineBeforeAccessModifier = FormatStyle::ELBAMS_Always;\n  verifyFormat(\"struct foo {\\n\"\n               \"private:\\n\"\n               \"  void f() {}\\n\"\n               \"\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"\\n\"\n               \"protected:\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               Style);\n  verifyFormat(\"struct foo {\\n\"\n               \"private:\\n\"\n               \"  void f() {}\\n\"\n               \"\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"\\n\"\n               \"protected:\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               \"struct foo {\\n\"\n               \"private:\\n\"\n               \"  void f() {}\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"protected:\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               Style);\n  verifyFormat(\"struct foo { /* comment */\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"  // comment\\n\"\n               \"\\n\"\n               \"private:\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               \"struct foo { /* comment */\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"  // comment\\n\"\n               \"\\n\"\n               \"private:\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               Style);\n  verifyFormat(\"struct foo {\\n\"\n               \"#ifdef FOO\\n\"\n               \"#endif\\n\"\n               \"\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"#ifdef FOO\\n\"\n               \"\\n\"\n               \"private:\\n\"\n               \"#endif\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               \"struct foo {\\n\"\n               \"#ifdef FOO\\n\"\n               \"#endif\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"#ifdef FOO\\n\"\n               \"private:\\n\"\n               \"#endif\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               Style);\n  Style.EmptyLineBeforeAccessModifier = FormatStyle::ELBAMS_Leave;\n  EXPECT_EQ(\"struct foo {\\n\"\n            \"\\n\"\n            \"private:\\n\"\n            \"  void f() {}\\n\"\n            \"\\n\"\n            \"private:\\n\"\n            \"  int i;\\n\"\n            \"\\n\"\n            \"protected:\\n\"\n            \"  int j;\\n\"\n            \"};\\n\",\n            format(\"struct foo {\\n\"\n                   \"\\n\"\n                   \"private:\\n\"\n                   \"  void f() {}\\n\"\n                   \"\\n\"\n                   \"private:\\n\"\n                   \"  int i;\\n\"\n                   \"\\n\"\n                   \"protected:\\n\"\n                   \"  int j;\\n\"\n                   \"};\\n\",\n                   Style));\n  verifyFormat(\"struct foo {\\n\"\n               \"private:\\n\"\n               \"  void f() {}\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"protected:\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               Style);\n  EXPECT_EQ(\"struct foo { /* comment */\\n\"\n            \"\\n\"\n            \"private:\\n\"\n            \"  int i;\\n\"\n            \"  // comment\\n\"\n            \"\\n\"\n            \"private:\\n\"\n            \"  int j;\\n\"\n            \"};\\n\",\n            format(\"struct foo { /* comment */\\n\"\n                   \"\\n\"\n                   \"private:\\n\"\n                   \"  int i;\\n\"\n                   \"  // comment\\n\"\n                   \"\\n\"\n                   \"private:\\n\"\n                   \"  int j;\\n\"\n                   \"};\\n\",\n                   Style));\n  verifyFormat(\"struct foo { /* comment */\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"  // comment\\n\"\n               \"private:\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               Style);\n  EXPECT_EQ(\"struct foo {\\n\"\n            \"#ifdef FOO\\n\"\n            \"#endif\\n\"\n            \"\\n\"\n            \"private:\\n\"\n            \"  int i;\\n\"\n            \"#ifdef FOO\\n\"\n            \"\\n\"\n            \"private:\\n\"\n            \"#endif\\n\"\n            \"  int j;\\n\"\n            \"};\\n\",\n            format(\"struct foo {\\n\"\n                   \"#ifdef FOO\\n\"\n                   \"#endif\\n\"\n                   \"\\n\"\n                   \"private:\\n\"\n                   \"  int i;\\n\"\n                   \"#ifdef FOO\\n\"\n                   \"\\n\"\n                   \"private:\\n\"\n                   \"#endif\\n\"\n                   \"  int j;\\n\"\n                   \"};\\n\",\n                   Style));\n  verifyFormat(\"struct foo {\\n\"\n               \"#ifdef FOO\\n\"\n               \"#endif\\n\"\n               \"private:\\n\"\n               \"  int i;\\n\"\n               \"#ifdef FOO\\n\"\n               \"private:\\n\"\n               \"#endif\\n\"\n               \"  int j;\\n\"\n               \"};\\n\",\n               Style);\n}\n\nTEST_F(FormatTest, FormatsArrays) {\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaa[aaaaaaaaaaaaaaaaaaaaaaaaa]\\n\"\n               \"                         [bbbbbbbbbbbbbbbbbbbbbbbbb] = c;\");\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaa[aaaaaaaaaaa(aaaaaaaaaaaa)]\\n\"\n               \"                         [bbbbbbbbbbb(bbbbbbbbbbbb)] = c;\");\n  verifyFormat(\"if (aaaaaaaaaaaaaaaaaaaaaaaa &&\\n\"\n               \"    aaaaaaaaaaaaaaaaaaa[aaaaaaaaaaaaa][aaaaaaaaaaaaa]) {\\n}\");\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    [bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb] = ccccccccccc;\");\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    [a][bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb] = cccccccc;\");\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n               \"    [aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa]\\n\"\n               \"    [bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb] = ccccccccccc;\");\n  verifyFormat(\n      \"llvm::outs() << \\\"aaaaaaaaaaaa: \\\"\\n\"\n      \"             << (*aaaaaaaiaaaaaaa)[aaaaaaaaaaaaaaaaaaaaaaaaa]\\n\"\n      \"                                  [aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa];\");\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa[aaaaaaaaaaaaaaaaa][a]\\n\"\n               \"    .aaaaaaaaaaaaaaaaaaaaaa();\");\n\n  verifyGoogleFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<int>\\n\"\n                     \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa[aaaaaaaaaaaa];\");\n  verifyFormat(\n      \"aaaaaaaaaaa aaaaaaaaaaaaaaa = aaaaaaaaaaaaaaaaaaaaaaaaaa->aaaaaaaaa[0]\\n\"\n      \"                                  .aaaaaaa[0]\\n\"\n      \"                                  .aaaaaaaaaaaaaaaaaaaaaa();\");\n  verifyFormat(\"a[::b::c];\");\n\n  verifyNoCrash(\"a[,Y?)]\", getLLVMStyleWithColumns(10));\n\n  FormatStyle NoColumnLimit = getLLVMStyleWithColumns(0);\n  verifyFormat(\"aaaaa[bbbbbb].cccccc()\", NoColumnLimit);\n}\n\nTEST_F(FormatTest, LineStartsWithSpecialCharacter) {\n  verifyFormat(\"(a)->b();\");\n  verifyFormat(\"--a;\");\n}\n\nTEST_F(FormatTest, HandlesIncludeDirectives) {\n  verifyFormat(\"#include <string>\\n\"\n               \"#include <a/b/c.h>\\n\"\n               \"#include \\\"a/b/string\\\"\\n\"\n               \"#include \\\"string.h\\\"\\n\"\n               \"#include \\\"string.h\\\"\\n\"\n               \"#include <a-a>\\n\"\n               \"#include < path with space >\\n\"\n               \"#include_next <test.h>\"\n               \"#include \\\"abc.h\\\" // this is included for ABC\\n\"\n               \"#include \\\"some long include\\\" // with a comment\\n\"\n               \"#include \\\"some very long include path\\\"\\n\"\n               \"#include <some/very/long/include/path>\\n\",\n               getLLVMStyleWithColumns(35));\n  EXPECT_EQ(\"#include \\\"a.h\\\"\", format(\"#include  \\\"a.h\\\"\"));\n  EXPECT_EQ(\"#include <a>\", format(\"#include<a>\"));\n\n  verifyFormat(\"#import <string>\");\n  verifyFormat(\"#import <a/b/c.h>\");\n  verifyFormat(\"#import \\\"a/b/string\\\"\");\n  verifyFormat(\"#import \\\"string.h\\\"\");\n  verifyFormat(\"#import \\\"string.h\\\"\");\n  verifyFormat(\"#if __has_include(<strstream>)\\n\"\n               \"#include <strstream>\\n\"\n               \"#endif\");\n\n  verifyFormat(\"#define MY_IMPORT <a/b>\");\n\n  verifyFormat(\"#if __has_include(<a/b>)\");\n  verifyFormat(\"#if __has_include_next(<a/b>)\");\n  verifyFormat(\"#define F __has_include(<a/b>)\");\n  verifyFormat(\"#define F __has_include_next(<a/b>)\");\n\n  // Protocol buffer definition or missing \"#\".\n  verifyFormat(\"import \\\"aaaaaaaaaaaaaaaaa/aaaaaaaaaaaaaaa\\\";\",\n               getLLVMStyleWithColumns(30));\n\n  FormatStyle Style = getLLVMStyle();\n  Style.AlwaysBreakBeforeMultilineStrings = true;\n  Style.ColumnLimit = 0;\n  verifyFormat(\"#import \\\"abc.h\\\"\", Style);\n\n  // But 'import' might also be a regular C++ namespace.\n  verifyFormat(\"import::SomeFunction(aaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                     aaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\");\n}\n\n//===----------------------------------------------------------------------===//\n// Error recovery tests.\n//===----------------------------------------------------------------------===//\n\nTEST_F(FormatTest, IncompleteParameterLists) {\n  FormatStyle NoBinPacking = getLLVMStyle();\n  NoBinPacking.BinPackParameters = false;\n  verifyFormat(\"void aaaaaaaaaaaaaaaaaa(int level,\\n\"\n               \"                        double *min_x,\\n\"\n               \"                        double *max_x,\\n\"\n               \"                        double *min_y,\\n\"\n               \"                        double *max_y,\\n\"\n               \"                        double *min_z,\\n\"\n               \"                        double *max_z, ) {}\",\n               NoBinPacking);\n}\n\nTEST_F(FormatTest, IncorrectCodeTrailingStuff) {\n  verifyFormat(\"void f() { return; }\\n42\");\n  verifyFormat(\"void f() {\\n\"\n               \"  if (0)\\n\"\n               \"    return;\\n\"\n               \"}\\n\"\n               \"42\");\n  verifyFormat(\"void f() { return }\\n42\");\n  verifyFormat(\"void f() {\\n\"\n               \"  if (0)\\n\"\n               \"    return\\n\"\n               \"}\\n\"\n               \"42\");\n}\n\nTEST_F(FormatTest, IncorrectCodeMissingSemicolon) {\n  EXPECT_EQ(\"void f() { return }\", format(\"void  f ( )  {  return  }\"));\n  EXPECT_EQ(\"void f() {\\n\"\n            \"  if (a)\\n\"\n            \"    return\\n\"\n            \"}\",\n            format(\"void  f  (  )  {  if  ( a )  return  }\"));\n  EXPECT_EQ(\"namespace N {\\n\"\n            \"void f()\\n\"\n            \"}\",\n            format(\"namespace  N  {  void f()  }\"));\n  EXPECT_EQ(\"namespace N {\\n\"\n            \"void f() {}\\n\"\n            \"void g()\\n\"\n            \"} // namespace N\",\n            format(\"namespace N  { void f( ) { } void g( ) }\"));\n}\n\nTEST_F(FormatTest, IndentationWithinColumnLimitNotPossible) {\n  verifyFormat(\"int aaaaaaaa =\\n\"\n               \"    // Overlylongcomment\\n\"\n               \"    b;\",\n               getLLVMStyleWithColumns(20));\n  verifyFormat(\"function(\\n\"\n               \"    ShortArgument,\\n\"\n               \"    LoooooooooooongArgument);\\n\",\n               getLLVMStyleWithColumns(20));\n}\n\nTEST_F(FormatTest, IncorrectAccessSpecifier) {\n  verifyFormat(\"public:\");\n  verifyFormat(\"class A {\\n\"\n               \"public\\n\"\n               \"  void f() {}\\n\"\n               \"};\");\n  verifyFormat(\"public\\n\"\n               \"int qwerty;\");\n  verifyFormat(\"public\\n\"\n               \"B {}\");\n  verifyFormat(\"public\\n\"\n               \"{}\");\n  verifyFormat(\"public\\n\"\n               \"B { int x; }\");\n}\n\nTEST_F(FormatTest, IncorrectCodeUnbalancedBraces) {\n  verifyFormat(\"{\");\n  verifyFormat(\"#})\");\n  verifyNoCrash(\"(/**/[:!] ?[).\");\n}\n\nTEST_F(FormatTest, IncorrectUnbalancedBracesInMacrosWithUnicode) {\n  // Found by oss-fuzz:\n  // https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=8212\n  FormatStyle Style = getGoogleStyle(FormatStyle::LK_Cpp);\n  Style.ColumnLimit = 60;\n  verifyNoCrash(\n      \"\\x23\\x47\\xff\\x20\\x28\\xff\\x3c\\xff\\x3f\\xff\\x20\\x2f\\x7b\\x7a\\xff\\x20\"\n      \"\\xff\\xff\\xff\\xca\\xb5\\xff\\xff\\xff\\xff\\x3a\\x7b\\x7d\\xff\\x20\\xff\\x20\"\n      \"\\xff\\x74\\xff\\x20\\x7d\\x7d\\xff\\x7b\\x3a\\xff\\x20\\x71\\xff\\x20\\xff\\x0a\",\n      Style);\n}\n\nTEST_F(FormatTest, IncorrectCodeDoNoWhile) {\n  verifyFormat(\"do {\\n}\");\n  verifyFormat(\"do {\\n}\\n\"\n               \"f();\");\n  verifyFormat(\"do {\\n}\\n\"\n               \"wheeee(fun);\");\n  verifyFormat(\"do {\\n\"\n               \"  f();\\n\"\n               \"}\");\n}\n\nTEST_F(FormatTest, IncorrectCodeMissingParens) {\n  verifyFormat(\"if {\\n  foo;\\n  foo();\\n}\");\n  verifyFormat(\"switch {\\n  foo;\\n  foo();\\n}\");\n  verifyIncompleteFormat(\"for {\\n  foo;\\n  foo();\\n}\");\n  verifyFormat(\"while {\\n  foo;\\n  foo();\\n}\");\n  verifyFormat(\"do {\\n  foo;\\n  foo();\\n} while;\");\n}\n\nTEST_F(FormatTest, DoesNotTouchUnwrappedLinesWithErrors) {\n  verifyIncompleteFormat(\"namespace {\\n\"\n                         \"class Foo { Foo (\\n\"\n                         \"};\\n\"\n                         \"} // namespace\");\n}\n\nTEST_F(FormatTest, IncorrectCodeErrorDetection) {\n  EXPECT_EQ(\"{\\n  {}\\n\", format(\"{\\n{\\n}\\n\"));\n  EXPECT_EQ(\"{\\n  {}\\n\", format(\"{\\n  {\\n}\\n\"));\n  EXPECT_EQ(\"{\\n  {}\\n\", format(\"{\\n  {\\n  }\\n\"));\n  EXPECT_EQ(\"{\\n  {}\\n}\\n}\\n\", format(\"{\\n  {\\n    }\\n  }\\n}\\n\"));\n\n  EXPECT_EQ(\"{\\n\"\n            \"  {\\n\"\n            \"    breakme(\\n\"\n            \"        qwe);\\n\"\n            \"  }\\n\",\n            format(\"{\\n\"\n                   \"    {\\n\"\n                   \" breakme(qwe);\\n\"\n                   \"}\\n\",\n                   getLLVMStyleWithColumns(10)));\n}\n\nTEST_F(FormatTest, LayoutCallsInsideBraceInitializers) {\n  verifyFormat(\"int x = {\\n\"\n               \"    avariable,\\n\"\n               \"    b(alongervariable)};\",\n               getLLVMStyleWithColumns(25));\n}\n\nTEST_F(FormatTest, LayoutBraceInitializersInReturnStatement) {\n  verifyFormat(\"return (a)(b){1, 2, 3};\");\n}\n\nTEST_F(FormatTest, LayoutCxx11BraceInitializers) {\n  verifyFormat(\"vector<int> x{1, 2, 3, 4};\");\n  verifyFormat(\"vector<int> x{\\n\"\n               \"    1,\\n\"\n               \"    2,\\n\"\n               \"    3,\\n\"\n               \"    4,\\n\"\n               \"};\");\n  verifyFormat(\"vector<T> x{{}, {}, {}, {}};\");\n  verifyFormat(\"f({1, 2});\");\n  verifyFormat(\"auto v = Foo{-1};\");\n  verifyFormat(\"f({1, 2}, {{2, 3}, {4, 5}}, c, {d});\");\n  verifyFormat(\"Class::Class : member{1, 2, 3} {}\");\n  verifyFormat(\"new vector<int>{1, 2, 3};\");\n  verifyFormat(\"new int[3]{1, 2, 3};\");\n  verifyFormat(\"new int{1};\");\n  verifyFormat(\"return {arg1, arg2};\");\n  verifyFormat(\"return {arg1, SomeType{parameter}};\");\n  verifyFormat(\"int count = set<int>{f(), g(), h()}.size();\");\n  verifyFormat(\"new T{arg1, arg2};\");\n  verifyFormat(\"f(MyMap[{composite, key}]);\");\n  verifyFormat(\"class Class {\\n\"\n               \"  T member = {arg1, arg2};\\n\"\n               \"};\");\n  verifyFormat(\"vector<int> foo = {::SomeGlobalFunction()};\");\n  verifyFormat(\"const struct A a = {.a = 1, .b = 2};\");\n  verifyFormat(\"const struct A a = {[0] = 1, [1] = 2};\");\n  verifyFormat(\"static_assert(std::is_integral<int>{} + 0, \\\"\\\");\");\n  verifyFormat(\"int a = std::is_integral<int>{} + 0;\");\n\n  verifyFormat(\"int foo(int i) { return fo1{}(i); }\");\n  verifyFormat(\"int foo(int i) { return fo1{}(i); }\");\n  verifyFormat(\"auto i = decltype(x){};\");\n  verifyFormat(\"auto i = typeof(x){};\");\n  verifyFormat(\"auto i = _Atomic(x){};\");\n  verifyFormat(\"std::vector<int> v = {1, 0 /* comment */};\");\n  verifyFormat(\"Node n{1, Node{1000}, //\\n\"\n               \"       2};\");\n  verifyFormat(\"Aaaa aaaaaaa{\\n\"\n               \"    {\\n\"\n               \"        aaaa,\\n\"\n               \"    },\\n\"\n               \"};\");\n  verifyFormat(\"class C : public D {\\n\"\n               \"  SomeClass SC{2};\\n\"\n               \"};\");\n  verifyFormat(\"class C : public A {\\n\"\n               \"  class D : public B {\\n\"\n               \"    void f() { int i{2}; }\\n\"\n               \"  };\\n\"\n               \"};\");\n  verifyFormat(\"#define A {a, a},\");\n\n  // Avoid breaking between equal sign and opening brace\n  FormatStyle AvoidBreakingFirstArgument = getLLVMStyle();\n  AvoidBreakingFirstArgument.PenaltyBreakBeforeFirstCallParameter = 200;\n  verifyFormat(\"const std::unordered_map<std::string, int> MyHashTable =\\n\"\n               \"    {{\\\"aaaaaaaaaaaaaaaaaaaaa\\\", 0},\\n\"\n               \"     {\\\"bbbbbbbbbbbbbbbbbbbbb\\\", 1},\\n\"\n               \"     {\\\"ccccccccccccccccccccc\\\", 2}};\",\n               AvoidBreakingFirstArgument);\n\n  // Binpacking only if there is no trailing comma\n  verifyFormat(\"const Aaaaaa aaaaa = {aaaaaaaaaa, bbbbbbbbbb,\\n\"\n               \"                      cccccccccc, dddddddddd};\",\n               getLLVMStyleWithColumns(50));\n  verifyFormat(\"const Aaaaaa aaaaa = {\\n\"\n               \"    aaaaaaaaaaa,\\n\"\n               \"    bbbbbbbbbbb,\\n\"\n               \"    ccccccccccc,\\n\"\n               \"    ddddddddddd,\\n\"\n               \"};\",\n               getLLVMStyleWithColumns(50));\n\n  // Cases where distinguising braced lists and blocks is hard.\n  verifyFormat(\"vector<int> v{12} GUARDED_BY(mutex);\");\n  verifyFormat(\"void f() {\\n\"\n               \"  return; // comment\\n\"\n               \"}\\n\"\n               \"SomeType t;\");\n  verifyFormat(\"void f() {\\n\"\n               \"  if (a) {\\n\"\n               \"    f();\\n\"\n               \"  }\\n\"\n               \"}\\n\"\n               \"SomeType t;\");\n\n  // In combination with BinPackArguments = false.\n  FormatStyle NoBinPacking = getLLVMStyle();\n  NoBinPacking.BinPackArguments = false;\n  verifyFormat(\"const Aaaaaa aaaaa = {aaaaa,\\n\"\n               \"                      bbbbb,\\n\"\n               \"                      ccccc,\\n\"\n               \"                      ddddd,\\n\"\n               \"                      eeeee,\\n\"\n               \"                      ffffff,\\n\"\n               \"                      ggggg,\\n\"\n               \"                      hhhhhh,\\n\"\n               \"                      iiiiii,\\n\"\n               \"                      jjjjjj,\\n\"\n               \"                      kkkkkk};\",\n               NoBinPacking);\n  verifyFormat(\"const Aaaaaa aaaaa = {\\n\"\n               \"    aaaaa,\\n\"\n               \"    bbbbb,\\n\"\n               \"    ccccc,\\n\"\n               \"    ddddd,\\n\"\n               \"    eeeee,\\n\"\n               \"    ffffff,\\n\"\n               \"    ggggg,\\n\"\n               \"    hhhhhh,\\n\"\n               \"    iiiiii,\\n\"\n               \"    jjjjjj,\\n\"\n               \"    kkkkkk,\\n\"\n               \"};\",\n               NoBinPacking);\n  verifyFormat(\n      \"const Aaaaaa aaaaa = {\\n\"\n      \"    aaaaa,  bbbbb,  ccccc,  ddddd,  eeeee,  ffffff, ggggg, hhhhhh,\\n\"\n      \"    iiiiii, jjjjjj, kkkkkk, aaaaa,  bbbbb,  ccccc,  ddddd, eeeee,\\n\"\n      \"    ffffff, ggggg,  hhhhhh, iiiiii, jjjjjj, kkkkkk,\\n\"\n      \"};\",\n      NoBinPacking);\n\n  NoBinPacking.AlignAfterOpenBracket = FormatStyle::BAS_AlwaysBreak;\n  EXPECT_EQ(\"static uint8 CddDp83848Reg[] = {\\n\"\n            \"    CDDDP83848_BMCR_REGISTER,\\n\"\n            \"    CDDDP83848_BMSR_REGISTER,\\n\"\n            \"    CDDDP83848_RBR_REGISTER};\",\n            format(\"static uint8 CddDp83848Reg[] = {CDDDP83848_BMCR_REGISTER,\\n\"\n                   \"                                CDDDP83848_BMSR_REGISTER,\\n\"\n                   \"                                CDDDP83848_RBR_REGISTER};\",\n                   NoBinPacking));\n\n  // FIXME: The alignment of these trailing comments might be bad. Then again,\n  // this might be utterly useless in real code.\n  verifyFormat(\"Constructor::Constructor()\\n\"\n               \"    : some_value{         //\\n\"\n               \"                 aaaaaaa, //\\n\"\n               \"                 bbbbbbb} {}\");\n\n  // In braced lists, the first comment is always assumed to belong to the\n  // first element. Thus, it can be moved to the next or previous line as\n  // appropriate.\n  EXPECT_EQ(\"function({// First element:\\n\"\n            \"          1,\\n\"\n            \"          // Second element:\\n\"\n            \"          2});\",\n            format(\"function({\\n\"\n                   \"    // First element:\\n\"\n                   \"    1,\\n\"\n                   \"    // Second element:\\n\"\n                   \"    2});\"));\n  EXPECT_EQ(\"std::vector<int> MyNumbers{\\n\"\n            \"    // First element:\\n\"\n            \"    1,\\n\"\n            \"    // Second element:\\n\"\n            \"    2};\",\n            format(\"std::vector<int> MyNumbers{// First element:\\n\"\n                   \"                           1,\\n\"\n                   \"                           // Second element:\\n\"\n                   \"                           2};\",\n                   getLLVMStyleWithColumns(30)));\n  // A trailing comma should still lead to an enforced line break and no\n  // binpacking.\n  EXPECT_EQ(\"vector<int> SomeVector = {\\n\"\n            \"    // aaa\\n\"\n            \"    1,\\n\"\n            \"    2,\\n\"\n            \"};\",\n            format(\"vector<int> SomeVector = { // aaa\\n\"\n                   \"    1, 2, };\"));\n\n  // C++11 brace initializer list l-braces should not be treated any differently\n  // when breaking before lambda bodies is enabled\n  FormatStyle BreakBeforeLambdaBody = getLLVMStyle();\n  BreakBeforeLambdaBody.BreakBeforeBraces = FormatStyle::BS_Custom;\n  BreakBeforeLambdaBody.BraceWrapping.BeforeLambdaBody = true;\n  BreakBeforeLambdaBody.AlwaysBreakBeforeMultilineStrings = true;\n  verifyFormat(\n      \"std::runtime_error{\\n\"\n      \"    \\\"Long string which will force a break onto the next line...\\\"};\",\n      BreakBeforeLambdaBody);\n\n  FormatStyle ExtraSpaces = getLLVMStyle();\n  ExtraSpaces.Cpp11BracedListStyle = false;\n  ExtraSpaces.ColumnLimit = 75;\n  verifyFormat(\"vector<int> x{ 1, 2, 3, 4 };\", ExtraSpaces);\n  verifyFormat(\"vector<T> x{ {}, {}, {}, {} };\", ExtraSpaces);\n  verifyFormat(\"f({ 1, 2 });\", ExtraSpaces);\n  verifyFormat(\"auto v = Foo{ 1 };\", ExtraSpaces);\n  verifyFormat(\"f({ 1, 2 }, { { 2, 3 }, { 4, 5 } }, c, { d });\", ExtraSpaces);\n  verifyFormat(\"Class::Class : member{ 1, 2, 3 } {}\", ExtraSpaces);\n  verifyFormat(\"new vector<int>{ 1, 2, 3 };\", ExtraSpaces);\n  verifyFormat(\"new int[3]{ 1, 2, 3 };\", ExtraSpaces);\n  verifyFormat(\"return { arg1, arg2 };\", ExtraSpaces);\n  verifyFormat(\"return { arg1, SomeType{ parameter } };\", ExtraSpaces);\n  verifyFormat(\"int count = set<int>{ f(), g(), h() }.size();\", ExtraSpaces);\n  verifyFormat(\"new T{ arg1, arg2 };\", ExtraSpaces);\n  verifyFormat(\"f(MyMap[{ composite, key }]);\", ExtraSpaces);\n  verifyFormat(\"class Class {\\n\"\n               \"  T member = { arg1, arg2 };\\n\"\n               \"};\",\n               ExtraSpaces);\n  verifyFormat(\n      \"foo = aaaaaaaaaaa ? vector<int>{ aaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"                                 aaaaaaaaaaaaaaaaaaaa, aaaaa }\\n\"\n      \"                  : vector<int>{ bbbbbbbbbbbbbbbbbbbbbbbbbbb,\\n\"\n      \"                                 bbbbbbbbbbbbbbbbbbbb, bbbbb };\",\n      ExtraSpaces);\n  verifyFormat(\"DoSomethingWithVector({} /* No data */);\", ExtraSpaces);\n  verifyFormat(\"DoSomethingWithVector({ {} /* No data */ }, { { 1, 2 } });\",\n               ExtraSpaces);\n  verifyFormat(\n      \"someFunction(OtherParam,\\n\"\n      \"             BracedList{ // comment 1 (Forcing interesting break)\\n\"\n      \"                         param1, param2,\\n\"\n      \"                         // comment 2\\n\"\n      \"                         param3, param4 });\",\n      ExtraSpaces);\n  verifyFormat(\n      \"std::this_thread::sleep_for(\\n\"\n      \"    std::chrono::nanoseconds{ std::chrono::seconds{ 1 } } / 5);\",\n      ExtraSpaces);\n  verifyFormat(\"std::vector<MyValues> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa{\\n\"\n               \"    aaaaaaa,\\n\"\n               \"    aaaaaaaaaa,\\n\"\n               \"    aaaaa,\\n\"\n               \"    aaaaaaaaaaaaaaa,\\n\"\n               \"    aaa,\\n\"\n               \"    aaaaaaaaaa,\\n\"\n               \"    a,\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    aaaaaaaaaaaa,\\n\"\n               \"    aaaaaaaaaaaaaaaaaaa + aaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    aaaaaaa,\\n\"\n               \"    a};\");\n  verifyFormat(\"vector<int> foo = { ::SomeGlobalFunction() };\", ExtraSpaces);\n  verifyFormat(\"const struct A a = { .a = 1, .b = 2 };\", ExtraSpaces);\n  verifyFormat(\"const struct A a = { [0] = 1, [1] = 2 };\", ExtraSpaces);\n\n  // Avoid breaking between initializer/equal sign and opening brace\n  ExtraSpaces.PenaltyBreakBeforeFirstCallParameter = 200;\n  verifyFormat(\"const std::unordered_map<std::string, int> MyHashTable = {\\n\"\n               \"  { \\\"aaaaaaaaaaaaaaaaaaaaa\\\", 0 },\\n\"\n               \"  { \\\"bbbbbbbbbbbbbbbbbbbbb\\\", 1 },\\n\"\n               \"  { \\\"ccccccccccccccccccccc\\\", 2 }\\n\"\n               \"};\",\n               ExtraSpaces);\n  verifyFormat(\"const std::unordered_map<std::string, int> MyHashTable{\\n\"\n               \"  { \\\"aaaaaaaaaaaaaaaaaaaaa\\\", 0 },\\n\"\n               \"  { \\\"bbbbbbbbbbbbbbbbbbbbb\\\", 1 },\\n\"\n               \"  { \\\"ccccccccccccccccccccc\\\", 2 }\\n\"\n               \"};\",\n               ExtraSpaces);\n\n  FormatStyle SpaceBeforeBrace = getLLVMStyle();\n  SpaceBeforeBrace.SpaceBeforeCpp11BracedList = true;\n  verifyFormat(\"vector<int> x {1, 2, 3, 4};\", SpaceBeforeBrace);\n  verifyFormat(\"f({}, {{}, {}}, MyMap[{k, v}]);\", SpaceBeforeBrace);\n\n  FormatStyle SpaceBetweenBraces = getLLVMStyle();\n  SpaceBetweenBraces.SpacesInAngles = true;\n  SpaceBetweenBraces.SpacesInParentheses = true;\n  SpaceBetweenBraces.SpacesInSquareBrackets = true;\n  verifyFormat(\"vector< int > x{ 1, 2, 3, 4 };\", SpaceBetweenBraces);\n  verifyFormat(\"f( {}, { {}, {} }, MyMap[ { k, v } ] );\", SpaceBetweenBraces);\n  verifyFormat(\"vector< int > x{ // comment 1\\n\"\n               \"                 1, 2, 3, 4 };\",\n               SpaceBetweenBraces);\n  SpaceBetweenBraces.ColumnLimit = 20;\n  EXPECT_EQ(\"vector< int > x{\\n\"\n            \"    1, 2, 3, 4 };\",\n            format(\"vector<int>x{1,2,3,4};\", SpaceBetweenBraces));\n  SpaceBetweenBraces.ColumnLimit = 24;\n  EXPECT_EQ(\"vector< int > x{ 1, 2,\\n\"\n            \"                 3, 4 };\",\n            format(\"vector<int>x{1,2,3,4};\", SpaceBetweenBraces));\n  EXPECT_EQ(\"vector< int > x{\\n\"\n            \"    1,\\n\"\n            \"    2,\\n\"\n            \"    3,\\n\"\n            \"    4,\\n\"\n            \"};\",\n            format(\"vector<int>x{1,2,3,4,};\", SpaceBetweenBraces));\n  verifyFormat(\"vector< int > x{};\", SpaceBetweenBraces);\n  SpaceBetweenBraces.SpaceInEmptyParentheses = true;\n  verifyFormat(\"vector< int > x{ };\", SpaceBetweenBraces);\n}\n\nTEST_F(FormatTest, FormatSpacesInAngles) {\n  FormatStyle SpaceInAngles = getLLVMStyle();\n  SpaceInAngles.SpacesInAngles = true;\n  verifyFormat(\"vector< ::std::string > x1;\", SpaceInAngles);\n  verifyFormat(\"Foo< int, Bar > x2;\", SpaceInAngles);\n  verifyFormat(\"Foo< ::int, ::Bar > x3;\", SpaceInAngles);\n\n  SpaceInAngles.SpacesInAngles = false;\n  verifyFormat(\"vector<::std::string> x4;\", SpaceInAngles);\n  verifyFormat(\"vector<int> x5;\", SpaceInAngles);\n  verifyFormat(\"Foo<int, Bar> x6;\", SpaceInAngles);\n  verifyFormat(\"Foo<::int, ::Bar> x7;\", SpaceInAngles);\n}\n\nTEST_F(FormatTest, FormatsBracedListsInColumnLayout) {\n  verifyFormat(\"vector<int> x = {1, 22, 333, 4444, 55555, 666666, 7777777,\\n\"\n               \"                 1, 22, 333, 4444, 55555, 666666, 7777777,\\n\"\n               \"                 1, 22, 333, 4444, 55555, 666666, 7777777,\\n\"\n               \"                 1, 22, 333, 4444, 55555, 666666, 7777777,\\n\"\n               \"                 1, 22, 333, 4444, 55555, 666666, 7777777,\\n\"\n               \"                 1, 22, 333, 4444, 55555, 666666, 7777777};\");\n  verifyFormat(\"vector<int> x = {1, 22, 333, 4444, 55555, 666666, 7777777, //\\n\"\n               \"                 1, 22, 333, 4444, 55555, 666666, 7777777,\\n\"\n               \"                 1, 22, 333, 4444, 55555, //\\n\"\n               \"                 1, 22, 333, 4444, 55555, 666666, 7777777,\\n\"\n               \"                 1, 22, 333, 4444, 55555, 666666, 7777777};\");\n  verifyFormat(\n      \"vector<int> x = {1,       22, 333, 4444, 55555, 666666, 7777777,\\n\"\n      \"                 1,       22, 333, 4444, 55555, 666666, 7777777,\\n\"\n      \"                 1,       22, 333, 4444, 55555, 666666, // comment\\n\"\n      \"                 7777777, 1,  22,  333,  4444,  55555,  666666,\\n\"\n      \"                 7777777, 1,  22,  333,  4444,  55555,  666666,\\n\"\n      \"                 7777777, 1,  22,  333,  4444,  55555,  666666,\\n\"\n      \"                 7777777};\");\n  verifyFormat(\"static const uint16_t CallerSavedRegs64Bittttt[] = {\\n\"\n               \"    X86::RAX, X86::RDX, X86::RCX, X86::RSI, X86::RDI,\\n\"\n               \"    X86::R8,  X86::R9,  X86::R10, X86::R11, 0};\");\n  verifyFormat(\"static const uint16_t CallerSavedRegs64Bittttt[] = {\\n\"\n               \"    X86::RAX, X86::RDX, X86::RCX, X86::RSI, X86::RDI,\\n\"\n               \"    // Separating comment.\\n\"\n               \"    X86::R8, X86::R9, X86::R10, X86::R11, 0};\");\n  verifyFormat(\"static const uint16_t CallerSavedRegs64Bittttt[] = {\\n\"\n               \"    // Leading comment\\n\"\n               \"    X86::RAX, X86::RDX, X86::RCX, X86::RSI, X86::RDI,\\n\"\n               \"    X86::R8,  X86::R9,  X86::R10, X86::R11, 0};\");\n  verifyFormat(\"vector<int> x = {1, 1, 1, 1,\\n\"\n               \"                 1, 1, 1, 1};\",\n               getLLVMStyleWithColumns(39));\n  verifyFormat(\"vector<int> x = {1, 1, 1, 1,\\n\"\n               \"                 1, 1, 1, 1};\",\n               getLLVMStyleWithColumns(38));\n  verifyFormat(\"vector<int> aaaaaaaaaaaaaaaaaaaaaa = {\\n\"\n               \"    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\",\n               getLLVMStyleWithColumns(43));\n  verifyFormat(\n      \"static unsigned SomeValues[10][3] = {\\n\"\n      \"    {1, 4, 0},  {4, 9, 0},  {4, 5, 9},  {8, 5, 4}, {1, 8, 4},\\n\"\n      \"    {10, 1, 6}, {11, 0, 9}, {2, 11, 9}, {5, 2, 9}, {11, 2, 7}};\");\n  verifyFormat(\"static auto fields = new vector<string>{\\n\"\n               \"    \\\"aaaaaaaaaaaaa\\\",\\n\"\n               \"    \\\"aaaaaaaaaaaaa\\\",\\n\"\n               \"    \\\"aaaaaaaaaaaa\\\",\\n\"\n               \"    \\\"aaaaaaaaaaaaaa\\\",\\n\"\n               \"    \\\"aaaaaaaaaaaaaaaaaaaaaaaaa\\\",\\n\"\n               \"    \\\"aaaaaaaaaaaa\\\",\\n\"\n               \"    \\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\",\\n\"\n               \"};\");\n  verifyFormat(\"vector<int> x = {1, 2, 3, 4, aaaaaaaaaaaaaaaaa, 6};\");\n  verifyFormat(\"vector<int> x = {1, aaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"                 2, bbbbbbbbbbbbbbbbbbbbbb,\\n\"\n               \"                 3, cccccccccccccccccccccc};\",\n               getLLVMStyleWithColumns(60));\n\n  // Trailing commas.\n  verifyFormat(\"vector<int> x = {\\n\"\n               \"    1, 1, 1, 1, 1, 1, 1, 1,\\n\"\n               \"};\",\n               getLLVMStyleWithColumns(39));\n  verifyFormat(\"vector<int> x = {\\n\"\n               \"    1, 1, 1, 1, 1, 1, 1, 1, //\\n\"\n               \"};\",\n               getLLVMStyleWithColumns(39));\n  verifyFormat(\"vector<int> x = {1, 1, 1, 1,\\n\"\n               \"                 1, 1, 1, 1,\\n\"\n               \"                 /**/ /**/};\",\n               getLLVMStyleWithColumns(39));\n\n  // Trailing comment in the first line.\n  verifyFormat(\"vector<int> iiiiiiiiiiiiiii = {                      //\\n\"\n               \"    1111111111, 2222222222, 33333333333, 4444444444, //\\n\"\n               \"    111111111,  222222222,  3333333333,  444444444,  //\\n\"\n               \"    11111111,   22222222,   333333333,   44444444};\");\n  // Trailing comment in the last line.\n  verifyFormat(\"int aaaaa[] = {\\n\"\n               \"    1, 2, 3, // comment\\n\"\n               \"    4, 5, 6  // comment\\n\"\n               \"};\");\n\n  // With nested lists, we should either format one item per line or all nested\n  // lists one on line.\n  // FIXME: For some nested lists, we can do better.\n  verifyFormat(\"return {{aaaaaaaaaaaaaaaaaaaaa},\\n\"\n               \"        {aaaaaaaaaaaaaaaaaaa},\\n\"\n               \"        {aaaaaaaaaaaaaaaaaaaaa},\\n\"\n               \"        {aaaaaaaaaaaaaaaaa}};\",\n               getLLVMStyleWithColumns(60));\n  verifyFormat(\n      \"SomeStruct my_struct_array = {\\n\"\n      \"    {aaaaaa, aaaaaaaa, aaaaaaaaaa, aaaaaaaaa, aaaaaaaaa, aaaaaaaaaa,\\n\"\n      \"     aaaaaaaaaaaaa, aaaaaaa, aaa},\\n\"\n      \"    {aaa, aaa},\\n\"\n      \"    {aaa, aaa},\\n\"\n      \"    {aaaa, aaaa, aaaa, aaaa, aaaa, aaaa, aaaa, aaa},\\n\"\n      \"    {aaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"     aaaaaaaaaaaa, a, aaaaaaaaaa, aaaaaaaaa, aaa}};\");\n\n  // No column layout should be used here.\n  verifyFormat(\"aaaaaaaaaaaaaaa = {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, 0, 0,\\n\"\n               \"                   bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb};\");\n\n  verifyNoCrash(\"a<,\");\n\n  // No braced initializer here.\n  verifyFormat(\"void f() {\\n\"\n               \"  struct Dummy {};\\n\"\n               \"  f(v);\\n\"\n               \"}\");\n\n  // Long lists should be formatted in columns even if they are nested.\n  verifyFormat(\n      \"vector<int> x = function({1, 22, 333, 4444, 55555, 666666, 7777777,\\n\"\n      \"                          1, 22, 333, 4444, 55555, 666666, 7777777,\\n\"\n      \"                          1, 22, 333, 4444, 55555, 666666, 7777777,\\n\"\n      \"                          1, 22, 333, 4444, 55555, 666666, 7777777,\\n\"\n      \"                          1, 22, 333, 4444, 55555, 666666, 7777777,\\n\"\n      \"                          1, 22, 333, 4444, 55555, 666666, 7777777});\");\n\n  // Allow \"single-column\" layout even if that violates the column limit. There\n  // isn't going to be a better way.\n  verifyFormat(\"std::vector<int> a = {\\n\"\n               \"    aaaaaaaa,\\n\"\n               \"    aaaaaaaa,\\n\"\n               \"    aaaaaaaa,\\n\"\n               \"    aaaaaaaa,\\n\"\n               \"    aaaaaaaaaa,\\n\"\n               \"    aaaaaaaa,\\n\"\n               \"    aaaaaaaaaaaaaaaaaaaaaaaaaaa};\",\n               getLLVMStyleWithColumns(30));\n  verifyFormat(\"vector<int> aaaa = {\\n\"\n               \"    aaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    aaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\\n\"\n               \"    aaaaaa.aaaaaaa,\\n\"\n               \"    aaaaaa.aaaaaaa,\\n\"\n               \"    aaaaaa.aaaaaaa,\\n\"\n               \"    aaaaaa.aaaaaaa,\\n\"\n               \"};\");\n\n  // Don't create hanging lists.\n  verifyFormat(\"someFunction(Param, {List1, List2,\\n\"\n               \"                     List3});\",\n               getLLVMStyleWithColumns(35));\n  verifyFormat(\"someFunction(Param, Param,\\n\"\n               \"             {List1, List2,\\n\"\n               \"              List3});\",\n               getLLVMStyleWithColumns(35));\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaa, {},\\n\"\n               \"                               aaaaaaaaaaaaaaaaaaaaaaa);\");\n}\n\nTEST_F(FormatTest, PullTrivialFunctionDefinitionsIntoSingleLine) {\n  FormatStyle DoNotMerge = getLLVMStyle();\n  DoNotMerge.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_None;\n\n  verifyFormat(\"void f() { return 42; }\");\n  verifyFormat(\"void f() {\\n\"\n               \"  return 42;\\n\"\n               \"}\",\n               DoNotMerge);\n  verifyFormat(\"void f() {\\n\"\n               \"  // Comment\\n\"\n               \"}\");\n  verifyFormat(\"{\\n\"\n               \"#error {\\n\"\n               \"  int a;\\n\"\n               \"}\");\n  verifyFormat(\"{\\n\"\n               \"  int a;\\n\"\n               \"#error {\\n\"\n               \"}\");\n  verifyFormat(\"void f() {} // comment\");\n  verifyFormat(\"void f() { int a; } // comment\");\n  verifyFormat(\"void f() {\\n\"\n               \"} // comment\",\n               DoNotMerge);\n  verifyFormat(\"void f() {\\n\"\n               \"  int a;\\n\"\n               \"} // comment\",\n               DoNotMerge);\n  verifyFormat(\"void f() {\\n\"\n               \"} // comment\",\n               getLLVMStyleWithColumns(15));\n\n  verifyFormat(\"void f() { return 42; }\", getLLVMStyleWithColumns(23));\n  verifyFormat(\"void f() {\\n  return 42;\\n}\", getLLVMStyleWithColumns(22));\n\n  verifyFormat(\"void f() {}\", getLLVMStyleWithColumns(11));\n  verifyFormat(\"void f() {\\n}\", getLLVMStyleWithColumns(10));\n  verifyFormat(\"class C {\\n\"\n               \"  C()\\n\"\n               \"      : iiiiiiii(nullptr),\\n\"\n               \"        kkkkkkk(nullptr),\\n\"\n               \"        mmmmmmm(nullptr),\\n\"\n               \"        nnnnnnn(nullptr) {}\\n\"\n               \"};\",\n               getGoogleStyle());\n\n  FormatStyle NoColumnLimit = getLLVMStyle();\n  NoColumnLimit.ColumnLimit = 0;\n  EXPECT_EQ(\"A() : b(0) {}\", format(\"A():b(0){}\", NoColumnLimit));\n  EXPECT_EQ(\"class C {\\n\"\n            \"  A() : b(0) {}\\n\"\n            \"};\",\n            format(\"class C{A():b(0){}};\", NoColumnLimit));\n  EXPECT_EQ(\"A()\\n\"\n            \"    : b(0) {\\n\"\n            \"}\",\n            format(\"A()\\n:b(0)\\n{\\n}\", NoColumnLimit));\n\n  FormatStyle DoNotMergeNoColumnLimit = NoColumnLimit;\n  DoNotMergeNoColumnLimit.AllowShortFunctionsOnASingleLine =\n      FormatStyle::SFS_None;\n  EXPECT_EQ(\"A()\\n\"\n            \"    : b(0) {\\n\"\n            \"}\",\n            format(\"A():b(0){}\", DoNotMergeNoColumnLimit));\n  EXPECT_EQ(\"A()\\n\"\n            \"    : b(0) {\\n\"\n            \"}\",\n            format(\"A()\\n:b(0)\\n{\\n}\", DoNotMergeNoColumnLimit));\n\n  verifyFormat(\"#define A          \\\\\\n\"\n               \"  void f() {       \\\\\\n\"\n               \"    int i;         \\\\\\n\"\n               \"  }\",\n               getLLVMStyleWithColumns(20));\n  verifyFormat(\"#define A           \\\\\\n\"\n               \"  void f() { int i; }\",\n               getLLVMStyleWithColumns(21));\n  verifyFormat(\"#define A            \\\\\\n\"\n               \"  void f() {         \\\\\\n\"\n               \"    int i;           \\\\\\n\"\n               \"  }                  \\\\\\n\"\n               \"  int j;\",\n               getLLVMStyleWithColumns(22));\n  verifyFormat(\"#define A             \\\\\\n\"\n               \"  void f() { int i; } \\\\\\n\"\n               \"  int j;\",\n               getLLVMStyleWithColumns(23));\n}\n\nTEST_F(FormatTest, PullEmptyFunctionDefinitionsIntoSingleLine) {\n  FormatStyle MergeEmptyOnly = getLLVMStyle();\n  MergeEmptyOnly.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_Empty;\n  verifyFormat(\"class C {\\n\"\n               \"  int f() {}\\n\"\n               \"};\",\n               MergeEmptyOnly);\n  verifyFormat(\"class C {\\n\"\n               \"  int f() {\\n\"\n               \"    return 42;\\n\"\n               \"  }\\n\"\n               \"};\",\n               MergeEmptyOnly);\n  verifyFormat(\"int f() {}\", MergeEmptyOnly);\n  verifyFormat(\"int f() {\\n\"\n               \"  return 42;\\n\"\n               \"}\",\n               MergeEmptyOnly);\n\n  // Also verify behavior when BraceWrapping.AfterFunction = true\n  MergeEmptyOnly.BreakBeforeBraces = FormatStyle::BS_Custom;\n  MergeEmptyOnly.BraceWrapping.AfterFunction = true;\n  verifyFormat(\"int f() {}\", MergeEmptyOnly);\n  verifyFormat(\"class C {\\n\"\n               \"  int f() {}\\n\"\n               \"};\",\n               MergeEmptyOnly);\n}\n\nTEST_F(FormatTest, PullInlineFunctionDefinitionsIntoSingleLine) {\n  FormatStyle MergeInlineOnly = getLLVMStyle();\n  MergeInlineOnly.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_Inline;\n  verifyFormat(\"class C {\\n\"\n               \"  int f() { return 42; }\\n\"\n               \"};\",\n               MergeInlineOnly);\n  verifyFormat(\"int f() {\\n\"\n               \"  return 42;\\n\"\n               \"}\",\n               MergeInlineOnly);\n\n  // SFS_Inline implies SFS_Empty\n  verifyFormat(\"class C {\\n\"\n               \"  int f() {}\\n\"\n               \"};\",\n               MergeInlineOnly);\n  verifyFormat(\"int f() {}\", MergeInlineOnly);\n\n  // Also verify behavior when BraceWrapping.AfterFunction = true\n  MergeInlineOnly.BreakBeforeBraces = FormatStyle::BS_Custom;\n  MergeInlineOnly.BraceWrapping.AfterFunction = true;\n  verifyFormat(\"class C {\\n\"\n               \"  int f() { return 42; }\\n\"\n               \"};\",\n               MergeInlineOnly);\n  verifyFormat(\"int f()\\n\"\n               \"{\\n\"\n               \"  return 42;\\n\"\n               \"}\",\n               MergeInlineOnly);\n\n  // SFS_Inline implies SFS_Empty\n  verifyFormat(\"int f() {}\", MergeInlineOnly);\n  verifyFormat(\"class C {\\n\"\n               \"  int f() {}\\n\"\n               \"};\",\n               MergeInlineOnly);\n}\n\nTEST_F(FormatTest, PullInlineOnlyFunctionDefinitionsIntoSingleLine) {\n  FormatStyle MergeInlineOnly = getLLVMStyle();\n  MergeInlineOnly.AllowShortFunctionsOnASingleLine =\n      FormatStyle::SFS_InlineOnly;\n  verifyFormat(\"class C {\\n\"\n               \"  int f() { return 42; }\\n\"\n               \"};\",\n               MergeInlineOnly);\n  verifyFormat(\"int f() {\\n\"\n               \"  return 42;\\n\"\n               \"}\",\n               MergeInlineOnly);\n\n  // SFS_InlineOnly does not imply SFS_Empty\n  verifyFormat(\"class C {\\n\"\n               \"  int f() {}\\n\"\n               \"};\",\n               MergeInlineOnly);\n  verifyFormat(\"int f() {\\n\"\n               \"}\",\n               MergeInlineOnly);\n\n  // Also verify behavior when BraceWrapping.AfterFunction = true\n  MergeInlineOnly.BreakBeforeBraces = FormatStyle::BS_Custom;\n  MergeInlineOnly.BraceWrapping.AfterFunction = true;\n  verifyFormat(\"class C {\\n\"\n               \"  int f() { return 42; }\\n\"\n               \"};\",\n               MergeInlineOnly);\n  verifyFormat(\"int f()\\n\"\n               \"{\\n\"\n               \"  return 42;\\n\"\n               \"}\",\n               MergeInlineOnly);\n\n  // SFS_InlineOnly does not imply SFS_Empty\n  verifyFormat(\"int f()\\n\"\n               \"{\\n\"\n               \"}\",\n               MergeInlineOnly);\n  verifyFormat(\"class C {\\n\"\n               \"  int f() {}\\n\"\n               \"};\",\n               MergeInlineOnly);\n}\n\nTEST_F(FormatTest, SplitEmptyFunction) {\n  FormatStyle Style = getLLVMStyle();\n  Style.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_None;\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.AfterFunction = true;\n  Style.BraceWrapping.SplitEmptyFunction = false;\n  Style.ColumnLimit = 40;\n\n  verifyFormat(\"int f()\\n\"\n               \"{}\",\n               Style);\n  verifyFormat(\"int f()\\n\"\n               \"{\\n\"\n               \"  return 42;\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"int f()\\n\"\n               \"{\\n\"\n               \"  // some comment\\n\"\n               \"}\",\n               Style);\n\n  Style.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_Empty;\n  verifyFormat(\"int f() {}\", Style);\n  verifyFormat(\"int aaaaaaaaaaaaaa(int bbbbbbbbbbbbbb)\\n\"\n               \"{}\",\n               Style);\n  verifyFormat(\"int f()\\n\"\n               \"{\\n\"\n               \"  return 0;\\n\"\n               \"}\",\n               Style);\n\n  Style.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_Inline;\n  verifyFormat(\"class Foo {\\n\"\n               \"  int f() {}\\n\"\n               \"};\\n\",\n               Style);\n  verifyFormat(\"class Foo {\\n\"\n               \"  int f() { return 0; }\\n\"\n               \"};\\n\",\n               Style);\n  verifyFormat(\"class Foo {\\n\"\n               \"  int aaaaaaaaaaaaaa(int bbbbbbbbbbbbbb)\\n\"\n               \"  {}\\n\"\n               \"};\\n\",\n               Style);\n  verifyFormat(\"class Foo {\\n\"\n               \"  int aaaaaaaaaaaaaa(int bbbbbbbbbbbbbb)\\n\"\n               \"  {\\n\"\n               \"    return 0;\\n\"\n               \"  }\\n\"\n               \"};\\n\",\n               Style);\n\n  Style.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_All;\n  verifyFormat(\"int f() {}\", Style);\n  verifyFormat(\"int f() { return 0; }\", Style);\n  verifyFormat(\"int aaaaaaaaaaaaaa(int bbbbbbbbbbbbbb)\\n\"\n               \"{}\",\n               Style);\n  verifyFormat(\"int aaaaaaaaaaaaaa(int bbbbbbbbbbbbbb)\\n\"\n               \"{\\n\"\n               \"  return 0;\\n\"\n               \"}\",\n               Style);\n}\nTEST_F(FormatTest, KeepShortFunctionAfterPPElse) {\n  FormatStyle Style = getLLVMStyle();\n  Style.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_All;\n  verifyFormat(\"#ifdef A\\n\"\n               \"int f() {}\\n\"\n               \"#else\\n\"\n               \"int g() {}\\n\"\n               \"#endif\",\n               Style);\n}\n\nTEST_F(FormatTest, SplitEmptyClass) {\n  FormatStyle Style = getLLVMStyle();\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.AfterClass = true;\n  Style.BraceWrapping.SplitEmptyRecord = false;\n\n  verifyFormat(\"class Foo\\n\"\n               \"{};\",\n               Style);\n  verifyFormat(\"/* something */ class Foo\\n\"\n               \"{};\",\n               Style);\n  verifyFormat(\"template <typename X> class Foo\\n\"\n               \"{};\",\n               Style);\n  verifyFormat(\"class Foo\\n\"\n               \"{\\n\"\n               \"  Foo();\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"typedef class Foo\\n\"\n               \"{\\n\"\n               \"} Foo_t;\",\n               Style);\n\n  Style.BraceWrapping.SplitEmptyRecord = true;\n  Style.BraceWrapping.AfterStruct = true;\n  verifyFormat(\"class rep\\n\"\n               \"{\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"struct rep\\n\"\n               \"{\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"template <typename T> class rep\\n\"\n               \"{\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"template <typename T> struct rep\\n\"\n               \"{\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"class rep\\n\"\n               \"{\\n\"\n               \"  int x;\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"struct rep\\n\"\n               \"{\\n\"\n               \"  int x;\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"template <typename T> class rep\\n\"\n               \"{\\n\"\n               \"  int x;\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"template <typename T> struct rep\\n\"\n               \"{\\n\"\n               \"  int x;\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"template <typename T> class rep // Foo\\n\"\n               \"{\\n\"\n               \"  int x;\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"template <typename T> struct rep // Bar\\n\"\n               \"{\\n\"\n               \"  int x;\\n\"\n               \"};\",\n               Style);\n\n  verifyFormat(\"template <typename T> class rep<T>\\n\"\n               \"{\\n\"\n               \"  int x;\\n\"\n               \"};\",\n               Style);\n\n  verifyFormat(\"template <typename T> class rep<std::complex<T>>\\n\"\n               \"{\\n\"\n               \"  int x;\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"template <typename T> class rep<std::complex<T>>\\n\"\n               \"{\\n\"\n               \"};\",\n               Style);\n\n  verifyFormat(\"#include \\\"stdint.h\\\"\\n\"\n               \"namespace rep {}\",\n               Style);\n  verifyFormat(\"#include <stdint.h>\\n\"\n               \"namespace rep {}\",\n               Style);\n  verifyFormat(\"#include <stdint.h>\\n\"\n               \"namespace rep {}\",\n               \"#include <stdint.h>\\n\"\n               \"namespace rep {\\n\"\n               \"\\n\"\n               \"\\n\"\n               \"}\",\n               Style);\n}\n\nTEST_F(FormatTest, SplitEmptyStruct) {\n  FormatStyle Style = getLLVMStyle();\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.AfterStruct = true;\n  Style.BraceWrapping.SplitEmptyRecord = false;\n\n  verifyFormat(\"struct Foo\\n\"\n               \"{};\",\n               Style);\n  verifyFormat(\"/* something */ struct Foo\\n\"\n               \"{};\",\n               Style);\n  verifyFormat(\"template <typename X> struct Foo\\n\"\n               \"{};\",\n               Style);\n  verifyFormat(\"struct Foo\\n\"\n               \"{\\n\"\n               \"  Foo();\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"typedef struct Foo\\n\"\n               \"{\\n\"\n               \"} Foo_t;\",\n               Style);\n  // typedef struct Bar {} Bar_t;\n}\n\nTEST_F(FormatTest, SplitEmptyUnion) {\n  FormatStyle Style = getLLVMStyle();\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.AfterUnion = true;\n  Style.BraceWrapping.SplitEmptyRecord = false;\n\n  verifyFormat(\"union Foo\\n\"\n               \"{};\",\n               Style);\n  verifyFormat(\"/* something */ union Foo\\n\"\n               \"{};\",\n               Style);\n  verifyFormat(\"union Foo\\n\"\n               \"{\\n\"\n               \"  A,\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"typedef union Foo\\n\"\n               \"{\\n\"\n               \"} Foo_t;\",\n               Style);\n}\n\nTEST_F(FormatTest, SplitEmptyNamespace) {\n  FormatStyle Style = getLLVMStyle();\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.AfterNamespace = true;\n  Style.BraceWrapping.SplitEmptyNamespace = false;\n\n  verifyFormat(\"namespace Foo\\n\"\n               \"{};\",\n               Style);\n  verifyFormat(\"/* something */ namespace Foo\\n\"\n               \"{};\",\n               Style);\n  verifyFormat(\"inline namespace Foo\\n\"\n               \"{};\",\n               Style);\n  verifyFormat(\"/* something */ inline namespace Foo\\n\"\n               \"{};\",\n               Style);\n  verifyFormat(\"export namespace Foo\\n\"\n               \"{};\",\n               Style);\n  verifyFormat(\"namespace Foo\\n\"\n               \"{\\n\"\n               \"void Bar();\\n\"\n               \"};\",\n               Style);\n}\n\nTEST_F(FormatTest, NeverMergeShortRecords) {\n  FormatStyle Style = getLLVMStyle();\n\n  verifyFormat(\"class Foo {\\n\"\n               \"  Foo();\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"typedef class Foo {\\n\"\n               \"  Foo();\\n\"\n               \"} Foo_t;\",\n               Style);\n  verifyFormat(\"struct Foo {\\n\"\n               \"  Foo();\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"typedef struct Foo {\\n\"\n               \"  Foo();\\n\"\n               \"} Foo_t;\",\n               Style);\n  verifyFormat(\"union Foo {\\n\"\n               \"  A,\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"typedef union Foo {\\n\"\n               \"  A,\\n\"\n               \"} Foo_t;\",\n               Style);\n  verifyFormat(\"namespace Foo {\\n\"\n               \"void Bar();\\n\"\n               \"};\",\n               Style);\n\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.AfterClass = true;\n  Style.BraceWrapping.AfterStruct = true;\n  Style.BraceWrapping.AfterUnion = true;\n  Style.BraceWrapping.AfterNamespace = true;\n  verifyFormat(\"class Foo\\n\"\n               \"{\\n\"\n               \"  Foo();\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"typedef class Foo\\n\"\n               \"{\\n\"\n               \"  Foo();\\n\"\n               \"} Foo_t;\",\n               Style);\n  verifyFormat(\"struct Foo\\n\"\n               \"{\\n\"\n               \"  Foo();\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"typedef struct Foo\\n\"\n               \"{\\n\"\n               \"  Foo();\\n\"\n               \"} Foo_t;\",\n               Style);\n  verifyFormat(\"union Foo\\n\"\n               \"{\\n\"\n               \"  A,\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"typedef union Foo\\n\"\n               \"{\\n\"\n               \"  A,\\n\"\n               \"} Foo_t;\",\n               Style);\n  verifyFormat(\"namespace Foo\\n\"\n               \"{\\n\"\n               \"void Bar();\\n\"\n               \"};\",\n               Style);\n}\n\nTEST_F(FormatTest, UnderstandContextOfRecordTypeKeywords) {\n  // Elaborate type variable declarations.\n  verifyFormat(\"struct foo a = {bar};\\nint n;\");\n  verifyFormat(\"class foo a = {bar};\\nint n;\");\n  verifyFormat(\"union foo a = {bar};\\nint n;\");\n\n  // Elaborate types inside function definitions.\n  verifyFormat(\"struct foo f() {}\\nint n;\");\n  verifyFormat(\"class foo f() {}\\nint n;\");\n  verifyFormat(\"union foo f() {}\\nint n;\");\n\n  // Templates.\n  verifyFormat(\"template <class X> void f() {}\\nint n;\");\n  verifyFormat(\"template <struct X> void f() {}\\nint n;\");\n  verifyFormat(\"template <union X> void f() {}\\nint n;\");\n\n  // Actual definitions...\n  verifyFormat(\"struct {\\n} n;\");\n  verifyFormat(\n      \"template <template <class T, class Y>, class Z> class X {\\n} n;\");\n  verifyFormat(\"union Z {\\n  int n;\\n} x;\");\n  verifyFormat(\"class MACRO Z {\\n} n;\");\n  verifyFormat(\"class MACRO(X) Z {\\n} n;\");\n  verifyFormat(\"class __attribute__(X) Z {\\n} n;\");\n  verifyFormat(\"class __declspec(X) Z {\\n} n;\");\n  verifyFormat(\"class A##B##C {\\n} n;\");\n  verifyFormat(\"class alignas(16) Z {\\n} n;\");\n  verifyFormat(\"class MACRO(X) alignas(16) Z {\\n} n;\");\n  verifyFormat(\"class MACROA MACRO(X) Z {\\n} n;\");\n\n  // Redefinition from nested context:\n  verifyFormat(\"class A::B::C {\\n} n;\");\n\n  // Template definitions.\n  verifyFormat(\n      \"template <typename F>\\n\"\n      \"Matcher(const Matcher<F> &Other,\\n\"\n      \"        typename enable_if_c<is_base_of<F, T>::value &&\\n\"\n      \"                             !is_same<F, T>::value>::type * = 0)\\n\"\n      \"    : Implementation(new ImplicitCastMatcher<F>(Other)) {}\");\n\n  // FIXME: This is still incorrectly handled at the formatter side.\n  verifyFormat(\"template <> struct X < 15, i<3 && 42 < 50 && 33 < 28> {};\");\n  verifyFormat(\"int i = SomeFunction(a<b, a> b);\");\n\n  // FIXME:\n  // This now gets parsed incorrectly as class definition.\n  // verifyFormat(\"class A<int> f() {\\n}\\nint n;\");\n\n  // Elaborate types where incorrectly parsing the structural element would\n  // break the indent.\n  verifyFormat(\"if (true)\\n\"\n               \"  class X x;\\n\"\n               \"else\\n\"\n               \"  f();\\n\");\n\n  // This is simply incomplete. Formatting is not important, but must not crash.\n  verifyFormat(\"class A:\");\n}\n\nTEST_F(FormatTest, DoNotInterfereWithErrorAndWarning) {\n  EXPECT_EQ(\"#error Leave     all         white!!!!! space* alone!\\n\",\n            format(\"#error Leave     all         white!!!!! space* alone!\\n\"));\n  EXPECT_EQ(\n      \"#warning Leave     all         white!!!!! space* alone!\\n\",\n      format(\"#warning Leave     all         white!!!!! space* alone!\\n\"));\n  EXPECT_EQ(\"#error 1\", format(\"  #  error   1\"));\n  EXPECT_EQ(\"#warning 1\", format(\"  #  warning 1\"));\n}\n\nTEST_F(FormatTest, FormatHashIfExpressions) {\n  verifyFormat(\"#if AAAA && BBBB\");\n  verifyFormat(\"#if (AAAA && BBBB)\");\n  verifyFormat(\"#elif (AAAA && BBBB)\");\n  // FIXME: Come up with a better indentation for #elif.\n  verifyFormat(\n      \"#if !defined(AAAAAAA) && (defined CCCCCC || defined DDDDDD) &&  \\\\\\n\"\n      \"    defined(BBBBBBBB)\\n\"\n      \"#elif !defined(AAAAAA) && (defined CCCCC || defined DDDDDD) &&  \\\\\\n\"\n      \"    defined(BBBBBBBB)\\n\"\n      \"#endif\",\n      getLLVMStyleWithColumns(65));\n}\n\nTEST_F(FormatTest, MergeHandlingInTheFaceOfPreprocessorDirectives) {\n  FormatStyle AllowsMergedIf = getGoogleStyle();\n  AllowsMergedIf.AllowShortIfStatementsOnASingleLine =\n      FormatStyle::SIS_WithoutElse;\n  verifyFormat(\"void f() { f(); }\\n#error E\", AllowsMergedIf);\n  verifyFormat(\"if (true) return 42;\\n#error E\", AllowsMergedIf);\n  verifyFormat(\"if (true)\\n#error E\\n  return 42;\", AllowsMergedIf);\n  EXPECT_EQ(\"if (true) return 42;\",\n            format(\"if (true)\\nreturn 42;\", AllowsMergedIf));\n  FormatStyle ShortMergedIf = AllowsMergedIf;\n  ShortMergedIf.ColumnLimit = 25;\n  verifyFormat(\"#define A \\\\\\n\"\n               \"  if (true) return 42;\",\n               ShortMergedIf);\n  verifyFormat(\"#define A \\\\\\n\"\n               \"  f();    \\\\\\n\"\n               \"  if (true)\\n\"\n               \"#define B\",\n               ShortMergedIf);\n  verifyFormat(\"#define A \\\\\\n\"\n               \"  f();    \\\\\\n\"\n               \"  if (true)\\n\"\n               \"g();\",\n               ShortMergedIf);\n  verifyFormat(\"{\\n\"\n               \"#ifdef A\\n\"\n               \"  // Comment\\n\"\n               \"  if (true) continue;\\n\"\n               \"#endif\\n\"\n               \"  // Comment\\n\"\n               \"  if (true) continue;\\n\"\n               \"}\",\n               ShortMergedIf);\n  ShortMergedIf.ColumnLimit = 33;\n  verifyFormat(\"#define A \\\\\\n\"\n               \"  if constexpr (true) return 42;\",\n               ShortMergedIf);\n  verifyFormat(\"#define A \\\\\\n\"\n               \"  if CONSTEXPR (true) return 42;\",\n               ShortMergedIf);\n  ShortMergedIf.ColumnLimit = 29;\n  verifyFormat(\"#define A                   \\\\\\n\"\n               \"  if (aaaaaaaaaa) return 1; \\\\\\n\"\n               \"  return 2;\",\n               ShortMergedIf);\n  ShortMergedIf.ColumnLimit = 28;\n  verifyFormat(\"#define A         \\\\\\n\"\n               \"  if (aaaaaaaaaa) \\\\\\n\"\n               \"    return 1;     \\\\\\n\"\n               \"  return 2;\",\n               ShortMergedIf);\n  verifyFormat(\"#define A                \\\\\\n\"\n               \"  if constexpr (aaaaaaa) \\\\\\n\"\n               \"    return 1;            \\\\\\n\"\n               \"  return 2;\",\n               ShortMergedIf);\n  verifyFormat(\"#define A                \\\\\\n\"\n               \"  if CONSTEXPR (aaaaaaa) \\\\\\n\"\n               \"    return 1;            \\\\\\n\"\n               \"  return 2;\",\n               ShortMergedIf);\n}\n\nTEST_F(FormatTest, FormatStarDependingOnContext) {\n  verifyFormat(\"void f(int *a);\");\n  verifyFormat(\"void f() { f(fint * b); }\");\n  verifyFormat(\"class A {\\n  void f(int *a);\\n};\");\n  verifyFormat(\"class A {\\n  int *a;\\n};\");\n  verifyFormat(\"namespace a {\\n\"\n               \"namespace b {\\n\"\n               \"class A {\\n\"\n               \"  void f() {}\\n\"\n               \"  int *a;\\n\"\n               \"};\\n\"\n               \"} // namespace b\\n\"\n               \"} // namespace a\");\n}\n\nTEST_F(FormatTest, SpecialTokensAtEndOfLine) {\n  verifyFormat(\"while\");\n  verifyFormat(\"operator\");\n}\n\nTEST_F(FormatTest, SkipsDeeplyNestedLines) {\n  // This code would be painfully slow to format if we didn't skip it.\n  std::string Code(\"A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(\\n\" // 20x\n                   \"A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(\\n\"\n                   \"A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(\\n\"\n                   \"A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(\\n\"\n                   \"A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(A(\\n\"\n                   \"A(1, 1)\\n\"\n                   \", 1), 1), 1), 1), 1), 1), 1), 1), 1), 1)\\n\" // 10x\n                   \", 1), 1), 1), 1), 1), 1), 1), 1), 1), 1)\\n\"\n                   \", 1), 1), 1), 1), 1), 1), 1), 1), 1), 1)\\n\"\n                   \", 1), 1), 1), 1), 1), 1), 1), 1), 1), 1)\\n\"\n                   \", 1), 1), 1), 1), 1), 1), 1), 1), 1), 1)\\n\"\n                   \", 1), 1), 1), 1), 1), 1), 1), 1), 1), 1)\\n\"\n                   \", 1), 1), 1), 1), 1), 1), 1), 1), 1), 1)\\n\"\n                   \", 1), 1), 1), 1), 1), 1), 1), 1), 1), 1)\\n\"\n                   \", 1), 1), 1), 1), 1), 1), 1), 1), 1), 1)\\n\"\n                   \", 1), 1), 1), 1), 1), 1), 1), 1), 1), 1);\\n\");\n  // Deeply nested part is untouched, rest is formatted.\n  EXPECT_EQ(std::string(\"int i;\\n\") + Code + \"int j;\\n\",\n            format(std::string(\"int    i;\\n\") + Code + \"int    j;\\n\",\n                   getLLVMStyle(), SC_ExpectIncomplete));\n}\n\n//===----------------------------------------------------------------------===//\n// Objective-C tests.\n//===----------------------------------------------------------------------===//\n\nTEST_F(FormatTest, FormatForObjectiveCMethodDecls) {\n  verifyFormat(\"- (void)sendAction:(SEL)aSelector to:(BOOL)anObject;\");\n  EXPECT_EQ(\"- (NSUInteger)indexOfObject:(id)anObject;\",\n            format(\"-(NSUInteger)indexOfObject:(id)anObject;\"));\n  EXPECT_EQ(\"- (NSInteger)Mthod1;\", format(\"-(NSInteger)Mthod1;\"));\n  EXPECT_EQ(\"+ (id)Mthod2;\", format(\"+(id)Mthod2;\"));\n  EXPECT_EQ(\"- (NSInteger)Method3:(id)anObject;\",\n            format(\"-(NSInteger)Method3:(id)anObject;\"));\n  EXPECT_EQ(\"- (NSInteger)Method4:(id)anObject;\",\n            format(\"-(NSInteger)Method4:(id)anObject;\"));\n  EXPECT_EQ(\"- (NSInteger)Method5:(id)anObject:(id)AnotherObject;\",\n            format(\"-(NSInteger)Method5:(id)anObject:(id)AnotherObject;\"));\n  EXPECT_EQ(\"- (id)Method6:(id)A:(id)B:(id)C:(id)D;\",\n            format(\"- (id)Method6:(id)A:(id)B:(id)C:(id)D;\"));\n  EXPECT_EQ(\"- (void)sendAction:(SEL)aSelector to:(id)anObject \"\n            \"forAllCells:(BOOL)flag;\",\n            format(\"- (void)sendAction:(SEL)aSelector to:(id)anObject \"\n                   \"forAllCells:(BOOL)flag;\"));\n\n  // Very long objectiveC method declaration.\n  verifyFormat(\"- (void)aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:\\n\"\n               \"    (SoooooooooooooooooooooomeType *)bbbbbbbbbb;\");\n  verifyFormat(\"- (NSUInteger)indexOfObject:(id)anObject\\n\"\n               \"                    inRange:(NSRange)range\\n\"\n               \"                   outRange:(NSRange)out_range\\n\"\n               \"                  outRange1:(NSRange)out_range1\\n\"\n               \"                  outRange2:(NSRange)out_range2\\n\"\n               \"                  outRange3:(NSRange)out_range3\\n\"\n               \"                  outRange4:(NSRange)out_range4\\n\"\n               \"                  outRange5:(NSRange)out_range5\\n\"\n               \"                  outRange6:(NSRange)out_range6\\n\"\n               \"                  outRange7:(NSRange)out_range7\\n\"\n               \"                  outRange8:(NSRange)out_range8\\n\"\n               \"                  outRange9:(NSRange)out_range9;\");\n\n  // When the function name has to be wrapped.\n  FormatStyle Style = getLLVMStyle();\n  // ObjC ignores IndentWrappedFunctionNames when wrapping methods\n  // and always indents instead.\n  Style.IndentWrappedFunctionNames = false;\n  verifyFormat(\"- (SomeLooooooooooooooooooooongType *)\\n\"\n               \"    veryLooooooooooongName:(NSString)aaaaaaaaaaaaaa\\n\"\n               \"               anotherName:(NSString)bbbbbbbbbbbbbb {\\n\"\n               \"}\",\n               Style);\n  Style.IndentWrappedFunctionNames = true;\n  verifyFormat(\"- (SomeLooooooooooooooooooooongType *)\\n\"\n               \"    veryLooooooooooongName:(NSString)cccccccccccccc\\n\"\n               \"               anotherName:(NSString)dddddddddddddd {\\n\"\n               \"}\",\n               Style);\n\n  verifyFormat(\"- (int)sum:(vector<int>)numbers;\");\n  verifyGoogleFormat(\"- (void)setDelegate:(id<Protocol>)delegate;\");\n  // FIXME: In LLVM style, there should be a space in front of a '<' for ObjC\n  // protocol lists (but not for template classes):\n  // verifyFormat(\"- (void)setDelegate:(id <Protocol>)delegate;\");\n\n  verifyFormat(\"- (int (*)())foo:(int (*)())f;\");\n  verifyGoogleFormat(\"- (int (*)())foo:(int (*)())foo;\");\n\n  // If there's no return type (very rare in practice!), LLVM and Google style\n  // agree.\n  verifyFormat(\"- foo;\");\n  verifyFormat(\"- foo:(int)f;\");\n  verifyGoogleFormat(\"- foo:(int)foo;\");\n}\n\nTEST_F(FormatTest, BreaksStringLiterals) {\n  EXPECT_EQ(\"\\\"some text \\\"\\n\"\n            \"\\\"other\\\";\",\n            format(\"\\\"some text other\\\";\", getLLVMStyleWithColumns(12)));\n  EXPECT_EQ(\"\\\"some text \\\"\\n\"\n            \"\\\"other\\\";\",\n            format(\"\\\\\\n\\\"some text other\\\";\", getLLVMStyleWithColumns(12)));\n  EXPECT_EQ(\n      \"#define A  \\\\\\n\"\n      \"  \\\"some \\\"  \\\\\\n\"\n      \"  \\\"text \\\"  \\\\\\n\"\n      \"  \\\"other\\\";\",\n      format(\"#define A \\\"some text other\\\";\", getLLVMStyleWithColumns(12)));\n  EXPECT_EQ(\n      \"#define A  \\\\\\n\"\n      \"  \\\"so \\\"    \\\\\\n\"\n      \"  \\\"text \\\"  \\\\\\n\"\n      \"  \\\"other\\\";\",\n      format(\"#define A \\\"so text other\\\";\", getLLVMStyleWithColumns(12)));\n\n  EXPECT_EQ(\"\\\"some text\\\"\",\n            format(\"\\\"some text\\\"\", getLLVMStyleWithColumns(1)));\n  EXPECT_EQ(\"\\\"some text\\\"\",\n            format(\"\\\"some text\\\"\", getLLVMStyleWithColumns(11)));\n  EXPECT_EQ(\"\\\"some \\\"\\n\"\n            \"\\\"text\\\"\",\n            format(\"\\\"some text\\\"\", getLLVMStyleWithColumns(10)));\n  EXPECT_EQ(\"\\\"some \\\"\\n\"\n            \"\\\"text\\\"\",\n            format(\"\\\"some text\\\"\", getLLVMStyleWithColumns(7)));\n  EXPECT_EQ(\"\\\"some\\\"\\n\"\n            \"\\\" tex\\\"\\n\"\n            \"\\\"t\\\"\",\n            format(\"\\\"some text\\\"\", getLLVMStyleWithColumns(6)));\n  EXPECT_EQ(\"\\\"some\\\"\\n\"\n            \"\\\" tex\\\"\\n\"\n            \"\\\" and\\\"\",\n            format(\"\\\"some tex and\\\"\", getLLVMStyleWithColumns(6)));\n  EXPECT_EQ(\"\\\"some\\\"\\n\"\n            \"\\\"/tex\\\"\\n\"\n            \"\\\"/and\\\"\",\n            format(\"\\\"some/tex/and\\\"\", getLLVMStyleWithColumns(6)));\n\n  EXPECT_EQ(\"variable =\\n\"\n            \"    \\\"long string \\\"\\n\"\n            \"    \\\"literal\\\";\",\n            format(\"variable = \\\"long string literal\\\";\",\n                   getLLVMStyleWithColumns(20)));\n\n  EXPECT_EQ(\"variable = f(\\n\"\n            \"    \\\"long string \\\"\\n\"\n            \"    \\\"literal\\\",\\n\"\n            \"    short,\\n\"\n            \"    loooooooooooooooooooong);\",\n            format(\"variable = f(\\\"long string literal\\\", short, \"\n                   \"loooooooooooooooooooong);\",\n                   getLLVMStyleWithColumns(20)));\n\n  EXPECT_EQ(\n      \"f(g(\\\"long string \\\"\\n\"\n      \"    \\\"literal\\\"),\\n\"\n      \"  b);\",\n      format(\"f(g(\\\"long string literal\\\"), b);\", getLLVMStyleWithColumns(20)));\n  EXPECT_EQ(\"f(g(\\\"long string \\\"\\n\"\n            \"    \\\"literal\\\",\\n\"\n            \"    a),\\n\"\n            \"  b);\",\n            format(\"f(g(\\\"long string literal\\\", a), b);\",\n                   getLLVMStyleWithColumns(20)));\n  EXPECT_EQ(\n      \"f(\\\"one two\\\".split(\\n\"\n      \"    variable));\",\n      format(\"f(\\\"one two\\\".split(variable));\", getLLVMStyleWithColumns(20)));\n  EXPECT_EQ(\"f(\\\"one two three four five six \\\"\\n\"\n            \"  \\\"seven\\\".split(\\n\"\n            \"      really_looooong_variable));\",\n            format(\"f(\\\"one two three four five six seven\\\".\"\n                   \"split(really_looooong_variable));\",\n                   getLLVMStyleWithColumns(33)));\n\n  EXPECT_EQ(\"f(\\\"some \\\"\\n\"\n            \"  \\\"text\\\",\\n\"\n            \"  other);\",\n            format(\"f(\\\"some text\\\", other);\", getLLVMStyleWithColumns(10)));\n\n  // Only break as a last resort.\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaa,\\n\"\n      \"    aaaaaa(\\\"aaa aaaaa aaa aaa aaaaa aaa aaaaa aaa aaa aaaaaa\\\"));\");\n\n  EXPECT_EQ(\"\\\"splitmea\\\"\\n\"\n            \"\\\"trandomp\\\"\\n\"\n            \"\\\"oint\\\"\",\n            format(\"\\\"splitmeatrandompoint\\\"\", getLLVMStyleWithColumns(10)));\n\n  EXPECT_EQ(\"\\\"split/\\\"\\n\"\n            \"\\\"pathat/\\\"\\n\"\n            \"\\\"slashes\\\"\",\n            format(\"\\\"split/pathat/slashes\\\"\", getLLVMStyleWithColumns(10)));\n\n  EXPECT_EQ(\"\\\"split/\\\"\\n\"\n            \"\\\"pathat/\\\"\\n\"\n            \"\\\"slashes\\\"\",\n            format(\"\\\"split/pathat/slashes\\\"\", getLLVMStyleWithColumns(10)));\n  EXPECT_EQ(\"\\\"split at \\\"\\n\"\n            \"\\\"spaces/at/\\\"\\n\"\n            \"\\\"slashes.at.any$\\\"\\n\"\n            \"\\\"non-alphanumeric%\\\"\\n\"\n            \"\\\"1111111111characte\\\"\\n\"\n            \"\\\"rs\\\"\",\n            format(\"\\\"split at \"\n                   \"spaces/at/\"\n                   \"slashes.at.\"\n                   \"any$non-\"\n                   \"alphanumeric%\"\n                   \"1111111111characte\"\n                   \"rs\\\"\",\n                   getLLVMStyleWithColumns(20)));\n\n  // Verify that splitting the strings understands\n  // Style::AlwaysBreakBeforeMultilineStrings.\n  EXPECT_EQ(\"aaaaaaaaaaaa(\\n\"\n            \"    \\\"aaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaa \\\"\\n\"\n            \"    \\\"aaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaa\\\");\",\n            format(\"aaaaaaaaaaaa(\\\"aaaaaaaaaaaaaaaaaaaaaaaaaa \"\n                   \"aaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaa \"\n                   \"aaaaaaaaaaaaaaaaaaaaaa\\\");\",\n                   getGoogleStyle()));\n  EXPECT_EQ(\"return \\\"aaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaa \\\"\\n\"\n            \"       \\\"aaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaa\\\";\",\n            format(\"return \\\"aaaaaaaaaaaaaaaaaaaaaa \"\n                   \"aaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaa \"\n                   \"aaaaaaaaaaaaaaaaaaaaaa\\\";\",\n                   getGoogleStyle()));\n  EXPECT_EQ(\"llvm::outs() << \\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \\\"\\n\"\n            \"                \\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\";\",\n            format(\"llvm::outs() << \"\n                   \"\\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaa\"\n                   \"aaaaaaaaaaaaaaaaaaa\\\";\"));\n  EXPECT_EQ(\"ffff(\\n\"\n            \"    {\\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \\\"\\n\"\n            \"     \\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\"});\",\n            format(\"ffff({\\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \"\n                   \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\"});\",\n                   getGoogleStyle()));\n\n  FormatStyle Style = getLLVMStyleWithColumns(12);\n  Style.BreakStringLiterals = false;\n  EXPECT_EQ(\"\\\"some text other\\\";\", format(\"\\\"some text other\\\";\", Style));\n\n  FormatStyle AlignLeft = getLLVMStyleWithColumns(12);\n  AlignLeft.AlignEscapedNewlines = FormatStyle::ENAS_Left;\n  EXPECT_EQ(\"#define A \\\\\\n\"\n            \"  \\\"some \\\" \\\\\\n\"\n            \"  \\\"text \\\" \\\\\\n\"\n            \"  \\\"other\\\";\",\n            format(\"#define A \\\"some text other\\\";\", AlignLeft));\n}\n\nTEST_F(FormatTest, BreaksStringLiteralsAtColumnLimit) {\n  EXPECT_EQ(\"C a = \\\"some more \\\"\\n\"\n            \"      \\\"text\\\";\",\n            format(\"C a = \\\"some more text\\\";\", getLLVMStyleWithColumns(18)));\n}\n\nTEST_F(FormatTest, FullyRemoveEmptyLines) {\n  FormatStyle NoEmptyLines = getLLVMStyleWithColumns(80);\n  NoEmptyLines.MaxEmptyLinesToKeep = 0;\n  EXPECT_EQ(\"int i = a(b());\",\n            format(\"int i=a(\\n\\n b(\\n\\n\\n )\\n\\n);\", NoEmptyLines));\n}\n\nTEST_F(FormatTest, BreaksStringLiteralsWithTabs) {\n  EXPECT_EQ(\n      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"(\\n\"\n      \"    \\\"x\\t\\\");\",\n      format(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n             \"aaaaaaa(\"\n             \"\\\"x\\t\\\");\"));\n}\n\nTEST_F(FormatTest, BreaksWideAndNSStringLiterals) {\n  EXPECT_EQ(\n      \"u8\\\"utf8 string \\\"\\n\"\n      \"u8\\\"literal\\\";\",\n      format(\"u8\\\"utf8 string literal\\\";\", getGoogleStyleWithColumns(16)));\n  EXPECT_EQ(\n      \"u\\\"utf16 string \\\"\\n\"\n      \"u\\\"literal\\\";\",\n      format(\"u\\\"utf16 string literal\\\";\", getGoogleStyleWithColumns(16)));\n  EXPECT_EQ(\n      \"U\\\"utf32 string \\\"\\n\"\n      \"U\\\"literal\\\";\",\n      format(\"U\\\"utf32 string literal\\\";\", getGoogleStyleWithColumns(16)));\n  EXPECT_EQ(\"L\\\"wide string \\\"\\n\"\n            \"L\\\"literal\\\";\",\n            format(\"L\\\"wide string literal\\\";\", getGoogleStyleWithColumns(16)));\n  EXPECT_EQ(\"@\\\"NSString \\\"\\n\"\n            \"@\\\"literal\\\";\",\n            format(\"@\\\"NSString literal\\\";\", getGoogleStyleWithColumns(19)));\n  verifyFormat(R\"(NSString *s = @\"\u90a3\u90a3\u90a3\u90a3\";)\", getLLVMStyleWithColumns(26));\n\n  // This input makes clang-format try to split the incomplete unicode escape\n  // sequence, which used to lead to a crasher.\n  verifyNoCrash(\n      \"aaaaaaaaaaaaaaaaaaaa = L\\\"\\\\udff\\\"'; // aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n      getLLVMStyleWithColumns(60));\n}\n\nTEST_F(FormatTest, DoesNotBreakRawStringLiterals) {\n  FormatStyle Style = getGoogleStyleWithColumns(15);\n  EXPECT_EQ(\"R\\\"x(raw literal)x\\\";\", format(\"R\\\"x(raw literal)x\\\";\", Style));\n  EXPECT_EQ(\"uR\\\"x(raw literal)x\\\";\", format(\"uR\\\"x(raw literal)x\\\";\", Style));\n  EXPECT_EQ(\"LR\\\"x(raw literal)x\\\";\", format(\"LR\\\"x(raw literal)x\\\";\", Style));\n  EXPECT_EQ(\"UR\\\"x(raw literal)x\\\";\", format(\"UR\\\"x(raw literal)x\\\";\", Style));\n  EXPECT_EQ(\"u8R\\\"x(raw literal)x\\\";\",\n            format(\"u8R\\\"x(raw literal)x\\\";\", Style));\n}\n\nTEST_F(FormatTest, BreaksStringLiteralsWithin_TMacro) {\n  FormatStyle Style = getLLVMStyleWithColumns(20);\n  EXPECT_EQ(\n      \"_T(\\\"aaaaaaaaaaaaaa\\\")\\n\"\n      \"_T(\\\"aaaaaaaaaaaaaa\\\")\\n\"\n      \"_T(\\\"aaaaaaaaaaaa\\\")\",\n      format(\"  _T(\\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\")\", Style));\n  EXPECT_EQ(\"f(x,\\n\"\n            \"  _T(\\\"aaaaaaaaaaaa\\\")\\n\"\n            \"  _T(\\\"aaa\\\"),\\n\"\n            \"  z);\",\n            format(\"f(x, _T(\\\"aaaaaaaaaaaaaaa\\\"), z);\", Style));\n\n  // FIXME: Handle embedded spaces in one iteration.\n  //  EXPECT_EQ(\"_T(\\\"aaaaaaaaaaaaa\\\")\\n\"\n  //            \"_T(\\\"aaaaaaaaaaaaa\\\")\\n\"\n  //            \"_T(\\\"aaaaaaaaaaaaa\\\")\\n\"\n  //            \"_T(\\\"a\\\")\",\n  //            format(\"  _T ( \\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\" )\",\n  //                   getLLVMStyleWithColumns(20)));\n  EXPECT_EQ(\n      \"_T ( \\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\" )\",\n      format(\"  _T ( \\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\" )\", Style));\n  EXPECT_EQ(\"f(\\n\"\n            \"#if !TEST\\n\"\n            \"    _T(\\\"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXn\\\")\\n\"\n            \"#endif\\n\"\n            \");\",\n            format(\"f(\\n\"\n                   \"#if !TEST\\n\"\n                   \"_T(\\\"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXn\\\")\\n\"\n                   \"#endif\\n\"\n                   \");\"));\n  EXPECT_EQ(\"f(\\n\"\n            \"\\n\"\n            \"    _T(\\\"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXn\\\"));\",\n            format(\"f(\\n\"\n                   \"\\n\"\n                   \"_T(\\\"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXn\\\"));\"));\n}\n\nTEST_F(FormatTest, BreaksStringLiteralOperands) {\n  // In a function call with two operands, the second can be broken with no line\n  // break before it.\n  EXPECT_EQ(\n      \"func(a, \\\"long long \\\"\\n\"\n      \"        \\\"long long\\\");\",\n      format(\"func(a, \\\"long long long long\\\");\", getLLVMStyleWithColumns(24)));\n  // In a function call with three operands, the second must be broken with a\n  // line break before it.\n  EXPECT_EQ(\"func(a,\\n\"\n            \"     \\\"long long long \\\"\\n\"\n            \"     \\\"long\\\",\\n\"\n            \"     c);\",\n            format(\"func(a, \\\"long long long long\\\", c);\",\n                   getLLVMStyleWithColumns(24)));\n  // In a function call with three operands, the third must be broken with a\n  // line break before it.\n  EXPECT_EQ(\"func(a, b,\\n\"\n            \"     \\\"long long long \\\"\\n\"\n            \"     \\\"long\\\");\",\n            format(\"func(a, b, \\\"long long long long\\\");\",\n                   getLLVMStyleWithColumns(24)));\n  // In a function call with three operands, both the second and the third must\n  // be broken with a line break before them.\n  EXPECT_EQ(\"func(a,\\n\"\n            \"     \\\"long long long \\\"\\n\"\n            \"     \\\"long\\\",\\n\"\n            \"     \\\"long long long \\\"\\n\"\n            \"     \\\"long\\\");\",\n            format(\"func(a, \\\"long long long long\\\", \\\"long long long long\\\");\",\n                   getLLVMStyleWithColumns(24)));\n  // In a chain of << with two operands, the second can be broken with no line\n  // break before it.\n  EXPECT_EQ(\"a << \\\"line line \\\"\\n\"\n            \"     \\\"line\\\";\",\n            format(\"a << \\\"line line line\\\";\", getLLVMStyleWithColumns(20)));\n  // In a chain of << with three operands, the second can be broken with no line\n  // break before it.\n  EXPECT_EQ(\n      \"abcde << \\\"line \\\"\\n\"\n      \"         \\\"line line\\\"\\n\"\n      \"      << c;\",\n      format(\"abcde << \\\"line line line\\\" << c;\", getLLVMStyleWithColumns(20)));\n  // In a chain of << with three operands, the third must be broken with a line\n  // break before it.\n  EXPECT_EQ(\n      \"a << b\\n\"\n      \"  << \\\"line line \\\"\\n\"\n      \"     \\\"line\\\";\",\n      format(\"a << b << \\\"line line line\\\";\", getLLVMStyleWithColumns(20)));\n  // In a chain of << with three operands, the second can be broken with no line\n  // break before it and the third must be broken with a line break before it.\n  EXPECT_EQ(\"abcd << \\\"line line \\\"\\n\"\n            \"        \\\"line\\\"\\n\"\n            \"     << \\\"line line \\\"\\n\"\n            \"        \\\"line\\\";\",\n            format(\"abcd << \\\"line line line\\\" << \\\"line line line\\\";\",\n                   getLLVMStyleWithColumns(20)));\n  // In a chain of binary operators with two operands, the second can be broken\n  // with no line break before it.\n  EXPECT_EQ(\n      \"abcd + \\\"line line \\\"\\n\"\n      \"       \\\"line line\\\";\",\n      format(\"abcd + \\\"line line line line\\\";\", getLLVMStyleWithColumns(20)));\n  // In a chain of binary operators with three operands, the second must be\n  // broken with a line break before it.\n  EXPECT_EQ(\"abcd +\\n\"\n            \"    \\\"line line \\\"\\n\"\n            \"    \\\"line line\\\" +\\n\"\n            \"    e;\",\n            format(\"abcd + \\\"line line line line\\\" + e;\",\n                   getLLVMStyleWithColumns(20)));\n  // In a function call with two operands, with AlignAfterOpenBracket enabled,\n  // the first must be broken with a line break before it.\n  FormatStyle Style = getLLVMStyleWithColumns(25);\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_AlwaysBreak;\n  EXPECT_EQ(\"someFunction(\\n\"\n            \"    \\\"long long long \\\"\\n\"\n            \"    \\\"long\\\",\\n\"\n            \"    a);\",\n            format(\"someFunction(\\\"long long long long\\\", a);\", Style));\n}\n\nTEST_F(FormatTest, DontSplitStringLiteralsWithEscapedNewlines) {\n  EXPECT_EQ(\n      \"aaaaaaaaaaa = \\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\\\\n\"\n      \"  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\\\\n\"\n      \"  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\";\",\n      format(\"aaaaaaaaaaa  =  \\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\\\\n\"\n             \"  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\\\\n\"\n             \"  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\";\"));\n}\n\nTEST_F(FormatTest, CountsCharactersInMultilineRawStringLiterals) {\n  EXPECT_EQ(\"f(g(R\\\"x(raw literal)x\\\", a), b);\",\n            format(\"f(g(R\\\"x(raw literal)x\\\",   a), b);\", getGoogleStyle()));\n  EXPECT_EQ(\"fffffffffff(g(R\\\"x(\\n\"\n            \"multiline raw string literal xxxxxxxxxxxxxx\\n\"\n            \")x\\\",\\n\"\n            \"              a),\\n\"\n            \"            b);\",\n            format(\"fffffffffff(g(R\\\"x(\\n\"\n                   \"multiline raw string literal xxxxxxxxxxxxxx\\n\"\n                   \")x\\\", a), b);\",\n                   getGoogleStyleWithColumns(20)));\n  EXPECT_EQ(\"fffffffffff(\\n\"\n            \"    g(R\\\"x(qqq\\n\"\n            \"multiline raw string literal xxxxxxxxxxxxxx\\n\"\n            \")x\\\",\\n\"\n            \"      a),\\n\"\n            \"    b);\",\n            format(\"fffffffffff(g(R\\\"x(qqq\\n\"\n                   \"multiline raw string literal xxxxxxxxxxxxxx\\n\"\n                   \")x\\\", a), b);\",\n                   getGoogleStyleWithColumns(20)));\n\n  EXPECT_EQ(\"fffffffffff(R\\\"x(\\n\"\n            \"multiline raw string literal xxxxxxxxxxxxxx\\n\"\n            \")x\\\");\",\n            format(\"fffffffffff(R\\\"x(\\n\"\n                   \"multiline raw string literal xxxxxxxxxxxxxx\\n\"\n                   \")x\\\");\",\n                   getGoogleStyleWithColumns(20)));\n  EXPECT_EQ(\"fffffffffff(R\\\"x(\\n\"\n            \"multiline raw string literal xxxxxxxxxxxxxx\\n\"\n            \")x\\\" + bbbbbb);\",\n            format(\"fffffffffff(R\\\"x(\\n\"\n                   \"multiline raw string literal xxxxxxxxxxxxxx\\n\"\n                   \")x\\\" +   bbbbbb);\",\n                   getGoogleStyleWithColumns(20)));\n  EXPECT_EQ(\"fffffffffff(\\n\"\n            \"    R\\\"x(\\n\"\n            \"multiline raw string literal xxxxxxxxxxxxxx\\n\"\n            \")x\\\" +\\n\"\n            \"    bbbbbb);\",\n            format(\"fffffffffff(\\n\"\n                   \" R\\\"x(\\n\"\n                   \"multiline raw string literal xxxxxxxxxxxxxx\\n\"\n                   \")x\\\" + bbbbbb);\",\n                   getGoogleStyleWithColumns(20)));\n  EXPECT_EQ(\"fffffffffff(R\\\"(single line raw string)\\\" + bbbbbb);\",\n            format(\"fffffffffff(\\n\"\n                   \" R\\\"(single line raw string)\\\" + bbbbbb);\"));\n}\n\nTEST_F(FormatTest, SkipsUnknownStringLiterals) {\n  verifyFormat(\"string a = \\\"unterminated;\");\n  EXPECT_EQ(\"function(\\\"unterminated,\\n\"\n            \"         OtherParameter);\",\n            format(\"function(  \\\"unterminated,\\n\"\n                   \"    OtherParameter);\"));\n}\n\nTEST_F(FormatTest, DoesNotTryToParseUDLiteralsInPreCpp11Code) {\n  FormatStyle Style = getLLVMStyle();\n  Style.Standard = FormatStyle::LS_Cpp03;\n  EXPECT_EQ(\"#define x(_a) printf(\\\"foo\\\" _a);\",\n            format(\"#define x(_a) printf(\\\"foo\\\"_a);\", Style));\n}\n\nTEST_F(FormatTest, CppLexVersion) {\n  FormatStyle Style = getLLVMStyle();\n  // Formatting of x * y differs if x is a type.\n  verifyFormat(\"void foo() { MACRO(a * b); }\", Style);\n  verifyFormat(\"void foo() { MACRO(int *b); }\", Style);\n\n  // LLVM style uses latest lexer.\n  verifyFormat(\"void foo() { MACRO(char8_t *b); }\", Style);\n  Style.Standard = FormatStyle::LS_Cpp17;\n  // But in c++17, char8_t isn't a keyword.\n  verifyFormat(\"void foo() { MACRO(char8_t * b); }\", Style);\n}\n\nTEST_F(FormatTest, UnderstandsCpp1y) { verifyFormat(\"int bi{1'000'000};\"); }\n\nTEST_F(FormatTest, BreakStringLiteralsBeforeUnbreakableTokenSequence) {\n  EXPECT_EQ(\"someFunction(\\\"aaabbbcccd\\\"\\n\"\n            \"             \\\"ddeeefff\\\");\",\n            format(\"someFunction(\\\"aaabbbcccdddeeefff\\\");\",\n                   getLLVMStyleWithColumns(25)));\n  EXPECT_EQ(\"someFunction1234567890(\\n\"\n            \"    \\\"aaabbbcccdddeeefff\\\");\",\n            format(\"someFunction1234567890(\\\"aaabbbcccdddeeefff\\\");\",\n                   getLLVMStyleWithColumns(26)));\n  EXPECT_EQ(\"someFunction1234567890(\\n\"\n            \"    \\\"aaabbbcccdddeeeff\\\"\\n\"\n            \"    \\\"f\\\");\",\n            format(\"someFunction1234567890(\\\"aaabbbcccdddeeefff\\\");\",\n                   getLLVMStyleWithColumns(25)));\n  EXPECT_EQ(\"someFunction1234567890(\\n\"\n            \"    \\\"aaabbbcccdddeeeff\\\"\\n\"\n            \"    \\\"f\\\");\",\n            format(\"someFunction1234567890(\\\"aaabbbcccdddeeefff\\\");\",\n                   getLLVMStyleWithColumns(24)));\n  EXPECT_EQ(\"someFunction(\\n\"\n            \"    \\\"aaabbbcc ddde \\\"\\n\"\n            \"    \\\"efff\\\");\",\n            format(\"someFunction(\\\"aaabbbcc ddde efff\\\");\",\n                   getLLVMStyleWithColumns(25)));\n  EXPECT_EQ(\"someFunction(\\\"aaabbbccc \\\"\\n\"\n            \"             \\\"ddeeefff\\\");\",\n            format(\"someFunction(\\\"aaabbbccc ddeeefff\\\");\",\n                   getLLVMStyleWithColumns(25)));\n  EXPECT_EQ(\"someFunction1234567890(\\n\"\n            \"    \\\"aaabb \\\"\\n\"\n            \"    \\\"cccdddeeefff\\\");\",\n            format(\"someFunction1234567890(\\\"aaabb cccdddeeefff\\\");\",\n                   getLLVMStyleWithColumns(25)));\n  EXPECT_EQ(\"#define A          \\\\\\n\"\n            \"  string s =       \\\\\\n\"\n            \"      \\\"123456789\\\"  \\\\\\n\"\n            \"      \\\"0\\\";         \\\\\\n\"\n            \"  int i;\",\n            format(\"#define A string s = \\\"1234567890\\\"; int i;\",\n                   getLLVMStyleWithColumns(20)));\n  EXPECT_EQ(\"someFunction(\\n\"\n            \"    \\\"aaabbbcc \\\"\\n\"\n            \"    \\\"dddeeefff\\\");\",\n            format(\"someFunction(\\\"aaabbbcc dddeeefff\\\");\",\n                   getLLVMStyleWithColumns(25)));\n}\n\nTEST_F(FormatTest, DoNotBreakStringLiteralsInEscapeSequence) {\n  EXPECT_EQ(\"\\\"\\\\a\\\"\", format(\"\\\"\\\\a\\\"\", getLLVMStyleWithColumns(3)));\n  EXPECT_EQ(\"\\\"\\\\\\\"\", format(\"\\\"\\\\\\\"\", getLLVMStyleWithColumns(2)));\n  EXPECT_EQ(\"\\\"test\\\"\\n\"\n            \"\\\"\\\\n\\\"\",\n            format(\"\\\"test\\\\n\\\"\", getLLVMStyleWithColumns(7)));\n  EXPECT_EQ(\"\\\"tes\\\\\\\\\\\"\\n\"\n            \"\\\"n\\\"\",\n            format(\"\\\"tes\\\\\\\\n\\\"\", getLLVMStyleWithColumns(7)));\n  EXPECT_EQ(\"\\\"\\\\\\\\\\\\\\\\\\\"\\n\"\n            \"\\\"\\\\n\\\"\",\n            format(\"\\\"\\\\\\\\\\\\\\\\\\\\n\\\"\", getLLVMStyleWithColumns(7)));\n  EXPECT_EQ(\"\\\"\\\\uff01\\\"\", format(\"\\\"\\\\uff01\\\"\", getLLVMStyleWithColumns(7)));\n  EXPECT_EQ(\"\\\"\\\\uff01\\\"\\n\"\n            \"\\\"test\\\"\",\n            format(\"\\\"\\\\uff01test\\\"\", getLLVMStyleWithColumns(8)));\n  EXPECT_EQ(\"\\\"\\\\Uff01ff02\\\"\",\n            format(\"\\\"\\\\Uff01ff02\\\"\", getLLVMStyleWithColumns(11)));\n  EXPECT_EQ(\"\\\"\\\\x000000000001\\\"\\n\"\n            \"\\\"next\\\"\",\n            format(\"\\\"\\\\x000000000001next\\\"\", getLLVMStyleWithColumns(16)));\n  EXPECT_EQ(\"\\\"\\\\x000000000001next\\\"\",\n            format(\"\\\"\\\\x000000000001next\\\"\", getLLVMStyleWithColumns(15)));\n  EXPECT_EQ(\"\\\"\\\\x000000000001\\\"\",\n            format(\"\\\"\\\\x000000000001\\\"\", getLLVMStyleWithColumns(7)));\n  EXPECT_EQ(\"\\\"test\\\"\\n\"\n            \"\\\"\\\\000000\\\"\\n\"\n            \"\\\"000001\\\"\",\n            format(\"\\\"test\\\\000000000001\\\"\", getLLVMStyleWithColumns(9)));\n  EXPECT_EQ(\"\\\"test\\\\000\\\"\\n\"\n            \"\\\"00000000\\\"\\n\"\n            \"\\\"1\\\"\",\n            format(\"\\\"test\\\\000000000001\\\"\", getLLVMStyleWithColumns(10)));\n}\n\nTEST_F(FormatTest, DoNotCreateUnreasonableUnwrappedLines) {\n  verifyFormat(\"void f() {\\n\"\n               \"  return g() {}\\n\"\n               \"  void h() {}\");\n  verifyFormat(\"int a[] = {void forgot_closing_brace(){f();\\n\"\n               \"g();\\n\"\n               \"}\");\n}\n\nTEST_F(FormatTest, DoNotPrematurelyEndUnwrappedLineForReturnStatements) {\n  verifyFormat(\n      \"void f() { return C{param1, param2}.SomeCall(param1, param2); }\");\n}\n\nTEST_F(FormatTest, FormatsClosingBracesInEmptyNestedBlocks) {\n  verifyFormat(\"class X {\\n\"\n               \"  void f() {\\n\"\n               \"  }\\n\"\n               \"};\",\n               getLLVMStyleWithColumns(12));\n}\n\nTEST_F(FormatTest, ConfigurableIndentWidth) {\n  FormatStyle EightIndent = getLLVMStyleWithColumns(18);\n  EightIndent.IndentWidth = 8;\n  EightIndent.ContinuationIndentWidth = 8;\n  verifyFormat(\"void f() {\\n\"\n               \"        someFunction();\\n\"\n               \"        if (true) {\\n\"\n               \"                f();\\n\"\n               \"        }\\n\"\n               \"}\",\n               EightIndent);\n  verifyFormat(\"class X {\\n\"\n               \"        void f() {\\n\"\n               \"        }\\n\"\n               \"};\",\n               EightIndent);\n  verifyFormat(\"int x[] = {\\n\"\n               \"        call(),\\n\"\n               \"        call()};\",\n               EightIndent);\n}\n\nTEST_F(FormatTest, ConfigurableFunctionDeclarationIndentAfterType) {\n  verifyFormat(\"double\\n\"\n               \"f();\",\n               getLLVMStyleWithColumns(8));\n}\n\nTEST_F(FormatTest, ConfigurableUseOfTab) {\n  FormatStyle Tab = getLLVMStyleWithColumns(42);\n  Tab.IndentWidth = 8;\n  Tab.UseTab = FormatStyle::UT_Always;\n  Tab.AlignEscapedNewlines = FormatStyle::ENAS_Left;\n\n  EXPECT_EQ(\"if (aaaaaaaa && // q\\n\"\n            \"    bb)\\t\\t// w\\n\"\n            \"\\t;\",\n            format(\"if (aaaaaaaa &&// q\\n\"\n                   \"bb)// w\\n\"\n                   \";\",\n                   Tab));\n  EXPECT_EQ(\"if (aaa && bbb) // w\\n\"\n            \"\\t;\",\n            format(\"if(aaa&&bbb)// w\\n\"\n                   \";\",\n                   Tab));\n\n  verifyFormat(\"class X {\\n\"\n               \"\\tvoid f() {\\n\"\n               \"\\t\\tsomeFunction(parameter1,\\n\"\n               \"\\t\\t\\t     parameter2);\\n\"\n               \"\\t}\\n\"\n               \"};\",\n               Tab);\n  verifyFormat(\"#define A                        \\\\\\n\"\n               \"\\tvoid f() {               \\\\\\n\"\n               \"\\t\\tsomeFunction(    \\\\\\n\"\n               \"\\t\\t    parameter1,  \\\\\\n\"\n               \"\\t\\t    parameter2); \\\\\\n\"\n               \"\\t}\",\n               Tab);\n  verifyFormat(\"int a;\\t      // x\\n\"\n               \"int bbbbbbbb; // x\\n\",\n               Tab);\n\n  Tab.TabWidth = 4;\n  Tab.IndentWidth = 8;\n  verifyFormat(\"class TabWidth4Indent8 {\\n\"\n               \"\\t\\tvoid f() {\\n\"\n               \"\\t\\t\\t\\tsomeFunction(parameter1,\\n\"\n               \"\\t\\t\\t\\t\\t\\t\\t parameter2);\\n\"\n               \"\\t\\t}\\n\"\n               \"};\",\n               Tab);\n\n  Tab.TabWidth = 4;\n  Tab.IndentWidth = 4;\n  verifyFormat(\"class TabWidth4Indent4 {\\n\"\n               \"\\tvoid f() {\\n\"\n               \"\\t\\tsomeFunction(parameter1,\\n\"\n               \"\\t\\t\\t\\t\\t parameter2);\\n\"\n               \"\\t}\\n\"\n               \"};\",\n               Tab);\n\n  Tab.TabWidth = 8;\n  Tab.IndentWidth = 4;\n  verifyFormat(\"class TabWidth8Indent4 {\\n\"\n               \"    void f() {\\n\"\n               \"\\tsomeFunction(parameter1,\\n\"\n               \"\\t\\t     parameter2);\\n\"\n               \"    }\\n\"\n               \"};\",\n               Tab);\n\n  Tab.TabWidth = 8;\n  Tab.IndentWidth = 8;\n  EXPECT_EQ(\"/*\\n\"\n            \"\\t      a\\t\\tcomment\\n\"\n            \"\\t      in multiple lines\\n\"\n            \"       */\",\n            format(\"   /*\\t \\t \\n\"\n                   \" \\t \\t a\\t\\tcomment\\t \\t\\n\"\n                   \" \\t \\t in multiple lines\\t\\n\"\n                   \" \\t  */\",\n                   Tab));\n\n  Tab.UseTab = FormatStyle::UT_ForIndentation;\n  verifyFormat(\"{\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"};\",\n               Tab);\n  verifyFormat(\"enum AA {\\n\"\n               \"\\ta1, // Force multiple lines\\n\"\n               \"\\ta2,\\n\"\n               \"\\ta3\\n\"\n               \"};\",\n               Tab);\n  EXPECT_EQ(\"if (aaaaaaaa && // q\\n\"\n            \"    bb)         // w\\n\"\n            \"\\t;\",\n            format(\"if (aaaaaaaa &&// q\\n\"\n                   \"bb)// w\\n\"\n                   \";\",\n                   Tab));\n  verifyFormat(\"class X {\\n\"\n               \"\\tvoid f() {\\n\"\n               \"\\t\\tsomeFunction(parameter1,\\n\"\n               \"\\t\\t             parameter2);\\n\"\n               \"\\t}\\n\"\n               \"};\",\n               Tab);\n  verifyFormat(\"{\\n\"\n               \"\\tQ(\\n\"\n               \"\\t    {\\n\"\n               \"\\t\\t    int a;\\n\"\n               \"\\t\\t    someFunction(aaaaaaaa,\\n\"\n               \"\\t\\t                 bbbbbbb);\\n\"\n               \"\\t    },\\n\"\n               \"\\t    p);\\n\"\n               \"}\",\n               Tab);\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/* aaaa\\n\"\n            \"\\t   bbbb */\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"/* aaaa\\n\"\n                   \"   bbbb */\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/*\\n\"\n            \"\\t  aaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n            \"\\t  bbbbbbbbbbbbb\\n\"\n            \"\\t*/\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"/*\\n\"\n                   \"  aaaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbb\\n\"\n                   \"*/\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t// aaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n            \"\\t// bbbbbbbbbbbbb\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"\\t// aaaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbb\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/*\\n\"\n            \"\\t  aaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n            \"\\t  bbbbbbbbbbbbb\\n\"\n            \"\\t*/\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"\\t/*\\n\"\n                   \"\\t  aaaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbb\\n\"\n                   \"\\t*/\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/*\\n\"\n            \"\\n\"\n            \"\\t*/\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"\\t/*\\n\"\n                   \"\\n\"\n                   \"\\t*/\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/*\\n\"\n            \" asdf\\n\"\n            \"\\t*/\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"\\t/*\\n\"\n                   \" asdf\\n\"\n                   \"\\t*/\\n\"\n                   \"}\",\n                   Tab));\n\n  Tab.UseTab = FormatStyle::UT_Never;\n  EXPECT_EQ(\"/*\\n\"\n            \"              a\\t\\tcomment\\n\"\n            \"              in multiple lines\\n\"\n            \"       */\",\n            format(\"   /*\\t \\t \\n\"\n                   \" \\t \\t a\\t\\tcomment\\t \\t\\n\"\n                   \" \\t \\t in multiple lines\\t\\n\"\n                   \" \\t  */\",\n                   Tab));\n  EXPECT_EQ(\"/* some\\n\"\n            \"   comment */\",\n            format(\" \\t \\t /* some\\n\"\n                   \" \\t \\t    comment */\",\n                   Tab));\n  EXPECT_EQ(\"int a; /* some\\n\"\n            \"   comment */\",\n            format(\" \\t \\t int a; /* some\\n\"\n                   \" \\t \\t    comment */\",\n                   Tab));\n\n  EXPECT_EQ(\"int a; /* some\\n\"\n            \"comment */\",\n            format(\" \\t \\t int\\ta; /* some\\n\"\n                   \" \\t \\t    comment */\",\n                   Tab));\n  EXPECT_EQ(\"f(\\\"\\t\\t\\\"); /* some\\n\"\n            \"    comment */\",\n            format(\" \\t \\t f(\\\"\\t\\t\\\"); /* some\\n\"\n                   \" \\t \\t    comment */\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"        /*\\n\"\n            \"         * Comment\\n\"\n            \"         */\\n\"\n            \"        int i;\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"\\t/*\\n\"\n                   \"\\t * Comment\\n\"\n                   \"\\t */\\n\"\n                   \"\\t int i;\\n\"\n                   \"}\",\n                   Tab));\n\n  Tab.UseTab = FormatStyle::UT_ForContinuationAndIndentation;\n  Tab.TabWidth = 8;\n  Tab.IndentWidth = 8;\n  EXPECT_EQ(\"if (aaaaaaaa && // q\\n\"\n            \"    bb)         // w\\n\"\n            \"\\t;\",\n            format(\"if (aaaaaaaa &&// q\\n\"\n                   \"bb)// w\\n\"\n                   \";\",\n                   Tab));\n  EXPECT_EQ(\"if (aaa && bbb) // w\\n\"\n            \"\\t;\",\n            format(\"if(aaa&&bbb)// w\\n\"\n                   \";\",\n                   Tab));\n  verifyFormat(\"class X {\\n\"\n               \"\\tvoid f() {\\n\"\n               \"\\t\\tsomeFunction(parameter1,\\n\"\n               \"\\t\\t\\t     parameter2);\\n\"\n               \"\\t}\\n\"\n               \"};\",\n               Tab);\n  verifyFormat(\"#define A                        \\\\\\n\"\n               \"\\tvoid f() {               \\\\\\n\"\n               \"\\t\\tsomeFunction(    \\\\\\n\"\n               \"\\t\\t    parameter1,  \\\\\\n\"\n               \"\\t\\t    parameter2); \\\\\\n\"\n               \"\\t}\",\n               Tab);\n  Tab.TabWidth = 4;\n  Tab.IndentWidth = 8;\n  verifyFormat(\"class TabWidth4Indent8 {\\n\"\n               \"\\t\\tvoid f() {\\n\"\n               \"\\t\\t\\t\\tsomeFunction(parameter1,\\n\"\n               \"\\t\\t\\t\\t\\t\\t\\t parameter2);\\n\"\n               \"\\t\\t}\\n\"\n               \"};\",\n               Tab);\n  Tab.TabWidth = 4;\n  Tab.IndentWidth = 4;\n  verifyFormat(\"class TabWidth4Indent4 {\\n\"\n               \"\\tvoid f() {\\n\"\n               \"\\t\\tsomeFunction(parameter1,\\n\"\n               \"\\t\\t\\t\\t\\t parameter2);\\n\"\n               \"\\t}\\n\"\n               \"};\",\n               Tab);\n  Tab.TabWidth = 8;\n  Tab.IndentWidth = 4;\n  verifyFormat(\"class TabWidth8Indent4 {\\n\"\n               \"    void f() {\\n\"\n               \"\\tsomeFunction(parameter1,\\n\"\n               \"\\t\\t     parameter2);\\n\"\n               \"    }\\n\"\n               \"};\",\n               Tab);\n  Tab.TabWidth = 8;\n  Tab.IndentWidth = 8;\n  EXPECT_EQ(\"/*\\n\"\n            \"\\t      a\\t\\tcomment\\n\"\n            \"\\t      in multiple lines\\n\"\n            \"       */\",\n            format(\"   /*\\t \\t \\n\"\n                   \" \\t \\t a\\t\\tcomment\\t \\t\\n\"\n                   \" \\t \\t in multiple lines\\t\\n\"\n                   \" \\t  */\",\n                   Tab));\n  verifyFormat(\"{\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"};\",\n               Tab);\n  verifyFormat(\"enum AA {\\n\"\n               \"\\ta1, // Force multiple lines\\n\"\n               \"\\ta2,\\n\"\n               \"\\ta3\\n\"\n               \"};\",\n               Tab);\n  EXPECT_EQ(\"if (aaaaaaaa && // q\\n\"\n            \"    bb)         // w\\n\"\n            \"\\t;\",\n            format(\"if (aaaaaaaa &&// q\\n\"\n                   \"bb)// w\\n\"\n                   \";\",\n                   Tab));\n  verifyFormat(\"class X {\\n\"\n               \"\\tvoid f() {\\n\"\n               \"\\t\\tsomeFunction(parameter1,\\n\"\n               \"\\t\\t\\t     parameter2);\\n\"\n               \"\\t}\\n\"\n               \"};\",\n               Tab);\n  verifyFormat(\"{\\n\"\n               \"\\tQ(\\n\"\n               \"\\t    {\\n\"\n               \"\\t\\t    int a;\\n\"\n               \"\\t\\t    someFunction(aaaaaaaa,\\n\"\n               \"\\t\\t\\t\\t bbbbbbb);\\n\"\n               \"\\t    },\\n\"\n               \"\\t    p);\\n\"\n               \"}\",\n               Tab);\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/* aaaa\\n\"\n            \"\\t   bbbb */\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"/* aaaa\\n\"\n                   \"   bbbb */\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/*\\n\"\n            \"\\t  aaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n            \"\\t  bbbbbbbbbbbbb\\n\"\n            \"\\t*/\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"/*\\n\"\n                   \"  aaaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbb\\n\"\n                   \"*/\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t// aaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n            \"\\t// bbbbbbbbbbbbb\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"\\t// aaaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbb\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/*\\n\"\n            \"\\t  aaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n            \"\\t  bbbbbbbbbbbbb\\n\"\n            \"\\t*/\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"\\t/*\\n\"\n                   \"\\t  aaaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbb\\n\"\n                   \"\\t*/\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/*\\n\"\n            \"\\n\"\n            \"\\t*/\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"\\t/*\\n\"\n                   \"\\n\"\n                   \"\\t*/\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/*\\n\"\n            \" asdf\\n\"\n            \"\\t*/\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"\\t/*\\n\"\n                   \" asdf\\n\"\n                   \"\\t*/\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"/* some\\n\"\n            \"   comment */\",\n            format(\" \\t \\t /* some\\n\"\n                   \" \\t \\t    comment */\",\n                   Tab));\n  EXPECT_EQ(\"int a; /* some\\n\"\n            \"   comment */\",\n            format(\" \\t \\t int a; /* some\\n\"\n                   \" \\t \\t    comment */\",\n                   Tab));\n  EXPECT_EQ(\"int a; /* some\\n\"\n            \"comment */\",\n            format(\" \\t \\t int\\ta; /* some\\n\"\n                   \" \\t \\t    comment */\",\n                   Tab));\n  EXPECT_EQ(\"f(\\\"\\t\\t\\\"); /* some\\n\"\n            \"    comment */\",\n            format(\" \\t \\t f(\\\"\\t\\t\\\"); /* some\\n\"\n                   \" \\t \\t    comment */\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/*\\n\"\n            \"\\t * Comment\\n\"\n            \"\\t */\\n\"\n            \"\\tint i;\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"\\t/*\\n\"\n                   \"\\t * Comment\\n\"\n                   \"\\t */\\n\"\n                   \"\\t int i;\\n\"\n                   \"}\",\n                   Tab));\n  Tab.TabWidth = 2;\n  Tab.IndentWidth = 2;\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/* aaaa\\n\"\n            \"\\t\\t bbbb */\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"/* aaaa\\n\"\n                   \"\\t bbbb */\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/*\\n\"\n            \"\\t\\taaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n            \"\\t\\tbbbbbbbbbbbbb\\n\"\n            \"\\t*/\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"/*\\n\"\n                   \"\\taaaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbb\\n\"\n                   \"*/\\n\"\n                   \"}\",\n                   Tab));\n  Tab.AlignConsecutiveAssignments = FormatStyle::ACS_Consecutive;\n  Tab.AlignConsecutiveDeclarations = FormatStyle::ACS_Consecutive;\n  Tab.TabWidth = 4;\n  Tab.IndentWidth = 4;\n  verifyFormat(\"class Assign {\\n\"\n               \"\\tvoid f() {\\n\"\n               \"\\t\\tint         x      = 123;\\n\"\n               \"\\t\\tint         random = 4;\\n\"\n               \"\\t\\tstd::string alphabet =\\n\"\n               \"\\t\\t\\t\\\"abcdefghijklmnopqrstuvwxyz\\\";\\n\"\n               \"\\t}\\n\"\n               \"};\",\n               Tab);\n\n  Tab.UseTab = FormatStyle::UT_AlignWithSpaces;\n  Tab.TabWidth = 8;\n  Tab.IndentWidth = 8;\n  EXPECT_EQ(\"if (aaaaaaaa && // q\\n\"\n            \"    bb)         // w\\n\"\n            \"\\t;\",\n            format(\"if (aaaaaaaa &&// q\\n\"\n                   \"bb)// w\\n\"\n                   \";\",\n                   Tab));\n  EXPECT_EQ(\"if (aaa && bbb) // w\\n\"\n            \"\\t;\",\n            format(\"if(aaa&&bbb)// w\\n\"\n                   \";\",\n                   Tab));\n  verifyFormat(\"class X {\\n\"\n               \"\\tvoid f() {\\n\"\n               \"\\t\\tsomeFunction(parameter1,\\n\"\n               \"\\t\\t             parameter2);\\n\"\n               \"\\t}\\n\"\n               \"};\",\n               Tab);\n  verifyFormat(\"#define A                        \\\\\\n\"\n               \"\\tvoid f() {               \\\\\\n\"\n               \"\\t\\tsomeFunction(    \\\\\\n\"\n               \"\\t\\t    parameter1,  \\\\\\n\"\n               \"\\t\\t    parameter2); \\\\\\n\"\n               \"\\t}\",\n               Tab);\n  Tab.TabWidth = 4;\n  Tab.IndentWidth = 8;\n  verifyFormat(\"class TabWidth4Indent8 {\\n\"\n               \"\\t\\tvoid f() {\\n\"\n               \"\\t\\t\\t\\tsomeFunction(parameter1,\\n\"\n               \"\\t\\t\\t\\t             parameter2);\\n\"\n               \"\\t\\t}\\n\"\n               \"};\",\n               Tab);\n  Tab.TabWidth = 4;\n  Tab.IndentWidth = 4;\n  verifyFormat(\"class TabWidth4Indent4 {\\n\"\n               \"\\tvoid f() {\\n\"\n               \"\\t\\tsomeFunction(parameter1,\\n\"\n               \"\\t\\t             parameter2);\\n\"\n               \"\\t}\\n\"\n               \"};\",\n               Tab);\n  Tab.TabWidth = 8;\n  Tab.IndentWidth = 4;\n  verifyFormat(\"class TabWidth8Indent4 {\\n\"\n               \"    void f() {\\n\"\n               \"\\tsomeFunction(parameter1,\\n\"\n               \"\\t             parameter2);\\n\"\n               \"    }\\n\"\n               \"};\",\n               Tab);\n  Tab.TabWidth = 8;\n  Tab.IndentWidth = 8;\n  EXPECT_EQ(\"/*\\n\"\n            \"              a\\t\\tcomment\\n\"\n            \"              in multiple lines\\n\"\n            \"       */\",\n            format(\"   /*\\t \\t \\n\"\n                   \" \\t \\t a\\t\\tcomment\\t \\t\\n\"\n                   \" \\t \\t in multiple lines\\t\\n\"\n                   \" \\t  */\",\n                   Tab));\n  verifyFormat(\"{\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"\\taaaaaaaaaaaaaaaaaaaaaaaaaaaa();\\n\"\n               \"};\",\n               Tab);\n  verifyFormat(\"enum AA {\\n\"\n               \"\\ta1, // Force multiple lines\\n\"\n               \"\\ta2,\\n\"\n               \"\\ta3\\n\"\n               \"};\",\n               Tab);\n  EXPECT_EQ(\"if (aaaaaaaa && // q\\n\"\n            \"    bb)         // w\\n\"\n            \"\\t;\",\n            format(\"if (aaaaaaaa &&// q\\n\"\n                   \"bb)// w\\n\"\n                   \";\",\n                   Tab));\n  verifyFormat(\"class X {\\n\"\n               \"\\tvoid f() {\\n\"\n               \"\\t\\tsomeFunction(parameter1,\\n\"\n               \"\\t\\t             parameter2);\\n\"\n               \"\\t}\\n\"\n               \"};\",\n               Tab);\n  verifyFormat(\"{\\n\"\n               \"\\tQ(\\n\"\n               \"\\t    {\\n\"\n               \"\\t\\t    int a;\\n\"\n               \"\\t\\t    someFunction(aaaaaaaa,\\n\"\n               \"\\t\\t                 bbbbbbb);\\n\"\n               \"\\t    },\\n\"\n               \"\\t    p);\\n\"\n               \"}\",\n               Tab);\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/* aaaa\\n\"\n            \"\\t   bbbb */\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"/* aaaa\\n\"\n                   \"   bbbb */\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/*\\n\"\n            \"\\t  aaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n            \"\\t  bbbbbbbbbbbbb\\n\"\n            \"\\t*/\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"/*\\n\"\n                   \"  aaaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbb\\n\"\n                   \"*/\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t// aaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n            \"\\t// bbbbbbbbbbbbb\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"\\t// aaaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbb\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/*\\n\"\n            \"\\t  aaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n            \"\\t  bbbbbbbbbbbbb\\n\"\n            \"\\t*/\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"\\t/*\\n\"\n                   \"\\t  aaaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbb\\n\"\n                   \"\\t*/\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/*\\n\"\n            \"\\n\"\n            \"\\t*/\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"\\t/*\\n\"\n                   \"\\n\"\n                   \"\\t*/\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/*\\n\"\n            \" asdf\\n\"\n            \"\\t*/\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"\\t/*\\n\"\n                   \" asdf\\n\"\n                   \"\\t*/\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"/* some\\n\"\n            \"   comment */\",\n            format(\" \\t \\t /* some\\n\"\n                   \" \\t \\t    comment */\",\n                   Tab));\n  EXPECT_EQ(\"int a; /* some\\n\"\n            \"   comment */\",\n            format(\" \\t \\t int a; /* some\\n\"\n                   \" \\t \\t    comment */\",\n                   Tab));\n  EXPECT_EQ(\"int a; /* some\\n\"\n            \"comment */\",\n            format(\" \\t \\t int\\ta; /* some\\n\"\n                   \" \\t \\t    comment */\",\n                   Tab));\n  EXPECT_EQ(\"f(\\\"\\t\\t\\\"); /* some\\n\"\n            \"    comment */\",\n            format(\" \\t \\t f(\\\"\\t\\t\\\"); /* some\\n\"\n                   \" \\t \\t    comment */\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/*\\n\"\n            \"\\t * Comment\\n\"\n            \"\\t */\\n\"\n            \"\\tint i;\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"\\t/*\\n\"\n                   \"\\t * Comment\\n\"\n                   \"\\t */\\n\"\n                   \"\\t int i;\\n\"\n                   \"}\",\n                   Tab));\n  Tab.TabWidth = 2;\n  Tab.IndentWidth = 2;\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/* aaaa\\n\"\n            \"\\t   bbbb */\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"/* aaaa\\n\"\n                   \"   bbbb */\\n\"\n                   \"}\",\n                   Tab));\n  EXPECT_EQ(\"{\\n\"\n            \"\\t/*\\n\"\n            \"\\t  aaaaaaaaaaaaaaaaaaaaaaaaaa\\n\"\n            \"\\t  bbbbbbbbbbbbb\\n\"\n            \"\\t*/\\n\"\n            \"}\",\n            format(\"{\\n\"\n                   \"/*\\n\"\n                   \"  aaaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbb\\n\"\n                   \"*/\\n\"\n                   \"}\",\n                   Tab));\n  Tab.AlignConsecutiveAssignments = FormatStyle::ACS_Consecutive;\n  Tab.AlignConsecutiveDeclarations = FormatStyle::ACS_Consecutive;\n  Tab.TabWidth = 4;\n  Tab.IndentWidth = 4;\n  verifyFormat(\"class Assign {\\n\"\n               \"\\tvoid f() {\\n\"\n               \"\\t\\tint         x      = 123;\\n\"\n               \"\\t\\tint         random = 4;\\n\"\n               \"\\t\\tstd::string alphabet =\\n\"\n               \"\\t\\t\\t\\\"abcdefghijklmnopqrstuvwxyz\\\";\\n\"\n               \"\\t}\\n\"\n               \"};\",\n               Tab);\n  Tab.AlignOperands = FormatStyle::OAS_Align;\n  verifyFormat(\"int aaaaaaaaaa = bbbbbbbbbbbbbbbbbbbb +\\n\"\n               \"                 cccccccccccccccccccc;\",\n               Tab);\n  // no alignment\n  verifyFormat(\"int aaaaaaaaaa =\\n\"\n               \"\\tbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\",\n               Tab);\n  verifyFormat(\"return aaaaaaaaaaaaaaaa ? 111111111111111\\n\"\n               \"       : bbbbbbbbbbbbbb ? 222222222222222\\n\"\n               \"                        : 333333333333333;\",\n               Tab);\n  Tab.BreakBeforeBinaryOperators = FormatStyle::BOS_All;\n  Tab.AlignOperands = FormatStyle::OAS_AlignAfterOperator;\n  verifyFormat(\"int aaaaaaaaaa = bbbbbbbbbbbbbbbbbbbb\\n\"\n               \"               + cccccccccccccccccccc;\",\n               Tab);\n}\n\nTEST_F(FormatTest, ZeroTabWidth) {\n  FormatStyle Tab = getLLVMStyleWithColumns(42);\n  Tab.IndentWidth = 8;\n  Tab.UseTab = FormatStyle::UT_Never;\n  Tab.TabWidth = 0;\n  EXPECT_EQ(\"void a(){\\n\"\n            \"    // line starts with '\\t'\\n\"\n            \"};\",\n            format(\"void a(){\\n\"\n                   \"\\t// line starts with '\\t'\\n\"\n                   \"};\",\n                   Tab));\n\n  EXPECT_EQ(\"void a(){\\n\"\n            \"    // line starts with '\\t'\\n\"\n            \"};\",\n            format(\"void a(){\\n\"\n                   \"\\t\\t// line starts with '\\t'\\n\"\n                   \"};\",\n                   Tab));\n\n  Tab.UseTab = FormatStyle::UT_ForIndentation;\n  EXPECT_EQ(\"void a(){\\n\"\n            \"    // line starts with '\\t'\\n\"\n            \"};\",\n            format(\"void a(){\\n\"\n                   \"\\t// line starts with '\\t'\\n\"\n                   \"};\",\n                   Tab));\n\n  EXPECT_EQ(\"void a(){\\n\"\n            \"    // line starts with '\\t'\\n\"\n            \"};\",\n            format(\"void a(){\\n\"\n                   \"\\t\\t// line starts with '\\t'\\n\"\n                   \"};\",\n                   Tab));\n\n  Tab.UseTab = FormatStyle::UT_ForContinuationAndIndentation;\n  EXPECT_EQ(\"void a(){\\n\"\n            \"    // line starts with '\\t'\\n\"\n            \"};\",\n            format(\"void a(){\\n\"\n                   \"\\t// line starts with '\\t'\\n\"\n                   \"};\",\n                   Tab));\n\n  EXPECT_EQ(\"void a(){\\n\"\n            \"    // line starts with '\\t'\\n\"\n            \"};\",\n            format(\"void a(){\\n\"\n                   \"\\t\\t// line starts with '\\t'\\n\"\n                   \"};\",\n                   Tab));\n\n  Tab.UseTab = FormatStyle::UT_AlignWithSpaces;\n  EXPECT_EQ(\"void a(){\\n\"\n            \"    // line starts with '\\t'\\n\"\n            \"};\",\n            format(\"void a(){\\n\"\n                   \"\\t// line starts with '\\t'\\n\"\n                   \"};\",\n                   Tab));\n\n  EXPECT_EQ(\"void a(){\\n\"\n            \"    // line starts with '\\t'\\n\"\n            \"};\",\n            format(\"void a(){\\n\"\n                   \"\\t\\t// line starts with '\\t'\\n\"\n                   \"};\",\n                   Tab));\n\n  Tab.UseTab = FormatStyle::UT_Always;\n  EXPECT_EQ(\"void a(){\\n\"\n            \"// line starts with '\\t'\\n\"\n            \"};\",\n            format(\"void a(){\\n\"\n                   \"\\t// line starts with '\\t'\\n\"\n                   \"};\",\n                   Tab));\n\n  EXPECT_EQ(\"void a(){\\n\"\n            \"// line starts with '\\t'\\n\"\n            \"};\",\n            format(\"void a(){\\n\"\n                   \"\\t\\t// line starts with '\\t'\\n\"\n                   \"};\",\n                   Tab));\n}\n\nTEST_F(FormatTest, CalculatesOriginalColumn) {\n  EXPECT_EQ(\"\\\"qqqqqqqqqqqqqqqqqqqqqqqqqq\\\\\\n\"\n            \"q\\\"; /* some\\n\"\n            \"       comment */\",\n            format(\"  \\\"qqqqqqqqqqqqqqqqqqqqqqqqqq\\\\\\n\"\n                   \"q\\\"; /* some\\n\"\n                   \"       comment */\",\n                   getLLVMStyle()));\n  EXPECT_EQ(\"// qqqqqqqqqqqqqqqqqqqqqqqqqq\\n\"\n            \"/* some\\n\"\n            \"   comment */\",\n            format(\"// qqqqqqqqqqqqqqqqqqqqqqqqqq\\n\"\n                   \" /* some\\n\"\n                   \"    comment */\",\n                   getLLVMStyle()));\n  EXPECT_EQ(\"// qqqqqqqqqqqqqqqqqqqqqqqqqq\\\\\\n\"\n            \"qqq\\n\"\n            \"/* some\\n\"\n            \"   comment */\",\n            format(\"// qqqqqqqqqqqqqqqqqqqqqqqqqq\\\\\\n\"\n                   \"qqq\\n\"\n                   \" /* some\\n\"\n                   \"    comment */\",\n                   getLLVMStyle()));\n  EXPECT_EQ(\"inttt qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\\\\\\n\"\n            \"wwww; /* some\\n\"\n            \"         comment */\",\n            format(\"  inttt qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\\\\\\n\"\n                   \"wwww; /* some\\n\"\n                   \"         comment */\",\n                   getLLVMStyle()));\n}\n\nTEST_F(FormatTest, ConfigurableSpaceBeforeParens) {\n  FormatStyle NoSpace = getLLVMStyle();\n  NoSpace.SpaceBeforeParens = FormatStyle::SBPO_Never;\n\n  verifyFormat(\"while(true)\\n\"\n               \"  continue;\",\n               NoSpace);\n  verifyFormat(\"for(;;)\\n\"\n               \"  continue;\",\n               NoSpace);\n  verifyFormat(\"if(true)\\n\"\n               \"  f();\\n\"\n               \"else if(true)\\n\"\n               \"  f();\",\n               NoSpace);\n  verifyFormat(\"do {\\n\"\n               \"  do_something();\\n\"\n               \"} while(something());\",\n               NoSpace);\n  verifyFormat(\"switch(x) {\\n\"\n               \"default:\\n\"\n               \"  break;\\n\"\n               \"}\",\n               NoSpace);\n  verifyFormat(\"auto i = std::make_unique<int>(5);\", NoSpace);\n  verifyFormat(\"size_t x = sizeof(x);\", NoSpace);\n  verifyFormat(\"auto f(int x) -> decltype(x);\", NoSpace);\n  verifyFormat(\"auto f(int x) -> typeof(x);\", NoSpace);\n  verifyFormat(\"auto f(int x) -> _Atomic(x);\", NoSpace);\n  verifyFormat(\"auto f(int x) -> __underlying_type(x);\", NoSpace);\n  verifyFormat(\"int f(T x) noexcept(x.create());\", NoSpace);\n  verifyFormat(\"alignas(128) char a[128];\", NoSpace);\n  verifyFormat(\"size_t x = alignof(MyType);\", NoSpace);\n  verifyFormat(\"static_assert(sizeof(char) == 1, \\\"Impossible!\\\");\", NoSpace);\n  verifyFormat(\"int f() throw(Deprecated);\", NoSpace);\n  verifyFormat(\"typedef void (*cb)(int);\", NoSpace);\n  verifyFormat(\"T A::operator()();\", NoSpace);\n  verifyFormat(\"X A::operator++(T);\", NoSpace);\n  verifyFormat(\"auto lambda = []() { return 0; };\", NoSpace);\n\n  FormatStyle Space = getLLVMStyle();\n  Space.SpaceBeforeParens = FormatStyle::SBPO_Always;\n\n  verifyFormat(\"int f ();\", Space);\n  verifyFormat(\"void f (int a, T b) {\\n\"\n               \"  while (true)\\n\"\n               \"    continue;\\n\"\n               \"}\",\n               Space);\n  verifyFormat(\"if (true)\\n\"\n               \"  f ();\\n\"\n               \"else if (true)\\n\"\n               \"  f ();\",\n               Space);\n  verifyFormat(\"do {\\n\"\n               \"  do_something ();\\n\"\n               \"} while (something ());\",\n               Space);\n  verifyFormat(\"switch (x) {\\n\"\n               \"default:\\n\"\n               \"  break;\\n\"\n               \"}\",\n               Space);\n  verifyFormat(\"A::A () : a (1) {}\", Space);\n  verifyFormat(\"void f () __attribute__ ((asdf));\", Space);\n  verifyFormat(\"*(&a + 1);\\n\"\n               \"&((&a)[1]);\\n\"\n               \"a[(b + c) * d];\\n\"\n               \"(((a + 1) * 2) + 3) * 4;\",\n               Space);\n  verifyFormat(\"#define A(x) x\", Space);\n  verifyFormat(\"#define A (x) x\", Space);\n  verifyFormat(\"#if defined(x)\\n\"\n               \"#endif\",\n               Space);\n  verifyFormat(\"auto i = std::make_unique<int> (5);\", Space);\n  verifyFormat(\"size_t x = sizeof (x);\", Space);\n  verifyFormat(\"auto f (int x) -> decltype (x);\", Space);\n  verifyFormat(\"auto f (int x) -> typeof (x);\", Space);\n  verifyFormat(\"auto f (int x) -> _Atomic (x);\", Space);\n  verifyFormat(\"auto f (int x) -> __underlying_type (x);\", Space);\n  verifyFormat(\"int f (T x) noexcept (x.create ());\", Space);\n  verifyFormat(\"alignas (128) char a[128];\", Space);\n  verifyFormat(\"size_t x = alignof (MyType);\", Space);\n  verifyFormat(\"static_assert (sizeof (char) == 1, \\\"Impossible!\\\");\", Space);\n  verifyFormat(\"int f () throw (Deprecated);\", Space);\n  verifyFormat(\"typedef void (*cb) (int);\", Space);\n  verifyFormat(\"T A::operator() ();\", Space);\n  verifyFormat(\"X A::operator++ (T);\", Space);\n  verifyFormat(\"auto lambda = [] () { return 0; };\", Space);\n  verifyFormat(\"int x = int (y);\", Space);\n\n  FormatStyle SomeSpace = getLLVMStyle();\n  SomeSpace.SpaceBeforeParens = FormatStyle::SBPO_NonEmptyParentheses;\n\n  verifyFormat(\"[]() -> float {}\", SomeSpace);\n  verifyFormat(\"[] (auto foo) {}\", SomeSpace);\n  verifyFormat(\"[foo]() -> int {}\", SomeSpace);\n  verifyFormat(\"int f();\", SomeSpace);\n  verifyFormat(\"void f (int a, T b) {\\n\"\n               \"  while (true)\\n\"\n               \"    continue;\\n\"\n               \"}\",\n               SomeSpace);\n  verifyFormat(\"if (true)\\n\"\n               \"  f();\\n\"\n               \"else if (true)\\n\"\n               \"  f();\",\n               SomeSpace);\n  verifyFormat(\"do {\\n\"\n               \"  do_something();\\n\"\n               \"} while (something());\",\n               SomeSpace);\n  verifyFormat(\"switch (x) {\\n\"\n               \"default:\\n\"\n               \"  break;\\n\"\n               \"}\",\n               SomeSpace);\n  verifyFormat(\"A::A() : a (1) {}\", SomeSpace);\n  verifyFormat(\"void f() __attribute__ ((asdf));\", SomeSpace);\n  verifyFormat(\"*(&a + 1);\\n\"\n               \"&((&a)[1]);\\n\"\n               \"a[(b + c) * d];\\n\"\n               \"(((a + 1) * 2) + 3) * 4;\",\n               SomeSpace);\n  verifyFormat(\"#define A(x) x\", SomeSpace);\n  verifyFormat(\"#define A (x) x\", SomeSpace);\n  verifyFormat(\"#if defined(x)\\n\"\n               \"#endif\",\n               SomeSpace);\n  verifyFormat(\"auto i = std::make_unique<int> (5);\", SomeSpace);\n  verifyFormat(\"size_t x = sizeof (x);\", SomeSpace);\n  verifyFormat(\"auto f (int x) -> decltype (x);\", SomeSpace);\n  verifyFormat(\"auto f (int x) -> typeof (x);\", SomeSpace);\n  verifyFormat(\"auto f (int x) -> _Atomic (x);\", SomeSpace);\n  verifyFormat(\"auto f (int x) -> __underlying_type (x);\", SomeSpace);\n  verifyFormat(\"int f (T x) noexcept (x.create());\", SomeSpace);\n  verifyFormat(\"alignas (128) char a[128];\", SomeSpace);\n  verifyFormat(\"size_t x = alignof (MyType);\", SomeSpace);\n  verifyFormat(\"static_assert (sizeof (char) == 1, \\\"Impossible!\\\");\",\n               SomeSpace);\n  verifyFormat(\"int f() throw (Deprecated);\", SomeSpace);\n  verifyFormat(\"typedef void (*cb) (int);\", SomeSpace);\n  verifyFormat(\"T A::operator()();\", SomeSpace);\n  verifyFormat(\"X A::operator++ (T);\", SomeSpace);\n  verifyFormat(\"int x = int (y);\", SomeSpace);\n  verifyFormat(\"auto lambda = []() { return 0; };\", SomeSpace);\n}\n\nTEST_F(FormatTest, SpaceAfterLogicalNot) {\n  FormatStyle Spaces = getLLVMStyle();\n  Spaces.SpaceAfterLogicalNot = true;\n\n  verifyFormat(\"bool x = ! y\", Spaces);\n  verifyFormat(\"if (! isFailure())\", Spaces);\n  verifyFormat(\"if (! (a && b))\", Spaces);\n  verifyFormat(\"\\\"Error!\\\"\", Spaces);\n  verifyFormat(\"! ! x\", Spaces);\n}\n\nTEST_F(FormatTest, ConfigurableSpacesInParentheses) {\n  FormatStyle Spaces = getLLVMStyle();\n\n  Spaces.SpacesInParentheses = true;\n  verifyFormat(\"do_something( ::globalVar );\", Spaces);\n  verifyFormat(\"call( x, y, z );\", Spaces);\n  verifyFormat(\"call();\", Spaces);\n  verifyFormat(\"std::function<void( int, int )> callback;\", Spaces);\n  verifyFormat(\"void inFunction() { std::function<void( int, int )> fct; }\",\n               Spaces);\n  verifyFormat(\"while ( (bool)1 )\\n\"\n               \"  continue;\",\n               Spaces);\n  verifyFormat(\"for ( ;; )\\n\"\n               \"  continue;\",\n               Spaces);\n  verifyFormat(\"if ( true )\\n\"\n               \"  f();\\n\"\n               \"else if ( true )\\n\"\n               \"  f();\",\n               Spaces);\n  verifyFormat(\"do {\\n\"\n               \"  do_something( (int)i );\\n\"\n               \"} while ( something() );\",\n               Spaces);\n  verifyFormat(\"switch ( x ) {\\n\"\n               \"default:\\n\"\n               \"  break;\\n\"\n               \"}\",\n               Spaces);\n\n  Spaces.SpacesInParentheses = false;\n  Spaces.SpacesInCStyleCastParentheses = true;\n  verifyFormat(\"Type *A = ( Type * )P;\", Spaces);\n  verifyFormat(\"Type *A = ( vector<Type *, int *> )P;\", Spaces);\n  verifyFormat(\"x = ( int32 )y;\", Spaces);\n  verifyFormat(\"int a = ( int )(2.0f);\", Spaces);\n  verifyFormat(\"#define AA(X) sizeof((( X * )NULL)->a)\", Spaces);\n  verifyFormat(\"my_int a = ( my_int )sizeof(int);\", Spaces);\n  verifyFormat(\"#define x (( int )-1)\", Spaces);\n\n  // Run the first set of tests again with:\n  Spaces.SpacesInParentheses = false;\n  Spaces.SpaceInEmptyParentheses = true;\n  Spaces.SpacesInCStyleCastParentheses = true;\n  verifyFormat(\"call(x, y, z);\", Spaces);\n  verifyFormat(\"call( );\", Spaces);\n  verifyFormat(\"std::function<void(int, int)> callback;\", Spaces);\n  verifyFormat(\"while (( bool )1)\\n\"\n               \"  continue;\",\n               Spaces);\n  verifyFormat(\"for (;;)\\n\"\n               \"  continue;\",\n               Spaces);\n  verifyFormat(\"if (true)\\n\"\n               \"  f( );\\n\"\n               \"else if (true)\\n\"\n               \"  f( );\",\n               Spaces);\n  verifyFormat(\"do {\\n\"\n               \"  do_something(( int )i);\\n\"\n               \"} while (something( ));\",\n               Spaces);\n  verifyFormat(\"switch (x) {\\n\"\n               \"default:\\n\"\n               \"  break;\\n\"\n               \"}\",\n               Spaces);\n\n  // Run the first set of tests again with:\n  Spaces.SpaceAfterCStyleCast = true;\n  verifyFormat(\"call(x, y, z);\", Spaces);\n  verifyFormat(\"call( );\", Spaces);\n  verifyFormat(\"std::function<void(int, int)> callback;\", Spaces);\n  verifyFormat(\"while (( bool ) 1)\\n\"\n               \"  continue;\",\n               Spaces);\n  verifyFormat(\"for (;;)\\n\"\n               \"  continue;\",\n               Spaces);\n  verifyFormat(\"if (true)\\n\"\n               \"  f( );\\n\"\n               \"else if (true)\\n\"\n               \"  f( );\",\n               Spaces);\n  verifyFormat(\"do {\\n\"\n               \"  do_something(( int ) i);\\n\"\n               \"} while (something( ));\",\n               Spaces);\n  verifyFormat(\"switch (x) {\\n\"\n               \"default:\\n\"\n               \"  break;\\n\"\n               \"}\",\n               Spaces);\n\n  // Run subset of tests again with:\n  Spaces.SpacesInCStyleCastParentheses = false;\n  Spaces.SpaceAfterCStyleCast = true;\n  verifyFormat(\"while ((bool) 1)\\n\"\n               \"  continue;\",\n               Spaces);\n  verifyFormat(\"do {\\n\"\n               \"  do_something((int) i);\\n\"\n               \"} while (something( ));\",\n               Spaces);\n\n  verifyFormat(\"size_t idx = (size_t) (ptr - ((char *) file));\", Spaces);\n  verifyFormat(\"size_t idx = (size_t) a;\", Spaces);\n  verifyFormat(\"size_t idx = (size_t) (a - 1);\", Spaces);\n  verifyFormat(\"size_t idx = (a->*foo)(a - 1);\", Spaces);\n  verifyFormat(\"size_t idx = (a->foo)(a - 1);\", Spaces);\n  verifyFormat(\"size_t idx = (*foo)(a - 1);\", Spaces);\n  Spaces.SpaceAfterCStyleCast = false;\n  verifyFormat(\"size_t idx = (size_t)(ptr - ((char *)file));\", Spaces);\n  verifyFormat(\"size_t idx = (size_t)a;\", Spaces);\n  verifyFormat(\"size_t idx = (size_t)(a - 1);\", Spaces);\n  verifyFormat(\"size_t idx = (a->*foo)(a - 1);\", Spaces);\n  verifyFormat(\"size_t idx = (a->foo)(a - 1);\", Spaces);\n  verifyFormat(\"size_t idx = (*foo)(a - 1);\", Spaces);\n}\n\nTEST_F(FormatTest, ConfigurableSpacesInSquareBrackets) {\n  verifyFormat(\"int a[5];\");\n  verifyFormat(\"a[3] += 42;\");\n\n  FormatStyle Spaces = getLLVMStyle();\n  Spaces.SpacesInSquareBrackets = true;\n  // Not lambdas.\n  verifyFormat(\"int a[ 5 ];\", Spaces);\n  verifyFormat(\"a[ 3 ] += 42;\", Spaces);\n  verifyFormat(\"constexpr char hello[]{\\\"hello\\\"};\", Spaces);\n  verifyFormat(\"double &operator[](int i) { return 0; }\\n\"\n               \"int i;\",\n               Spaces);\n  verifyFormat(\"std::unique_ptr<int[]> foo() {}\", Spaces);\n  verifyFormat(\"int i = a[ a ][ a ]->f();\", Spaces);\n  verifyFormat(\"int i = (*b)[ a ]->f();\", Spaces);\n  // Lambdas.\n  verifyFormat(\"int c = []() -> int { return 2; }();\\n\", Spaces);\n  verifyFormat(\"return [ i, args... ] {};\", Spaces);\n  verifyFormat(\"int foo = [ &bar ]() {};\", Spaces);\n  verifyFormat(\"int foo = [ = ]() {};\", Spaces);\n  verifyFormat(\"int foo = [ & ]() {};\", Spaces);\n  verifyFormat(\"int foo = [ =, &bar ]() {};\", Spaces);\n  verifyFormat(\"int foo = [ &bar, = ]() {};\", Spaces);\n}\n\nTEST_F(FormatTest, ConfigurableSpaceBeforeBrackets) {\n  FormatStyle NoSpaceStyle = getLLVMStyle();\n  verifyFormat(\"int a[5];\", NoSpaceStyle);\n  verifyFormat(\"a[3] += 42;\", NoSpaceStyle);\n\n  verifyFormat(\"int a[1];\", NoSpaceStyle);\n  verifyFormat(\"int 1 [a];\", NoSpaceStyle);\n  verifyFormat(\"int a[1][2];\", NoSpaceStyle);\n  verifyFormat(\"a[7] = 5;\", NoSpaceStyle);\n  verifyFormat(\"int a = (f())[23];\", NoSpaceStyle);\n  verifyFormat(\"f([] {})\", NoSpaceStyle);\n\n  FormatStyle Space = getLLVMStyle();\n  Space.SpaceBeforeSquareBrackets = true;\n  verifyFormat(\"int c = []() -> int { return 2; }();\\n\", Space);\n  verifyFormat(\"return [i, args...] {};\", Space);\n\n  verifyFormat(\"int a [5];\", Space);\n  verifyFormat(\"a [3] += 42;\", Space);\n  verifyFormat(\"constexpr char hello []{\\\"hello\\\"};\", Space);\n  verifyFormat(\"double &operator[](int i) { return 0; }\\n\"\n               \"int i;\",\n               Space);\n  verifyFormat(\"std::unique_ptr<int []> foo() {}\", Space);\n  verifyFormat(\"int i = a [a][a]->f();\", Space);\n  verifyFormat(\"int i = (*b) [a]->f();\", Space);\n\n  verifyFormat(\"int a [1];\", Space);\n  verifyFormat(\"int 1 [a];\", Space);\n  verifyFormat(\"int a [1][2];\", Space);\n  verifyFormat(\"a [7] = 5;\", Space);\n  verifyFormat(\"int a = (f()) [23];\", Space);\n  verifyFormat(\"f([] {})\", Space);\n}\n\nTEST_F(FormatTest, ConfigurableSpaceBeforeAssignmentOperators) {\n  verifyFormat(\"int a = 5;\");\n  verifyFormat(\"a += 42;\");\n  verifyFormat(\"a or_eq 8;\");\n\n  FormatStyle Spaces = getLLVMStyle();\n  Spaces.SpaceBeforeAssignmentOperators = false;\n  verifyFormat(\"int a= 5;\", Spaces);\n  verifyFormat(\"a+= 42;\", Spaces);\n  verifyFormat(\"a or_eq 8;\", Spaces);\n}\n\nTEST_F(FormatTest, ConfigurableSpaceBeforeColon) {\n  verifyFormat(\"class Foo : public Bar {};\");\n  verifyFormat(\"Foo::Foo() : foo(1) {}\");\n  verifyFormat(\"for (auto a : b) {\\n}\");\n  verifyFormat(\"int x = a ? b : c;\");\n  verifyFormat(\"{\\n\"\n               \"label0:\\n\"\n               \"  int x = 0;\\n\"\n               \"}\");\n  verifyFormat(\"switch (x) {\\n\"\n               \"case 1:\\n\"\n               \"default:\\n\"\n               \"}\");\n  verifyFormat(\"switch (allBraces) {\\n\"\n               \"case 1: {\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"case 2: {\\n\"\n               \"  [[fallthrough]];\\n\"\n               \"}\\n\"\n               \"default: {\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"}\");\n\n  FormatStyle CtorInitializerStyle = getLLVMStyleWithColumns(30);\n  CtorInitializerStyle.SpaceBeforeCtorInitializerColon = false;\n  verifyFormat(\"class Foo : public Bar {};\", CtorInitializerStyle);\n  verifyFormat(\"Foo::Foo(): foo(1) {}\", CtorInitializerStyle);\n  verifyFormat(\"for (auto a : b) {\\n}\", CtorInitializerStyle);\n  verifyFormat(\"int x = a ? b : c;\", CtorInitializerStyle);\n  verifyFormat(\"{\\n\"\n               \"label1:\\n\"\n               \"  int x = 0;\\n\"\n               \"}\",\n               CtorInitializerStyle);\n  verifyFormat(\"switch (x) {\\n\"\n               \"case 1:\\n\"\n               \"default:\\n\"\n               \"}\",\n               CtorInitializerStyle);\n  verifyFormat(\"switch (allBraces) {\\n\"\n               \"case 1: {\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"case 2: {\\n\"\n               \"  [[fallthrough]];\\n\"\n               \"}\\n\"\n               \"default: {\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"}\",\n               CtorInitializerStyle);\n  CtorInitializerStyle.BreakConstructorInitializers =\n      FormatStyle::BCIS_AfterColon;\n  verifyFormat(\"Fooooooooooo::Fooooooooooo():\\n\"\n               \"    aaaaaaaaaaaaaaaa(1),\\n\"\n               \"    bbbbbbbbbbbbbbbb(2) {}\",\n               CtorInitializerStyle);\n  CtorInitializerStyle.BreakConstructorInitializers =\n      FormatStyle::BCIS_BeforeComma;\n  verifyFormat(\"Fooooooooooo::Fooooooooooo()\\n\"\n               \"    : aaaaaaaaaaaaaaaa(1)\\n\"\n               \"    , bbbbbbbbbbbbbbbb(2) {}\",\n               CtorInitializerStyle);\n  CtorInitializerStyle.BreakConstructorInitializers =\n      FormatStyle::BCIS_BeforeColon;\n  verifyFormat(\"Fooooooooooo::Fooooooooooo()\\n\"\n               \"    : aaaaaaaaaaaaaaaa(1),\\n\"\n               \"      bbbbbbbbbbbbbbbb(2) {}\",\n               CtorInitializerStyle);\n  CtorInitializerStyle.ConstructorInitializerIndentWidth = 0;\n  verifyFormat(\"Fooooooooooo::Fooooooooooo()\\n\"\n               \": aaaaaaaaaaaaaaaa(1),\\n\"\n               \"  bbbbbbbbbbbbbbbb(2) {}\",\n               CtorInitializerStyle);\n\n  FormatStyle InheritanceStyle = getLLVMStyleWithColumns(30);\n  InheritanceStyle.SpaceBeforeInheritanceColon = false;\n  verifyFormat(\"class Foo: public Bar {};\", InheritanceStyle);\n  verifyFormat(\"Foo::Foo() : foo(1) {}\", InheritanceStyle);\n  verifyFormat(\"for (auto a : b) {\\n}\", InheritanceStyle);\n  verifyFormat(\"int x = a ? b : c;\", InheritanceStyle);\n  verifyFormat(\"{\\n\"\n               \"label2:\\n\"\n               \"  int x = 0;\\n\"\n               \"}\",\n               InheritanceStyle);\n  verifyFormat(\"switch (x) {\\n\"\n               \"case 1:\\n\"\n               \"default:\\n\"\n               \"}\",\n               InheritanceStyle);\n  verifyFormat(\"switch (allBraces) {\\n\"\n               \"case 1: {\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"case 2: {\\n\"\n               \"  [[fallthrough]];\\n\"\n               \"}\\n\"\n               \"default: {\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"}\",\n               InheritanceStyle);\n  InheritanceStyle.BreakInheritanceList = FormatStyle::BILS_AfterColon;\n  verifyFormat(\"class Foooooooooooooooooooooo:\\n\"\n               \"    public aaaaaaaaaaaaaaaaaa,\\n\"\n               \"    public bbbbbbbbbbbbbbbbbb {\\n\"\n               \"}\",\n               InheritanceStyle);\n  InheritanceStyle.BreakInheritanceList = FormatStyle::BILS_BeforeComma;\n  verifyFormat(\"class Foooooooooooooooooooooo\\n\"\n               \"    : public aaaaaaaaaaaaaaaaaa\\n\"\n               \"    , public bbbbbbbbbbbbbbbbbb {\\n\"\n               \"}\",\n               InheritanceStyle);\n  InheritanceStyle.BreakInheritanceList = FormatStyle::BILS_BeforeColon;\n  verifyFormat(\"class Foooooooooooooooooooooo\\n\"\n               \"    : public aaaaaaaaaaaaaaaaaa,\\n\"\n               \"      public bbbbbbbbbbbbbbbbbb {\\n\"\n               \"}\",\n               InheritanceStyle);\n  InheritanceStyle.ConstructorInitializerIndentWidth = 0;\n  verifyFormat(\"class Foooooooooooooooooooooo\\n\"\n               \": public aaaaaaaaaaaaaaaaaa,\\n\"\n               \"  public bbbbbbbbbbbbbbbbbb {}\",\n               InheritanceStyle);\n\n  FormatStyle ForLoopStyle = getLLVMStyle();\n  ForLoopStyle.SpaceBeforeRangeBasedForLoopColon = false;\n  verifyFormat(\"class Foo : public Bar {};\", ForLoopStyle);\n  verifyFormat(\"Foo::Foo() : foo(1) {}\", ForLoopStyle);\n  verifyFormat(\"for (auto a: b) {\\n}\", ForLoopStyle);\n  verifyFormat(\"int x = a ? b : c;\", ForLoopStyle);\n  verifyFormat(\"{\\n\"\n               \"label2:\\n\"\n               \"  int x = 0;\\n\"\n               \"}\",\n               ForLoopStyle);\n  verifyFormat(\"switch (x) {\\n\"\n               \"case 1:\\n\"\n               \"default:\\n\"\n               \"}\",\n               ForLoopStyle);\n  verifyFormat(\"switch (allBraces) {\\n\"\n               \"case 1: {\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"case 2: {\\n\"\n               \"  [[fallthrough]];\\n\"\n               \"}\\n\"\n               \"default: {\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"}\",\n               ForLoopStyle);\n\n  FormatStyle CaseStyle = getLLVMStyle();\n  CaseStyle.SpaceBeforeCaseColon = true;\n  verifyFormat(\"class Foo : public Bar {};\", CaseStyle);\n  verifyFormat(\"Foo::Foo() : foo(1) {}\", CaseStyle);\n  verifyFormat(\"for (auto a : b) {\\n}\", CaseStyle);\n  verifyFormat(\"int x = a ? b : c;\", CaseStyle);\n  verifyFormat(\"switch (x) {\\n\"\n               \"case 1 :\\n\"\n               \"default :\\n\"\n               \"}\",\n               CaseStyle);\n  verifyFormat(\"switch (allBraces) {\\n\"\n               \"case 1 : {\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"case 2 : {\\n\"\n               \"  [[fallthrough]];\\n\"\n               \"}\\n\"\n               \"default : {\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"}\",\n               CaseStyle);\n\n  FormatStyle NoSpaceStyle = getLLVMStyle();\n  EXPECT_EQ(NoSpaceStyle.SpaceBeforeCaseColon, false);\n  NoSpaceStyle.SpaceBeforeCtorInitializerColon = false;\n  NoSpaceStyle.SpaceBeforeInheritanceColon = false;\n  NoSpaceStyle.SpaceBeforeRangeBasedForLoopColon = false;\n  verifyFormat(\"class Foo: public Bar {};\", NoSpaceStyle);\n  verifyFormat(\"Foo::Foo(): foo(1) {}\", NoSpaceStyle);\n  verifyFormat(\"for (auto a: b) {\\n}\", NoSpaceStyle);\n  verifyFormat(\"int x = a ? b : c;\", NoSpaceStyle);\n  verifyFormat(\"{\\n\"\n               \"label3:\\n\"\n               \"  int x = 0;\\n\"\n               \"}\",\n               NoSpaceStyle);\n  verifyFormat(\"switch (x) {\\n\"\n               \"case 1:\\n\"\n               \"default:\\n\"\n               \"}\",\n               NoSpaceStyle);\n  verifyFormat(\"switch (allBraces) {\\n\"\n               \"case 1: {\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"case 2: {\\n\"\n               \"  [[fallthrough]];\\n\"\n               \"}\\n\"\n               \"default: {\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"}\",\n               NoSpaceStyle);\n\n  FormatStyle InvertedSpaceStyle = getLLVMStyle();\n  InvertedSpaceStyle.SpaceBeforeCaseColon = true;\n  InvertedSpaceStyle.SpaceBeforeCtorInitializerColon = false;\n  InvertedSpaceStyle.SpaceBeforeInheritanceColon = false;\n  InvertedSpaceStyle.SpaceBeforeRangeBasedForLoopColon = false;\n  verifyFormat(\"class Foo: public Bar {};\", InvertedSpaceStyle);\n  verifyFormat(\"Foo::Foo(): foo(1) {}\", InvertedSpaceStyle);\n  verifyFormat(\"for (auto a: b) {\\n}\", InvertedSpaceStyle);\n  verifyFormat(\"int x = a ? b : c;\", InvertedSpaceStyle);\n  verifyFormat(\"{\\n\"\n               \"label3:\\n\"\n               \"  int x = 0;\\n\"\n               \"}\",\n               InvertedSpaceStyle);\n  verifyFormat(\"switch (x) {\\n\"\n               \"case 1 :\\n\"\n               \"case 2 : {\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"default :\\n\"\n               \"  break;\\n\"\n               \"}\",\n               InvertedSpaceStyle);\n  verifyFormat(\"switch (allBraces) {\\n\"\n               \"case 1 : {\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"case 2 : {\\n\"\n               \"  [[fallthrough]];\\n\"\n               \"}\\n\"\n               \"default : {\\n\"\n               \"  break;\\n\"\n               \"}\\n\"\n               \"}\",\n               InvertedSpaceStyle);\n}\n\nTEST_F(FormatTest, ConfigurableSpaceAroundPointerQualifiers) {\n  FormatStyle Style = getLLVMStyle();\n\n  Style.PointerAlignment = FormatStyle::PAS_Left;\n  Style.SpaceAroundPointerQualifiers = FormatStyle::SAPQ_Default;\n  verifyFormat(\"void* const* x = NULL;\", Style);\n\n#define verifyQualifierSpaces(Code, Pointers, Qualifiers)                      \\\n  do {                                                                         \\\n    Style.PointerAlignment = FormatStyle::Pointers;                            \\\n    Style.SpaceAroundPointerQualifiers = FormatStyle::Qualifiers;              \\\n    verifyFormat(Code, Style);                                                 \\\n  } while (false)\n\n  verifyQualifierSpaces(\"void* const* x = NULL;\", PAS_Left, SAPQ_Default);\n  verifyQualifierSpaces(\"void *const *x = NULL;\", PAS_Right, SAPQ_Default);\n  verifyQualifierSpaces(\"void * const * x = NULL;\", PAS_Middle, SAPQ_Default);\n\n  verifyQualifierSpaces(\"void* const* x = NULL;\", PAS_Left, SAPQ_Before);\n  verifyQualifierSpaces(\"void * const *x = NULL;\", PAS_Right, SAPQ_Before);\n  verifyQualifierSpaces(\"void * const * x = NULL;\", PAS_Middle, SAPQ_Before);\n\n  verifyQualifierSpaces(\"void* const * x = NULL;\", PAS_Left, SAPQ_After);\n  verifyQualifierSpaces(\"void *const *x = NULL;\", PAS_Right, SAPQ_After);\n  verifyQualifierSpaces(\"void * const * x = NULL;\", PAS_Middle, SAPQ_After);\n\n  verifyQualifierSpaces(\"void* const * x = NULL;\", PAS_Left, SAPQ_Both);\n  verifyQualifierSpaces(\"void * const *x = NULL;\", PAS_Right, SAPQ_Both);\n  verifyQualifierSpaces(\"void * const * x = NULL;\", PAS_Middle, SAPQ_Both);\n\n#undef verifyQualifierSpaces\n\n  FormatStyle Spaces = getLLVMStyle();\n  Spaces.AttributeMacros.push_back(\"qualified\");\n  Spaces.PointerAlignment = FormatStyle::PAS_Right;\n  Spaces.SpaceAroundPointerQualifiers = FormatStyle::SAPQ_Default;\n  verifyFormat(\"SomeType *volatile *a = NULL;\", Spaces);\n  verifyFormat(\"SomeType *__attribute__((attr)) *a = NULL;\", Spaces);\n  verifyFormat(\"std::vector<SomeType *const *> x;\", Spaces);\n  verifyFormat(\"std::vector<SomeType *qualified *> x;\", Spaces);\n  verifyFormat(\"std::vector<SomeVar * NotAQualifier> x;\", Spaces);\n  Spaces.SpaceAroundPointerQualifiers = FormatStyle::SAPQ_Before;\n  verifyFormat(\"SomeType * volatile *a = NULL;\", Spaces);\n  verifyFormat(\"SomeType * __attribute__((attr)) *a = NULL;\", Spaces);\n  verifyFormat(\"std::vector<SomeType * const *> x;\", Spaces);\n  verifyFormat(\"std::vector<SomeType * qualified *> x;\", Spaces);\n  verifyFormat(\"std::vector<SomeVar * NotAQualifier> x;\", Spaces);\n\n  // Check that SAPQ_Before doesn't result in extra spaces for PAS_Left.\n  Spaces.PointerAlignment = FormatStyle::PAS_Left;\n  Spaces.SpaceAroundPointerQualifiers = FormatStyle::SAPQ_Before;\n  verifyFormat(\"SomeType* volatile* a = NULL;\", Spaces);\n  verifyFormat(\"SomeType* __attribute__((attr))* a = NULL;\", Spaces);\n  verifyFormat(\"std::vector<SomeType* const*> x;\", Spaces);\n  verifyFormat(\"std::vector<SomeType* qualified*> x;\", Spaces);\n  verifyFormat(\"std::vector<SomeVar * NotAQualifier> x;\", Spaces);\n  // However, setting it to SAPQ_After should add spaces after __attribute, etc.\n  Spaces.SpaceAroundPointerQualifiers = FormatStyle::SAPQ_After;\n  verifyFormat(\"SomeType* volatile * a = NULL;\", Spaces);\n  verifyFormat(\"SomeType* __attribute__((attr)) * a = NULL;\", Spaces);\n  verifyFormat(\"std::vector<SomeType* const *> x;\", Spaces);\n  verifyFormat(\"std::vector<SomeType* qualified *> x;\", Spaces);\n  verifyFormat(\"std::vector<SomeVar * NotAQualifier> x;\", Spaces);\n\n  // PAS_Middle should not have any noticeable changes even for SAPQ_Both\n  Spaces.PointerAlignment = FormatStyle::PAS_Middle;\n  Spaces.SpaceAroundPointerQualifiers = FormatStyle::SAPQ_After;\n  verifyFormat(\"SomeType * volatile * a = NULL;\", Spaces);\n  verifyFormat(\"SomeType * __attribute__((attr)) * a = NULL;\", Spaces);\n  verifyFormat(\"std::vector<SomeType * const *> x;\", Spaces);\n  verifyFormat(\"std::vector<SomeType * qualified *> x;\", Spaces);\n  verifyFormat(\"std::vector<SomeVar * NotAQualifier> x;\", Spaces);\n}\n\nTEST_F(FormatTest, AlignConsecutiveMacros) {\n  FormatStyle Style = getLLVMStyle();\n  Style.AlignConsecutiveAssignments = FormatStyle::ACS_Consecutive;\n  Style.AlignConsecutiveDeclarations = FormatStyle::ACS_Consecutive;\n  Style.AlignConsecutiveMacros = FormatStyle::ACS_None;\n\n  verifyFormat(\"#define a 3\\n\"\n               \"#define bbbb 4\\n\"\n               \"#define ccc (5)\",\n               Style);\n\n  verifyFormat(\"#define f(x) (x * x)\\n\"\n               \"#define fff(x, y, z) (x * y + z)\\n\"\n               \"#define ffff(x, y) (x - y)\",\n               Style);\n\n  verifyFormat(\"#define foo(x, y) (x + y)\\n\"\n               \"#define bar (5, 6)(2 + 2)\",\n               Style);\n\n  verifyFormat(\"#define a 3\\n\"\n               \"#define bbbb 4\\n\"\n               \"#define ccc (5)\\n\"\n               \"#define f(x) (x * x)\\n\"\n               \"#define fff(x, y, z) (x * y + z)\\n\"\n               \"#define ffff(x, y) (x - y)\",\n               Style);\n\n  Style.AlignConsecutiveMacros = FormatStyle::ACS_Consecutive;\n  verifyFormat(\"#define a    3\\n\"\n               \"#define bbbb 4\\n\"\n               \"#define ccc  (5)\",\n               Style);\n\n  verifyFormat(\"#define f(x)         (x * x)\\n\"\n               \"#define fff(x, y, z) (x * y + z)\\n\"\n               \"#define ffff(x, y)   (x - y)\",\n               Style);\n\n  verifyFormat(\"#define foo(x, y) (x + y)\\n\"\n               \"#define bar       (5, 6)(2 + 2)\",\n               Style);\n\n  verifyFormat(\"#define a            3\\n\"\n               \"#define bbbb         4\\n\"\n               \"#define ccc          (5)\\n\"\n               \"#define f(x)         (x * x)\\n\"\n               \"#define fff(x, y, z) (x * y + z)\\n\"\n               \"#define ffff(x, y)   (x - y)\",\n               Style);\n\n  verifyFormat(\"#define a         5\\n\"\n               \"#define foo(x, y) (x + y)\\n\"\n               \"#define CCC       (6)\\n\"\n               \"auto lambda = []() {\\n\"\n               \"  auto  ii = 0;\\n\"\n               \"  float j  = 0;\\n\"\n               \"  return 0;\\n\"\n               \"};\\n\"\n               \"int   i  = 0;\\n\"\n               \"float i2 = 0;\\n\"\n               \"auto  v  = type{\\n\"\n               \"    i = 1,   //\\n\"\n               \"    (i = 2), //\\n\"\n               \"    i = 3    //\\n\"\n               \"};\",\n               Style);\n\n  Style.AlignConsecutiveMacros = FormatStyle::ACS_None;\n  Style.ColumnLimit = 20;\n\n  verifyFormat(\"#define a          \\\\\\n\"\n               \"  \\\"aabbbbbbbbbbbb\\\"\\n\"\n               \"#define D          \\\\\\n\"\n               \"  \\\"aabbbbbbbbbbbb\\\" \\\\\\n\"\n               \"  \\\"ccddeeeeeeeee\\\"\\n\"\n               \"#define B          \\\\\\n\"\n               \"  \\\"QQQQQQQQQQQQQ\\\"  \\\\\\n\"\n               \"  \\\"FFFFFFFFFFFFF\\\"  \\\\\\n\"\n               \"  \\\"LLLLLLLL\\\"\\n\",\n               Style);\n\n  Style.AlignConsecutiveMacros = FormatStyle::ACS_Consecutive;\n  verifyFormat(\"#define a          \\\\\\n\"\n               \"  \\\"aabbbbbbbbbbbb\\\"\\n\"\n               \"#define D          \\\\\\n\"\n               \"  \\\"aabbbbbbbbbbbb\\\" \\\\\\n\"\n               \"  \\\"ccddeeeeeeeee\\\"\\n\"\n               \"#define B          \\\\\\n\"\n               \"  \\\"QQQQQQQQQQQQQ\\\"  \\\\\\n\"\n               \"  \\\"FFFFFFFFFFFFF\\\"  \\\\\\n\"\n               \"  \\\"LLLLLLLL\\\"\\n\",\n               Style);\n\n  // Test across comments\n  Style.MaxEmptyLinesToKeep = 10;\n  Style.ReflowComments = false;\n  Style.AlignConsecutiveMacros = FormatStyle::ACS_AcrossComments;\n  EXPECT_EQ(\"#define a    3\\n\"\n            \"// line comment\\n\"\n            \"#define bbbb 4\\n\"\n            \"#define ccc  (5)\",\n            format(\"#define a 3\\n\"\n                   \"// line comment\\n\"\n                   \"#define bbbb 4\\n\"\n                   \"#define ccc (5)\",\n                   Style));\n\n  EXPECT_EQ(\"#define a    3\\n\"\n            \"/* block comment */\\n\"\n            \"#define bbbb 4\\n\"\n            \"#define ccc  (5)\",\n            format(\"#define a  3\\n\"\n                   \"/* block comment */\\n\"\n                   \"#define bbbb 4\\n\"\n                   \"#define ccc (5)\",\n                   Style));\n\n  EXPECT_EQ(\"#define a    3\\n\"\n            \"/* multi-line *\\n\"\n            \" * block comment */\\n\"\n            \"#define bbbb 4\\n\"\n            \"#define ccc  (5)\",\n            format(\"#define a 3\\n\"\n                   \"/* multi-line *\\n\"\n                   \" * block comment */\\n\"\n                   \"#define bbbb 4\\n\"\n                   \"#define ccc (5)\",\n                   Style));\n\n  EXPECT_EQ(\"#define a    3\\n\"\n            \"// multi-line line comment\\n\"\n            \"//\\n\"\n            \"#define bbbb 4\\n\"\n            \"#define ccc  (5)\",\n            format(\"#define a  3\\n\"\n                   \"// multi-line line comment\\n\"\n                   \"//\\n\"\n                   \"#define bbbb 4\\n\"\n                   \"#define ccc (5)\",\n                   Style));\n\n  EXPECT_EQ(\"#define a 3\\n\"\n            \"// empty lines still break.\\n\"\n            \"\\n\"\n            \"#define bbbb 4\\n\"\n            \"#define ccc  (5)\",\n            format(\"#define a     3\\n\"\n                   \"// empty lines still break.\\n\"\n                   \"\\n\"\n                   \"#define bbbb     4\\n\"\n                   \"#define ccc  (5)\",\n                   Style));\n\n  // Test across empty lines\n  Style.AlignConsecutiveMacros = FormatStyle::ACS_AcrossEmptyLines;\n  EXPECT_EQ(\"#define a    3\\n\"\n            \"\\n\"\n            \"#define bbbb 4\\n\"\n            \"#define ccc  (5)\",\n            format(\"#define a 3\\n\"\n                   \"\\n\"\n                   \"#define bbbb 4\\n\"\n                   \"#define ccc (5)\",\n                   Style));\n\n  EXPECT_EQ(\"#define a    3\\n\"\n            \"\\n\"\n            \"\\n\"\n            \"\\n\"\n            \"#define bbbb 4\\n\"\n            \"#define ccc  (5)\",\n            format(\"#define a        3\\n\"\n                   \"\\n\"\n                   \"\\n\"\n                   \"\\n\"\n                   \"#define bbbb 4\\n\"\n                   \"#define ccc (5)\",\n                   Style));\n\n  EXPECT_EQ(\"#define a 3\\n\"\n            \"// comments should break alignment\\n\"\n            \"//\\n\"\n            \"#define bbbb 4\\n\"\n            \"#define ccc  (5)\",\n            format(\"#define a        3\\n\"\n                   \"// comments should break alignment\\n\"\n                   \"//\\n\"\n                   \"#define bbbb 4\\n\"\n                   \"#define ccc (5)\",\n                   Style));\n\n  // Test across empty lines and comments\n  Style.AlignConsecutiveMacros = FormatStyle::ACS_AcrossEmptyLinesAndComments;\n  verifyFormat(\"#define a    3\\n\"\n               \"\\n\"\n               \"// line comment\\n\"\n               \"#define bbbb 4\\n\"\n               \"#define ccc  (5)\",\n               Style);\n\n  EXPECT_EQ(\"#define a    3\\n\"\n            \"\\n\"\n            \"\\n\"\n            \"/* multi-line *\\n\"\n            \" * block comment */\\n\"\n            \"\\n\"\n            \"\\n\"\n            \"#define bbbb 4\\n\"\n            \"#define ccc  (5)\",\n            format(\"#define a 3\\n\"\n                   \"\\n\"\n                   \"\\n\"\n                   \"/* multi-line *\\n\"\n                   \" * block comment */\\n\"\n                   \"\\n\"\n                   \"\\n\"\n                   \"#define bbbb 4\\n\"\n                   \"#define ccc (5)\",\n                   Style));\n\n  EXPECT_EQ(\"#define a    3\\n\"\n            \"\\n\"\n            \"\\n\"\n            \"/* multi-line *\\n\"\n            \" * block comment */\\n\"\n            \"\\n\"\n            \"\\n\"\n            \"#define bbbb 4\\n\"\n            \"#define ccc  (5)\",\n            format(\"#define a 3\\n\"\n                   \"\\n\"\n                   \"\\n\"\n                   \"/* multi-line *\\n\"\n                   \" * block comment */\\n\"\n                   \"\\n\"\n                   \"\\n\"\n                   \"#define bbbb 4\\n\"\n                   \"#define ccc       (5)\",\n                   Style));\n}\n\nTEST_F(FormatTest, AlignConsecutiveAssignmentsAcrossEmptyLines) {\n  FormatStyle Alignment = getLLVMStyle();\n  Alignment.AlignConsecutiveMacros = FormatStyle::ACS_Consecutive;\n  Alignment.AlignConsecutiveAssignments = FormatStyle::ACS_AcrossEmptyLines;\n\n  Alignment.MaxEmptyLinesToKeep = 10;\n  /* Test alignment across empty lines */\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a       = 5;\\n\"\n                   \"\\n\"\n                   \"int oneTwoThree= 123;\",\n                   Alignment));\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"int one         = 1;\\n\"\n            \"\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"int one = 1;\\n\"\n                   \"\\n\"\n                   \"int oneTwoThree = 123;\",\n                   Alignment));\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"int one         = 1;\\n\"\n            \"\\n\"\n            \"int oneTwoThree = 123;\\n\"\n            \"int oneTwo      = 12;\",\n            format(\"int a = 5;\\n\"\n                   \"int one = 1;\\n\"\n                   \"\\n\"\n                   \"int oneTwoThree = 123;\\n\"\n                   \"int oneTwo = 12;\",\n                   Alignment));\n\n  /* Test across comments */\n  EXPECT_EQ(\"int a = 5;\\n\"\n            \"/* block comment */\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"/* block comment */\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  EXPECT_EQ(\"int a = 5;\\n\"\n            \"// line comment\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"// line comment\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  /* Test across comments and newlines */\n  EXPECT_EQ(\"int a = 5;\\n\"\n            \"\\n\"\n            \"/* block comment */\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"\\n\"\n                   \"/* block comment */\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  EXPECT_EQ(\"int a = 5;\\n\"\n            \"\\n\"\n            \"// line comment\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"\\n\"\n                   \"// line comment\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n}\n\nTEST_F(FormatTest, AlignConsecutiveDeclarationsAcrossEmptyLinesAndComments) {\n  FormatStyle Alignment = getLLVMStyle();\n  Alignment.AlignConsecutiveDeclarations =\n      FormatStyle::ACS_AcrossEmptyLinesAndComments;\n  Alignment.AlignConsecutiveAssignments = FormatStyle::ACS_None;\n\n  Alignment.MaxEmptyLinesToKeep = 10;\n  /* Test alignment across empty lines */\n  EXPECT_EQ(\"int         a = 5;\\n\"\n            \"\\n\"\n            \"float const oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"\\n\"\n                   \"float const oneTwoThree = 123;\",\n                   Alignment));\n  EXPECT_EQ(\"int         a = 5;\\n\"\n            \"float const one = 1;\\n\"\n            \"\\n\"\n            \"int         oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"float const one = 1;\\n\"\n                   \"\\n\"\n                   \"int oneTwoThree = 123;\",\n                   Alignment));\n\n  /* Test across comments */\n  EXPECT_EQ(\"float const a = 5;\\n\"\n            \"/* block comment */\\n\"\n            \"int         oneTwoThree = 123;\",\n            format(\"float const a = 5;\\n\"\n                   \"/* block comment */\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  EXPECT_EQ(\"float const a = 5;\\n\"\n            \"// line comment\\n\"\n            \"int         oneTwoThree = 123;\",\n            format(\"float const a = 5;\\n\"\n                   \"// line comment\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  /* Test across comments and newlines */\n  EXPECT_EQ(\"float const a = 5;\\n\"\n            \"\\n\"\n            \"/* block comment */\\n\"\n            \"int         oneTwoThree = 123;\",\n            format(\"float const a = 5;\\n\"\n                   \"\\n\"\n                   \"/* block comment */\\n\"\n                   \"int         oneTwoThree=123;\",\n                   Alignment));\n\n  EXPECT_EQ(\"float const a = 5;\\n\"\n            \"\\n\"\n            \"// line comment\\n\"\n            \"int         oneTwoThree = 123;\",\n            format(\"float const a = 5;\\n\"\n                   \"\\n\"\n                   \"// line comment\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n}\n\nTEST_F(FormatTest, AlignConsecutiveBitFieldsAcrossEmptyLinesAndComments) {\n  FormatStyle Alignment = getLLVMStyle();\n  Alignment.AlignConsecutiveBitFields =\n      FormatStyle::ACS_AcrossEmptyLinesAndComments;\n\n  Alignment.MaxEmptyLinesToKeep = 10;\n  /* Test alignment across empty lines */\n  EXPECT_EQ(\"int a            : 5;\\n\"\n            \"\\n\"\n            \"int longbitfield : 6;\",\n            format(\"int a : 5;\\n\"\n                   \"\\n\"\n                   \"int longbitfield : 6;\",\n                   Alignment));\n  EXPECT_EQ(\"int a            : 5;\\n\"\n            \"int one          : 1;\\n\"\n            \"\\n\"\n            \"int longbitfield : 6;\",\n            format(\"int a : 5;\\n\"\n                   \"int one : 1;\\n\"\n                   \"\\n\"\n                   \"int longbitfield : 6;\",\n                   Alignment));\n\n  /* Test across comments */\n  EXPECT_EQ(\"int a            : 5;\\n\"\n            \"/* block comment */\\n\"\n            \"int longbitfield : 6;\",\n            format(\"int a : 5;\\n\"\n                   \"/* block comment */\\n\"\n                   \"int longbitfield : 6;\",\n                   Alignment));\n  EXPECT_EQ(\"int a            : 5;\\n\"\n            \"int one          : 1;\\n\"\n            \"// line comment\\n\"\n            \"int longbitfield : 6;\",\n            format(\"int a : 5;\\n\"\n                   \"int one : 1;\\n\"\n                   \"// line comment\\n\"\n                   \"int longbitfield : 6;\",\n                   Alignment));\n\n  /* Test across comments and newlines */\n  EXPECT_EQ(\"int a            : 5;\\n\"\n            \"/* block comment */\\n\"\n            \"\\n\"\n            \"int longbitfield : 6;\",\n            format(\"int a : 5;\\n\"\n                   \"/* block comment */\\n\"\n                   \"\\n\"\n                   \"int longbitfield : 6;\",\n                   Alignment));\n  EXPECT_EQ(\"int a            : 5;\\n\"\n            \"int one          : 1;\\n\"\n            \"\\n\"\n            \"// line comment\\n\"\n            \"\\n\"\n            \"int longbitfield : 6;\",\n            format(\"int a : 5;\\n\"\n                   \"int one : 1;\\n\"\n                   \"\\n\"\n                   \"// line comment \\n\"\n                   \"\\n\"\n                   \"int longbitfield : 6;\",\n                   Alignment));\n}\n\nTEST_F(FormatTest, AlignConsecutiveAssignmentsAcrossComments) {\n  FormatStyle Alignment = getLLVMStyle();\n  Alignment.AlignConsecutiveMacros = FormatStyle::ACS_Consecutive;\n  Alignment.AlignConsecutiveAssignments = FormatStyle::ACS_AcrossComments;\n\n  Alignment.MaxEmptyLinesToKeep = 10;\n  /* Test alignment across empty lines */\n  EXPECT_EQ(\"int a = 5;\\n\"\n            \"\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a       = 5;\\n\"\n                   \"\\n\"\n                   \"int oneTwoThree= 123;\",\n                   Alignment));\n  EXPECT_EQ(\"int a   = 5;\\n\"\n            \"int one = 1;\\n\"\n            \"\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"int one = 1;\\n\"\n                   \"\\n\"\n                   \"int oneTwoThree = 123;\",\n                   Alignment));\n\n  /* Test across comments */\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"/* block comment */\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"/* block comment */\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"// line comment\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"// line comment\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"/*\\n\"\n            \" * multi-line block comment\\n\"\n            \" */\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"/*\\n\"\n                   \" * multi-line block comment\\n\"\n                   \" */\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"//\\n\"\n            \"// multi-line line comment\\n\"\n            \"//\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"//\\n\"\n                   \"// multi-line line comment\\n\"\n                   \"//\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  /* Test across comments and newlines */\n  EXPECT_EQ(\"int a = 5;\\n\"\n            \"\\n\"\n            \"/* block comment */\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"\\n\"\n                   \"/* block comment */\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  EXPECT_EQ(\"int a = 5;\\n\"\n            \"\\n\"\n            \"// line comment\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"\\n\"\n                   \"// line comment\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n}\n\nTEST_F(FormatTest, AlignConsecutiveAssignmentsAcrossEmptyLinesAndComments) {\n  FormatStyle Alignment = getLLVMStyle();\n  Alignment.AlignConsecutiveMacros = FormatStyle::ACS_Consecutive;\n  Alignment.AlignConsecutiveAssignments =\n      FormatStyle::ACS_AcrossEmptyLinesAndComments;\n  verifyFormat(\"int a           = 5;\\n\"\n               \"int oneTwoThree = 123;\",\n               Alignment);\n  verifyFormat(\"int a           = method();\\n\"\n               \"int oneTwoThree = 133;\",\n               Alignment);\n  verifyFormat(\"a &= 5;\\n\"\n               \"bcd *= 5;\\n\"\n               \"ghtyf += 5;\\n\"\n               \"dvfvdb -= 5;\\n\"\n               \"a /= 5;\\n\"\n               \"vdsvsv %= 5;\\n\"\n               \"sfdbddfbdfbb ^= 5;\\n\"\n               \"dvsdsv |= 5;\\n\"\n               \"int dsvvdvsdvvv = 123;\",\n               Alignment);\n  verifyFormat(\"int i = 1, j = 10;\\n\"\n               \"something = 2000;\",\n               Alignment);\n  verifyFormat(\"something = 2000;\\n\"\n               \"int i = 1, j = 10;\\n\",\n               Alignment);\n  verifyFormat(\"something = 2000;\\n\"\n               \"another   = 911;\\n\"\n               \"int i = 1, j = 10;\\n\"\n               \"oneMore = 1;\\n\"\n               \"i       = 2;\",\n               Alignment);\n  verifyFormat(\"int a   = 5;\\n\"\n               \"int one = 1;\\n\"\n               \"method();\\n\"\n               \"int oneTwoThree = 123;\\n\"\n               \"int oneTwo      = 12;\",\n               Alignment);\n  verifyFormat(\"int oneTwoThree = 123;\\n\"\n               \"int oneTwo      = 12;\\n\"\n               \"method();\\n\",\n               Alignment);\n  verifyFormat(\"int oneTwoThree = 123; // comment\\n\"\n               \"int oneTwo      = 12;  // comment\",\n               Alignment);\n\n  // Bug 25167\n  /* Uncomment when fixed\n    verifyFormat(\"#if A\\n\"\n                 \"#else\\n\"\n                 \"int aaaaaaaa = 12;\\n\"\n                 \"#endif\\n\"\n                 \"#if B\\n\"\n                 \"#else\\n\"\n                 \"int a = 12;\\n\"\n                 \"#endif\\n\",\n                 Alignment);\n    verifyFormat(\"enum foo {\\n\"\n                 \"#if A\\n\"\n                 \"#else\\n\"\n                 \"  aaaaaaaa = 12;\\n\"\n                 \"#endif\\n\"\n                 \"#if B\\n\"\n                 \"#else\\n\"\n                 \"  a = 12;\\n\"\n                 \"#endif\\n\"\n                 \"};\\n\",\n                 Alignment);\n  */\n\n  Alignment.MaxEmptyLinesToKeep = 10;\n  /* Test alignment across empty lines */\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a       = 5;\\n\"\n                   \"\\n\"\n                   \"int oneTwoThree= 123;\",\n                   Alignment));\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"int one         = 1;\\n\"\n            \"\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"int one = 1;\\n\"\n                   \"\\n\"\n                   \"int oneTwoThree = 123;\",\n                   Alignment));\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"int one         = 1;\\n\"\n            \"\\n\"\n            \"int oneTwoThree = 123;\\n\"\n            \"int oneTwo      = 12;\",\n            format(\"int a = 5;\\n\"\n                   \"int one = 1;\\n\"\n                   \"\\n\"\n                   \"int oneTwoThree = 123;\\n\"\n                   \"int oneTwo = 12;\",\n                   Alignment));\n\n  /* Test across comments */\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"/* block comment */\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"/* block comment */\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"// line comment\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"// line comment\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  /* Test across comments and newlines */\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"\\n\"\n            \"/* block comment */\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"\\n\"\n                   \"/* block comment */\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"\\n\"\n            \"// line comment\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"\\n\"\n                   \"// line comment\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"//\\n\"\n            \"// multi-line line comment\\n\"\n            \"//\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"//\\n\"\n                   \"// multi-line line comment\\n\"\n                   \"//\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"/*\\n\"\n            \" *  multi-line block comment\\n\"\n            \" */\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"/*\\n\"\n                   \" *  multi-line block comment\\n\"\n                   \" */\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"\\n\"\n            \"/* block comment */\\n\"\n            \"\\n\"\n            \"\\n\"\n            \"\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"\\n\"\n                   \"/* block comment */\\n\"\n                   \"\\n\"\n                   \"\\n\"\n                   \"\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  EXPECT_EQ(\"int a           = 5;\\n\"\n            \"\\n\"\n            \"// line comment\\n\"\n            \"\\n\"\n            \"\\n\"\n            \"\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"\\n\"\n                   \"// line comment\\n\"\n                   \"\\n\"\n                   \"\\n\"\n                   \"\\n\"\n                   \"int oneTwoThree=123;\",\n                   Alignment));\n\n  Alignment.AlignEscapedNewlines = FormatStyle::ENAS_DontAlign;\n  verifyFormat(\"#define A \\\\\\n\"\n               \"  int aaaa       = 12; \\\\\\n\"\n               \"  int b          = 23; \\\\\\n\"\n               \"  int ccc        = 234; \\\\\\n\"\n               \"  int dddddddddd = 2345;\",\n               Alignment);\n  Alignment.AlignEscapedNewlines = FormatStyle::ENAS_Left;\n  verifyFormat(\"#define A               \\\\\\n\"\n               \"  int aaaa       = 12;  \\\\\\n\"\n               \"  int b          = 23;  \\\\\\n\"\n               \"  int ccc        = 234; \\\\\\n\"\n               \"  int dddddddddd = 2345;\",\n               Alignment);\n  Alignment.AlignEscapedNewlines = FormatStyle::ENAS_Right;\n  verifyFormat(\"#define A                                                      \"\n               \"                \\\\\\n\"\n               \"  int aaaa       = 12;                                         \"\n               \"                \\\\\\n\"\n               \"  int b          = 23;                                         \"\n               \"                \\\\\\n\"\n               \"  int ccc        = 234;                                        \"\n               \"                \\\\\\n\"\n               \"  int dddddddddd = 2345;\",\n               Alignment);\n  verifyFormat(\"void SomeFunction(int parameter = 1, int i = 2, int j = 3, int \"\n               \"k = 4, int l = 5,\\n\"\n               \"                  int m = 6) {\\n\"\n               \"  int j      = 10;\\n\"\n               \"  otherThing = 1;\\n\"\n               \"}\",\n               Alignment);\n  verifyFormat(\"void SomeFunction(int parameter = 0) {\\n\"\n               \"  int i   = 1;\\n\"\n               \"  int j   = 2;\\n\"\n               \"  int big = 10000;\\n\"\n               \"}\",\n               Alignment);\n  verifyFormat(\"class C {\\n\"\n               \"public:\\n\"\n               \"  int i            = 1;\\n\"\n               \"  virtual void f() = 0;\\n\"\n               \"};\",\n               Alignment);\n  verifyFormat(\"int i = 1;\\n\"\n               \"if (SomeType t = getSomething()) {\\n\"\n               \"}\\n\"\n               \"int j   = 2;\\n\"\n               \"int big = 10000;\",\n               Alignment);\n  verifyFormat(\"int j = 7;\\n\"\n               \"for (int k = 0; k < N; ++k) {\\n\"\n               \"}\\n\"\n               \"int j   = 2;\\n\"\n               \"int big = 10000;\\n\"\n               \"}\",\n               Alignment);\n  Alignment.BreakBeforeBinaryOperators = FormatStyle::BOS_All;\n  verifyFormat(\"int i = 1;\\n\"\n               \"LooooooooooongType loooooooooooooooooooooongVariable\\n\"\n               \"    = someLooooooooooooooooongFunction();\\n\"\n               \"int j = 2;\",\n               Alignment);\n  Alignment.BreakBeforeBinaryOperators = FormatStyle::BOS_None;\n  verifyFormat(\"int i = 1;\\n\"\n               \"LooooooooooongType loooooooooooooooooooooongVariable =\\n\"\n               \"    someLooooooooooooooooongFunction();\\n\"\n               \"int j = 2;\",\n               Alignment);\n\n  verifyFormat(\"auto lambda = []() {\\n\"\n               \"  auto i = 0;\\n\"\n               \"  return 0;\\n\"\n               \"};\\n\"\n               \"int i  = 0;\\n\"\n               \"auto v = type{\\n\"\n               \"    i = 1,   //\\n\"\n               \"    (i = 2), //\\n\"\n               \"    i = 3    //\\n\"\n               \"};\",\n               Alignment);\n\n  verifyFormat(\n      \"int i      = 1;\\n\"\n      \"SomeType a = SomeFunction(looooooooooooooooooooooongParameterA,\\n\"\n      \"                          loooooooooooooooooooooongParameterB);\\n\"\n      \"int j      = 2;\",\n      Alignment);\n\n  verifyFormat(\"template <typename T, typename T_0 = very_long_type_name_0,\\n\"\n               \"          typename B   = very_long_type_name_1,\\n\"\n               \"          typename T_2 = very_long_type_name_2>\\n\"\n               \"auto foo() {}\\n\",\n               Alignment);\n  verifyFormat(\"int a, b = 1;\\n\"\n               \"int c  = 2;\\n\"\n               \"int dd = 3;\\n\",\n               Alignment);\n  verifyFormat(\"int aa       = ((1 > 2) ? 3 : 4);\\n\"\n               \"float b[1][] = {{3.f}};\\n\",\n               Alignment);\n  verifyFormat(\"for (int i = 0; i < 1; i++)\\n\"\n               \"  int x = 1;\\n\",\n               Alignment);\n  verifyFormat(\"for (i = 0; i < 1; i++)\\n\"\n               \"  x = 1;\\n\"\n               \"y = 1;\\n\",\n               Alignment);\n\n  Alignment.ReflowComments = true;\n  Alignment.ColumnLimit = 50;\n  EXPECT_EQ(\"int x   = 0;\\n\"\n            \"int yy  = 1; /// specificlennospace\\n\"\n            \"int zzz = 2;\\n\",\n            format(\"int x   = 0;\\n\"\n                   \"int yy  = 1; ///specificlennospace\\n\"\n                   \"int zzz = 2;\\n\",\n                   Alignment));\n}\n\nTEST_F(FormatTest, AlignConsecutiveAssignments) {\n  FormatStyle Alignment = getLLVMStyle();\n  Alignment.AlignConsecutiveMacros = FormatStyle::ACS_Consecutive;\n  Alignment.AlignConsecutiveAssignments = FormatStyle::ACS_None;\n  verifyFormat(\"int a = 5;\\n\"\n               \"int oneTwoThree = 123;\",\n               Alignment);\n  verifyFormat(\"int a = 5;\\n\"\n               \"int oneTwoThree = 123;\",\n               Alignment);\n\n  Alignment.AlignConsecutiveAssignments = FormatStyle::ACS_Consecutive;\n  verifyFormat(\"int a           = 5;\\n\"\n               \"int oneTwoThree = 123;\",\n               Alignment);\n  verifyFormat(\"int a           = method();\\n\"\n               \"int oneTwoThree = 133;\",\n               Alignment);\n  verifyFormat(\"a &= 5;\\n\"\n               \"bcd *= 5;\\n\"\n               \"ghtyf += 5;\\n\"\n               \"dvfvdb -= 5;\\n\"\n               \"a /= 5;\\n\"\n               \"vdsvsv %= 5;\\n\"\n               \"sfdbddfbdfbb ^= 5;\\n\"\n               \"dvsdsv |= 5;\\n\"\n               \"int dsvvdvsdvvv = 123;\",\n               Alignment);\n  verifyFormat(\"int i = 1, j = 10;\\n\"\n               \"something = 2000;\",\n               Alignment);\n  verifyFormat(\"something = 2000;\\n\"\n               \"int i = 1, j = 10;\\n\",\n               Alignment);\n  verifyFormat(\"something = 2000;\\n\"\n               \"another   = 911;\\n\"\n               \"int i = 1, j = 10;\\n\"\n               \"oneMore = 1;\\n\"\n               \"i       = 2;\",\n               Alignment);\n  verifyFormat(\"int a   = 5;\\n\"\n               \"int one = 1;\\n\"\n               \"method();\\n\"\n               \"int oneTwoThree = 123;\\n\"\n               \"int oneTwo      = 12;\",\n               Alignment);\n  verifyFormat(\"int oneTwoThree = 123;\\n\"\n               \"int oneTwo      = 12;\\n\"\n               \"method();\\n\",\n               Alignment);\n  verifyFormat(\"int oneTwoThree = 123; // comment\\n\"\n               \"int oneTwo      = 12;  // comment\",\n               Alignment);\n\n  // Bug 25167\n  /* Uncomment when fixed\n    verifyFormat(\"#if A\\n\"\n                 \"#else\\n\"\n                 \"int aaaaaaaa = 12;\\n\"\n                 \"#endif\\n\"\n                 \"#if B\\n\"\n                 \"#else\\n\"\n                 \"int a = 12;\\n\"\n                 \"#endif\\n\",\n                 Alignment);\n    verifyFormat(\"enum foo {\\n\"\n                 \"#if A\\n\"\n                 \"#else\\n\"\n                 \"  aaaaaaaa = 12;\\n\"\n                 \"#endif\\n\"\n                 \"#if B\\n\"\n                 \"#else\\n\"\n                 \"  a = 12;\\n\"\n                 \"#endif\\n\"\n                 \"};\\n\",\n                 Alignment);\n  */\n\n  EXPECT_EQ(\"int a = 5;\\n\"\n            \"\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a       = 5;\\n\"\n                   \"\\n\"\n                   \"int oneTwoThree= 123;\",\n                   Alignment));\n  EXPECT_EQ(\"int a   = 5;\\n\"\n            \"int one = 1;\\n\"\n            \"\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"int a = 5;\\n\"\n                   \"int one = 1;\\n\"\n                   \"\\n\"\n                   \"int oneTwoThree = 123;\",\n                   Alignment));\n  EXPECT_EQ(\"int a   = 5;\\n\"\n            \"int one = 1;\\n\"\n            \"\\n\"\n            \"int oneTwoThree = 123;\\n\"\n            \"int oneTwo      = 12;\",\n            format(\"int a = 5;\\n\"\n                   \"int one = 1;\\n\"\n                   \"\\n\"\n                   \"int oneTwoThree = 123;\\n\"\n                   \"int oneTwo = 12;\",\n                   Alignment));\n  Alignment.AlignEscapedNewlines = FormatStyle::ENAS_DontAlign;\n  verifyFormat(\"#define A \\\\\\n\"\n               \"  int aaaa       = 12; \\\\\\n\"\n               \"  int b          = 23; \\\\\\n\"\n               \"  int ccc        = 234; \\\\\\n\"\n               \"  int dddddddddd = 2345;\",\n               Alignment);\n  Alignment.AlignEscapedNewlines = FormatStyle::ENAS_Left;\n  verifyFormat(\"#define A               \\\\\\n\"\n               \"  int aaaa       = 12;  \\\\\\n\"\n               \"  int b          = 23;  \\\\\\n\"\n               \"  int ccc        = 234; \\\\\\n\"\n               \"  int dddddddddd = 2345;\",\n               Alignment);\n  Alignment.AlignEscapedNewlines = FormatStyle::ENAS_Right;\n  verifyFormat(\"#define A                                                      \"\n               \"                \\\\\\n\"\n               \"  int aaaa       = 12;                                         \"\n               \"                \\\\\\n\"\n               \"  int b          = 23;                                         \"\n               \"                \\\\\\n\"\n               \"  int ccc        = 234;                                        \"\n               \"                \\\\\\n\"\n               \"  int dddddddddd = 2345;\",\n               Alignment);\n  verifyFormat(\"void SomeFunction(int parameter = 1, int i = 2, int j = 3, int \"\n               \"k = 4, int l = 5,\\n\"\n               \"                  int m = 6) {\\n\"\n               \"  int j      = 10;\\n\"\n               \"  otherThing = 1;\\n\"\n               \"}\",\n               Alignment);\n  verifyFormat(\"void SomeFunction(int parameter = 0) {\\n\"\n               \"  int i   = 1;\\n\"\n               \"  int j   = 2;\\n\"\n               \"  int big = 10000;\\n\"\n               \"}\",\n               Alignment);\n  verifyFormat(\"class C {\\n\"\n               \"public:\\n\"\n               \"  int i            = 1;\\n\"\n               \"  virtual void f() = 0;\\n\"\n               \"};\",\n               Alignment);\n  verifyFormat(\"int i = 1;\\n\"\n               \"if (SomeType t = getSomething()) {\\n\"\n               \"}\\n\"\n               \"int j   = 2;\\n\"\n               \"int big = 10000;\",\n               Alignment);\n  verifyFormat(\"int j = 7;\\n\"\n               \"for (int k = 0; k < N; ++k) {\\n\"\n               \"}\\n\"\n               \"int j   = 2;\\n\"\n               \"int big = 10000;\\n\"\n               \"}\",\n               Alignment);\n  Alignment.BreakBeforeBinaryOperators = FormatStyle::BOS_All;\n  verifyFormat(\"int i = 1;\\n\"\n               \"LooooooooooongType loooooooooooooooooooooongVariable\\n\"\n               \"    = someLooooooooooooooooongFunction();\\n\"\n               \"int j = 2;\",\n               Alignment);\n  Alignment.BreakBeforeBinaryOperators = FormatStyle::BOS_None;\n  verifyFormat(\"int i = 1;\\n\"\n               \"LooooooooooongType loooooooooooooooooooooongVariable =\\n\"\n               \"    someLooooooooooooooooongFunction();\\n\"\n               \"int j = 2;\",\n               Alignment);\n\n  verifyFormat(\"auto lambda = []() {\\n\"\n               \"  auto i = 0;\\n\"\n               \"  return 0;\\n\"\n               \"};\\n\"\n               \"int i  = 0;\\n\"\n               \"auto v = type{\\n\"\n               \"    i = 1,   //\\n\"\n               \"    (i = 2), //\\n\"\n               \"    i = 3    //\\n\"\n               \"};\",\n               Alignment);\n\n  verifyFormat(\n      \"int i      = 1;\\n\"\n      \"SomeType a = SomeFunction(looooooooooooooooooooooongParameterA,\\n\"\n      \"                          loooooooooooooooooooooongParameterB);\\n\"\n      \"int j      = 2;\",\n      Alignment);\n\n  verifyFormat(\"template <typename T, typename T_0 = very_long_type_name_0,\\n\"\n               \"          typename B   = very_long_type_name_1,\\n\"\n               \"          typename T_2 = very_long_type_name_2>\\n\"\n               \"auto foo() {}\\n\",\n               Alignment);\n  verifyFormat(\"int a, b = 1;\\n\"\n               \"int c  = 2;\\n\"\n               \"int dd = 3;\\n\",\n               Alignment);\n  verifyFormat(\"int aa       = ((1 > 2) ? 3 : 4);\\n\"\n               \"float b[1][] = {{3.f}};\\n\",\n               Alignment);\n  verifyFormat(\"for (int i = 0; i < 1; i++)\\n\"\n               \"  int x = 1;\\n\",\n               Alignment);\n  verifyFormat(\"for (i = 0; i < 1; i++)\\n\"\n               \"  x = 1;\\n\"\n               \"y = 1;\\n\",\n               Alignment);\n\n  Alignment.ReflowComments = true;\n  Alignment.ColumnLimit = 50;\n  EXPECT_EQ(\"int x   = 0;\\n\"\n            \"int yy  = 1; /// specificlennospace\\n\"\n            \"int zzz = 2;\\n\",\n            format(\"int x   = 0;\\n\"\n                   \"int yy  = 1; ///specificlennospace\\n\"\n                   \"int zzz = 2;\\n\",\n                   Alignment));\n}\n\nTEST_F(FormatTest, AlignConsecutiveBitFields) {\n  FormatStyle Alignment = getLLVMStyle();\n  Alignment.AlignConsecutiveBitFields = FormatStyle::ACS_Consecutive;\n  verifyFormat(\"int const a     : 5;\\n\"\n               \"int oneTwoThree : 23;\",\n               Alignment);\n\n  // Initializers are allowed starting with c++2a\n  verifyFormat(\"int const a     : 5 = 1;\\n\"\n               \"int oneTwoThree : 23 = 0;\",\n               Alignment);\n\n  Alignment.AlignConsecutiveDeclarations = FormatStyle::ACS_Consecutive;\n  verifyFormat(\"int const a           : 5;\\n\"\n               \"int       oneTwoThree : 23;\",\n               Alignment);\n\n  verifyFormat(\"int const a           : 5;  // comment\\n\"\n               \"int       oneTwoThree : 23; // comment\",\n               Alignment);\n\n  verifyFormat(\"int const a           : 5 = 1;\\n\"\n               \"int       oneTwoThree : 23 = 0;\",\n               Alignment);\n\n  Alignment.AlignConsecutiveAssignments = FormatStyle::ACS_Consecutive;\n  verifyFormat(\"int const a           : 5  = 1;\\n\"\n               \"int       oneTwoThree : 23 = 0;\",\n               Alignment);\n  verifyFormat(\"int const a           : 5  = {1};\\n\"\n               \"int       oneTwoThree : 23 = 0;\",\n               Alignment);\n\n  Alignment.BitFieldColonSpacing = FormatStyle::BFCS_None;\n  verifyFormat(\"int const a          :5;\\n\"\n               \"int       oneTwoThree:23;\",\n               Alignment);\n\n  Alignment.BitFieldColonSpacing = FormatStyle::BFCS_Before;\n  verifyFormat(\"int const a           :5;\\n\"\n               \"int       oneTwoThree :23;\",\n               Alignment);\n\n  Alignment.BitFieldColonSpacing = FormatStyle::BFCS_After;\n  verifyFormat(\"int const a          : 5;\\n\"\n               \"int       oneTwoThree: 23;\",\n               Alignment);\n\n  // Known limitations: ':' is only recognized as a bitfield colon when\n  // followed by a number.\n  /*\n  verifyFormat(\"int oneTwoThree : SOME_CONSTANT;\\n\"\n               \"int a           : 5;\",\n               Alignment);\n  */\n}\n\nTEST_F(FormatTest, AlignConsecutiveDeclarations) {\n  FormatStyle Alignment = getLLVMStyle();\n  Alignment.AlignConsecutiveMacros = FormatStyle::ACS_Consecutive;\n  Alignment.AlignConsecutiveDeclarations = FormatStyle::ACS_None;\n  verifyFormat(\"float const a = 5;\\n\"\n               \"int oneTwoThree = 123;\",\n               Alignment);\n  verifyFormat(\"int a = 5;\\n\"\n               \"float const oneTwoThree = 123;\",\n               Alignment);\n\n  Alignment.AlignConsecutiveDeclarations = FormatStyle::ACS_Consecutive;\n  verifyFormat(\"float const a = 5;\\n\"\n               \"int         oneTwoThree = 123;\",\n               Alignment);\n  verifyFormat(\"int         a = method();\\n\"\n               \"float const oneTwoThree = 133;\",\n               Alignment);\n  verifyFormat(\"int i = 1, j = 10;\\n\"\n               \"something = 2000;\",\n               Alignment);\n  verifyFormat(\"something = 2000;\\n\"\n               \"int i = 1, j = 10;\\n\",\n               Alignment);\n  verifyFormat(\"float      something = 2000;\\n\"\n               \"double     another = 911;\\n\"\n               \"int        i = 1, j = 10;\\n\"\n               \"const int *oneMore = 1;\\n\"\n               \"unsigned   i = 2;\",\n               Alignment);\n  verifyFormat(\"float a = 5;\\n\"\n               \"int   one = 1;\\n\"\n               \"method();\\n\"\n               \"const double       oneTwoThree = 123;\\n\"\n               \"const unsigned int oneTwo = 12;\",\n               Alignment);\n  verifyFormat(\"int      oneTwoThree{0}; // comment\\n\"\n               \"unsigned oneTwo;         // comment\",\n               Alignment);\n  verifyFormat(\"unsigned int *      a;\\n\"\n               \"int *               b;\\n\"\n               \"unsigned int Const *c;\\n\"\n               \"unsigned int const *d;\\n\"\n               \"unsigned int Const &e;\\n\"\n               \"unsigned int const &f;\",\n               Alignment);\n  verifyFormat(\"Const unsigned int *c;\\n\"\n               \"const unsigned int *d;\\n\"\n               \"Const unsigned int &e;\\n\"\n               \"const unsigned int &f;\\n\"\n               \"const unsigned      g;\\n\"\n               \"Const unsigned      h;\",\n               Alignment);\n  EXPECT_EQ(\"float const a = 5;\\n\"\n            \"\\n\"\n            \"int oneTwoThree = 123;\",\n            format(\"float const   a = 5;\\n\"\n                   \"\\n\"\n                   \"int           oneTwoThree= 123;\",\n                   Alignment));\n  EXPECT_EQ(\"float a = 5;\\n\"\n            \"int   one = 1;\\n\"\n            \"\\n\"\n            \"unsigned oneTwoThree = 123;\",\n            format(\"float    a = 5;\\n\"\n                   \"int      one = 1;\\n\"\n                   \"\\n\"\n                   \"unsigned oneTwoThree = 123;\",\n                   Alignment));\n  EXPECT_EQ(\"float a = 5;\\n\"\n            \"int   one = 1;\\n\"\n            \"\\n\"\n            \"unsigned oneTwoThree = 123;\\n\"\n            \"int      oneTwo = 12;\",\n            format(\"float    a = 5;\\n\"\n                   \"int one = 1;\\n\"\n                   \"\\n\"\n                   \"unsigned oneTwoThree = 123;\\n\"\n                   \"int oneTwo = 12;\",\n                   Alignment));\n  // Function prototype alignment\n  verifyFormat(\"int    a();\\n\"\n               \"double b();\",\n               Alignment);\n  verifyFormat(\"int    a(int x);\\n\"\n               \"double b();\",\n               Alignment);\n  unsigned OldColumnLimit = Alignment.ColumnLimit;\n  // We need to set ColumnLimit to zero, in order to stress nested alignments,\n  // otherwise the function parameters will be re-flowed onto a single line.\n  Alignment.ColumnLimit = 0;\n  EXPECT_EQ(\"int    a(int   x,\\n\"\n            \"         float y);\\n\"\n            \"double b(int    x,\\n\"\n            \"         double y);\",\n            format(\"int a(int x,\\n\"\n                   \" float y);\\n\"\n                   \"double b(int x,\\n\"\n                   \" double y);\",\n                   Alignment));\n  // This ensures that function parameters of function declarations are\n  // correctly indented when their owning functions are indented.\n  // The failure case here is for 'double y' to not be indented enough.\n  EXPECT_EQ(\"double a(int x);\\n\"\n            \"int    b(int    y,\\n\"\n            \"         double z);\",\n            format(\"double a(int x);\\n\"\n                   \"int b(int y,\\n\"\n                   \" double z);\",\n                   Alignment));\n  // Set ColumnLimit low so that we induce wrapping immediately after\n  // the function name and opening paren.\n  Alignment.ColumnLimit = 13;\n  verifyFormat(\"int function(\\n\"\n               \"    int  x,\\n\"\n               \"    bool y);\",\n               Alignment);\n  Alignment.ColumnLimit = OldColumnLimit;\n  // Ensure function pointers don't screw up recursive alignment\n  verifyFormat(\"int    a(int x, void (*fp)(int y));\\n\"\n               \"double b();\",\n               Alignment);\n  Alignment.AlignConsecutiveAssignments = FormatStyle::ACS_Consecutive;\n  // Ensure recursive alignment is broken by function braces, so that the\n  // \"a = 1\" does not align with subsequent assignments inside the function\n  // body.\n  verifyFormat(\"int func(int a = 1) {\\n\"\n               \"  int b  = 2;\\n\"\n               \"  int cc = 3;\\n\"\n               \"}\",\n               Alignment);\n  verifyFormat(\"float      something = 2000;\\n\"\n               \"double     another   = 911;\\n\"\n               \"int        i = 1, j = 10;\\n\"\n               \"const int *oneMore = 1;\\n\"\n               \"unsigned   i       = 2;\",\n               Alignment);\n  verifyFormat(\"int      oneTwoThree = {0}; // comment\\n\"\n               \"unsigned oneTwo      = 0;   // comment\",\n               Alignment);\n  // Make sure that scope is correctly tracked, in the absence of braces\n  verifyFormat(\"for (int i = 0; i < n; i++)\\n\"\n               \"  j = i;\\n\"\n               \"double x = 1;\\n\",\n               Alignment);\n  verifyFormat(\"if (int i = 0)\\n\"\n               \"  j = i;\\n\"\n               \"double x = 1;\\n\",\n               Alignment);\n  // Ensure operator[] and operator() are comprehended\n  verifyFormat(\"struct test {\\n\"\n               \"  long long int foo();\\n\"\n               \"  int           operator[](int a);\\n\"\n               \"  double        bar();\\n\"\n               \"};\\n\",\n               Alignment);\n  verifyFormat(\"struct test {\\n\"\n               \"  long long int foo();\\n\"\n               \"  int           operator()(int a);\\n\"\n               \"  double        bar();\\n\"\n               \"};\\n\",\n               Alignment);\n  EXPECT_EQ(\"void SomeFunction(int parameter = 0) {\\n\"\n            \"  int const i   = 1;\\n\"\n            \"  int *     j   = 2;\\n\"\n            \"  int       big = 10000;\\n\"\n            \"\\n\"\n            \"  unsigned oneTwoThree = 123;\\n\"\n            \"  int      oneTwo      = 12;\\n\"\n            \"  method();\\n\"\n            \"  float k  = 2;\\n\"\n            \"  int   ll = 10000;\\n\"\n            \"}\",\n            format(\"void SomeFunction(int parameter= 0) {\\n\"\n                   \" int const  i= 1;\\n\"\n                   \"  int *j=2;\\n\"\n                   \" int big  =  10000;\\n\"\n                   \"\\n\"\n                   \"unsigned oneTwoThree  =123;\\n\"\n                   \"int oneTwo = 12;\\n\"\n                   \"  method();\\n\"\n                   \"float k= 2;\\n\"\n                   \"int ll=10000;\\n\"\n                   \"}\",\n                   Alignment));\n  Alignment.AlignConsecutiveAssignments = FormatStyle::ACS_None;\n  Alignment.AlignEscapedNewlines = FormatStyle::ENAS_DontAlign;\n  verifyFormat(\"#define A \\\\\\n\"\n               \"  int       aaaa = 12; \\\\\\n\"\n               \"  float     b = 23; \\\\\\n\"\n               \"  const int ccc = 234; \\\\\\n\"\n               \"  unsigned  dddddddddd = 2345;\",\n               Alignment);\n  Alignment.AlignEscapedNewlines = FormatStyle::ENAS_Left;\n  verifyFormat(\"#define A              \\\\\\n\"\n               \"  int       aaaa = 12; \\\\\\n\"\n               \"  float     b = 23;    \\\\\\n\"\n               \"  const int ccc = 234; \\\\\\n\"\n               \"  unsigned  dddddddddd = 2345;\",\n               Alignment);\n  Alignment.AlignEscapedNewlines = FormatStyle::ENAS_Right;\n  Alignment.ColumnLimit = 30;\n  verifyFormat(\"#define A                    \\\\\\n\"\n               \"  int       aaaa = 12;       \\\\\\n\"\n               \"  float     b = 23;          \\\\\\n\"\n               \"  const int ccc = 234;       \\\\\\n\"\n               \"  int       dddddddddd = 2345;\",\n               Alignment);\n  Alignment.ColumnLimit = 80;\n  verifyFormat(\"void SomeFunction(int parameter = 1, int i = 2, int j = 3, int \"\n               \"k = 4, int l = 5,\\n\"\n               \"                  int m = 6) {\\n\"\n               \"  const int j = 10;\\n\"\n               \"  otherThing = 1;\\n\"\n               \"}\",\n               Alignment);\n  verifyFormat(\"void SomeFunction(int parameter = 0) {\\n\"\n               \"  int const i = 1;\\n\"\n               \"  int *     j = 2;\\n\"\n               \"  int       big = 10000;\\n\"\n               \"}\",\n               Alignment);\n  verifyFormat(\"class C {\\n\"\n               \"public:\\n\"\n               \"  int          i = 1;\\n\"\n               \"  virtual void f() = 0;\\n\"\n               \"};\",\n               Alignment);\n  verifyFormat(\"float i = 1;\\n\"\n               \"if (SomeType t = getSomething()) {\\n\"\n               \"}\\n\"\n               \"const unsigned j = 2;\\n\"\n               \"int            big = 10000;\",\n               Alignment);\n  verifyFormat(\"float j = 7;\\n\"\n               \"for (int k = 0; k < N; ++k) {\\n\"\n               \"}\\n\"\n               \"unsigned j = 2;\\n\"\n               \"int      big = 10000;\\n\"\n               \"}\",\n               Alignment);\n  Alignment.BreakBeforeBinaryOperators = FormatStyle::BOS_All;\n  verifyFormat(\"float              i = 1;\\n\"\n               \"LooooooooooongType loooooooooooooooooooooongVariable\\n\"\n               \"    = someLooooooooooooooooongFunction();\\n\"\n               \"int j = 2;\",\n               Alignment);\n  Alignment.BreakBeforeBinaryOperators = FormatStyle::BOS_None;\n  verifyFormat(\"int                i = 1;\\n\"\n               \"LooooooooooongType loooooooooooooooooooooongVariable =\\n\"\n               \"    someLooooooooooooooooongFunction();\\n\"\n               \"int j = 2;\",\n               Alignment);\n\n  Alignment.AlignConsecutiveAssignments = FormatStyle::ACS_Consecutive;\n  verifyFormat(\"auto lambda = []() {\\n\"\n               \"  auto  ii = 0;\\n\"\n               \"  float j  = 0;\\n\"\n               \"  return 0;\\n\"\n               \"};\\n\"\n               \"int   i  = 0;\\n\"\n               \"float i2 = 0;\\n\"\n               \"auto  v  = type{\\n\"\n               \"    i = 1,   //\\n\"\n               \"    (i = 2), //\\n\"\n               \"    i = 3    //\\n\"\n               \"};\",\n               Alignment);\n  Alignment.AlignConsecutiveAssignments = FormatStyle::ACS_None;\n\n  verifyFormat(\n      \"int      i = 1;\\n\"\n      \"SomeType a = SomeFunction(looooooooooooooooooooooongParameterA,\\n\"\n      \"                          loooooooooooooooooooooongParameterB);\\n\"\n      \"int      j = 2;\",\n      Alignment);\n\n  // Test interactions with ColumnLimit and AlignConsecutiveAssignments:\n  // We expect declarations and assignments to align, as long as it doesn't\n  // exceed the column limit, starting a new alignment sequence whenever it\n  // happens.\n  Alignment.AlignConsecutiveAssignments = FormatStyle::ACS_Consecutive;\n  Alignment.ColumnLimit = 30;\n  verifyFormat(\"float    ii              = 1;\\n\"\n               \"unsigned j               = 2;\\n\"\n               \"int someVerylongVariable = 1;\\n\"\n               \"AnotherLongType  ll = 123456;\\n\"\n               \"VeryVeryLongType k  = 2;\\n\"\n               \"int              myvar = 1;\",\n               Alignment);\n  Alignment.ColumnLimit = 80;\n  Alignment.AlignConsecutiveAssignments = FormatStyle::ACS_None;\n\n  verifyFormat(\n      \"template <typename LongTemplate, typename VeryLongTemplateTypeName,\\n\"\n      \"          typename LongType, typename B>\\n\"\n      \"auto foo() {}\\n\",\n      Alignment);\n  verifyFormat(\"float a, b = 1;\\n\"\n               \"int   c = 2;\\n\"\n               \"int   dd = 3;\\n\",\n               Alignment);\n  verifyFormat(\"int   aa = ((1 > 2) ? 3 : 4);\\n\"\n               \"float b[1][] = {{3.f}};\\n\",\n               Alignment);\n  Alignment.AlignConsecutiveAssignments = FormatStyle::ACS_Consecutive;\n  verifyFormat(\"float a, b = 1;\\n\"\n               \"int   c  = 2;\\n\"\n               \"int   dd = 3;\\n\",\n               Alignment);\n  verifyFormat(\"int   aa     = ((1 > 2) ? 3 : 4);\\n\"\n               \"float b[1][] = {{3.f}};\\n\",\n               Alignment);\n  Alignment.AlignConsecutiveAssignments = FormatStyle::ACS_None;\n\n  Alignment.ColumnLimit = 30;\n  Alignment.BinPackParameters = false;\n  verifyFormat(\"void foo(float     a,\\n\"\n               \"         float     b,\\n\"\n               \"         int       c,\\n\"\n               \"         uint32_t *d) {\\n\"\n               \"  int *  e = 0;\\n\"\n               \"  float  f = 0;\\n\"\n               \"  double g = 0;\\n\"\n               \"}\\n\"\n               \"void bar(ino_t     a,\\n\"\n               \"         int       b,\\n\"\n               \"         uint32_t *c,\\n\"\n               \"         bool      d) {}\\n\",\n               Alignment);\n  Alignment.BinPackParameters = true;\n  Alignment.ColumnLimit = 80;\n\n  // Bug 33507\n  Alignment.PointerAlignment = FormatStyle::PAS_Middle;\n  verifyFormat(\n      \"auto found = range::find_if(vsProducts, [&](auto * aProduct) {\\n\"\n      \"  static const Version verVs2017;\\n\"\n      \"  return true;\\n\"\n      \"});\\n\",\n      Alignment);\n  Alignment.PointerAlignment = FormatStyle::PAS_Right;\n\n  // See llvm.org/PR35641\n  Alignment.AlignConsecutiveDeclarations = FormatStyle::ACS_Consecutive;\n  verifyFormat(\"int func() { //\\n\"\n               \"  int      b;\\n\"\n               \"  unsigned c;\\n\"\n               \"}\",\n               Alignment);\n\n  // See PR37175\n  FormatStyle Style = getMozillaStyle();\n  Style.AlignConsecutiveDeclarations = FormatStyle::ACS_Consecutive;\n  EXPECT_EQ(\"DECOR1 /**/ int8_t /**/ DECOR2 /**/\\n\"\n            \"foo(int a);\",\n            format(\"DECOR1 /**/ int8_t /**/ DECOR2 /**/ foo (int a);\", Style));\n\n  Alignment.PointerAlignment = FormatStyle::PAS_Left;\n  verifyFormat(\"unsigned int*       a;\\n\"\n               \"int*                b;\\n\"\n               \"unsigned int Const* c;\\n\"\n               \"unsigned int const* d;\\n\"\n               \"unsigned int Const& e;\\n\"\n               \"unsigned int const& f;\",\n               Alignment);\n  verifyFormat(\"Const unsigned int* c;\\n\"\n               \"const unsigned int* d;\\n\"\n               \"Const unsigned int& e;\\n\"\n               \"const unsigned int& f;\\n\"\n               \"const unsigned      g;\\n\"\n               \"Const unsigned      h;\",\n               Alignment);\n\n  Alignment.PointerAlignment = FormatStyle::PAS_Middle;\n  verifyFormat(\"unsigned int *       a;\\n\"\n               \"int *                b;\\n\"\n               \"unsigned int Const * c;\\n\"\n               \"unsigned int const * d;\\n\"\n               \"unsigned int Const & e;\\n\"\n               \"unsigned int const & f;\",\n               Alignment);\n  verifyFormat(\"Const unsigned int * c;\\n\"\n               \"const unsigned int * d;\\n\"\n               \"Const unsigned int & e;\\n\"\n               \"const unsigned int & f;\\n\"\n               \"const unsigned       g;\\n\"\n               \"Const unsigned       h;\",\n               Alignment);\n}\n\nTEST_F(FormatTest, LinuxBraceBreaking) {\n  FormatStyle LinuxBraceStyle = getLLVMStyle();\n  LinuxBraceStyle.BreakBeforeBraces = FormatStyle::BS_Linux;\n  verifyFormat(\"namespace a\\n\"\n               \"{\\n\"\n               \"class A\\n\"\n               \"{\\n\"\n               \"  void f()\\n\"\n               \"  {\\n\"\n               \"    if (true) {\\n\"\n               \"      a();\\n\"\n               \"      b();\\n\"\n               \"    } else {\\n\"\n               \"      a();\\n\"\n               \"    }\\n\"\n               \"  }\\n\"\n               \"  void g() { return; }\\n\"\n               \"};\\n\"\n               \"struct B {\\n\"\n               \"  int x;\\n\"\n               \"};\\n\"\n               \"} // namespace a\\n\",\n               LinuxBraceStyle);\n  verifyFormat(\"enum X {\\n\"\n               \"  Y = 0,\\n\"\n               \"}\\n\",\n               LinuxBraceStyle);\n  verifyFormat(\"struct S {\\n\"\n               \"  int Type;\\n\"\n               \"  union {\\n\"\n               \"    int x;\\n\"\n               \"    double y;\\n\"\n               \"  } Value;\\n\"\n               \"  class C\\n\"\n               \"  {\\n\"\n               \"    MyFavoriteType Value;\\n\"\n               \"  } Class;\\n\"\n               \"}\\n\",\n               LinuxBraceStyle);\n}\n\nTEST_F(FormatTest, MozillaBraceBreaking) {\n  FormatStyle MozillaBraceStyle = getLLVMStyle();\n  MozillaBraceStyle.BreakBeforeBraces = FormatStyle::BS_Mozilla;\n  MozillaBraceStyle.FixNamespaceComments = false;\n  verifyFormat(\"namespace a {\\n\"\n               \"class A\\n\"\n               \"{\\n\"\n               \"  void f()\\n\"\n               \"  {\\n\"\n               \"    if (true) {\\n\"\n               \"      a();\\n\"\n               \"      b();\\n\"\n               \"    }\\n\"\n               \"  }\\n\"\n               \"  void g() { return; }\\n\"\n               \"};\\n\"\n               \"enum E\\n\"\n               \"{\\n\"\n               \"  A,\\n\"\n               \"  // foo\\n\"\n               \"  B,\\n\"\n               \"  C\\n\"\n               \"};\\n\"\n               \"struct B\\n\"\n               \"{\\n\"\n               \"  int x;\\n\"\n               \"};\\n\"\n               \"}\\n\",\n               MozillaBraceStyle);\n  verifyFormat(\"struct S\\n\"\n               \"{\\n\"\n               \"  int Type;\\n\"\n               \"  union\\n\"\n               \"  {\\n\"\n               \"    int x;\\n\"\n               \"    double y;\\n\"\n               \"  } Value;\\n\"\n               \"  class C\\n\"\n               \"  {\\n\"\n               \"    MyFavoriteType Value;\\n\"\n               \"  } Class;\\n\"\n               \"}\\n\",\n               MozillaBraceStyle);\n}\n\nTEST_F(FormatTest, StroustrupBraceBreaking) {\n  FormatStyle StroustrupBraceStyle = getLLVMStyle();\n  StroustrupBraceStyle.BreakBeforeBraces = FormatStyle::BS_Stroustrup;\n  verifyFormat(\"namespace a {\\n\"\n               \"class A {\\n\"\n               \"  void f()\\n\"\n               \"  {\\n\"\n               \"    if (true) {\\n\"\n               \"      a();\\n\"\n               \"      b();\\n\"\n               \"    }\\n\"\n               \"  }\\n\"\n               \"  void g() { return; }\\n\"\n               \"};\\n\"\n               \"struct B {\\n\"\n               \"  int x;\\n\"\n               \"};\\n\"\n               \"} // namespace a\\n\",\n               StroustrupBraceStyle);\n\n  verifyFormat(\"void foo()\\n\"\n               \"{\\n\"\n               \"  if (a) {\\n\"\n               \"    a();\\n\"\n               \"  }\\n\"\n               \"  else {\\n\"\n               \"    b();\\n\"\n               \"  }\\n\"\n               \"}\\n\",\n               StroustrupBraceStyle);\n\n  verifyFormat(\"#ifdef _DEBUG\\n\"\n               \"int foo(int i = 0)\\n\"\n               \"#else\\n\"\n               \"int foo(int i = 5)\\n\"\n               \"#endif\\n\"\n               \"{\\n\"\n               \"  return i;\\n\"\n               \"}\",\n               StroustrupBraceStyle);\n\n  verifyFormat(\"void foo() {}\\n\"\n               \"void bar()\\n\"\n               \"#ifdef _DEBUG\\n\"\n               \"{\\n\"\n               \"  foo();\\n\"\n               \"}\\n\"\n               \"#else\\n\"\n               \"{\\n\"\n               \"}\\n\"\n               \"#endif\",\n               StroustrupBraceStyle);\n\n  verifyFormat(\"void foobar() { int i = 5; }\\n\"\n               \"#ifdef _DEBUG\\n\"\n               \"void bar() {}\\n\"\n               \"#else\\n\"\n               \"void bar() { foobar(); }\\n\"\n               \"#endif\",\n               StroustrupBraceStyle);\n}\n\nTEST_F(FormatTest, AllmanBraceBreaking) {\n  FormatStyle AllmanBraceStyle = getLLVMStyle();\n  AllmanBraceStyle.BreakBeforeBraces = FormatStyle::BS_Allman;\n\n  EXPECT_EQ(\"namespace a\\n\"\n            \"{\\n\"\n            \"void f();\\n\"\n            \"void g();\\n\"\n            \"} // namespace a\\n\",\n            format(\"namespace a\\n\"\n                   \"{\\n\"\n                   \"void f();\\n\"\n                   \"void g();\\n\"\n                   \"}\\n\",\n                   AllmanBraceStyle));\n\n  verifyFormat(\"namespace a\\n\"\n               \"{\\n\"\n               \"class A\\n\"\n               \"{\\n\"\n               \"  void f()\\n\"\n               \"  {\\n\"\n               \"    if (true)\\n\"\n               \"    {\\n\"\n               \"      a();\\n\"\n               \"      b();\\n\"\n               \"    }\\n\"\n               \"  }\\n\"\n               \"  void g() { return; }\\n\"\n               \"};\\n\"\n               \"struct B\\n\"\n               \"{\\n\"\n               \"  int x;\\n\"\n               \"};\\n\"\n               \"union C\\n\"\n               \"{\\n\"\n               \"};\\n\"\n               \"} // namespace a\",\n               AllmanBraceStyle);\n\n  verifyFormat(\"void f()\\n\"\n               \"{\\n\"\n               \"  if (true)\\n\"\n               \"  {\\n\"\n               \"    a();\\n\"\n               \"  }\\n\"\n               \"  else if (false)\\n\"\n               \"  {\\n\"\n               \"    b();\\n\"\n               \"  }\\n\"\n               \"  else\\n\"\n               \"  {\\n\"\n               \"    c();\\n\"\n               \"  }\\n\"\n               \"}\\n\",\n               AllmanBraceStyle);\n\n  verifyFormat(\"void f()\\n\"\n               \"{\\n\"\n               \"  for (int i = 0; i < 10; ++i)\\n\"\n               \"  {\\n\"\n               \"    a();\\n\"\n               \"  }\\n\"\n               \"  while (false)\\n\"\n               \"  {\\n\"\n               \"    b();\\n\"\n               \"  }\\n\"\n               \"  do\\n\"\n               \"  {\\n\"\n               \"    c();\\n\"\n               \"  } while (false)\\n\"\n               \"}\\n\",\n               AllmanBraceStyle);\n\n  verifyFormat(\"void f(int a)\\n\"\n               \"{\\n\"\n               \"  switch (a)\\n\"\n               \"  {\\n\"\n               \"  case 0:\\n\"\n               \"    break;\\n\"\n               \"  case 1:\\n\"\n               \"  {\\n\"\n               \"    break;\\n\"\n               \"  }\\n\"\n               \"  case 2:\\n\"\n               \"  {\\n\"\n               \"  }\\n\"\n               \"  break;\\n\"\n               \"  default:\\n\"\n               \"    break;\\n\"\n               \"  }\\n\"\n               \"}\\n\",\n               AllmanBraceStyle);\n\n  verifyFormat(\"enum X\\n\"\n               \"{\\n\"\n               \"  Y = 0,\\n\"\n               \"}\\n\",\n               AllmanBraceStyle);\n  verifyFormat(\"enum X\\n\"\n               \"{\\n\"\n               \"  Y = 0\\n\"\n               \"}\\n\",\n               AllmanBraceStyle);\n\n  verifyFormat(\"@interface BSApplicationController ()\\n\"\n               \"{\\n\"\n               \"@private\\n\"\n               \"  id _extraIvar;\\n\"\n               \"}\\n\"\n               \"@end\\n\",\n               AllmanBraceStyle);\n\n  verifyFormat(\"#ifdef _DEBUG\\n\"\n               \"int foo(int i = 0)\\n\"\n               \"#else\\n\"\n               \"int foo(int i = 5)\\n\"\n               \"#endif\\n\"\n               \"{\\n\"\n               \"  return i;\\n\"\n               \"}\",\n               AllmanBraceStyle);\n\n  verifyFormat(\"void foo() {}\\n\"\n               \"void bar()\\n\"\n               \"#ifdef _DEBUG\\n\"\n               \"{\\n\"\n               \"  foo();\\n\"\n               \"}\\n\"\n               \"#else\\n\"\n               \"{\\n\"\n               \"}\\n\"\n               \"#endif\",\n               AllmanBraceStyle);\n\n  verifyFormat(\"void foobar() { int i = 5; }\\n\"\n               \"#ifdef _DEBUG\\n\"\n               \"void bar() {}\\n\"\n               \"#else\\n\"\n               \"void bar() { foobar(); }\\n\"\n               \"#endif\",\n               AllmanBraceStyle);\n\n  EXPECT_EQ(AllmanBraceStyle.AllowShortLambdasOnASingleLine,\n            FormatStyle::SLS_All);\n\n  verifyFormat(\"[](int i) { return i + 2; };\\n\"\n               \"[](int i, int j)\\n\"\n               \"{\\n\"\n               \"  auto x = i + j;\\n\"\n               \"  auto y = i * j;\\n\"\n               \"  return x ^ y;\\n\"\n               \"};\\n\"\n               \"void foo()\\n\"\n               \"{\\n\"\n               \"  auto shortLambda = [](int i) { return i + 2; };\\n\"\n               \"  auto longLambda = [](int i, int j)\\n\"\n               \"  {\\n\"\n               \"    auto x = i + j;\\n\"\n               \"    auto y = i * j;\\n\"\n               \"    return x ^ y;\\n\"\n               \"  };\\n\"\n               \"}\",\n               AllmanBraceStyle);\n\n  AllmanBraceStyle.AllowShortLambdasOnASingleLine = FormatStyle::SLS_None;\n\n  verifyFormat(\"[](int i)\\n\"\n               \"{\\n\"\n               \"  return i + 2;\\n\"\n               \"};\\n\"\n               \"[](int i, int j)\\n\"\n               \"{\\n\"\n               \"  auto x = i + j;\\n\"\n               \"  auto y = i * j;\\n\"\n               \"  return x ^ y;\\n\"\n               \"};\\n\"\n               \"void foo()\\n\"\n               \"{\\n\"\n               \"  auto shortLambda = [](int i)\\n\"\n               \"  {\\n\"\n               \"    return i + 2;\\n\"\n               \"  };\\n\"\n               \"  auto longLambda = [](int i, int j)\\n\"\n               \"  {\\n\"\n               \"    auto x = i + j;\\n\"\n               \"    auto y = i * j;\\n\"\n               \"    return x ^ y;\\n\"\n               \"  };\\n\"\n               \"}\",\n               AllmanBraceStyle);\n\n  // Reset\n  AllmanBraceStyle.AllowShortLambdasOnASingleLine = FormatStyle::SLS_All;\n\n  // This shouldn't affect ObjC blocks..\n  verifyFormat(\"[self doSomeThingWithACompletionHandler:^{\\n\"\n               \"  // ...\\n\"\n               \"  int i;\\n\"\n               \"}];\",\n               AllmanBraceStyle);\n  verifyFormat(\"void (^block)(void) = ^{\\n\"\n               \"  // ...\\n\"\n               \"  int i;\\n\"\n               \"};\",\n               AllmanBraceStyle);\n  // .. or dict literals.\n  verifyFormat(\"void f()\\n\"\n               \"{\\n\"\n               \"  // ...\\n\"\n               \"  [object someMethod:@{@\\\"a\\\" : @\\\"b\\\"}];\\n\"\n               \"}\",\n               AllmanBraceStyle);\n  verifyFormat(\"void f()\\n\"\n               \"{\\n\"\n               \"  // ...\\n\"\n               \"  [object someMethod:@{a : @\\\"b\\\"}];\\n\"\n               \"}\",\n               AllmanBraceStyle);\n  verifyFormat(\"int f()\\n\"\n               \"{ // comment\\n\"\n               \"  return 42;\\n\"\n               \"}\",\n               AllmanBraceStyle);\n\n  AllmanBraceStyle.ColumnLimit = 19;\n  verifyFormat(\"void f() { int i; }\", AllmanBraceStyle);\n  AllmanBraceStyle.ColumnLimit = 18;\n  verifyFormat(\"void f()\\n\"\n               \"{\\n\"\n               \"  int i;\\n\"\n               \"}\",\n               AllmanBraceStyle);\n  AllmanBraceStyle.ColumnLimit = 80;\n\n  FormatStyle BreakBeforeBraceShortIfs = AllmanBraceStyle;\n  BreakBeforeBraceShortIfs.AllowShortIfStatementsOnASingleLine =\n      FormatStyle::SIS_WithoutElse;\n  BreakBeforeBraceShortIfs.AllowShortLoopsOnASingleLine = true;\n  verifyFormat(\"void f(bool b)\\n\"\n               \"{\\n\"\n               \"  if (b)\\n\"\n               \"  {\\n\"\n               \"    return;\\n\"\n               \"  }\\n\"\n               \"}\\n\",\n               BreakBeforeBraceShortIfs);\n  verifyFormat(\"void f(bool b)\\n\"\n               \"{\\n\"\n               \"  if constexpr (b)\\n\"\n               \"  {\\n\"\n               \"    return;\\n\"\n               \"  }\\n\"\n               \"}\\n\",\n               BreakBeforeBraceShortIfs);\n  verifyFormat(\"void f(bool b)\\n\"\n               \"{\\n\"\n               \"  if CONSTEXPR (b)\\n\"\n               \"  {\\n\"\n               \"    return;\\n\"\n               \"  }\\n\"\n               \"}\\n\",\n               BreakBeforeBraceShortIfs);\n  verifyFormat(\"void f(bool b)\\n\"\n               \"{\\n\"\n               \"  if (b) return;\\n\"\n               \"}\\n\",\n               BreakBeforeBraceShortIfs);\n  verifyFormat(\"void f(bool b)\\n\"\n               \"{\\n\"\n               \"  if constexpr (b) return;\\n\"\n               \"}\\n\",\n               BreakBeforeBraceShortIfs);\n  verifyFormat(\"void f(bool b)\\n\"\n               \"{\\n\"\n               \"  if CONSTEXPR (b) return;\\n\"\n               \"}\\n\",\n               BreakBeforeBraceShortIfs);\n  verifyFormat(\"void f(bool b)\\n\"\n               \"{\\n\"\n               \"  while (b)\\n\"\n               \"  {\\n\"\n               \"    return;\\n\"\n               \"  }\\n\"\n               \"}\\n\",\n               BreakBeforeBraceShortIfs);\n}\n\nTEST_F(FormatTest, WhitesmithsBraceBreaking) {\n  FormatStyle WhitesmithsBraceStyle = getLLVMStyle();\n  WhitesmithsBraceStyle.BreakBeforeBraces = FormatStyle::BS_Whitesmiths;\n\n  // Make a few changes to the style for testing purposes\n  WhitesmithsBraceStyle.AllowShortFunctionsOnASingleLine =\n      FormatStyle::SFS_Empty;\n  WhitesmithsBraceStyle.AllowShortLambdasOnASingleLine = FormatStyle::SLS_None;\n  WhitesmithsBraceStyle.ColumnLimit = 0;\n\n  // FIXME: this test case can't decide whether there should be a blank line\n  // after the ~D() line or not. It adds one if one doesn't exist in the test\n  // and it removes the line if one exists.\n  /*\n  verifyFormat(\"class A;\\n\"\n               \"namespace B\\n\"\n               \"  {\\n\"\n               \"class C;\\n\"\n               \"// Comment\\n\"\n               \"class D\\n\"\n               \"  {\\n\"\n               \"public:\\n\"\n               \"  D();\\n\"\n               \"  ~D() {}\\n\"\n               \"private:\\n\"\n               \"  enum E\\n\"\n               \"    {\\n\"\n               \"    F\\n\"\n               \"    }\\n\"\n               \"  };\\n\"\n               \"  } // namespace B\\n\",\n               WhitesmithsBraceStyle);\n  */\n\n  WhitesmithsBraceStyle.NamespaceIndentation = FormatStyle::NI_None;\n  verifyFormat(\"namespace a\\n\"\n               \"  {\\n\"\n               \"class A\\n\"\n               \"  {\\n\"\n               \"  void f()\\n\"\n               \"    {\\n\"\n               \"    if (true)\\n\"\n               \"      {\\n\"\n               \"      a();\\n\"\n               \"      b();\\n\"\n               \"      }\\n\"\n               \"    }\\n\"\n               \"  void g()\\n\"\n               \"    {\\n\"\n               \"    return;\\n\"\n               \"    }\\n\"\n               \"  };\\n\"\n               \"struct B\\n\"\n               \"  {\\n\"\n               \"  int x;\\n\"\n               \"  };\\n\"\n               \"  } // namespace a\",\n               WhitesmithsBraceStyle);\n\n  verifyFormat(\"namespace a\\n\"\n               \"  {\\n\"\n               \"namespace b\\n\"\n               \"  {\\n\"\n               \"class A\\n\"\n               \"  {\\n\"\n               \"  void f()\\n\"\n               \"    {\\n\"\n               \"    if (true)\\n\"\n               \"      {\\n\"\n               \"      a();\\n\"\n               \"      b();\\n\"\n               \"      }\\n\"\n               \"    }\\n\"\n               \"  void g()\\n\"\n               \"    {\\n\"\n               \"    return;\\n\"\n               \"    }\\n\"\n               \"  };\\n\"\n               \"struct B\\n\"\n               \"  {\\n\"\n               \"  int x;\\n\"\n               \"  };\\n\"\n               \"  } // namespace b\\n\"\n               \"  } // namespace a\",\n               WhitesmithsBraceStyle);\n\n  WhitesmithsBraceStyle.NamespaceIndentation = FormatStyle::NI_Inner;\n  verifyFormat(\"namespace a\\n\"\n               \"  {\\n\"\n               \"namespace b\\n\"\n               \"  {\\n\"\n               \"  class A\\n\"\n               \"    {\\n\"\n               \"    void f()\\n\"\n               \"      {\\n\"\n               \"      if (true)\\n\"\n               \"        {\\n\"\n               \"        a();\\n\"\n               \"        b();\\n\"\n               \"        }\\n\"\n               \"      }\\n\"\n               \"    void g()\\n\"\n               \"      {\\n\"\n               \"      return;\\n\"\n               \"      }\\n\"\n               \"    };\\n\"\n               \"  struct B\\n\"\n               \"    {\\n\"\n               \"    int x;\\n\"\n               \"    };\\n\"\n               \"  } // namespace b\\n\"\n               \"  } // namespace a\",\n               WhitesmithsBraceStyle);\n\n  WhitesmithsBraceStyle.NamespaceIndentation = FormatStyle::NI_All;\n  verifyFormat(\"namespace a\\n\"\n               \"  {\\n\"\n               \"  namespace b\\n\"\n               \"    {\\n\"\n               \"    class A\\n\"\n               \"      {\\n\"\n               \"      void f()\\n\"\n               \"        {\\n\"\n               \"        if (true)\\n\"\n               \"          {\\n\"\n               \"          a();\\n\"\n               \"          b();\\n\"\n               \"          }\\n\"\n               \"        }\\n\"\n               \"      void g()\\n\"\n               \"        {\\n\"\n               \"        return;\\n\"\n               \"        }\\n\"\n               \"      };\\n\"\n               \"    struct B\\n\"\n               \"      {\\n\"\n               \"      int x;\\n\"\n               \"      };\\n\"\n               \"    } // namespace b\\n\"\n               \"  }   // namespace a\",\n               WhitesmithsBraceStyle);\n\n  verifyFormat(\"void f()\\n\"\n               \"  {\\n\"\n               \"  if (true)\\n\"\n               \"    {\\n\"\n               \"    a();\\n\"\n               \"    }\\n\"\n               \"  else if (false)\\n\"\n               \"    {\\n\"\n               \"    b();\\n\"\n               \"    }\\n\"\n               \"  else\\n\"\n               \"    {\\n\"\n               \"    c();\\n\"\n               \"    }\\n\"\n               \"  }\\n\",\n               WhitesmithsBraceStyle);\n\n  verifyFormat(\"void f()\\n\"\n               \"  {\\n\"\n               \"  for (int i = 0; i < 10; ++i)\\n\"\n               \"    {\\n\"\n               \"    a();\\n\"\n               \"    }\\n\"\n               \"  while (false)\\n\"\n               \"    {\\n\"\n               \"    b();\\n\"\n               \"    }\\n\"\n               \"  do\\n\"\n               \"    {\\n\"\n               \"    c();\\n\"\n               \"    } while (false)\\n\"\n               \"  }\\n\",\n               WhitesmithsBraceStyle);\n\n  WhitesmithsBraceStyle.IndentCaseLabels = true;\n  verifyFormat(\"void switchTest1(int a)\\n\"\n               \"  {\\n\"\n               \"  switch (a)\\n\"\n               \"    {\\n\"\n               \"    case 2:\\n\"\n               \"      {\\n\"\n               \"      }\\n\"\n               \"      break;\\n\"\n               \"    }\\n\"\n               \"  }\\n\",\n               WhitesmithsBraceStyle);\n\n  verifyFormat(\"void switchTest2(int a)\\n\"\n               \"  {\\n\"\n               \"  switch (a)\\n\"\n               \"    {\\n\"\n               \"    case 0:\\n\"\n               \"      break;\\n\"\n               \"    case 1:\\n\"\n               \"      {\\n\"\n               \"      break;\\n\"\n               \"      }\\n\"\n               \"    case 2:\\n\"\n               \"      {\\n\"\n               \"      }\\n\"\n               \"      break;\\n\"\n               \"    default:\\n\"\n               \"      break;\\n\"\n               \"    }\\n\"\n               \"  }\\n\",\n               WhitesmithsBraceStyle);\n\n  verifyFormat(\"void switchTest3(int a)\\n\"\n               \"  {\\n\"\n               \"  switch (a)\\n\"\n               \"    {\\n\"\n               \"    case 0:\\n\"\n               \"      {\\n\"\n               \"      foo(x);\\n\"\n               \"      }\\n\"\n               \"      break;\\n\"\n               \"    default:\\n\"\n               \"      {\\n\"\n               \"      foo(1);\\n\"\n               \"      }\\n\"\n               \"      break;\\n\"\n               \"    }\\n\"\n               \"  }\\n\",\n               WhitesmithsBraceStyle);\n\n  WhitesmithsBraceStyle.IndentCaseLabels = false;\n\n  verifyFormat(\"void switchTest4(int a)\\n\"\n               \"  {\\n\"\n               \"  switch (a)\\n\"\n               \"    {\\n\"\n               \"  case 2:\\n\"\n               \"    {\\n\"\n               \"    }\\n\"\n               \"    break;\\n\"\n               \"    }\\n\"\n               \"  }\\n\",\n               WhitesmithsBraceStyle);\n\n  verifyFormat(\"void switchTest5(int a)\\n\"\n               \"  {\\n\"\n               \"  switch (a)\\n\"\n               \"    {\\n\"\n               \"  case 0:\\n\"\n               \"    break;\\n\"\n               \"  case 1:\\n\"\n               \"    {\\n\"\n               \"    foo();\\n\"\n               \"    break;\\n\"\n               \"    }\\n\"\n               \"  case 2:\\n\"\n               \"    {\\n\"\n               \"    }\\n\"\n               \"    break;\\n\"\n               \"  default:\\n\"\n               \"    break;\\n\"\n               \"    }\\n\"\n               \"  }\\n\",\n               WhitesmithsBraceStyle);\n\n  verifyFormat(\"void switchTest6(int a)\\n\"\n               \"  {\\n\"\n               \"  switch (a)\\n\"\n               \"    {\\n\"\n               \"  case 0:\\n\"\n               \"    {\\n\"\n               \"    foo(x);\\n\"\n               \"    }\\n\"\n               \"    break;\\n\"\n               \"  default:\\n\"\n               \"    {\\n\"\n               \"    foo(1);\\n\"\n               \"    }\\n\"\n               \"    break;\\n\"\n               \"    }\\n\"\n               \"  }\\n\",\n               WhitesmithsBraceStyle);\n\n  verifyFormat(\"enum X\\n\"\n               \"  {\\n\"\n               \"  Y = 0, // testing\\n\"\n               \"  }\\n\",\n               WhitesmithsBraceStyle);\n\n  verifyFormat(\"enum X\\n\"\n               \"  {\\n\"\n               \"  Y = 0\\n\"\n               \"  }\\n\",\n               WhitesmithsBraceStyle);\n  verifyFormat(\"enum X\\n\"\n               \"  {\\n\"\n               \"  Y = 0,\\n\"\n               \"  Z = 1\\n\"\n               \"  };\\n\",\n               WhitesmithsBraceStyle);\n\n  verifyFormat(\"@interface BSApplicationController ()\\n\"\n               \"  {\\n\"\n               \"@private\\n\"\n               \"  id _extraIvar;\\n\"\n               \"  }\\n\"\n               \"@end\\n\",\n               WhitesmithsBraceStyle);\n\n  verifyFormat(\"#ifdef _DEBUG\\n\"\n               \"int foo(int i = 0)\\n\"\n               \"#else\\n\"\n               \"int foo(int i = 5)\\n\"\n               \"#endif\\n\"\n               \"  {\\n\"\n               \"  return i;\\n\"\n               \"  }\",\n               WhitesmithsBraceStyle);\n\n  verifyFormat(\"void foo() {}\\n\"\n               \"void bar()\\n\"\n               \"#ifdef _DEBUG\\n\"\n               \"  {\\n\"\n               \"  foo();\\n\"\n               \"  }\\n\"\n               \"#else\\n\"\n               \"  {\\n\"\n               \"  }\\n\"\n               \"#endif\",\n               WhitesmithsBraceStyle);\n\n  verifyFormat(\"void foobar()\\n\"\n               \"  {\\n\"\n               \"  int i = 5;\\n\"\n               \"  }\\n\"\n               \"#ifdef _DEBUG\\n\"\n               \"void bar()\\n\"\n               \"  {\\n\"\n               \"  }\\n\"\n               \"#else\\n\"\n               \"void bar()\\n\"\n               \"  {\\n\"\n               \"  foobar();\\n\"\n               \"  }\\n\"\n               \"#endif\",\n               WhitesmithsBraceStyle);\n\n  // This shouldn't affect ObjC blocks..\n  verifyFormat(\"[self doSomeThingWithACompletionHandler:^{\\n\"\n               \"  // ...\\n\"\n               \"  int i;\\n\"\n               \"}];\",\n               WhitesmithsBraceStyle);\n  verifyFormat(\"void (^block)(void) = ^{\\n\"\n               \"  // ...\\n\"\n               \"  int i;\\n\"\n               \"};\",\n               WhitesmithsBraceStyle);\n  // .. or dict literals.\n  verifyFormat(\"void f()\\n\"\n               \"  {\\n\"\n               \"  [object someMethod:@{@\\\"a\\\" : @\\\"b\\\"}];\\n\"\n               \"  }\",\n               WhitesmithsBraceStyle);\n\n  verifyFormat(\"int f()\\n\"\n               \"  { // comment\\n\"\n               \"  return 42;\\n\"\n               \"  }\",\n               WhitesmithsBraceStyle);\n\n  FormatStyle BreakBeforeBraceShortIfs = WhitesmithsBraceStyle;\n  BreakBeforeBraceShortIfs.AllowShortIfStatementsOnASingleLine =\n      FormatStyle::SIS_Always;\n  BreakBeforeBraceShortIfs.AllowShortLoopsOnASingleLine = true;\n  verifyFormat(\"void f(bool b)\\n\"\n               \"  {\\n\"\n               \"  if (b)\\n\"\n               \"    {\\n\"\n               \"    return;\\n\"\n               \"    }\\n\"\n               \"  }\\n\",\n               BreakBeforeBraceShortIfs);\n  verifyFormat(\"void f(bool b)\\n\"\n               \"  {\\n\"\n               \"  if (b) return;\\n\"\n               \"  }\\n\",\n               BreakBeforeBraceShortIfs);\n  verifyFormat(\"void f(bool b)\\n\"\n               \"  {\\n\"\n               \"  while (b)\\n\"\n               \"    {\\n\"\n               \"    return;\\n\"\n               \"    }\\n\"\n               \"  }\\n\",\n               BreakBeforeBraceShortIfs);\n}\n\nTEST_F(FormatTest, GNUBraceBreaking) {\n  FormatStyle GNUBraceStyle = getLLVMStyle();\n  GNUBraceStyle.BreakBeforeBraces = FormatStyle::BS_GNU;\n  verifyFormat(\"namespace a\\n\"\n               \"{\\n\"\n               \"class A\\n\"\n               \"{\\n\"\n               \"  void f()\\n\"\n               \"  {\\n\"\n               \"    int a;\\n\"\n               \"    {\\n\"\n               \"      int b;\\n\"\n               \"    }\\n\"\n               \"    if (true)\\n\"\n               \"      {\\n\"\n               \"        a();\\n\"\n               \"        b();\\n\"\n               \"      }\\n\"\n               \"  }\\n\"\n               \"  void g() { return; }\\n\"\n               \"}\\n\"\n               \"} // namespace a\",\n               GNUBraceStyle);\n\n  verifyFormat(\"void f()\\n\"\n               \"{\\n\"\n               \"  if (true)\\n\"\n               \"    {\\n\"\n               \"      a();\\n\"\n               \"    }\\n\"\n               \"  else if (false)\\n\"\n               \"    {\\n\"\n               \"      b();\\n\"\n               \"    }\\n\"\n               \"  else\\n\"\n               \"    {\\n\"\n               \"      c();\\n\"\n               \"    }\\n\"\n               \"}\\n\",\n               GNUBraceStyle);\n\n  verifyFormat(\"void f()\\n\"\n               \"{\\n\"\n               \"  for (int i = 0; i < 10; ++i)\\n\"\n               \"    {\\n\"\n               \"      a();\\n\"\n               \"    }\\n\"\n               \"  while (false)\\n\"\n               \"    {\\n\"\n               \"      b();\\n\"\n               \"    }\\n\"\n               \"  do\\n\"\n               \"    {\\n\"\n               \"      c();\\n\"\n               \"    }\\n\"\n               \"  while (false);\\n\"\n               \"}\\n\",\n               GNUBraceStyle);\n\n  verifyFormat(\"void f(int a)\\n\"\n               \"{\\n\"\n               \"  switch (a)\\n\"\n               \"    {\\n\"\n               \"    case 0:\\n\"\n               \"      break;\\n\"\n               \"    case 1:\\n\"\n               \"      {\\n\"\n               \"        break;\\n\"\n               \"      }\\n\"\n               \"    case 2:\\n\"\n               \"      {\\n\"\n               \"      }\\n\"\n               \"      break;\\n\"\n               \"    default:\\n\"\n               \"      break;\\n\"\n               \"    }\\n\"\n               \"}\\n\",\n               GNUBraceStyle);\n\n  verifyFormat(\"enum X\\n\"\n               \"{\\n\"\n               \"  Y = 0,\\n\"\n               \"}\\n\",\n               GNUBraceStyle);\n\n  verifyFormat(\"@interface BSApplicationController ()\\n\"\n               \"{\\n\"\n               \"@private\\n\"\n               \"  id _extraIvar;\\n\"\n               \"}\\n\"\n               \"@end\\n\",\n               GNUBraceStyle);\n\n  verifyFormat(\"#ifdef _DEBUG\\n\"\n               \"int foo(int i = 0)\\n\"\n               \"#else\\n\"\n               \"int foo(int i = 5)\\n\"\n               \"#endif\\n\"\n               \"{\\n\"\n               \"  return i;\\n\"\n               \"}\",\n               GNUBraceStyle);\n\n  verifyFormat(\"void foo() {}\\n\"\n               \"void bar()\\n\"\n               \"#ifdef _DEBUG\\n\"\n               \"{\\n\"\n               \"  foo();\\n\"\n               \"}\\n\"\n               \"#else\\n\"\n               \"{\\n\"\n               \"}\\n\"\n               \"#endif\",\n               GNUBraceStyle);\n\n  verifyFormat(\"void foobar() { int i = 5; }\\n\"\n               \"#ifdef _DEBUG\\n\"\n               \"void bar() {}\\n\"\n               \"#else\\n\"\n               \"void bar() { foobar(); }\\n\"\n               \"#endif\",\n               GNUBraceStyle);\n}\n\nTEST_F(FormatTest, WebKitBraceBreaking) {\n  FormatStyle WebKitBraceStyle = getLLVMStyle();\n  WebKitBraceStyle.BreakBeforeBraces = FormatStyle::BS_WebKit;\n  WebKitBraceStyle.FixNamespaceComments = false;\n  verifyFormat(\"namespace a {\\n\"\n               \"class A {\\n\"\n               \"  void f()\\n\"\n               \"  {\\n\"\n               \"    if (true) {\\n\"\n               \"      a();\\n\"\n               \"      b();\\n\"\n               \"    }\\n\"\n               \"  }\\n\"\n               \"  void g() { return; }\\n\"\n               \"};\\n\"\n               \"enum E {\\n\"\n               \"  A,\\n\"\n               \"  // foo\\n\"\n               \"  B,\\n\"\n               \"  C\\n\"\n               \"};\\n\"\n               \"struct B {\\n\"\n               \"  int x;\\n\"\n               \"};\\n\"\n               \"}\\n\",\n               WebKitBraceStyle);\n  verifyFormat(\"struct S {\\n\"\n               \"  int Type;\\n\"\n               \"  union {\\n\"\n               \"    int x;\\n\"\n               \"    double y;\\n\"\n               \"  } Value;\\n\"\n               \"  class C {\\n\"\n               \"    MyFavoriteType Value;\\n\"\n               \"  } Class;\\n\"\n               \"};\\n\",\n               WebKitBraceStyle);\n}\n\nTEST_F(FormatTest, CatchExceptionReferenceBinding) {\n  verifyFormat(\"void f() {\\n\"\n               \"  try {\\n\"\n               \"  } catch (const Exception &e) {\\n\"\n               \"  }\\n\"\n               \"}\\n\",\n               getLLVMStyle());\n}\n\nTEST_F(FormatTest, UnderstandsPragmas) {\n  verifyFormat(\"#pragma omp reduction(| : var)\");\n  verifyFormat(\"#pragma omp reduction(+ : var)\");\n\n  EXPECT_EQ(\"#pragma mark Any non-hyphenated or hyphenated string \"\n            \"(including parentheses).\",\n            format(\"#pragma    mark   Any non-hyphenated or hyphenated string \"\n                   \"(including parentheses).\"));\n}\n\nTEST_F(FormatTest, UnderstandPragmaOption) {\n  verifyFormat(\"#pragma option -C -A\");\n\n  EXPECT_EQ(\"#pragma option -C -A\", format(\"#pragma    option   -C   -A\"));\n}\n\nTEST_F(FormatTest, OptimizeBreakPenaltyVsExcess) {\n  FormatStyle Style = getLLVMStyle();\n  Style.ColumnLimit = 20;\n\n  // See PR41213\n  EXPECT_EQ(\"/*\\n\"\n            \" *\\t9012345\\n\"\n            \" * /8901\\n\"\n            \" */\",\n            format(\"/*\\n\"\n                   \" *\\t9012345 /8901\\n\"\n                   \" */\",\n                   Style));\n  EXPECT_EQ(\"/*\\n\"\n            \" *345678\\n\"\n            \" *\\t/8901\\n\"\n            \" */\",\n            format(\"/*\\n\"\n                   \" *345678\\t/8901\\n\"\n                   \" */\",\n                   Style));\n\n  verifyFormat(\"int a; // the\\n\"\n               \"       // comment\",\n               Style);\n  EXPECT_EQ(\"int a; /* first line\\n\"\n            \"        * second\\n\"\n            \"        * line third\\n\"\n            \"        * line\\n\"\n            \"        */\",\n            format(\"int a; /* first line\\n\"\n                   \"        * second\\n\"\n                   \"        * line third\\n\"\n                   \"        * line\\n\"\n                   \"        */\",\n                   Style));\n  EXPECT_EQ(\"int a; // first line\\n\"\n            \"       // second\\n\"\n            \"       // line third\\n\"\n            \"       // line\",\n            format(\"int a; // first line\\n\"\n                   \"       // second line\\n\"\n                   \"       // third line\",\n                   Style));\n\n  Style.PenaltyExcessCharacter = 90;\n  verifyFormat(\"int a; // the comment\", Style);\n  EXPECT_EQ(\"int a; // the comment\\n\"\n            \"       // aaa\",\n            format(\"int a; // the comment aaa\", Style));\n  EXPECT_EQ(\"int a; /* first line\\n\"\n            \"        * second line\\n\"\n            \"        * third line\\n\"\n            \"        */\",\n            format(\"int a; /* first line\\n\"\n                   \"        * second line\\n\"\n                   \"        * third line\\n\"\n                   \"        */\",\n                   Style));\n  EXPECT_EQ(\"int a; // first line\\n\"\n            \"       // second line\\n\"\n            \"       // third line\",\n            format(\"int a; // first line\\n\"\n                   \"       // second line\\n\"\n                   \"       // third line\",\n                   Style));\n  // FIXME: Investigate why this is not getting the same layout as the test\n  // above.\n  EXPECT_EQ(\"int a; /* first line\\n\"\n            \"        * second line\\n\"\n            \"        * third line\\n\"\n            \"        */\",\n            format(\"int a; /* first line second line third line\"\n                   \"\\n*/\",\n                   Style));\n\n  EXPECT_EQ(\"// foo bar baz bazfoo\\n\"\n            \"// foo bar foo bar\\n\",\n            format(\"// foo bar baz bazfoo\\n\"\n                   \"// foo bar foo           bar\\n\",\n                   Style));\n  EXPECT_EQ(\"// foo bar baz bazfoo\\n\"\n            \"// foo bar foo bar\\n\",\n            format(\"// foo bar baz      bazfoo\\n\"\n                   \"// foo            bar foo bar\\n\",\n                   Style));\n\n  // FIXME: Optimally, we'd keep bazfoo on the first line and reflow bar to the\n  // next one.\n  EXPECT_EQ(\"// foo bar baz bazfoo\\n\"\n            \"// bar foo bar\\n\",\n            format(\"// foo bar baz      bazfoo bar\\n\"\n                   \"// foo            bar\\n\",\n                   Style));\n\n  EXPECT_EQ(\"// foo bar baz bazfoo\\n\"\n            \"// foo bar baz bazfoo\\n\"\n            \"// bar foo bar\\n\",\n            format(\"// foo bar baz      bazfoo\\n\"\n                   \"// foo bar baz      bazfoo bar\\n\"\n                   \"// foo bar\\n\",\n                   Style));\n\n  EXPECT_EQ(\"// foo bar baz bazfoo\\n\"\n            \"// foo bar baz bazfoo\\n\"\n            \"// bar foo bar\\n\",\n            format(\"// foo bar baz      bazfoo\\n\"\n                   \"// foo bar baz      bazfoo bar\\n\"\n                   \"// foo           bar\\n\",\n                   Style));\n\n  // Make sure we do not keep protruding characters if strict mode reflow is\n  // cheaper than keeping protruding characters.\n  Style.ColumnLimit = 21;\n  EXPECT_EQ(\n      \"// foo foo foo foo\\n\"\n      \"// foo foo foo foo\\n\"\n      \"// foo foo foo foo\\n\",\n      format(\"// foo foo foo foo foo foo foo foo foo foo foo foo\\n\", Style));\n\n  EXPECT_EQ(\"int a = /* long block\\n\"\n            \"           comment */\\n\"\n            \"    42;\",\n            format(\"int a = /* long block comment */ 42;\", Style));\n}\n\n#define EXPECT_ALL_STYLES_EQUAL(Styles)                                        \\\n  for (size_t i = 1; i < Styles.size(); ++i)                                   \\\n  EXPECT_EQ(Styles[0], Styles[i])                                              \\\n      << \"Style #\" << i << \" of \" << Styles.size() << \" differs from Style #0\"\n\nTEST_F(FormatTest, GetsPredefinedStyleByName) {\n  SmallVector<FormatStyle, 3> Styles;\n  Styles.resize(3);\n\n  Styles[0] = getLLVMStyle();\n  EXPECT_TRUE(getPredefinedStyle(\"LLVM\", FormatStyle::LK_Cpp, &Styles[1]));\n  EXPECT_TRUE(getPredefinedStyle(\"lLvM\", FormatStyle::LK_Cpp, &Styles[2]));\n  EXPECT_ALL_STYLES_EQUAL(Styles);\n\n  Styles[0] = getGoogleStyle();\n  EXPECT_TRUE(getPredefinedStyle(\"Google\", FormatStyle::LK_Cpp, &Styles[1]));\n  EXPECT_TRUE(getPredefinedStyle(\"gOOgle\", FormatStyle::LK_Cpp, &Styles[2]));\n  EXPECT_ALL_STYLES_EQUAL(Styles);\n\n  Styles[0] = getGoogleStyle(FormatStyle::LK_JavaScript);\n  EXPECT_TRUE(\n      getPredefinedStyle(\"Google\", FormatStyle::LK_JavaScript, &Styles[1]));\n  EXPECT_TRUE(\n      getPredefinedStyle(\"gOOgle\", FormatStyle::LK_JavaScript, &Styles[2]));\n  EXPECT_ALL_STYLES_EQUAL(Styles);\n\n  Styles[0] = getChromiumStyle(FormatStyle::LK_Cpp);\n  EXPECT_TRUE(getPredefinedStyle(\"Chromium\", FormatStyle::LK_Cpp, &Styles[1]));\n  EXPECT_TRUE(getPredefinedStyle(\"cHRoMiUM\", FormatStyle::LK_Cpp, &Styles[2]));\n  EXPECT_ALL_STYLES_EQUAL(Styles);\n\n  Styles[0] = getMozillaStyle();\n  EXPECT_TRUE(getPredefinedStyle(\"Mozilla\", FormatStyle::LK_Cpp, &Styles[1]));\n  EXPECT_TRUE(getPredefinedStyle(\"moZILla\", FormatStyle::LK_Cpp, &Styles[2]));\n  EXPECT_ALL_STYLES_EQUAL(Styles);\n\n  Styles[0] = getWebKitStyle();\n  EXPECT_TRUE(getPredefinedStyle(\"WebKit\", FormatStyle::LK_Cpp, &Styles[1]));\n  EXPECT_TRUE(getPredefinedStyle(\"wEbKit\", FormatStyle::LK_Cpp, &Styles[2]));\n  EXPECT_ALL_STYLES_EQUAL(Styles);\n\n  Styles[0] = getGNUStyle();\n  EXPECT_TRUE(getPredefinedStyle(\"GNU\", FormatStyle::LK_Cpp, &Styles[1]));\n  EXPECT_TRUE(getPredefinedStyle(\"gnU\", FormatStyle::LK_Cpp, &Styles[2]));\n  EXPECT_ALL_STYLES_EQUAL(Styles);\n\n  EXPECT_FALSE(getPredefinedStyle(\"qwerty\", FormatStyle::LK_Cpp, &Styles[0]));\n}\n\nTEST_F(FormatTest, GetsCorrectBasedOnStyle) {\n  SmallVector<FormatStyle, 8> Styles;\n  Styles.resize(2);\n\n  Styles[0] = getGoogleStyle();\n  Styles[1] = getLLVMStyle();\n  EXPECT_EQ(0, parseConfiguration(\"BasedOnStyle: Google\", &Styles[1]).value());\n  EXPECT_ALL_STYLES_EQUAL(Styles);\n\n  Styles.resize(5);\n  Styles[0] = getGoogleStyle(FormatStyle::LK_JavaScript);\n  Styles[1] = getLLVMStyle();\n  Styles[1].Language = FormatStyle::LK_JavaScript;\n  EXPECT_EQ(0, parseConfiguration(\"BasedOnStyle: Google\", &Styles[1]).value());\n\n  Styles[2] = getLLVMStyle();\n  Styles[2].Language = FormatStyle::LK_JavaScript;\n  EXPECT_EQ(0, parseConfiguration(\"Language: JavaScript\\n\"\n                                  \"BasedOnStyle: Google\",\n                                  &Styles[2])\n                   .value());\n\n  Styles[3] = getLLVMStyle();\n  Styles[3].Language = FormatStyle::LK_JavaScript;\n  EXPECT_EQ(0, parseConfiguration(\"BasedOnStyle: Google\\n\"\n                                  \"Language: JavaScript\",\n                                  &Styles[3])\n                   .value());\n\n  Styles[4] = getLLVMStyle();\n  Styles[4].Language = FormatStyle::LK_JavaScript;\n  EXPECT_EQ(0, parseConfiguration(\"---\\n\"\n                                  \"BasedOnStyle: LLVM\\n\"\n                                  \"IndentWidth: 123\\n\"\n                                  \"---\\n\"\n                                  \"BasedOnStyle: Google\\n\"\n                                  \"Language: JavaScript\",\n                                  &Styles[4])\n                   .value());\n  EXPECT_ALL_STYLES_EQUAL(Styles);\n}\n\n#define CHECK_PARSE_BOOL_FIELD(FIELD, CONFIG_NAME)                             \\\n  Style.FIELD = false;                                                         \\\n  EXPECT_EQ(0, parseConfiguration(CONFIG_NAME \": true\", &Style).value());      \\\n  EXPECT_TRUE(Style.FIELD);                                                    \\\n  EXPECT_EQ(0, parseConfiguration(CONFIG_NAME \": false\", &Style).value());     \\\n  EXPECT_FALSE(Style.FIELD);\n\n#define CHECK_PARSE_BOOL(FIELD) CHECK_PARSE_BOOL_FIELD(FIELD, #FIELD)\n\n#define CHECK_PARSE_NESTED_BOOL_FIELD(STRUCT, FIELD, CONFIG_NAME)              \\\n  Style.STRUCT.FIELD = false;                                                  \\\n  EXPECT_EQ(0,                                                                 \\\n            parseConfiguration(#STRUCT \":\\n  \" CONFIG_NAME \": true\", &Style)   \\\n                .value());                                                     \\\n  EXPECT_TRUE(Style.STRUCT.FIELD);                                             \\\n  EXPECT_EQ(0,                                                                 \\\n            parseConfiguration(#STRUCT \":\\n  \" CONFIG_NAME \": false\", &Style)  \\\n                .value());                                                     \\\n  EXPECT_FALSE(Style.STRUCT.FIELD);\n\n#define CHECK_PARSE_NESTED_BOOL(STRUCT, FIELD)                                 \\\n  CHECK_PARSE_NESTED_BOOL_FIELD(STRUCT, FIELD, #FIELD)\n\n#define CHECK_PARSE(TEXT, FIELD, VALUE)                                        \\\n  EXPECT_NE(VALUE, Style.FIELD) << \"Initial value already the same!\";          \\\n  EXPECT_EQ(0, parseConfiguration(TEXT, &Style).value());                      \\\n  EXPECT_EQ(VALUE, Style.FIELD) << \"Unexpected value after parsing!\"\n\nTEST_F(FormatTest, ParsesConfigurationBools) {\n  FormatStyle Style = {};\n  Style.Language = FormatStyle::LK_Cpp;\n  CHECK_PARSE_BOOL(AlignTrailingComments);\n  CHECK_PARSE_BOOL(AllowAllArgumentsOnNextLine);\n  CHECK_PARSE_BOOL(AllowAllConstructorInitializersOnNextLine);\n  CHECK_PARSE_BOOL(AllowAllParametersOfDeclarationOnNextLine);\n  CHECK_PARSE_BOOL(AllowShortCaseLabelsOnASingleLine);\n  CHECK_PARSE_BOOL(AllowShortEnumsOnASingleLine);\n  CHECK_PARSE_BOOL(AllowShortLoopsOnASingleLine);\n  CHECK_PARSE_BOOL(BinPackArguments);\n  CHECK_PARSE_BOOL(BinPackParameters);\n  CHECK_PARSE_BOOL(BreakAfterJavaFieldAnnotations);\n  CHECK_PARSE_BOOL(BreakBeforeConceptDeclarations);\n  CHECK_PARSE_BOOL(BreakBeforeTernaryOperators);\n  CHECK_PARSE_BOOL(BreakStringLiterals);\n  CHECK_PARSE_BOOL(CompactNamespaces);\n  CHECK_PARSE_BOOL(ConstructorInitializerAllOnOneLineOrOnePerLine);\n  CHECK_PARSE_BOOL(DeriveLineEnding);\n  CHECK_PARSE_BOOL(DerivePointerAlignment);\n  CHECK_PARSE_BOOL_FIELD(DerivePointerAlignment, \"DerivePointerBinding\");\n  CHECK_PARSE_BOOL(DisableFormat);\n  CHECK_PARSE_BOOL(IndentAccessModifiers);\n  CHECK_PARSE_BOOL(IndentCaseLabels);\n  CHECK_PARSE_BOOL(IndentCaseBlocks);\n  CHECK_PARSE_BOOL(IndentGotoLabels);\n  CHECK_PARSE_BOOL(IndentRequires);\n  CHECK_PARSE_BOOL(IndentWrappedFunctionNames);\n  CHECK_PARSE_BOOL(KeepEmptyLinesAtTheStartOfBlocks);\n  CHECK_PARSE_BOOL(ObjCSpaceAfterProperty);\n  CHECK_PARSE_BOOL(ObjCSpaceBeforeProtocolList);\n  CHECK_PARSE_BOOL(Cpp11BracedListStyle);\n  CHECK_PARSE_BOOL(ReflowComments);\n  CHECK_PARSE_BOOL(SortUsingDeclarations);\n  CHECK_PARSE_BOOL(SpacesInParentheses);\n  CHECK_PARSE_BOOL(SpacesInSquareBrackets);\n  CHECK_PARSE_BOOL(SpacesInAngles);\n  CHECK_PARSE_BOOL(SpacesInConditionalStatement);\n  CHECK_PARSE_BOOL(SpaceInEmptyBlock);\n  CHECK_PARSE_BOOL(SpaceInEmptyParentheses);\n  CHECK_PARSE_BOOL(SpacesInContainerLiterals);\n  CHECK_PARSE_BOOL(SpacesInCStyleCastParentheses);\n  CHECK_PARSE_BOOL(SpaceAfterCStyleCast);\n  CHECK_PARSE_BOOL(SpaceAfterTemplateKeyword);\n  CHECK_PARSE_BOOL(SpaceAfterLogicalNot);\n  CHECK_PARSE_BOOL(SpaceBeforeAssignmentOperators);\n  CHECK_PARSE_BOOL(SpaceBeforeCaseColon);\n  CHECK_PARSE_BOOL(SpaceBeforeCpp11BracedList);\n  CHECK_PARSE_BOOL(SpaceBeforeCtorInitializerColon);\n  CHECK_PARSE_BOOL(SpaceBeforeInheritanceColon);\n  CHECK_PARSE_BOOL(SpaceBeforeRangeBasedForLoopColon);\n  CHECK_PARSE_BOOL(SpaceBeforeSquareBrackets);\n  CHECK_PARSE_BOOL(UseCRLF);\n\n  CHECK_PARSE_NESTED_BOOL(BraceWrapping, AfterCaseLabel);\n  CHECK_PARSE_NESTED_BOOL(BraceWrapping, AfterClass);\n  CHECK_PARSE_NESTED_BOOL(BraceWrapping, AfterEnum);\n  CHECK_PARSE_NESTED_BOOL(BraceWrapping, AfterFunction);\n  CHECK_PARSE_NESTED_BOOL(BraceWrapping, AfterNamespace);\n  CHECK_PARSE_NESTED_BOOL(BraceWrapping, AfterObjCDeclaration);\n  CHECK_PARSE_NESTED_BOOL(BraceWrapping, AfterStruct);\n  CHECK_PARSE_NESTED_BOOL(BraceWrapping, AfterUnion);\n  CHECK_PARSE_NESTED_BOOL(BraceWrapping, AfterExternBlock);\n  CHECK_PARSE_NESTED_BOOL(BraceWrapping, BeforeCatch);\n  CHECK_PARSE_NESTED_BOOL(BraceWrapping, BeforeElse);\n  CHECK_PARSE_NESTED_BOOL(BraceWrapping, BeforeLambdaBody);\n  CHECK_PARSE_NESTED_BOOL(BraceWrapping, BeforeWhile);\n  CHECK_PARSE_NESTED_BOOL(BraceWrapping, IndentBraces);\n  CHECK_PARSE_NESTED_BOOL(BraceWrapping, SplitEmptyFunction);\n  CHECK_PARSE_NESTED_BOOL(BraceWrapping, SplitEmptyRecord);\n  CHECK_PARSE_NESTED_BOOL(BraceWrapping, SplitEmptyNamespace);\n}\n\n#undef CHECK_PARSE_BOOL\n\nTEST_F(FormatTest, ParsesConfiguration) {\n  FormatStyle Style = {};\n  Style.Language = FormatStyle::LK_Cpp;\n  CHECK_PARSE(\"AccessModifierOffset: -1234\", AccessModifierOffset, -1234);\n  CHECK_PARSE(\"ConstructorInitializerIndentWidth: 1234\",\n              ConstructorInitializerIndentWidth, 1234u);\n  CHECK_PARSE(\"ObjCBlockIndentWidth: 1234\", ObjCBlockIndentWidth, 1234u);\n  CHECK_PARSE(\"ColumnLimit: 1234\", ColumnLimit, 1234u);\n  CHECK_PARSE(\"MaxEmptyLinesToKeep: 1234\", MaxEmptyLinesToKeep, 1234u);\n  CHECK_PARSE(\"PenaltyBreakAssignment: 1234\", PenaltyBreakAssignment, 1234u);\n  CHECK_PARSE(\"PenaltyBreakBeforeFirstCallParameter: 1234\",\n              PenaltyBreakBeforeFirstCallParameter, 1234u);\n  CHECK_PARSE(\"PenaltyBreakTemplateDeclaration: 1234\",\n              PenaltyBreakTemplateDeclaration, 1234u);\n  CHECK_PARSE(\"PenaltyExcessCharacter: 1234\", PenaltyExcessCharacter, 1234u);\n  CHECK_PARSE(\"PenaltyReturnTypeOnItsOwnLine: 1234\",\n              PenaltyReturnTypeOnItsOwnLine, 1234u);\n  CHECK_PARSE(\"SpacesBeforeTrailingComments: 1234\",\n              SpacesBeforeTrailingComments, 1234u);\n  CHECK_PARSE(\"IndentWidth: 32\", IndentWidth, 32u);\n  CHECK_PARSE(\"ContinuationIndentWidth: 11\", ContinuationIndentWidth, 11u);\n  CHECK_PARSE(\"CommentPragmas: '// abc$'\", CommentPragmas, \"// abc$\");\n\n  Style.AlignConsecutiveAssignments = FormatStyle::ACS_Consecutive;\n  CHECK_PARSE(\"AlignConsecutiveAssignments: None\", AlignConsecutiveAssignments,\n              FormatStyle::ACS_None);\n  CHECK_PARSE(\"AlignConsecutiveAssignments: Consecutive\",\n              AlignConsecutiveAssignments, FormatStyle::ACS_Consecutive);\n  CHECK_PARSE(\"AlignConsecutiveAssignments: AcrossEmptyLines\",\n              AlignConsecutiveAssignments, FormatStyle::ACS_AcrossEmptyLines);\n  CHECK_PARSE(\"AlignConsecutiveAssignments: AcrossEmptyLinesAndComments\",\n              AlignConsecutiveAssignments,\n              FormatStyle::ACS_AcrossEmptyLinesAndComments);\n  // For backwards compability, false / true should still parse\n  CHECK_PARSE(\"AlignConsecutiveAssignments: false\", AlignConsecutiveAssignments,\n              FormatStyle::ACS_None);\n  CHECK_PARSE(\"AlignConsecutiveAssignments: true\", AlignConsecutiveAssignments,\n              FormatStyle::ACS_Consecutive);\n\n  Style.AlignConsecutiveBitFields = FormatStyle::ACS_Consecutive;\n  CHECK_PARSE(\"AlignConsecutiveBitFields: None\", AlignConsecutiveBitFields,\n              FormatStyle::ACS_None);\n  CHECK_PARSE(\"AlignConsecutiveBitFields: Consecutive\",\n              AlignConsecutiveBitFields, FormatStyle::ACS_Consecutive);\n  CHECK_PARSE(\"AlignConsecutiveBitFields: AcrossEmptyLines\",\n              AlignConsecutiveBitFields, FormatStyle::ACS_AcrossEmptyLines);\n  CHECK_PARSE(\"AlignConsecutiveBitFields: AcrossEmptyLinesAndComments\",\n              AlignConsecutiveBitFields,\n              FormatStyle::ACS_AcrossEmptyLinesAndComments);\n  // For backwards compability, false / true should still parse\n  CHECK_PARSE(\"AlignConsecutiveBitFields: false\", AlignConsecutiveBitFields,\n              FormatStyle::ACS_None);\n  CHECK_PARSE(\"AlignConsecutiveBitFields: true\", AlignConsecutiveBitFields,\n              FormatStyle::ACS_Consecutive);\n\n  Style.AlignConsecutiveMacros = FormatStyle::ACS_Consecutive;\n  CHECK_PARSE(\"AlignConsecutiveMacros: None\", AlignConsecutiveMacros,\n              FormatStyle::ACS_None);\n  CHECK_PARSE(\"AlignConsecutiveMacros: Consecutive\", AlignConsecutiveMacros,\n              FormatStyle::ACS_Consecutive);\n  CHECK_PARSE(\"AlignConsecutiveMacros: AcrossEmptyLines\",\n              AlignConsecutiveMacros, FormatStyle::ACS_AcrossEmptyLines);\n  CHECK_PARSE(\"AlignConsecutiveMacros: AcrossEmptyLinesAndComments\",\n              AlignConsecutiveMacros,\n              FormatStyle::ACS_AcrossEmptyLinesAndComments);\n  // For backwards compability, false / true should still parse\n  CHECK_PARSE(\"AlignConsecutiveMacros: false\", AlignConsecutiveMacros,\n              FormatStyle::ACS_None);\n  CHECK_PARSE(\"AlignConsecutiveMacros: true\", AlignConsecutiveMacros,\n              FormatStyle::ACS_Consecutive);\n\n  Style.AlignConsecutiveDeclarations = FormatStyle::ACS_Consecutive;\n  CHECK_PARSE(\"AlignConsecutiveDeclarations: None\",\n              AlignConsecutiveDeclarations, FormatStyle::ACS_None);\n  CHECK_PARSE(\"AlignConsecutiveDeclarations: Consecutive\",\n              AlignConsecutiveDeclarations, FormatStyle::ACS_Consecutive);\n  CHECK_PARSE(\"AlignConsecutiveDeclarations: AcrossEmptyLines\",\n              AlignConsecutiveDeclarations, FormatStyle::ACS_AcrossEmptyLines);\n  CHECK_PARSE(\"AlignConsecutiveDeclarations: AcrossEmptyLinesAndComments\",\n              AlignConsecutiveDeclarations,\n              FormatStyle::ACS_AcrossEmptyLinesAndComments);\n  // For backwards compability, false / true should still parse\n  CHECK_PARSE(\"AlignConsecutiveDeclarations: false\",\n              AlignConsecutiveDeclarations, FormatStyle::ACS_None);\n  CHECK_PARSE(\"AlignConsecutiveDeclarations: true\",\n              AlignConsecutiveDeclarations, FormatStyle::ACS_Consecutive);\n\n  Style.PointerAlignment = FormatStyle::PAS_Middle;\n  CHECK_PARSE(\"PointerAlignment: Left\", PointerAlignment,\n              FormatStyle::PAS_Left);\n  CHECK_PARSE(\"PointerAlignment: Right\", PointerAlignment,\n              FormatStyle::PAS_Right);\n  CHECK_PARSE(\"PointerAlignment: Middle\", PointerAlignment,\n              FormatStyle::PAS_Middle);\n  // For backward compatibility:\n  CHECK_PARSE(\"PointerBindsToType: Left\", PointerAlignment,\n              FormatStyle::PAS_Left);\n  CHECK_PARSE(\"PointerBindsToType: Right\", PointerAlignment,\n              FormatStyle::PAS_Right);\n  CHECK_PARSE(\"PointerBindsToType: Middle\", PointerAlignment,\n              FormatStyle::PAS_Middle);\n\n  Style.Standard = FormatStyle::LS_Auto;\n  CHECK_PARSE(\"Standard: c++03\", Standard, FormatStyle::LS_Cpp03);\n  CHECK_PARSE(\"Standard: c++11\", Standard, FormatStyle::LS_Cpp11);\n  CHECK_PARSE(\"Standard: c++14\", Standard, FormatStyle::LS_Cpp14);\n  CHECK_PARSE(\"Standard: c++17\", Standard, FormatStyle::LS_Cpp17);\n  CHECK_PARSE(\"Standard: c++20\", Standard, FormatStyle::LS_Cpp20);\n  CHECK_PARSE(\"Standard: Auto\", Standard, FormatStyle::LS_Auto);\n  CHECK_PARSE(\"Standard: Latest\", Standard, FormatStyle::LS_Latest);\n  // Legacy aliases:\n  CHECK_PARSE(\"Standard: Cpp03\", Standard, FormatStyle::LS_Cpp03);\n  CHECK_PARSE(\"Standard: Cpp11\", Standard, FormatStyle::LS_Latest);\n  CHECK_PARSE(\"Standard: C++03\", Standard, FormatStyle::LS_Cpp03);\n  CHECK_PARSE(\"Standard: C++11\", Standard, FormatStyle::LS_Cpp11);\n\n  Style.BreakBeforeBinaryOperators = FormatStyle::BOS_All;\n  CHECK_PARSE(\"BreakBeforeBinaryOperators: NonAssignment\",\n              BreakBeforeBinaryOperators, FormatStyle::BOS_NonAssignment);\n  CHECK_PARSE(\"BreakBeforeBinaryOperators: None\", BreakBeforeBinaryOperators,\n              FormatStyle::BOS_None);\n  CHECK_PARSE(\"BreakBeforeBinaryOperators: All\", BreakBeforeBinaryOperators,\n              FormatStyle::BOS_All);\n  // For backward compatibility:\n  CHECK_PARSE(\"BreakBeforeBinaryOperators: false\", BreakBeforeBinaryOperators,\n              FormatStyle::BOS_None);\n  CHECK_PARSE(\"BreakBeforeBinaryOperators: true\", BreakBeforeBinaryOperators,\n              FormatStyle::BOS_All);\n\n  Style.BreakConstructorInitializers = FormatStyle::BCIS_BeforeColon;\n  CHECK_PARSE(\"BreakConstructorInitializers: BeforeComma\",\n              BreakConstructorInitializers, FormatStyle::BCIS_BeforeComma);\n  CHECK_PARSE(\"BreakConstructorInitializers: AfterColon\",\n              BreakConstructorInitializers, FormatStyle::BCIS_AfterColon);\n  CHECK_PARSE(\"BreakConstructorInitializers: BeforeColon\",\n              BreakConstructorInitializers, FormatStyle::BCIS_BeforeColon);\n  // For backward compatibility:\n  CHECK_PARSE(\"BreakConstructorInitializersBeforeComma: true\",\n              BreakConstructorInitializers, FormatStyle::BCIS_BeforeComma);\n\n  Style.BreakInheritanceList = FormatStyle::BILS_BeforeColon;\n  CHECK_PARSE(\"BreakInheritanceList: BeforeComma\", BreakInheritanceList,\n              FormatStyle::BILS_BeforeComma);\n  CHECK_PARSE(\"BreakInheritanceList: AfterColon\", BreakInheritanceList,\n              FormatStyle::BILS_AfterColon);\n  CHECK_PARSE(\"BreakInheritanceList: BeforeColon\", BreakInheritanceList,\n              FormatStyle::BILS_BeforeColon);\n  // For backward compatibility:\n  CHECK_PARSE(\"BreakBeforeInheritanceComma: true\", BreakInheritanceList,\n              FormatStyle::BILS_BeforeComma);\n\n  Style.EmptyLineBeforeAccessModifier = FormatStyle::ELBAMS_LogicalBlock;\n  CHECK_PARSE(\"EmptyLineBeforeAccessModifier: Never\",\n              EmptyLineBeforeAccessModifier, FormatStyle::ELBAMS_Never);\n  CHECK_PARSE(\"EmptyLineBeforeAccessModifier: Leave\",\n              EmptyLineBeforeAccessModifier, FormatStyle::ELBAMS_Leave);\n  CHECK_PARSE(\"EmptyLineBeforeAccessModifier: LogicalBlock\",\n              EmptyLineBeforeAccessModifier, FormatStyle::ELBAMS_LogicalBlock);\n  CHECK_PARSE(\"EmptyLineBeforeAccessModifier: Always\",\n              EmptyLineBeforeAccessModifier, FormatStyle::ELBAMS_Always);\n\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_AlwaysBreak;\n  CHECK_PARSE(\"AlignAfterOpenBracket: Align\", AlignAfterOpenBracket,\n              FormatStyle::BAS_Align);\n  CHECK_PARSE(\"AlignAfterOpenBracket: DontAlign\", AlignAfterOpenBracket,\n              FormatStyle::BAS_DontAlign);\n  CHECK_PARSE(\"AlignAfterOpenBracket: AlwaysBreak\", AlignAfterOpenBracket,\n              FormatStyle::BAS_AlwaysBreak);\n  // For backward compatibility:\n  CHECK_PARSE(\"AlignAfterOpenBracket: false\", AlignAfterOpenBracket,\n              FormatStyle::BAS_DontAlign);\n  CHECK_PARSE(\"AlignAfterOpenBracket: true\", AlignAfterOpenBracket,\n              FormatStyle::BAS_Align);\n\n  Style.AlignEscapedNewlines = FormatStyle::ENAS_Left;\n  CHECK_PARSE(\"AlignEscapedNewlines: DontAlign\", AlignEscapedNewlines,\n              FormatStyle::ENAS_DontAlign);\n  CHECK_PARSE(\"AlignEscapedNewlines: Left\", AlignEscapedNewlines,\n              FormatStyle::ENAS_Left);\n  CHECK_PARSE(\"AlignEscapedNewlines: Right\", AlignEscapedNewlines,\n              FormatStyle::ENAS_Right);\n  // For backward compatibility:\n  CHECK_PARSE(\"AlignEscapedNewlinesLeft: true\", AlignEscapedNewlines,\n              FormatStyle::ENAS_Left);\n  CHECK_PARSE(\"AlignEscapedNewlinesLeft: false\", AlignEscapedNewlines,\n              FormatStyle::ENAS_Right);\n\n  Style.AlignOperands = FormatStyle::OAS_Align;\n  CHECK_PARSE(\"AlignOperands: DontAlign\", AlignOperands,\n              FormatStyle::OAS_DontAlign);\n  CHECK_PARSE(\"AlignOperands: Align\", AlignOperands, FormatStyle::OAS_Align);\n  CHECK_PARSE(\"AlignOperands: AlignAfterOperator\", AlignOperands,\n              FormatStyle::OAS_AlignAfterOperator);\n  // For backward compatibility:\n  CHECK_PARSE(\"AlignOperands: false\", AlignOperands,\n              FormatStyle::OAS_DontAlign);\n  CHECK_PARSE(\"AlignOperands: true\", AlignOperands, FormatStyle::OAS_Align);\n\n  Style.UseTab = FormatStyle::UT_ForIndentation;\n  CHECK_PARSE(\"UseTab: Never\", UseTab, FormatStyle::UT_Never);\n  CHECK_PARSE(\"UseTab: ForIndentation\", UseTab, FormatStyle::UT_ForIndentation);\n  CHECK_PARSE(\"UseTab: Always\", UseTab, FormatStyle::UT_Always);\n  CHECK_PARSE(\"UseTab: ForContinuationAndIndentation\", UseTab,\n              FormatStyle::UT_ForContinuationAndIndentation);\n  CHECK_PARSE(\"UseTab: AlignWithSpaces\", UseTab,\n              FormatStyle::UT_AlignWithSpaces);\n  // For backward compatibility:\n  CHECK_PARSE(\"UseTab: false\", UseTab, FormatStyle::UT_Never);\n  CHECK_PARSE(\"UseTab: true\", UseTab, FormatStyle::UT_Always);\n\n  Style.AllowShortBlocksOnASingleLine = FormatStyle::SBS_Empty;\n  CHECK_PARSE(\"AllowShortBlocksOnASingleLine: Never\",\n              AllowShortBlocksOnASingleLine, FormatStyle::SBS_Never);\n  CHECK_PARSE(\"AllowShortBlocksOnASingleLine: Empty\",\n              AllowShortBlocksOnASingleLine, FormatStyle::SBS_Empty);\n  CHECK_PARSE(\"AllowShortBlocksOnASingleLine: Always\",\n              AllowShortBlocksOnASingleLine, FormatStyle::SBS_Always);\n  // For backward compatibility:\n  CHECK_PARSE(\"AllowShortBlocksOnASingleLine: false\",\n              AllowShortBlocksOnASingleLine, FormatStyle::SBS_Never);\n  CHECK_PARSE(\"AllowShortBlocksOnASingleLine: true\",\n              AllowShortBlocksOnASingleLine, FormatStyle::SBS_Always);\n\n  Style.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_Inline;\n  CHECK_PARSE(\"AllowShortFunctionsOnASingleLine: None\",\n              AllowShortFunctionsOnASingleLine, FormatStyle::SFS_None);\n  CHECK_PARSE(\"AllowShortFunctionsOnASingleLine: Inline\",\n              AllowShortFunctionsOnASingleLine, FormatStyle::SFS_Inline);\n  CHECK_PARSE(\"AllowShortFunctionsOnASingleLine: Empty\",\n              AllowShortFunctionsOnASingleLine, FormatStyle::SFS_Empty);\n  CHECK_PARSE(\"AllowShortFunctionsOnASingleLine: All\",\n              AllowShortFunctionsOnASingleLine, FormatStyle::SFS_All);\n  // For backward compatibility:\n  CHECK_PARSE(\"AllowShortFunctionsOnASingleLine: false\",\n              AllowShortFunctionsOnASingleLine, FormatStyle::SFS_None);\n  CHECK_PARSE(\"AllowShortFunctionsOnASingleLine: true\",\n              AllowShortFunctionsOnASingleLine, FormatStyle::SFS_All);\n\n  Style.SpaceAroundPointerQualifiers = FormatStyle::SAPQ_Both;\n  CHECK_PARSE(\"SpaceAroundPointerQualifiers: Default\",\n              SpaceAroundPointerQualifiers, FormatStyle::SAPQ_Default);\n  CHECK_PARSE(\"SpaceAroundPointerQualifiers: Before\",\n              SpaceAroundPointerQualifiers, FormatStyle::SAPQ_Before);\n  CHECK_PARSE(\"SpaceAroundPointerQualifiers: After\",\n              SpaceAroundPointerQualifiers, FormatStyle::SAPQ_After);\n  CHECK_PARSE(\"SpaceAroundPointerQualifiers: Both\",\n              SpaceAroundPointerQualifiers, FormatStyle::SAPQ_Both);\n\n  Style.SpaceBeforeParens = FormatStyle::SBPO_Always;\n  CHECK_PARSE(\"SpaceBeforeParens: Never\", SpaceBeforeParens,\n              FormatStyle::SBPO_Never);\n  CHECK_PARSE(\"SpaceBeforeParens: Always\", SpaceBeforeParens,\n              FormatStyle::SBPO_Always);\n  CHECK_PARSE(\"SpaceBeforeParens: ControlStatements\", SpaceBeforeParens,\n              FormatStyle::SBPO_ControlStatements);\n  CHECK_PARSE(\"SpaceBeforeParens: NonEmptyParentheses\", SpaceBeforeParens,\n              FormatStyle::SBPO_NonEmptyParentheses);\n  // For backward compatibility:\n  CHECK_PARSE(\"SpaceAfterControlStatementKeyword: false\", SpaceBeforeParens,\n              FormatStyle::SBPO_Never);\n  CHECK_PARSE(\"SpaceAfterControlStatementKeyword: true\", SpaceBeforeParens,\n              FormatStyle::SBPO_ControlStatements);\n\n  Style.ColumnLimit = 123;\n  FormatStyle BaseStyle = getLLVMStyle();\n  CHECK_PARSE(\"BasedOnStyle: LLVM\", ColumnLimit, BaseStyle.ColumnLimit);\n  CHECK_PARSE(\"BasedOnStyle: LLVM\\nColumnLimit: 1234\", ColumnLimit, 1234u);\n\n  Style.BreakBeforeBraces = FormatStyle::BS_Stroustrup;\n  CHECK_PARSE(\"BreakBeforeBraces: Attach\", BreakBeforeBraces,\n              FormatStyle::BS_Attach);\n  CHECK_PARSE(\"BreakBeforeBraces: Linux\", BreakBeforeBraces,\n              FormatStyle::BS_Linux);\n  CHECK_PARSE(\"BreakBeforeBraces: Mozilla\", BreakBeforeBraces,\n              FormatStyle::BS_Mozilla);\n  CHECK_PARSE(\"BreakBeforeBraces: Stroustrup\", BreakBeforeBraces,\n              FormatStyle::BS_Stroustrup);\n  CHECK_PARSE(\"BreakBeforeBraces: Allman\", BreakBeforeBraces,\n              FormatStyle::BS_Allman);\n  CHECK_PARSE(\"BreakBeforeBraces: Whitesmiths\", BreakBeforeBraces,\n              FormatStyle::BS_Whitesmiths);\n  CHECK_PARSE(\"BreakBeforeBraces: GNU\", BreakBeforeBraces, FormatStyle::BS_GNU);\n  CHECK_PARSE(\"BreakBeforeBraces: WebKit\", BreakBeforeBraces,\n              FormatStyle::BS_WebKit);\n  CHECK_PARSE(\"BreakBeforeBraces: Custom\", BreakBeforeBraces,\n              FormatStyle::BS_Custom);\n\n  Style.BraceWrapping.AfterControlStatement = FormatStyle::BWACS_Never;\n  CHECK_PARSE(\"BraceWrapping:\\n\"\n              \"  AfterControlStatement: MultiLine\",\n              BraceWrapping.AfterControlStatement,\n              FormatStyle::BWACS_MultiLine);\n  CHECK_PARSE(\"BraceWrapping:\\n\"\n              \"  AfterControlStatement: Always\",\n              BraceWrapping.AfterControlStatement, FormatStyle::BWACS_Always);\n  CHECK_PARSE(\"BraceWrapping:\\n\"\n              \"  AfterControlStatement: Never\",\n              BraceWrapping.AfterControlStatement, FormatStyle::BWACS_Never);\n  // For backward compatibility:\n  CHECK_PARSE(\"BraceWrapping:\\n\"\n              \"  AfterControlStatement: true\",\n              BraceWrapping.AfterControlStatement, FormatStyle::BWACS_Always);\n  CHECK_PARSE(\"BraceWrapping:\\n\"\n              \"  AfterControlStatement: false\",\n              BraceWrapping.AfterControlStatement, FormatStyle::BWACS_Never);\n\n  Style.AlwaysBreakAfterReturnType = FormatStyle::RTBS_All;\n  CHECK_PARSE(\"AlwaysBreakAfterReturnType: None\", AlwaysBreakAfterReturnType,\n              FormatStyle::RTBS_None);\n  CHECK_PARSE(\"AlwaysBreakAfterReturnType: All\", AlwaysBreakAfterReturnType,\n              FormatStyle::RTBS_All);\n  CHECK_PARSE(\"AlwaysBreakAfterReturnType: TopLevel\",\n              AlwaysBreakAfterReturnType, FormatStyle::RTBS_TopLevel);\n  CHECK_PARSE(\"AlwaysBreakAfterReturnType: AllDefinitions\",\n              AlwaysBreakAfterReturnType, FormatStyle::RTBS_AllDefinitions);\n  CHECK_PARSE(\"AlwaysBreakAfterReturnType: TopLevelDefinitions\",\n              AlwaysBreakAfterReturnType,\n              FormatStyle::RTBS_TopLevelDefinitions);\n\n  Style.AlwaysBreakTemplateDeclarations = FormatStyle::BTDS_Yes;\n  CHECK_PARSE(\"AlwaysBreakTemplateDeclarations: No\",\n              AlwaysBreakTemplateDeclarations, FormatStyle::BTDS_No);\n  CHECK_PARSE(\"AlwaysBreakTemplateDeclarations: MultiLine\",\n              AlwaysBreakTemplateDeclarations, FormatStyle::BTDS_MultiLine);\n  CHECK_PARSE(\"AlwaysBreakTemplateDeclarations: Yes\",\n              AlwaysBreakTemplateDeclarations, FormatStyle::BTDS_Yes);\n  CHECK_PARSE(\"AlwaysBreakTemplateDeclarations: false\",\n              AlwaysBreakTemplateDeclarations, FormatStyle::BTDS_MultiLine);\n  CHECK_PARSE(\"AlwaysBreakTemplateDeclarations: true\",\n              AlwaysBreakTemplateDeclarations, FormatStyle::BTDS_Yes);\n\n  Style.AlwaysBreakAfterDefinitionReturnType = FormatStyle::DRTBS_All;\n  CHECK_PARSE(\"AlwaysBreakAfterDefinitionReturnType: None\",\n              AlwaysBreakAfterDefinitionReturnType, FormatStyle::DRTBS_None);\n  CHECK_PARSE(\"AlwaysBreakAfterDefinitionReturnType: All\",\n              AlwaysBreakAfterDefinitionReturnType, FormatStyle::DRTBS_All);\n  CHECK_PARSE(\"AlwaysBreakAfterDefinitionReturnType: TopLevel\",\n              AlwaysBreakAfterDefinitionReturnType,\n              FormatStyle::DRTBS_TopLevel);\n\n  Style.NamespaceIndentation = FormatStyle::NI_All;\n  CHECK_PARSE(\"NamespaceIndentation: None\", NamespaceIndentation,\n              FormatStyle::NI_None);\n  CHECK_PARSE(\"NamespaceIndentation: Inner\", NamespaceIndentation,\n              FormatStyle::NI_Inner);\n  CHECK_PARSE(\"NamespaceIndentation: All\", NamespaceIndentation,\n              FormatStyle::NI_All);\n\n  Style.AllowShortIfStatementsOnASingleLine = FormatStyle::SIS_Always;\n  CHECK_PARSE(\"AllowShortIfStatementsOnASingleLine: Never\",\n              AllowShortIfStatementsOnASingleLine, FormatStyle::SIS_Never);\n  CHECK_PARSE(\"AllowShortIfStatementsOnASingleLine: WithoutElse\",\n              AllowShortIfStatementsOnASingleLine,\n              FormatStyle::SIS_WithoutElse);\n  CHECK_PARSE(\"AllowShortIfStatementsOnASingleLine: Always\",\n              AllowShortIfStatementsOnASingleLine, FormatStyle::SIS_Always);\n  CHECK_PARSE(\"AllowShortIfStatementsOnASingleLine: false\",\n              AllowShortIfStatementsOnASingleLine, FormatStyle::SIS_Never);\n  CHECK_PARSE(\"AllowShortIfStatementsOnASingleLine: true\",\n              AllowShortIfStatementsOnASingleLine,\n              FormatStyle::SIS_WithoutElse);\n\n  Style.IndentExternBlock = FormatStyle::IEBS_NoIndent;\n  CHECK_PARSE(\"IndentExternBlock: AfterExternBlock\", IndentExternBlock,\n              FormatStyle::IEBS_AfterExternBlock);\n  CHECK_PARSE(\"IndentExternBlock: Indent\", IndentExternBlock,\n              FormatStyle::IEBS_Indent);\n  CHECK_PARSE(\"IndentExternBlock: NoIndent\", IndentExternBlock,\n              FormatStyle::IEBS_NoIndent);\n  CHECK_PARSE(\"IndentExternBlock: true\", IndentExternBlock,\n              FormatStyle::IEBS_Indent);\n  CHECK_PARSE(\"IndentExternBlock: false\", IndentExternBlock,\n              FormatStyle::IEBS_NoIndent);\n\n  Style.BitFieldColonSpacing = FormatStyle::BFCS_None;\n  CHECK_PARSE(\"BitFieldColonSpacing: Both\", BitFieldColonSpacing,\n              FormatStyle::BFCS_Both);\n  CHECK_PARSE(\"BitFieldColonSpacing: None\", BitFieldColonSpacing,\n              FormatStyle::BFCS_None);\n  CHECK_PARSE(\"BitFieldColonSpacing: Before\", BitFieldColonSpacing,\n              FormatStyle::BFCS_Before);\n  CHECK_PARSE(\"BitFieldColonSpacing: After\", BitFieldColonSpacing,\n              FormatStyle::BFCS_After);\n\n  Style.SortJavaStaticImport = FormatStyle::SJSIO_Before;\n  CHECK_PARSE(\"SortJavaStaticImport: After\", SortJavaStaticImport,\n              FormatStyle::SJSIO_After);\n  CHECK_PARSE(\"SortJavaStaticImport: Before\", SortJavaStaticImport,\n              FormatStyle::SJSIO_Before);\n\n  // FIXME: This is required because parsing a configuration simply overwrites\n  // the first N elements of the list instead of resetting it.\n  Style.ForEachMacros.clear();\n  std::vector<std::string> BoostForeach;\n  BoostForeach.push_back(\"BOOST_FOREACH\");\n  CHECK_PARSE(\"ForEachMacros: [BOOST_FOREACH]\", ForEachMacros, BoostForeach);\n  std::vector<std::string> BoostAndQForeach;\n  BoostAndQForeach.push_back(\"BOOST_FOREACH\");\n  BoostAndQForeach.push_back(\"Q_FOREACH\");\n  CHECK_PARSE(\"ForEachMacros: [BOOST_FOREACH, Q_FOREACH]\", ForEachMacros,\n              BoostAndQForeach);\n\n  Style.AttributeMacros.clear();\n  CHECK_PARSE(\"BasedOnStyle: LLVM\", AttributeMacros,\n              std::vector<std::string>{\"__capability\"});\n  CHECK_PARSE(\"AttributeMacros: [attr1, attr2]\", AttributeMacros,\n              std::vector<std::string>({\"attr1\", \"attr2\"}));\n\n  Style.StatementAttributeLikeMacros.clear();\n  CHECK_PARSE(\"StatementAttributeLikeMacros: [emit,Q_EMIT]\",\n              StatementAttributeLikeMacros,\n              std::vector<std::string>({\"emit\", \"Q_EMIT\"}));\n\n  Style.StatementMacros.clear();\n  CHECK_PARSE(\"StatementMacros: [QUNUSED]\", StatementMacros,\n              std::vector<std::string>{\"QUNUSED\"});\n  CHECK_PARSE(\"StatementMacros: [QUNUSED, QT_REQUIRE_VERSION]\", StatementMacros,\n              std::vector<std::string>({\"QUNUSED\", \"QT_REQUIRE_VERSION\"}));\n\n  Style.NamespaceMacros.clear();\n  CHECK_PARSE(\"NamespaceMacros: [TESTSUITE]\", NamespaceMacros,\n              std::vector<std::string>{\"TESTSUITE\"});\n  CHECK_PARSE(\"NamespaceMacros: [TESTSUITE, SUITE]\", NamespaceMacros,\n              std::vector<std::string>({\"TESTSUITE\", \"SUITE\"}));\n\n  Style.WhitespaceSensitiveMacros.clear();\n  CHECK_PARSE(\"WhitespaceSensitiveMacros: [STRINGIZE]\",\n              WhitespaceSensitiveMacros, std::vector<std::string>{\"STRINGIZE\"});\n  CHECK_PARSE(\"WhitespaceSensitiveMacros: [STRINGIZE, ASSERT]\",\n              WhitespaceSensitiveMacros,\n              std::vector<std::string>({\"STRINGIZE\", \"ASSERT\"}));\n  Style.WhitespaceSensitiveMacros.clear();\n  CHECK_PARSE(\"WhitespaceSensitiveMacros: ['STRINGIZE']\",\n              WhitespaceSensitiveMacros, std::vector<std::string>{\"STRINGIZE\"});\n  CHECK_PARSE(\"WhitespaceSensitiveMacros: ['STRINGIZE', 'ASSERT']\",\n              WhitespaceSensitiveMacros,\n              std::vector<std::string>({\"STRINGIZE\", \"ASSERT\"}));\n\n  Style.IncludeStyle.IncludeCategories.clear();\n  std::vector<tooling::IncludeStyle::IncludeCategory> ExpectedCategories = {\n      {\"abc/.*\", 2, 0, false}, {\".*\", 1, 0, true}};\n  CHECK_PARSE(\"IncludeCategories:\\n\"\n              \"  - Regex: abc/.*\\n\"\n              \"    Priority: 2\\n\"\n              \"  - Regex: .*\\n\"\n              \"    Priority: 1\\n\"\n              \"    CaseSensitive: true\\n\",\n              IncludeStyle.IncludeCategories, ExpectedCategories);\n  CHECK_PARSE(\"IncludeIsMainRegex: 'abc$'\", IncludeStyle.IncludeIsMainRegex,\n              \"abc$\");\n  CHECK_PARSE(\"IncludeIsMainSourceRegex: 'abc$'\",\n              IncludeStyle.IncludeIsMainSourceRegex, \"abc$\");\n\n  Style.SortIncludes = FormatStyle::SI_Never;\n  CHECK_PARSE(\"SortIncludes: true\", SortIncludes,\n              FormatStyle::SI_CaseSensitive);\n  CHECK_PARSE(\"SortIncludes: false\", SortIncludes, FormatStyle::SI_Never);\n  CHECK_PARSE(\"SortIncludes: CaseInsensitive\", SortIncludes,\n              FormatStyle::SI_CaseInsensitive);\n  CHECK_PARSE(\"SortIncludes: CaseSensitive\", SortIncludes,\n              FormatStyle::SI_CaseSensitive);\n  CHECK_PARSE(\"SortIncludes: Never\", SortIncludes, FormatStyle::SI_Never);\n\n  Style.RawStringFormats.clear();\n  std::vector<FormatStyle::RawStringFormat> ExpectedRawStringFormats = {\n      {\n          FormatStyle::LK_TextProto,\n          {\"pb\", \"proto\"},\n          {\"PARSE_TEXT_PROTO\"},\n          /*CanonicalDelimiter=*/\"\",\n          \"llvm\",\n      },\n      {\n          FormatStyle::LK_Cpp,\n          {\"cc\", \"cpp\"},\n          {\"C_CODEBLOCK\", \"CPPEVAL\"},\n          /*CanonicalDelimiter=*/\"cc\",\n          /*BasedOnStyle=*/\"\",\n      },\n  };\n\n  CHECK_PARSE(\"RawStringFormats:\\n\"\n              \"  - Language: TextProto\\n\"\n              \"    Delimiters:\\n\"\n              \"      - 'pb'\\n\"\n              \"      - 'proto'\\n\"\n              \"    EnclosingFunctions:\\n\"\n              \"      - 'PARSE_TEXT_PROTO'\\n\"\n              \"    BasedOnStyle: llvm\\n\"\n              \"  - Language: Cpp\\n\"\n              \"    Delimiters:\\n\"\n              \"      - 'cc'\\n\"\n              \"      - 'cpp'\\n\"\n              \"    EnclosingFunctions:\\n\"\n              \"      - 'C_CODEBLOCK'\\n\"\n              \"      - 'CPPEVAL'\\n\"\n              \"    CanonicalDelimiter: 'cc'\",\n              RawStringFormats, ExpectedRawStringFormats);\n\n  CHECK_PARSE(\"SpacesInLineCommentPrefix:\\n\"\n              \"  Minimum: 0\\n\"\n              \"  Maximum: 0\",\n              SpacesInLineCommentPrefix.Minimum, 0u);\n  EXPECT_EQ(Style.SpacesInLineCommentPrefix.Maximum, 0u);\n  Style.SpacesInLineCommentPrefix.Minimum = 1;\n  CHECK_PARSE(\"SpacesInLineCommentPrefix:\\n\"\n              \"  Minimum: 2\",\n              SpacesInLineCommentPrefix.Minimum, 0u);\n  CHECK_PARSE(\"SpacesInLineCommentPrefix:\\n\"\n              \"  Maximum: -1\",\n              SpacesInLineCommentPrefix.Maximum, -1u);\n  CHECK_PARSE(\"SpacesInLineCommentPrefix:\\n\"\n              \"  Minimum: 2\",\n              SpacesInLineCommentPrefix.Minimum, 2u);\n  CHECK_PARSE(\"SpacesInLineCommentPrefix:\\n\"\n              \"  Maximum: 1\",\n              SpacesInLineCommentPrefix.Maximum, 1u);\n  EXPECT_EQ(Style.SpacesInLineCommentPrefix.Minimum, 1u);\n}\n\nTEST_F(FormatTest, ParsesConfigurationWithLanguages) {\n  FormatStyle Style = {};\n  Style.Language = FormatStyle::LK_Cpp;\n  CHECK_PARSE(\"Language: Cpp\\n\"\n              \"IndentWidth: 12\",\n              IndentWidth, 12u);\n  EXPECT_EQ(parseConfiguration(\"Language: JavaScript\\n\"\n                               \"IndentWidth: 34\",\n                               &Style),\n            ParseError::Unsuitable);\n  FormatStyle BinPackedTCS = {};\n  BinPackedTCS.Language = FormatStyle::LK_JavaScript;\n  EXPECT_EQ(parseConfiguration(\"BinPackArguments: true\\n\"\n                               \"InsertTrailingCommas: Wrapped\",\n                               &BinPackedTCS),\n            ParseError::BinPackTrailingCommaConflict);\n  EXPECT_EQ(12u, Style.IndentWidth);\n  CHECK_PARSE(\"IndentWidth: 56\", IndentWidth, 56u);\n  EXPECT_EQ(FormatStyle::LK_Cpp, Style.Language);\n\n  Style.Language = FormatStyle::LK_JavaScript;\n  CHECK_PARSE(\"Language: JavaScript\\n\"\n              \"IndentWidth: 12\",\n              IndentWidth, 12u);\n  CHECK_PARSE(\"IndentWidth: 23\", IndentWidth, 23u);\n  EXPECT_EQ(parseConfiguration(\"Language: Cpp\\n\"\n                               \"IndentWidth: 34\",\n                               &Style),\n            ParseError::Unsuitable);\n  EXPECT_EQ(23u, Style.IndentWidth);\n  CHECK_PARSE(\"IndentWidth: 56\", IndentWidth, 56u);\n  EXPECT_EQ(FormatStyle::LK_JavaScript, Style.Language);\n\n  CHECK_PARSE(\"BasedOnStyle: LLVM\\n\"\n              \"IndentWidth: 67\",\n              IndentWidth, 67u);\n\n  CHECK_PARSE(\"---\\n\"\n              \"Language: JavaScript\\n\"\n              \"IndentWidth: 12\\n\"\n              \"---\\n\"\n              \"Language: Cpp\\n\"\n              \"IndentWidth: 34\\n\"\n              \"...\\n\",\n              IndentWidth, 12u);\n\n  Style.Language = FormatStyle::LK_Cpp;\n  CHECK_PARSE(\"---\\n\"\n              \"Language: JavaScript\\n\"\n              \"IndentWidth: 12\\n\"\n              \"---\\n\"\n              \"Language: Cpp\\n\"\n              \"IndentWidth: 34\\n\"\n              \"...\\n\",\n              IndentWidth, 34u);\n  CHECK_PARSE(\"---\\n\"\n              \"IndentWidth: 78\\n\"\n              \"---\\n\"\n              \"Language: JavaScript\\n\"\n              \"IndentWidth: 56\\n\"\n              \"...\\n\",\n              IndentWidth, 78u);\n\n  Style.ColumnLimit = 123;\n  Style.IndentWidth = 234;\n  Style.BreakBeforeBraces = FormatStyle::BS_Linux;\n  Style.TabWidth = 345;\n  EXPECT_FALSE(parseConfiguration(\"---\\n\"\n                                  \"IndentWidth: 456\\n\"\n                                  \"BreakBeforeBraces: Allman\\n\"\n                                  \"---\\n\"\n                                  \"Language: JavaScript\\n\"\n                                  \"IndentWidth: 111\\n\"\n                                  \"TabWidth: 111\\n\"\n                                  \"---\\n\"\n                                  \"Language: Cpp\\n\"\n                                  \"BreakBeforeBraces: Stroustrup\\n\"\n                                  \"TabWidth: 789\\n\"\n                                  \"...\\n\",\n                                  &Style));\n  EXPECT_EQ(123u, Style.ColumnLimit);\n  EXPECT_EQ(456u, Style.IndentWidth);\n  EXPECT_EQ(FormatStyle::BS_Stroustrup, Style.BreakBeforeBraces);\n  EXPECT_EQ(789u, Style.TabWidth);\n\n  EXPECT_EQ(parseConfiguration(\"---\\n\"\n                               \"Language: JavaScript\\n\"\n                               \"IndentWidth: 56\\n\"\n                               \"---\\n\"\n                               \"IndentWidth: 78\\n\"\n                               \"...\\n\",\n                               &Style),\n            ParseError::Error);\n  EXPECT_EQ(parseConfiguration(\"---\\n\"\n                               \"Language: JavaScript\\n\"\n                               \"IndentWidth: 56\\n\"\n                               \"---\\n\"\n                               \"Language: JavaScript\\n\"\n                               \"IndentWidth: 78\\n\"\n                               \"...\\n\",\n                               &Style),\n            ParseError::Error);\n\n  EXPECT_EQ(FormatStyle::LK_Cpp, Style.Language);\n}\n\n#undef CHECK_PARSE\n\nTEST_F(FormatTest, UsesLanguageForBasedOnStyle) {\n  FormatStyle Style = {};\n  Style.Language = FormatStyle::LK_JavaScript;\n  Style.BreakBeforeTernaryOperators = true;\n  EXPECT_EQ(0, parseConfiguration(\"BasedOnStyle: Google\", &Style).value());\n  EXPECT_FALSE(Style.BreakBeforeTernaryOperators);\n\n  Style.BreakBeforeTernaryOperators = true;\n  EXPECT_EQ(0, parseConfiguration(\"---\\n\"\n                                  \"BasedOnStyle: Google\\n\"\n                                  \"---\\n\"\n                                  \"Language: JavaScript\\n\"\n                                  \"IndentWidth: 76\\n\"\n                                  \"...\\n\",\n                                  &Style)\n                   .value());\n  EXPECT_FALSE(Style.BreakBeforeTernaryOperators);\n  EXPECT_EQ(76u, Style.IndentWidth);\n  EXPECT_EQ(FormatStyle::LK_JavaScript, Style.Language);\n}\n\nTEST_F(FormatTest, ConfigurationRoundTripTest) {\n  FormatStyle Style = getLLVMStyle();\n  std::string YAML = configurationAsText(Style);\n  FormatStyle ParsedStyle = {};\n  ParsedStyle.Language = FormatStyle::LK_Cpp;\n  EXPECT_EQ(0, parseConfiguration(YAML, &ParsedStyle).value());\n  EXPECT_EQ(Style, ParsedStyle);\n}\n\nTEST_F(FormatTest, WorksFor8bitEncodings) {\n  EXPECT_EQ(\"\\\"\\xce\\xe4\\xed\\xe0\\xe6\\xe4\\xfb \\xe2 \\\"\\n\"\n            \"\\\"\\xf1\\xf2\\xf3\\xe4\\xb8\\xed\\xf3\\xfe \\\"\\n\"\n            \"\\\"\\xe7\\xe8\\xec\\xed\\xfe\\xfe \\\"\\n\"\n            \"\\\"\\xef\\xee\\xf0\\xf3...\\\"\",\n            format(\"\\\"\\xce\\xe4\\xed\\xe0\\xe6\\xe4\\xfb \\xe2 \"\n                   \"\\xf1\\xf2\\xf3\\xe4\\xb8\\xed\\xf3\\xfe \\xe7\\xe8\\xec\\xed\\xfe\\xfe \"\n                   \"\\xef\\xee\\xf0\\xf3...\\\"\",\n                   getLLVMStyleWithColumns(12)));\n}\n\nTEST_F(FormatTest, HandlesUTF8BOM) {\n  EXPECT_EQ(\"\\xef\\xbb\\xbf\", format(\"\\xef\\xbb\\xbf\"));\n  EXPECT_EQ(\"\\xef\\xbb\\xbf#include <iostream>\",\n            format(\"\\xef\\xbb\\xbf#include <iostream>\"));\n  EXPECT_EQ(\"\\xef\\xbb\\xbf\\n#include <iostream>\",\n            format(\"\\xef\\xbb\\xbf\\n#include <iostream>\"));\n}\n\n// FIXME: Encode Cyrillic and CJK characters below to appease MS compilers.\n#if !defined(_MSC_VER)\n\nTEST_F(FormatTest, CountsUTF8CharactersProperly) {\n  verifyFormat(\"\\\"\u041e\u0434\u043d\u0430\u0436\u0434\u044b \u0432 \u0441\u0442\u0443\u0434\u0451\u043d\u0443\u044e \u0437\u0438\u043c\u043d\u044e\u044e \u043f\u043e\u0440\u0443...\\\"\",\n               getLLVMStyleWithColumns(35));\n  verifyFormat(\"\\\"\u4e00 \u4e8c \u4e09 \u56db \u4e94 \u516d \u4e03 \u516b \u4e5d \u5341\\\"\",\n               getLLVMStyleWithColumns(31));\n  verifyFormat(\"// \u041e\u0434\u043d\u0430\u0436\u0434\u044b \u0432 \u0441\u0442\u0443\u0434\u0451\u043d\u0443\u044e \u0437\u0438\u043c\u043d\u044e\u044e \u043f\u043e\u0440\u0443...\",\n               getLLVMStyleWithColumns(36));\n  verifyFormat(\"// \u4e00 \u4e8c \u4e09 \u56db \u4e94 \u516d \u4e03 \u516b \u4e5d \u5341\", getLLVMStyleWithColumns(32));\n  verifyFormat(\"/* \u041e\u0434\u043d\u0430\u0436\u0434\u044b \u0432 \u0441\u0442\u0443\u0434\u0451\u043d\u0443\u044e \u0437\u0438\u043c\u043d\u044e\u044e \u043f\u043e\u0440\u0443... */\",\n               getLLVMStyleWithColumns(39));\n  verifyFormat(\"/* \u4e00 \u4e8c \u4e09 \u56db \u4e94 \u516d \u4e03 \u516b \u4e5d \u5341 */\",\n               getLLVMStyleWithColumns(35));\n}\n\nTEST_F(FormatTest, SplitsUTF8Strings) {\n  // Non-printable characters' width is currently considered to be the length in\n  // bytes in UTF8. The characters can be displayed in very different manner\n  // (zero-width, single width with a substitution glyph, expanded to their code\n  // (e.g. \"<8d>\"), so there's no single correct way to handle them.\n  EXPECT_EQ(\"\\\"aaaa\u00c4\\\"\\n\"\n            \"\\\"\\xc2\\x8d\\\";\",\n            format(\"\\\"aaaa\u00c4\\xc2\\x8d\\\";\", getLLVMStyleWithColumns(10)));\n  EXPECT_EQ(\"\\\"aaaaaaa\u00c4\\\"\\n\"\n            \"\\\"\\xc2\\x8d\\\";\",\n            format(\"\\\"aaaaaaa\u00c4\\xc2\\x8d\\\";\", getLLVMStyleWithColumns(10)));\n  EXPECT_EQ(\"\\\"\u041e\u0434\u043d\u0430\u0436\u0434\u044b, \u0432 \\\"\\n\"\n            \"\\\"\u0441\u0442\u0443\u0434\u0451\u043d\u0443\u044e \\\"\\n\"\n            \"\\\"\u0437\u0438\u043c\u043d\u044e\u044e \\\"\\n\"\n            \"\\\"\u043f\u043e\u0440\u0443,\\\"\",\n            format(\"\\\"\u041e\u0434\u043d\u0430\u0436\u0434\u044b, \u0432 \u0441\u0442\u0443\u0434\u0451\u043d\u0443\u044e \u0437\u0438\u043c\u043d\u044e\u044e \u043f\u043e\u0440\u0443,\\\"\",\n                   getLLVMStyleWithColumns(13)));\n  EXPECT_EQ(\n      \"\\\"\u4e00 \u4e8c \u4e09 \\\"\\n\"\n      \"\\\"\u56db \u4e94\u516d \\\"\\n\"\n      \"\\\"\u4e03 \u516b \u4e5d \\\"\\n\"\n      \"\\\"\u5341\\\"\",\n      format(\"\\\"\u4e00 \u4e8c \u4e09 \u56db \u4e94\u516d \u4e03 \u516b \u4e5d \u5341\\\"\", getLLVMStyleWithColumns(11)));\n  EXPECT_EQ(\"\\\"\u4e00\\t\\\"\\n\"\n            \"\\\"\u4e8c \\t\\\"\\n\"\n            \"\\\"\u4e09 \u56db \\\"\\n\"\n            \"\\\"\u4e94\\t\\\"\\n\"\n            \"\\\"\u516d \\t\\\"\\n\"\n            \"\\\"\u4e03 \\\"\\n\"\n            \"\\\"\u516b\u4e5d\u5341\\tqq\\\"\",\n            format(\"\\\"\u4e00\\t\u4e8c \\t\u4e09 \u56db \u4e94\\t\u516d \\t\u4e03 \u516b\u4e5d\u5341\\tqq\\\"\",\n                   getLLVMStyleWithColumns(11)));\n\n  // UTF8 character in an escape sequence.\n  EXPECT_EQ(\"\\\"aaaaaa\\\"\\n\"\n            \"\\\"\\\\\\xC2\\x8D\\\"\",\n            format(\"\\\"aaaaaa\\\\\\xC2\\x8D\\\"\", getLLVMStyleWithColumns(10)));\n}\n\nTEST_F(FormatTest, HandlesDoubleWidthCharsInMultiLineStrings) {\n  EXPECT_EQ(\"const char *sssss =\\n\"\n            \"    \\\"\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\\\\\\n\"\n            \" \u4e5d \u5341\\\";\",\n            format(\"const char *sssss = \\\"\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\\\\\\n\"\n                   \" \u4e5d \u5341\\\";\",\n                   getLLVMStyleWithColumns(30)));\n}\n\nTEST_F(FormatTest, SplitsUTF8LineComments) {\n  EXPECT_EQ(\"// aaaa\u00c4\\xc2\\x8d\",\n            format(\"// aaaa\u00c4\\xc2\\x8d\", getLLVMStyleWithColumns(10)));\n  EXPECT_EQ(\"// \u042f \u0438\u0437 \u043b\u0435\u0441\u0443\\n\"\n            \"// \u0432\u044b\u0448\u0435\u043b; \u0431\u044b\u043b\\n\"\n            \"// \u0441\u0438\u043b\u044c\u043d\u044b\u0439\\n\"\n            \"// \u043c\u043e\u0440\u043e\u0437.\",\n            format(\"// \u042f \u0438\u0437 \u043b\u0435\u0441\u0443 \u0432\u044b\u0448\u0435\u043b; \u0431\u044b\u043b \u0441\u0438\u043b\u044c\u043d\u044b\u0439 \u043c\u043e\u0440\u043e\u0437.\",\n                   getLLVMStyleWithColumns(13)));\n  EXPECT_EQ(\"// \u4e00\u4e8c\u4e09\\n\"\n            \"// \u56db\u4e94\u516d\u4e03\\n\"\n            \"// \u516b  \u4e5d\\n\"\n            \"// \u5341\",\n            format(\"// \u4e00\u4e8c\u4e09 \u56db\u4e94\u516d\u4e03 \u516b  \u4e5d \u5341\", getLLVMStyleWithColumns(9)));\n}\n\nTEST_F(FormatTest, SplitsUTF8BlockComments) {\n  EXPECT_EQ(\"/* \u0413\u043b\u044f\u0436\u0443,\\n\"\n            \" * \u043f\u043e\u0434\u043d\u0438\u043c\u0430\u0435\u0442\u0441\u044f\\n\"\n            \" * \u043c\u0435\u0434\u043b\u0435\u043d\u043d\u043e \u0432\\n\"\n            \" * \u0433\u043e\u0440\u0443\\n\"\n            \" * \u041b\u043e\u0448\u0430\u0434\u043a\u0430,\\n\"\n            \" * \u0432\u0435\u0437\u0443\u0449\u0430\u044f\\n\"\n            \" * \u0445\u0432\u043e\u0440\u043e\u0441\u0442\u0443\\n\"\n            \" * \u0432\u043e\u0437. */\",\n            format(\"/* \u0413\u043b\u044f\u0436\u0443, \u043f\u043e\u0434\u043d\u0438\u043c\u0430\u0435\u0442\u0441\u044f \u043c\u0435\u0434\u043b\u0435\u043d\u043d\u043e \u0432 \u0433\u043e\u0440\u0443\\n\"\n                   \" * \u041b\u043e\u0448\u0430\u0434\u043a\u0430, \u0432\u0435\u0437\u0443\u0449\u0430\u044f \u0445\u0432\u043e\u0440\u043e\u0441\u0442\u0443 \u0432\u043e\u0437. */\",\n                   getLLVMStyleWithColumns(13)));\n  EXPECT_EQ(\n      \"/* \u4e00\u4e8c\u4e09\\n\"\n      \" * \u56db\u4e94\u516d\u4e03\\n\"\n      \" * \u516b  \u4e5d\\n\"\n      \" * \u5341  */\",\n      format(\"/* \u4e00\u4e8c\u4e09 \u56db\u4e94\u516d\u4e03 \u516b  \u4e5d \u5341  */\", getLLVMStyleWithColumns(9)));\n  EXPECT_EQ(\"/* \ud835\udce3\ud835\udcee\ud835\udcfc\ud835\udcfd \ud835\udd23\ud835\udd2c\ud835\udd32\ud835\udd2f\\n\"\n            \" * \ud835\udd53\ud835\udd6a\ud835\udd65\ud835\udd56\\n\"\n            \" * \ud835\udd80\ud835\udd7f\ud835\udd71-\ud835\udfe0 */\",\n            format(\"/* \ud835\udce3\ud835\udcee\ud835\udcfc\ud835\udcfd \ud835\udd23\ud835\udd2c\ud835\udd32\ud835\udd2f \ud835\udd53\ud835\udd6a\ud835\udd65\ud835\udd56 \ud835\udd80\ud835\udd7f\ud835\udd71-\ud835\udfe0 */\", getLLVMStyleWithColumns(12)));\n}\n\n#endif // _MSC_VER\n\nTEST_F(FormatTest, ConstructorInitializerIndentWidth) {\n  FormatStyle Style = getLLVMStyle();\n\n  Style.ConstructorInitializerIndentWidth = 4;\n  verifyFormat(\n      \"SomeClass::Constructor()\\n\"\n      \"    : aaaaaaaaaaaaa(aaaaaaaaaaaaaa), aaaaaaaaaaaaa(aaaaaaaaaaaaaa),\\n\"\n      \"      aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}\",\n      Style);\n\n  Style.ConstructorInitializerIndentWidth = 2;\n  verifyFormat(\n      \"SomeClass::Constructor()\\n\"\n      \"  : aaaaaaaaaaaaa(aaaaaaaaaaaaaa), aaaaaaaaaaaaa(aaaaaaaaaaaaaa),\\n\"\n      \"    aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}\",\n      Style);\n\n  Style.ConstructorInitializerIndentWidth = 0;\n  verifyFormat(\n      \"SomeClass::Constructor()\\n\"\n      \": aaaaaaaaaaaaa(aaaaaaaaaaaaaa), aaaaaaaaaaaaa(aaaaaaaaaaaaaa),\\n\"\n      \"  aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}\",\n      Style);\n  Style.AlignAfterOpenBracket = FormatStyle::BAS_AlwaysBreak;\n  verifyFormat(\n      \"SomeLongTemplateVariableName<\\n\"\n      \"    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa>\",\n      Style);\n  verifyFormat(\"bool smaller = 1 < \"\n               \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb(\\n\"\n               \"                       \"\n               \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);\",\n               Style);\n\n  Style.BreakConstructorInitializers = FormatStyle::BCIS_AfterColon;\n  verifyFormat(\"SomeClass::Constructor() :\\n\"\n               \"aaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaa),\\n\"\n               \"aaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaa) {}\",\n               Style);\n}\n\nTEST_F(FormatTest, BreakConstructorInitializersBeforeComma) {\n  FormatStyle Style = getLLVMStyle();\n  Style.BreakConstructorInitializers = FormatStyle::BCIS_BeforeComma;\n  Style.ConstructorInitializerIndentWidth = 4;\n  verifyFormat(\"SomeClass::Constructor()\\n\"\n               \"    : a(a)\\n\"\n               \"    , b(b)\\n\"\n               \"    , c(c) {}\",\n               Style);\n  verifyFormat(\"SomeClass::Constructor()\\n\"\n               \"    : a(a) {}\",\n               Style);\n\n  Style.ColumnLimit = 0;\n  verifyFormat(\"SomeClass::Constructor()\\n\"\n               \"    : a(a) {}\",\n               Style);\n  verifyFormat(\"SomeClass::Constructor() noexcept\\n\"\n               \"    : a(a) {}\",\n               Style);\n  verifyFormat(\"SomeClass::Constructor()\\n\"\n               \"    : a(a)\\n\"\n               \"    , b(b)\\n\"\n               \"    , c(c) {}\",\n               Style);\n  verifyFormat(\"SomeClass::Constructor()\\n\"\n               \"    : a(a) {\\n\"\n               \"  foo();\\n\"\n               \"  bar();\\n\"\n               \"}\",\n               Style);\n\n  Style.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_None;\n  verifyFormat(\"SomeClass::Constructor()\\n\"\n               \"    : a(a)\\n\"\n               \"    , b(b)\\n\"\n               \"    , c(c) {\\n}\",\n               Style);\n  verifyFormat(\"SomeClass::Constructor()\\n\"\n               \"    : a(a) {\\n}\",\n               Style);\n\n  Style.ColumnLimit = 80;\n  Style.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_All;\n  Style.ConstructorInitializerIndentWidth = 2;\n  verifyFormat(\"SomeClass::Constructor()\\n\"\n               \"  : a(a)\\n\"\n               \"  , b(b)\\n\"\n               \"  , c(c) {}\",\n               Style);\n\n  Style.ConstructorInitializerIndentWidth = 0;\n  verifyFormat(\"SomeClass::Constructor()\\n\"\n               \": a(a)\\n\"\n               \", b(b)\\n\"\n               \", c(c) {}\",\n               Style);\n\n  Style.ConstructorInitializerAllOnOneLineOrOnePerLine = true;\n  Style.ConstructorInitializerIndentWidth = 4;\n  verifyFormat(\"SomeClass::Constructor() : aaaaaaaa(aaaaaaaa) {}\", Style);\n  verifyFormat(\n      \"SomeClass::Constructor() : aaaaa(aaaaa), aaaaa(aaaaa), aaaaa(aaaaa)\\n\",\n      Style);\n  verifyFormat(\n      \"SomeClass::Constructor()\\n\"\n      \"    : aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa), aaaaaaaa(aaaaaaaa) {}\",\n      Style);\n  Style.ConstructorInitializerIndentWidth = 4;\n  Style.ColumnLimit = 60;\n  verifyFormat(\"SomeClass::Constructor()\\n\"\n               \"    : aaaaaaaa(aaaaaaaa)\\n\"\n               \"    , aaaaaaaa(aaaaaaaa)\\n\"\n               \"    , aaaaaaaa(aaaaaaaa) {}\",\n               Style);\n}\n\nTEST_F(FormatTest, Destructors) {\n  verifyFormat(\"void F(int &i) { i.~int(); }\");\n  verifyFormat(\"void F(int &i) { i->~int(); }\");\n}\n\nTEST_F(FormatTest, FormatsWithWebKitStyle) {\n  FormatStyle Style = getWebKitStyle();\n\n  // Don't indent in outer namespaces.\n  verifyFormat(\"namespace outer {\\n\"\n               \"int i;\\n\"\n               \"namespace inner {\\n\"\n               \"    int i;\\n\"\n               \"} // namespace inner\\n\"\n               \"} // namespace outer\\n\"\n               \"namespace other_outer {\\n\"\n               \"int i;\\n\"\n               \"}\",\n               Style);\n\n  // Don't indent case labels.\n  verifyFormat(\"switch (variable) {\\n\"\n               \"case 1:\\n\"\n               \"case 2:\\n\"\n               \"    doSomething();\\n\"\n               \"    break;\\n\"\n               \"default:\\n\"\n               \"    ++variable;\\n\"\n               \"}\",\n               Style);\n\n  // Wrap before binary operators.\n  EXPECT_EQ(\"void f()\\n\"\n            \"{\\n\"\n            \"    if (aaaaaaaaaaaaaaaa\\n\"\n            \"        && bbbbbbbbbbbbbbbbbbbbbbbb\\n\"\n            \"        && (cccccccccccccccccccccccccc || dddddddddddddddddddd))\\n\"\n            \"        return;\\n\"\n            \"}\",\n            format(\"void f() {\\n\"\n                   \"if (aaaaaaaaaaaaaaaa\\n\"\n                   \"&& bbbbbbbbbbbbbbbbbbbbbbbb\\n\"\n                   \"&& (cccccccccccccccccccccccccc || dddddddddddddddddddd))\\n\"\n                   \"return;\\n\"\n                   \"}\",\n                   Style));\n\n  // Allow functions on a single line.\n  verifyFormat(\"void f() { return; }\", Style);\n\n  // Allow empty blocks on a single line and insert a space in empty blocks.\n  EXPECT_EQ(\"void f() { }\", format(\"void f() {}\", Style));\n  EXPECT_EQ(\"while (true) { }\", format(\"while (true) {}\", Style));\n  // However, don't merge non-empty short loops.\n  EXPECT_EQ(\"while (true) {\\n\"\n            \"    continue;\\n\"\n            \"}\",\n            format(\"while (true) { continue; }\", Style));\n\n  // Constructor initializers are formatted one per line with the \",\" on the\n  // new line.\n  verifyFormat(\"Constructor()\\n\"\n               \"    : aaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaaaaaaaaaaa)\\n\"\n               \"    , aaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaa, // break\\n\"\n               \"          aaaaaaaaaaaaaa)\\n\"\n               \"    , aaaaaaaaaaaaaaaaaaaaaaa()\\n\"\n               \"{\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"SomeClass::Constructor()\\n\"\n               \"    : a(a)\\n\"\n               \"{\\n\"\n               \"}\",\n               Style);\n  EXPECT_EQ(\"SomeClass::Constructor()\\n\"\n            \"    : a(a)\\n\"\n            \"{\\n\"\n            \"}\",\n            format(\"SomeClass::Constructor():a(a){}\", Style));\n  verifyFormat(\"SomeClass::Constructor()\\n\"\n               \"    : a(a)\\n\"\n               \"    , b(b)\\n\"\n               \"    , c(c)\\n\"\n               \"{\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"SomeClass::Constructor()\\n\"\n               \"    : a(a)\\n\"\n               \"{\\n\"\n               \"    foo();\\n\"\n               \"    bar();\\n\"\n               \"}\",\n               Style);\n\n  // Access specifiers should be aligned left.\n  verifyFormat(\"class C {\\n\"\n               \"public:\\n\"\n               \"    int i;\\n\"\n               \"};\",\n               Style);\n\n  // Do not align comments.\n  verifyFormat(\"int a; // Do not\\n\"\n               \"double b; // align comments.\",\n               Style);\n\n  // Do not align operands.\n  EXPECT_EQ(\"ASSERT(aaaa\\n\"\n            \"    || bbbb);\",\n            format(\"ASSERT ( aaaa\\n||bbbb);\", Style));\n\n  // Accept input's line breaks.\n  EXPECT_EQ(\"if (aaaaaaaaaaaaaaa\\n\"\n            \"    || bbbbbbbbbbbbbbb) {\\n\"\n            \"    i++;\\n\"\n            \"}\",\n            format(\"if (aaaaaaaaaaaaaaa\\n\"\n                   \"|| bbbbbbbbbbbbbbb) { i++; }\",\n                   Style));\n  EXPECT_EQ(\"if (aaaaaaaaaaaaaaa || bbbbbbbbbbbbbbb) {\\n\"\n            \"    i++;\\n\"\n            \"}\",\n            format(\"if (aaaaaaaaaaaaaaa || bbbbbbbbbbbbbbb) { i++; }\", Style));\n\n  // Don't automatically break all macro definitions (llvm.org/PR17842).\n  verifyFormat(\"#define aNumber 10\", Style);\n  // However, generally keep the line breaks that the user authored.\n  EXPECT_EQ(\"#define aNumber \\\\\\n\"\n            \"    10\",\n            format(\"#define aNumber \\\\\\n\"\n                   \" 10\",\n                   Style));\n\n  // Keep empty and one-element array literals on a single line.\n  EXPECT_EQ(\"NSArray* a = [[NSArray alloc] initWithArray:@[]\\n\"\n            \"                                  copyItems:YES];\",\n            format(\"NSArray*a=[[NSArray alloc] initWithArray:@[]\\n\"\n                   \"copyItems:YES];\",\n                   Style));\n  EXPECT_EQ(\"NSArray* a = [[NSArray alloc] initWithArray:@[ @\\\"a\\\" ]\\n\"\n            \"                                  copyItems:YES];\",\n            format(\"NSArray*a=[[NSArray alloc]initWithArray:@[ @\\\"a\\\" ]\\n\"\n                   \"             copyItems:YES];\",\n                   Style));\n  // FIXME: This does not seem right, there should be more indentation before\n  // the array literal's entries. Nested blocks have the same problem.\n  EXPECT_EQ(\"NSArray* a = [[NSArray alloc] initWithArray:@[\\n\"\n            \"    @\\\"a\\\",\\n\"\n            \"    @\\\"a\\\"\\n\"\n            \"]\\n\"\n            \"                                  copyItems:YES];\",\n            format(\"NSArray* a = [[NSArray alloc] initWithArray:@[\\n\"\n                   \"     @\\\"a\\\",\\n\"\n                   \"     @\\\"a\\\"\\n\"\n                   \"     ]\\n\"\n                   \"       copyItems:YES];\",\n                   Style));\n  EXPECT_EQ(\n      \"NSArray* a = [[NSArray alloc] initWithArray:@[ @\\\"a\\\", @\\\"a\\\" ]\\n\"\n      \"                                  copyItems:YES];\",\n      format(\"NSArray* a = [[NSArray alloc] initWithArray:@[ @\\\"a\\\", @\\\"a\\\" ]\\n\"\n             \"   copyItems:YES];\",\n             Style));\n\n  verifyFormat(\"[self.a b:c c:d];\", Style);\n  EXPECT_EQ(\"[self.a b:c\\n\"\n            \"        c:d];\",\n            format(\"[self.a b:c\\n\"\n                   \"c:d];\",\n                   Style));\n}\n\nTEST_F(FormatTest, FormatsLambdas) {\n  verifyFormat(\"int c = [b]() mutable { return [&b] { return b++; }(); }();\\n\");\n  verifyFormat(\n      \"int c = [b]() mutable noexcept { return [&b] { return b++; }(); }();\\n\");\n  verifyFormat(\"int c = [&] { [=] { return b++; }(); }();\\n\");\n  verifyFormat(\"int c = [&, &a, a] { [=, c, &d] { return b++; }(); }();\\n\");\n  verifyFormat(\"int c = [&a, &a, a] { [=, a, b, &c] { return b++; }(); }();\\n\");\n  verifyFormat(\"auto c = {[&a, &a, a] { [=, a, b, &c] { return b++; }(); }}\\n\");\n  verifyFormat(\"auto c = {[&a, &a, a] { [=, a, b, &c] {}(); }}\\n\");\n  verifyFormat(\"auto c = [a = [b = 42] {}] {};\\n\");\n  verifyFormat(\"auto c = [a = &i + 10, b = [] {}] {};\\n\");\n  verifyFormat(\"int x = f(*+[] {});\");\n  verifyFormat(\"void f() {\\n\"\n               \"  other(x.begin(), x.end(), [&](int, int) { return 1; });\\n\"\n               \"}\\n\");\n  verifyFormat(\"void f() {\\n\"\n               \"  other(x.begin(), //\\n\"\n               \"        x.end(),   //\\n\"\n               \"        [&](int, int) { return 1; });\\n\"\n               \"}\\n\");\n  verifyFormat(\"void f() {\\n\"\n               \"  other.other.other.other.other(\\n\"\n               \"      x.begin(), x.end(),\\n\"\n               \"      [something, rather](int, int, int, int, int, int, int) { \"\n               \"return 1; });\\n\"\n               \"}\\n\");\n  verifyFormat(\n      \"void f() {\\n\"\n      \"  other.other.other.other.other(\\n\"\n      \"      x.begin(), x.end(),\\n\"\n      \"      [something, rather](int, int, int, int, int, int, int) {\\n\"\n      \"        //\\n\"\n      \"      });\\n\"\n      \"}\\n\");\n  verifyFormat(\"SomeFunction([]() { // A cool function...\\n\"\n               \"  return 43;\\n\"\n               \"});\");\n  EXPECT_EQ(\"SomeFunction([]() {\\n\"\n            \"#define A a\\n\"\n            \"  return 43;\\n\"\n            \"});\",\n            format(\"SomeFunction([](){\\n\"\n                   \"#define A a\\n\"\n                   \"return 43;\\n\"\n                   \"});\"));\n  verifyFormat(\"void f() {\\n\"\n               \"  SomeFunction([](decltype(x), A *a) {});\\n\"\n               \"  SomeFunction([](typeof(x), A *a) {});\\n\"\n               \"  SomeFunction([](_Atomic(x), A *a) {});\\n\"\n               \"  SomeFunction([](__underlying_type(x), A *a) {});\\n\"\n               \"}\");\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"    [](const aaaaaaaaaa &a) { return a; });\");\n  verifyFormat(\"string abc = SomeFunction(aaaaaaaaaaaaa, aaaaa, []() {\\n\"\n               \"  SomeOtherFunctioooooooooooooooooooooooooon();\\n\"\n               \"});\");\n  verifyFormat(\"Constructor()\\n\"\n               \"    : Field([] { // comment\\n\"\n               \"        int i;\\n\"\n               \"      }) {}\");\n  verifyFormat(\"auto my_lambda = [](const string &some_parameter) {\\n\"\n               \"  return some_parameter.size();\\n\"\n               \"};\");\n  verifyFormat(\"std::function<std::string(const std::string &)> my_lambda =\\n\"\n               \"    [](const string &s) { return s; };\");\n  verifyFormat(\"int i = aaaaaa ? 1 //\\n\"\n               \"               : [] {\\n\"\n               \"                   return 2; //\\n\"\n               \"                 }();\");\n  verifyFormat(\"llvm::errs() << \\\"number of twos is \\\"\\n\"\n               \"             << std::count_if(v.begin(), v.end(), [](int x) {\\n\"\n               \"                  return x == 2; // force break\\n\"\n               \"                });\");\n  verifyFormat(\"return aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"    [=](int iiiiiiiiiiii) {\\n\"\n               \"      return aaaaaaaaaaaaaaaaaaaaaaa !=\\n\"\n               \"             aaaaaaaaaaaaaaaaaaaaaaa;\\n\"\n               \"    });\",\n               getLLVMStyleWithColumns(60));\n  verifyFormat(\"SomeFunction({[&] {\\n\"\n               \"                // comment\\n\"\n               \"              },\\n\"\n               \"              [&] {\\n\"\n               \"                // comment\\n\"\n               \"              }});\");\n  verifyFormat(\"SomeFunction({[&] {\\n\"\n               \"  // comment\\n\"\n               \"}});\");\n  verifyFormat(\n      \"virtual aaaaaaaaaaaaaaaa(\\n\"\n      \"    std::function<bool()> bbbbbbbbbbbb = [&]() { return true; },\\n\"\n      \"    aaaaa aaaaaaaaa);\");\n\n  // Lambdas with return types.\n  verifyFormat(\"int c = []() -> int { return 2; }();\\n\");\n  verifyFormat(\"int c = []() -> int * { return 2; }();\\n\");\n  verifyFormat(\"int c = []() -> vector<int> { return {2}; }();\\n\");\n  verifyFormat(\"Foo([]() -> std::vector<int> { return {2}; }());\");\n  verifyGoogleFormat(\"auto a = [&b, c](D* d) -> D* {};\");\n  verifyGoogleFormat(\"auto a = [&b, c](D* d) -> pair<D*, D*> {};\");\n  verifyGoogleFormat(\"auto a = [&b, c](D* d) -> D& {};\");\n  verifyGoogleFormat(\"auto a = [&b, c](D* d) -> const D* {};\");\n  verifyFormat(\"[a, a]() -> a<1> {};\");\n  verifyFormat(\"[]() -> foo<5 + 2> { return {}; };\");\n  verifyFormat(\"[]() -> foo<5 - 2> { return {}; };\");\n  verifyFormat(\"[]() -> foo<5 / 2> { return {}; };\");\n  verifyFormat(\"[]() -> foo<5 * 2> { return {}; };\");\n  verifyFormat(\"[]() -> foo<5 % 2> { return {}; };\");\n  verifyFormat(\"[]() -> foo<5 << 2> { return {}; };\");\n  verifyFormat(\"[]() -> foo<!5> { return {}; };\");\n  verifyFormat(\"[]() -> foo<~5> { return {}; };\");\n  verifyFormat(\"[]() -> foo<5 | 2> { return {}; };\");\n  verifyFormat(\"[]() -> foo<5 || 2> { return {}; };\");\n  verifyFormat(\"[]() -> foo<5 & 2> { return {}; };\");\n  verifyFormat(\"[]() -> foo<5 && 2> { return {}; };\");\n  verifyFormat(\"[]() -> foo<5 == 2> { return {}; };\");\n  verifyFormat(\"[]() -> foo<5 != 2> { return {}; };\");\n  verifyFormat(\"[]() -> foo<5 >= 2> { return {}; };\");\n  verifyFormat(\"[]() -> foo<5 <= 2> { return {}; };\");\n  verifyFormat(\"[]() -> foo<5 < 2> { return {}; };\");\n  verifyFormat(\"[]() -> foo<2 ? 1 : 0> { return {}; };\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<5 + 2> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<5 - 2> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<5 / 2> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<5 * 2> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<5 % 2> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<5 << 2> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<!5> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<~5> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<5 | 2> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<5 || 2> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<5 & 2> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<5 && 2> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<5 == 2> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<5 != 2> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<5 >= 2> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<5 <= 2> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<5 < 2> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"// broken:\\n\"\n               \"auto foo{[]() -> foo<2 ? 1 : 0> { return {}; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"[]() -> a<1> {};\");\n  verifyFormat(\"[]() -> a<1> { ; };\");\n  verifyFormat(\"[]() -> a<1> { ; }();\");\n  verifyFormat(\"[a, a]() -> a<true> {};\");\n  verifyFormat(\"[]() -> a<true> {};\");\n  verifyFormat(\"[]() -> a<true> { ; };\");\n  verifyFormat(\"[]() -> a<true> { ; }();\");\n  verifyFormat(\"[a, a]() -> a<false> {};\");\n  verifyFormat(\"[]() -> a<false> {};\");\n  verifyFormat(\"[]() -> a<false> { ; };\");\n  verifyFormat(\"[]() -> a<false> { ; }();\");\n  verifyFormat(\"auto foo{[]() -> foo<false> { ; }};\");\n  verifyFormat(\"namespace bar {\\n\"\n               \"auto foo{[]() -> foo<false> { ; }};\\n\"\n               \"} // namespace bar\");\n  verifyFormat(\"auto aaaaaaaa = [](int i, // break for some reason\\n\"\n               \"                   int j) -> int {\\n\"\n               \"  return ffffffffffffffffffffffffffffffffffffffffffff(i * j);\\n\"\n               \"};\");\n  verifyFormat(\n      \"aaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"    [](aaaaaaaaaaaaaaaaaaaaaaaaaaa &aaa) -> aaaaaaaaaaaaaaaa {\\n\"\n      \"      return aaaaaaaaaaaaaaaaa;\\n\"\n      \"    });\",\n      getLLVMStyleWithColumns(70));\n  verifyFormat(\"[]() //\\n\"\n               \"    -> int {\\n\"\n               \"  return 1; //\\n\"\n               \"};\");\n  verifyFormat(\"[]() -> Void<T...> {};\");\n  verifyFormat(\"[a, b]() -> Tuple<T...> { return {}; };\");\n\n  // Lambdas with explicit template argument lists.\n  verifyFormat(\n      \"auto L = []<template <typename> class T, class U>(T<U> &&a) {};\\n\");\n\n  // Multiple lambdas in the same parentheses change indentation rules. These\n  // lambdas are forced to start on new lines.\n  verifyFormat(\"SomeFunction(\\n\"\n               \"    []() {\\n\"\n               \"      //\\n\"\n               \"    },\\n\"\n               \"    []() {\\n\"\n               \"      //\\n\"\n               \"    });\");\n\n  // A lambda passed as arg0 is always pushed to the next line.\n  verifyFormat(\"SomeFunction(\\n\"\n               \"    [this] {\\n\"\n               \"      //\\n\"\n               \"    },\\n\"\n               \"    1);\\n\");\n\n  // A multi-line lambda passed as arg1 forces arg0 to be pushed out, just like\n  // the arg0 case above.\n  auto Style = getGoogleStyle();\n  Style.BinPackArguments = false;\n  verifyFormat(\"SomeFunction(\\n\"\n               \"    a,\\n\"\n               \"    [this] {\\n\"\n               \"      //\\n\"\n               \"    },\\n\"\n               \"    b);\\n\",\n               Style);\n  verifyFormat(\"SomeFunction(\\n\"\n               \"    a,\\n\"\n               \"    [this] {\\n\"\n               \"      //\\n\"\n               \"    },\\n\"\n               \"    b);\\n\");\n\n  // A lambda with a very long line forces arg0 to be pushed out irrespective of\n  // the BinPackArguments value (as long as the code is wide enough).\n  verifyFormat(\n      \"something->SomeFunction(\\n\"\n      \"    a,\\n\"\n      \"    [this] {\\n\"\n      \"      \"\n      \"D0000000000000000000000000000000000000000000000000000000000001();\\n\"\n      \"    },\\n\"\n      \"    b);\\n\");\n\n  // A multi-line lambda is pulled up as long as the introducer fits on the\n  // previous line and there are no further args.\n  verifyFormat(\"function(1, [this, that] {\\n\"\n               \"  //\\n\"\n               \"});\\n\");\n  verifyFormat(\"function([this, that] {\\n\"\n               \"  //\\n\"\n               \"});\\n\");\n  // FIXME: this format is not ideal and we should consider forcing the first\n  // arg onto its own line.\n  verifyFormat(\"function(a, b, c, //\\n\"\n               \"         d, [this, that] {\\n\"\n               \"           //\\n\"\n               \"         });\\n\");\n\n  // Multiple lambdas are treated correctly even when there is a short arg0.\n  verifyFormat(\"SomeFunction(\\n\"\n               \"    1,\\n\"\n               \"    [this] {\\n\"\n               \"      //\\n\"\n               \"    },\\n\"\n               \"    [this] {\\n\"\n               \"      //\\n\"\n               \"    },\\n\"\n               \"    1);\\n\");\n\n  // More complex introducers.\n  verifyFormat(\"return [i, args...] {};\");\n\n  // Not lambdas.\n  verifyFormat(\"constexpr char hello[]{\\\"hello\\\"};\");\n  verifyFormat(\"double &operator[](int i) { return 0; }\\n\"\n               \"int i;\");\n  verifyFormat(\"std::unique_ptr<int[]> foo() {}\");\n  verifyFormat(\"int i = a[a][a]->f();\");\n  verifyFormat(\"int i = (*b)[a]->f();\");\n\n  // Other corner cases.\n  verifyFormat(\"void f() {\\n\"\n               \"  bar([]() {} // Did not respect SpacesBeforeTrailingComments\\n\"\n               \"  );\\n\"\n               \"}\");\n\n  // Lambdas created through weird macros.\n  verifyFormat(\"void f() {\\n\"\n               \"  MACRO((const AA &a) { return 1; });\\n\"\n               \"  MACRO((AA &a) { return 1; });\\n\"\n               \"}\");\n\n  verifyFormat(\"if (blah_blah(whatever, whatever, [] {\\n\"\n               \"      doo_dah();\\n\"\n               \"      doo_dah();\\n\"\n               \"    })) {\\n\"\n               \"}\");\n  verifyFormat(\"if constexpr (blah_blah(whatever, whatever, [] {\\n\"\n               \"                doo_dah();\\n\"\n               \"                doo_dah();\\n\"\n               \"              })) {\\n\"\n               \"}\");\n  verifyFormat(\"if CONSTEXPR (blah_blah(whatever, whatever, [] {\\n\"\n               \"                doo_dah();\\n\"\n               \"                doo_dah();\\n\"\n               \"              })) {\\n\"\n               \"}\");\n  verifyFormat(\"auto lambda = []() {\\n\"\n               \"  int a = 2\\n\"\n               \"#if A\\n\"\n               \"          + 2\\n\"\n               \"#endif\\n\"\n               \"      ;\\n\"\n               \"};\");\n\n  // Lambdas with complex multiline introducers.\n  verifyFormat(\n      \"aaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n      \"    [aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa]()\\n\"\n      \"        -> ::std::unordered_set<\\n\"\n      \"            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa> {\\n\"\n      \"      //\\n\"\n      \"    });\");\n\n  FormatStyle DoNotMerge = getLLVMStyle();\n  DoNotMerge.AllowShortLambdasOnASingleLine = FormatStyle::SLS_None;\n  verifyFormat(\"auto c = []() {\\n\"\n               \"  return b;\\n\"\n               \"};\",\n               \"auto c = []() { return b; };\", DoNotMerge);\n  verifyFormat(\"auto c = []() {\\n\"\n               \"};\",\n               \" auto c = []() {};\", DoNotMerge);\n\n  FormatStyle MergeEmptyOnly = getLLVMStyle();\n  MergeEmptyOnly.AllowShortLambdasOnASingleLine = FormatStyle::SLS_Empty;\n  verifyFormat(\"auto c = []() {\\n\"\n               \"  return b;\\n\"\n               \"};\",\n               \"auto c = []() {\\n\"\n               \"  return b;\\n\"\n               \" };\",\n               MergeEmptyOnly);\n  verifyFormat(\"auto c = []() {};\",\n               \"auto c = []() {\\n\"\n               \"};\",\n               MergeEmptyOnly);\n\n  FormatStyle MergeInline = getLLVMStyle();\n  MergeInline.AllowShortLambdasOnASingleLine = FormatStyle::SLS_Inline;\n  verifyFormat(\"auto c = []() {\\n\"\n               \"  return b;\\n\"\n               \"};\",\n               \"auto c = []() { return b; };\", MergeInline);\n  verifyFormat(\"function([]() { return b; })\", \"function([]() { return b; })\",\n               MergeInline);\n  verifyFormat(\"function([]() { return b; }, a)\",\n               \"function([]() { return b; }, a)\", MergeInline);\n  verifyFormat(\"function(a, []() { return b; })\",\n               \"function(a, []() { return b; })\", MergeInline);\n\n  // Check option \"BraceWrapping.BeforeLambdaBody\" and different state of\n  // AllowShortLambdasOnASingleLine\n  FormatStyle LLVMWithBeforeLambdaBody = getLLVMStyle();\n  LLVMWithBeforeLambdaBody.BreakBeforeBraces = FormatStyle::BS_Custom;\n  LLVMWithBeforeLambdaBody.BraceWrapping.BeforeLambdaBody = true;\n  LLVMWithBeforeLambdaBody.AllowShortLambdasOnASingleLine =\n      FormatStyle::ShortLambdaStyle::SLS_None;\n  verifyFormat(\"FctWithOneNestedLambdaInline_SLS_None(\\n\"\n               \"    []()\\n\"\n               \"    {\\n\"\n               \"      return 17;\\n\"\n               \"    });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"FctWithOneNestedLambdaEmpty_SLS_None(\\n\"\n               \"    []()\\n\"\n               \"    {\\n\"\n               \"    });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"auto fct_SLS_None = []()\\n\"\n               \"{\\n\"\n               \"  return 17;\\n\"\n               \"};\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"TwoNestedLambdas_SLS_None(\\n\"\n               \"    []()\\n\"\n               \"    {\\n\"\n               \"      return Call(\\n\"\n               \"          []()\\n\"\n               \"          {\\n\"\n               \"            return 17;\\n\"\n               \"          });\\n\"\n               \"    });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"void Fct()\\n\"\n               \"{\\n\"\n               \"  return {[]()\\n\"\n               \"          {\\n\"\n               \"            return 17;\\n\"\n               \"          }};\\n\"\n               \"}\",\n               LLVMWithBeforeLambdaBody);\n\n  LLVMWithBeforeLambdaBody.AllowShortLambdasOnASingleLine =\n      FormatStyle::ShortLambdaStyle::SLS_Empty;\n  verifyFormat(\"FctWithOneNestedLambdaInline_SLS_Empty(\\n\"\n               \"    []()\\n\"\n               \"    {\\n\"\n               \"      return 17;\\n\"\n               \"    });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"FctWithOneNestedLambdaEmpty_SLS_Empty([]() {});\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"FctWithOneNestedLambdaEmptyInsideAVeryVeryVeryVeryVeryVeryVeryL\"\n               \"ongFunctionName_SLS_Empty(\\n\"\n               \"    []() {});\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"FctWithMultipleParams_SLS_Empty(A, B,\\n\"\n               \"                                []()\\n\"\n               \"                                {\\n\"\n               \"                                  return 17;\\n\"\n               \"                                });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"auto fct_SLS_Empty = []()\\n\"\n               \"{\\n\"\n               \"  return 17;\\n\"\n               \"};\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"TwoNestedLambdas_SLS_Empty(\\n\"\n               \"    []()\\n\"\n               \"    {\\n\"\n               \"      return Call([]() {});\\n\"\n               \"    });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"TwoNestedLambdas_SLS_Empty(A,\\n\"\n               \"                           []()\\n\"\n               \"                           {\\n\"\n               \"                             return Call([]() {});\\n\"\n               \"                           });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\n      \"FctWithLongLineInLambda_SLS_Empty(\\n\"\n      \"    []()\\n\"\n      \"    {\\n\"\n      \"      return HereAVeryLongLine(ThatWillBeFormatted, OnMultipleLine,\\n\"\n      \"                               AndShouldNotBeConsiderAsInline,\\n\"\n      \"                               LambdaBodyMustBeBreak);\\n\"\n      \"    });\",\n      LLVMWithBeforeLambdaBody);\n\n  LLVMWithBeforeLambdaBody.AllowShortLambdasOnASingleLine =\n      FormatStyle::ShortLambdaStyle::SLS_Inline;\n  verifyFormat(\"FctWithOneNestedLambdaInline_SLS_Inline([]() { return 17; });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"FctWithOneNestedLambdaEmpty_SLS_Inline([]() {});\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"auto fct_SLS_Inline = []()\\n\"\n               \"{\\n\"\n               \"  return 17;\\n\"\n               \"};\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"TwoNestedLambdas_SLS_Inline([]() { return Call([]() { return \"\n               \"17; }); });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\n      \"FctWithLongLineInLambda_SLS_Inline(\\n\"\n      \"    []()\\n\"\n      \"    {\\n\"\n      \"      return HereAVeryLongLine(ThatWillBeFormatted, OnMultipleLine,\\n\"\n      \"                               AndShouldNotBeConsiderAsInline,\\n\"\n      \"                               LambdaBodyMustBeBreak);\\n\"\n      \"    });\",\n      LLVMWithBeforeLambdaBody);\n  verifyFormat(\"FctWithMultipleParams_SLS_Inline(\"\n               \"VeryLongParameterThatShouldAskToBeOnMultiLine,\\n\"\n               \"                                 []() { return 17; });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\n      \"FctWithMultipleParams_SLS_Inline(FirstParam, []() { return 17; });\",\n      LLVMWithBeforeLambdaBody);\n\n  LLVMWithBeforeLambdaBody.AllowShortLambdasOnASingleLine =\n      FormatStyle::ShortLambdaStyle::SLS_All;\n  verifyFormat(\"FctWithOneNestedLambdaInline_SLS_All([]() { return 17; });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"FctWithOneNestedLambdaEmpty_SLS_All([]() {});\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"auto fct_SLS_All = []() { return 17; };\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"FctWithOneParam_SLS_All(\\n\"\n               \"    []()\\n\"\n               \"    {\\n\"\n               \"      // A cool function...\\n\"\n               \"      return 43;\\n\"\n               \"    });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"FctWithMultipleParams_SLS_All(\"\n               \"VeryLongParameterThatShouldAskToBeOnMultiLine,\\n\"\n               \"                              []() { return 17; });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"FctWithMultipleParams_SLS_All(A, []() { return 17; });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"FctWithMultipleParams_SLS_All(A, B, []() { return 17; });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\n      \"FctWithLongLineInLambda_SLS_All(\\n\"\n      \"    []()\\n\"\n      \"    {\\n\"\n      \"      return HereAVeryLongLine(ThatWillBeFormatted, OnMultipleLine,\\n\"\n      \"                               AndShouldNotBeConsiderAsInline,\\n\"\n      \"                               LambdaBodyMustBeBreak);\\n\"\n      \"    });\",\n      LLVMWithBeforeLambdaBody);\n  verifyFormat(\n      \"auto fct_SLS_All = []()\\n\"\n      \"{\\n\"\n      \"  return HereAVeryLongLine(ThatWillBeFormatted, OnMultipleLine,\\n\"\n      \"                           AndShouldNotBeConsiderAsInline,\\n\"\n      \"                           LambdaBodyMustBeBreak);\\n\"\n      \"};\",\n      LLVMWithBeforeLambdaBody);\n  LLVMWithBeforeLambdaBody.BinPackParameters = false;\n  verifyFormat(\"FctAllOnSameLine_SLS_All([]() { return S; }, Fst, Second);\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\n      \"FctWithLongLineInLambda_SLS_All([]() { return SomeValueNotSoLong; },\\n\"\n      \"                                FirstParam,\\n\"\n      \"                                SecondParam,\\n\"\n      \"                                ThirdParam,\\n\"\n      \"                                FourthParam);\",\n      LLVMWithBeforeLambdaBody);\n  verifyFormat(\"FctWithLongLineInLambda_SLS_All(\\n\"\n               \"    []() { return \"\n               \"SomeValueVeryVeryVeryVeryVeryVeryVeryVeryVeryLong; },\\n\"\n               \"    FirstParam,\\n\"\n               \"    SecondParam,\\n\"\n               \"    ThirdParam,\\n\"\n               \"    FourthParam);\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\n      \"FctWithLongLineInLambda_SLS_All(FirstParam,\\n\"\n      \"                                SecondParam,\\n\"\n      \"                                ThirdParam,\\n\"\n      \"                                FourthParam,\\n\"\n      \"                                []() { return SomeValueNotSoLong; });\",\n      LLVMWithBeforeLambdaBody);\n  verifyFormat(\"FctWithLongLineInLambda_SLS_All(\\n\"\n               \"    []()\\n\"\n               \"    {\\n\"\n               \"      return \"\n               \"HereAVeryLongLineThatWillBeFormattedOnMultipleLineAndShouldNotB\"\n               \"eConsiderAsInline;\\n\"\n               \"    });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\n      \"FctWithLongLineInLambda_SLS_All(\\n\"\n      \"    []()\\n\"\n      \"    {\\n\"\n      \"      return HereAVeryLongLine(ThatWillBeFormatted, OnMultipleLine,\\n\"\n      \"                               AndShouldNotBeConsiderAsInline,\\n\"\n      \"                               LambdaBodyMustBeBreak);\\n\"\n      \"    });\",\n      LLVMWithBeforeLambdaBody);\n  verifyFormat(\"FctWithTwoParams_SLS_All(\\n\"\n               \"    []()\\n\"\n               \"    {\\n\"\n               \"      // A cool function...\\n\"\n               \"      return 43;\\n\"\n               \"    },\\n\"\n               \"    87);\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"FctWithTwoParams_SLS_All([]() { return 43; }, 87);\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"FctWithOneNestedLambdas_SLS_All([]() { return 17; });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\n      \"TwoNestedLambdas_SLS_All([]() { return Call([]() { return 17; }); });\",\n      LLVMWithBeforeLambdaBody);\n  verifyFormat(\"TwoNestedLambdas_SLS_All([]() { return Call([]() { return 17; \"\n               \"}); }, x);\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"TwoNestedLambdas_SLS_All(\\n\"\n               \"    []()\\n\"\n               \"    {\\n\"\n               \"      // A cool function...\\n\"\n               \"      return Call([]() { return 17; });\\n\"\n               \"    });\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"TwoNestedLambdas_SLS_All(\\n\"\n               \"    []()\\n\"\n               \"    {\\n\"\n               \"      return Call(\\n\"\n               \"          []()\\n\"\n               \"          {\\n\"\n               \"            // A cool function...\\n\"\n               \"            return 17;\\n\"\n               \"          });\\n\"\n               \"    });\",\n               LLVMWithBeforeLambdaBody);\n}\n\nTEST_F(FormatTest, LambdaWithLineComments) {\n  FormatStyle LLVMWithBeforeLambdaBody = getLLVMStyle();\n  LLVMWithBeforeLambdaBody.BreakBeforeBraces = FormatStyle::BS_Custom;\n  LLVMWithBeforeLambdaBody.BraceWrapping.BeforeLambdaBody = true;\n  LLVMWithBeforeLambdaBody.AllowShortLambdasOnASingleLine =\n      FormatStyle::ShortLambdaStyle::SLS_All;\n\n  verifyFormat(\"auto k = []() { return; }\", LLVMWithBeforeLambdaBody);\n  verifyFormat(\"auto k = []() // comment\\n\"\n               \"{ return; }\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"auto k = []() /* comment */ { return; }\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"auto k = []() /* comment */ /* comment */ { return; }\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\"auto k = []() // X\\n\"\n               \"{ return; }\",\n               LLVMWithBeforeLambdaBody);\n  verifyFormat(\n      \"auto k = []() // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\\n\"\n      \"{ return; }\",\n      LLVMWithBeforeLambdaBody);\n}\n\nTEST_F(FormatTest, EmptyLinesInLambdas) {\n  verifyFormat(\"auto lambda = []() {\\n\"\n               \"  x(); //\\n\"\n               \"};\",\n               \"auto lambda = []() {\\n\"\n               \"\\n\"\n               \"  x(); //\\n\"\n               \"\\n\"\n               \"};\");\n}\n\nTEST_F(FormatTest, FormatsBlocks) {\n  FormatStyle ShortBlocks = getLLVMStyle();\n  ShortBlocks.AllowShortBlocksOnASingleLine = FormatStyle::SBS_Always;\n  verifyFormat(\"int (^Block)(int, int);\", ShortBlocks);\n  verifyFormat(\"int (^Block1)(int, int) = ^(int i, int j)\", ShortBlocks);\n  verifyFormat(\"void (^block)(int) = ^(id test) { int i; };\", ShortBlocks);\n  verifyFormat(\"void (^block)(int) = ^(int test) { int i; };\", ShortBlocks);\n  verifyFormat(\"void (^block)(int) = ^id(int test) { int i; };\", ShortBlocks);\n  verifyFormat(\"void (^block)(int) = ^int(int test) { int i; };\", ShortBlocks);\n\n  verifyFormat(\"foo(^{ bar(); });\", ShortBlocks);\n  verifyFormat(\"foo(a, ^{ bar(); });\", ShortBlocks);\n  verifyFormat(\"{ void (^block)(Object *x); }\", ShortBlocks);\n\n  verifyFormat(\"[operation setCompletionBlock:^{\\n\"\n               \"  [self onOperationDone];\\n\"\n               \"}];\");\n  verifyFormat(\"int i = {[operation setCompletionBlock:^{\\n\"\n               \"  [self onOperationDone];\\n\"\n               \"}]};\");\n  verifyFormat(\"[operation setCompletionBlock:^(int *i) {\\n\"\n               \"  f();\\n\"\n               \"}];\");\n  verifyFormat(\"int a = [operation block:^int(int *i) {\\n\"\n               \"  return 1;\\n\"\n               \"}];\");\n  verifyFormat(\"[myObject doSomethingWith:arg1\\n\"\n               \"                      aaa:^int(int *a) {\\n\"\n               \"                        return 1;\\n\"\n               \"                      }\\n\"\n               \"                      bbb:f(a * bbbbbbbb)];\");\n\n  verifyFormat(\"[operation setCompletionBlock:^{\\n\"\n               \"  [self.delegate newDataAvailable];\\n\"\n               \"}];\",\n               getLLVMStyleWithColumns(60));\n  verifyFormat(\"dispatch_async(_fileIOQueue, ^{\\n\"\n               \"  NSString *path = [self sessionFilePath];\\n\"\n               \"  if (path) {\\n\"\n               \"    // ...\\n\"\n               \"  }\\n\"\n               \"});\");\n  verifyFormat(\"[[SessionService sharedService]\\n\"\n               \"    loadWindowWithCompletionBlock:^(SessionWindow *window) {\\n\"\n               \"      if (window) {\\n\"\n               \"        [self windowDidLoad:window];\\n\"\n               \"      } else {\\n\"\n               \"        [self errorLoadingWindow];\\n\"\n               \"      }\\n\"\n               \"    }];\");\n  verifyFormat(\"void (^largeBlock)(void) = ^{\\n\"\n               \"  // ...\\n\"\n               \"};\\n\",\n               getLLVMStyleWithColumns(40));\n  verifyFormat(\"[[SessionService sharedService]\\n\"\n               \"    loadWindowWithCompletionBlock: //\\n\"\n               \"        ^(SessionWindow *window) {\\n\"\n               \"          if (window) {\\n\"\n               \"            [self windowDidLoad:window];\\n\"\n               \"          } else {\\n\"\n               \"            [self errorLoadingWindow];\\n\"\n               \"          }\\n\"\n               \"        }];\",\n               getLLVMStyleWithColumns(60));\n  verifyFormat(\"[myObject doSomethingWith:arg1\\n\"\n               \"    firstBlock:^(Foo *a) {\\n\"\n               \"      // ...\\n\"\n               \"      int i;\\n\"\n               \"    }\\n\"\n               \"    secondBlock:^(Bar *b) {\\n\"\n               \"      // ...\\n\"\n               \"      int i;\\n\"\n               \"    }\\n\"\n               \"    thirdBlock:^Foo(Bar *b) {\\n\"\n               \"      // ...\\n\"\n               \"      int i;\\n\"\n               \"    }];\");\n  verifyFormat(\"[myObject doSomethingWith:arg1\\n\"\n               \"               firstBlock:-1\\n\"\n               \"              secondBlock:^(Bar *b) {\\n\"\n               \"                // ...\\n\"\n               \"                int i;\\n\"\n               \"              }];\");\n\n  verifyFormat(\"f(^{\\n\"\n               \"  @autoreleasepool {\\n\"\n               \"    if (a) {\\n\"\n               \"      g();\\n\"\n               \"    }\\n\"\n               \"  }\\n\"\n               \"});\");\n  verifyFormat(\"Block b = ^int *(A *a, B *b) {}\");\n  verifyFormat(\"BOOL (^aaa)(void) = ^BOOL {\\n\"\n               \"};\");\n\n  FormatStyle FourIndent = getLLVMStyle();\n  FourIndent.ObjCBlockIndentWidth = 4;\n  verifyFormat(\"[operation setCompletionBlock:^{\\n\"\n               \"    [self onOperationDone];\\n\"\n               \"}];\",\n               FourIndent);\n}\n\nTEST_F(FormatTest, FormatsBlocksWithZeroColumnWidth) {\n  FormatStyle ZeroColumn = getLLVMStyle();\n  ZeroColumn.ColumnLimit = 0;\n\n  verifyFormat(\"[[SessionService sharedService] \"\n               \"loadWindowWithCompletionBlock:^(SessionWindow *window) {\\n\"\n               \"  if (window) {\\n\"\n               \"    [self windowDidLoad:window];\\n\"\n               \"  } else {\\n\"\n               \"    [self errorLoadingWindow];\\n\"\n               \"  }\\n\"\n               \"}];\",\n               ZeroColumn);\n  EXPECT_EQ(\"[[SessionService sharedService]\\n\"\n            \"    loadWindowWithCompletionBlock:^(SessionWindow *window) {\\n\"\n            \"      if (window) {\\n\"\n            \"        [self windowDidLoad:window];\\n\"\n            \"      } else {\\n\"\n            \"        [self errorLoadingWindow];\\n\"\n            \"      }\\n\"\n            \"    }];\",\n            format(\"[[SessionService sharedService]\\n\"\n                   \"loadWindowWithCompletionBlock:^(SessionWindow *window) {\\n\"\n                   \"                if (window) {\\n\"\n                   \"    [self windowDidLoad:window];\\n\"\n                   \"  } else {\\n\"\n                   \"    [self errorLoadingWindow];\\n\"\n                   \"  }\\n\"\n                   \"}];\",\n                   ZeroColumn));\n  verifyFormat(\"[myObject doSomethingWith:arg1\\n\"\n               \"    firstBlock:^(Foo *a) {\\n\"\n               \"      // ...\\n\"\n               \"      int i;\\n\"\n               \"    }\\n\"\n               \"    secondBlock:^(Bar *b) {\\n\"\n               \"      // ...\\n\"\n               \"      int i;\\n\"\n               \"    }\\n\"\n               \"    thirdBlock:^Foo(Bar *b) {\\n\"\n               \"      // ...\\n\"\n               \"      int i;\\n\"\n               \"    }];\",\n               ZeroColumn);\n  verifyFormat(\"f(^{\\n\"\n               \"  @autoreleasepool {\\n\"\n               \"    if (a) {\\n\"\n               \"      g();\\n\"\n               \"    }\\n\"\n               \"  }\\n\"\n               \"});\",\n               ZeroColumn);\n  verifyFormat(\"void (^largeBlock)(void) = ^{\\n\"\n               \"  // ...\\n\"\n               \"};\",\n               ZeroColumn);\n\n  ZeroColumn.AllowShortBlocksOnASingleLine = FormatStyle::SBS_Always;\n  EXPECT_EQ(\"void (^largeBlock)(void) = ^{ int i; };\",\n            format(\"void   (^largeBlock)(void) = ^{ int   i; };\", ZeroColumn));\n  ZeroColumn.AllowShortBlocksOnASingleLine = FormatStyle::SBS_Never;\n  EXPECT_EQ(\"void (^largeBlock)(void) = ^{\\n\"\n            \"  int i;\\n\"\n            \"};\",\n            format(\"void   (^largeBlock)(void) = ^{ int   i; };\", ZeroColumn));\n}\n\nTEST_F(FormatTest, SupportsCRLF) {\n  EXPECT_EQ(\"int a;\\r\\n\"\n            \"int b;\\r\\n\"\n            \"int c;\\r\\n\",\n            format(\"int a;\\r\\n\"\n                   \"  int b;\\r\\n\"\n                   \"    int c;\\r\\n\",\n                   getLLVMStyle()));\n  EXPECT_EQ(\"int a;\\r\\n\"\n            \"int b;\\r\\n\"\n            \"int c;\\r\\n\",\n            format(\"int a;\\r\\n\"\n                   \"  int b;\\n\"\n                   \"    int c;\\r\\n\",\n                   getLLVMStyle()));\n  EXPECT_EQ(\"int a;\\n\"\n            \"int b;\\n\"\n            \"int c;\\n\",\n            format(\"int a;\\r\\n\"\n                   \"  int b;\\n\"\n                   \"    int c;\\n\",\n                   getLLVMStyle()));\n  EXPECT_EQ(\"\\\"aaaaaaa \\\"\\r\\n\"\n            \"\\\"bbbbbbb\\\";\\r\\n\",\n            format(\"\\\"aaaaaaa bbbbbbb\\\";\\r\\n\", getLLVMStyleWithColumns(10)));\n  EXPECT_EQ(\"#define A \\\\\\r\\n\"\n            \"  b;      \\\\\\r\\n\"\n            \"  c;      \\\\\\r\\n\"\n            \"  d;\\r\\n\",\n            format(\"#define A \\\\\\r\\n\"\n                   \"  b; \\\\\\r\\n\"\n                   \"  c; d; \\r\\n\",\n                   getGoogleStyle()));\n\n  EXPECT_EQ(\"/*\\r\\n\"\n            \"multi line block comments\\r\\n\"\n            \"should not introduce\\r\\n\"\n            \"an extra carriage return\\r\\n\"\n            \"*/\\r\\n\",\n            format(\"/*\\r\\n\"\n                   \"multi line block comments\\r\\n\"\n                   \"should not introduce\\r\\n\"\n                   \"an extra carriage return\\r\\n\"\n                   \"*/\\r\\n\"));\n  EXPECT_EQ(\"/*\\r\\n\"\n            \"\\r\\n\"\n            \"*/\",\n            format(\"/*\\r\\n\"\n                   \"    \\r\\r\\r\\n\"\n                   \"*/\"));\n\n  FormatStyle style = getLLVMStyle();\n\n  style.DeriveLineEnding = true;\n  style.UseCRLF = false;\n  EXPECT_EQ(\"union FooBarBazQux {\\n\"\n            \"  int foo;\\n\"\n            \"  int bar;\\n\"\n            \"  int baz;\\n\"\n            \"};\",\n            format(\"union FooBarBazQux {\\r\\n\"\n                   \"  int foo;\\n\"\n                   \"  int bar;\\r\\n\"\n                   \"  int baz;\\n\"\n                   \"};\",\n                   style));\n  style.UseCRLF = true;\n  EXPECT_EQ(\"union FooBarBazQux {\\r\\n\"\n            \"  int foo;\\r\\n\"\n            \"  int bar;\\r\\n\"\n            \"  int baz;\\r\\n\"\n            \"};\",\n            format(\"union FooBarBazQux {\\r\\n\"\n                   \"  int foo;\\n\"\n                   \"  int bar;\\r\\n\"\n                   \"  int baz;\\n\"\n                   \"};\",\n                   style));\n\n  style.DeriveLineEnding = false;\n  style.UseCRLF = false;\n  EXPECT_EQ(\"union FooBarBazQux {\\n\"\n            \"  int foo;\\n\"\n            \"  int bar;\\n\"\n            \"  int baz;\\n\"\n            \"  int qux;\\n\"\n            \"};\",\n            format(\"union FooBarBazQux {\\r\\n\"\n                   \"  int foo;\\n\"\n                   \"  int bar;\\r\\n\"\n                   \"  int baz;\\n\"\n                   \"  int qux;\\r\\n\"\n                   \"};\",\n                   style));\n  style.UseCRLF = true;\n  EXPECT_EQ(\"union FooBarBazQux {\\r\\n\"\n            \"  int foo;\\r\\n\"\n            \"  int bar;\\r\\n\"\n            \"  int baz;\\r\\n\"\n            \"  int qux;\\r\\n\"\n            \"};\",\n            format(\"union FooBarBazQux {\\r\\n\"\n                   \"  int foo;\\n\"\n                   \"  int bar;\\r\\n\"\n                   \"  int baz;\\n\"\n                   \"  int qux;\\n\"\n                   \"};\",\n                   style));\n\n  style.DeriveLineEnding = true;\n  style.UseCRLF = false;\n  EXPECT_EQ(\"union FooBarBazQux {\\r\\n\"\n            \"  int foo;\\r\\n\"\n            \"  int bar;\\r\\n\"\n            \"  int baz;\\r\\n\"\n            \"  int qux;\\r\\n\"\n            \"};\",\n            format(\"union FooBarBazQux {\\r\\n\"\n                   \"  int foo;\\n\"\n                   \"  int bar;\\r\\n\"\n                   \"  int baz;\\n\"\n                   \"  int qux;\\r\\n\"\n                   \"};\",\n                   style));\n  style.UseCRLF = true;\n  EXPECT_EQ(\"union FooBarBazQux {\\n\"\n            \"  int foo;\\n\"\n            \"  int bar;\\n\"\n            \"  int baz;\\n\"\n            \"  int qux;\\n\"\n            \"};\",\n            format(\"union FooBarBazQux {\\r\\n\"\n                   \"  int foo;\\n\"\n                   \"  int bar;\\r\\n\"\n                   \"  int baz;\\n\"\n                   \"  int qux;\\n\"\n                   \"};\",\n                   style));\n}\n\nTEST_F(FormatTest, MunchSemicolonAfterBlocks) {\n  verifyFormat(\"MY_CLASS(C) {\\n\"\n               \"  int i;\\n\"\n               \"  int j;\\n\"\n               \"};\");\n}\n\nTEST_F(FormatTest, ConfigurableContinuationIndentWidth) {\n  FormatStyle TwoIndent = getLLVMStyleWithColumns(15);\n  TwoIndent.ContinuationIndentWidth = 2;\n\n  EXPECT_EQ(\"int i =\\n\"\n            \"  longFunction(\\n\"\n            \"    arg);\",\n            format(\"int i = longFunction(arg);\", TwoIndent));\n\n  FormatStyle SixIndent = getLLVMStyleWithColumns(20);\n  SixIndent.ContinuationIndentWidth = 6;\n\n  EXPECT_EQ(\"int i =\\n\"\n            \"      longFunction(\\n\"\n            \"            arg);\",\n            format(\"int i = longFunction(arg);\", SixIndent));\n}\n\nTEST_F(FormatTest, WrappedClosingParenthesisIndent) {\n  FormatStyle Style = getLLVMStyle();\n  verifyFormat(\"int Foo::getter(\\n\"\n               \"    //\\n\"\n               \") const {\\n\"\n               \"  return foo;\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"void Foo::setter(\\n\"\n               \"    //\\n\"\n               \") {\\n\"\n               \"  foo = 1;\\n\"\n               \"}\",\n               Style);\n}\n\nTEST_F(FormatTest, SpacesInAngles) {\n  FormatStyle Spaces = getLLVMStyle();\n  Spaces.SpacesInAngles = true;\n\n  verifyFormat(\"static_cast< int >(arg);\", Spaces);\n  verifyFormat(\"template < typename T0, typename T1 > void f() {}\", Spaces);\n  verifyFormat(\"f< int, float >();\", Spaces);\n  verifyFormat(\"template <> g() {}\", Spaces);\n  verifyFormat(\"template < std::vector< int > > f() {}\", Spaces);\n  verifyFormat(\"std::function< void(int, int) > fct;\", Spaces);\n  verifyFormat(\"void inFunction() { std::function< void(int, int) > fct; }\",\n               Spaces);\n\n  Spaces.Standard = FormatStyle::LS_Cpp03;\n  Spaces.SpacesInAngles = true;\n  verifyFormat(\"A< A< int > >();\", Spaces);\n\n  Spaces.SpacesInAngles = false;\n  verifyFormat(\"A<A<int> >();\", Spaces);\n\n  Spaces.Standard = FormatStyle::LS_Cpp11;\n  Spaces.SpacesInAngles = true;\n  verifyFormat(\"A< A< int > >();\", Spaces);\n\n  Spaces.SpacesInAngles = false;\n  verifyFormat(\"A<A<int>>();\", Spaces);\n}\n\nTEST_F(FormatTest, SpaceAfterTemplateKeyword) {\n  FormatStyle Style = getLLVMStyle();\n  Style.SpaceAfterTemplateKeyword = false;\n  verifyFormat(\"template<int> void foo();\", Style);\n}\n\nTEST_F(FormatTest, TripleAngleBrackets) {\n  verifyFormat(\"f<<<1, 1>>>();\");\n  verifyFormat(\"f<<<1, 1, 1, s>>>();\");\n  verifyFormat(\"f<<<a, b, c, d>>>();\");\n  EXPECT_EQ(\"f<<<1, 1>>>();\", format(\"f <<< 1, 1 >>> ();\"));\n  verifyFormat(\"f<param><<<1, 1>>>();\");\n  verifyFormat(\"f<1><<<1, 1>>>();\");\n  EXPECT_EQ(\"f<param><<<1, 1>>>();\", format(\"f< param > <<< 1, 1 >>> ();\"));\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n               \"aaaaaaaaaaa<<<\\n    1, 1>>>();\");\n  verifyFormat(\"aaaaaaaaaaaaaaa<aaaaaaaaa, aaaaaaaaaa, aaaaaaaaaaaaaa>\\n\"\n               \"    <<<aaaaaaaaa, aaaaaaaaaa, aaaaaaaaaaaaaaaaaa>>>();\");\n}\n\nTEST_F(FormatTest, MergeLessLessAtEnd) {\n  verifyFormat(\"<<\");\n  EXPECT_EQ(\"< < <\", format(\"\\\\\\n<<<\"));\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n               \"aaallvm::outs() <<\");\n  verifyFormat(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n               \"aaaallvm::outs()\\n    <<\");\n}\n\nTEST_F(FormatTest, HandleUnbalancedImplicitBracesAcrossPPBranches) {\n  std::string code = \"#if A\\n\"\n                     \"#if B\\n\"\n                     \"a.\\n\"\n                     \"#endif\\n\"\n                     \"    a = 1;\\n\"\n                     \"#else\\n\"\n                     \"#endif\\n\"\n                     \"#if C\\n\"\n                     \"#else\\n\"\n                     \"#endif\\n\";\n  EXPECT_EQ(code, format(code));\n}\n\nTEST_F(FormatTest, HandleConflictMarkers) {\n  // Git/SVN conflict markers.\n  EXPECT_EQ(\"int a;\\n\"\n            \"void f() {\\n\"\n            \"  callme(some(parameter1,\\n\"\n            \"<<<<<<< text by the vcs\\n\"\n            \"              parameter2),\\n\"\n            \"||||||| text by the vcs\\n\"\n            \"              parameter2),\\n\"\n            \"         parameter3,\\n\"\n            \"======= text by the vcs\\n\"\n            \"              parameter2, parameter3),\\n\"\n            \">>>>>>> text by the vcs\\n\"\n            \"         otherparameter);\\n\",\n            format(\"int a;\\n\"\n                   \"void f() {\\n\"\n                   \"  callme(some(parameter1,\\n\"\n                   \"<<<<<<< text by the vcs\\n\"\n                   \"  parameter2),\\n\"\n                   \"||||||| text by the vcs\\n\"\n                   \"  parameter2),\\n\"\n                   \"  parameter3,\\n\"\n                   \"======= text by the vcs\\n\"\n                   \"  parameter2,\\n\"\n                   \"  parameter3),\\n\"\n                   \">>>>>>> text by the vcs\\n\"\n                   \"  otherparameter);\\n\"));\n\n  // Perforce markers.\n  EXPECT_EQ(\"void f() {\\n\"\n            \"  function(\\n\"\n            \">>>> text by the vcs\\n\"\n            \"      parameter,\\n\"\n            \"==== text by the vcs\\n\"\n            \"      parameter,\\n\"\n            \"==== text by the vcs\\n\"\n            \"      parameter,\\n\"\n            \"<<<< text by the vcs\\n\"\n            \"      parameter);\\n\",\n            format(\"void f() {\\n\"\n                   \"  function(\\n\"\n                   \">>>> text by the vcs\\n\"\n                   \"  parameter,\\n\"\n                   \"==== text by the vcs\\n\"\n                   \"  parameter,\\n\"\n                   \"==== text by the vcs\\n\"\n                   \"  parameter,\\n\"\n                   \"<<<< text by the vcs\\n\"\n                   \"  parameter);\\n\"));\n\n  EXPECT_EQ(\"<<<<<<<\\n\"\n            \"|||||||\\n\"\n            \"=======\\n\"\n            \">>>>>>>\",\n            format(\"<<<<<<<\\n\"\n                   \"|||||||\\n\"\n                   \"=======\\n\"\n                   \">>>>>>>\"));\n\n  EXPECT_EQ(\"<<<<<<<\\n\"\n            \"|||||||\\n\"\n            \"int i;\\n\"\n            \"=======\\n\"\n            \">>>>>>>\",\n            format(\"<<<<<<<\\n\"\n                   \"|||||||\\n\"\n                   \"int i;\\n\"\n                   \"=======\\n\"\n                   \">>>>>>>\"));\n\n  // FIXME: Handle parsing of macros around conflict markers correctly:\n  EXPECT_EQ(\"#define Macro \\\\\\n\"\n            \"<<<<<<<\\n\"\n            \"Something \\\\\\n\"\n            \"|||||||\\n\"\n            \"Else \\\\\\n\"\n            \"=======\\n\"\n            \"Other \\\\\\n\"\n            \">>>>>>>\\n\"\n            \"    End int i;\\n\",\n            format(\"#define Macro \\\\\\n\"\n                   \"<<<<<<<\\n\"\n                   \"  Something \\\\\\n\"\n                   \"|||||||\\n\"\n                   \"  Else \\\\\\n\"\n                   \"=======\\n\"\n                   \"  Other \\\\\\n\"\n                   \">>>>>>>\\n\"\n                   \"  End\\n\"\n                   \"int i;\\n\"));\n}\n\nTEST_F(FormatTest, DisableRegions) {\n  EXPECT_EQ(\"int i;\\n\"\n            \"// clang-format off\\n\"\n            \"  int j;\\n\"\n            \"// clang-format on\\n\"\n            \"int k;\",\n            format(\" int  i;\\n\"\n                   \"   // clang-format off\\n\"\n                   \"  int j;\\n\"\n                   \" // clang-format on\\n\"\n                   \"   int   k;\"));\n  EXPECT_EQ(\"int i;\\n\"\n            \"/* clang-format off */\\n\"\n            \"  int j;\\n\"\n            \"/* clang-format on */\\n\"\n            \"int k;\",\n            format(\" int  i;\\n\"\n                   \"   /* clang-format off */\\n\"\n                   \"  int j;\\n\"\n                   \" /* clang-format on */\\n\"\n                   \"   int   k;\"));\n\n  // Don't reflow comments within disabled regions.\n  EXPECT_EQ(\"// clang-format off\\n\"\n            \"// long long long long long long line\\n\"\n            \"/* clang-format on */\\n\"\n            \"/* long long long\\n\"\n            \" * long long long\\n\"\n            \" * line */\\n\"\n            \"int i;\\n\"\n            \"/* clang-format off */\\n\"\n            \"/* long long long long long long line */\\n\",\n            format(\"// clang-format off\\n\"\n                   \"// long long long long long long line\\n\"\n                   \"/* clang-format on */\\n\"\n                   \"/* long long long long long long line */\\n\"\n                   \"int i;\\n\"\n                   \"/* clang-format off */\\n\"\n                   \"/* long long long long long long line */\\n\",\n                   getLLVMStyleWithColumns(20)));\n}\n\nTEST_F(FormatTest, DoNotCrashOnInvalidInput) {\n  format(\"? ) =\");\n  verifyNoCrash(\"#define a\\\\\\n /**/}\");\n}\n\nTEST_F(FormatTest, FormatsTableGenCode) {\n  FormatStyle Style = getLLVMStyle();\n  Style.Language = FormatStyle::LK_TableGen;\n  verifyFormat(\"include \\\"a.td\\\"\\ninclude \\\"b.td\\\"\", Style);\n}\n\nTEST_F(FormatTest, ArrayOfTemplates) {\n  EXPECT_EQ(\"auto a = new unique_ptr<int>[10];\",\n            format(\"auto a = new unique_ptr<int > [ 10];\"));\n\n  FormatStyle Spaces = getLLVMStyle();\n  Spaces.SpacesInSquareBrackets = true;\n  EXPECT_EQ(\"auto a = new unique_ptr<int>[ 10 ];\",\n            format(\"auto a = new unique_ptr<int > [10];\", Spaces));\n}\n\nTEST_F(FormatTest, ArrayAsTemplateType) {\n  EXPECT_EQ(\"auto a = unique_ptr<Foo<Bar>[10]>;\",\n            format(\"auto a = unique_ptr < Foo < Bar>[ 10]> ;\"));\n\n  FormatStyle Spaces = getLLVMStyle();\n  Spaces.SpacesInSquareBrackets = true;\n  EXPECT_EQ(\"auto a = unique_ptr<Foo<Bar>[ 10 ]>;\",\n            format(\"auto a = unique_ptr < Foo < Bar>[10]> ;\", Spaces));\n}\n\nTEST_F(FormatTest, NoSpaceAfterSuper) { verifyFormat(\"__super::FooBar();\"); }\n\nTEST(FormatStyle, GetStyleWithEmptyFileName) {\n  llvm::vfs::InMemoryFileSystem FS;\n  auto Style1 = getStyle(\"file\", \"\", \"Google\", \"\", &FS);\n  ASSERT_TRUE((bool)Style1);\n  ASSERT_EQ(*Style1, getGoogleStyle());\n}\n\nTEST(FormatStyle, GetStyleOfFile) {\n  llvm::vfs::InMemoryFileSystem FS;\n  // Test 1: format file in the same directory.\n  ASSERT_TRUE(\n      FS.addFile(\"/a/.clang-format\", 0,\n                 llvm::MemoryBuffer::getMemBuffer(\"BasedOnStyle: LLVM\")));\n  ASSERT_TRUE(\n      FS.addFile(\"/a/test.cpp\", 0, llvm::MemoryBuffer::getMemBuffer(\"int i;\")));\n  auto Style1 = getStyle(\"file\", \"/a/.clang-format\", \"Google\", \"\", &FS);\n  ASSERT_TRUE((bool)Style1);\n  ASSERT_EQ(*Style1, getLLVMStyle());\n\n  // Test 2.1: fallback to default.\n  ASSERT_TRUE(\n      FS.addFile(\"/b/test.cpp\", 0, llvm::MemoryBuffer::getMemBuffer(\"int i;\")));\n  auto Style2 = getStyle(\"file\", \"/b/test.cpp\", \"Mozilla\", \"\", &FS);\n  ASSERT_TRUE((bool)Style2);\n  ASSERT_EQ(*Style2, getMozillaStyle());\n\n  // Test 2.2: no format on 'none' fallback style.\n  Style2 = getStyle(\"file\", \"/b/test.cpp\", \"none\", \"\", &FS);\n  ASSERT_TRUE((bool)Style2);\n  ASSERT_EQ(*Style2, getNoStyle());\n\n  // Test 2.3: format if config is found with no based style while fallback is\n  // 'none'.\n  ASSERT_TRUE(FS.addFile(\"/b/.clang-format\", 0,\n                         llvm::MemoryBuffer::getMemBuffer(\"IndentWidth: 2\")));\n  Style2 = getStyle(\"file\", \"/b/test.cpp\", \"none\", \"\", &FS);\n  ASSERT_TRUE((bool)Style2);\n  ASSERT_EQ(*Style2, getLLVMStyle());\n\n  // Test 2.4: format if yaml with no based style, while fallback is 'none'.\n  Style2 = getStyle(\"{}\", \"a.h\", \"none\", \"\", &FS);\n  ASSERT_TRUE((bool)Style2);\n  ASSERT_EQ(*Style2, getLLVMStyle());\n\n  // Test 3: format file in parent directory.\n  ASSERT_TRUE(\n      FS.addFile(\"/c/.clang-format\", 0,\n                 llvm::MemoryBuffer::getMemBuffer(\"BasedOnStyle: Google\")));\n  ASSERT_TRUE(FS.addFile(\"/c/sub/sub/sub/test.cpp\", 0,\n                         llvm::MemoryBuffer::getMemBuffer(\"int i;\")));\n  auto Style3 = getStyle(\"file\", \"/c/sub/sub/sub/test.cpp\", \"LLVM\", \"\", &FS);\n  ASSERT_TRUE((bool)Style3);\n  ASSERT_EQ(*Style3, getGoogleStyle());\n\n  // Test 4: error on invalid fallback style\n  auto Style4 = getStyle(\"file\", \"a.h\", \"KungFu\", \"\", &FS);\n  ASSERT_FALSE((bool)Style4);\n  llvm::consumeError(Style4.takeError());\n\n  // Test 5: error on invalid yaml on command line\n  auto Style5 = getStyle(\"{invalid_key=invalid_value}\", \"a.h\", \"LLVM\", \"\", &FS);\n  ASSERT_FALSE((bool)Style5);\n  llvm::consumeError(Style5.takeError());\n\n  // Test 6: error on invalid style\n  auto Style6 = getStyle(\"KungFu\", \"a.h\", \"LLVM\", \"\", &FS);\n  ASSERT_FALSE((bool)Style6);\n  llvm::consumeError(Style6.takeError());\n\n  // Test 7: found config file, error on parsing it\n  ASSERT_TRUE(\n      FS.addFile(\"/d/.clang-format\", 0,\n                 llvm::MemoryBuffer::getMemBuffer(\"BasedOnStyle: LLVM\\n\"\n                                                  \"InvalidKey: InvalidValue\")));\n  ASSERT_TRUE(\n      FS.addFile(\"/d/test.cpp\", 0, llvm::MemoryBuffer::getMemBuffer(\"int i;\")));\n  auto Style7a = getStyle(\"file\", \"/d/.clang-format\", \"LLVM\", \"\", &FS);\n  ASSERT_FALSE((bool)Style7a);\n  llvm::consumeError(Style7a.takeError());\n\n  auto Style7b = getStyle(\"file\", \"/d/.clang-format\", \"LLVM\", \"\", &FS, true);\n  ASSERT_TRUE((bool)Style7b);\n\n  // Test 8: inferred per-language defaults apply.\n  auto StyleTd = getStyle(\"file\", \"x.td\", \"llvm\", \"\", &FS);\n  ASSERT_TRUE((bool)StyleTd);\n  ASSERT_EQ(*StyleTd, getLLVMStyle(FormatStyle::LK_TableGen));\n\n  // Test 9.1: overwriting a file style, when parent no file exists with no\n  // fallback style\n  ASSERT_TRUE(FS.addFile(\n      \"/e/sub/.clang-format\", 0,\n      llvm::MemoryBuffer::getMemBuffer(\"BasedOnStyle: InheritParentConfig\\n\"\n                                       \"ColumnLimit: 20\")));\n  ASSERT_TRUE(FS.addFile(\"/e/sub/code.cpp\", 0,\n                         llvm::MemoryBuffer::getMemBuffer(\"int i;\")));\n  auto Style9 = getStyle(\"file\", \"/e/sub/code.cpp\", \"none\", \"\", &FS);\n  ASSERT_TRUE(static_cast<bool>(Style9));\n  ASSERT_EQ(*Style9, [] {\n    auto Style = getNoStyle();\n    Style.ColumnLimit = 20;\n    return Style;\n  }());\n\n  // Test 9.2: with LLVM fallback style\n  Style9 = getStyle(\"file\", \"/e/sub/code.cpp\", \"LLVM\", \"\", &FS);\n  ASSERT_TRUE(static_cast<bool>(Style9));\n  ASSERT_EQ(*Style9, [] {\n    auto Style = getLLVMStyle();\n    Style.ColumnLimit = 20;\n    return Style;\n  }());\n\n  // Test 9.3: with a parent file\n  ASSERT_TRUE(\n      FS.addFile(\"/e/.clang-format\", 0,\n                 llvm::MemoryBuffer::getMemBuffer(\"BasedOnStyle: Google\\n\"\n                                                  \"UseTab: Always\")));\n  Style9 = getStyle(\"file\", \"/e/sub/code.cpp\", \"none\", \"\", &FS);\n  ASSERT_TRUE(static_cast<bool>(Style9));\n  ASSERT_EQ(*Style9, [] {\n    auto Style = getGoogleStyle();\n    Style.ColumnLimit = 20;\n    Style.UseTab = FormatStyle::UT_Always;\n    return Style;\n  }());\n\n  // Test 9.4: propagate more than one level\n  ASSERT_TRUE(FS.addFile(\"/e/sub/sub/code.cpp\", 0,\n                         llvm::MemoryBuffer::getMemBuffer(\"int i;\")));\n  ASSERT_TRUE(FS.addFile(\"/e/sub/sub/.clang-format\", 0,\n                         llvm::MemoryBuffer::getMemBuffer(\n                             \"BasedOnStyle: InheritParentConfig\\n\"\n                             \"WhitespaceSensitiveMacros: ['FOO', 'BAR']\")));\n  std::vector<std::string> NonDefaultWhiteSpaceMacros{\"FOO\", \"BAR\"};\n\n  const auto SubSubStyle = [&NonDefaultWhiteSpaceMacros] {\n    auto Style = getGoogleStyle();\n    Style.ColumnLimit = 20;\n    Style.UseTab = FormatStyle::UT_Always;\n    Style.WhitespaceSensitiveMacros = NonDefaultWhiteSpaceMacros;\n    return Style;\n  }();\n\n  ASSERT_NE(Style9->WhitespaceSensitiveMacros, NonDefaultWhiteSpaceMacros);\n  Style9 = getStyle(\"file\", \"/e/sub/sub/code.cpp\", \"none\", \"\", &FS);\n  ASSERT_TRUE(static_cast<bool>(Style9));\n  ASSERT_EQ(*Style9, SubSubStyle);\n\n  // Test 9.5: use InheritParentConfig as style name\n  Style9 =\n      getStyle(\"inheritparentconfig\", \"/e/sub/sub/code.cpp\", \"none\", \"\", &FS);\n  ASSERT_TRUE(static_cast<bool>(Style9));\n  ASSERT_EQ(*Style9, SubSubStyle);\n\n  // Test 9.6: use command line style with inheritance\n  Style9 = getStyle(\"{BasedOnStyle: InheritParentConfig}\", \"/e/sub/code.cpp\",\n                    \"none\", \"\", &FS);\n  ASSERT_TRUE(static_cast<bool>(Style9));\n  ASSERT_EQ(*Style9, SubSubStyle);\n\n  // Test 9.7: use command line style with inheritance and own config\n  Style9 = getStyle(\"{BasedOnStyle: InheritParentConfig, \"\n                    \"WhitespaceSensitiveMacros: ['FOO', 'BAR']}\",\n                    \"/e/sub/code.cpp\", \"none\", \"\", &FS);\n  ASSERT_TRUE(static_cast<bool>(Style9));\n  ASSERT_EQ(*Style9, SubSubStyle);\n\n  // Test 9.8: use inheritance from a file without BasedOnStyle\n  ASSERT_TRUE(FS.addFile(\"/e/withoutbase/.clang-format\", 0,\n                         llvm::MemoryBuffer::getMemBuffer(\"ColumnLimit: 123\")));\n  ASSERT_TRUE(\n      FS.addFile(\"/e/withoutbase/sub/.clang-format\", 0,\n                 llvm::MemoryBuffer::getMemBuffer(\n                     \"BasedOnStyle: InheritParentConfig\\nIndentWidth: 7\")));\n  // Make sure we do not use the fallback style\n  Style9 = getStyle(\"file\", \"/e/withoutbase/code.cpp\", \"google\", \"\", &FS);\n  ASSERT_TRUE(static_cast<bool>(Style9));\n  ASSERT_EQ(*Style9, [] {\n    auto Style = getLLVMStyle();\n    Style.ColumnLimit = 123;\n    return Style;\n  }());\n\n  Style9 = getStyle(\"file\", \"/e/withoutbase/sub/code.cpp\", \"google\", \"\", &FS);\n  ASSERT_TRUE(static_cast<bool>(Style9));\n  ASSERT_EQ(*Style9, [] {\n    auto Style = getLLVMStyle();\n    Style.ColumnLimit = 123;\n    Style.IndentWidth = 7;\n    return Style;\n  }());\n}\n\nTEST_F(ReplacementTest, FormatCodeAfterReplacements) {\n  // Column limit is 20.\n  std::string Code = \"Type *a =\\n\"\n                     \"    new Type();\\n\"\n                     \"g(iiiii, 0, jjjjj,\\n\"\n                     \"  0, kkkkk, 0, mm);\\n\"\n                     \"int  bad     = format   ;\";\n  std::string Expected = \"auto a = new Type();\\n\"\n                         \"g(iiiii, nullptr,\\n\"\n                         \"  jjjjj, nullptr,\\n\"\n                         \"  kkkkk, nullptr,\\n\"\n                         \"  mm);\\n\"\n                         \"int  bad     = format   ;\";\n  FileID ID = Context.createInMemoryFile(\"format.cpp\", Code);\n  tooling::Replacements Replaces = toReplacements(\n      {tooling::Replacement(Context.Sources, Context.getLocation(ID, 1, 1), 6,\n                            \"auto \"),\n       tooling::Replacement(Context.Sources, Context.getLocation(ID, 3, 10), 1,\n                            \"nullptr\"),\n       tooling::Replacement(Context.Sources, Context.getLocation(ID, 4, 3), 1,\n                            \"nullptr\"),\n       tooling::Replacement(Context.Sources, Context.getLocation(ID, 4, 13), 1,\n                            \"nullptr\")});\n\n  format::FormatStyle Style = format::getLLVMStyle();\n  Style.ColumnLimit = 20; // Set column limit to 20 to increase readibility.\n  auto FormattedReplaces = formatReplacements(Code, Replaces, Style);\n  EXPECT_TRUE(static_cast<bool>(FormattedReplaces))\n      << llvm::toString(FormattedReplaces.takeError()) << \"\\n\";\n  auto Result = applyAllReplacements(Code, *FormattedReplaces);\n  EXPECT_TRUE(static_cast<bool>(Result));\n  EXPECT_EQ(Expected, *Result);\n}\n\nTEST_F(ReplacementTest, SortIncludesAfterReplacement) {\n  std::string Code = \"#include \\\"a.h\\\"\\n\"\n                     \"#include \\\"c.h\\\"\\n\"\n                     \"\\n\"\n                     \"int main() {\\n\"\n                     \"  return 0;\\n\"\n                     \"}\";\n  std::string Expected = \"#include \\\"a.h\\\"\\n\"\n                         \"#include \\\"b.h\\\"\\n\"\n                         \"#include \\\"c.h\\\"\\n\"\n                         \"\\n\"\n                         \"int main() {\\n\"\n                         \"  return 0;\\n\"\n                         \"}\";\n  FileID ID = Context.createInMemoryFile(\"fix.cpp\", Code);\n  tooling::Replacements Replaces = toReplacements(\n      {tooling::Replacement(Context.Sources, Context.getLocation(ID, 1, 1), 0,\n                            \"#include \\\"b.h\\\"\\n\")});\n\n  format::FormatStyle Style = format::getLLVMStyle();\n  Style.SortIncludes = FormatStyle::SI_CaseSensitive;\n  auto FormattedReplaces = formatReplacements(Code, Replaces, Style);\n  EXPECT_TRUE(static_cast<bool>(FormattedReplaces))\n      << llvm::toString(FormattedReplaces.takeError()) << \"\\n\";\n  auto Result = applyAllReplacements(Code, *FormattedReplaces);\n  EXPECT_TRUE(static_cast<bool>(Result));\n  EXPECT_EQ(Expected, *Result);\n}\n\nTEST_F(FormatTest, FormatSortsUsingDeclarations) {\n  EXPECT_EQ(\"using std::cin;\\n\"\n            \"using std::cout;\",\n            format(\"using std::cout;\\n\"\n                   \"using std::cin;\",\n                   getGoogleStyle()));\n}\n\nTEST_F(FormatTest, UTF8CharacterLiteralCpp03) {\n  format::FormatStyle Style = format::getLLVMStyle();\n  Style.Standard = FormatStyle::LS_Cpp03;\n  // cpp03 recognize this string as identifier u8 and literal character 'a'\n  EXPECT_EQ(\"auto c = u8 'a';\", format(\"auto c = u8'a';\", Style));\n}\n\nTEST_F(FormatTest, UTF8CharacterLiteralCpp11) {\n  // u8'a' is a C++17 feature, utf8 literal character, LS_Cpp11 covers\n  // all modes, including C++11, C++14 and C++17\n  EXPECT_EQ(\"auto c = u8'a';\", format(\"auto c = u8'a';\"));\n}\n\nTEST_F(FormatTest, DoNotFormatLikelyXml) {\n  EXPECT_EQ(\"<!-- ;> -->\", format(\"<!-- ;> -->\", getGoogleStyle()));\n  EXPECT_EQ(\" <!-- >; -->\", format(\" <!-- >; -->\", getGoogleStyle()));\n}\n\nTEST_F(FormatTest, StructuredBindings) {\n  // Structured bindings is a C++17 feature.\n  // all modes, including C++11, C++14 and C++17\n  verifyFormat(\"auto [a, b] = f();\");\n  EXPECT_EQ(\"auto [a, b] = f();\", format(\"auto[a, b] = f();\"));\n  EXPECT_EQ(\"const auto [a, b] = f();\", format(\"const   auto[a, b] = f();\"));\n  EXPECT_EQ(\"auto const [a, b] = f();\", format(\"auto  const[a, b] = f();\"));\n  EXPECT_EQ(\"auto const volatile [a, b] = f();\",\n            format(\"auto  const   volatile[a, b] = f();\"));\n  EXPECT_EQ(\"auto [a, b, c] = f();\", format(\"auto   [  a  ,  b,c   ] = f();\"));\n  EXPECT_EQ(\"auto &[a, b, c] = f();\",\n            format(\"auto   &[  a  ,  b,c   ] = f();\"));\n  EXPECT_EQ(\"auto &&[a, b, c] = f();\",\n            format(\"auto   &&[  a  ,  b,c   ] = f();\"));\n  EXPECT_EQ(\"auto const &[a, b] = f();\", format(\"auto  const&[a, b] = f();\"));\n  EXPECT_EQ(\"auto const volatile &&[a, b] = f();\",\n            format(\"auto  const  volatile  &&[a, b] = f();\"));\n  EXPECT_EQ(\"auto const &&[a, b] = f();\",\n            format(\"auto  const   &&  [a, b] = f();\"));\n  EXPECT_EQ(\"const auto &[a, b] = f();\",\n            format(\"const  auto  &  [a, b] = f();\"));\n  EXPECT_EQ(\"const auto volatile &&[a, b] = f();\",\n            format(\"const  auto   volatile  &&[a, b] = f();\"));\n  EXPECT_EQ(\"volatile const auto &&[a, b] = f();\",\n            format(\"volatile  const  auto   &&[a, b] = f();\"));\n  EXPECT_EQ(\"const auto &&[a, b] = f();\",\n            format(\"const  auto  &&  [a, b] = f();\"));\n\n  // Make sure we don't mistake structured bindings for lambdas.\n  FormatStyle PointerMiddle = getLLVMStyle();\n  PointerMiddle.PointerAlignment = FormatStyle::PAS_Middle;\n  verifyFormat(\"auto [a1, b]{A * i};\", getGoogleStyle());\n  verifyFormat(\"auto [a2, b]{A * i};\", getLLVMStyle());\n  verifyFormat(\"auto [a3, b]{A * i};\", PointerMiddle);\n  verifyFormat(\"auto const [a1, b]{A * i};\", getGoogleStyle());\n  verifyFormat(\"auto const [a2, b]{A * i};\", getLLVMStyle());\n  verifyFormat(\"auto const [a3, b]{A * i};\", PointerMiddle);\n  verifyFormat(\"auto const& [a1, b]{A * i};\", getGoogleStyle());\n  verifyFormat(\"auto const &[a2, b]{A * i};\", getLLVMStyle());\n  verifyFormat(\"auto const & [a3, b]{A * i};\", PointerMiddle);\n  verifyFormat(\"auto const&& [a1, b]{A * i};\", getGoogleStyle());\n  verifyFormat(\"auto const &&[a2, b]{A * i};\", getLLVMStyle());\n  verifyFormat(\"auto const && [a3, b]{A * i};\", PointerMiddle);\n\n  EXPECT_EQ(\"for (const auto &&[a, b] : some_range) {\\n}\",\n            format(\"for (const auto   &&   [a, b] : some_range) {\\n}\"));\n  EXPECT_EQ(\"for (const auto &[a, b] : some_range) {\\n}\",\n            format(\"for (const auto   &   [a, b] : some_range) {\\n}\"));\n  EXPECT_EQ(\"for (const auto [a, b] : some_range) {\\n}\",\n            format(\"for (const auto[a, b] : some_range) {\\n}\"));\n  EXPECT_EQ(\"auto [x, y](expr);\", format(\"auto[x,y]  (expr);\"));\n  EXPECT_EQ(\"auto &[x, y](expr);\", format(\"auto  &  [x,y]  (expr);\"));\n  EXPECT_EQ(\"auto &&[x, y](expr);\", format(\"auto  &&  [x,y]  (expr);\"));\n  EXPECT_EQ(\"auto const &[x, y](expr);\",\n            format(\"auto  const  &  [x,y]  (expr);\"));\n  EXPECT_EQ(\"auto const &&[x, y](expr);\",\n            format(\"auto  const  &&  [x,y]  (expr);\"));\n  EXPECT_EQ(\"auto [x, y]{expr};\", format(\"auto[x,y]     {expr};\"));\n  EXPECT_EQ(\"auto const &[x, y]{expr};\",\n            format(\"auto  const  &  [x,y]  {expr};\"));\n  EXPECT_EQ(\"auto const &&[x, y]{expr};\",\n            format(\"auto  const  &&  [x,y]  {expr};\"));\n\n  format::FormatStyle Spaces = format::getLLVMStyle();\n  Spaces.SpacesInSquareBrackets = true;\n  verifyFormat(\"auto [ a, b ] = f();\", Spaces);\n  verifyFormat(\"auto &&[ a, b ] = f();\", Spaces);\n  verifyFormat(\"auto &[ a, b ] = f();\", Spaces);\n  verifyFormat(\"auto const &&[ a, b ] = f();\", Spaces);\n  verifyFormat(\"auto const &[ a, b ] = f();\", Spaces);\n}\n\nTEST_F(FormatTest, FileAndCode) {\n  EXPECT_EQ(FormatStyle::LK_Cpp, guessLanguage(\"foo.cc\", \"\"));\n  EXPECT_EQ(FormatStyle::LK_ObjC, guessLanguage(\"foo.m\", \"\"));\n  EXPECT_EQ(FormatStyle::LK_ObjC, guessLanguage(\"foo.mm\", \"\"));\n  EXPECT_EQ(FormatStyle::LK_Cpp, guessLanguage(\"foo.h\", \"\"));\n  EXPECT_EQ(FormatStyle::LK_ObjC,\n            guessLanguage(\"foo.h\", \"@interface Foo\\n@end\\n\"));\n  EXPECT_EQ(\n      FormatStyle::LK_ObjC,\n      guessLanguage(\"foo.h\", \"#define TRY(x, y) @try { x; } @finally { y; }\"));\n  EXPECT_EQ(FormatStyle::LK_ObjC,\n            guessLanguage(\"foo.h\", \"#define AVAIL(x) @available(x, *))\"));\n  EXPECT_EQ(FormatStyle::LK_ObjC, guessLanguage(\"foo.h\", \"@class Foo;\"));\n  EXPECT_EQ(FormatStyle::LK_Cpp, guessLanguage(\"foo\", \"\"));\n  EXPECT_EQ(FormatStyle::LK_ObjC,\n            guessLanguage(\"foo\", \"@interface Foo\\n@end\\n\"));\n  EXPECT_EQ(FormatStyle::LK_ObjC,\n            guessLanguage(\"foo.h\", \"int DoStuff(CGRect rect);\\n\"));\n  EXPECT_EQ(\n      FormatStyle::LK_ObjC,\n      guessLanguage(\"foo.h\",\n                    \"#define MY_POINT_MAKE(x, y) CGPointMake((x), (y));\\n\"));\n  EXPECT_EQ(\n      FormatStyle::LK_Cpp,\n      guessLanguage(\"foo.h\", \"#define FOO(...) auto bar = [] __VA_ARGS__;\"));\n}\n\nTEST_F(FormatTest, GuessLanguageWithCpp11AttributeSpecifiers) {\n  EXPECT_EQ(FormatStyle::LK_Cpp, guessLanguage(\"foo.h\", \"[[noreturn]];\"));\n  EXPECT_EQ(FormatStyle::LK_ObjC,\n            guessLanguage(\"foo.h\", \"array[[calculator getIndex]];\"));\n  EXPECT_EQ(FormatStyle::LK_Cpp,\n            guessLanguage(\"foo.h\", \"[[noreturn, deprecated(\\\"so sorry\\\")]];\"));\n  EXPECT_EQ(\n      FormatStyle::LK_Cpp,\n      guessLanguage(\"foo.h\", \"[[noreturn, deprecated(\\\"gone, sorry\\\")]];\"));\n  EXPECT_EQ(FormatStyle::LK_ObjC,\n            guessLanguage(\"foo.h\", \"[[noreturn foo] bar];\"));\n  EXPECT_EQ(FormatStyle::LK_Cpp,\n            guessLanguage(\"foo.h\", \"[[clang::fallthrough]];\"));\n  EXPECT_EQ(FormatStyle::LK_ObjC,\n            guessLanguage(\"foo.h\", \"[[clang:fallthrough] foo];\"));\n  EXPECT_EQ(FormatStyle::LK_Cpp,\n            guessLanguage(\"foo.h\", \"[[gsl::suppress(\\\"type\\\")]];\"));\n  EXPECT_EQ(FormatStyle::LK_Cpp,\n            guessLanguage(\"foo.h\", \"[[using clang: fallthrough]];\"));\n  EXPECT_EQ(FormatStyle::LK_ObjC,\n            guessLanguage(\"foo.h\", \"[[abusing clang:fallthrough] bar];\"));\n  EXPECT_EQ(FormatStyle::LK_Cpp,\n            guessLanguage(\"foo.h\", \"[[using gsl: suppress(\\\"type\\\")]];\"));\n  EXPECT_EQ(\n      FormatStyle::LK_Cpp,\n      guessLanguage(\"foo.h\", \"for (auto &&[endpoint, stream] : streams_)\"));\n  EXPECT_EQ(\n      FormatStyle::LK_Cpp,\n      guessLanguage(\"foo.h\",\n                    \"[[clang::callable_when(\\\"unconsumed\\\", \\\"unknown\\\")]]\"));\n  EXPECT_EQ(FormatStyle::LK_Cpp, guessLanguage(\"foo.h\", \"[[foo::bar, ...]]\"));\n}\n\nTEST_F(FormatTest, GuessLanguageWithCaret) {\n  EXPECT_EQ(FormatStyle::LK_Cpp, guessLanguage(\"foo.h\", \"FOO(^);\"));\n  EXPECT_EQ(FormatStyle::LK_Cpp, guessLanguage(\"foo.h\", \"FOO(^, Bar);\"));\n  EXPECT_EQ(FormatStyle::LK_ObjC,\n            guessLanguage(\"foo.h\", \"int(^)(char, float);\"));\n  EXPECT_EQ(FormatStyle::LK_ObjC,\n            guessLanguage(\"foo.h\", \"int(^foo)(char, float);\"));\n  EXPECT_EQ(FormatStyle::LK_ObjC,\n            guessLanguage(\"foo.h\", \"int(^foo[10])(char, float);\"));\n  EXPECT_EQ(FormatStyle::LK_ObjC,\n            guessLanguage(\"foo.h\", \"int(^foo[kNumEntries])(char, float);\"));\n  EXPECT_EQ(\n      FormatStyle::LK_ObjC,\n      guessLanguage(\"foo.h\", \"int(^foo[(kNumEntries + 10)])(char, float);\"));\n}\n\nTEST_F(FormatTest, GuessLanguageWithPragmas) {\n  EXPECT_EQ(FormatStyle::LK_Cpp,\n            guessLanguage(\"foo.h\", \"__pragma(warning(disable:))\"));\n  EXPECT_EQ(FormatStyle::LK_Cpp,\n            guessLanguage(\"foo.h\", \"#pragma(warning(disable:))\"));\n  EXPECT_EQ(FormatStyle::LK_Cpp,\n            guessLanguage(\"foo.h\", \"_Pragma(warning(disable:))\"));\n}\n\nTEST_F(FormatTest, FormatsInlineAsmSymbolicNames) {\n  // ASM symbolic names are identifiers that must be surrounded by [] without\n  // space in between:\n  // https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#InputOperands\n\n  // Example from https://bugs.llvm.org/show_bug.cgi?id=45108.\n  verifyFormat(R\"(//\nasm volatile(\"mrs %x[result], FPCR\" : [result] \"=r\"(result));\n)\");\n\n  // A list of several ASM symbolic names.\n  verifyFormat(R\"(asm(\"mov %[e], %[d]\" : [d] \"=rm\"(d), [e] \"rm\"(*e));)\");\n\n  // ASM symbolic names in inline ASM with inputs and outputs.\n  verifyFormat(R\"(//\nasm(\"cmoveq %1, %2, %[result]\"\n    : [result] \"=r\"(result)\n    : \"r\"(test), \"r\"(new), \"[result]\"(old));\n)\");\n\n  // ASM symbolic names in inline ASM with no outputs.\n  verifyFormat(R\"(asm(\"mov %[e], %[d]\" : : [d] \"=rm\"(d), [e] \"rm\"(*e));)\");\n}\n\nTEST_F(FormatTest, GuessedLanguageWithInlineAsmClobbers) {\n  EXPECT_EQ(FormatStyle::LK_Cpp,\n            guessLanguage(\"foo.h\", \"void f() {\\n\"\n                                   \"  asm (\\\"mov %[e], %[d]\\\"\\n\"\n                                   \"     : [d] \\\"=rm\\\" (d)\\n\"\n                                   \"       [e] \\\"rm\\\" (*e));\\n\"\n                                   \"}\"));\n  EXPECT_EQ(FormatStyle::LK_Cpp,\n            guessLanguage(\"foo.h\", \"void f() {\\n\"\n                                   \"  _asm (\\\"mov %[e], %[d]\\\"\\n\"\n                                   \"     : [d] \\\"=rm\\\" (d)\\n\"\n                                   \"       [e] \\\"rm\\\" (*e));\\n\"\n                                   \"}\"));\n  EXPECT_EQ(FormatStyle::LK_Cpp,\n            guessLanguage(\"foo.h\", \"void f() {\\n\"\n                                   \"  __asm (\\\"mov %[e], %[d]\\\"\\n\"\n                                   \"     : [d] \\\"=rm\\\" (d)\\n\"\n                                   \"       [e] \\\"rm\\\" (*e));\\n\"\n                                   \"}\"));\n  EXPECT_EQ(FormatStyle::LK_Cpp,\n            guessLanguage(\"foo.h\", \"void f() {\\n\"\n                                   \"  __asm__ (\\\"mov %[e], %[d]\\\"\\n\"\n                                   \"     : [d] \\\"=rm\\\" (d)\\n\"\n                                   \"       [e] \\\"rm\\\" (*e));\\n\"\n                                   \"}\"));\n  EXPECT_EQ(FormatStyle::LK_Cpp,\n            guessLanguage(\"foo.h\", \"void f() {\\n\"\n                                   \"  asm (\\\"mov %[e], %[d]\\\"\\n\"\n                                   \"     : [d] \\\"=rm\\\" (d),\\n\"\n                                   \"       [e] \\\"rm\\\" (*e));\\n\"\n                                   \"}\"));\n  EXPECT_EQ(FormatStyle::LK_Cpp,\n            guessLanguage(\"foo.h\", \"void f() {\\n\"\n                                   \"  asm volatile (\\\"mov %[e], %[d]\\\"\\n\"\n                                   \"     : [d] \\\"=rm\\\" (d)\\n\"\n                                   \"       [e] \\\"rm\\\" (*e));\\n\"\n                                   \"}\"));\n}\n\nTEST_F(FormatTest, GuessLanguageWithChildLines) {\n  EXPECT_EQ(FormatStyle::LK_Cpp,\n            guessLanguage(\"foo.h\", \"#define FOO ({ std::string s; })\"));\n  EXPECT_EQ(FormatStyle::LK_ObjC,\n            guessLanguage(\"foo.h\", \"#define FOO ({ NSString *s; })\"));\n  EXPECT_EQ(\n      FormatStyle::LK_Cpp,\n      guessLanguage(\"foo.h\", \"#define FOO ({ foo(); ({ std::string s; }) })\"));\n  EXPECT_EQ(\n      FormatStyle::LK_ObjC,\n      guessLanguage(\"foo.h\", \"#define FOO ({ foo(); ({ NSString *s; }) })\"));\n}\n\nTEST_F(FormatTest, TypenameMacros) {\n  std::vector<std::string> TypenameMacros = {\"STACK_OF\", \"LIST\", \"TAILQ_ENTRY\"};\n\n  // Test case reported in https://bugs.llvm.org/show_bug.cgi?id=30353\n  FormatStyle Google = getGoogleStyleWithColumns(0);\n  Google.TypenameMacros = TypenameMacros;\n  verifyFormat(\"struct foo {\\n\"\n               \"  int bar;\\n\"\n               \"  TAILQ_ENTRY(a) bleh;\\n\"\n               \"};\",\n               Google);\n\n  FormatStyle Macros = getLLVMStyle();\n  Macros.TypenameMacros = TypenameMacros;\n\n  verifyFormat(\"STACK_OF(int) a;\", Macros);\n  verifyFormat(\"STACK_OF(int) *a;\", Macros);\n  verifyFormat(\"STACK_OF(int const *) *a;\", Macros);\n  verifyFormat(\"STACK_OF(int *const) *a;\", Macros);\n  verifyFormat(\"STACK_OF(int, string) a;\", Macros);\n  verifyFormat(\"STACK_OF(LIST(int)) a;\", Macros);\n  verifyFormat(\"STACK_OF(LIST(int)) a, b;\", Macros);\n  verifyFormat(\"for (LIST(int) *a = NULL; a;) {\\n}\", Macros);\n  verifyFormat(\"STACK_OF(int) f(LIST(int) *arg);\", Macros);\n  verifyFormat(\"vector<LIST(uint64_t) *attr> x;\", Macros);\n  verifyFormat(\"vector<LIST(uint64_t) *const> f(LIST(uint64_t) *arg);\", Macros);\n\n  Macros.PointerAlignment = FormatStyle::PAS_Left;\n  verifyFormat(\"STACK_OF(int)* a;\", Macros);\n  verifyFormat(\"STACK_OF(int*)* a;\", Macros);\n  verifyFormat(\"x = (STACK_OF(uint64_t))*a;\", Macros);\n  verifyFormat(\"x = (STACK_OF(uint64_t))&a;\", Macros);\n  verifyFormat(\"vector<STACK_OF(uint64_t)* attr> x;\", Macros);\n}\n\nTEST_F(FormatTest, AtomicQualifier) {\n  // Check that we treate _Atomic as a type and not a function call\n  FormatStyle Google = getGoogleStyleWithColumns(0);\n  verifyFormat(\"struct foo {\\n\"\n               \"  int a1;\\n\"\n               \"  _Atomic(a) a2;\\n\"\n               \"  _Atomic(_Atomic(int) *const) a3;\\n\"\n               \"};\",\n               Google);\n  verifyFormat(\"_Atomic(uint64_t) a;\");\n  verifyFormat(\"_Atomic(uint64_t) *a;\");\n  verifyFormat(\"_Atomic(uint64_t const *) *a;\");\n  verifyFormat(\"_Atomic(uint64_t *const) *a;\");\n  verifyFormat(\"_Atomic(const uint64_t *) *a;\");\n  verifyFormat(\"_Atomic(uint64_t) a;\");\n  verifyFormat(\"_Atomic(_Atomic(uint64_t)) a;\");\n  verifyFormat(\"_Atomic(_Atomic(uint64_t)) a, b;\");\n  verifyFormat(\"for (_Atomic(uint64_t) *a = NULL; a;) {\\n}\");\n  verifyFormat(\"_Atomic(uint64_t) f(_Atomic(uint64_t) *arg);\");\n\n  verifyFormat(\"_Atomic(uint64_t) *s(InitValue);\");\n  verifyFormat(\"_Atomic(uint64_t) *s{InitValue};\");\n  FormatStyle Style = getLLVMStyle();\n  Style.PointerAlignment = FormatStyle::PAS_Left;\n  verifyFormat(\"_Atomic(uint64_t)* s(InitValue);\", Style);\n  verifyFormat(\"_Atomic(uint64_t)* s{InitValue};\", Style);\n  verifyFormat(\"_Atomic(int)* a;\", Style);\n  verifyFormat(\"_Atomic(int*)* a;\", Style);\n  verifyFormat(\"vector<_Atomic(uint64_t)* attr> x;\", Style);\n\n  Style.SpacesInCStyleCastParentheses = true;\n  Style.SpacesInParentheses = false;\n  verifyFormat(\"x = ( _Atomic(uint64_t) )*a;\", Style);\n  Style.SpacesInCStyleCastParentheses = false;\n  Style.SpacesInParentheses = true;\n  verifyFormat(\"x = (_Atomic( uint64_t ))*a;\", Style);\n  verifyFormat(\"x = (_Atomic( uint64_t ))&a;\", Style);\n}\n\nTEST_F(FormatTest, AmbersandInLamda) {\n  // Test case reported in https://bugs.llvm.org/show_bug.cgi?id=41899\n  FormatStyle AlignStyle = getLLVMStyle();\n  AlignStyle.PointerAlignment = FormatStyle::PAS_Left;\n  verifyFormat(\"auto lambda = [&a = a]() { a = 2; };\", AlignStyle);\n  AlignStyle.PointerAlignment = FormatStyle::PAS_Right;\n  verifyFormat(\"auto lambda = [&a = a]() { a = 2; };\", AlignStyle);\n}\n\nTEST_F(FormatTest, SpacesInConditionalStatement) {\n  FormatStyle Spaces = getLLVMStyle();\n  Spaces.SpacesInConditionalStatement = true;\n  verifyFormat(\"for ( int i = 0; i; i++ )\\n  continue;\", Spaces);\n  verifyFormat(\"if ( !a )\\n  return;\", Spaces);\n  verifyFormat(\"if ( a )\\n  return;\", Spaces);\n  verifyFormat(\"if constexpr ( a )\\n  return;\", Spaces);\n  verifyFormat(\"switch ( a )\\ncase 1:\\n  return;\", Spaces);\n  verifyFormat(\"while ( a )\\n  return;\", Spaces);\n  verifyFormat(\"while ( (a && b) )\\n  return;\", Spaces);\n  verifyFormat(\"do {\\n} while ( 1 != 0 );\", Spaces);\n  verifyFormat(\"try {\\n} catch ( const std::exception & ) {\\n}\", Spaces);\n  // Check that space on the left of \"::\" is inserted as expected at beginning\n  // of condition.\n  verifyFormat(\"while ( ::func() )\\n  return;\", Spaces);\n}\n\nTEST_F(FormatTest, AlternativeOperators) {\n  // Test case for ensuring alternate operators are not\n  // combined with their right most neighbour.\n  verifyFormat(\"int a and b;\");\n  verifyFormat(\"int a and_eq b;\");\n  verifyFormat(\"int a bitand b;\");\n  verifyFormat(\"int a bitor b;\");\n  verifyFormat(\"int a compl b;\");\n  verifyFormat(\"int a not b;\");\n  verifyFormat(\"int a not_eq b;\");\n  verifyFormat(\"int a or b;\");\n  verifyFormat(\"int a xor b;\");\n  verifyFormat(\"int a xor_eq b;\");\n  verifyFormat(\"return this not_eq bitand other;\");\n  verifyFormat(\"bool operator not_eq(const X bitand other)\");\n\n  verifyFormat(\"int a and 5;\");\n  verifyFormat(\"int a and_eq 5;\");\n  verifyFormat(\"int a bitand 5;\");\n  verifyFormat(\"int a bitor 5;\");\n  verifyFormat(\"int a compl 5;\");\n  verifyFormat(\"int a not 5;\");\n  verifyFormat(\"int a not_eq 5;\");\n  verifyFormat(\"int a or 5;\");\n  verifyFormat(\"int a xor 5;\");\n  verifyFormat(\"int a xor_eq 5;\");\n\n  verifyFormat(\"int a compl(5);\");\n  verifyFormat(\"int a not(5);\");\n\n  /* FIXME handle alternate tokens\n   * https://en.cppreference.com/w/cpp/language/operator_alternative\n  // alternative tokens\n  verifyFormat(\"compl foo();\");     //  ~foo();\n  verifyFormat(\"foo() <%%>;\");      // foo();\n  verifyFormat(\"void foo() <%%>;\"); // void foo(){}\n  verifyFormat(\"int a <:1:>;\");     // int a[1];[\n  verifyFormat(\"%:define ABC abc\"); // #define ABC abc\n  verifyFormat(\"%:%:\");             // ##\n  */\n}\n\nTEST_F(FormatTest, STLWhileNotDefineChed) {\n  verifyFormat(\"#if defined(while)\\n\"\n               \"#define while EMIT WARNING C4005\\n\"\n               \"#endif // while\");\n}\n\nTEST_F(FormatTest, OperatorSpacing) {\n  FormatStyle Style = getLLVMStyle();\n  Style.PointerAlignment = FormatStyle::PAS_Right;\n  verifyFormat(\"Foo::operator*();\", Style);\n  verifyFormat(\"Foo::operator void *();\", Style);\n  verifyFormat(\"Foo::operator void **();\", Style);\n  verifyFormat(\"Foo::operator void *&();\", Style);\n  verifyFormat(\"Foo::operator void *&&();\", Style);\n  verifyFormat(\"Foo::operator()(void *);\", Style);\n  verifyFormat(\"Foo::operator*(void *);\", Style);\n  verifyFormat(\"Foo::operator*();\", Style);\n  verifyFormat(\"Foo::operator**();\", Style);\n  verifyFormat(\"Foo::operator&();\", Style);\n  verifyFormat(\"Foo::operator<int> *();\", Style);\n  verifyFormat(\"Foo::operator<Foo> *();\", Style);\n  verifyFormat(\"Foo::operator<int> **();\", Style);\n  verifyFormat(\"Foo::operator<Foo> **();\", Style);\n  verifyFormat(\"Foo::operator<int> &();\", Style);\n  verifyFormat(\"Foo::operator<Foo> &();\", Style);\n  verifyFormat(\"Foo::operator<int> &&();\", Style);\n  verifyFormat(\"Foo::operator<Foo> &&();\", Style);\n  verifyFormat(\"Foo::operator<int> *&();\", Style);\n  verifyFormat(\"Foo::operator<Foo> *&();\", Style);\n  verifyFormat(\"Foo::operator<int> *&&();\", Style);\n  verifyFormat(\"Foo::operator<Foo> *&&();\", Style);\n  verifyFormat(\"operator*(int (*)(), class Foo);\", Style);\n\n  verifyFormat(\"Foo::operator&();\", Style);\n  verifyFormat(\"Foo::operator void &();\", Style);\n  verifyFormat(\"Foo::operator()(void &);\", Style);\n  verifyFormat(\"Foo::operator&(void &);\", Style);\n  verifyFormat(\"Foo::operator&();\", Style);\n  verifyFormat(\"operator&(int (&)(), class Foo);\", Style);\n\n  verifyFormat(\"Foo::operator&&();\", Style);\n  verifyFormat(\"Foo::operator**();\", Style);\n  verifyFormat(\"Foo::operator void &&();\", Style);\n  verifyFormat(\"Foo::operator()(void &&);\", Style);\n  verifyFormat(\"Foo::operator&&(void &&);\", Style);\n  verifyFormat(\"Foo::operator&&();\", Style);\n  verifyFormat(\"operator&&(int(&&)(), class Foo);\", Style);\n  verifyFormat(\"operator const nsTArrayRight<E> &()\", Style);\n  verifyFormat(\"[[nodiscard]] operator const nsTArrayRight<E, Allocator> &()\",\n               Style);\n  verifyFormat(\"operator void **()\", Style);\n  verifyFormat(\"operator const FooRight<Object> &()\", Style);\n  verifyFormat(\"operator const FooRight<Object> *()\", Style);\n  verifyFormat(\"operator const FooRight<Object> **()\", Style);\n  verifyFormat(\"operator const FooRight<Object> *&()\", Style);\n  verifyFormat(\"operator const FooRight<Object> *&&()\", Style);\n\n  Style.PointerAlignment = FormatStyle::PAS_Left;\n  verifyFormat(\"Foo::operator*();\", Style);\n  verifyFormat(\"Foo::operator**();\", Style);\n  verifyFormat(\"Foo::operator void*();\", Style);\n  verifyFormat(\"Foo::operator void**();\", Style);\n  verifyFormat(\"Foo::operator void*&();\", Style);\n  verifyFormat(\"Foo::operator/*comment*/ void*();\", Style);\n  verifyFormat(\"Foo::operator/*a*/ const /*b*/ void*();\", Style);\n  verifyFormat(\"Foo::operator/*a*/ volatile /*b*/ void*();\", Style);\n  verifyFormat(\"Foo::operator()(void*);\", Style);\n  verifyFormat(\"Foo::operator*(void*);\", Style);\n  verifyFormat(\"Foo::operator*();\", Style);\n  verifyFormat(\"Foo::operator<int>*();\", Style);\n  verifyFormat(\"Foo::operator<Foo>*();\", Style);\n  verifyFormat(\"Foo::operator<int>**();\", Style);\n  verifyFormat(\"Foo::operator<Foo>**();\", Style);\n  verifyFormat(\"Foo::operator<Foo>*&();\", Style);\n  verifyFormat(\"Foo::operator<int>&();\", Style);\n  verifyFormat(\"Foo::operator<Foo>&();\", Style);\n  verifyFormat(\"Foo::operator<int>&&();\", Style);\n  verifyFormat(\"Foo::operator<Foo>&&();\", Style);\n  verifyFormat(\"Foo::operator<int>*&();\", Style);\n  verifyFormat(\"Foo::operator<Foo>*&();\", Style);\n  verifyFormat(\"operator*(int (*)(), class Foo);\", Style);\n\n  verifyFormat(\"Foo::operator&();\", Style);\n  verifyFormat(\"Foo::operator void&();\", Style);\n  verifyFormat(\"Foo::operator/*comment*/ void&();\", Style);\n  verifyFormat(\"Foo::operator/*a*/ const /*b*/ void&();\", Style);\n  verifyFormat(\"Foo::operator/*a*/ volatile /*b*/ void&();\", Style);\n  verifyFormat(\"Foo::operator()(void&);\", Style);\n  verifyFormat(\"Foo::operator&(void&);\", Style);\n  verifyFormat(\"Foo::operator&();\", Style);\n  verifyFormat(\"operator&(int (&)(), class Foo);\", Style);\n\n  verifyFormat(\"Foo::operator&&();\", Style);\n  verifyFormat(\"Foo::operator void&&();\", Style);\n  verifyFormat(\"Foo::operator/*comment*/ void&&();\", Style);\n  verifyFormat(\"Foo::operator/*a*/ const /*b*/ void&&();\", Style);\n  verifyFormat(\"Foo::operator/*a*/ volatile /*b*/ void&&();\", Style);\n  verifyFormat(\"Foo::operator()(void&&);\", Style);\n  verifyFormat(\"Foo::operator&&(void&&);\", Style);\n  verifyFormat(\"Foo::operator&&();\", Style);\n  verifyFormat(\"operator&&(int(&&)(), class Foo);\", Style);\n  verifyFormat(\"operator const nsTArrayLeft<E>&()\", Style);\n  verifyFormat(\"[[nodiscard]] operator const nsTArrayLeft<E, Allocator>&()\",\n               Style);\n  verifyFormat(\"operator void**()\", Style);\n  verifyFormat(\"operator const FooLeft<Object>&()\", Style);\n  verifyFormat(\"operator const FooLeft<Object>*()\", Style);\n  verifyFormat(\"operator const FooLeft<Object>**()\", Style);\n  verifyFormat(\"operator const FooLeft<Object>*&()\", Style);\n  verifyFormat(\"operator const FooLeft<Object>*&&()\", Style);\n\n  // PR45107\n  verifyFormat(\"operator Vector<String>&();\", Style);\n  verifyFormat(\"operator const Vector<String>&();\", Style);\n  verifyFormat(\"operator foo::Bar*();\", Style);\n  verifyFormat(\"operator const Foo<X>::Bar<Y>*();\", Style);\n  verifyFormat(\"operator/*a*/ const /*b*/ Foo /*c*/<X> /*d*/ ::Bar<Y>*();\",\n               Style);\n\n  Style.PointerAlignment = FormatStyle::PAS_Middle;\n  verifyFormat(\"Foo::operator*();\", Style);\n  verifyFormat(\"Foo::operator void *();\", Style);\n  verifyFormat(\"Foo::operator()(void *);\", Style);\n  verifyFormat(\"Foo::operator*(void *);\", Style);\n  verifyFormat(\"Foo::operator*();\", Style);\n  verifyFormat(\"operator*(int (*)(), class Foo);\", Style);\n\n  verifyFormat(\"Foo::operator&();\", Style);\n  verifyFormat(\"Foo::operator void &();\", Style);\n  verifyFormat(\"Foo::operator()(void &);\", Style);\n  verifyFormat(\"Foo::operator&(void &);\", Style);\n  verifyFormat(\"Foo::operator&();\", Style);\n  verifyFormat(\"operator&(int (&)(), class Foo);\", Style);\n\n  verifyFormat(\"Foo::operator&&();\", Style);\n  verifyFormat(\"Foo::operator void &&();\", Style);\n  verifyFormat(\"Foo::operator()(void &&);\", Style);\n  verifyFormat(\"Foo::operator&&(void &&);\", Style);\n  verifyFormat(\"Foo::operator&&();\", Style);\n  verifyFormat(\"operator&&(int(&&)(), class Foo);\", Style);\n}\n\nTEST_F(FormatTest, OperatorPassedAsAFunctionPtr) {\n  FormatStyle Style = getLLVMStyle();\n  // PR46157\n  verifyFormat(\"foo(operator+, -42);\", Style);\n  verifyFormat(\"foo(operator++, -42);\", Style);\n  verifyFormat(\"foo(operator--, -42);\", Style);\n  verifyFormat(\"foo(-42, operator--);\", Style);\n  verifyFormat(\"foo(-42, operator, );\", Style);\n  verifyFormat(\"foo(operator, , -42);\", Style);\n}\n\nTEST_F(FormatTest, WhitespaceSensitiveMacros) {\n  FormatStyle Style = getLLVMStyle();\n  Style.WhitespaceSensitiveMacros.push_back(\"FOO\");\n\n  // Don't use the helpers here, since 'mess up' will change the whitespace\n  // and these are all whitespace sensitive by definition\n  EXPECT_EQ(\"FOO(String-ized&Messy+But(: :Still)=Intentional);\",\n            format(\"FOO(String-ized&Messy+But(: :Still)=Intentional);\", Style));\n  EXPECT_EQ(\n      \"FOO(String-ized&Messy+But\\\\(: :Still)=Intentional);\",\n      format(\"FOO(String-ized&Messy+But\\\\(: :Still)=Intentional);\", Style));\n  EXPECT_EQ(\"FOO(String-ized&Messy+But,: :Still=Intentional);\",\n            format(\"FOO(String-ized&Messy+But,: :Still=Intentional);\", Style));\n  EXPECT_EQ(\"FOO(String-ized&Messy+But,: :\\n\"\n            \"       Still=Intentional);\",\n            format(\"FOO(String-ized&Messy+But,: :\\n\"\n                   \"       Still=Intentional);\",\n                   Style));\n  Style.AlignConsecutiveAssignments = FormatStyle::ACS_Consecutive;\n  EXPECT_EQ(\"FOO(String-ized=&Messy+But,: :\\n\"\n            \"       Still=Intentional);\",\n            format(\"FOO(String-ized=&Messy+But,: :\\n\"\n                   \"       Still=Intentional);\",\n                   Style));\n\n  Style.ColumnLimit = 21;\n  EXPECT_EQ(\"FOO(String-ized&Messy+But: :Still=Intentional);\",\n            format(\"FOO(String-ized&Messy+But: :Still=Intentional);\", Style));\n}\n\nTEST_F(FormatTest, VeryLongNamespaceCommentSplit) {\n  // These tests are not in NamespaceFixer because that doesn't\n  // test its interaction with line wrapping\n  FormatStyle Style = getLLVMStyle();\n  Style.ColumnLimit = 80;\n  verifyFormat(\"namespace {\\n\"\n               \"int i;\\n\"\n               \"int j;\\n\"\n               \"} // namespace\",\n               Style);\n\n  verifyFormat(\"namespace AAA {\\n\"\n               \"int i;\\n\"\n               \"int j;\\n\"\n               \"} // namespace AAA\",\n               Style);\n\n  EXPECT_EQ(\"namespace Averyveryveryverylongnamespace {\\n\"\n            \"int i;\\n\"\n            \"int j;\\n\"\n            \"} // namespace Averyveryveryverylongnamespace\",\n            format(\"namespace Averyveryveryverylongnamespace {\\n\"\n                   \"int i;\\n\"\n                   \"int j;\\n\"\n                   \"}\",\n                   Style));\n\n  EXPECT_EQ(\n      \"namespace \"\n      \"would::it::save::you::a::lot::of::time::if_::i::just::gave::up::and_::\\n\"\n      \"    went::mad::now {\\n\"\n      \"int i;\\n\"\n      \"int j;\\n\"\n      \"} // namespace\\n\"\n      \"  // \"\n      \"would::it::save::you::a::lot::of::time::if_::i::just::gave::up::and_::\"\n      \"went::mad::now\",\n      format(\"namespace \"\n             \"would::it::save::you::a::lot::of::time::if_::i::\"\n             \"just::gave::up::and_::went::mad::now {\\n\"\n             \"int i;\\n\"\n             \"int j;\\n\"\n             \"}\",\n             Style));\n\n  // This used to duplicate the comment again and again on subsequent runs\n  EXPECT_EQ(\n      \"namespace \"\n      \"would::it::save::you::a::lot::of::time::if_::i::just::gave::up::and_::\\n\"\n      \"    went::mad::now {\\n\"\n      \"int i;\\n\"\n      \"int j;\\n\"\n      \"} // namespace\\n\"\n      \"  // \"\n      \"would::it::save::you::a::lot::of::time::if_::i::just::gave::up::and_::\"\n      \"went::mad::now\",\n      format(\"namespace \"\n             \"would::it::save::you::a::lot::of::time::if_::i::\"\n             \"just::gave::up::and_::went::mad::now {\\n\"\n             \"int i;\\n\"\n             \"int j;\\n\"\n             \"} // namespace\\n\"\n             \"  // \"\n             \"would::it::save::you::a::lot::of::time::if_::i::just::gave::up::\"\n             \"and_::went::mad::now\",\n             Style));\n}\n\nTEST_F(FormatTest, LikelyUnlikely) {\n  FormatStyle Style = getLLVMStyle();\n\n  verifyFormat(\"if (argc > 5) [[unlikely]] {\\n\"\n               \"  return 29;\\n\"\n               \"}\",\n               Style);\n\n  verifyFormat(\"if (argc > 5) [[likely]] {\\n\"\n               \"  return 29;\\n\"\n               \"}\",\n               Style);\n\n  verifyFormat(\"if (argc > 5) [[unlikely]] {\\n\"\n               \"  return 29;\\n\"\n               \"} else [[likely]] {\\n\"\n               \"  return 42;\\n\"\n               \"}\\n\",\n               Style);\n\n  verifyFormat(\"if (argc > 5) [[unlikely]] {\\n\"\n               \"  return 29;\\n\"\n               \"} else if (argc > 10) [[likely]] {\\n\"\n               \"  return 99;\\n\"\n               \"} else {\\n\"\n               \"  return 42;\\n\"\n               \"}\\n\",\n               Style);\n\n  verifyFormat(\"if (argc > 5) [[gnu::unused]] {\\n\"\n               \"  return 29;\\n\"\n               \"}\",\n               Style);\n}\n\nTEST_F(FormatTest, PenaltyIndentedWhitespace) {\n  verifyFormat(\"Constructor()\\n\"\n               \"    : aaaaaa(aaaaaa), aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"                          aaaa(aaaaaaaaaaaaaaaaaa, \"\n               \"aaaaaaaaaaaaaaaaaat))\");\n  verifyFormat(\"Constructor()\\n\"\n               \"    : aaaaaaaaaaaaa(aaaaaa), \"\n               \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaa)\");\n\n  FormatStyle StyleWithWhitespacePenalty = getLLVMStyle();\n  StyleWithWhitespacePenalty.PenaltyIndentedWhitespace = 5;\n  verifyFormat(\"Constructor()\\n\"\n               \"    : aaaaaa(aaaaaa),\\n\"\n               \"      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(\\n\"\n               \"          aaaa(aaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaat))\",\n               StyleWithWhitespacePenalty);\n  verifyFormat(\"Constructor()\\n\"\n               \"    : aaaaaaaaaaaaa(aaaaaa), \"\n               \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(aaaaaaaaaaaaaaaaaa)\",\n               StyleWithWhitespacePenalty);\n}\n\nTEST_F(FormatTest, LLVMDefaultStyle) {\n  FormatStyle Style = getLLVMStyle();\n  verifyFormat(\"extern \\\"C\\\" {\\n\"\n               \"int foo();\\n\"\n               \"}\",\n               Style);\n}\nTEST_F(FormatTest, GNUDefaultStyle) {\n  FormatStyle Style = getGNUStyle();\n  verifyFormat(\"extern \\\"C\\\"\\n\"\n               \"{\\n\"\n               \"  int foo ();\\n\"\n               \"}\",\n               Style);\n}\nTEST_F(FormatTest, MozillaDefaultStyle) {\n  FormatStyle Style = getMozillaStyle();\n  verifyFormat(\"extern \\\"C\\\"\\n\"\n               \"{\\n\"\n               \"  int foo();\\n\"\n               \"}\",\n               Style);\n}\nTEST_F(FormatTest, GoogleDefaultStyle) {\n  FormatStyle Style = getGoogleStyle();\n  verifyFormat(\"extern \\\"C\\\" {\\n\"\n               \"int foo();\\n\"\n               \"}\",\n               Style);\n}\nTEST_F(FormatTest, ChromiumDefaultStyle) {\n  FormatStyle Style = getChromiumStyle(FormatStyle::LanguageKind::LK_Cpp);\n  verifyFormat(\"extern \\\"C\\\" {\\n\"\n               \"int foo();\\n\"\n               \"}\",\n               Style);\n}\nTEST_F(FormatTest, MicrosoftDefaultStyle) {\n  FormatStyle Style = getMicrosoftStyle(FormatStyle::LanguageKind::LK_Cpp);\n  verifyFormat(\"extern \\\"C\\\"\\n\"\n               \"{\\n\"\n               \"    int foo();\\n\"\n               \"}\",\n               Style);\n}\nTEST_F(FormatTest, WebKitDefaultStyle) {\n  FormatStyle Style = getWebKitStyle();\n  verifyFormat(\"extern \\\"C\\\" {\\n\"\n               \"int foo();\\n\"\n               \"}\",\n               Style);\n}\n\nTEST_F(FormatTest, ConceptsAndRequires) {\n  FormatStyle Style = getLLVMStyle();\n  Style.AllowShortFunctionsOnASingleLine = FormatStyle::SFS_None;\n\n  verifyFormat(\"template <typename T>\\n\"\n               \"concept Hashable = requires(T a) {\\n\"\n               \"  { std::hash<T>{}(a) } -> std::convertible_to<std::size_t>;\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"template <typename T>\\n\"\n               \"concept EqualityComparable = requires(T a, T b) {\\n\"\n               \"  { a == b } -> bool;\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"template <typename T>\\n\"\n               \"concept EqualityComparable = requires(T a, T b) {\\n\"\n               \"  { a == b } -> bool;\\n\"\n               \"  { a != b } -> bool;\\n\"\n               \"};\",\n               Style);\n  verifyFormat(\"template <typename T>\\n\"\n               \"concept EqualityComparable = requires(T a, T b) {\\n\"\n               \"  { a == b } -> bool;\\n\"\n               \"  { a != b } -> bool;\\n\"\n               \"};\",\n               Style);\n\n  verifyFormat(\"template <typename It>\\n\"\n               \"requires Iterator<It>\\n\"\n               \"void sort(It begin, It end) {\\n\"\n               \"  //....\\n\"\n               \"}\",\n               Style);\n\n  verifyFormat(\"template <typename T>\\n\"\n               \"concept Large = sizeof(T) > 10;\",\n               Style);\n\n  verifyFormat(\"template <typename T, typename U>\\n\"\n               \"concept FooableWith = requires(T t, U u) {\\n\"\n               \"  typename T::foo_type;\\n\"\n               \"  { t.foo(u) } -> typename T::foo_type;\\n\"\n               \"  t++;\\n\"\n               \"};\\n\"\n               \"void doFoo(FooableWith<int> auto t) {\\n\"\n               \"  t.foo(3);\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"template <typename T>\\n\"\n               \"concept Context = sizeof(T) == 1;\",\n               Style);\n  verifyFormat(\"template <typename T>\\n\"\n               \"concept Context = is_specialization_of_v<context, T>;\",\n               Style);\n  verifyFormat(\"template <typename T>\\n\"\n               \"concept Node = std::is_object_v<T>;\",\n               Style);\n  verifyFormat(\"template <typename T>\\n\"\n               \"concept Tree = true;\",\n               Style);\n\n  verifyFormat(\"template <typename T> int g(T i) requires Concept1<I> {\\n\"\n               \"  //...\\n\"\n               \"}\",\n               Style);\n\n  verifyFormat(\n      \"template <typename T> int g(T i) requires Concept1<I> && Concept2<I> {\\n\"\n      \"  //...\\n\"\n      \"}\",\n      Style);\n\n  verifyFormat(\n      \"template <typename T> int g(T i) requires Concept1<I> || Concept2<I> {\\n\"\n      \"  //...\\n\"\n      \"}\",\n      Style);\n\n  verifyFormat(\"template <typename T>\\n\"\n               \"veryveryvery_long_return_type g(T i) requires Concept1<I> || \"\n               \"Concept2<I> {\\n\"\n               \"  //...\\n\"\n               \"}\",\n               Style);\n\n  verifyFormat(\"template <typename T>\\n\"\n               \"veryveryvery_long_return_type g(T i) requires Concept1<I> && \"\n               \"Concept2<I> {\\n\"\n               \"  //...\\n\"\n               \"}\",\n               Style);\n\n  verifyFormat(\n      \"template <typename T>\\n\"\n      \"veryveryvery_long_return_type g(T i) requires Concept1 && Concept2 {\\n\"\n      \"  //...\\n\"\n      \"}\",\n      Style);\n\n  verifyFormat(\n      \"template <typename T>\\n\"\n      \"veryveryvery_long_return_type g(T i) requires Concept1 || Concept2 {\\n\"\n      \"  //...\\n\"\n      \"}\",\n      Style);\n\n  verifyFormat(\"template <typename It>\\n\"\n               \"requires Foo<It>() && Bar<It> {\\n\"\n               \"  //....\\n\"\n               \"}\",\n               Style);\n\n  verifyFormat(\"template <typename It>\\n\"\n               \"requires Foo<Bar<It>>() && Bar<Foo<It, It>> {\\n\"\n               \"  //....\\n\"\n               \"}\",\n               Style);\n\n  verifyFormat(\"template <typename It>\\n\"\n               \"requires Foo<Bar<It, It>>() && Bar<Foo<It, It>> {\\n\"\n               \"  //....\\n\"\n               \"}\",\n               Style);\n\n  verifyFormat(\n      \"template <typename It>\\n\"\n      \"requires Foo<Bar<It>, Baz<It>>() && Bar<Foo<It>, Baz<It, It>> {\\n\"\n      \"  //....\\n\"\n      \"}\",\n      Style);\n\n  Style.IndentRequires = true;\n  verifyFormat(\"template <typename It>\\n\"\n               \"  requires Iterator<It>\\n\"\n               \"void sort(It begin, It end) {\\n\"\n               \"  //....\\n\"\n               \"}\",\n               Style);\n  verifyFormat(\"template <std::size index_>\\n\"\n               \"  requires(index_ < sizeof...(Children_))\\n\"\n               \"Tree auto &child() {\\n\"\n               \"  // ...\\n\"\n               \"}\",\n               Style);\n\n  Style.SpaceBeforeParens = FormatStyle::SBPO_Always;\n  verifyFormat(\"template <typename T>\\n\"\n               \"concept Hashable = requires (T a) {\\n\"\n               \"  { std::hash<T>{}(a) } -> std::convertible_to<std::size_t>;\\n\"\n               \"};\",\n               Style);\n\n  verifyFormat(\"template <class T = void>\\n\"\n               \"  requires EqualityComparable<T> || Same<T, void>\\n\"\n               \"struct equal_to;\",\n               Style);\n\n  verifyFormat(\"template <class T>\\n\"\n               \"  requires requires {\\n\"\n               \"    T{};\\n\"\n               \"    T (int);\\n\"\n               \"  }\\n\",\n               Style);\n\n  Style.ColumnLimit = 78;\n  verifyFormat(\"template <typename T>\\n\"\n               \"concept Context = Traits<typename T::traits_type> and\\n\"\n               \"    Interface<typename T::interface_type> and\\n\"\n               \"    Request<typename T::request_type> and\\n\"\n               \"    Response<typename T::response_type> and\\n\"\n               \"    ContextExtension<typename T::extension_type> and\\n\"\n               \"    ::std::is_copy_constructable<T> and \"\n               \"::std::is_move_constructable<T> and\\n\"\n               \"    requires (T c) {\\n\"\n               \"  { c.response; } -> Response;\\n\"\n               \"} and requires (T c) {\\n\"\n               \"  { c.request; } -> Request;\\n\"\n               \"}\\n\",\n               Style);\n\n  verifyFormat(\"template <typename T>\\n\"\n               \"concept Context = Traits<typename T::traits_type> or\\n\"\n               \"    Interface<typename T::interface_type> or\\n\"\n               \"    Request<typename T::request_type> or\\n\"\n               \"    Response<typename T::response_type> or\\n\"\n               \"    ContextExtension<typename T::extension_type> or\\n\"\n               \"    ::std::is_copy_constructable<T> or \"\n               \"::std::is_move_constructable<T> or\\n\"\n               \"    requires (T c) {\\n\"\n               \"  { c.response; } -> Response;\\n\"\n               \"} or requires (T c) {\\n\"\n               \"  { c.request; } -> Request;\\n\"\n               \"}\\n\",\n               Style);\n\n  verifyFormat(\"template <typename T>\\n\"\n               \"concept Context = Traits<typename T::traits_type> &&\\n\"\n               \"    Interface<typename T::interface_type> &&\\n\"\n               \"    Request<typename T::request_type> &&\\n\"\n               \"    Response<typename T::response_type> &&\\n\"\n               \"    ContextExtension<typename T::extension_type> &&\\n\"\n               \"    ::std::is_copy_constructable<T> && \"\n               \"::std::is_move_constructable<T> &&\\n\"\n               \"    requires (T c) {\\n\"\n               \"  { c.response; } -> Response;\\n\"\n               \"} && requires (T c) {\\n\"\n               \"  { c.request; } -> Request;\\n\"\n               \"}\\n\",\n               Style);\n\n  verifyFormat(\"template <typename T>\\nconcept someConcept = Constraint1<T> && \"\n               \"Constraint2<T>;\");\n\n  Style.BreakBeforeBraces = FormatStyle::BS_Custom;\n  Style.BraceWrapping.AfterFunction = true;\n  Style.BraceWrapping.AfterClass = true;\n  Style.AlwaysBreakTemplateDeclarations = FormatStyle::BTDS_Yes;\n  Style.BreakConstructorInitializers = FormatStyle::BCIS_BeforeColon;\n  verifyFormat(\"void Foo () requires (std::copyable<T>)\\n\"\n               \"{\\n\"\n               \"  return\\n\"\n               \"}\\n\",\n               Style);\n\n  verifyFormat(\"void Foo () requires std::copyable<T>\\n\"\n               \"{\\n\"\n               \"  return\\n\"\n               \"}\\n\",\n               Style);\n\n  verifyFormat(\"template <std::semiregular F, std::semiregular... Args>\\n\"\n               \"  requires (std::invocable<F, std::invoke_result_t<Args>...>)\\n\"\n               \"struct constant;\",\n               Style);\n\n  verifyFormat(\"template <std::semiregular F, std::semiregular... Args>\\n\"\n               \"  requires std::invocable<F, std::invoke_result_t<Args>...>\\n\"\n               \"struct constant;\",\n               Style);\n\n  verifyFormat(\"template <class T>\\n\"\n               \"class plane_with_very_very_very_long_name\\n\"\n               \"{\\n\"\n               \"  constexpr plane_with_very_very_very_long_name () requires \"\n               \"std::copyable<T>\\n\"\n               \"      : plane_with_very_very_very_long_name (1)\\n\"\n               \"  {\\n\"\n               \"  }\\n\"\n               \"}\\n\",\n               Style);\n\n  verifyFormat(\"template <class T>\\n\"\n               \"class plane_with_long_name\\n\"\n               \"{\\n\"\n               \"  constexpr plane_with_long_name () requires std::copyable<T>\\n\"\n               \"      : plane_with_long_name (1)\\n\"\n               \"  {\\n\"\n               \"  }\\n\"\n               \"}\\n\",\n               Style);\n\n  Style.BreakBeforeConceptDeclarations = false;\n  verifyFormat(\"template <typename T> concept Tree = true;\", Style);\n\n  Style.IndentRequires = false;\n  verifyFormat(\"template <std::semiregular F, std::semiregular... Args>\\n\"\n               \"requires (std::invocable<F, std::invoke_result_t<Args>...>) \"\n               \"struct constant;\",\n               Style);\n}\n\nTEST_F(FormatTest, StatementAttributeLikeMacros) {\n  FormatStyle Style = getLLVMStyle();\n  StringRef Source = \"void Foo::slot() {\\n\"\n                     \"  unsigned char MyChar = 'x';\\n\"\n                     \"  emit signal(MyChar);\\n\"\n                     \"  Q_EMIT signal(MyChar);\\n\"\n                     \"}\";\n\n  EXPECT_EQ(Source, format(Source, Style));\n\n  Style.AlignConsecutiveDeclarations = FormatStyle::ACS_Consecutive;\n  EXPECT_EQ(\"void Foo::slot() {\\n\"\n            \"  unsigned char MyChar = 'x';\\n\"\n            \"  emit          signal(MyChar);\\n\"\n            \"  Q_EMIT signal(MyChar);\\n\"\n            \"}\",\n            format(Source, Style));\n\n  Style.StatementAttributeLikeMacros.push_back(\"emit\");\n  EXPECT_EQ(Source, format(Source, Style));\n\n  Style.StatementAttributeLikeMacros = {};\n  EXPECT_EQ(\"void Foo::slot() {\\n\"\n            \"  unsigned char MyChar = 'x';\\n\"\n            \"  emit          signal(MyChar);\\n\"\n            \"  Q_EMIT        signal(MyChar);\\n\"\n            \"}\",\n            format(Source, Style));\n}\n\nTEST_F(FormatTest, IndentAccessModifiers) {\n  FormatStyle Style = getLLVMStyle();\n  Style.IndentAccessModifiers = true;\n  // Members are *two* levels below the record;\n  // Style.IndentWidth == 2, thus yielding a 4 spaces wide indentation.\n  verifyFormat(\"class C {\\n\"\n               \"    int i;\\n\"\n               \"};\\n\",\n               Style);\n  verifyFormat(\"union C {\\n\"\n               \"    int i;\\n\"\n               \"    unsigned u;\\n\"\n               \"};\\n\",\n               Style);\n  // Access modifiers should be indented one level below the record.\n  verifyFormat(\"class C {\\n\"\n               \"  public:\\n\"\n               \"    int i;\\n\"\n               \"};\\n\",\n               Style);\n  verifyFormat(\"struct S {\\n\"\n               \"  private:\\n\"\n               \"    class C {\\n\"\n               \"        int j;\\n\"\n               \"\\n\"\n               \"      public:\\n\"\n               \"        C();\\n\"\n               \"    };\\n\"\n               \"\\n\"\n               \"  public:\\n\"\n               \"    int i;\\n\"\n               \"};\\n\",\n               Style);\n  // Enumerations are not records and should be unaffected.\n  Style.AllowShortEnumsOnASingleLine = false;\n  verifyFormat(\"enum class E\\n\"\n               \"{\\n\"\n               \"  A,\\n\"\n               \"  B\\n\"\n               \"};\\n\",\n               Style);\n  // Test with a different indentation width;\n  // also proves that the result is Style.AccessModifierOffset agnostic.\n  Style.IndentWidth = 3;\n  verifyFormat(\"class C {\\n\"\n               \"   public:\\n\"\n               \"      int i;\\n\"\n               \"};\\n\",\n               Style);\n}\n\nTEST_F(FormatTest, LimitlessStringsAndComments) {\n  auto Style = getLLVMStyleWithColumns(0);\n  constexpr StringRef Code =\n      \"/**\\n\"\n      \" * This is a multiline comment with quite some long lines, at least for \"\n      \"the LLVM Style.\\n\"\n      \" * We will redo this with strings and line comments. Just to  check if \"\n      \"everything is working.\\n\"\n      \" */\\n\"\n      \"bool foo() {\\n\"\n      \"  /* Single line multi line comment. */\\n\"\n      \"  const std::string String = \\\"This is a multiline string with quite \"\n      \"some long lines, at least for the LLVM Style.\\\"\\n\"\n      \"                             \\\"We already did it with multi line \"\n      \"comments, and we will do it with line comments. Just to check if \"\n      \"everything is working.\\\";\\n\"\n      \"  // This is a line comment (block) with quite some long lines, at \"\n      \"least for the LLVM Style.\\n\"\n      \"  // We already did this with multi line comments and strings. Just to \"\n      \"check if everything is working.\\n\"\n      \"  const std::string SmallString = \\\"Hello World\\\";\\n\"\n      \"  // Small line comment\\n\"\n      \"  return String.size() > SmallString.size();\\n\"\n      \"}\";\n  EXPECT_EQ(Code, format(Code, Style));\n}\n} // namespace\n} // namespace format\n} // namespace clang\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 18, "line": 30}, "message": "'FormatTest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/unittests/Format/FormatTest.cpp", "reportHash": "642d793e513b2ff244480f1c1d19b6da", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
