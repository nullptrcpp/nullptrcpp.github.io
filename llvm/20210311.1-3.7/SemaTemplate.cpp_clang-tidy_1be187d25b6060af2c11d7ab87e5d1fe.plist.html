<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Template.h", "content": "//===- SemaTemplate.h - C++ Templates ---------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//===----------------------------------------------------------------------===//\n//\n// This file provides types used in the semantic analysis of C++ templates.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_TEMPLATE_H\n#define LLVM_CLANG_SEMA_TEMPLATE_H\n\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/DeclVisitor.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <cassert>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass BindingDecl;\nclass CXXMethodDecl;\nclass Decl;\nclass DeclaratorDecl;\nclass DeclContext;\nclass EnumDecl;\nclass FunctionDecl;\nclass NamedDecl;\nclass ParmVarDecl;\nclass TagDecl;\nclass TypedefNameDecl;\nclass TypeSourceInfo;\nclass VarDecl;\n\n/// The kind of template substitution being performed.\nenum class TemplateSubstitutionKind : char {\n  /// We are substituting template parameters for template arguments in order\n  /// to form a template specialization.\n  Specialization,\n  /// We are substituting template parameters for (typically) other template\n  /// parameters in order to rewrite a declaration as a different declaration\n  /// (for example, when forming a deduction guide from a constructor).\n  Rewrite,\n};\n\n  /// Data structure that captures multiple levels of template argument\n  /// lists for use in template instantiation.\n  ///\n  /// Multiple levels of template arguments occur when instantiating the\n  /// definitions of member templates. For example:\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   template<T Value>\n  ///   struct Y {\n  ///     void f();\n  ///   };\n  /// };\n  /// \\endcode\n  ///\n  /// When instantiating X<int>::Y<17>::f, the multi-level template argument\n  /// list will contain a template argument list (int) at depth 0 and a\n  /// template argument list (17) at depth 1.\n  class MultiLevelTemplateArgumentList {\n    /// The template argument list at a certain template depth\n    using ArgList = ArrayRef<TemplateArgument>;\n\n    /// The template argument lists, stored from the innermost template\n    /// argument list (first) to the outermost template argument list (last).\n    SmallVector<ArgList, 4> TemplateArgumentLists;\n\n    /// The number of outer levels of template arguments that are not\n    /// being substituted.\n    unsigned NumRetainedOuterLevels = 0;\n\n    /// The kind of substitution described by this argument list.\n    TemplateSubstitutionKind Kind = TemplateSubstitutionKind::Specialization;\n\n  public:\n    /// Construct an empty set of template argument lists.\n    MultiLevelTemplateArgumentList() = default;\n\n    /// Construct a single-level template argument list.\n    explicit\n    MultiLevelTemplateArgumentList(const TemplateArgumentList &TemplateArgs) {\n      addOuterTemplateArguments(&TemplateArgs);\n    }\n\n    void setKind(TemplateSubstitutionKind K) { Kind = K; }\n\n    /// Determine the kind of template substitution being performed.\n    TemplateSubstitutionKind getKind() const { return Kind; }\n\n    /// Determine whether we are rewriting template parameters rather than\n    /// substituting for them. If so, we should not leave references to the\n    /// original template parameters behind.\n    bool isRewrite() const {\n      return Kind == TemplateSubstitutionKind::Rewrite;\n    }\n\n    /// Determine the number of levels in this template argument\n    /// list.\n    unsigned getNumLevels() const {\n      return TemplateArgumentLists.size() + NumRetainedOuterLevels;\n    }\n\n    /// Determine the number of substituted levels in this template\n    /// argument list.\n    unsigned getNumSubstitutedLevels() const {\n      return TemplateArgumentLists.size();\n    }\n\n    unsigned getNumRetainedOuterLevels() const {\n      return NumRetainedOuterLevels;\n    }\n\n    /// Determine how many of the \\p OldDepth outermost template parameter\n    /// lists would be removed by substituting these arguments.\n    unsigned getNewDepth(unsigned OldDepth) const {\n      if (OldDepth < NumRetainedOuterLevels)\n        return OldDepth;\n      if (OldDepth < getNumLevels())\n        return NumRetainedOuterLevels;\n      return OldDepth - TemplateArgumentLists.size();\n    }\n\n    /// Retrieve the template argument at a given depth and index.\n    const TemplateArgument &operator()(unsigned Depth, unsigned Index) const {\n      assert(NumRetainedOuterLevels <= Depth && Depth < getNumLevels());\n      assert(Index < TemplateArgumentLists[getNumLevels() - Depth - 1].size());\n      return TemplateArgumentLists[getNumLevels() - Depth - 1][Index];\n    }\n\n    /// Determine whether there is a non-NULL template argument at the\n    /// given depth and index.\n    ///\n    /// There must exist a template argument list at the given depth.\n    bool hasTemplateArgument(unsigned Depth, unsigned Index) const {\n      assert(Depth < getNumLevels());\n\n      if (Depth < NumRetainedOuterLevels)\n        return false;\n\n      if (Index >= TemplateArgumentLists[getNumLevels() - Depth - 1].size())\n        return false;\n\n      return !(*this)(Depth, Index).isNull();\n    }\n\n    /// Clear out a specific template argument.\n    void setArgument(unsigned Depth, unsigned Index,\n                     TemplateArgument Arg) {\n      assert(NumRetainedOuterLevels <= Depth && Depth < getNumLevels());\n      assert(Index < TemplateArgumentLists[getNumLevels() - Depth - 1].size());\n      const_cast<TemplateArgument&>(\n                TemplateArgumentLists[getNumLevels() - Depth - 1][Index])\n        = Arg;\n    }\n\n    /// Add a new outermost level to the multi-level template argument\n    /// list.\n    void addOuterTemplateArguments(const TemplateArgumentList *TemplateArgs) {\n      addOuterTemplateArguments(ArgList(TemplateArgs->data(),\n                                        TemplateArgs->size()));\n    }\n\n    /// Add a new outmost level to the multi-level template argument\n    /// list.\n    void addOuterTemplateArguments(ArgList Args) {\n      assert(!NumRetainedOuterLevels &&\n             \"substituted args outside retained args?\");\n      TemplateArgumentLists.push_back(Args);\n    }\n\n    /// Add an outermost level that we are not substituting. We have no\n    /// arguments at this level, and do not remove it from the depth of inner\n    /// template parameters that we instantiate.\n    void addOuterRetainedLevel() {\n      ++NumRetainedOuterLevels;\n    }\n    void addOuterRetainedLevels(unsigned Num) {\n      NumRetainedOuterLevels += Num;\n    }\n\n    /// Retrieve the innermost template argument list.\n    const ArgList &getInnermost() const {\n      return TemplateArgumentLists.front();\n    }\n  };\n\n  /// The context in which partial ordering of function templates occurs.\n  enum TPOC {\n    /// Partial ordering of function templates for a function call.\n    TPOC_Call,\n\n    /// Partial ordering of function templates for a call to a\n    /// conversion function.\n    TPOC_Conversion,\n\n    /// Partial ordering of function templates in other contexts, e.g.,\n    /// taking the address of a function template or matching a function\n    /// template specialization to a function template.\n    TPOC_Other\n  };\n\n  // This is lame but unavoidable in a world without forward\n  // declarations of enums.  The alternatives are to either pollute\n  // Sema.h (by including this file) or sacrifice type safety (by\n  // making Sema.h declare things as enums).\n  class TemplatePartialOrderingContext {\n    TPOC Value;\n\n  public:\n    TemplatePartialOrderingContext(TPOC Value) : Value(Value) {}\n\n    operator TPOC() const { return Value; }\n  };\n\n  /// Captures a template argument whose value has been deduced\n  /// via c++ template argument deduction.\n  class DeducedTemplateArgument : public TemplateArgument {\n    /// For a non-type template argument, whether the value was\n    /// deduced from an array bound.\n    bool DeducedFromArrayBound = false;\n\n  public:\n    DeducedTemplateArgument() = default;\n\n    DeducedTemplateArgument(const TemplateArgument &Arg,\n                            bool DeducedFromArrayBound = false)\n        : TemplateArgument(Arg), DeducedFromArrayBound(DeducedFromArrayBound) {}\n\n    /// Construct an integral non-type template argument that\n    /// has been deduced, possibly from an array bound.\n    DeducedTemplateArgument(ASTContext &Ctx,\n                            const llvm::APSInt &Value,\n                            QualType ValueType,\n                            bool DeducedFromArrayBound)\n        : TemplateArgument(Ctx, Value, ValueType),\n          DeducedFromArrayBound(DeducedFromArrayBound) {}\n\n    /// For a non-type template argument, determine whether the\n    /// template argument was deduced from an array bound.\n    bool wasDeducedFromArrayBound() const { return DeducedFromArrayBound; }\n\n    /// Specify whether the given non-type template argument\n    /// was deduced from an array bound.\n    void setDeducedFromArrayBound(bool Deduced) {\n      DeducedFromArrayBound = Deduced;\n    }\n  };\n\n  /// A stack-allocated class that identifies which local\n  /// variable declaration instantiations are present in this scope.\n  ///\n  /// A new instance of this class type will be created whenever we\n  /// instantiate a new function declaration, which will have its own\n  /// set of parameter declarations.\n  class LocalInstantiationScope {\n  public:\n    /// A set of declarations.\n    using DeclArgumentPack = SmallVector<VarDecl *, 4>;\n\n  private:\n    /// Reference to the semantic analysis that is performing\n    /// this template instantiation.\n    Sema &SemaRef;\n\n    using LocalDeclsMap =\n        llvm::SmallDenseMap<const Decl *,\n                            llvm::PointerUnion<Decl *, DeclArgumentPack *>, 4>;\n\n    /// A mapping from local declarations that occur\n    /// within a template to their instantiations.\n    ///\n    /// This mapping is used during instantiation to keep track of,\n    /// e.g., function parameter and variable declarations. For example,\n    /// given:\n    ///\n    /// \\code\n    ///   template<typename T> T add(T x, T y) { return x + y; }\n    /// \\endcode\n    ///\n    /// when we instantiate add<int>, we will introduce a mapping from\n    /// the ParmVarDecl for 'x' that occurs in the template to the\n    /// instantiated ParmVarDecl for 'x'.\n    ///\n    /// For a parameter pack, the local instantiation scope may contain a\n    /// set of instantiated parameters. This is stored as a DeclArgumentPack\n    /// pointer.\n    LocalDeclsMap LocalDecls;\n\n    /// The set of argument packs we've allocated.\n    SmallVector<DeclArgumentPack *, 1> ArgumentPacks;\n\n    /// The outer scope, which contains local variable\n    /// definitions from some other instantiation (that may not be\n    /// relevant to this particular scope).\n    LocalInstantiationScope *Outer;\n\n    /// Whether we have already exited this scope.\n    bool Exited = false;\n\n    /// Whether to combine this scope with the outer scope, such that\n    /// lookup will search our outer scope.\n    bool CombineWithOuterScope;\n\n    /// If non-NULL, the template parameter pack that has been\n    /// partially substituted per C++0x [temp.arg.explicit]p9.\n    NamedDecl *PartiallySubstitutedPack = nullptr;\n\n    /// If \\c PartiallySubstitutedPack is non-null, the set of\n    /// explicitly-specified template arguments in that pack.\n    const TemplateArgument *ArgsInPartiallySubstitutedPack;\n\n    /// If \\c PartiallySubstitutedPack, the number of\n    /// explicitly-specified template arguments in\n    /// ArgsInPartiallySubstitutedPack.\n    unsigned NumArgsInPartiallySubstitutedPack;\n\n  public:\n    LocalInstantiationScope(Sema &SemaRef, bool CombineWithOuterScope = false)\n        : SemaRef(SemaRef), Outer(SemaRef.CurrentInstantiationScope),\n          CombineWithOuterScope(CombineWithOuterScope) {\n      SemaRef.CurrentInstantiationScope = this;\n    }\n\n    LocalInstantiationScope(const LocalInstantiationScope &) = delete;\n    LocalInstantiationScope &\n    operator=(const LocalInstantiationScope &) = delete;\n\n    ~LocalInstantiationScope() {\n      Exit();\n    }\n\n    const Sema &getSema() const { return SemaRef; }\n\n    /// Exit this local instantiation scope early.\n    void Exit() {\n      if (Exited)\n        return;\n\n      for (unsigned I = 0, N = ArgumentPacks.size(); I != N; ++I)\n        delete ArgumentPacks[I];\n\n      SemaRef.CurrentInstantiationScope = Outer;\n      Exited = true;\n    }\n\n    /// Clone this scope, and all outer scopes, down to the given\n    /// outermost scope.\n    LocalInstantiationScope *cloneScopes(LocalInstantiationScope *Outermost) {\n      if (this == Outermost) return this;\n\n      // Save the current scope from SemaRef since the LocalInstantiationScope\n      // will overwrite it on construction\n      LocalInstantiationScope *oldScope = SemaRef.CurrentInstantiationScope;\n\n      LocalInstantiationScope *newScope =\n        new LocalInstantiationScope(SemaRef, CombineWithOuterScope);\n\n      newScope->Outer = nullptr;\n      if (Outer)\n        newScope->Outer = Outer->cloneScopes(Outermost);\n\n      newScope->PartiallySubstitutedPack = PartiallySubstitutedPack;\n      newScope->ArgsInPartiallySubstitutedPack = ArgsInPartiallySubstitutedPack;\n      newScope->NumArgsInPartiallySubstitutedPack =\n        NumArgsInPartiallySubstitutedPack;\n\n      for (LocalDeclsMap::iterator I = LocalDecls.begin(), E = LocalDecls.end();\n           I != E; ++I) {\n        const Decl *D = I->first;\n        llvm::PointerUnion<Decl *, DeclArgumentPack *> &Stored =\n          newScope->LocalDecls[D];\n        if (I->second.is<Decl *>()) {\n          Stored = I->second.get<Decl *>();\n        } else {\n          DeclArgumentPack *OldPack = I->second.get<DeclArgumentPack *>();\n          DeclArgumentPack *NewPack = new DeclArgumentPack(*OldPack);\n          Stored = NewPack;\n          newScope->ArgumentPacks.push_back(NewPack);\n        }\n      }\n      // Restore the saved scope to SemaRef\n      SemaRef.CurrentInstantiationScope = oldScope;\n      return newScope;\n    }\n\n    /// deletes the given scope, and all otuer scopes, down to the\n    /// given outermost scope.\n    static void deleteScopes(LocalInstantiationScope *Scope,\n                             LocalInstantiationScope *Outermost) {\n      while (Scope && Scope != Outermost) {\n        LocalInstantiationScope *Out = Scope->Outer;\n        delete Scope;\n        Scope = Out;\n      }\n    }\n\n    /// Find the instantiation of the declaration D within the current\n    /// instantiation scope.\n    ///\n    /// \\param D The declaration whose instantiation we are searching for.\n    ///\n    /// \\returns A pointer to the declaration or argument pack of declarations\n    /// to which the declaration \\c D is instantiated, if found. Otherwise,\n    /// returns NULL.\n    llvm::PointerUnion<Decl *, DeclArgumentPack *> *\n    findInstantiationOf(const Decl *D);\n\n    void InstantiatedLocal(const Decl *D, Decl *Inst);\n    void InstantiatedLocalPackArg(const Decl *D, VarDecl *Inst);\n    void MakeInstantiatedLocalArgPack(const Decl *D);\n\n    /// Note that the given parameter pack has been partially substituted\n    /// via explicit specification of template arguments\n    /// (C++0x [temp.arg.explicit]p9).\n    ///\n    /// \\param Pack The parameter pack, which will always be a template\n    /// parameter pack.\n    ///\n    /// \\param ExplicitArgs The explicitly-specified template arguments provided\n    /// for this parameter pack.\n    ///\n    /// \\param NumExplicitArgs The number of explicitly-specified template\n    /// arguments provided for this parameter pack.\n    void SetPartiallySubstitutedPack(NamedDecl *Pack,\n                                     const TemplateArgument *ExplicitArgs,\n                                     unsigned NumExplicitArgs);\n\n    /// Reset the partially-substituted pack when it is no longer of\n    /// interest.\n    void ResetPartiallySubstitutedPack() {\n      assert(PartiallySubstitutedPack && \"No partially-substituted pack\");\n      PartiallySubstitutedPack = nullptr;\n      ArgsInPartiallySubstitutedPack = nullptr;\n      NumArgsInPartiallySubstitutedPack = 0;\n    }\n\n    /// Retrieve the partially-substitued template parameter pack.\n    ///\n    /// If there is no partially-substituted parameter pack, returns NULL.\n    NamedDecl *\n    getPartiallySubstitutedPack(const TemplateArgument **ExplicitArgs = nullptr,\n                                unsigned *NumExplicitArgs = nullptr) const;\n\n    /// Determine whether D is a pack expansion created in this scope.\n    bool isLocalPackExpansion(const Decl *D);\n  };\n\n  class TemplateDeclInstantiator\n    : public DeclVisitor<TemplateDeclInstantiator, Decl *>\n  {\n    Sema &SemaRef;\n    Sema::ArgumentPackSubstitutionIndexRAII SubstIndex;\n    DeclContext *Owner;\n    const MultiLevelTemplateArgumentList &TemplateArgs;\n    Sema::LateInstantiatedAttrVec* LateAttrs = nullptr;\n    LocalInstantiationScope *StartingScope = nullptr;\n\n    /// A list of out-of-line class template partial\n    /// specializations that will need to be instantiated after the\n    /// enclosing class's instantiation is complete.\n    SmallVector<std::pair<ClassTemplateDecl *,\n                                ClassTemplatePartialSpecializationDecl *>, 4>\n      OutOfLinePartialSpecs;\n\n    /// A list of out-of-line variable template partial\n    /// specializations that will need to be instantiated after the\n    /// enclosing variable's instantiation is complete.\n    /// FIXME: Verify that this is needed.\n    SmallVector<\n        std::pair<VarTemplateDecl *, VarTemplatePartialSpecializationDecl *>, 4>\n    OutOfLineVarPartialSpecs;\n\n  public:\n    TemplateDeclInstantiator(Sema &SemaRef, DeclContext *Owner,\n                             const MultiLevelTemplateArgumentList &TemplateArgs)\n        : SemaRef(SemaRef),\n          SubstIndex(SemaRef, SemaRef.ArgumentPackSubstitutionIndex),\n          Owner(Owner), TemplateArgs(TemplateArgs) {}\n\n// Define all the decl visitors using DeclNodes.inc\n#define DECL(DERIVED, BASE) \\\n    Decl *Visit ## DERIVED ## Decl(DERIVED ## Decl *D);\n#define ABSTRACT_DECL(DECL)\n\n// Decls which never appear inside a class or function.\n#define OBJCCONTAINER(DERIVED, BASE)\n#define FILESCOPEASM(DERIVED, BASE)\n#define IMPORT(DERIVED, BASE)\n#define EXPORT(DERIVED, BASE)\n#define LINKAGESPEC(DERIVED, BASE)\n#define OBJCCOMPATIBLEALIAS(DERIVED, BASE)\n#define OBJCMETHOD(DERIVED, BASE)\n#define OBJCTYPEPARAM(DERIVED, BASE)\n#define OBJCIVAR(DERIVED, BASE)\n#define OBJCPROPERTY(DERIVED, BASE)\n#define OBJCPROPERTYIMPL(DERIVED, BASE)\n#define EMPTY(DERIVED, BASE)\n#define LIFETIMEEXTENDEDTEMPORARY(DERIVED, BASE)\n\n    // Decls which use special-case instantiation code.\n#define BLOCK(DERIVED, BASE)\n#define CAPTURED(DERIVED, BASE)\n#define IMPLICITPARAM(DERIVED, BASE)\n\n#include \"clang/AST/DeclNodes.inc\"\n\n    enum class RewriteKind { None, RewriteSpaceshipAsEqualEqual };\n\n    void adjustForRewrite(RewriteKind RK, FunctionDecl *Orig, QualType &T,\n                          TypeSourceInfo *&TInfo,\n                          DeclarationNameInfo &NameInfo);\n\n    // A few supplemental visitor functions.\n    Decl *VisitCXXMethodDecl(CXXMethodDecl *D,\n                             TemplateParameterList *TemplateParams,\n                             Optional<const ASTTemplateArgumentListInfo *>\n                                 ClassScopeSpecializationArgs = llvm::None,\n                             RewriteKind RK = RewriteKind::None);\n    Decl *VisitFunctionDecl(FunctionDecl *D,\n                            TemplateParameterList *TemplateParams,\n                            RewriteKind RK = RewriteKind::None);\n    Decl *VisitDecl(Decl *D);\n    Decl *VisitVarDecl(VarDecl *D, bool InstantiatingVarTemplate,\n                       ArrayRef<BindingDecl *> *Bindings = nullptr);\n\n    // Enable late instantiation of attributes.  Late instantiated attributes\n    // will be stored in LA.\n    void enableLateAttributeInstantiation(Sema::LateInstantiatedAttrVec *LA) {\n      LateAttrs = LA;\n      StartingScope = SemaRef.CurrentInstantiationScope;\n    }\n\n    // Disable late instantiation of attributes.\n    void disableLateAttributeInstantiation() {\n      LateAttrs = nullptr;\n      StartingScope = nullptr;\n    }\n\n    LocalInstantiationScope *getStartingScope() const { return StartingScope; }\n\n    using delayed_partial_spec_iterator = SmallVectorImpl<std::pair<\n      ClassTemplateDecl *, ClassTemplatePartialSpecializationDecl *>>::iterator;\n\n    using delayed_var_partial_spec_iterator = SmallVectorImpl<std::pair<\n        VarTemplateDecl *, VarTemplatePartialSpecializationDecl *>>::iterator;\n\n    /// Return an iterator to the beginning of the set of\n    /// \"delayed\" partial specializations, which must be passed to\n    /// InstantiateClassTemplatePartialSpecialization once the class\n    /// definition has been completed.\n    delayed_partial_spec_iterator delayed_partial_spec_begin() {\n      return OutOfLinePartialSpecs.begin();\n    }\n\n    delayed_var_partial_spec_iterator delayed_var_partial_spec_begin() {\n      return OutOfLineVarPartialSpecs.begin();\n    }\n\n    /// Return an iterator to the end of the set of\n    /// \"delayed\" partial specializations, which must be passed to\n    /// InstantiateClassTemplatePartialSpecialization once the class\n    /// definition has been completed.\n    delayed_partial_spec_iterator delayed_partial_spec_end() {\n      return OutOfLinePartialSpecs.end();\n    }\n\n    delayed_var_partial_spec_iterator delayed_var_partial_spec_end() {\n      return OutOfLineVarPartialSpecs.end();\n    }\n\n    // Helper functions for instantiating methods.\n    TypeSourceInfo *SubstFunctionType(FunctionDecl *D,\n                             SmallVectorImpl<ParmVarDecl *> &Params);\n    bool InitFunctionInstantiation(FunctionDecl *New, FunctionDecl *Tmpl);\n    bool InitMethodInstantiation(CXXMethodDecl *New, CXXMethodDecl *Tmpl);\n\n    bool SubstDefaultedFunction(FunctionDecl *New, FunctionDecl *Tmpl);\n\n    TemplateParameterList *\n      SubstTemplateParams(TemplateParameterList *List);\n\n    bool SubstQualifier(const DeclaratorDecl *OldDecl,\n                        DeclaratorDecl *NewDecl);\n    bool SubstQualifier(const TagDecl *OldDecl,\n                        TagDecl *NewDecl);\n\n    Decl *VisitVarTemplateSpecializationDecl(\n        VarTemplateDecl *VarTemplate, VarDecl *FromVar,\n        const TemplateArgumentListInfo &TemplateArgsInfo,\n        ArrayRef<TemplateArgument> Converted,\n        VarTemplateSpecializationDecl *PrevDecl = nullptr);\n\n    Decl *InstantiateTypedefNameDecl(TypedefNameDecl *D, bool IsTypeAlias);\n    ClassTemplatePartialSpecializationDecl *\n    InstantiateClassTemplatePartialSpecialization(\n                                              ClassTemplateDecl *ClassTemplate,\n                           ClassTemplatePartialSpecializationDecl *PartialSpec);\n    VarTemplatePartialSpecializationDecl *\n    InstantiateVarTemplatePartialSpecialization(\n        VarTemplateDecl *VarTemplate,\n        VarTemplatePartialSpecializationDecl *PartialSpec);\n    void InstantiateEnumDefinition(EnumDecl *Enum, EnumDecl *Pattern);\n\n  private:\n    template<typename T>\n    Decl *instantiateUnresolvedUsingDecl(T *D,\n                                         bool InstantiatingPackElement = false);\n  };\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SEMA_TEMPLATE_H\n"}, "45": {"id": 45, "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplate.cpp", "content": "//===------- SemaTemplate.cpp - Semantic Analysis for C++ Templates -------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//===----------------------------------------------------------------------===//\n//\n//  This file implements semantic analysis for C++ templates.\n//===----------------------------------------------------------------------===//\n\n#include \"TreeTransform.h\"\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/DeclFriend.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"clang/AST/TypeVisitor.h\"\n#include \"clang/Basic/Builtins.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/Stack.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"clang/Sema/Initialization.h\"\n#include \"clang/Sema/Lookup.h\"\n#include \"clang/Sema/Overload.h\"\n#include \"clang/Sema/ParsedTemplate.h\"\n#include \"clang/Sema/Scope.h\"\n#include \"clang/Sema/SemaInternal.h\"\n#include \"clang/Sema/Template.h\"\n#include \"clang/Sema/TemplateDeduction.h\"\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringExtras.h\"\n\n#include <iterator>\nusing namespace clang;\nusing namespace sema;\n\n// Exported for use by Parser.\nSourceRange\nclang::getTemplateParamsRange(TemplateParameterList const * const *Ps,\n                              unsigned N) {\n  if (!N) return SourceRange();\n  return SourceRange(Ps[0]->getTemplateLoc(), Ps[N-1]->getRAngleLoc());\n}\n\nunsigned Sema::getTemplateDepth(Scope *S) const {\n  unsigned Depth = 0;\n\n  // Each template parameter scope represents one level of template parameter\n  // depth.\n  for (Scope *TempParamScope = S->getTemplateParamParent(); TempParamScope;\n       TempParamScope = TempParamScope->getParent()->getTemplateParamParent()) {\n    ++Depth;\n  }\n\n  // Note that there are template parameters with the given depth.\n  auto ParamsAtDepth = [&](unsigned D) { Depth = std::max(Depth, D + 1); };\n\n  // Look for parameters of an enclosing generic lambda. We don't create a\n  // template parameter scope for these.\n  for (FunctionScopeInfo *FSI : getFunctionScopes()) {\n    if (auto *LSI = dyn_cast<LambdaScopeInfo>(FSI)) {\n      if (!LSI->TemplateParams.empty()) {\n        ParamsAtDepth(LSI->AutoTemplateParameterDepth);\n        break;\n      }\n      if (LSI->GLTemplateParameterList) {\n        ParamsAtDepth(LSI->GLTemplateParameterList->getDepth());\n        break;\n      }\n    }\n  }\n\n  // Look for parameters of an enclosing terse function template. We don't\n  // create a template parameter scope for these either.\n  for (const InventedTemplateParameterInfo &Info :\n       getInventedParameterInfos()) {\n    if (!Info.TemplateParams.empty()) {\n      ParamsAtDepth(Info.AutoTemplateParameterDepth);\n      break;\n    }\n  }\n\n  return Depth;\n}\n\n/// \\brief Determine whether the declaration found is acceptable as the name\n/// of a template and, if so, return that template declaration. Otherwise,\n/// returns null.\n///\n/// Note that this may return an UnresolvedUsingValueDecl if AllowDependent\n/// is true. In all other cases it will return a TemplateDecl (or null).\nNamedDecl *Sema::getAsTemplateNameDecl(NamedDecl *D,\n                                       bool AllowFunctionTemplates,\n                                       bool AllowDependent) {\n  D = D->getUnderlyingDecl();\n\n  if (isa<TemplateDecl>(D)) {\n    if (!AllowFunctionTemplates && isa<FunctionTemplateDecl>(D))\n      return nullptr;\n\n    return D;\n  }\n\n  if (CXXRecordDecl *Record = dyn_cast<CXXRecordDecl>(D)) {\n    // C++ [temp.local]p1:\n    //   Like normal (non-template) classes, class templates have an\n    //   injected-class-name (Clause 9). The injected-class-name\n    //   can be used with or without a template-argument-list. When\n    //   it is used without a template-argument-list, it is\n    //   equivalent to the injected-class-name followed by the\n    //   template-parameters of the class template enclosed in\n    //   <>. When it is used with a template-argument-list, it\n    //   refers to the specified class template specialization,\n    //   which could be the current specialization or another\n    //   specialization.\n    if (Record->isInjectedClassName()) {\n      Record = cast<CXXRecordDecl>(Record->getDeclContext());\n      if (Record->getDescribedClassTemplate())\n        return Record->getDescribedClassTemplate();\n\n      if (ClassTemplateSpecializationDecl *Spec\n            = dyn_cast<ClassTemplateSpecializationDecl>(Record))\n        return Spec->getSpecializedTemplate();\n    }\n\n    return nullptr;\n  }\n\n  // 'using Dependent::foo;' can resolve to a template name.\n  // 'using typename Dependent::foo;' cannot (not even if 'foo' is an\n  // injected-class-name).\n  if (AllowDependent && isa<UnresolvedUsingValueDecl>(D))\n    return D;\n\n  return nullptr;\n}\n\nvoid Sema::FilterAcceptableTemplateNames(LookupResult &R,\n                                         bool AllowFunctionTemplates,\n                                         bool AllowDependent) {\n  LookupResult::Filter filter = R.makeFilter();\n  while (filter.hasNext()) {\n    NamedDecl *Orig = filter.next();\n    if (!getAsTemplateNameDecl(Orig, AllowFunctionTemplates, AllowDependent))\n      filter.erase();\n  }\n  filter.done();\n}\n\nbool Sema::hasAnyAcceptableTemplateNames(LookupResult &R,\n                                         bool AllowFunctionTemplates,\n                                         bool AllowDependent,\n                                         bool AllowNonTemplateFunctions) {\n  for (LookupResult::iterator I = R.begin(), IEnd = R.end(); I != IEnd; ++I) {\n    if (getAsTemplateNameDecl(*I, AllowFunctionTemplates, AllowDependent))\n      return true;\n    if (AllowNonTemplateFunctions &&\n        isa<FunctionDecl>((*I)->getUnderlyingDecl()))\n      return true;\n  }\n\n  return false;\n}\n\nTemplateNameKind Sema::isTemplateName(Scope *S,\n                                      CXXScopeSpec &SS,\n                                      bool hasTemplateKeyword,\n                                      const UnqualifiedId &Name,\n                                      ParsedType ObjectTypePtr,\n                                      bool EnteringContext,\n                                      TemplateTy &TemplateResult,\n                                      bool &MemberOfUnknownSpecialization,\n                                      bool Disambiguation) {\n  assert(getLangOpts().CPlusPlus && \"No template names in C!\");\n\n  DeclarationName TName;\n  MemberOfUnknownSpecialization = false;\n\n  switch (Name.getKind()) {\n  case UnqualifiedIdKind::IK_Identifier:\n    TName = DeclarationName(Name.Identifier);\n    break;\n\n  case UnqualifiedIdKind::IK_OperatorFunctionId:\n    TName = Context.DeclarationNames.getCXXOperatorName(\n                                              Name.OperatorFunctionId.Operator);\n    break;\n\n  case UnqualifiedIdKind::IK_LiteralOperatorId:\n    TName = Context.DeclarationNames.getCXXLiteralOperatorName(Name.Identifier);\n    break;\n\n  default:\n    return TNK_Non_template;\n  }\n\n  QualType ObjectType = ObjectTypePtr.get();\n\n  AssumedTemplateKind AssumedTemplate;\n  LookupResult R(*this, TName, Name.getBeginLoc(), LookupOrdinaryName);\n  if (LookupTemplateName(R, S, SS, ObjectType, EnteringContext,\n                         MemberOfUnknownSpecialization, SourceLocation(),\n                         &AssumedTemplate,\n                         /*AllowTypoCorrection=*/!Disambiguation))\n    return TNK_Non_template;\n\n  if (AssumedTemplate != AssumedTemplateKind::None) {\n    TemplateResult = TemplateTy::make(Context.getAssumedTemplateName(TName));\n    // Let the parser know whether we found nothing or found functions; if we\n    // found nothing, we want to more carefully check whether this is actually\n    // a function template name versus some other kind of undeclared identifier.\n    return AssumedTemplate == AssumedTemplateKind::FoundNothing\n               ? TNK_Undeclared_template\n               : TNK_Function_template;\n  }\n\n  if (R.empty())\n    return TNK_Non_template;\n\n  NamedDecl *D = nullptr;\n  if (R.isAmbiguous()) {\n    // If we got an ambiguity involving a non-function template, treat this\n    // as a template name, and pick an arbitrary template for error recovery.\n    bool AnyFunctionTemplates = false;\n    for (NamedDecl *FoundD : R) {\n      if (NamedDecl *FoundTemplate = getAsTemplateNameDecl(FoundD)) {\n        if (isa<FunctionTemplateDecl>(FoundTemplate))\n          AnyFunctionTemplates = true;\n        else {\n          D = FoundTemplate;\n          break;\n        }\n      }\n    }\n\n    // If we didn't find any templates at all, this isn't a template name.\n    // Leave the ambiguity for a later lookup to diagnose.\n    if (!D && !AnyFunctionTemplates) {\n      R.suppressDiagnostics();\n      return TNK_Non_template;\n    }\n\n    // If the only templates were function templates, filter out the rest.\n    // We'll diagnose the ambiguity later.\n    if (!D)\n      FilterAcceptableTemplateNames(R);\n  }\n\n  // At this point, we have either picked a single template name declaration D\n  // or we have a non-empty set of results R containing either one template name\n  // declaration or a set of function templates.\n\n  TemplateName Template;\n  TemplateNameKind TemplateKind;\n\n  unsigned ResultCount = R.end() - R.begin();\n  if (!D && ResultCount > 1) {\n    // We assume that we'll preserve the qualifier from a function\n    // template name in other ways.\n    Template = Context.getOverloadedTemplateName(R.begin(), R.end());\n    TemplateKind = TNK_Function_template;\n\n    // We'll do this lookup again later.\n    R.suppressDiagnostics();\n  } else {\n    if (!D) {\n      D = getAsTemplateNameDecl(*R.begin());\n      assert(D && \"unambiguous result is not a template name\");\n    }\n\n    if (isa<UnresolvedUsingValueDecl>(D)) {\n      // We don't yet know whether this is a template-name or not.\n      MemberOfUnknownSpecialization = true;\n      return TNK_Non_template;\n    }\n\n    TemplateDecl *TD = cast<TemplateDecl>(D);\n\n    if (SS.isSet() && !SS.isInvalid()) {\n      NestedNameSpecifier *Qualifier = SS.getScopeRep();\n      Template = Context.getQualifiedTemplateName(Qualifier,\n                                                  hasTemplateKeyword, TD);\n    } else {\n      Template = TemplateName(TD);\n    }\n\n    if (isa<FunctionTemplateDecl>(TD)) {\n      TemplateKind = TNK_Function_template;\n\n      // We'll do this lookup again later.\n      R.suppressDiagnostics();\n    } else {\n      assert(isa<ClassTemplateDecl>(TD) || isa<TemplateTemplateParmDecl>(TD) ||\n             isa<TypeAliasTemplateDecl>(TD) || isa<VarTemplateDecl>(TD) ||\n             isa<BuiltinTemplateDecl>(TD) || isa<ConceptDecl>(TD));\n      TemplateKind =\n          isa<VarTemplateDecl>(TD) ? TNK_Var_template :\n          isa<ConceptDecl>(TD) ? TNK_Concept_template :\n          TNK_Type_template;\n    }\n  }\n\n  TemplateResult = TemplateTy::make(Template);\n  return TemplateKind;\n}\n\nbool Sema::isDeductionGuideName(Scope *S, const IdentifierInfo &Name,\n                                SourceLocation NameLoc,\n                                ParsedTemplateTy *Template) {\n  CXXScopeSpec SS;\n  bool MemberOfUnknownSpecialization = false;\n\n  // We could use redeclaration lookup here, but we don't need to: the\n  // syntactic form of a deduction guide is enough to identify it even\n  // if we can't look up the template name at all.\n  LookupResult R(*this, DeclarationName(&Name), NameLoc, LookupOrdinaryName);\n  if (LookupTemplateName(R, S, SS, /*ObjectType*/ QualType(),\n                         /*EnteringContext*/ false,\n                         MemberOfUnknownSpecialization))\n    return false;\n\n  if (R.empty()) return false;\n  if (R.isAmbiguous()) {\n    // FIXME: Diagnose an ambiguity if we find at least one template.\n    R.suppressDiagnostics();\n    return false;\n  }\n\n  // We only treat template-names that name type templates as valid deduction\n  // guide names.\n  TemplateDecl *TD = R.getAsSingle<TemplateDecl>();\n  if (!TD || !getAsTypeTemplateDecl(TD))\n    return false;\n\n  if (Template)\n    *Template = TemplateTy::make(TemplateName(TD));\n  return true;\n}\n\nbool Sema::DiagnoseUnknownTemplateName(const IdentifierInfo &II,\n                                       SourceLocation IILoc,\n                                       Scope *S,\n                                       const CXXScopeSpec *SS,\n                                       TemplateTy &SuggestedTemplate,\n                                       TemplateNameKind &SuggestedKind) {\n  // We can't recover unless there's a dependent scope specifier preceding the\n  // template name.\n  // FIXME: Typo correction?\n  if (!SS || !SS->isSet() || !isDependentScopeSpecifier(*SS) ||\n      computeDeclContext(*SS))\n    return false;\n\n  // The code is missing a 'template' keyword prior to the dependent template\n  // name.\n  NestedNameSpecifier *Qualifier = (NestedNameSpecifier*)SS->getScopeRep();\n  Diag(IILoc, diag::err_template_kw_missing)\n    << Qualifier << II.getName()\n    << FixItHint::CreateInsertion(IILoc, \"template \");\n  SuggestedTemplate\n    = TemplateTy::make(Context.getDependentTemplateName(Qualifier, &II));\n  SuggestedKind = TNK_Dependent_template_name;\n  return true;\n}\n\nbool Sema::LookupTemplateName(LookupResult &Found,\n                              Scope *S, CXXScopeSpec &SS,\n                              QualType ObjectType,\n                              bool EnteringContext,\n                              bool &MemberOfUnknownSpecialization,\n                              RequiredTemplateKind RequiredTemplate,\n                              AssumedTemplateKind *ATK,\n                              bool AllowTypoCorrection) {\n  if (ATK)\n    *ATK = AssumedTemplateKind::None;\n\n  if (SS.isInvalid())\n    return true;\n\n  Found.setTemplateNameLookup(true);\n\n  // Determine where to perform name lookup\n  MemberOfUnknownSpecialization = false;\n  DeclContext *LookupCtx = nullptr;\n  bool IsDependent = false;\n  if (!ObjectType.isNull()) {\n    // This nested-name-specifier occurs in a member access expression, e.g.,\n    // x->B::f, and we are looking into the type of the object.\n    assert(SS.isEmpty() && \"ObjectType and scope specifier cannot coexist\");\n    LookupCtx = computeDeclContext(ObjectType);\n    IsDependent = !LookupCtx && ObjectType->isDependentType();\n    assert((IsDependent || !ObjectType->isIncompleteType() ||\n            ObjectType->castAs<TagType>()->isBeingDefined()) &&\n           \"Caller should have completed object type\");\n\n    // Template names cannot appear inside an Objective-C class or object type\n    // or a vector type.\n    //\n    // FIXME: This is wrong. For example:\n    //\n    //   template<typename T> using Vec = T __attribute__((ext_vector_type(4)));\n    //   Vec<int> vi;\n    //   vi.Vec<int>::~Vec<int>();\n    //\n    // ... should be accepted but we will not treat 'Vec' as a template name\n    // here. The right thing to do would be to check if the name is a valid\n    // vector component name, and look up a template name if not. And similarly\n    // for lookups into Objective-C class and object types, where the same\n    // problem can arise.\n    if (ObjectType->isObjCObjectOrInterfaceType() ||\n        ObjectType->isVectorType()) {\n      Found.clear();\n      return false;\n    }\n  } else if (SS.isNotEmpty()) {\n    // This nested-name-specifier occurs after another nested-name-specifier,\n    // so long into the context associated with the prior nested-name-specifier.\n    LookupCtx = computeDeclContext(SS, EnteringContext);\n    IsDependent = !LookupCtx && isDependentScopeSpecifier(SS);\n\n    // The declaration context must be complete.\n    if (LookupCtx && RequireCompleteDeclContext(SS, LookupCtx))\n      return true;\n  }\n\n  bool ObjectTypeSearchedInScope = false;\n  bool AllowFunctionTemplatesInLookup = true;\n  if (LookupCtx) {\n    // Perform \"qualified\" name lookup into the declaration context we\n    // computed, which is either the type of the base of a member access\n    // expression or the declaration context associated with a prior\n    // nested-name-specifier.\n    LookupQualifiedName(Found, LookupCtx);\n\n    // FIXME: The C++ standard does not clearly specify what happens in the\n    // case where the object type is dependent, and implementations vary. In\n    // Clang, we treat a name after a . or -> as a template-name if lookup\n    // finds a non-dependent member or member of the current instantiation that\n    // is a type template, or finds no such members and lookup in the context\n    // of the postfix-expression finds a type template. In the latter case, the\n    // name is nonetheless dependent, and we may resolve it to a member of an\n    // unknown specialization when we come to instantiate the template.\n    IsDependent |= Found.wasNotFoundInCurrentInstantiation();\n  }\n\n  if (SS.isEmpty() && (ObjectType.isNull() || Found.empty())) {\n    // C++ [basic.lookup.classref]p1:\n    //   In a class member access expression (5.2.5), if the . or -> token is\n    //   immediately followed by an identifier followed by a <, the\n    //   identifier must be looked up to determine whether the < is the\n    //   beginning of a template argument list (14.2) or a less-than operator.\n    //   The identifier is first looked up in the class of the object\n    //   expression. If the identifier is not found, it is then looked up in\n    //   the context of the entire postfix-expression and shall name a class\n    //   template.\n    if (S)\n      LookupName(Found, S);\n\n    if (!ObjectType.isNull()) {\n      //  FIXME: We should filter out all non-type templates here, particularly\n      //  variable templates and concepts. But the exclusion of alias templates\n      //  and template template parameters is a wording defect.\n      AllowFunctionTemplatesInLookup = false;\n      ObjectTypeSearchedInScope = true;\n    }\n\n    IsDependent |= Found.wasNotFoundInCurrentInstantiation();\n  }\n\n  if (Found.isAmbiguous())\n    return false;\n\n  if (ATK && SS.isEmpty() && ObjectType.isNull() &&\n      !RequiredTemplate.hasTemplateKeyword()) {\n    // C++2a [temp.names]p2:\n    //   A name is also considered to refer to a template if it is an\n    //   unqualified-id followed by a < and name lookup finds either one or more\n    //   functions or finds nothing.\n    //\n    // To keep our behavior consistent, we apply the \"finds nothing\" part in\n    // all language modes, and diagnose the empty lookup in ActOnCallExpr if we\n    // successfully form a call to an undeclared template-id.\n    bool AllFunctions =\n        getLangOpts().CPlusPlus20 &&\n        std::all_of(Found.begin(), Found.end(), [](NamedDecl *ND) {\n          return isa<FunctionDecl>(ND->getUnderlyingDecl());\n        });\n    if (AllFunctions || (Found.empty() && !IsDependent)) {\n      // If lookup found any functions, or if this is a name that can only be\n      // used for a function, then strongly assume this is a function\n      // template-id.\n      *ATK = (Found.empty() && Found.getLookupName().isIdentifier())\n                 ? AssumedTemplateKind::FoundNothing\n                 : AssumedTemplateKind::FoundFunctions;\n      Found.clear();\n      return false;\n    }\n  }\n\n  if (Found.empty() && !IsDependent && AllowTypoCorrection) {\n    // If we did not find any names, and this is not a disambiguation, attempt\n    // to correct any typos.\n    DeclarationName Name = Found.getLookupName();\n    Found.clear();\n    // Simple filter callback that, for keywords, only accepts the C++ *_cast\n    DefaultFilterCCC FilterCCC{};\n    FilterCCC.WantTypeSpecifiers = false;\n    FilterCCC.WantExpressionKeywords = false;\n    FilterCCC.WantRemainingKeywords = false;\n    FilterCCC.WantCXXNamedCasts = true;\n    if (TypoCorrection Corrected =\n            CorrectTypo(Found.getLookupNameInfo(), Found.getLookupKind(), S,\n                        &SS, FilterCCC, CTK_ErrorRecovery, LookupCtx)) {\n      if (auto *ND = Corrected.getFoundDecl())\n        Found.addDecl(ND);\n      FilterAcceptableTemplateNames(Found);\n      if (Found.isAmbiguous()) {\n        Found.clear();\n      } else if (!Found.empty()) {\n        Found.setLookupName(Corrected.getCorrection());\n        if (LookupCtx) {\n          std::string CorrectedStr(Corrected.getAsString(getLangOpts()));\n          bool DroppedSpecifier = Corrected.WillReplaceSpecifier() &&\n                                  Name.getAsString() == CorrectedStr;\n          diagnoseTypo(Corrected, PDiag(diag::err_no_member_template_suggest)\n                                    << Name << LookupCtx << DroppedSpecifier\n                                    << SS.getRange());\n        } else {\n          diagnoseTypo(Corrected, PDiag(diag::err_no_template_suggest) << Name);\n        }\n      }\n    }\n  }\n\n  NamedDecl *ExampleLookupResult =\n      Found.empty() ? nullptr : Found.getRepresentativeDecl();\n  FilterAcceptableTemplateNames(Found, AllowFunctionTemplatesInLookup);\n  if (Found.empty()) {\n    if (IsDependent) {\n      MemberOfUnknownSpecialization = true;\n      return false;\n    }\n\n    // If a 'template' keyword was used, a lookup that finds only non-template\n    // names is an error.\n    if (ExampleLookupResult && RequiredTemplate) {\n      Diag(Found.getNameLoc(), diag::err_template_kw_refers_to_non_template)\n          << Found.getLookupName() << SS.getRange()\n          << RequiredTemplate.hasTemplateKeyword()\n          << RequiredTemplate.getTemplateKeywordLoc();\n      Diag(ExampleLookupResult->getUnderlyingDecl()->getLocation(),\n           diag::note_template_kw_refers_to_non_template)\n          << Found.getLookupName();\n      return true;\n    }\n\n    return false;\n  }\n\n  if (S && !ObjectType.isNull() && !ObjectTypeSearchedInScope &&\n      !getLangOpts().CPlusPlus11) {\n    // C++03 [basic.lookup.classref]p1:\n    //   [...] If the lookup in the class of the object expression finds a\n    //   template, the name is also looked up in the context of the entire\n    //   postfix-expression and [...]\n    //\n    // Note: C++11 does not perform this second lookup.\n    LookupResult FoundOuter(*this, Found.getLookupName(), Found.getNameLoc(),\n                            LookupOrdinaryName);\n    FoundOuter.setTemplateNameLookup(true);\n    LookupName(FoundOuter, S);\n    // FIXME: We silently accept an ambiguous lookup here, in violation of\n    // [basic.lookup]/1.\n    FilterAcceptableTemplateNames(FoundOuter, /*AllowFunctionTemplates=*/false);\n\n    NamedDecl *OuterTemplate;\n    if (FoundOuter.empty()) {\n      //   - if the name is not found, the name found in the class of the\n      //     object expression is used, otherwise\n    } else if (FoundOuter.isAmbiguous() || !FoundOuter.isSingleResult() ||\n               !(OuterTemplate =\n                     getAsTemplateNameDecl(FoundOuter.getFoundDecl()))) {\n      //   - if the name is found in the context of the entire\n      //     postfix-expression and does not name a class template, the name\n      //     found in the class of the object expression is used, otherwise\n      FoundOuter.clear();\n    } else if (!Found.isSuppressingDiagnostics()) {\n      //   - if the name found is a class template, it must refer to the same\n      //     entity as the one found in the class of the object expression,\n      //     otherwise the program is ill-formed.\n      if (!Found.isSingleResult() ||\n          getAsTemplateNameDecl(Found.getFoundDecl())->getCanonicalDecl() !=\n              OuterTemplate->getCanonicalDecl()) {\n        Diag(Found.getNameLoc(),\n             diag::ext_nested_name_member_ref_lookup_ambiguous)\n          << Found.getLookupName()\n          << ObjectType;\n        Diag(Found.getRepresentativeDecl()->getLocation(),\n             diag::note_ambig_member_ref_object_type)\n          << ObjectType;\n        Diag(FoundOuter.getFoundDecl()->getLocation(),\n             diag::note_ambig_member_ref_scope);\n\n        // Recover by taking the template that we found in the object\n        // expression's type.\n      }\n    }\n  }\n\n  return false;\n}\n\nvoid Sema::diagnoseExprIntendedAsTemplateName(Scope *S, ExprResult TemplateName,\n                                              SourceLocation Less,\n                                              SourceLocation Greater) {\n  if (TemplateName.isInvalid())\n    return;\n\n  DeclarationNameInfo NameInfo;\n  CXXScopeSpec SS;\n  LookupNameKind LookupKind;\n\n  DeclContext *LookupCtx = nullptr;\n  NamedDecl *Found = nullptr;\n  bool MissingTemplateKeyword = false;\n\n  // Figure out what name we looked up.\n  if (auto *DRE = dyn_cast<DeclRefExpr>(TemplateName.get())) {\n    NameInfo = DRE->getNameInfo();\n    SS.Adopt(DRE->getQualifierLoc());\n    LookupKind = LookupOrdinaryName;\n    Found = DRE->getFoundDecl();\n  } else if (auto *ME = dyn_cast<MemberExpr>(TemplateName.get())) {\n    NameInfo = ME->getMemberNameInfo();\n    SS.Adopt(ME->getQualifierLoc());\n    LookupKind = LookupMemberName;\n    LookupCtx = ME->getBase()->getType()->getAsCXXRecordDecl();\n    Found = ME->getMemberDecl();\n  } else if (auto *DSDRE =\n                 dyn_cast<DependentScopeDeclRefExpr>(TemplateName.get())) {\n    NameInfo = DSDRE->getNameInfo();\n    SS.Adopt(DSDRE->getQualifierLoc());\n    MissingTemplateKeyword = true;\n  } else if (auto *DSME =\n                 dyn_cast<CXXDependentScopeMemberExpr>(TemplateName.get())) {\n    NameInfo = DSME->getMemberNameInfo();\n    SS.Adopt(DSME->getQualifierLoc());\n    MissingTemplateKeyword = true;\n  } else {\n    llvm_unreachable(\"unexpected kind of potential template name\");\n  }\n\n  // If this is a dependent-scope lookup, diagnose that the 'template' keyword\n  // was missing.\n  if (MissingTemplateKeyword) {\n    Diag(NameInfo.getBeginLoc(), diag::err_template_kw_missing)\n        << \"\" << NameInfo.getName().getAsString() << SourceRange(Less, Greater);\n    return;\n  }\n\n  // Try to correct the name by looking for templates and C++ named casts.\n  struct TemplateCandidateFilter : CorrectionCandidateCallback {\n    Sema &S;\n    TemplateCandidateFilter(Sema &S) : S(S) {\n      WantTypeSpecifiers = false;\n      WantExpressionKeywords = false;\n      WantRemainingKeywords = false;\n      WantCXXNamedCasts = true;\n    };\n    bool ValidateCandidate(const TypoCorrection &Candidate) override {\n      if (auto *ND = Candidate.getCorrectionDecl())\n        return S.getAsTemplateNameDecl(ND);\n      return Candidate.isKeyword();\n    }\n\n    std::unique_ptr<CorrectionCandidateCallback> clone() override {\n      return std::make_unique<TemplateCandidateFilter>(*this);\n    }\n  };\n\n  DeclarationName Name = NameInfo.getName();\n  TemplateCandidateFilter CCC(*this);\n  if (TypoCorrection Corrected = CorrectTypo(NameInfo, LookupKind, S, &SS, CCC,\n                                             CTK_ErrorRecovery, LookupCtx)) {\n    auto *ND = Corrected.getFoundDecl();\n    if (ND)\n      ND = getAsTemplateNameDecl(ND);\n    if (ND || Corrected.isKeyword()) {\n      if (LookupCtx) {\n        std::string CorrectedStr(Corrected.getAsString(getLangOpts()));\n        bool DroppedSpecifier = Corrected.WillReplaceSpecifier() &&\n                                Name.getAsString() == CorrectedStr;\n        diagnoseTypo(Corrected,\n                     PDiag(diag::err_non_template_in_member_template_id_suggest)\n                         << Name << LookupCtx << DroppedSpecifier\n                         << SS.getRange(), false);\n      } else {\n        diagnoseTypo(Corrected,\n                     PDiag(diag::err_non_template_in_template_id_suggest)\n                         << Name, false);\n      }\n      if (Found)\n        Diag(Found->getLocation(),\n             diag::note_non_template_in_template_id_found);\n      return;\n    }\n  }\n\n  Diag(NameInfo.getLoc(), diag::err_non_template_in_template_id)\n    << Name << SourceRange(Less, Greater);\n  if (Found)\n    Diag(Found->getLocation(), diag::note_non_template_in_template_id_found);\n}\n\n/// ActOnDependentIdExpression - Handle a dependent id-expression that\n/// was just parsed.  This is only possible with an explicit scope\n/// specifier naming a dependent type.\nExprResult\nSema::ActOnDependentIdExpression(const CXXScopeSpec &SS,\n                                 SourceLocation TemplateKWLoc,\n                                 const DeclarationNameInfo &NameInfo,\n                                 bool isAddressOfOperand,\n                           const TemplateArgumentListInfo *TemplateArgs) {\n  DeclContext *DC = getFunctionLevelDeclContext();\n\n  // C++11 [expr.prim.general]p12:\n  //   An id-expression that denotes a non-static data member or non-static\n  //   member function of a class can only be used:\n  //   (...)\n  //   - if that id-expression denotes a non-static data member and it\n  //     appears in an unevaluated operand.\n  //\n  // If this might be the case, form a DependentScopeDeclRefExpr instead of a\n  // CXXDependentScopeMemberExpr. The former can instantiate to either\n  // DeclRefExpr or MemberExpr depending on lookup results, while the latter is\n  // always a MemberExpr.\n  bool MightBeCxx11UnevalField =\n      getLangOpts().CPlusPlus11 && isUnevaluatedContext();\n\n  // Check if the nested name specifier is an enum type.\n  bool IsEnum = false;\n  if (NestedNameSpecifier *NNS = SS.getScopeRep())\n    IsEnum = dyn_cast_or_null<EnumType>(NNS->getAsType());\n\n  if (!MightBeCxx11UnevalField && !isAddressOfOperand && !IsEnum &&\n      isa<CXXMethodDecl>(DC) && cast<CXXMethodDecl>(DC)->isInstance()) {\n    QualType ThisType = cast<CXXMethodDecl>(DC)->getThisType();\n\n    // Since the 'this' expression is synthesized, we don't need to\n    // perform the double-lookup check.\n    NamedDecl *FirstQualifierInScope = nullptr;\n\n    return CXXDependentScopeMemberExpr::Create(\n        Context, /*This*/ nullptr, ThisType, /*IsArrow*/ true,\n        /*Op*/ SourceLocation(), SS.getWithLocInContext(Context), TemplateKWLoc,\n        FirstQualifierInScope, NameInfo, TemplateArgs);\n  }\n\n  return BuildDependentDeclRefExpr(SS, TemplateKWLoc, NameInfo, TemplateArgs);\n}\n\nExprResult\nSema::BuildDependentDeclRefExpr(const CXXScopeSpec &SS,\n                                SourceLocation TemplateKWLoc,\n                                const DeclarationNameInfo &NameInfo,\n                                const TemplateArgumentListInfo *TemplateArgs) {\n  // DependentScopeDeclRefExpr::Create requires a valid QualifierLoc\n  NestedNameSpecifierLoc QualifierLoc = SS.getWithLocInContext(Context);\n  if (!QualifierLoc)\n    return ExprError();\n\n  return DependentScopeDeclRefExpr::Create(\n      Context, QualifierLoc, TemplateKWLoc, NameInfo, TemplateArgs);\n}\n\n\n/// Determine whether we would be unable to instantiate this template (because\n/// it either has no definition, or is in the process of being instantiated).\nbool Sema::DiagnoseUninstantiableTemplate(SourceLocation PointOfInstantiation,\n                                          NamedDecl *Instantiation,\n                                          bool InstantiatedFromMember,\n                                          const NamedDecl *Pattern,\n                                          const NamedDecl *PatternDef,\n                                          TemplateSpecializationKind TSK,\n                                          bool Complain /*= true*/) {\n  assert(isa<TagDecl>(Instantiation) || isa<FunctionDecl>(Instantiation) ||\n         isa<VarDecl>(Instantiation));\n\n  bool IsEntityBeingDefined = false;\n  if (const TagDecl *TD = dyn_cast_or_null<TagDecl>(PatternDef))\n    IsEntityBeingDefined = TD->isBeingDefined();\n\n  if (PatternDef && !IsEntityBeingDefined) {\n    NamedDecl *SuggestedDef = nullptr;\n    if (!hasVisibleDefinition(const_cast<NamedDecl*>(PatternDef), &SuggestedDef,\n                              /*OnlyNeedComplete*/false)) {\n      // If we're allowed to diagnose this and recover, do so.\n      bool Recover = Complain && !isSFINAEContext();\n      if (Complain)\n        diagnoseMissingImport(PointOfInstantiation, SuggestedDef,\n                              Sema::MissingImportKind::Definition, Recover);\n      return !Recover;\n    }\n    return false;\n  }\n\n  if (!Complain || (PatternDef && PatternDef->isInvalidDecl()))\n    return true;\n\n  llvm::Optional<unsigned> Note;\n  QualType InstantiationTy;\n  if (TagDecl *TD = dyn_cast<TagDecl>(Instantiation))\n    InstantiationTy = Context.getTypeDeclType(TD);\n  if (PatternDef) {\n    Diag(PointOfInstantiation,\n         diag::err_template_instantiate_within_definition)\n      << /*implicit|explicit*/(TSK != TSK_ImplicitInstantiation)\n      << InstantiationTy;\n    // Not much point in noting the template declaration here, since\n    // we're lexically inside it.\n    Instantiation->setInvalidDecl();\n  } else if (InstantiatedFromMember) {\n    if (isa<FunctionDecl>(Instantiation)) {\n      Diag(PointOfInstantiation,\n           diag::err_explicit_instantiation_undefined_member)\n        << /*member function*/ 1 << Instantiation->getDeclName()\n        << Instantiation->getDeclContext();\n      Note = diag::note_explicit_instantiation_here;\n    } else {\n      assert(isa<TagDecl>(Instantiation) && \"Must be a TagDecl!\");\n      Diag(PointOfInstantiation,\n           diag::err_implicit_instantiate_member_undefined)\n        << InstantiationTy;\n      Note = diag::note_member_declared_at;\n    }\n  } else {\n    if (isa<FunctionDecl>(Instantiation)) {\n      Diag(PointOfInstantiation,\n           diag::err_explicit_instantiation_undefined_func_template)\n        << Pattern;\n      Note = diag::note_explicit_instantiation_here;\n    } else if (isa<TagDecl>(Instantiation)) {\n      Diag(PointOfInstantiation, diag::err_template_instantiate_undefined)\n        << (TSK != TSK_ImplicitInstantiation)\n        << InstantiationTy;\n      Note = diag::note_template_decl_here;\n    } else {\n      assert(isa<VarDecl>(Instantiation) && \"Must be a VarDecl!\");\n      if (isa<VarTemplateSpecializationDecl>(Instantiation)) {\n        Diag(PointOfInstantiation,\n             diag::err_explicit_instantiation_undefined_var_template)\n          << Instantiation;\n        Instantiation->setInvalidDecl();\n      } else\n        Diag(PointOfInstantiation,\n             diag::err_explicit_instantiation_undefined_member)\n          << /*static data member*/ 2 << Instantiation->getDeclName()\n          << Instantiation->getDeclContext();\n      Note = diag::note_explicit_instantiation_here;\n    }\n  }\n  if (Note) // Diagnostics were emitted.\n    Diag(Pattern->getLocation(), Note.getValue());\n\n  // In general, Instantiation isn't marked invalid to get more than one\n  // error for multiple undefined instantiations. But the code that does\n  // explicit declaration -> explicit definition conversion can't handle\n  // invalid declarations, so mark as invalid in that case.\n  if (TSK == TSK_ExplicitInstantiationDeclaration)\n    Instantiation->setInvalidDecl();\n  return true;\n}\n\n/// DiagnoseTemplateParameterShadow - Produce a diagnostic complaining\n/// that the template parameter 'PrevDecl' is being shadowed by a new\n/// declaration at location Loc. Returns true to indicate that this is\n/// an error, and false otherwise.\nvoid Sema::DiagnoseTemplateParameterShadow(SourceLocation Loc, Decl *PrevDecl) {\n  assert(PrevDecl->isTemplateParameter() && \"Not a template parameter\");\n\n  // C++ [temp.local]p4:\n  //   A template-parameter shall not be redeclared within its\n  //   scope (including nested scopes).\n  //\n  // Make this a warning when MSVC compatibility is requested.\n  unsigned DiagId = getLangOpts().MSVCCompat ? diag::ext_template_param_shadow\n                                             : diag::err_template_param_shadow;\n  Diag(Loc, DiagId) << cast<NamedDecl>(PrevDecl)->getDeclName();\n  Diag(PrevDecl->getLocation(), diag::note_template_param_here);\n}\n\n/// AdjustDeclIfTemplate - If the given decl happens to be a template, reset\n/// the parameter D to reference the templated declaration and return a pointer\n/// to the template declaration. Otherwise, do nothing to D and return null.\nTemplateDecl *Sema::AdjustDeclIfTemplate(Decl *&D) {\n  if (TemplateDecl *Temp = dyn_cast_or_null<TemplateDecl>(D)) {\n    D = Temp->getTemplatedDecl();\n    return Temp;\n  }\n  return nullptr;\n}\n\nParsedTemplateArgument ParsedTemplateArgument::getTemplatePackExpansion(\n                                             SourceLocation EllipsisLoc) const {\n  assert(Kind == Template &&\n         \"Only template template arguments can be pack expansions here\");\n  assert(getAsTemplate().get().containsUnexpandedParameterPack() &&\n         \"Template template argument pack expansion without packs\");\n  ParsedTemplateArgument Result(*this);\n  Result.EllipsisLoc = EllipsisLoc;\n  return Result;\n}\n\nstatic TemplateArgumentLoc translateTemplateArgument(Sema &SemaRef,\n                                            const ParsedTemplateArgument &Arg) {\n\n  switch (Arg.getKind()) {\n  case ParsedTemplateArgument::Type: {\n    TypeSourceInfo *DI;\n    QualType T = SemaRef.GetTypeFromParser(Arg.getAsType(), &DI);\n    if (!DI)\n      DI = SemaRef.Context.getTrivialTypeSourceInfo(T, Arg.getLocation());\n    return TemplateArgumentLoc(TemplateArgument(T), DI);\n  }\n\n  case ParsedTemplateArgument::NonType: {\n    Expr *E = static_cast<Expr *>(Arg.getAsExpr());\n    return TemplateArgumentLoc(TemplateArgument(E), E);\n  }\n\n  case ParsedTemplateArgument::Template: {\n    TemplateName Template = Arg.getAsTemplate().get();\n    TemplateArgument TArg;\n    if (Arg.getEllipsisLoc().isValid())\n      TArg = TemplateArgument(Template, Optional<unsigned int>());\n    else\n      TArg = Template;\n    return TemplateArgumentLoc(\n        SemaRef.Context, TArg,\n        Arg.getScopeSpec().getWithLocInContext(SemaRef.Context),\n        Arg.getLocation(), Arg.getEllipsisLoc());\n  }\n  }\n\n  llvm_unreachable(\"Unhandled parsed template argument\");\n}\n\n/// Translates template arguments as provided by the parser\n/// into template arguments used by semantic analysis.\nvoid Sema::translateTemplateArguments(const ASTTemplateArgsPtr &TemplateArgsIn,\n                                      TemplateArgumentListInfo &TemplateArgs) {\n for (unsigned I = 0, Last = TemplateArgsIn.size(); I != Last; ++I)\n   TemplateArgs.addArgument(translateTemplateArgument(*this,\n                                                      TemplateArgsIn[I]));\n}\n\nstatic void maybeDiagnoseTemplateParameterShadow(Sema &SemaRef, Scope *S,\n                                                 SourceLocation Loc,\n                                                 IdentifierInfo *Name) {\n  NamedDecl *PrevDecl = SemaRef.LookupSingleName(\n      S, Name, Loc, Sema::LookupOrdinaryName, Sema::ForVisibleRedeclaration);\n  if (PrevDecl && PrevDecl->isTemplateParameter())\n    SemaRef.DiagnoseTemplateParameterShadow(Loc, PrevDecl);\n}\n\n/// Convert a parsed type into a parsed template argument. This is mostly\n/// trivial, except that we may have parsed a C++17 deduced class template\n/// specialization type, in which case we should form a template template\n/// argument instead of a type template argument.\nParsedTemplateArgument Sema::ActOnTemplateTypeArgument(TypeResult ParsedType) {\n  TypeSourceInfo *TInfo;\n  QualType T = GetTypeFromParser(ParsedType.get(), &TInfo);\n  if (T.isNull())\n    return ParsedTemplateArgument();\n  assert(TInfo && \"template argument with no location\");\n\n  // If we might have formed a deduced template specialization type, convert\n  // it to a template template argument.\n  if (getLangOpts().CPlusPlus17) {\n    TypeLoc TL = TInfo->getTypeLoc();\n    SourceLocation EllipsisLoc;\n    if (auto PET = TL.getAs<PackExpansionTypeLoc>()) {\n      EllipsisLoc = PET.getEllipsisLoc();\n      TL = PET.getPatternLoc();\n    }\n\n    CXXScopeSpec SS;\n    if (auto ET = TL.getAs<ElaboratedTypeLoc>()) {\n      SS.Adopt(ET.getQualifierLoc());\n      TL = ET.getNamedTypeLoc();\n    }\n\n    if (auto DTST = TL.getAs<DeducedTemplateSpecializationTypeLoc>()) {\n      TemplateName Name = DTST.getTypePtr()->getTemplateName();\n      if (SS.isSet())\n        Name = Context.getQualifiedTemplateName(SS.getScopeRep(),\n                                                /*HasTemplateKeyword*/ false,\n                                                Name.getAsTemplateDecl());\n      ParsedTemplateArgument Result(SS, TemplateTy::make(Name),\n                                    DTST.getTemplateNameLoc());\n      if (EllipsisLoc.isValid())\n        Result = Result.getTemplatePackExpansion(EllipsisLoc);\n      return Result;\n    }\n  }\n\n  // This is a normal type template argument. Note, if the type template\n  // argument is an injected-class-name for a template, it has a dual nature\n  // and can be used as either a type or a template. We handle that in\n  // convertTypeTemplateArgumentToTemplate.\n  return ParsedTemplateArgument(ParsedTemplateArgument::Type,\n                                ParsedType.get().getAsOpaquePtr(),\n                                TInfo->getTypeLoc().getBeginLoc());\n}\n\n/// ActOnTypeParameter - Called when a C++ template type parameter\n/// (e.g., \"typename T\") has been parsed. Typename specifies whether\n/// the keyword \"typename\" was used to declare the type parameter\n/// (otherwise, \"class\" was used), and KeyLoc is the location of the\n/// \"class\" or \"typename\" keyword. ParamName is the name of the\n/// parameter (NULL indicates an unnamed template parameter) and\n/// ParamNameLoc is the location of the parameter name (if any).\n/// If the type parameter has a default argument, it will be added\n/// later via ActOnTypeParameterDefault.\nNamedDecl *Sema::ActOnTypeParameter(Scope *S, bool Typename,\n                                    SourceLocation EllipsisLoc,\n                                    SourceLocation KeyLoc,\n                                    IdentifierInfo *ParamName,\n                                    SourceLocation ParamNameLoc,\n                                    unsigned Depth, unsigned Position,\n                                    SourceLocation EqualLoc,\n                                    ParsedType DefaultArg,\n                                    bool HasTypeConstraint) {\n  assert(S->isTemplateParamScope() &&\n         \"Template type parameter not in template parameter scope!\");\n\n  bool IsParameterPack = EllipsisLoc.isValid();\n  TemplateTypeParmDecl *Param\n    = TemplateTypeParmDecl::Create(Context, Context.getTranslationUnitDecl(),\n                                   KeyLoc, ParamNameLoc, Depth, Position,\n                                   ParamName, Typename, IsParameterPack,\n                                   HasTypeConstraint);\n  Param->setAccess(AS_public);\n\n  if (Param->isParameterPack())\n    if (auto *LSI = getEnclosingLambda())\n      LSI->LocalPacks.push_back(Param);\n\n  if (ParamName) {\n    maybeDiagnoseTemplateParameterShadow(*this, S, ParamNameLoc, ParamName);\n\n    // Add the template parameter into the current scope.\n    S->AddDecl(Param);\n    IdResolver.AddDecl(Param);\n  }\n\n  // C++0x [temp.param]p9:\n  //   A default template-argument may be specified for any kind of\n  //   template-parameter that is not a template parameter pack.\n  if (DefaultArg && IsParameterPack) {\n    Diag(EqualLoc, diag::err_template_param_pack_default_arg);\n    DefaultArg = nullptr;\n  }\n\n  // Handle the default argument, if provided.\n  if (DefaultArg) {\n    TypeSourceInfo *DefaultTInfo;\n    GetTypeFromParser(DefaultArg, &DefaultTInfo);\n\n    assert(DefaultTInfo && \"expected source information for type\");\n\n    // Check for unexpanded parameter packs.\n    if (DiagnoseUnexpandedParameterPack(ParamNameLoc, DefaultTInfo,\n                                        UPPC_DefaultArgument))\n      return Param;\n\n    // Check the template argument itself.\n    if (CheckTemplateArgument(Param, DefaultTInfo)) {\n      Param->setInvalidDecl();\n      return Param;\n    }\n\n    Param->setDefaultArgument(DefaultTInfo);\n  }\n\n  return Param;\n}\n\n/// Convert the parser's template argument list representation into our form.\nstatic TemplateArgumentListInfo\nmakeTemplateArgumentListInfo(Sema &S, TemplateIdAnnotation &TemplateId) {\n  TemplateArgumentListInfo TemplateArgs(TemplateId.LAngleLoc,\n                                        TemplateId.RAngleLoc);\n  ASTTemplateArgsPtr TemplateArgsPtr(TemplateId.getTemplateArgs(),\n                                     TemplateId.NumArgs);\n  S.translateTemplateArguments(TemplateArgsPtr, TemplateArgs);\n  return TemplateArgs;\n}\n\nbool Sema::ActOnTypeConstraint(const CXXScopeSpec &SS,\n                               TemplateIdAnnotation *TypeConstr,\n                               TemplateTypeParmDecl *ConstrainedParameter,\n                               SourceLocation EllipsisLoc) {\n  ConceptDecl *CD =\n      cast<ConceptDecl>(TypeConstr->Template.get().getAsTemplateDecl());\n\n  // C++2a [temp.param]p4:\n  //     [...] The concept designated by a type-constraint shall be a type\n  //     concept ([temp.concept]).\n  if (!CD->isTypeConcept()) {\n    Diag(TypeConstr->TemplateNameLoc,\n         diag::err_type_constraint_non_type_concept);\n    return true;\n  }\n\n  bool WereArgsSpecified = TypeConstr->LAngleLoc.isValid();\n\n  if (!WereArgsSpecified &&\n      CD->getTemplateParameters()->getMinRequiredArguments() > 1) {\n    Diag(TypeConstr->TemplateNameLoc,\n         diag::err_type_constraint_missing_arguments) << CD;\n    return true;\n  }\n\n  TemplateArgumentListInfo TemplateArgs;\n  if (TypeConstr->LAngleLoc.isValid()) {\n    TemplateArgs =\n        makeTemplateArgumentListInfo(*this, *TypeConstr);\n  }\n  return AttachTypeConstraint(\n      SS.isSet() ? SS.getWithLocInContext(Context) : NestedNameSpecifierLoc(),\n      DeclarationNameInfo(DeclarationName(TypeConstr->Name),\n                          TypeConstr->TemplateNameLoc), CD,\n      TypeConstr->LAngleLoc.isValid() ? &TemplateArgs : nullptr,\n      ConstrainedParameter, EllipsisLoc);\n}\n\ntemplate<typename ArgumentLocAppender>\nstatic ExprResult formImmediatelyDeclaredConstraint(\n    Sema &S, NestedNameSpecifierLoc NS, DeclarationNameInfo NameInfo,\n    ConceptDecl *NamedConcept, SourceLocation LAngleLoc,\n    SourceLocation RAngleLoc, QualType ConstrainedType,\n    SourceLocation ParamNameLoc, ArgumentLocAppender Appender,\n    SourceLocation EllipsisLoc) {\n\n  TemplateArgumentListInfo ConstraintArgs;\n  ConstraintArgs.addArgument(\n    S.getTrivialTemplateArgumentLoc(TemplateArgument(ConstrainedType),\n                                    /*NTTPType=*/QualType(), ParamNameLoc));\n\n  ConstraintArgs.setRAngleLoc(RAngleLoc);\n  ConstraintArgs.setLAngleLoc(LAngleLoc);\n  Appender(ConstraintArgs);\n\n  // C++2a [temp.param]p4:\n  //     [...] This constraint-expression E is called the immediately-declared\n  //     constraint of T. [...]\n  CXXScopeSpec SS;\n  SS.Adopt(NS);\n  ExprResult ImmediatelyDeclaredConstraint = S.CheckConceptTemplateId(\n      SS, /*TemplateKWLoc=*/SourceLocation(), NameInfo,\n      /*FoundDecl=*/NamedConcept, NamedConcept, &ConstraintArgs);\n  if (ImmediatelyDeclaredConstraint.isInvalid() || !EllipsisLoc.isValid())\n    return ImmediatelyDeclaredConstraint;\n\n  // C++2a [temp.param]p4:\n  //     [...] If T is not a pack, then E is E', otherwise E is (E' && ...).\n  //\n  // We have the following case:\n  //\n  // template<typename T> concept C1 = true;\n  // template<C1... T> struct s1;\n  //\n  // The constraint: (C1<T> && ...)\n  //\n  // Note that the type of C1<T> is known to be 'bool', so we don't need to do\n  // any unqualified lookups for 'operator&&' here.\n  return S.BuildCXXFoldExpr(/*UnqualifiedLookup=*/nullptr,\n                            /*LParenLoc=*/SourceLocation(),\n                            ImmediatelyDeclaredConstraint.get(), BO_LAnd,\n                            EllipsisLoc, /*RHS=*/nullptr,\n                            /*RParenLoc=*/SourceLocation(),\n                            /*NumExpansions=*/None);\n}\n\n/// Attach a type-constraint to a template parameter.\n/// \\returns true if an error occured. This can happen if the\n/// immediately-declared constraint could not be formed (e.g. incorrect number\n/// of arguments for the named concept).\nbool Sema::AttachTypeConstraint(NestedNameSpecifierLoc NS,\n                                DeclarationNameInfo NameInfo,\n                                ConceptDecl *NamedConcept,\n                                const TemplateArgumentListInfo *TemplateArgs,\n                                TemplateTypeParmDecl *ConstrainedParameter,\n                                SourceLocation EllipsisLoc) {\n  // C++2a [temp.param]p4:\n  //     [...] If Q is of the form C<A1, ..., An>, then let E' be\n  //     C<T, A1, ..., An>. Otherwise, let E' be C<T>. [...]\n  const ASTTemplateArgumentListInfo *ArgsAsWritten =\n    TemplateArgs ? ASTTemplateArgumentListInfo::Create(Context,\n                                                       *TemplateArgs) : nullptr;\n\n  QualType ParamAsArgument(ConstrainedParameter->getTypeForDecl(), 0);\n\n  ExprResult ImmediatelyDeclaredConstraint =\n      formImmediatelyDeclaredConstraint(\n          *this, NS, NameInfo, NamedConcept,\n          TemplateArgs ? TemplateArgs->getLAngleLoc() : SourceLocation(),\n          TemplateArgs ? TemplateArgs->getRAngleLoc() : SourceLocation(),\n          ParamAsArgument, ConstrainedParameter->getLocation(),\n          [&] (TemplateArgumentListInfo &ConstraintArgs) {\n            if (TemplateArgs)\n              for (const auto &ArgLoc : TemplateArgs->arguments())\n                ConstraintArgs.addArgument(ArgLoc);\n          }, EllipsisLoc);\n  if (ImmediatelyDeclaredConstraint.isInvalid())\n    return true;\n\n  ConstrainedParameter->setTypeConstraint(NS, NameInfo,\n                                          /*FoundDecl=*/NamedConcept,\n                                          NamedConcept, ArgsAsWritten,\n                                          ImmediatelyDeclaredConstraint.get());\n  return false;\n}\n\nbool Sema::AttachTypeConstraint(AutoTypeLoc TL, NonTypeTemplateParmDecl *NTTP,\n                                SourceLocation EllipsisLoc) {\n  if (NTTP->getType() != TL.getType() ||\n      TL.getAutoKeyword() != AutoTypeKeyword::Auto) {\n    Diag(NTTP->getTypeSourceInfo()->getTypeLoc().getBeginLoc(),\n         diag::err_unsupported_placeholder_constraint)\n       << NTTP->getTypeSourceInfo()->getTypeLoc().getSourceRange();\n    return true;\n  }\n  // FIXME: Concepts: This should be the type of the placeholder, but this is\n  // unclear in the wording right now.\n  DeclRefExpr *Ref = BuildDeclRefExpr(NTTP, NTTP->getType(), VK_RValue,\n                                      NTTP->getLocation());\n  if (!Ref)\n    return true;\n  ExprResult ImmediatelyDeclaredConstraint =\n      formImmediatelyDeclaredConstraint(\n          *this, TL.getNestedNameSpecifierLoc(), TL.getConceptNameInfo(),\n          TL.getNamedConcept(), TL.getLAngleLoc(), TL.getRAngleLoc(),\n          BuildDecltypeType(Ref, NTTP->getLocation()), NTTP->getLocation(),\n          [&] (TemplateArgumentListInfo &ConstraintArgs) {\n            for (unsigned I = 0, C = TL.getNumArgs(); I != C; ++I)\n              ConstraintArgs.addArgument(TL.getArgLoc(I));\n          }, EllipsisLoc);\n  if (ImmediatelyDeclaredConstraint.isInvalid() ||\n     !ImmediatelyDeclaredConstraint.isUsable())\n    return true;\n\n  NTTP->setPlaceholderTypeConstraint(ImmediatelyDeclaredConstraint.get());\n  return false;\n}\n\n/// Check that the type of a non-type template parameter is\n/// well-formed.\n///\n/// \\returns the (possibly-promoted) parameter type if valid;\n/// otherwise, produces a diagnostic and returns a NULL type.\nQualType Sema::CheckNonTypeTemplateParameterType(TypeSourceInfo *&TSI,\n                                                 SourceLocation Loc) {\n  if (TSI->getType()->isUndeducedType()) {\n    // C++17 [temp.dep.expr]p3:\n    //   An id-expression is type-dependent if it contains\n    //    - an identifier associated by name lookup with a non-type\n    //      template-parameter declared with a type that contains a\n    //      placeholder type (7.1.7.4),\n    TSI = SubstAutoTypeSourceInfo(TSI, Context.DependentTy);\n  }\n\n  return CheckNonTypeTemplateParameterType(TSI->getType(), Loc);\n}\n\n/// Require the given type to be a structural type, and diagnose if it is not.\n///\n/// \\return \\c true if an error was produced.\nbool Sema::RequireStructuralType(QualType T, SourceLocation Loc) {\n  if (T->isDependentType())\n    return false;\n\n  if (RequireCompleteType(Loc, T, diag::err_template_nontype_parm_incomplete))\n    return true;\n\n  if (T->isStructuralType())\n    return false;\n\n  // Structural types are required to be object types or lvalue references.\n  if (T->isRValueReferenceType()) {\n    Diag(Loc, diag::err_template_nontype_parm_rvalue_ref) << T;\n    return true;\n  }\n\n  // Don't mention structural types in our diagnostic prior to C++20. Also,\n  // there's not much more we can say about non-scalar non-class types --\n  // because we can't see functions or arrays here, those can only be language\n  // extensions.\n  if (!getLangOpts().CPlusPlus20 ||\n      (!T->isScalarType() && !T->isRecordType())) {\n    Diag(Loc, diag::err_template_nontype_parm_bad_type) << T;\n    return true;\n  }\n\n  // Structural types are required to be literal types.\n  if (RequireLiteralType(Loc, T, diag::err_template_nontype_parm_not_literal))\n    return true;\n\n  Diag(Loc, diag::err_template_nontype_parm_not_structural) << T;\n\n  // Drill down into the reason why the class is non-structural.\n  while (const CXXRecordDecl *RD = T->getAsCXXRecordDecl()) {\n    // All members are required to be public and non-mutable, and can't be of\n    // rvalue reference type. Check these conditions first to prefer a \"local\"\n    // reason over a more distant one.\n    for (const FieldDecl *FD : RD->fields()) {\n      if (FD->getAccess() != AS_public) {\n        Diag(FD->getLocation(), diag::note_not_structural_non_public) << T << 0;\n        return true;\n      }\n      if (FD->isMutable()) {\n        Diag(FD->getLocation(), diag::note_not_structural_mutable_field) << T;\n        return true;\n      }\n      if (FD->getType()->isRValueReferenceType()) {\n        Diag(FD->getLocation(), diag::note_not_structural_rvalue_ref_field)\n            << T;\n        return true;\n      }\n    }\n\n    // All bases are required to be public.\n    for (const auto &BaseSpec : RD->bases()) {\n      if (BaseSpec.getAccessSpecifier() != AS_public) {\n        Diag(BaseSpec.getBaseTypeLoc(), diag::note_not_structural_non_public)\n            << T << 1;\n        return true;\n      }\n    }\n\n    // All subobjects are required to be of structural types.\n    SourceLocation SubLoc;\n    QualType SubType;\n    int Kind = -1;\n\n    for (const FieldDecl *FD : RD->fields()) {\n      QualType T = Context.getBaseElementType(FD->getType());\n      if (!T->isStructuralType()) {\n        SubLoc = FD->getLocation();\n        SubType = T;\n        Kind = 0;\n        break;\n      }\n    }\n\n    if (Kind == -1) {\n      for (const auto &BaseSpec : RD->bases()) {\n        QualType T = BaseSpec.getType();\n        if (!T->isStructuralType()) {\n          SubLoc = BaseSpec.getBaseTypeLoc();\n          SubType = T;\n          Kind = 1;\n          break;\n        }\n      }\n    }\n\n    assert(Kind != -1 && \"couldn't find reason why type is not structural\");\n    Diag(SubLoc, diag::note_not_structural_subobject)\n        << T << Kind << SubType;\n    T = SubType;\n    RD = T->getAsCXXRecordDecl();\n  }\n\n  return true;\n}\n\nQualType Sema::CheckNonTypeTemplateParameterType(QualType T,\n                                                 SourceLocation Loc) {\n  // We don't allow variably-modified types as the type of non-type template\n  // parameters.\n  if (T->isVariablyModifiedType()) {\n    Diag(Loc, diag::err_variably_modified_nontype_template_param)\n      << T;\n    return QualType();\n  }\n\n  // C++ [temp.param]p4:\n  //\n  // A non-type template-parameter shall have one of the following\n  // (optionally cv-qualified) types:\n  //\n  //       -- integral or enumeration type,\n  if (T->isIntegralOrEnumerationType() ||\n      //   -- pointer to object or pointer to function,\n      T->isPointerType() ||\n      //   -- lvalue reference to object or lvalue reference to function,\n      T->isLValueReferenceType() ||\n      //   -- pointer to member,\n      T->isMemberPointerType() ||\n      //   -- std::nullptr_t, or\n      T->isNullPtrType() ||\n      //   -- a type that contains a placeholder type.\n      T->isUndeducedType()) {\n    // C++ [temp.param]p5: The top-level cv-qualifiers on the template-parameter\n    // are ignored when determining its type.\n    return T.getUnqualifiedType();\n  }\n\n  // C++ [temp.param]p8:\n  //\n  //   A non-type template-parameter of type \"array of T\" or\n  //   \"function returning T\" is adjusted to be of type \"pointer to\n  //   T\" or \"pointer to function returning T\", respectively.\n  if (T->isArrayType() || T->isFunctionType())\n    return Context.getDecayedType(T);\n\n  // If T is a dependent type, we can't do the check now, so we\n  // assume that it is well-formed. Note that stripping off the\n  // qualifiers here is not really correct if T turns out to be\n  // an array type, but we'll recompute the type everywhere it's\n  // used during instantiation, so that should be OK. (Using the\n  // qualified type is equally wrong.)\n  if (T->isDependentType())\n    return T.getUnqualifiedType();\n\n  // C++20 [temp.param]p6:\n  //   -- a structural type\n  if (RequireStructuralType(T, Loc))\n    return QualType();\n\n  if (!getLangOpts().CPlusPlus20) {\n    // FIXME: Consider allowing structural types as an extension in C++17. (In\n    // earlier language modes, the template argument evaluation rules are too\n    // inflexible.)\n    Diag(Loc, diag::err_template_nontype_parm_bad_structural_type) << T;\n    return QualType();\n  }\n\n  Diag(Loc, diag::warn_cxx17_compat_template_nontype_parm_type) << T;\n  return T.getUnqualifiedType();\n}\n\nNamedDecl *Sema::ActOnNonTypeTemplateParameter(Scope *S, Declarator &D,\n                                          unsigned Depth,\n                                          unsigned Position,\n                                          SourceLocation EqualLoc,\n                                          Expr *Default) {\n  TypeSourceInfo *TInfo = GetTypeForDeclarator(D, S);\n\n  // Check that we have valid decl-specifiers specified.\n  auto CheckValidDeclSpecifiers = [this, &D] {\n    // C++ [temp.param]\n    // p1\n    //   template-parameter:\n    //     ...\n    //     parameter-declaration\n    // p2\n    //   ... A storage class shall not be specified in a template-parameter\n    //   declaration.\n    // [dcl.typedef]p1:\n    //   The typedef specifier [...] shall not be used in the decl-specifier-seq\n    //   of a parameter-declaration\n    const DeclSpec &DS = D.getDeclSpec();\n    auto EmitDiag = [this](SourceLocation Loc) {\n      Diag(Loc, diag::err_invalid_decl_specifier_in_nontype_parm)\n          << FixItHint::CreateRemoval(Loc);\n    };\n    if (DS.getStorageClassSpec() != DeclSpec::SCS_unspecified)\n      EmitDiag(DS.getStorageClassSpecLoc());\n\n    if (DS.getThreadStorageClassSpec() != TSCS_unspecified)\n      EmitDiag(DS.getThreadStorageClassSpecLoc());\n\n    // [dcl.inline]p1:\n    //   The inline specifier can be applied only to the declaration or\n    //   definition of a variable or function.\n\n    if (DS.isInlineSpecified())\n      EmitDiag(DS.getInlineSpecLoc());\n\n    // [dcl.constexpr]p1:\n    //   The constexpr specifier shall be applied only to the definition of a\n    //   variable or variable template or the declaration of a function or\n    //   function template.\n\n    if (DS.hasConstexprSpecifier())\n      EmitDiag(DS.getConstexprSpecLoc());\n\n    // [dcl.fct.spec]p1:\n    //   Function-specifiers can be used only in function declarations.\n\n    if (DS.isVirtualSpecified())\n      EmitDiag(DS.getVirtualSpecLoc());\n\n    if (DS.hasExplicitSpecifier())\n      EmitDiag(DS.getExplicitSpecLoc());\n\n    if (DS.isNoreturnSpecified())\n      EmitDiag(DS.getNoreturnSpecLoc());\n  };\n\n  CheckValidDeclSpecifiers();\n\n  if (TInfo->getType()->isUndeducedType()) {\n    Diag(D.getIdentifierLoc(),\n         diag::warn_cxx14_compat_template_nontype_parm_auto_type)\n      << QualType(TInfo->getType()->getContainedAutoType(), 0);\n  }\n\n  assert(S->isTemplateParamScope() &&\n         \"Non-type template parameter not in template parameter scope!\");\n  bool Invalid = false;\n\n  QualType T = CheckNonTypeTemplateParameterType(TInfo, D.getIdentifierLoc());\n  if (T.isNull()) {\n    T = Context.IntTy; // Recover with an 'int' type.\n    Invalid = true;\n  }\n\n  CheckFunctionOrTemplateParamDeclarator(S, D);\n\n  IdentifierInfo *ParamName = D.getIdentifier();\n  bool IsParameterPack = D.hasEllipsis();\n  NonTypeTemplateParmDecl *Param = NonTypeTemplateParmDecl::Create(\n      Context, Context.getTranslationUnitDecl(), D.getBeginLoc(),\n      D.getIdentifierLoc(), Depth, Position, ParamName, T, IsParameterPack,\n      TInfo);\n  Param->setAccess(AS_public);\n\n  if (AutoTypeLoc TL = TInfo->getTypeLoc().getContainedAutoTypeLoc())\n    if (TL.isConstrained())\n      if (AttachTypeConstraint(TL, Param, D.getEllipsisLoc()))\n        Invalid = true;\n\n  if (Invalid)\n    Param->setInvalidDecl();\n\n  if (Param->isParameterPack())\n    if (auto *LSI = getEnclosingLambda())\n      LSI->LocalPacks.push_back(Param);\n\n  if (ParamName) {\n    maybeDiagnoseTemplateParameterShadow(*this, S, D.getIdentifierLoc(),\n                                         ParamName);\n\n    // Add the template parameter into the current scope.\n    S->AddDecl(Param);\n    IdResolver.AddDecl(Param);\n  }\n\n  // C++0x [temp.param]p9:\n  //   A default template-argument may be specified for any kind of\n  //   template-parameter that is not a template parameter pack.\n  if (Default && IsParameterPack) {\n    Diag(EqualLoc, diag::err_template_param_pack_default_arg);\n    Default = nullptr;\n  }\n\n  // Check the well-formedness of the default template argument, if provided.\n  if (Default) {\n    // Check for unexpanded parameter packs.\n    if (DiagnoseUnexpandedParameterPack(Default, UPPC_DefaultArgument))\n      return Param;\n\n    TemplateArgument Converted;\n    ExprResult DefaultRes =\n        CheckTemplateArgument(Param, Param->getType(), Default, Converted);\n    if (DefaultRes.isInvalid()) {\n      Param->setInvalidDecl();\n      return Param;\n    }\n    Default = DefaultRes.get();\n\n    Param->setDefaultArgument(Default);\n  }\n\n  return Param;\n}\n\n/// ActOnTemplateTemplateParameter - Called when a C++ template template\n/// parameter (e.g. T in template <template \\<typename> class T> class array)\n/// has been parsed. S is the current scope.\nNamedDecl *Sema::ActOnTemplateTemplateParameter(Scope* S,\n                                           SourceLocation TmpLoc,\n                                           TemplateParameterList *Params,\n                                           SourceLocation EllipsisLoc,\n                                           IdentifierInfo *Name,\n                                           SourceLocation NameLoc,\n                                           unsigned Depth,\n                                           unsigned Position,\n                                           SourceLocation EqualLoc,\n                                           ParsedTemplateArgument Default) {\n  assert(S->isTemplateParamScope() &&\n         \"Template template parameter not in template parameter scope!\");\n\n  // Construct the parameter object.\n  bool IsParameterPack = EllipsisLoc.isValid();\n  TemplateTemplateParmDecl *Param =\n    TemplateTemplateParmDecl::Create(Context, Context.getTranslationUnitDecl(),\n                                     NameLoc.isInvalid()? TmpLoc : NameLoc,\n                                     Depth, Position, IsParameterPack,\n                                     Name, Params);\n  Param->setAccess(AS_public);\n\n  if (Param->isParameterPack())\n    if (auto *LSI = getEnclosingLambda())\n      LSI->LocalPacks.push_back(Param);\n\n  // If the template template parameter has a name, then link the identifier\n  // into the scope and lookup mechanisms.\n  if (Name) {\n    maybeDiagnoseTemplateParameterShadow(*this, S, NameLoc, Name);\n\n    S->AddDecl(Param);\n    IdResolver.AddDecl(Param);\n  }\n\n  if (Params->size() == 0) {\n    Diag(Param->getLocation(), diag::err_template_template_parm_no_parms)\n    << SourceRange(Params->getLAngleLoc(), Params->getRAngleLoc());\n    Param->setInvalidDecl();\n  }\n\n  // C++0x [temp.param]p9:\n  //   A default template-argument may be specified for any kind of\n  //   template-parameter that is not a template parameter pack.\n  if (IsParameterPack && !Default.isInvalid()) {\n    Diag(EqualLoc, diag::err_template_param_pack_default_arg);\n    Default = ParsedTemplateArgument();\n  }\n\n  if (!Default.isInvalid()) {\n    // Check only that we have a template template argument. We don't want to\n    // try to check well-formedness now, because our template template parameter\n    // might have dependent types in its template parameters, which we wouldn't\n    // be able to match now.\n    //\n    // If none of the template template parameter's template arguments mention\n    // other template parameters, we could actually perform more checking here.\n    // However, it isn't worth doing.\n    TemplateArgumentLoc DefaultArg = translateTemplateArgument(*this, Default);\n    if (DefaultArg.getArgument().getAsTemplate().isNull()) {\n      Diag(DefaultArg.getLocation(), diag::err_template_arg_not_valid_template)\n        << DefaultArg.getSourceRange();\n      return Param;\n    }\n\n    // Check for unexpanded parameter packs.\n    if (DiagnoseUnexpandedParameterPack(DefaultArg.getLocation(),\n                                        DefaultArg.getArgument().getAsTemplate(),\n                                        UPPC_DefaultArgument))\n      return Param;\n\n    Param->setDefaultArgument(Context, DefaultArg);\n  }\n\n  return Param;\n}\n\n/// ActOnTemplateParameterList - Builds a TemplateParameterList, optionally\n/// constrained by RequiresClause, that contains the template parameters in\n/// Params.\nTemplateParameterList *\nSema::ActOnTemplateParameterList(unsigned Depth,\n                                 SourceLocation ExportLoc,\n                                 SourceLocation TemplateLoc,\n                                 SourceLocation LAngleLoc,\n                                 ArrayRef<NamedDecl *> Params,\n                                 SourceLocation RAngleLoc,\n                                 Expr *RequiresClause) {\n  if (ExportLoc.isValid())\n    Diag(ExportLoc, diag::warn_template_export_unsupported);\n\n  return TemplateParameterList::Create(\n      Context, TemplateLoc, LAngleLoc,\n      llvm::makeArrayRef(Params.data(), Params.size()),\n      RAngleLoc, RequiresClause);\n}\n\nstatic void SetNestedNameSpecifier(Sema &S, TagDecl *T,\n                                   const CXXScopeSpec &SS) {\n  if (SS.isSet())\n    T->setQualifierInfo(SS.getWithLocInContext(S.Context));\n}\n\nDeclResult Sema::CheckClassTemplate(\n    Scope *S, unsigned TagSpec, TagUseKind TUK, SourceLocation KWLoc,\n    CXXScopeSpec &SS, IdentifierInfo *Name, SourceLocation NameLoc,\n    const ParsedAttributesView &Attr, TemplateParameterList *TemplateParams,\n    AccessSpecifier AS, SourceLocation ModulePrivateLoc,\n    SourceLocation FriendLoc, unsigned NumOuterTemplateParamLists,\n    TemplateParameterList **OuterTemplateParamLists, SkipBodyInfo *SkipBody) {\n  assert(TemplateParams && TemplateParams->size() > 0 &&\n         \"No template parameters\");\n  assert(TUK != TUK_Reference && \"Can only declare or define class templates\");\n  bool Invalid = false;\n\n  // Check that we can declare a template here.\n  if (CheckTemplateDeclScope(S, TemplateParams))\n    return true;\n\n  TagTypeKind Kind = TypeWithKeyword::getTagTypeKindForTypeSpec(TagSpec);\n  assert(Kind != TTK_Enum && \"can't build template of enumerated type\");\n\n  // There is no such thing as an unnamed class template.\n  if (!Name) {\n    Diag(KWLoc, diag::err_template_unnamed_class);\n    return true;\n  }\n\n  // Find any previous declaration with this name. For a friend with no\n  // scope explicitly specified, we only look for tag declarations (per\n  // C++11 [basic.lookup.elab]p2).\n  DeclContext *SemanticContext;\n  LookupResult Previous(*this, Name, NameLoc,\n                        (SS.isEmpty() && TUK == TUK_Friend)\n                          ? LookupTagName : LookupOrdinaryName,\n                        forRedeclarationInCurContext());\n  if (SS.isNotEmpty() && !SS.isInvalid()) {\n    SemanticContext = computeDeclContext(SS, true);\n    if (!SemanticContext) {\n      // FIXME: Horrible, horrible hack! We can't currently represent this\n      // in the AST, and historically we have just ignored such friend\n      // class templates, so don't complain here.\n      Diag(NameLoc, TUK == TUK_Friend\n                        ? diag::warn_template_qualified_friend_ignored\n                        : diag::err_template_qualified_declarator_no_match)\n          << SS.getScopeRep() << SS.getRange();\n      return TUK != TUK_Friend;\n    }\n\n    if (RequireCompleteDeclContext(SS, SemanticContext))\n      return true;\n\n    // If we're adding a template to a dependent context, we may need to\n    // rebuilding some of the types used within the template parameter list,\n    // now that we know what the current instantiation is.\n    if (SemanticContext->isDependentContext()) {\n      ContextRAII SavedContext(*this, SemanticContext);\n      if (RebuildTemplateParamsInCurrentInstantiation(TemplateParams))\n        Invalid = true;\n    } else if (TUK != TUK_Friend && TUK != TUK_Reference)\n      diagnoseQualifiedDeclaration(SS, SemanticContext, Name, NameLoc, false);\n\n    LookupQualifiedName(Previous, SemanticContext);\n  } else {\n    SemanticContext = CurContext;\n\n    // C++14 [class.mem]p14:\n    //   If T is the name of a class, then each of the following shall have a\n    //   name different from T:\n    //    -- every member template of class T\n    if (TUK != TUK_Friend &&\n        DiagnoseClassNameShadow(SemanticContext,\n                                DeclarationNameInfo(Name, NameLoc)))\n      return true;\n\n    LookupName(Previous, S);\n  }\n\n  if (Previous.isAmbiguous())\n    return true;\n\n  NamedDecl *PrevDecl = nullptr;\n  if (Previous.begin() != Previous.end())\n    PrevDecl = (*Previous.begin())->getUnderlyingDecl();\n\n  if (PrevDecl && PrevDecl->isTemplateParameter()) {\n    // Maybe we will complain about the shadowed template parameter.\n    DiagnoseTemplateParameterShadow(NameLoc, PrevDecl);\n    // Just pretend that we didn't see the previous declaration.\n    PrevDecl = nullptr;\n  }\n\n  // If there is a previous declaration with the same name, check\n  // whether this is a valid redeclaration.\n  ClassTemplateDecl *PrevClassTemplate =\n      dyn_cast_or_null<ClassTemplateDecl>(PrevDecl);\n\n  // We may have found the injected-class-name of a class template,\n  // class template partial specialization, or class template specialization.\n  // In these cases, grab the template that is being defined or specialized.\n  if (!PrevClassTemplate && PrevDecl && isa<CXXRecordDecl>(PrevDecl) &&\n      cast<CXXRecordDecl>(PrevDecl)->isInjectedClassName()) {\n    PrevDecl = cast<CXXRecordDecl>(PrevDecl->getDeclContext());\n    PrevClassTemplate\n      = cast<CXXRecordDecl>(PrevDecl)->getDescribedClassTemplate();\n    if (!PrevClassTemplate && isa<ClassTemplateSpecializationDecl>(PrevDecl)) {\n      PrevClassTemplate\n        = cast<ClassTemplateSpecializationDecl>(PrevDecl)\n            ->getSpecializedTemplate();\n    }\n  }\n\n  if (TUK == TUK_Friend) {\n    // C++ [namespace.memdef]p3:\n    //   [...] When looking for a prior declaration of a class or a function\n    //   declared as a friend, and when the name of the friend class or\n    //   function is neither a qualified name nor a template-id, scopes outside\n    //   the innermost enclosing namespace scope are not considered.\n    if (!SS.isSet()) {\n      DeclContext *OutermostContext = CurContext;\n      while (!OutermostContext->isFileContext())\n        OutermostContext = OutermostContext->getLookupParent();\n\n      if (PrevDecl &&\n          (OutermostContext->Equals(PrevDecl->getDeclContext()) ||\n           OutermostContext->Encloses(PrevDecl->getDeclContext()))) {\n        SemanticContext = PrevDecl->getDeclContext();\n      } else {\n        // Declarations in outer scopes don't matter. However, the outermost\n        // context we computed is the semantic context for our new\n        // declaration.\n        PrevDecl = PrevClassTemplate = nullptr;\n        SemanticContext = OutermostContext;\n\n        // Check that the chosen semantic context doesn't already contain a\n        // declaration of this name as a non-tag type.\n        Previous.clear(LookupOrdinaryName);\n        DeclContext *LookupContext = SemanticContext;\n        while (LookupContext->isTransparentContext())\n          LookupContext = LookupContext->getLookupParent();\n        LookupQualifiedName(Previous, LookupContext);\n\n        if (Previous.isAmbiguous())\n          return true;\n\n        if (Previous.begin() != Previous.end())\n          PrevDecl = (*Previous.begin())->getUnderlyingDecl();\n      }\n    }\n  } else if (PrevDecl &&\n             !isDeclInScope(Previous.getRepresentativeDecl(), SemanticContext,\n                            S, SS.isValid()))\n    PrevDecl = PrevClassTemplate = nullptr;\n\n  if (auto *Shadow = dyn_cast_or_null<UsingShadowDecl>(\n          PrevDecl ? Previous.getRepresentativeDecl() : nullptr)) {\n    if (SS.isEmpty() &&\n        !(PrevClassTemplate &&\n          PrevClassTemplate->getDeclContext()->getRedeclContext()->Equals(\n              SemanticContext->getRedeclContext()))) {\n      Diag(KWLoc, diag::err_using_decl_conflict_reverse);\n      Diag(Shadow->getTargetDecl()->getLocation(),\n           diag::note_using_decl_target);\n      Diag(Shadow->getUsingDecl()->getLocation(), diag::note_using_decl) << 0;\n      // Recover by ignoring the old declaration.\n      PrevDecl = PrevClassTemplate = nullptr;\n    }\n  }\n\n  if (PrevClassTemplate) {\n    // Ensure that the template parameter lists are compatible. Skip this check\n    // for a friend in a dependent context: the template parameter list itself\n    // could be dependent.\n    if (!(TUK == TUK_Friend && CurContext->isDependentContext()) &&\n        !TemplateParameterListsAreEqual(TemplateParams,\n                                   PrevClassTemplate->getTemplateParameters(),\n                                        /*Complain=*/true,\n                                        TPL_TemplateMatch))\n      return true;\n\n    // C++ [temp.class]p4:\n    //   In a redeclaration, partial specialization, explicit\n    //   specialization or explicit instantiation of a class template,\n    //   the class-key shall agree in kind with the original class\n    //   template declaration (7.1.5.3).\n    RecordDecl *PrevRecordDecl = PrevClassTemplate->getTemplatedDecl();\n    if (!isAcceptableTagRedeclaration(PrevRecordDecl, Kind,\n                                      TUK == TUK_Definition,  KWLoc, Name)) {\n      Diag(KWLoc, diag::err_use_with_wrong_tag)\n        << Name\n        << FixItHint::CreateReplacement(KWLoc, PrevRecordDecl->getKindName());\n      Diag(PrevRecordDecl->getLocation(), diag::note_previous_use);\n      Kind = PrevRecordDecl->getTagKind();\n    }\n\n    // Check for redefinition of this class template.\n    if (TUK == TUK_Definition) {\n      if (TagDecl *Def = PrevRecordDecl->getDefinition()) {\n        // If we have a prior definition that is not visible, treat this as\n        // simply making that previous definition visible.\n        NamedDecl *Hidden = nullptr;\n        if (SkipBody && !hasVisibleDefinition(Def, &Hidden)) {\n          SkipBody->ShouldSkip = true;\n          SkipBody->Previous = Def;\n          auto *Tmpl = cast<CXXRecordDecl>(Hidden)->getDescribedClassTemplate();\n          assert(Tmpl && \"original definition of a class template is not a \"\n                         \"class template?\");\n          makeMergedDefinitionVisible(Hidden);\n          makeMergedDefinitionVisible(Tmpl);\n        } else {\n          Diag(NameLoc, diag::err_redefinition) << Name;\n          Diag(Def->getLocation(), diag::note_previous_definition);\n          // FIXME: Would it make sense to try to \"forget\" the previous\n          // definition, as part of error recovery?\n          return true;\n        }\n      }\n    }\n  } else if (PrevDecl) {\n    // C++ [temp]p5:\n    //   A class template shall not have the same name as any other\n    //   template, class, function, object, enumeration, enumerator,\n    //   namespace, or type in the same scope (3.3), except as specified\n    //   in (14.5.4).\n    Diag(NameLoc, diag::err_redefinition_different_kind) << Name;\n    Diag(PrevDecl->getLocation(), diag::note_previous_definition);\n    return true;\n  }\n\n  // Check the template parameter list of this declaration, possibly\n  // merging in the template parameter list from the previous class\n  // template declaration. Skip this check for a friend in a dependent\n  // context, because the template parameter list might be dependent.\n  if (!(TUK == TUK_Friend && CurContext->isDependentContext()) &&\n      CheckTemplateParameterList(\n          TemplateParams,\n          PrevClassTemplate\n              ? PrevClassTemplate->getMostRecentDecl()->getTemplateParameters()\n              : nullptr,\n          (SS.isSet() && SemanticContext && SemanticContext->isRecord() &&\n           SemanticContext->isDependentContext())\n              ? TPC_ClassTemplateMember\n              : TUK == TUK_Friend ? TPC_FriendClassTemplate : TPC_ClassTemplate,\n          SkipBody))\n    Invalid = true;\n\n  if (SS.isSet()) {\n    // If the name of the template was qualified, we must be defining the\n    // template out-of-line.\n    if (!SS.isInvalid() && !Invalid && !PrevClassTemplate) {\n      Diag(NameLoc, TUK == TUK_Friend ? diag::err_friend_decl_does_not_match\n                                      : diag::err_member_decl_does_not_match)\n        << Name << SemanticContext << /*IsDefinition*/true << SS.getRange();\n      Invalid = true;\n    }\n  }\n\n  // If this is a templated friend in a dependent context we should not put it\n  // on the redecl chain. In some cases, the templated friend can be the most\n  // recent declaration tricking the template instantiator to make substitutions\n  // there.\n  // FIXME: Figure out how to combine with shouldLinkDependentDeclWithPrevious\n  bool ShouldAddRedecl\n    = !(TUK == TUK_Friend && CurContext->isDependentContext());\n\n  CXXRecordDecl *NewClass =\n    CXXRecordDecl::Create(Context, Kind, SemanticContext, KWLoc, NameLoc, Name,\n                          PrevClassTemplate && ShouldAddRedecl ?\n                            PrevClassTemplate->getTemplatedDecl() : nullptr,\n                          /*DelayTypeCreation=*/true);\n  SetNestedNameSpecifier(*this, NewClass, SS);\n  if (NumOuterTemplateParamLists > 0)\n    NewClass->setTemplateParameterListsInfo(\n        Context, llvm::makeArrayRef(OuterTemplateParamLists,\n                                    NumOuterTemplateParamLists));\n\n  // Add alignment attributes if necessary; these attributes are checked when\n  // the ASTContext lays out the structure.\n  if (TUK == TUK_Definition && (!SkipBody || !SkipBody->ShouldSkip)) {\n    AddAlignmentAttributesForRecord(NewClass);\n    AddMsStructLayoutForRecord(NewClass);\n  }\n\n  ClassTemplateDecl *NewTemplate\n    = ClassTemplateDecl::Create(Context, SemanticContext, NameLoc,\n                                DeclarationName(Name), TemplateParams,\n                                NewClass);\n\n  if (ShouldAddRedecl)\n    NewTemplate->setPreviousDecl(PrevClassTemplate);\n\n  NewClass->setDescribedClassTemplate(NewTemplate);\n\n  if (ModulePrivateLoc.isValid())\n    NewTemplate->setModulePrivate();\n\n  // Build the type for the class template declaration now.\n  QualType T = NewTemplate->getInjectedClassNameSpecialization();\n  T = Context.getInjectedClassNameType(NewClass, T);\n  assert(T->isDependentType() && \"Class template type is not dependent?\");\n  (void)T;\n\n  // If we are providing an explicit specialization of a member that is a\n  // class template, make a note of that.\n  if (PrevClassTemplate &&\n      PrevClassTemplate->getInstantiatedFromMemberTemplate())\n    PrevClassTemplate->setMemberSpecialization();\n\n  // Set the access specifier.\n  if (!Invalid && TUK != TUK_Friend && NewTemplate->getDeclContext()->isRecord())\n    SetMemberAccessSpecifier(NewTemplate, PrevClassTemplate, AS);\n\n  // Set the lexical context of these templates\n  NewClass->setLexicalDeclContext(CurContext);\n  NewTemplate->setLexicalDeclContext(CurContext);\n\n  if (TUK == TUK_Definition && (!SkipBody || !SkipBody->ShouldSkip))\n    NewClass->startDefinition();\n\n  ProcessDeclAttributeList(S, NewClass, Attr);\n\n  if (PrevClassTemplate)\n    mergeDeclAttributes(NewClass, PrevClassTemplate->getTemplatedDecl());\n\n  AddPushedVisibilityAttribute(NewClass);\n  inferGslOwnerPointerAttribute(NewClass);\n\n  if (TUK != TUK_Friend) {\n    // Per C++ [basic.scope.temp]p2, skip the template parameter scopes.\n    Scope *Outer = S;\n    while ((Outer->getFlags() & Scope::TemplateParamScope) != 0)\n      Outer = Outer->getParent();\n    PushOnScopeChains(NewTemplate, Outer);\n  } else {\n    if (PrevClassTemplate && PrevClassTemplate->getAccess() != AS_none) {\n      NewTemplate->setAccess(PrevClassTemplate->getAccess());\n      NewClass->setAccess(PrevClassTemplate->getAccess());\n    }\n\n    NewTemplate->setObjectOfFriendDecl();\n\n    // Friend templates are visible in fairly strange ways.\n    if (!CurContext->isDependentContext()) {\n      DeclContext *DC = SemanticContext->getRedeclContext();\n      DC->makeDeclVisibleInContext(NewTemplate);\n      if (Scope *EnclosingScope = getScopeForDeclContext(S, DC))\n        PushOnScopeChains(NewTemplate, EnclosingScope,\n                          /* AddToContext = */ false);\n    }\n\n    FriendDecl *Friend = FriendDecl::Create(\n        Context, CurContext, NewClass->getLocation(), NewTemplate, FriendLoc);\n    Friend->setAccess(AS_public);\n    CurContext->addDecl(Friend);\n  }\n\n  if (PrevClassTemplate)\n    CheckRedeclarationModuleOwnership(NewTemplate, PrevClassTemplate);\n\n  if (Invalid) {\n    NewTemplate->setInvalidDecl();\n    NewClass->setInvalidDecl();\n  }\n\n  ActOnDocumentableDecl(NewTemplate);\n\n  if (SkipBody && SkipBody->ShouldSkip)\n    return SkipBody->Previous;\n\n  return NewTemplate;\n}\n\nnamespace {\n/// Tree transform to \"extract\" a transformed type from a class template's\n/// constructor to a deduction guide.\nclass ExtractTypeForDeductionGuide\n  : public TreeTransform<ExtractTypeForDeductionGuide> {\n  llvm::SmallVectorImpl<TypedefNameDecl *> &MaterializedTypedefs;\n\npublic:\n  typedef TreeTransform<ExtractTypeForDeductionGuide> Base;\n  ExtractTypeForDeductionGuide(\n      Sema &SemaRef,\n      llvm::SmallVectorImpl<TypedefNameDecl *> &MaterializedTypedefs)\n      : Base(SemaRef), MaterializedTypedefs(MaterializedTypedefs) {}\n\n  TypeSourceInfo *transform(TypeSourceInfo *TSI) { return TransformType(TSI); }\n\n  QualType TransformTypedefType(TypeLocBuilder &TLB, TypedefTypeLoc TL) {\n    ASTContext &Context = SemaRef.getASTContext();\n    TypedefNameDecl *OrigDecl = TL.getTypedefNameDecl();\n    TypedefNameDecl *Decl = OrigDecl;\n    // Transform the underlying type of the typedef and clone the Decl only if\n    // the typedef has a dependent context.\n    if (OrigDecl->getDeclContext()->isDependentContext()) {\n      TypeLocBuilder InnerTLB;\n      QualType Transformed =\n          TransformType(InnerTLB, OrigDecl->getTypeSourceInfo()->getTypeLoc());\n      TypeSourceInfo *TSI = InnerTLB.getTypeSourceInfo(Context, Transformed);\n      if (isa<TypeAliasDecl>(OrigDecl))\n        Decl = TypeAliasDecl::Create(\n            Context, Context.getTranslationUnitDecl(), OrigDecl->getBeginLoc(),\n            OrigDecl->getLocation(), OrigDecl->getIdentifier(), TSI);\n      else {\n        assert(isa<TypedefDecl>(OrigDecl) && \"Not a Type alias or typedef\");\n        Decl = TypedefDecl::Create(\n            Context, Context.getTranslationUnitDecl(), OrigDecl->getBeginLoc(),\n            OrigDecl->getLocation(), OrigDecl->getIdentifier(), TSI);\n      }\n      MaterializedTypedefs.push_back(Decl);\n    }\n\n    QualType TDTy = Context.getTypedefType(Decl);\n    TypedefTypeLoc TypedefTL = TLB.push<TypedefTypeLoc>(TDTy);\n    TypedefTL.setNameLoc(TL.getNameLoc());\n\n    return TDTy;\n  }\n};\n\n/// Transform to convert portions of a constructor declaration into the\n/// corresponding deduction guide, per C++1z [over.match.class.deduct]p1.\nstruct ConvertConstructorToDeductionGuideTransform {\n  ConvertConstructorToDeductionGuideTransform(Sema &S,\n                                              ClassTemplateDecl *Template)\n      : SemaRef(S), Template(Template) {}\n\n  Sema &SemaRef;\n  ClassTemplateDecl *Template;\n\n  DeclContext *DC = Template->getDeclContext();\n  CXXRecordDecl *Primary = Template->getTemplatedDecl();\n  DeclarationName DeductionGuideName =\n      SemaRef.Context.DeclarationNames.getCXXDeductionGuideName(Template);\n\n  QualType DeducedType = SemaRef.Context.getTypeDeclType(Primary);\n\n  // Index adjustment to apply to convert depth-1 template parameters into\n  // depth-0 template parameters.\n  unsigned Depth1IndexAdjustment = Template->getTemplateParameters()->size();\n\n  /// Transform a constructor declaration into a deduction guide.\n  NamedDecl *transformConstructor(FunctionTemplateDecl *FTD,\n                                  CXXConstructorDecl *CD) {\n    SmallVector<TemplateArgument, 16> SubstArgs;\n\n    LocalInstantiationScope Scope(SemaRef);\n\n    // C++ [over.match.class.deduct]p1:\n    // -- For each constructor of the class template designated by the\n    //    template-name, a function template with the following properties:\n\n    //    -- The template parameters are the template parameters of the class\n    //       template followed by the template parameters (including default\n    //       template arguments) of the constructor, if any.\n    TemplateParameterList *TemplateParams = Template->getTemplateParameters();\n    if (FTD) {\n      TemplateParameterList *InnerParams = FTD->getTemplateParameters();\n      SmallVector<NamedDecl *, 16> AllParams;\n      AllParams.reserve(TemplateParams->size() + InnerParams->size());\n      AllParams.insert(AllParams.begin(),\n                       TemplateParams->begin(), TemplateParams->end());\n      SubstArgs.reserve(InnerParams->size());\n\n      // Later template parameters could refer to earlier ones, so build up\n      // a list of substituted template arguments as we go.\n      for (NamedDecl *Param : *InnerParams) {\n        MultiLevelTemplateArgumentList Args;\n        Args.setKind(TemplateSubstitutionKind::Rewrite);\n        Args.addOuterTemplateArguments(SubstArgs);\n        Args.addOuterRetainedLevel();\n        NamedDecl *NewParam = transformTemplateParameter(Param, Args);\n        if (!NewParam)\n          return nullptr;\n        AllParams.push_back(NewParam);\n        SubstArgs.push_back(SemaRef.Context.getCanonicalTemplateArgument(\n            SemaRef.Context.getInjectedTemplateArg(NewParam)));\n      }\n      TemplateParams = TemplateParameterList::Create(\n          SemaRef.Context, InnerParams->getTemplateLoc(),\n          InnerParams->getLAngleLoc(), AllParams, InnerParams->getRAngleLoc(),\n          /*FIXME: RequiresClause*/ nullptr);\n    }\n\n    // If we built a new template-parameter-list, track that we need to\n    // substitute references to the old parameters into references to the\n    // new ones.\n    MultiLevelTemplateArgumentList Args;\n    Args.setKind(TemplateSubstitutionKind::Rewrite);\n    if (FTD) {\n      Args.addOuterTemplateArguments(SubstArgs);\n      Args.addOuterRetainedLevel();\n    }\n\n    FunctionProtoTypeLoc FPTL = CD->getTypeSourceInfo()->getTypeLoc()\n                                   .getAsAdjusted<FunctionProtoTypeLoc>();\n    assert(FPTL && \"no prototype for constructor declaration\");\n\n    // Transform the type of the function, adjusting the return type and\n    // replacing references to the old parameters with references to the\n    // new ones.\n    TypeLocBuilder TLB;\n    SmallVector<ParmVarDecl*, 8> Params;\n    SmallVector<TypedefNameDecl *, 4> MaterializedTypedefs;\n    QualType NewType = transformFunctionProtoType(TLB, FPTL, Params, Args,\n                                                  MaterializedTypedefs);\n    if (NewType.isNull())\n      return nullptr;\n    TypeSourceInfo *NewTInfo = TLB.getTypeSourceInfo(SemaRef.Context, NewType);\n\n    return buildDeductionGuide(TemplateParams, CD->getExplicitSpecifier(),\n                               NewTInfo, CD->getBeginLoc(), CD->getLocation(),\n                               CD->getEndLoc(), MaterializedTypedefs);\n  }\n\n  /// Build a deduction guide with the specified parameter types.\n  NamedDecl *buildSimpleDeductionGuide(MutableArrayRef<QualType> ParamTypes) {\n    SourceLocation Loc = Template->getLocation();\n\n    // Build the requested type.\n    FunctionProtoType::ExtProtoInfo EPI;\n    EPI.HasTrailingReturn = true;\n    QualType Result = SemaRef.BuildFunctionType(DeducedType, ParamTypes, Loc,\n                                                DeductionGuideName, EPI);\n    TypeSourceInfo *TSI = SemaRef.Context.getTrivialTypeSourceInfo(Result, Loc);\n\n    FunctionProtoTypeLoc FPTL =\n        TSI->getTypeLoc().castAs<FunctionProtoTypeLoc>();\n\n    // Build the parameters, needed during deduction / substitution.\n    SmallVector<ParmVarDecl*, 4> Params;\n    for (auto T : ParamTypes) {\n      ParmVarDecl *NewParam = ParmVarDecl::Create(\n          SemaRef.Context, DC, Loc, Loc, nullptr, T,\n          SemaRef.Context.getTrivialTypeSourceInfo(T, Loc), SC_None, nullptr);\n      NewParam->setScopeInfo(0, Params.size());\n      FPTL.setParam(Params.size(), NewParam);\n      Params.push_back(NewParam);\n    }\n\n    return buildDeductionGuide(Template->getTemplateParameters(),\n                               ExplicitSpecifier(), TSI, Loc, Loc, Loc);\n  }\n\nprivate:\n  /// Transform a constructor template parameter into a deduction guide template\n  /// parameter, rebuilding any internal references to earlier parameters and\n  /// renumbering as we go.\n  NamedDecl *transformTemplateParameter(NamedDecl *TemplateParam,\n                                        MultiLevelTemplateArgumentList &Args) {\n    if (auto *TTP = dyn_cast<TemplateTypeParmDecl>(TemplateParam)) {\n      // TemplateTypeParmDecl's index cannot be changed after creation, so\n      // substitute it directly.\n      auto *NewTTP = TemplateTypeParmDecl::Create(\n          SemaRef.Context, DC, TTP->getBeginLoc(), TTP->getLocation(),\n          /*Depth*/ 0, Depth1IndexAdjustment + TTP->getIndex(),\n          TTP->getIdentifier(), TTP->wasDeclaredWithTypename(),\n          TTP->isParameterPack(), TTP->hasTypeConstraint(),\n          TTP->isExpandedParameterPack() ?\n          llvm::Optional<unsigned>(TTP->getNumExpansionParameters()) : None);\n      if (const auto *TC = TTP->getTypeConstraint()) {\n        TemplateArgumentListInfo TransformedArgs;\n        const auto *ArgsAsWritten = TC->getTemplateArgsAsWritten();\n        if (!ArgsAsWritten ||\n            SemaRef.Subst(ArgsAsWritten->getTemplateArgs(),\n                          ArgsAsWritten->NumTemplateArgs, TransformedArgs,\n                          Args))\n          SemaRef.AttachTypeConstraint(\n              TC->getNestedNameSpecifierLoc(), TC->getConceptNameInfo(),\n              TC->getNamedConcept(), ArgsAsWritten ? &TransformedArgs : nullptr,\n              NewTTP,\n              NewTTP->isParameterPack()\n                 ? cast<CXXFoldExpr>(TC->getImmediatelyDeclaredConstraint())\n                     ->getEllipsisLoc()\n                 : SourceLocation());\n      }\n      if (TTP->hasDefaultArgument()) {\n        TypeSourceInfo *InstantiatedDefaultArg =\n            SemaRef.SubstType(TTP->getDefaultArgumentInfo(), Args,\n                              TTP->getDefaultArgumentLoc(), TTP->getDeclName());\n        if (InstantiatedDefaultArg)\n          NewTTP->setDefaultArgument(InstantiatedDefaultArg);\n      }\n      SemaRef.CurrentInstantiationScope->InstantiatedLocal(TemplateParam,\n                                                           NewTTP);\n      return NewTTP;\n    }\n\n    if (auto *TTP = dyn_cast<TemplateTemplateParmDecl>(TemplateParam))\n      return transformTemplateParameterImpl(TTP, Args);\n\n    return transformTemplateParameterImpl(\n        cast<NonTypeTemplateParmDecl>(TemplateParam), Args);\n  }\n  template<typename TemplateParmDecl>\n  TemplateParmDecl *\n  transformTemplateParameterImpl(TemplateParmDecl *OldParam,\n                                 MultiLevelTemplateArgumentList &Args) {\n    // Ask the template instantiator to do the heavy lifting for us, then adjust\n    // the index of the parameter once it's done.\n    auto *NewParam =\n        cast<TemplateParmDecl>(SemaRef.SubstDecl(OldParam, DC, Args));\n    assert(NewParam->getDepth() == 0 && \"unexpected template param depth\");\n    NewParam->setPosition(NewParam->getPosition() + Depth1IndexAdjustment);\n    return NewParam;\n  }\n\n  QualType transformFunctionProtoType(\n      TypeLocBuilder &TLB, FunctionProtoTypeLoc TL,\n      SmallVectorImpl<ParmVarDecl *> &Params,\n      MultiLevelTemplateArgumentList &Args,\n      SmallVectorImpl<TypedefNameDecl *> &MaterializedTypedefs) {\n    SmallVector<QualType, 4> ParamTypes;\n    const FunctionProtoType *T = TL.getTypePtr();\n\n    //    -- The types of the function parameters are those of the constructor.\n    for (auto *OldParam : TL.getParams()) {\n      ParmVarDecl *NewParam =\n          transformFunctionTypeParam(OldParam, Args, MaterializedTypedefs);\n      if (!NewParam)\n        return QualType();\n      ParamTypes.push_back(NewParam->getType());\n      Params.push_back(NewParam);\n    }\n\n    //    -- The return type is the class template specialization designated by\n    //       the template-name and template arguments corresponding to the\n    //       template parameters obtained from the class template.\n    //\n    // We use the injected-class-name type of the primary template instead.\n    // This has the convenient property that it is different from any type that\n    // the user can write in a deduction-guide (because they cannot enter the\n    // context of the template), so implicit deduction guides can never collide\n    // with explicit ones.\n    QualType ReturnType = DeducedType;\n    TLB.pushTypeSpec(ReturnType).setNameLoc(Primary->getLocation());\n\n    // Resolving a wording defect, we also inherit the variadicness of the\n    // constructor.\n    FunctionProtoType::ExtProtoInfo EPI;\n    EPI.Variadic = T->isVariadic();\n    EPI.HasTrailingReturn = true;\n\n    QualType Result = SemaRef.BuildFunctionType(\n        ReturnType, ParamTypes, TL.getBeginLoc(), DeductionGuideName, EPI);\n    if (Result.isNull())\n      return QualType();\n\n    FunctionProtoTypeLoc NewTL = TLB.push<FunctionProtoTypeLoc>(Result);\n    NewTL.setLocalRangeBegin(TL.getLocalRangeBegin());\n    NewTL.setLParenLoc(TL.getLParenLoc());\n    NewTL.setRParenLoc(TL.getRParenLoc());\n    NewTL.setExceptionSpecRange(SourceRange());\n    NewTL.setLocalRangeEnd(TL.getLocalRangeEnd());\n    for (unsigned I = 0, E = NewTL.getNumParams(); I != E; ++I)\n      NewTL.setParam(I, Params[I]);\n\n    return Result;\n  }\n\n  ParmVarDecl *transformFunctionTypeParam(\n      ParmVarDecl *OldParam, MultiLevelTemplateArgumentList &Args,\n      llvm::SmallVectorImpl<TypedefNameDecl *> &MaterializedTypedefs) {\n    TypeSourceInfo *OldDI = OldParam->getTypeSourceInfo();\n    TypeSourceInfo *NewDI;\n    if (auto PackTL = OldDI->getTypeLoc().getAs<PackExpansionTypeLoc>()) {\n      // Expand out the one and only element in each inner pack.\n      Sema::ArgumentPackSubstitutionIndexRAII SubstIndex(SemaRef, 0);\n      NewDI =\n          SemaRef.SubstType(PackTL.getPatternLoc(), Args,\n                            OldParam->getLocation(), OldParam->getDeclName());\n      if (!NewDI) return nullptr;\n      NewDI =\n          SemaRef.CheckPackExpansion(NewDI, PackTL.getEllipsisLoc(),\n                                     PackTL.getTypePtr()->getNumExpansions());\n    } else\n      NewDI = SemaRef.SubstType(OldDI, Args, OldParam->getLocation(),\n                                OldParam->getDeclName());\n    if (!NewDI)\n      return nullptr;\n\n    // Extract the type. This (for instance) replaces references to typedef\n    // members of the current instantiations with the definitions of those\n    // typedefs, avoiding triggering instantiation of the deduced type during\n    // deduction.\n    NewDI = ExtractTypeForDeductionGuide(SemaRef, MaterializedTypedefs)\n                .transform(NewDI);\n\n    // Resolving a wording defect, we also inherit default arguments from the\n    // constructor.\n    ExprResult NewDefArg;\n    if (OldParam->hasDefaultArg()) {\n      // We don't care what the value is (we won't use it); just create a\n      // placeholder to indicate there is a default argument.\n      QualType ParamTy = NewDI->getType();\n      NewDefArg = new (SemaRef.Context)\n          OpaqueValueExpr(OldParam->getDefaultArg()->getBeginLoc(),\n                          ParamTy.getNonLValueExprType(SemaRef.Context),\n                          ParamTy->isLValueReferenceType() ? VK_LValue :\n                          ParamTy->isRValueReferenceType() ? VK_XValue :\n                          VK_RValue);\n    }\n\n    ParmVarDecl *NewParam = ParmVarDecl::Create(SemaRef.Context, DC,\n                                                OldParam->getInnerLocStart(),\n                                                OldParam->getLocation(),\n                                                OldParam->getIdentifier(),\n                                                NewDI->getType(),\n                                                NewDI,\n                                                OldParam->getStorageClass(),\n                                                NewDefArg.get());\n    NewParam->setScopeInfo(OldParam->getFunctionScopeDepth(),\n                           OldParam->getFunctionScopeIndex());\n    SemaRef.CurrentInstantiationScope->InstantiatedLocal(OldParam, NewParam);\n    return NewParam;\n  }\n\n  FunctionTemplateDecl *buildDeductionGuide(\n      TemplateParameterList *TemplateParams, ExplicitSpecifier ES,\n      TypeSourceInfo *TInfo, SourceLocation LocStart, SourceLocation Loc,\n      SourceLocation LocEnd,\n      llvm::ArrayRef<TypedefNameDecl *> MaterializedTypedefs = {}) {\n    DeclarationNameInfo Name(DeductionGuideName, Loc);\n    ArrayRef<ParmVarDecl *> Params =\n        TInfo->getTypeLoc().castAs<FunctionProtoTypeLoc>().getParams();\n\n    // Build the implicit deduction guide template.\n    auto *Guide =\n        CXXDeductionGuideDecl::Create(SemaRef.Context, DC, LocStart, ES, Name,\n                                      TInfo->getType(), TInfo, LocEnd);\n    Guide->setImplicit();\n    Guide->setParams(Params);\n\n    for (auto *Param : Params)\n      Param->setDeclContext(Guide);\n    for (auto *TD : MaterializedTypedefs)\n      TD->setDeclContext(Guide);\n\n    auto *GuideTemplate = FunctionTemplateDecl::Create(\n        SemaRef.Context, DC, Loc, DeductionGuideName, TemplateParams, Guide);\n    GuideTemplate->setImplicit();\n    Guide->setDescribedFunctionTemplate(GuideTemplate);\n\n    if (isa<CXXRecordDecl>(DC)) {\n      Guide->setAccess(AS_public);\n      GuideTemplate->setAccess(AS_public);\n    }\n\n    DC->addDecl(GuideTemplate);\n    return GuideTemplate;\n  }\n};\n}\n\nvoid Sema::DeclareImplicitDeductionGuides(TemplateDecl *Template,\n                                          SourceLocation Loc) {\n  if (CXXRecordDecl *DefRecord =\n          cast<CXXRecordDecl>(Template->getTemplatedDecl())->getDefinition()) {\n    TemplateDecl *DescribedTemplate = DefRecord->getDescribedClassTemplate();\n    Template = DescribedTemplate ? DescribedTemplate : Template;\n  }\n\n  DeclContext *DC = Template->getDeclContext();\n  if (DC->isDependentContext())\n    return;\n\n  ConvertConstructorToDeductionGuideTransform Transform(\n      *this, cast<ClassTemplateDecl>(Template));\n  if (!isCompleteType(Loc, Transform.DeducedType))\n    return;\n\n  // Check whether we've already declared deduction guides for this template.\n  // FIXME: Consider storing a flag on the template to indicate this.\n  auto Existing = DC->lookup(Transform.DeductionGuideName);\n  for (auto *D : Existing)\n    if (D->isImplicit())\n      return;\n\n  // In case we were expanding a pack when we attempted to declare deduction\n  // guides, turn off pack expansion for everything we're about to do.\n  ArgumentPackSubstitutionIndexRAII SubstIndex(*this, -1);\n  // Create a template instantiation record to track the \"instantiation\" of\n  // constructors into deduction guides.\n  // FIXME: Add a kind for this to give more meaningful diagnostics. But can\n  // this substitution process actually fail?\n  InstantiatingTemplate BuildingDeductionGuides(*this, Loc, Template);\n  if (BuildingDeductionGuides.isInvalid())\n    return;\n\n  // Convert declared constructors into deduction guide templates.\n  // FIXME: Skip constructors for which deduction must necessarily fail (those\n  // for which some class template parameter without a default argument never\n  // appears in a deduced context).\n  bool AddedAny = false;\n  for (NamedDecl *D : LookupConstructors(Transform.Primary)) {\n    D = D->getUnderlyingDecl();\n    if (D->isInvalidDecl() || D->isImplicit())\n      continue;\n    D = cast<NamedDecl>(D->getCanonicalDecl());\n\n    auto *FTD = dyn_cast<FunctionTemplateDecl>(D);\n    auto *CD =\n        dyn_cast_or_null<CXXConstructorDecl>(FTD ? FTD->getTemplatedDecl() : D);\n    // Class-scope explicit specializations (MS extension) do not result in\n    // deduction guides.\n    if (!CD || (!FTD && CD->isFunctionTemplateSpecialization()))\n      continue;\n\n    // Cannot make a deduction guide when unparsed arguments are present.\n    if (std::any_of(CD->param_begin(), CD->param_end(), [](ParmVarDecl *P) {\n          return !P || P->hasUnparsedDefaultArg();\n        }))\n      continue;\n\n    Transform.transformConstructor(FTD, CD);\n    AddedAny = true;\n  }\n\n  // C++17 [over.match.class.deduct]\n  //    --  If C is not defined or does not declare any constructors, an\n  //    additional function template derived as above from a hypothetical\n  //    constructor C().\n  if (!AddedAny)\n    Transform.buildSimpleDeductionGuide(None);\n\n  //    -- An additional function template derived as above from a hypothetical\n  //    constructor C(C), called the copy deduction candidate.\n  cast<CXXDeductionGuideDecl>(\n      cast<FunctionTemplateDecl>(\n          Transform.buildSimpleDeductionGuide(Transform.DeducedType))\n          ->getTemplatedDecl())\n      ->setIsCopyDeductionCandidate();\n}\n\n/// Diagnose the presence of a default template argument on a\n/// template parameter, which is ill-formed in certain contexts.\n///\n/// \\returns true if the default template argument should be dropped.\nstatic bool DiagnoseDefaultTemplateArgument(Sema &S,\n                                            Sema::TemplateParamListContext TPC,\n                                            SourceLocation ParamLoc,\n                                            SourceRange DefArgRange) {\n  switch (TPC) {\n  case Sema::TPC_ClassTemplate:\n  case Sema::TPC_VarTemplate:\n  case Sema::TPC_TypeAliasTemplate:\n    return false;\n\n  case Sema::TPC_FunctionTemplate:\n  case Sema::TPC_FriendFunctionTemplateDefinition:\n    // C++ [temp.param]p9:\n    //   A default template-argument shall not be specified in a\n    //   function template declaration or a function template\n    //   definition [...]\n    //   If a friend function template declaration specifies a default\n    //   template-argument, that declaration shall be a definition and shall be\n    //   the only declaration of the function template in the translation unit.\n    // (C++98/03 doesn't have this wording; see DR226).\n    S.Diag(ParamLoc, S.getLangOpts().CPlusPlus11 ?\n         diag::warn_cxx98_compat_template_parameter_default_in_function_template\n           : diag::ext_template_parameter_default_in_function_template)\n      << DefArgRange;\n    return false;\n\n  case Sema::TPC_ClassTemplateMember:\n    // C++0x [temp.param]p9:\n    //   A default template-argument shall not be specified in the\n    //   template-parameter-lists of the definition of a member of a\n    //   class template that appears outside of the member's class.\n    S.Diag(ParamLoc, diag::err_template_parameter_default_template_member)\n      << DefArgRange;\n    return true;\n\n  case Sema::TPC_FriendClassTemplate:\n  case Sema::TPC_FriendFunctionTemplate:\n    // C++ [temp.param]p9:\n    //   A default template-argument shall not be specified in a\n    //   friend template declaration.\n    S.Diag(ParamLoc, diag::err_template_parameter_default_friend_template)\n      << DefArgRange;\n    return true;\n\n    // FIXME: C++0x [temp.param]p9 allows default template-arguments\n    // for friend function templates if there is only a single\n    // declaration (and it is a definition). Strange!\n  }\n\n  llvm_unreachable(\"Invalid TemplateParamListContext!\");\n}\n\n/// Check for unexpanded parameter packs within the template parameters\n/// of a template template parameter, recursively.\nstatic bool DiagnoseUnexpandedParameterPacks(Sema &S,\n                                             TemplateTemplateParmDecl *TTP) {\n  // A template template parameter which is a parameter pack is also a pack\n  // expansion.\n  if (TTP->isParameterPack())\n    return false;\n\n  TemplateParameterList *Params = TTP->getTemplateParameters();\n  for (unsigned I = 0, N = Params->size(); I != N; ++I) {\n    NamedDecl *P = Params->getParam(I);\n    if (TemplateTypeParmDecl *TTP = dyn_cast<TemplateTypeParmDecl>(P)) {\n      if (!TTP->isParameterPack())\n        if (const TypeConstraint *TC = TTP->getTypeConstraint())\n          if (TC->hasExplicitTemplateArgs())\n            for (auto &ArgLoc : TC->getTemplateArgsAsWritten()->arguments())\n              if (S.DiagnoseUnexpandedParameterPack(ArgLoc,\n                                                    Sema::UPPC_TypeConstraint))\n                return true;\n      continue;\n    }\n\n    if (NonTypeTemplateParmDecl *NTTP = dyn_cast<NonTypeTemplateParmDecl>(P)) {\n      if (!NTTP->isParameterPack() &&\n          S.DiagnoseUnexpandedParameterPack(NTTP->getLocation(),\n                                            NTTP->getTypeSourceInfo(),\n                                      Sema::UPPC_NonTypeTemplateParameterType))\n        return true;\n\n      continue;\n    }\n\n    if (TemplateTemplateParmDecl *InnerTTP\n                                        = dyn_cast<TemplateTemplateParmDecl>(P))\n      if (DiagnoseUnexpandedParameterPacks(S, InnerTTP))\n        return true;\n  }\n\n  return false;\n}\n\n/// Checks the validity of a template parameter list, possibly\n/// considering the template parameter list from a previous\n/// declaration.\n///\n/// If an \"old\" template parameter list is provided, it must be\n/// equivalent (per TemplateParameterListsAreEqual) to the \"new\"\n/// template parameter list.\n///\n/// \\param NewParams Template parameter list for a new template\n/// declaration. This template parameter list will be updated with any\n/// default arguments that are carried through from the previous\n/// template parameter list.\n///\n/// \\param OldParams If provided, template parameter list from a\n/// previous declaration of the same template. Default template\n/// arguments will be merged from the old template parameter list to\n/// the new template parameter list.\n///\n/// \\param TPC Describes the context in which we are checking the given\n/// template parameter list.\n///\n/// \\param SkipBody If we might have already made a prior merged definition\n/// of this template visible, the corresponding body-skipping information.\n/// Default argument redefinition is not an error when skipping such a body,\n/// because (under the ODR) we can assume the default arguments are the same\n/// as the prior merged definition.\n///\n/// \\returns true if an error occurred, false otherwise.\nbool Sema::CheckTemplateParameterList(TemplateParameterList *NewParams,\n                                      TemplateParameterList *OldParams,\n                                      TemplateParamListContext TPC,\n                                      SkipBodyInfo *SkipBody) {\n  bool Invalid = false;\n\n  // C++ [temp.param]p10:\n  //   The set of default template-arguments available for use with a\n  //   template declaration or definition is obtained by merging the\n  //   default arguments from the definition (if in scope) and all\n  //   declarations in scope in the same way default function\n  //   arguments are (8.3.6).\n  bool SawDefaultArgument = false;\n  SourceLocation PreviousDefaultArgLoc;\n\n  // Dummy initialization to avoid warnings.\n  TemplateParameterList::iterator OldParam = NewParams->end();\n  if (OldParams)\n    OldParam = OldParams->begin();\n\n  bool RemoveDefaultArguments = false;\n  for (TemplateParameterList::iterator NewParam = NewParams->begin(),\n                                    NewParamEnd = NewParams->end();\n       NewParam != NewParamEnd; ++NewParam) {\n    // Variables used to diagnose redundant default arguments\n    bool RedundantDefaultArg = false;\n    SourceLocation OldDefaultLoc;\n    SourceLocation NewDefaultLoc;\n\n    // Variable used to diagnose missing default arguments\n    bool MissingDefaultArg = false;\n\n    // Variable used to diagnose non-final parameter packs\n    bool SawParameterPack = false;\n\n    if (TemplateTypeParmDecl *NewTypeParm\n          = dyn_cast<TemplateTypeParmDecl>(*NewParam)) {\n      // Check the presence of a default argument here.\n      if (NewTypeParm->hasDefaultArgument() &&\n          DiagnoseDefaultTemplateArgument(*this, TPC,\n                                          NewTypeParm->getLocation(),\n               NewTypeParm->getDefaultArgumentInfo()->getTypeLoc()\n                                                       .getSourceRange()))\n        NewTypeParm->removeDefaultArgument();\n\n      // Merge default arguments for template type parameters.\n      TemplateTypeParmDecl *OldTypeParm\n          = OldParams? cast<TemplateTypeParmDecl>(*OldParam) : nullptr;\n      if (NewTypeParm->isParameterPack()) {\n        assert(!NewTypeParm->hasDefaultArgument() &&\n               \"Parameter packs can't have a default argument!\");\n        SawParameterPack = true;\n      } else if (OldTypeParm && hasVisibleDefaultArgument(OldTypeParm) &&\n                 NewTypeParm->hasDefaultArgument() &&\n                 (!SkipBody || !SkipBody->ShouldSkip)) {\n        OldDefaultLoc = OldTypeParm->getDefaultArgumentLoc();\n        NewDefaultLoc = NewTypeParm->getDefaultArgumentLoc();\n        SawDefaultArgument = true;\n        RedundantDefaultArg = true;\n        PreviousDefaultArgLoc = NewDefaultLoc;\n      } else if (OldTypeParm && OldTypeParm->hasDefaultArgument()) {\n        // Merge the default argument from the old declaration to the\n        // new declaration.\n        NewTypeParm->setInheritedDefaultArgument(Context, OldTypeParm);\n        PreviousDefaultArgLoc = OldTypeParm->getDefaultArgumentLoc();\n      } else if (NewTypeParm->hasDefaultArgument()) {\n        SawDefaultArgument = true;\n        PreviousDefaultArgLoc = NewTypeParm->getDefaultArgumentLoc();\n      } else if (SawDefaultArgument)\n        MissingDefaultArg = true;\n    } else if (NonTypeTemplateParmDecl *NewNonTypeParm\n               = dyn_cast<NonTypeTemplateParmDecl>(*NewParam)) {\n      // Check for unexpanded parameter packs.\n      if (!NewNonTypeParm->isParameterPack() &&\n          DiagnoseUnexpandedParameterPack(NewNonTypeParm->getLocation(),\n                                          NewNonTypeParm->getTypeSourceInfo(),\n                                          UPPC_NonTypeTemplateParameterType)) {\n        Invalid = true;\n        continue;\n      }\n\n      // Check the presence of a default argument here.\n      if (NewNonTypeParm->hasDefaultArgument() &&\n          DiagnoseDefaultTemplateArgument(*this, TPC,\n                                          NewNonTypeParm->getLocation(),\n                    NewNonTypeParm->getDefaultArgument()->getSourceRange())) {\n        NewNonTypeParm->removeDefaultArgument();\n      }\n\n      // Merge default arguments for non-type template parameters\n      NonTypeTemplateParmDecl *OldNonTypeParm\n        = OldParams? cast<NonTypeTemplateParmDecl>(*OldParam) : nullptr;\n      if (NewNonTypeParm->isParameterPack()) {\n        assert(!NewNonTypeParm->hasDefaultArgument() &&\n               \"Parameter packs can't have a default argument!\");\n        if (!NewNonTypeParm->isPackExpansion())\n          SawParameterPack = true;\n      } else if (OldNonTypeParm && hasVisibleDefaultArgument(OldNonTypeParm) &&\n                 NewNonTypeParm->hasDefaultArgument() &&\n                 (!SkipBody || !SkipBody->ShouldSkip)) {\n        OldDefaultLoc = OldNonTypeParm->getDefaultArgumentLoc();\n        NewDefaultLoc = NewNonTypeParm->getDefaultArgumentLoc();\n        SawDefaultArgument = true;\n        RedundantDefaultArg = true;\n        PreviousDefaultArgLoc = NewDefaultLoc;\n      } else if (OldNonTypeParm && OldNonTypeParm->hasDefaultArgument()) {\n        // Merge the default argument from the old declaration to the\n        // new declaration.\n        NewNonTypeParm->setInheritedDefaultArgument(Context, OldNonTypeParm);\n        PreviousDefaultArgLoc = OldNonTypeParm->getDefaultArgumentLoc();\n      } else if (NewNonTypeParm->hasDefaultArgument()) {\n        SawDefaultArgument = true;\n        PreviousDefaultArgLoc = NewNonTypeParm->getDefaultArgumentLoc();\n      } else if (SawDefaultArgument)\n        MissingDefaultArg = true;\n    } else {\n      TemplateTemplateParmDecl *NewTemplateParm\n        = cast<TemplateTemplateParmDecl>(*NewParam);\n\n      // Check for unexpanded parameter packs, recursively.\n      if (::DiagnoseUnexpandedParameterPacks(*this, NewTemplateParm)) {\n        Invalid = true;\n        continue;\n      }\n\n      // Check the presence of a default argument here.\n      if (NewTemplateParm->hasDefaultArgument() &&\n          DiagnoseDefaultTemplateArgument(*this, TPC,\n                                          NewTemplateParm->getLocation(),\n                     NewTemplateParm->getDefaultArgument().getSourceRange()))\n        NewTemplateParm->removeDefaultArgument();\n\n      // Merge default arguments for template template parameters\n      TemplateTemplateParmDecl *OldTemplateParm\n        = OldParams? cast<TemplateTemplateParmDecl>(*OldParam) : nullptr;\n      if (NewTemplateParm->isParameterPack()) {\n        assert(!NewTemplateParm->hasDefaultArgument() &&\n               \"Parameter packs can't have a default argument!\");\n        if (!NewTemplateParm->isPackExpansion())\n          SawParameterPack = true;\n      } else if (OldTemplateParm &&\n                 hasVisibleDefaultArgument(OldTemplateParm) &&\n                 NewTemplateParm->hasDefaultArgument() &&\n                 (!SkipBody || !SkipBody->ShouldSkip)) {\n        OldDefaultLoc = OldTemplateParm->getDefaultArgument().getLocation();\n        NewDefaultLoc = NewTemplateParm->getDefaultArgument().getLocation();\n        SawDefaultArgument = true;\n        RedundantDefaultArg = true;\n        PreviousDefaultArgLoc = NewDefaultLoc;\n      } else if (OldTemplateParm && OldTemplateParm->hasDefaultArgument()) {\n        // Merge the default argument from the old declaration to the\n        // new declaration.\n        NewTemplateParm->setInheritedDefaultArgument(Context, OldTemplateParm);\n        PreviousDefaultArgLoc\n          = OldTemplateParm->getDefaultArgument().getLocation();\n      } else if (NewTemplateParm->hasDefaultArgument()) {\n        SawDefaultArgument = true;\n        PreviousDefaultArgLoc\n          = NewTemplateParm->getDefaultArgument().getLocation();\n      } else if (SawDefaultArgument)\n        MissingDefaultArg = true;\n    }\n\n    // C++11 [temp.param]p11:\n    //   If a template parameter of a primary class template or alias template\n    //   is a template parameter pack, it shall be the last template parameter.\n    if (SawParameterPack && (NewParam + 1) != NewParamEnd &&\n        (TPC == TPC_ClassTemplate || TPC == TPC_VarTemplate ||\n         TPC == TPC_TypeAliasTemplate)) {\n      Diag((*NewParam)->getLocation(),\n           diag::err_template_param_pack_must_be_last_template_parameter);\n      Invalid = true;\n    }\n\n    if (RedundantDefaultArg) {\n      // C++ [temp.param]p12:\n      //   A template-parameter shall not be given default arguments\n      //   by two different declarations in the same scope.\n      Diag(NewDefaultLoc, diag::err_template_param_default_arg_redefinition);\n      Diag(OldDefaultLoc, diag::note_template_param_prev_default_arg);\n      Invalid = true;\n    } else if (MissingDefaultArg && TPC != TPC_FunctionTemplate) {\n      // C++ [temp.param]p11:\n      //   If a template-parameter of a class template has a default\n      //   template-argument, each subsequent template-parameter shall either\n      //   have a default template-argument supplied or be a template parameter\n      //   pack.\n      Diag((*NewParam)->getLocation(),\n           diag::err_template_param_default_arg_missing);\n      Diag(PreviousDefaultArgLoc, diag::note_template_param_prev_default_arg);\n      Invalid = true;\n      RemoveDefaultArguments = true;\n    }\n\n    // If we have an old template parameter list that we're merging\n    // in, move on to the next parameter.\n    if (OldParams)\n      ++OldParam;\n  }\n\n  // We were missing some default arguments at the end of the list, so remove\n  // all of the default arguments.\n  if (RemoveDefaultArguments) {\n    for (TemplateParameterList::iterator NewParam = NewParams->begin(),\n                                      NewParamEnd = NewParams->end();\n         NewParam != NewParamEnd; ++NewParam) {\n      if (TemplateTypeParmDecl *TTP = dyn_cast<TemplateTypeParmDecl>(*NewParam))\n        TTP->removeDefaultArgument();\n      else if (NonTypeTemplateParmDecl *NTTP\n                                = dyn_cast<NonTypeTemplateParmDecl>(*NewParam))\n        NTTP->removeDefaultArgument();\n      else\n        cast<TemplateTemplateParmDecl>(*NewParam)->removeDefaultArgument();\n    }\n  }\n\n  return Invalid;\n}\n\nnamespace {\n\n/// A class which looks for a use of a certain level of template\n/// parameter.\nstruct DependencyChecker : RecursiveASTVisitor<DependencyChecker> {\n  typedef RecursiveASTVisitor<DependencyChecker> super;\n\n  unsigned Depth;\n\n  // Whether we're looking for a use of a template parameter that makes the\n  // overall construct type-dependent / a dependent type. This is strictly\n  // best-effort for now; we may fail to match at all for a dependent type\n  // in some cases if this is set.\n  bool IgnoreNonTypeDependent;\n\n  bool Match;\n  SourceLocation MatchLoc;\n\n  DependencyChecker(unsigned Depth, bool IgnoreNonTypeDependent)\n      : Depth(Depth), IgnoreNonTypeDependent(IgnoreNonTypeDependent),\n        Match(false) {}\n\n  DependencyChecker(TemplateParameterList *Params, bool IgnoreNonTypeDependent)\n      : IgnoreNonTypeDependent(IgnoreNonTypeDependent), Match(false) {\n    NamedDecl *ND = Params->getParam(0);\n    if (TemplateTypeParmDecl *PD = dyn_cast<TemplateTypeParmDecl>(ND)) {\n      Depth = PD->getDepth();\n    } else if (NonTypeTemplateParmDecl *PD =\n                 dyn_cast<NonTypeTemplateParmDecl>(ND)) {\n      Depth = PD->getDepth();\n    } else {\n      Depth = cast<TemplateTemplateParmDecl>(ND)->getDepth();\n    }\n  }\n\n  bool Matches(unsigned ParmDepth, SourceLocation Loc = SourceLocation()) {\n    if (ParmDepth >= Depth) {\n      Match = true;\n      MatchLoc = Loc;\n      return true;\n    }\n    return false;\n  }\n\n  bool TraverseStmt(Stmt *S, DataRecursionQueue *Q = nullptr) {\n    // Prune out non-type-dependent expressions if requested. This can\n    // sometimes result in us failing to find a template parameter reference\n    // (if a value-dependent expression creates a dependent type), but this\n    // mode is best-effort only.\n    if (auto *E = dyn_cast_or_null<Expr>(S))\n      if (IgnoreNonTypeDependent && !E->isTypeDependent())\n        return true;\n    return super::TraverseStmt(S, Q);\n  }\n\n  bool TraverseTypeLoc(TypeLoc TL) {\n    if (IgnoreNonTypeDependent && !TL.isNull() &&\n        !TL.getType()->isDependentType())\n      return true;\n    return super::TraverseTypeLoc(TL);\n  }\n\n  bool VisitTemplateTypeParmTypeLoc(TemplateTypeParmTypeLoc TL) {\n    return !Matches(TL.getTypePtr()->getDepth(), TL.getNameLoc());\n  }\n\n  bool VisitTemplateTypeParmType(const TemplateTypeParmType *T) {\n    // For a best-effort search, keep looking until we find a location.\n    return IgnoreNonTypeDependent || !Matches(T->getDepth());\n  }\n\n  bool TraverseTemplateName(TemplateName N) {\n    if (TemplateTemplateParmDecl *PD =\n          dyn_cast_or_null<TemplateTemplateParmDecl>(N.getAsTemplateDecl()))\n      if (Matches(PD->getDepth()))\n        return false;\n    return super::TraverseTemplateName(N);\n  }\n\n  bool VisitDeclRefExpr(DeclRefExpr *E) {\n    if (NonTypeTemplateParmDecl *PD =\n          dyn_cast<NonTypeTemplateParmDecl>(E->getDecl()))\n      if (Matches(PD->getDepth(), E->getExprLoc()))\n        return false;\n    return super::VisitDeclRefExpr(E);\n  }\n\n  bool VisitSubstTemplateTypeParmType(const SubstTemplateTypeParmType *T) {\n    return TraverseType(T->getReplacementType());\n  }\n\n  bool\n  VisitSubstTemplateTypeParmPackType(const SubstTemplateTypeParmPackType *T) {\n    return TraverseTemplateArgument(T->getArgumentPack());\n  }\n\n  bool TraverseInjectedClassNameType(const InjectedClassNameType *T) {\n    return TraverseType(T->getInjectedSpecializationType());\n  }\n};\n} // end anonymous namespace\n\n/// Determines whether a given type depends on the given parameter\n/// list.\nstatic bool\nDependsOnTemplateParameters(QualType T, TemplateParameterList *Params) {\n  if (!Params->size())\n    return false;\n\n  DependencyChecker Checker(Params, /*IgnoreNonTypeDependent*/false);\n  Checker.TraverseType(T);\n  return Checker.Match;\n}\n\n// Find the source range corresponding to the named type in the given\n// nested-name-specifier, if any.\nstatic SourceRange getRangeOfTypeInNestedNameSpecifier(ASTContext &Context,\n                                                       QualType T,\n                                                       const CXXScopeSpec &SS) {\n  NestedNameSpecifierLoc NNSLoc(SS.getScopeRep(), SS.location_data());\n  while (NestedNameSpecifier *NNS = NNSLoc.getNestedNameSpecifier()) {\n    if (const Type *CurType = NNS->getAsType()) {\n      if (Context.hasSameUnqualifiedType(T, QualType(CurType, 0)))\n        return NNSLoc.getTypeLoc().getSourceRange();\n    } else\n      break;\n\n    NNSLoc = NNSLoc.getPrefix();\n  }\n\n  return SourceRange();\n}\n\n/// Match the given template parameter lists to the given scope\n/// specifier, returning the template parameter list that applies to the\n/// name.\n///\n/// \\param DeclStartLoc the start of the declaration that has a scope\n/// specifier or a template parameter list.\n///\n/// \\param DeclLoc The location of the declaration itself.\n///\n/// \\param SS the scope specifier that will be matched to the given template\n/// parameter lists. This scope specifier precedes a qualified name that is\n/// being declared.\n///\n/// \\param TemplateId The template-id following the scope specifier, if there\n/// is one. Used to check for a missing 'template<>'.\n///\n/// \\param ParamLists the template parameter lists, from the outermost to the\n/// innermost template parameter lists.\n///\n/// \\param IsFriend Whether to apply the slightly different rules for\n/// matching template parameters to scope specifiers in friend\n/// declarations.\n///\n/// \\param IsMemberSpecialization will be set true if the scope specifier\n/// denotes a fully-specialized type, and therefore this is a declaration of\n/// a member specialization.\n///\n/// \\returns the template parameter list, if any, that corresponds to the\n/// name that is preceded by the scope specifier @p SS. This template\n/// parameter list may have template parameters (if we're declaring a\n/// template) or may have no template parameters (if we're declaring a\n/// template specialization), or may be NULL (if what we're declaring isn't\n/// itself a template).\nTemplateParameterList *Sema::MatchTemplateParametersToScopeSpecifier(\n    SourceLocation DeclStartLoc, SourceLocation DeclLoc, const CXXScopeSpec &SS,\n    TemplateIdAnnotation *TemplateId,\n    ArrayRef<TemplateParameterList *> ParamLists, bool IsFriend,\n    bool &IsMemberSpecialization, bool &Invalid, bool SuppressDiagnostic) {\n  IsMemberSpecialization = false;\n  Invalid = false;\n\n  // The sequence of nested types to which we will match up the template\n  // parameter lists. We first build this list by starting with the type named\n  // by the nested-name-specifier and walking out until we run out of types.\n  SmallVector<QualType, 4> NestedTypes;\n  QualType T;\n  if (SS.getScopeRep()) {\n    if (CXXRecordDecl *Record\n              = dyn_cast_or_null<CXXRecordDecl>(computeDeclContext(SS, true)))\n      T = Context.getTypeDeclType(Record);\n    else\n      T = QualType(SS.getScopeRep()->getAsType(), 0);\n  }\n\n  // If we found an explicit specialization that prevents us from needing\n  // 'template<>' headers, this will be set to the location of that\n  // explicit specialization.\n  SourceLocation ExplicitSpecLoc;\n\n  while (!T.isNull()) {\n    NestedTypes.push_back(T);\n\n    // Retrieve the parent of a record type.\n    if (CXXRecordDecl *Record = T->getAsCXXRecordDecl()) {\n      // If this type is an explicit specialization, we're done.\n      if (ClassTemplateSpecializationDecl *Spec\n          = dyn_cast<ClassTemplateSpecializationDecl>(Record)) {\n        if (!isa<ClassTemplatePartialSpecializationDecl>(Spec) &&\n            Spec->getSpecializationKind() == TSK_ExplicitSpecialization) {\n          ExplicitSpecLoc = Spec->getLocation();\n          break;\n        }\n      } else if (Record->getTemplateSpecializationKind()\n                                                == TSK_ExplicitSpecialization) {\n        ExplicitSpecLoc = Record->getLocation();\n        break;\n      }\n\n      if (TypeDecl *Parent = dyn_cast<TypeDecl>(Record->getParent()))\n        T = Context.getTypeDeclType(Parent);\n      else\n        T = QualType();\n      continue;\n    }\n\n    if (const TemplateSpecializationType *TST\n                                     = T->getAs<TemplateSpecializationType>()) {\n      if (TemplateDecl *Template = TST->getTemplateName().getAsTemplateDecl()) {\n        if (TypeDecl *Parent = dyn_cast<TypeDecl>(Template->getDeclContext()))\n          T = Context.getTypeDeclType(Parent);\n        else\n          T = QualType();\n        continue;\n      }\n    }\n\n    // Look one step prior in a dependent template specialization type.\n    if (const DependentTemplateSpecializationType *DependentTST\n                          = T->getAs<DependentTemplateSpecializationType>()) {\n      if (NestedNameSpecifier *NNS = DependentTST->getQualifier())\n        T = QualType(NNS->getAsType(), 0);\n      else\n        T = QualType();\n      continue;\n    }\n\n    // Look one step prior in a dependent name type.\n    if (const DependentNameType *DependentName = T->getAs<DependentNameType>()){\n      if (NestedNameSpecifier *NNS = DependentName->getQualifier())\n        T = QualType(NNS->getAsType(), 0);\n      else\n        T = QualType();\n      continue;\n    }\n\n    // Retrieve the parent of an enumeration type.\n    if (const EnumType *EnumT = T->getAs<EnumType>()) {\n      // FIXME: Forward-declared enums require a TSK_ExplicitSpecialization\n      // check here.\n      EnumDecl *Enum = EnumT->getDecl();\n\n      // Get to the parent type.\n      if (TypeDecl *Parent = dyn_cast<TypeDecl>(Enum->getParent()))\n        T = Context.getTypeDeclType(Parent);\n      else\n        T = QualType();\n      continue;\n    }\n\n    T = QualType();\n  }\n  // Reverse the nested types list, since we want to traverse from the outermost\n  // to the innermost while checking template-parameter-lists.\n  std::reverse(NestedTypes.begin(), NestedTypes.end());\n\n  // C++0x [temp.expl.spec]p17:\n  //   A member or a member template may be nested within many\n  //   enclosing class templates. In an explicit specialization for\n  //   such a member, the member declaration shall be preceded by a\n  //   template<> for each enclosing class template that is\n  //   explicitly specialized.\n  bool SawNonEmptyTemplateParameterList = false;\n\n  auto CheckExplicitSpecialization = [&](SourceRange Range, bool Recovery) {\n    if (SawNonEmptyTemplateParameterList) {\n      if (!SuppressDiagnostic)\n        Diag(DeclLoc, diag::err_specialize_member_of_template)\n          << !Recovery << Range;\n      Invalid = true;\n      IsMemberSpecialization = false;\n      return true;\n    }\n\n    return false;\n  };\n\n  auto DiagnoseMissingExplicitSpecialization = [&] (SourceRange Range) {\n    // Check that we can have an explicit specialization here.\n    if (CheckExplicitSpecialization(Range, true))\n      return true;\n\n    // We don't have a template header, but we should.\n    SourceLocation ExpectedTemplateLoc;\n    if (!ParamLists.empty())\n      ExpectedTemplateLoc = ParamLists[0]->getTemplateLoc();\n    else\n      ExpectedTemplateLoc = DeclStartLoc;\n\n    if (!SuppressDiagnostic)\n      Diag(DeclLoc, diag::err_template_spec_needs_header)\n        << Range\n        << FixItHint::CreateInsertion(ExpectedTemplateLoc, \"template<> \");\n    return false;\n  };\n\n  unsigned ParamIdx = 0;\n  for (unsigned TypeIdx = 0, NumTypes = NestedTypes.size(); TypeIdx != NumTypes;\n       ++TypeIdx) {\n    T = NestedTypes[TypeIdx];\n\n    // Whether we expect a 'template<>' header.\n    bool NeedEmptyTemplateHeader = false;\n\n    // Whether we expect a template header with parameters.\n    bool NeedNonemptyTemplateHeader = false;\n\n    // For a dependent type, the set of template parameters that we\n    // expect to see.\n    TemplateParameterList *ExpectedTemplateParams = nullptr;\n\n    // C++0x [temp.expl.spec]p15:\n    //   A member or a member template may be nested within many enclosing\n    //   class templates. In an explicit specialization for such a member, the\n    //   member declaration shall be preceded by a template<> for each\n    //   enclosing class template that is explicitly specialized.\n    if (CXXRecordDecl *Record = T->getAsCXXRecordDecl()) {\n      if (ClassTemplatePartialSpecializationDecl *Partial\n            = dyn_cast<ClassTemplatePartialSpecializationDecl>(Record)) {\n        ExpectedTemplateParams = Partial->getTemplateParameters();\n        NeedNonemptyTemplateHeader = true;\n      } else if (Record->isDependentType()) {\n        if (Record->getDescribedClassTemplate()) {\n          ExpectedTemplateParams = Record->getDescribedClassTemplate()\n                                                      ->getTemplateParameters();\n          NeedNonemptyTemplateHeader = true;\n        }\n      } else if (ClassTemplateSpecializationDecl *Spec\n                     = dyn_cast<ClassTemplateSpecializationDecl>(Record)) {\n        // C++0x [temp.expl.spec]p4:\n        //   Members of an explicitly specialized class template are defined\n        //   in the same manner as members of normal classes, and not using\n        //   the template<> syntax.\n        if (Spec->getSpecializationKind() != TSK_ExplicitSpecialization)\n          NeedEmptyTemplateHeader = true;\n        else\n          continue;\n      } else if (Record->getTemplateSpecializationKind()) {\n        if (Record->getTemplateSpecializationKind()\n                                                != TSK_ExplicitSpecialization &&\n            TypeIdx == NumTypes - 1)\n          IsMemberSpecialization = true;\n\n        continue;\n      }\n    } else if (const TemplateSpecializationType *TST\n                                     = T->getAs<TemplateSpecializationType>()) {\n      if (TemplateDecl *Template = TST->getTemplateName().getAsTemplateDecl()) {\n        ExpectedTemplateParams = Template->getTemplateParameters();\n        NeedNonemptyTemplateHeader = true;\n      }\n    } else if (T->getAs<DependentTemplateSpecializationType>()) {\n      // FIXME:  We actually could/should check the template arguments here\n      // against the corresponding template parameter list.\n      NeedNonemptyTemplateHeader = false;\n    }\n\n    // C++ [temp.expl.spec]p16:\n    //   In an explicit specialization declaration for a member of a class\n    //   template or a member template that ap- pears in namespace scope, the\n    //   member template and some of its enclosing class templates may remain\n    //   unspecialized, except that the declaration shall not explicitly\n    //   specialize a class member template if its en- closing class templates\n    //   are not explicitly specialized as well.\n    if (ParamIdx < ParamLists.size()) {\n      if (ParamLists[ParamIdx]->size() == 0) {\n        if (CheckExplicitSpecialization(ParamLists[ParamIdx]->getSourceRange(),\n                                        false))\n          return nullptr;\n      } else\n        SawNonEmptyTemplateParameterList = true;\n    }\n\n    if (NeedEmptyTemplateHeader) {\n      // If we're on the last of the types, and we need a 'template<>' header\n      // here, then it's a member specialization.\n      if (TypeIdx == NumTypes - 1)\n        IsMemberSpecialization = true;\n\n      if (ParamIdx < ParamLists.size()) {\n        if (ParamLists[ParamIdx]->size() > 0) {\n          // The header has template parameters when it shouldn't. Complain.\n          if (!SuppressDiagnostic)\n            Diag(ParamLists[ParamIdx]->getTemplateLoc(),\n                 diag::err_template_param_list_matches_nontemplate)\n              << T\n              << SourceRange(ParamLists[ParamIdx]->getLAngleLoc(),\n                             ParamLists[ParamIdx]->getRAngleLoc())\n              << getRangeOfTypeInNestedNameSpecifier(Context, T, SS);\n          Invalid = true;\n          return nullptr;\n        }\n\n        // Consume this template header.\n        ++ParamIdx;\n        continue;\n      }\n\n      if (!IsFriend)\n        if (DiagnoseMissingExplicitSpecialization(\n                getRangeOfTypeInNestedNameSpecifier(Context, T, SS)))\n          return nullptr;\n\n      continue;\n    }\n\n    if (NeedNonemptyTemplateHeader) {\n      // In friend declarations we can have template-ids which don't\n      // depend on the corresponding template parameter lists.  But\n      // assume that empty parameter lists are supposed to match this\n      // template-id.\n      if (IsFriend && T->isDependentType()) {\n        if (ParamIdx < ParamLists.size() &&\n            DependsOnTemplateParameters(T, ParamLists[ParamIdx]))\n          ExpectedTemplateParams = nullptr;\n        else\n          continue;\n      }\n\n      if (ParamIdx < ParamLists.size()) {\n        // Check the template parameter list, if we can.\n        if (ExpectedTemplateParams &&\n            !TemplateParameterListsAreEqual(ParamLists[ParamIdx],\n                                            ExpectedTemplateParams,\n                                            !SuppressDiagnostic, TPL_TemplateMatch))\n          Invalid = true;\n\n        if (!Invalid &&\n            CheckTemplateParameterList(ParamLists[ParamIdx], nullptr,\n                                       TPC_ClassTemplateMember))\n          Invalid = true;\n\n        ++ParamIdx;\n        continue;\n      }\n\n      if (!SuppressDiagnostic)\n        Diag(DeclLoc, diag::err_template_spec_needs_template_parameters)\n          << T\n          << getRangeOfTypeInNestedNameSpecifier(Context, T, SS);\n      Invalid = true;\n      continue;\n    }\n  }\n\n  // If there were at least as many template-ids as there were template\n  // parameter lists, then there are no template parameter lists remaining for\n  // the declaration itself.\n  if (ParamIdx >= ParamLists.size()) {\n    if (TemplateId && !IsFriend) {\n      // We don't have a template header for the declaration itself, but we\n      // should.\n      DiagnoseMissingExplicitSpecialization(SourceRange(TemplateId->LAngleLoc,\n                                                        TemplateId->RAngleLoc));\n\n      // Fabricate an empty template parameter list for the invented header.\n      return TemplateParameterList::Create(Context, SourceLocation(),\n                                           SourceLocation(), None,\n                                           SourceLocation(), nullptr);\n    }\n\n    return nullptr;\n  }\n\n  // If there were too many template parameter lists, complain about that now.\n  if (ParamIdx < ParamLists.size() - 1) {\n    bool HasAnyExplicitSpecHeader = false;\n    bool AllExplicitSpecHeaders = true;\n    for (unsigned I = ParamIdx, E = ParamLists.size() - 1; I != E; ++I) {\n      if (ParamLists[I]->size() == 0)\n        HasAnyExplicitSpecHeader = true;\n      else\n        AllExplicitSpecHeaders = false;\n    }\n\n    if (!SuppressDiagnostic)\n      Diag(ParamLists[ParamIdx]->getTemplateLoc(),\n           AllExplicitSpecHeaders ? diag::warn_template_spec_extra_headers\n                                  : diag::err_template_spec_extra_headers)\n          << SourceRange(ParamLists[ParamIdx]->getTemplateLoc(),\n                         ParamLists[ParamLists.size() - 2]->getRAngleLoc());\n\n    // If there was a specialization somewhere, such that 'template<>' is\n    // not required, and there were any 'template<>' headers, note where the\n    // specialization occurred.\n    if (ExplicitSpecLoc.isValid() && HasAnyExplicitSpecHeader &&\n        !SuppressDiagnostic)\n      Diag(ExplicitSpecLoc,\n           diag::note_explicit_template_spec_does_not_need_header)\n        << NestedTypes.back();\n\n    // We have a template parameter list with no corresponding scope, which\n    // means that the resulting template declaration can't be instantiated\n    // properly (we'll end up with dependent nodes when we shouldn't).\n    if (!AllExplicitSpecHeaders)\n      Invalid = true;\n  }\n\n  // C++ [temp.expl.spec]p16:\n  //   In an explicit specialization declaration for a member of a class\n  //   template or a member template that ap- pears in namespace scope, the\n  //   member template and some of its enclosing class templates may remain\n  //   unspecialized, except that the declaration shall not explicitly\n  //   specialize a class member template if its en- closing class templates\n  //   are not explicitly specialized as well.\n  if (ParamLists.back()->size() == 0 &&\n      CheckExplicitSpecialization(ParamLists[ParamIdx]->getSourceRange(),\n                                  false))\n    return nullptr;\n\n  // Return the last template parameter list, which corresponds to the\n  // entity being declared.\n  return ParamLists.back();\n}\n\nvoid Sema::NoteAllFoundTemplates(TemplateName Name) {\n  if (TemplateDecl *Template = Name.getAsTemplateDecl()) {\n    Diag(Template->getLocation(), diag::note_template_declared_here)\n        << (isa<FunctionTemplateDecl>(Template)\n                ? 0\n                : isa<ClassTemplateDecl>(Template)\n                      ? 1\n                      : isa<VarTemplateDecl>(Template)\n                            ? 2\n                            : isa<TypeAliasTemplateDecl>(Template) ? 3 : 4)\n        << Template->getDeclName();\n    return;\n  }\n\n  if (OverloadedTemplateStorage *OST = Name.getAsOverloadedTemplate()) {\n    for (OverloadedTemplateStorage::iterator I = OST->begin(),\n                                          IEnd = OST->end();\n         I != IEnd; ++I)\n      Diag((*I)->getLocation(), diag::note_template_declared_here)\n        << 0 << (*I)->getDeclName();\n\n    return;\n  }\n}\n\nstatic QualType\ncheckBuiltinTemplateIdType(Sema &SemaRef, BuiltinTemplateDecl *BTD,\n                           const SmallVectorImpl<TemplateArgument> &Converted,\n                           SourceLocation TemplateLoc,\n                           TemplateArgumentListInfo &TemplateArgs) {\n  ASTContext &Context = SemaRef.getASTContext();\n  switch (BTD->getBuiltinTemplateKind()) {\n  case BTK__make_integer_seq: {\n    // Specializations of __make_integer_seq<S, T, N> are treated like\n    // S<T, 0, ..., N-1>.\n\n    // C++14 [inteseq.intseq]p1:\n    //   T shall be an integer type.\n    if (!Converted[1].getAsType()->isIntegralType(Context)) {\n      SemaRef.Diag(TemplateArgs[1].getLocation(),\n                   diag::err_integer_sequence_integral_element_type);\n      return QualType();\n    }\n\n    // C++14 [inteseq.make]p1:\n    //   If N is negative the program is ill-formed.\n    TemplateArgument NumArgsArg = Converted[2];\n    llvm::APSInt NumArgs = NumArgsArg.getAsIntegral();\n    if (NumArgs < 0) {\n      SemaRef.Diag(TemplateArgs[2].getLocation(),\n                   diag::err_integer_sequence_negative_length);\n      return QualType();\n    }\n\n    QualType ArgTy = NumArgsArg.getIntegralType();\n    TemplateArgumentListInfo SyntheticTemplateArgs;\n    // The type argument gets reused as the first template argument in the\n    // synthetic template argument list.\n    SyntheticTemplateArgs.addArgument(TemplateArgs[1]);\n    // Expand N into 0 ... N-1.\n    for (llvm::APSInt I(NumArgs.getBitWidth(), NumArgs.isUnsigned());\n         I < NumArgs; ++I) {\n      TemplateArgument TA(Context, I, ArgTy);\n      SyntheticTemplateArgs.addArgument(SemaRef.getTrivialTemplateArgumentLoc(\n          TA, ArgTy, TemplateArgs[2].getLocation()));\n    }\n    // The first template argument will be reused as the template decl that\n    // our synthetic template arguments will be applied to.\n    return SemaRef.CheckTemplateIdType(Converted[0].getAsTemplate(),\n                                       TemplateLoc, SyntheticTemplateArgs);\n  }\n\n  case BTK__type_pack_element:\n    // Specializations of\n    //    __type_pack_element<Index, T_1, ..., T_N>\n    // are treated like T_Index.\n    assert(Converted.size() == 2 &&\n      \"__type_pack_element should be given an index and a parameter pack\");\n\n    // If the Index is out of bounds, the program is ill-formed.\n    TemplateArgument IndexArg = Converted[0], Ts = Converted[1];\n    llvm::APSInt Index = IndexArg.getAsIntegral();\n    assert(Index >= 0 && \"the index used with __type_pack_element should be of \"\n                         \"type std::size_t, and hence be non-negative\");\n    if (Index >= Ts.pack_size()) {\n      SemaRef.Diag(TemplateArgs[0].getLocation(),\n                   diag::err_type_pack_element_out_of_bounds);\n      return QualType();\n    }\n\n    // We simply return the type at index `Index`.\n    auto Nth = std::next(Ts.pack_begin(), Index.getExtValue());\n    return Nth->getAsType();\n  }\n  llvm_unreachable(\"unexpected BuiltinTemplateDecl!\");\n}\n\n/// Determine whether this alias template is \"enable_if_t\".\nstatic bool isEnableIfAliasTemplate(TypeAliasTemplateDecl *AliasTemplate) {\n  return AliasTemplate->getName().equals(\"enable_if_t\");\n}\n\n/// Collect all of the separable terms in the given condition, which\n/// might be a conjunction.\n///\n/// FIXME: The right answer is to convert the logical expression into\n/// disjunctive normal form, so we can find the first failed term\n/// within each possible clause.\nstatic void collectConjunctionTerms(Expr *Clause,\n                                    SmallVectorImpl<Expr *> &Terms) {\n  if (auto BinOp = dyn_cast<BinaryOperator>(Clause->IgnoreParenImpCasts())) {\n    if (BinOp->getOpcode() == BO_LAnd) {\n      collectConjunctionTerms(BinOp->getLHS(), Terms);\n      collectConjunctionTerms(BinOp->getRHS(), Terms);\n    }\n\n    return;\n  }\n\n  Terms.push_back(Clause);\n}\n\n// The ranges-v3 library uses an odd pattern of a top-level \"||\" with\n// a left-hand side that is value-dependent but never true. Identify\n// the idiom and ignore that term.\nstatic Expr *lookThroughRangesV3Condition(Preprocessor &PP, Expr *Cond) {\n  // Top-level '||'.\n  auto *BinOp = dyn_cast<BinaryOperator>(Cond->IgnoreParenImpCasts());\n  if (!BinOp) return Cond;\n\n  if (BinOp->getOpcode() != BO_LOr) return Cond;\n\n  // With an inner '==' that has a literal on the right-hand side.\n  Expr *LHS = BinOp->getLHS();\n  auto *InnerBinOp = dyn_cast<BinaryOperator>(LHS->IgnoreParenImpCasts());\n  if (!InnerBinOp) return Cond;\n\n  if (InnerBinOp->getOpcode() != BO_EQ ||\n      !isa<IntegerLiteral>(InnerBinOp->getRHS()))\n    return Cond;\n\n  // If the inner binary operation came from a macro expansion named\n  // CONCEPT_REQUIRES or CONCEPT_REQUIRES_, return the right-hand side\n  // of the '||', which is the real, user-provided condition.\n  SourceLocation Loc = InnerBinOp->getExprLoc();\n  if (!Loc.isMacroID()) return Cond;\n\n  StringRef MacroName = PP.getImmediateMacroName(Loc);\n  if (MacroName == \"CONCEPT_REQUIRES\" || MacroName == \"CONCEPT_REQUIRES_\")\n    return BinOp->getRHS();\n\n  return Cond;\n}\n\nnamespace {\n\n// A PrinterHelper that prints more helpful diagnostics for some sub-expressions\n// within failing boolean expression, such as substituting template parameters\n// for actual types.\nclass FailedBooleanConditionPrinterHelper : public PrinterHelper {\npublic:\n  explicit FailedBooleanConditionPrinterHelper(const PrintingPolicy &P)\n      : Policy(P) {}\n\n  bool handledStmt(Stmt *E, raw_ostream &OS) override {\n    const auto *DR = dyn_cast<DeclRefExpr>(E);\n    if (DR && DR->getQualifier()) {\n      // If this is a qualified name, expand the template arguments in nested\n      // qualifiers.\n      DR->getQualifier()->print(OS, Policy, true);\n      // Then print the decl itself.\n      const ValueDecl *VD = DR->getDecl();\n      OS << VD->getName();\n      if (const auto *IV = dyn_cast<VarTemplateSpecializationDecl>(VD)) {\n        // This is a template variable, print the expanded template arguments.\n        printTemplateArgumentList(OS, IV->getTemplateArgs().asArray(), Policy);\n      }\n      return true;\n    }\n    return false;\n  }\n\nprivate:\n  const PrintingPolicy Policy;\n};\n\n} // end anonymous namespace\n\nstd::pair<Expr *, std::string>\nSema::findFailedBooleanCondition(Expr *Cond) {\n  Cond = lookThroughRangesV3Condition(PP, Cond);\n\n  // Separate out all of the terms in a conjunction.\n  SmallVector<Expr *, 4> Terms;\n  collectConjunctionTerms(Cond, Terms);\n\n  // Determine which term failed.\n  Expr *FailedCond = nullptr;\n  for (Expr *Term : Terms) {\n    Expr *TermAsWritten = Term->IgnoreParenImpCasts();\n\n    // Literals are uninteresting.\n    if (isa<CXXBoolLiteralExpr>(TermAsWritten) ||\n        isa<IntegerLiteral>(TermAsWritten))\n      continue;\n\n    // The initialization of the parameter from the argument is\n    // a constant-evaluated context.\n    EnterExpressionEvaluationContext ConstantEvaluated(\n      *this, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n\n    bool Succeeded;\n    if (Term->EvaluateAsBooleanCondition(Succeeded, Context) &&\n        !Succeeded) {\n      FailedCond = TermAsWritten;\n      break;\n    }\n  }\n  if (!FailedCond)\n    FailedCond = Cond->IgnoreParenImpCasts();\n\n  std::string Description;\n  {\n    llvm::raw_string_ostream Out(Description);\n    PrintingPolicy Policy = getPrintingPolicy();\n    Policy.PrintCanonicalTypes = true;\n    FailedBooleanConditionPrinterHelper Helper(Policy);\n    FailedCond->printPretty(Out, &Helper, Policy, 0, \"\\n\", nullptr);\n  }\n  return { FailedCond, Description };\n}\n\nQualType Sema::CheckTemplateIdType(TemplateName Name,\n                                   SourceLocation TemplateLoc,\n                                   TemplateArgumentListInfo &TemplateArgs) {\n  DependentTemplateName *DTN\n    = Name.getUnderlying().getAsDependentTemplateName();\n  if (DTN && DTN->isIdentifier())\n    // When building a template-id where the template-name is dependent,\n    // assume the template is a type template. Either our assumption is\n    // correct, or the code is ill-formed and will be diagnosed when the\n    // dependent name is substituted.\n    return Context.getDependentTemplateSpecializationType(ETK_None,\n                                                          DTN->getQualifier(),\n                                                          DTN->getIdentifier(),\n                                                          TemplateArgs);\n\n  if (Name.getAsAssumedTemplateName() &&\n      resolveAssumedTemplateNameAsType(/*Scope*/nullptr, Name, TemplateLoc))\n    return QualType();\n\n  TemplateDecl *Template = Name.getAsTemplateDecl();\n  if (!Template || isa<FunctionTemplateDecl>(Template) ||\n      isa<VarTemplateDecl>(Template) || isa<ConceptDecl>(Template)) {\n    // We might have a substituted template template parameter pack. If so,\n    // build a template specialization type for it.\n    if (Name.getAsSubstTemplateTemplateParmPack())\n      return Context.getTemplateSpecializationType(Name, TemplateArgs);\n\n    Diag(TemplateLoc, diag::err_template_id_not_a_type)\n      << Name;\n    NoteAllFoundTemplates(Name);\n    return QualType();\n  }\n\n  // Check that the template argument list is well-formed for this\n  // template.\n  SmallVector<TemplateArgument, 4> Converted;\n  if (CheckTemplateArgumentList(Template, TemplateLoc, TemplateArgs,\n                                false, Converted,\n                                /*UpdateArgsWithConversion=*/true))\n    return QualType();\n\n  QualType CanonType;\n\n  if (TypeAliasTemplateDecl *AliasTemplate =\n          dyn_cast<TypeAliasTemplateDecl>(Template)) {\n\n    // Find the canonical type for this type alias template specialization.\n    TypeAliasDecl *Pattern = AliasTemplate->getTemplatedDecl();\n    if (Pattern->isInvalidDecl())\n      return QualType();\n\n    TemplateArgumentList StackTemplateArgs(TemplateArgumentList::OnStack,\n                                           Converted);\n\n    // Only substitute for the innermost template argument list.\n    MultiLevelTemplateArgumentList TemplateArgLists;\n    TemplateArgLists.addOuterTemplateArguments(&StackTemplateArgs);\n    TemplateArgLists.addOuterRetainedLevels(\n        AliasTemplate->getTemplateParameters()->getDepth());\n\n    LocalInstantiationScope Scope(*this);\n    InstantiatingTemplate Inst(*this, TemplateLoc, Template);\n    if (Inst.isInvalid())\n      return QualType();\n\n    CanonType = SubstType(Pattern->getUnderlyingType(),\n                          TemplateArgLists, AliasTemplate->getLocation(),\n                          AliasTemplate->getDeclName());\n    if (CanonType.isNull()) {\n      // If this was enable_if and we failed to find the nested type\n      // within enable_if in a SFINAE context, dig out the specific\n      // enable_if condition that failed and present that instead.\n      if (isEnableIfAliasTemplate(AliasTemplate)) {\n        if (auto DeductionInfo = isSFINAEContext()) {\n          if (*DeductionInfo &&\n              (*DeductionInfo)->hasSFINAEDiagnostic() &&\n              (*DeductionInfo)->peekSFINAEDiagnostic().second.getDiagID() ==\n                diag::err_typename_nested_not_found_enable_if &&\n              TemplateArgs[0].getArgument().getKind()\n                == TemplateArgument::Expression) {\n            Expr *FailedCond;\n            std::string FailedDescription;\n            std::tie(FailedCond, FailedDescription) =\n              findFailedBooleanCondition(TemplateArgs[0].getSourceExpression());\n\n            // Remove the old SFINAE diagnostic.\n            PartialDiagnosticAt OldDiag =\n              {SourceLocation(), PartialDiagnostic::NullDiagnostic()};\n            (*DeductionInfo)->takeSFINAEDiagnostic(OldDiag);\n\n            // Add a new SFINAE diagnostic specifying which condition\n            // failed.\n            (*DeductionInfo)->addSFINAEDiagnostic(\n              OldDiag.first,\n              PDiag(diag::err_typename_nested_not_found_requirement)\n                << FailedDescription\n                << FailedCond->getSourceRange());\n          }\n        }\n      }\n\n      return QualType();\n    }\n  } else if (Name.isDependent() ||\n             TemplateSpecializationType::anyDependentTemplateArguments(\n                 TemplateArgs, Converted)) {\n    // This class template specialization is a dependent\n    // type. Therefore, its canonical type is another class template\n    // specialization type that contains all of the converted\n    // arguments in canonical form. This ensures that, e.g., A<T> and\n    // A<T, T> have identical types when A is declared as:\n    //\n    //   template<typename T, typename U = T> struct A;\n    CanonType = Context.getCanonicalTemplateSpecializationType(Name, Converted);\n\n    // This might work out to be a current instantiation, in which\n    // case the canonical type needs to be the InjectedClassNameType.\n    //\n    // TODO: in theory this could be a simple hashtable lookup; most\n    // changes to CurContext don't change the set of current\n    // instantiations.\n    if (isa<ClassTemplateDecl>(Template)) {\n      for (DeclContext *Ctx = CurContext; Ctx; Ctx = Ctx->getLookupParent()) {\n        // If we get out to a namespace, we're done.\n        if (Ctx->isFileContext()) break;\n\n        // If this isn't a record, keep looking.\n        CXXRecordDecl *Record = dyn_cast<CXXRecordDecl>(Ctx);\n        if (!Record) continue;\n\n        // Look for one of the two cases with InjectedClassNameTypes\n        // and check whether it's the same template.\n        if (!isa<ClassTemplatePartialSpecializationDecl>(Record) &&\n            !Record->getDescribedClassTemplate())\n          continue;\n\n        // Fetch the injected class name type and check whether its\n        // injected type is equal to the type we just built.\n        QualType ICNT = Context.getTypeDeclType(Record);\n        QualType Injected = cast<InjectedClassNameType>(ICNT)\n          ->getInjectedSpecializationType();\n\n        if (CanonType != Injected->getCanonicalTypeInternal())\n          continue;\n\n        // If so, the canonical type of this TST is the injected\n        // class name type of the record we just found.\n        assert(ICNT.isCanonical());\n        CanonType = ICNT;\n        break;\n      }\n    }\n  } else if (ClassTemplateDecl *ClassTemplate\n               = dyn_cast<ClassTemplateDecl>(Template)) {\n    // Find the class template specialization declaration that\n    // corresponds to these arguments.\n    void *InsertPos = nullptr;\n    ClassTemplateSpecializationDecl *Decl\n      = ClassTemplate->findSpecialization(Converted, InsertPos);\n    if (!Decl) {\n      // This is the first time we have referenced this class template\n      // specialization. Create the canonical declaration and add it to\n      // the set of specializations.\n      Decl = ClassTemplateSpecializationDecl::Create(\n          Context, ClassTemplate->getTemplatedDecl()->getTagKind(),\n          ClassTemplate->getDeclContext(),\n          ClassTemplate->getTemplatedDecl()->getBeginLoc(),\n          ClassTemplate->getLocation(), ClassTemplate, Converted, nullptr);\n      ClassTemplate->AddSpecialization(Decl, InsertPos);\n      if (ClassTemplate->isOutOfLine())\n        Decl->setLexicalDeclContext(ClassTemplate->getLexicalDeclContext());\n    }\n\n    if (Decl->getSpecializationKind() == TSK_Undeclared &&\n        ClassTemplate->getTemplatedDecl()->hasAttrs()) {\n      InstantiatingTemplate Inst(*this, TemplateLoc, Decl);\n      if (!Inst.isInvalid()) {\n        MultiLevelTemplateArgumentList TemplateArgLists;\n        TemplateArgLists.addOuterTemplateArguments(Converted);\n        InstantiateAttrsForDecl(TemplateArgLists,\n                                ClassTemplate->getTemplatedDecl(), Decl);\n      }\n    }\n\n    // Diagnose uses of this specialization.\n    (void)DiagnoseUseOfDecl(Decl, TemplateLoc);\n\n    CanonType = Context.getTypeDeclType(Decl);\n    assert(isa<RecordType>(CanonType) &&\n           \"type of non-dependent specialization is not a RecordType\");\n  } else if (auto *BTD = dyn_cast<BuiltinTemplateDecl>(Template)) {\n    CanonType = checkBuiltinTemplateIdType(*this, BTD, Converted, TemplateLoc,\n                                           TemplateArgs);\n  }\n\n  // Build the fully-sugared type for this class template\n  // specialization, which refers back to the class template\n  // specialization we created or found.\n  return Context.getTemplateSpecializationType(Name, TemplateArgs, CanonType);\n}\n\nvoid Sema::ActOnUndeclaredTypeTemplateName(Scope *S, TemplateTy &ParsedName,\n                                           TemplateNameKind &TNK,\n                                           SourceLocation NameLoc,\n                                           IdentifierInfo *&II) {\n  assert(TNK == TNK_Undeclared_template && \"not an undeclared template name\");\n\n  TemplateName Name = ParsedName.get();\n  auto *ATN = Name.getAsAssumedTemplateName();\n  assert(ATN && \"not an assumed template name\");\n  II = ATN->getDeclName().getAsIdentifierInfo();\n\n  if (!resolveAssumedTemplateNameAsType(S, Name, NameLoc, /*Diagnose*/false)) {\n    // Resolved to a type template name.\n    ParsedName = TemplateTy::make(Name);\n    TNK = TNK_Type_template;\n  }\n}\n\nbool Sema::resolveAssumedTemplateNameAsType(Scope *S, TemplateName &Name,\n                                            SourceLocation NameLoc,\n                                            bool Diagnose) {\n  // We assumed this undeclared identifier to be an (ADL-only) function\n  // template name, but it was used in a context where a type was required.\n  // Try to typo-correct it now.\n  AssumedTemplateStorage *ATN = Name.getAsAssumedTemplateName();\n  assert(ATN && \"not an assumed template name\");\n\n  LookupResult R(*this, ATN->getDeclName(), NameLoc, LookupOrdinaryName);\n  struct CandidateCallback : CorrectionCandidateCallback {\n    bool ValidateCandidate(const TypoCorrection &TC) override {\n      return TC.getCorrectionDecl() &&\n             getAsTypeTemplateDecl(TC.getCorrectionDecl());\n    }\n    std::unique_ptr<CorrectionCandidateCallback> clone() override {\n      return std::make_unique<CandidateCallback>(*this);\n    }\n  } FilterCCC;\n\n  TypoCorrection Corrected =\n      CorrectTypo(R.getLookupNameInfo(), R.getLookupKind(), S, nullptr,\n                  FilterCCC, CTK_ErrorRecovery);\n  if (Corrected && Corrected.getFoundDecl()) {\n    diagnoseTypo(Corrected, PDiag(diag::err_no_template_suggest)\n                                << ATN->getDeclName());\n    Name = TemplateName(Corrected.getCorrectionDeclAs<TemplateDecl>());\n    return false;\n  }\n\n  if (Diagnose)\n    Diag(R.getNameLoc(), diag::err_no_template) << R.getLookupName();\n  return true;\n}\n\nTypeResult Sema::ActOnTemplateIdType(\n    Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,\n    TemplateTy TemplateD, IdentifierInfo *TemplateII,\n    SourceLocation TemplateIILoc, SourceLocation LAngleLoc,\n    ASTTemplateArgsPtr TemplateArgsIn, SourceLocation RAngleLoc,\n    bool IsCtorOrDtorName, bool IsClassName) {\n  if (SS.isInvalid())\n    return true;\n\n  if (!IsCtorOrDtorName && !IsClassName && SS.isSet()) {\n    DeclContext *LookupCtx = computeDeclContext(SS, /*EnteringContext*/false);\n\n    // C++ [temp.res]p3:\n    //   A qualified-id that refers to a type and in which the\n    //   nested-name-specifier depends on a template-parameter (14.6.2)\n    //   shall be prefixed by the keyword typename to indicate that the\n    //   qualified-id denotes a type, forming an\n    //   elaborated-type-specifier (7.1.5.3).\n    if (!LookupCtx && isDependentScopeSpecifier(SS)) {\n      Diag(SS.getBeginLoc(), diag::err_typename_missing_template)\n        << SS.getScopeRep() << TemplateII->getName();\n      // Recover as if 'typename' were specified.\n      // FIXME: This is not quite correct recovery as we don't transform SS\n      // into the corresponding dependent form (and we don't diagnose missing\n      // 'template' keywords within SS as a result).\n      return ActOnTypenameType(nullptr, SourceLocation(), SS, TemplateKWLoc,\n                               TemplateD, TemplateII, TemplateIILoc, LAngleLoc,\n                               TemplateArgsIn, RAngleLoc);\n    }\n\n    // Per C++ [class.qual]p2, if the template-id was an injected-class-name,\n    // it's not actually allowed to be used as a type in most cases. Because\n    // we annotate it before we know whether it's valid, we have to check for\n    // this case here.\n    auto *LookupRD = dyn_cast_or_null<CXXRecordDecl>(LookupCtx);\n    if (LookupRD && LookupRD->getIdentifier() == TemplateII) {\n      Diag(TemplateIILoc,\n           TemplateKWLoc.isInvalid()\n               ? diag::err_out_of_line_qualified_id_type_names_constructor\n               : diag::ext_out_of_line_qualified_id_type_names_constructor)\n        << TemplateII << 0 /*injected-class-name used as template name*/\n        << 1 /*if any keyword was present, it was 'template'*/;\n    }\n  }\n\n  TemplateName Template = TemplateD.get();\n  if (Template.getAsAssumedTemplateName() &&\n      resolveAssumedTemplateNameAsType(S, Template, TemplateIILoc))\n    return true;\n\n  // Translate the parser's template argument list in our AST format.\n  TemplateArgumentListInfo TemplateArgs(LAngleLoc, RAngleLoc);\n  translateTemplateArguments(TemplateArgsIn, TemplateArgs);\n\n  if (DependentTemplateName *DTN = Template.getAsDependentTemplateName()) {\n    QualType T\n      = Context.getDependentTemplateSpecializationType(ETK_None,\n                                                       DTN->getQualifier(),\n                                                       DTN->getIdentifier(),\n                                                       TemplateArgs);\n    // Build type-source information.\n    TypeLocBuilder TLB;\n    DependentTemplateSpecializationTypeLoc SpecTL\n      = TLB.push<DependentTemplateSpecializationTypeLoc>(T);\n    SpecTL.setElaboratedKeywordLoc(SourceLocation());\n    SpecTL.setQualifierLoc(SS.getWithLocInContext(Context));\n    SpecTL.setTemplateKeywordLoc(TemplateKWLoc);\n    SpecTL.setTemplateNameLoc(TemplateIILoc);\n    SpecTL.setLAngleLoc(LAngleLoc);\n    SpecTL.setRAngleLoc(RAngleLoc);\n    for (unsigned I = 0, N = SpecTL.getNumArgs(); I != N; ++I)\n      SpecTL.setArgLocInfo(I, TemplateArgs[I].getLocInfo());\n    return CreateParsedType(T, TLB.getTypeSourceInfo(Context, T));\n  }\n\n  QualType Result = CheckTemplateIdType(Template, TemplateIILoc, TemplateArgs);\n  if (Result.isNull())\n    return true;\n\n  // Build type-source information.\n  TypeLocBuilder TLB;\n  TemplateSpecializationTypeLoc SpecTL\n    = TLB.push<TemplateSpecializationTypeLoc>(Result);\n  SpecTL.setTemplateKeywordLoc(TemplateKWLoc);\n  SpecTL.setTemplateNameLoc(TemplateIILoc);\n  SpecTL.setLAngleLoc(LAngleLoc);\n  SpecTL.setRAngleLoc(RAngleLoc);\n  for (unsigned i = 0, e = SpecTL.getNumArgs(); i != e; ++i)\n    SpecTL.setArgLocInfo(i, TemplateArgs[i].getLocInfo());\n\n  // NOTE: avoid constructing an ElaboratedTypeLoc if this is a\n  // constructor or destructor name (in such a case, the scope specifier\n  // will be attached to the enclosing Decl or Expr node).\n  if (SS.isNotEmpty() && !IsCtorOrDtorName) {\n    // Create an elaborated-type-specifier containing the nested-name-specifier.\n    Result = Context.getElaboratedType(ETK_None, SS.getScopeRep(), Result);\n    ElaboratedTypeLoc ElabTL = TLB.push<ElaboratedTypeLoc>(Result);\n    ElabTL.setElaboratedKeywordLoc(SourceLocation());\n    ElabTL.setQualifierLoc(SS.getWithLocInContext(Context));\n  }\n\n  return CreateParsedType(Result, TLB.getTypeSourceInfo(Context, Result));\n}\n\nTypeResult Sema::ActOnTagTemplateIdType(TagUseKind TUK,\n                                        TypeSpecifierType TagSpec,\n                                        SourceLocation TagLoc,\n                                        CXXScopeSpec &SS,\n                                        SourceLocation TemplateKWLoc,\n                                        TemplateTy TemplateD,\n                                        SourceLocation TemplateLoc,\n                                        SourceLocation LAngleLoc,\n                                        ASTTemplateArgsPtr TemplateArgsIn,\n                                        SourceLocation RAngleLoc) {\n  if (SS.isInvalid())\n    return TypeResult(true);\n\n  TemplateName Template = TemplateD.get();\n\n  // Translate the parser's template argument list in our AST format.\n  TemplateArgumentListInfo TemplateArgs(LAngleLoc, RAngleLoc);\n  translateTemplateArguments(TemplateArgsIn, TemplateArgs);\n\n  // Determine the tag kind\n  TagTypeKind TagKind = TypeWithKeyword::getTagTypeKindForTypeSpec(TagSpec);\n  ElaboratedTypeKeyword Keyword\n    = TypeWithKeyword::getKeywordForTagTypeKind(TagKind);\n\n  if (DependentTemplateName *DTN = Template.getAsDependentTemplateName()) {\n    QualType T = Context.getDependentTemplateSpecializationType(Keyword,\n                                                          DTN->getQualifier(),\n                                                          DTN->getIdentifier(),\n                                                                TemplateArgs);\n\n    // Build type-source information.\n    TypeLocBuilder TLB;\n    DependentTemplateSpecializationTypeLoc SpecTL\n      = TLB.push<DependentTemplateSpecializationTypeLoc>(T);\n    SpecTL.setElaboratedKeywordLoc(TagLoc);\n    SpecTL.setQualifierLoc(SS.getWithLocInContext(Context));\n    SpecTL.setTemplateKeywordLoc(TemplateKWLoc);\n    SpecTL.setTemplateNameLoc(TemplateLoc);\n    SpecTL.setLAngleLoc(LAngleLoc);\n    SpecTL.setRAngleLoc(RAngleLoc);\n    for (unsigned I = 0, N = SpecTL.getNumArgs(); I != N; ++I)\n      SpecTL.setArgLocInfo(I, TemplateArgs[I].getLocInfo());\n    return CreateParsedType(T, TLB.getTypeSourceInfo(Context, T));\n  }\n\n  if (TypeAliasTemplateDecl *TAT =\n        dyn_cast_or_null<TypeAliasTemplateDecl>(Template.getAsTemplateDecl())) {\n    // C++0x [dcl.type.elab]p2:\n    //   If the identifier resolves to a typedef-name or the simple-template-id\n    //   resolves to an alias template specialization, the\n    //   elaborated-type-specifier is ill-formed.\n    Diag(TemplateLoc, diag::err_tag_reference_non_tag)\n        << TAT << NTK_TypeAliasTemplate << TagKind;\n    Diag(TAT->getLocation(), diag::note_declared_at);\n  }\n\n  QualType Result = CheckTemplateIdType(Template, TemplateLoc, TemplateArgs);\n  if (Result.isNull())\n    return TypeResult(true);\n\n  // Check the tag kind\n  if (const RecordType *RT = Result->getAs<RecordType>()) {\n    RecordDecl *D = RT->getDecl();\n\n    IdentifierInfo *Id = D->getIdentifier();\n    assert(Id && \"templated class must have an identifier\");\n\n    if (!isAcceptableTagRedeclaration(D, TagKind, TUK == TUK_Definition,\n                                      TagLoc, Id)) {\n      Diag(TagLoc, diag::err_use_with_wrong_tag)\n        << Result\n        << FixItHint::CreateReplacement(SourceRange(TagLoc), D->getKindName());\n      Diag(D->getLocation(), diag::note_previous_use);\n    }\n  }\n\n  // Provide source-location information for the template specialization.\n  TypeLocBuilder TLB;\n  TemplateSpecializationTypeLoc SpecTL\n    = TLB.push<TemplateSpecializationTypeLoc>(Result);\n  SpecTL.setTemplateKeywordLoc(TemplateKWLoc);\n  SpecTL.setTemplateNameLoc(TemplateLoc);\n  SpecTL.setLAngleLoc(LAngleLoc);\n  SpecTL.setRAngleLoc(RAngleLoc);\n  for (unsigned i = 0, e = SpecTL.getNumArgs(); i != e; ++i)\n    SpecTL.setArgLocInfo(i, TemplateArgs[i].getLocInfo());\n\n  // Construct an elaborated type containing the nested-name-specifier (if any)\n  // and tag keyword.\n  Result = Context.getElaboratedType(Keyword, SS.getScopeRep(), Result);\n  ElaboratedTypeLoc ElabTL = TLB.push<ElaboratedTypeLoc>(Result);\n  ElabTL.setElaboratedKeywordLoc(TagLoc);\n  ElabTL.setQualifierLoc(SS.getWithLocInContext(Context));\n  return CreateParsedType(Result, TLB.getTypeSourceInfo(Context, Result));\n}\n\nstatic bool CheckTemplateSpecializationScope(Sema &S, NamedDecl *Specialized,\n                                             NamedDecl *PrevDecl,\n                                             SourceLocation Loc,\n                                             bool IsPartialSpecialization);\n\nstatic TemplateSpecializationKind getTemplateSpecializationKind(Decl *D);\n\nstatic bool isTemplateArgumentTemplateParameter(\n    const TemplateArgument &Arg, unsigned Depth, unsigned Index) {\n  switch (Arg.getKind()) {\n  case TemplateArgument::Null:\n  case TemplateArgument::NullPtr:\n  case TemplateArgument::Integral:\n  case TemplateArgument::Declaration:\n  case TemplateArgument::Pack:\n  case TemplateArgument::TemplateExpansion:\n    return false;\n\n  case TemplateArgument::Type: {\n    QualType Type = Arg.getAsType();\n    const TemplateTypeParmType *TPT =\n        Arg.getAsType()->getAs<TemplateTypeParmType>();\n    return TPT && !Type.hasQualifiers() &&\n           TPT->getDepth() == Depth && TPT->getIndex() == Index;\n  }\n\n  case TemplateArgument::Expression: {\n    DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(Arg.getAsExpr());\n    if (!DRE || !DRE->getDecl())\n      return false;\n    const NonTypeTemplateParmDecl *NTTP =\n        dyn_cast<NonTypeTemplateParmDecl>(DRE->getDecl());\n    return NTTP && NTTP->getDepth() == Depth && NTTP->getIndex() == Index;\n  }\n\n  case TemplateArgument::Template:\n    const TemplateTemplateParmDecl *TTP =\n        dyn_cast_or_null<TemplateTemplateParmDecl>(\n            Arg.getAsTemplateOrTemplatePattern().getAsTemplateDecl());\n    return TTP && TTP->getDepth() == Depth && TTP->getIndex() == Index;\n  }\n  llvm_unreachable(\"unexpected kind of template argument\");\n}\n\nstatic bool isSameAsPrimaryTemplate(TemplateParameterList *Params,\n                                    ArrayRef<TemplateArgument> Args) {\n  if (Params->size() != Args.size())\n    return false;\n\n  unsigned Depth = Params->getDepth();\n\n  for (unsigned I = 0, N = Args.size(); I != N; ++I) {\n    TemplateArgument Arg = Args[I];\n\n    // If the parameter is a pack expansion, the argument must be a pack\n    // whose only element is a pack expansion.\n    if (Params->getParam(I)->isParameterPack()) {\n      if (Arg.getKind() != TemplateArgument::Pack || Arg.pack_size() != 1 ||\n          !Arg.pack_begin()->isPackExpansion())\n        return false;\n      Arg = Arg.pack_begin()->getPackExpansionPattern();\n    }\n\n    if (!isTemplateArgumentTemplateParameter(Arg, Depth, I))\n      return false;\n  }\n\n  return true;\n}\n\ntemplate<typename PartialSpecDecl>\nstatic void checkMoreSpecializedThanPrimary(Sema &S, PartialSpecDecl *Partial) {\n  if (Partial->getDeclContext()->isDependentContext())\n    return;\n\n  // FIXME: Get the TDK from deduction in order to provide better diagnostics\n  // for non-substitution-failure issues?\n  TemplateDeductionInfo Info(Partial->getLocation());\n  if (S.isMoreSpecializedThanPrimary(Partial, Info))\n    return;\n\n  auto *Template = Partial->getSpecializedTemplate();\n  S.Diag(Partial->getLocation(),\n         diag::ext_partial_spec_not_more_specialized_than_primary)\n      << isa<VarTemplateDecl>(Template);\n\n  if (Info.hasSFINAEDiagnostic()) {\n    PartialDiagnosticAt Diag = {SourceLocation(),\n                                PartialDiagnostic::NullDiagnostic()};\n    Info.takeSFINAEDiagnostic(Diag);\n    SmallString<128> SFINAEArgString;\n    Diag.second.EmitToString(S.getDiagnostics(), SFINAEArgString);\n    S.Diag(Diag.first,\n           diag::note_partial_spec_not_more_specialized_than_primary)\n      << SFINAEArgString;\n  }\n\n  S.Diag(Template->getLocation(), diag::note_template_decl_here);\n  SmallVector<const Expr *, 3> PartialAC, TemplateAC;\n  Template->getAssociatedConstraints(TemplateAC);\n  Partial->getAssociatedConstraints(PartialAC);\n  S.MaybeEmitAmbiguousAtomicConstraintsDiagnostic(Partial, PartialAC, Template,\n                                                  TemplateAC);\n}\n\nstatic void\nnoteNonDeducibleParameters(Sema &S, TemplateParameterList *TemplateParams,\n                           const llvm::SmallBitVector &DeducibleParams) {\n  for (unsigned I = 0, N = DeducibleParams.size(); I != N; ++I) {\n    if (!DeducibleParams[I]) {\n      NamedDecl *Param = TemplateParams->getParam(I);\n      if (Param->getDeclName())\n        S.Diag(Param->getLocation(), diag::note_non_deducible_parameter)\n            << Param->getDeclName();\n      else\n        S.Diag(Param->getLocation(), diag::note_non_deducible_parameter)\n            << \"(anonymous)\";\n    }\n  }\n}\n\n\ntemplate<typename PartialSpecDecl>\nstatic void checkTemplatePartialSpecialization(Sema &S,\n                                               PartialSpecDecl *Partial) {\n  // C++1z [temp.class.spec]p8: (DR1495)\n  //   - The specialization shall be more specialized than the primary\n  //     template (14.5.5.2).\n  checkMoreSpecializedThanPrimary(S, Partial);\n\n  // C++ [temp.class.spec]p8: (DR1315)\n  //   - Each template-parameter shall appear at least once in the\n  //     template-id outside a non-deduced context.\n  // C++1z [temp.class.spec.match]p3 (P0127R2)\n  //   If the template arguments of a partial specialization cannot be\n  //   deduced because of the structure of its template-parameter-list\n  //   and the template-id, the program is ill-formed.\n  auto *TemplateParams = Partial->getTemplateParameters();\n  llvm::SmallBitVector DeducibleParams(TemplateParams->size());\n  S.MarkUsedTemplateParameters(Partial->getTemplateArgs(), true,\n                               TemplateParams->getDepth(), DeducibleParams);\n\n  if (!DeducibleParams.all()) {\n    unsigned NumNonDeducible = DeducibleParams.size() - DeducibleParams.count();\n    S.Diag(Partial->getLocation(), diag::ext_partial_specs_not_deducible)\n      << isa<VarTemplatePartialSpecializationDecl>(Partial)\n      << (NumNonDeducible > 1)\n      << SourceRange(Partial->getLocation(),\n                     Partial->getTemplateArgsAsWritten()->RAngleLoc);\n    noteNonDeducibleParameters(S, TemplateParams, DeducibleParams);\n  }\n}\n\nvoid Sema::CheckTemplatePartialSpecialization(\n    ClassTemplatePartialSpecializationDecl *Partial) {\n  checkTemplatePartialSpecialization(*this, Partial);\n}\n\nvoid Sema::CheckTemplatePartialSpecialization(\n    VarTemplatePartialSpecializationDecl *Partial) {\n  checkTemplatePartialSpecialization(*this, Partial);\n}\n\nvoid Sema::CheckDeductionGuideTemplate(FunctionTemplateDecl *TD) {\n  // C++1z [temp.param]p11:\n  //   A template parameter of a deduction guide template that does not have a\n  //   default-argument shall be deducible from the parameter-type-list of the\n  //   deduction guide template.\n  auto *TemplateParams = TD->getTemplateParameters();\n  llvm::SmallBitVector DeducibleParams(TemplateParams->size());\n  MarkDeducedTemplateParameters(TD, DeducibleParams);\n  for (unsigned I = 0; I != TemplateParams->size(); ++I) {\n    // A parameter pack is deducible (to an empty pack).\n    auto *Param = TemplateParams->getParam(I);\n    if (Param->isParameterPack() || hasVisibleDefaultArgument(Param))\n      DeducibleParams[I] = true;\n  }\n\n  if (!DeducibleParams.all()) {\n    unsigned NumNonDeducible = DeducibleParams.size() - DeducibleParams.count();\n    Diag(TD->getLocation(), diag::err_deduction_guide_template_not_deducible)\n      << (NumNonDeducible > 1);\n    noteNonDeducibleParameters(*this, TemplateParams, DeducibleParams);\n  }\n}\n\nDeclResult Sema::ActOnVarTemplateSpecialization(\n    Scope *S, Declarator &D, TypeSourceInfo *DI, SourceLocation TemplateKWLoc,\n    TemplateParameterList *TemplateParams, StorageClass SC,\n    bool IsPartialSpecialization) {\n  // D must be variable template id.\n  assert(D.getName().getKind() == UnqualifiedIdKind::IK_TemplateId &&\n         \"Variable template specialization is declared with a template it.\");\n\n  TemplateIdAnnotation *TemplateId = D.getName().TemplateId;\n  TemplateArgumentListInfo TemplateArgs =\n      makeTemplateArgumentListInfo(*this, *TemplateId);\n  SourceLocation TemplateNameLoc = D.getIdentifierLoc();\n  SourceLocation LAngleLoc = TemplateId->LAngleLoc;\n  SourceLocation RAngleLoc = TemplateId->RAngleLoc;\n\n  TemplateName Name = TemplateId->Template.get();\n\n  // The template-id must name a variable template.\n  VarTemplateDecl *VarTemplate =\n      dyn_cast_or_null<VarTemplateDecl>(Name.getAsTemplateDecl());\n  if (!VarTemplate) {\n    NamedDecl *FnTemplate;\n    if (auto *OTS = Name.getAsOverloadedTemplate())\n      FnTemplate = *OTS->begin();\n    else\n      FnTemplate = dyn_cast_or_null<FunctionTemplateDecl>(Name.getAsTemplateDecl());\n    if (FnTemplate)\n      return Diag(D.getIdentifierLoc(), diag::err_var_spec_no_template_but_method)\n               << FnTemplate->getDeclName();\n    return Diag(D.getIdentifierLoc(), diag::err_var_spec_no_template)\n             << IsPartialSpecialization;\n  }\n\n  // Check for unexpanded parameter packs in any of the template arguments.\n  for (unsigned I = 0, N = TemplateArgs.size(); I != N; ++I)\n    if (DiagnoseUnexpandedParameterPack(TemplateArgs[I],\n                                        UPPC_PartialSpecialization))\n      return true;\n\n  // Check that the template argument list is well-formed for this\n  // template.\n  SmallVector<TemplateArgument, 4> Converted;\n  if (CheckTemplateArgumentList(VarTemplate, TemplateNameLoc, TemplateArgs,\n                                false, Converted,\n                                /*UpdateArgsWithConversion=*/true))\n    return true;\n\n  // Find the variable template (partial) specialization declaration that\n  // corresponds to these arguments.\n  if (IsPartialSpecialization) {\n    if (CheckTemplatePartialSpecializationArgs(TemplateNameLoc, VarTemplate,\n                                               TemplateArgs.size(), Converted))\n      return true;\n\n    // FIXME: Move these checks to CheckTemplatePartialSpecializationArgs so we\n    // also do them during instantiation.\n    if (!Name.isDependent() &&\n        !TemplateSpecializationType::anyDependentTemplateArguments(TemplateArgs,\n                                                                   Converted)) {\n      Diag(TemplateNameLoc, diag::err_partial_spec_fully_specialized)\n          << VarTemplate->getDeclName();\n      IsPartialSpecialization = false;\n    }\n\n    if (isSameAsPrimaryTemplate(VarTemplate->getTemplateParameters(),\n                                Converted) &&\n        (!Context.getLangOpts().CPlusPlus20 ||\n         !TemplateParams->hasAssociatedConstraints())) {\n      // C++ [temp.class.spec]p9b3:\n      //\n      //   -- The argument list of the specialization shall not be identical\n      //      to the implicit argument list of the primary template.\n      Diag(TemplateNameLoc, diag::err_partial_spec_args_match_primary_template)\n        << /*variable template*/ 1\n        << /*is definition*/(SC != SC_Extern && !CurContext->isRecord())\n        << FixItHint::CreateRemoval(SourceRange(LAngleLoc, RAngleLoc));\n      // FIXME: Recover from this by treating the declaration as a redeclaration\n      // of the primary template.\n      return true;\n    }\n  }\n\n  void *InsertPos = nullptr;\n  VarTemplateSpecializationDecl *PrevDecl = nullptr;\n\n  if (IsPartialSpecialization)\n    PrevDecl = VarTemplate->findPartialSpecialization(Converted, TemplateParams,\n                                                      InsertPos);\n  else\n    PrevDecl = VarTemplate->findSpecialization(Converted, InsertPos);\n\n  VarTemplateSpecializationDecl *Specialization = nullptr;\n\n  // Check whether we can declare a variable template specialization in\n  // the current scope.\n  if (CheckTemplateSpecializationScope(*this, VarTemplate, PrevDecl,\n                                       TemplateNameLoc,\n                                       IsPartialSpecialization))\n    return true;\n\n  if (PrevDecl && PrevDecl->getSpecializationKind() == TSK_Undeclared) {\n    // Since the only prior variable template specialization with these\n    // arguments was referenced but not declared,  reuse that\n    // declaration node as our own, updating its source location and\n    // the list of outer template parameters to reflect our new declaration.\n    Specialization = PrevDecl;\n    Specialization->setLocation(TemplateNameLoc);\n    PrevDecl = nullptr;\n  } else if (IsPartialSpecialization) {\n    // Create a new class template partial specialization declaration node.\n    VarTemplatePartialSpecializationDecl *PrevPartial =\n        cast_or_null<VarTemplatePartialSpecializationDecl>(PrevDecl);\n    VarTemplatePartialSpecializationDecl *Partial =\n        VarTemplatePartialSpecializationDecl::Create(\n            Context, VarTemplate->getDeclContext(), TemplateKWLoc,\n            TemplateNameLoc, TemplateParams, VarTemplate, DI->getType(), DI, SC,\n            Converted, TemplateArgs);\n\n    if (!PrevPartial)\n      VarTemplate->AddPartialSpecialization(Partial, InsertPos);\n    Specialization = Partial;\n\n    // If we are providing an explicit specialization of a member variable\n    // template specialization, make a note of that.\n    if (PrevPartial && PrevPartial->getInstantiatedFromMember())\n      PrevPartial->setMemberSpecialization();\n\n    CheckTemplatePartialSpecialization(Partial);\n  } else {\n    // Create a new class template specialization declaration node for\n    // this explicit specialization or friend declaration.\n    Specialization = VarTemplateSpecializationDecl::Create(\n        Context, VarTemplate->getDeclContext(), TemplateKWLoc, TemplateNameLoc,\n        VarTemplate, DI->getType(), DI, SC, Converted);\n    Specialization->setTemplateArgsInfo(TemplateArgs);\n\n    if (!PrevDecl)\n      VarTemplate->AddSpecialization(Specialization, InsertPos);\n  }\n\n  // C++ [temp.expl.spec]p6:\n  //   If a template, a member template or the member of a class template is\n  //   explicitly specialized then that specialization shall be declared\n  //   before the first use of that specialization that would cause an implicit\n  //   instantiation to take place, in every translation unit in which such a\n  //   use occurs; no diagnostic is required.\n  if (PrevDecl && PrevDecl->getPointOfInstantiation().isValid()) {\n    bool Okay = false;\n    for (Decl *Prev = PrevDecl; Prev; Prev = Prev->getPreviousDecl()) {\n      // Is there any previous explicit specialization declaration?\n      if (getTemplateSpecializationKind(Prev) == TSK_ExplicitSpecialization) {\n        Okay = true;\n        break;\n      }\n    }\n\n    if (!Okay) {\n      SourceRange Range(TemplateNameLoc, RAngleLoc);\n      Diag(TemplateNameLoc, diag::err_specialization_after_instantiation)\n          << Name << Range;\n\n      Diag(PrevDecl->getPointOfInstantiation(),\n           diag::note_instantiation_required_here)\n          << (PrevDecl->getTemplateSpecializationKind() !=\n              TSK_ImplicitInstantiation);\n      return true;\n    }\n  }\n\n  Specialization->setTemplateKeywordLoc(TemplateKWLoc);\n  Specialization->setLexicalDeclContext(CurContext);\n\n  // Add the specialization into its lexical context, so that it can\n  // be seen when iterating through the list of declarations in that\n  // context. However, specializations are not found by name lookup.\n  CurContext->addDecl(Specialization);\n\n  // Note that this is an explicit specialization.\n  Specialization->setSpecializationKind(TSK_ExplicitSpecialization);\n\n  if (PrevDecl) {\n    // Check that this isn't a redefinition of this specialization,\n    // merging with previous declarations.\n    LookupResult PrevSpec(*this, GetNameForDeclarator(D), LookupOrdinaryName,\n                          forRedeclarationInCurContext());\n    PrevSpec.addDecl(PrevDecl);\n    D.setRedeclaration(CheckVariableDeclaration(Specialization, PrevSpec));\n  } else if (Specialization->isStaticDataMember() &&\n             Specialization->isOutOfLine()) {\n    Specialization->setAccess(VarTemplate->getAccess());\n  }\n\n  return Specialization;\n}\n\nnamespace {\n/// A partial specialization whose template arguments have matched\n/// a given template-id.\nstruct PartialSpecMatchResult {\n  VarTemplatePartialSpecializationDecl *Partial;\n  TemplateArgumentList *Args;\n};\n} // end anonymous namespace\n\nDeclResult\nSema::CheckVarTemplateId(VarTemplateDecl *Template, SourceLocation TemplateLoc,\n                         SourceLocation TemplateNameLoc,\n                         const TemplateArgumentListInfo &TemplateArgs) {\n  assert(Template && \"A variable template id without template?\");\n\n  // Check that the template argument list is well-formed for this template.\n  SmallVector<TemplateArgument, 4> Converted;\n  if (CheckTemplateArgumentList(\n          Template, TemplateNameLoc,\n          const_cast<TemplateArgumentListInfo &>(TemplateArgs), false,\n          Converted, /*UpdateArgsWithConversion=*/true))\n    return true;\n\n  // Produce a placeholder value if the specialization is dependent.\n  if (Template->getDeclContext()->isDependentContext() ||\n      TemplateSpecializationType::anyDependentTemplateArguments(TemplateArgs,\n                                                                Converted))\n    return DeclResult();\n\n  // Find the variable template specialization declaration that\n  // corresponds to these arguments.\n  void *InsertPos = nullptr;\n  if (VarTemplateSpecializationDecl *Spec = Template->findSpecialization(\n          Converted, InsertPos)) {\n    checkSpecializationVisibility(TemplateNameLoc, Spec);\n    // If we already have a variable template specialization, return it.\n    return Spec;\n  }\n\n  // This is the first time we have referenced this variable template\n  // specialization. Create the canonical declaration and add it to\n  // the set of specializations, based on the closest partial specialization\n  // that it represents. That is,\n  VarDecl *InstantiationPattern = Template->getTemplatedDecl();\n  TemplateArgumentList TemplateArgList(TemplateArgumentList::OnStack,\n                                       Converted);\n  TemplateArgumentList *InstantiationArgs = &TemplateArgList;\n  bool AmbiguousPartialSpec = false;\n  typedef PartialSpecMatchResult MatchResult;\n  SmallVector<MatchResult, 4> Matched;\n  SourceLocation PointOfInstantiation = TemplateNameLoc;\n  TemplateSpecCandidateSet FailedCandidates(PointOfInstantiation,\n                                            /*ForTakingAddress=*/false);\n\n  // 1. Attempt to find the closest partial specialization that this\n  // specializes, if any.\n  // TODO: Unify with InstantiateClassTemplateSpecialization()?\n  //       Perhaps better after unification of DeduceTemplateArguments() and\n  //       getMoreSpecializedPartialSpecialization().\n  SmallVector<VarTemplatePartialSpecializationDecl *, 4> PartialSpecs;\n  Template->getPartialSpecializations(PartialSpecs);\n\n  for (unsigned I = 0, N = PartialSpecs.size(); I != N; ++I) {\n    VarTemplatePartialSpecializationDecl *Partial = PartialSpecs[I];\n    TemplateDeductionInfo Info(FailedCandidates.getLocation());\n\n    if (TemplateDeductionResult Result =\n            DeduceTemplateArguments(Partial, TemplateArgList, Info)) {\n      // Store the failed-deduction information for use in diagnostics, later.\n      // TODO: Actually use the failed-deduction info?\n      FailedCandidates.addCandidate().set(\n          DeclAccessPair::make(Template, AS_public), Partial,\n          MakeDeductionFailureInfo(Context, Result, Info));\n      (void)Result;\n    } else {\n      Matched.push_back(PartialSpecMatchResult());\n      Matched.back().Partial = Partial;\n      Matched.back().Args = Info.take();\n    }\n  }\n\n  if (Matched.size() >= 1) {\n    SmallVector<MatchResult, 4>::iterator Best = Matched.begin();\n    if (Matched.size() == 1) {\n      //   -- If exactly one matching specialization is found, the\n      //      instantiation is generated from that specialization.\n      // We don't need to do anything for this.\n    } else {\n      //   -- If more than one matching specialization is found, the\n      //      partial order rules (14.5.4.2) are used to determine\n      //      whether one of the specializations is more specialized\n      //      than the others. If none of the specializations is more\n      //      specialized than all of the other matching\n      //      specializations, then the use of the variable template is\n      //      ambiguous and the program is ill-formed.\n      for (SmallVector<MatchResult, 4>::iterator P = Best + 1,\n                                                 PEnd = Matched.end();\n           P != PEnd; ++P) {\n        if (getMoreSpecializedPartialSpecialization(P->Partial, Best->Partial,\n                                                    PointOfInstantiation) ==\n            P->Partial)\n          Best = P;\n      }\n\n      // Determine if the best partial specialization is more specialized than\n      // the others.\n      for (SmallVector<MatchResult, 4>::iterator P = Matched.begin(),\n                                                 PEnd = Matched.end();\n           P != PEnd; ++P) {\n        if (P != Best && getMoreSpecializedPartialSpecialization(\n                             P->Partial, Best->Partial,\n                             PointOfInstantiation) != Best->Partial) {\n          AmbiguousPartialSpec = true;\n          break;\n        }\n      }\n    }\n\n    // Instantiate using the best variable template partial specialization.\n    InstantiationPattern = Best->Partial;\n    InstantiationArgs = Best->Args;\n  } else {\n    //   -- If no match is found, the instantiation is generated\n    //      from the primary template.\n    // InstantiationPattern = Template->getTemplatedDecl();\n  }\n\n  // 2. Create the canonical declaration.\n  // Note that we do not instantiate a definition until we see an odr-use\n  // in DoMarkVarDeclReferenced().\n  // FIXME: LateAttrs et al.?\n  VarTemplateSpecializationDecl *Decl = BuildVarTemplateInstantiation(\n      Template, InstantiationPattern, *InstantiationArgs, TemplateArgs,\n      Converted, TemplateNameLoc /*, LateAttrs, StartingScope*/);\n  if (!Decl)\n    return true;\n\n  if (AmbiguousPartialSpec) {\n    // Partial ordering did not produce a clear winner. Complain.\n    Decl->setInvalidDecl();\n    Diag(PointOfInstantiation, diag::err_partial_spec_ordering_ambiguous)\n        << Decl;\n\n    // Print the matching partial specializations.\n    for (MatchResult P : Matched)\n      Diag(P.Partial->getLocation(), diag::note_partial_spec_match)\n          << getTemplateArgumentBindingsText(P.Partial->getTemplateParameters(),\n                                             *P.Args);\n    return true;\n  }\n\n  if (VarTemplatePartialSpecializationDecl *D =\n          dyn_cast<VarTemplatePartialSpecializationDecl>(InstantiationPattern))\n    Decl->setInstantiationOf(D, InstantiationArgs);\n\n  checkSpecializationVisibility(TemplateNameLoc, Decl);\n\n  assert(Decl && \"No variable template specialization?\");\n  return Decl;\n}\n\nExprResult\nSema::CheckVarTemplateId(const CXXScopeSpec &SS,\n                         const DeclarationNameInfo &NameInfo,\n                         VarTemplateDecl *Template, SourceLocation TemplateLoc,\n                         const TemplateArgumentListInfo *TemplateArgs) {\n\n  DeclResult Decl = CheckVarTemplateId(Template, TemplateLoc, NameInfo.getLoc(),\n                                       *TemplateArgs);\n  if (Decl.isInvalid())\n    return ExprError();\n\n  if (!Decl.get())\n    return ExprResult();\n\n  VarDecl *Var = cast<VarDecl>(Decl.get());\n  if (!Var->getTemplateSpecializationKind())\n    Var->setTemplateSpecializationKind(TSK_ImplicitInstantiation,\n                                       NameInfo.getLoc());\n\n  // Build an ordinary singleton decl ref.\n  return BuildDeclarationNameExpr(SS, NameInfo, Var,\n                                  /*FoundD=*/nullptr, TemplateArgs);\n}\n\nvoid Sema::diagnoseMissingTemplateArguments(TemplateName Name,\n                                            SourceLocation Loc) {\n  Diag(Loc, diag::err_template_missing_args)\n    << (int)getTemplateNameKindForDiagnostics(Name) << Name;\n  if (TemplateDecl *TD = Name.getAsTemplateDecl()) {\n    Diag(TD->getLocation(), diag::note_template_decl_here)\n      << TD->getTemplateParameters()->getSourceRange();\n  }\n}\n\nExprResult\nSema::CheckConceptTemplateId(const CXXScopeSpec &SS,\n                             SourceLocation TemplateKWLoc,\n                             const DeclarationNameInfo &ConceptNameInfo,\n                             NamedDecl *FoundDecl,\n                             ConceptDecl *NamedConcept,\n                             const TemplateArgumentListInfo *TemplateArgs) {\n  assert(NamedConcept && \"A concept template id without a template?\");\n\n  llvm::SmallVector<TemplateArgument, 4> Converted;\n  if (CheckTemplateArgumentList(NamedConcept, ConceptNameInfo.getLoc(),\n                           const_cast<TemplateArgumentListInfo&>(*TemplateArgs),\n                                /*PartialTemplateArgs=*/false, Converted,\n                                /*UpdateArgsWithConversion=*/false))\n    return ExprError();\n\n  ConstraintSatisfaction Satisfaction;\n  bool AreArgsDependent =\n      TemplateSpecializationType::anyDependentTemplateArguments(*TemplateArgs,\n                                                                Converted);\n  if (!AreArgsDependent &&\n      CheckConstraintSatisfaction(\n          NamedConcept, {NamedConcept->getConstraintExpr()}, Converted,\n          SourceRange(SS.isSet() ? SS.getBeginLoc() : ConceptNameInfo.getLoc(),\n                      TemplateArgs->getRAngleLoc()),\n          Satisfaction))\n    return ExprError();\n\n  return ConceptSpecializationExpr::Create(Context,\n      SS.isSet() ? SS.getWithLocInContext(Context) : NestedNameSpecifierLoc{},\n      TemplateKWLoc, ConceptNameInfo, FoundDecl, NamedConcept,\n      ASTTemplateArgumentListInfo::Create(Context, *TemplateArgs), Converted,\n      AreArgsDependent ? nullptr : &Satisfaction);\n}\n\nExprResult Sema::BuildTemplateIdExpr(const CXXScopeSpec &SS,\n                                     SourceLocation TemplateKWLoc,\n                                     LookupResult &R,\n                                     bool RequiresADL,\n                                 const TemplateArgumentListInfo *TemplateArgs) {\n  // FIXME: Can we do any checking at this point? I guess we could check the\n  // template arguments that we have against the template name, if the template\n  // name refers to a single template. That's not a terribly common case,\n  // though.\n  // foo<int> could identify a single function unambiguously\n  // This approach does NOT work, since f<int>(1);\n  // gets resolved prior to resorting to overload resolution\n  // i.e., template<class T> void f(double);\n  //       vs template<class T, class U> void f(U);\n\n  // These should be filtered out by our callers.\n  assert(!R.isAmbiguous() && \"ambiguous lookup when building templateid\");\n\n  // Non-function templates require a template argument list.\n  if (auto *TD = R.getAsSingle<TemplateDecl>()) {\n    if (!TemplateArgs && !isa<FunctionTemplateDecl>(TD)) {\n      diagnoseMissingTemplateArguments(TemplateName(TD), R.getNameLoc());\n      return ExprError();\n    }\n  }\n\n  // In C++1y, check variable template ids.\n  if (R.getAsSingle<VarTemplateDecl>()) {\n    ExprResult Res = CheckVarTemplateId(SS, R.getLookupNameInfo(),\n                                        R.getAsSingle<VarTemplateDecl>(),\n                                        TemplateKWLoc, TemplateArgs);\n    if (Res.isInvalid() || Res.isUsable())\n      return Res;\n    // Result is dependent. Carry on to build an UnresolvedLookupEpxr.\n  }\n\n  if (R.getAsSingle<ConceptDecl>()) {\n    return CheckConceptTemplateId(SS, TemplateKWLoc, R.getLookupNameInfo(),\n                                  R.getFoundDecl(),\n                                  R.getAsSingle<ConceptDecl>(), TemplateArgs);\n  }\n\n  // We don't want lookup warnings at this point.\n  R.suppressDiagnostics();\n\n  UnresolvedLookupExpr *ULE\n    = UnresolvedLookupExpr::Create(Context, R.getNamingClass(),\n                                   SS.getWithLocInContext(Context),\n                                   TemplateKWLoc,\n                                   R.getLookupNameInfo(),\n                                   RequiresADL, TemplateArgs,\n                                   R.begin(), R.end());\n\n  return ULE;\n}\n\n// We actually only call this from template instantiation.\nExprResult\nSema::BuildQualifiedTemplateIdExpr(CXXScopeSpec &SS,\n                                   SourceLocation TemplateKWLoc,\n                                   const DeclarationNameInfo &NameInfo,\n                             const TemplateArgumentListInfo *TemplateArgs) {\n\n  assert(TemplateArgs || TemplateKWLoc.isValid());\n  DeclContext *DC;\n  if (!(DC = computeDeclContext(SS, false)) ||\n      DC->isDependentContext() ||\n      RequireCompleteDeclContext(SS, DC))\n    return BuildDependentDeclRefExpr(SS, TemplateKWLoc, NameInfo, TemplateArgs);\n\n  bool MemberOfUnknownSpecialization;\n  LookupResult R(*this, NameInfo, LookupOrdinaryName);\n  if (LookupTemplateName(R, (Scope *)nullptr, SS, QualType(),\n                         /*Entering*/false, MemberOfUnknownSpecialization,\n                         TemplateKWLoc))\n    return ExprError();\n\n  if (R.isAmbiguous())\n    return ExprError();\n\n  if (R.empty()) {\n    Diag(NameInfo.getLoc(), diag::err_no_member)\n      << NameInfo.getName() << DC << SS.getRange();\n    return ExprError();\n  }\n\n  if (ClassTemplateDecl *Temp = R.getAsSingle<ClassTemplateDecl>()) {\n    Diag(NameInfo.getLoc(), diag::err_template_kw_refers_to_class_template)\n      << SS.getScopeRep()\n      << NameInfo.getName().getAsString() << SS.getRange();\n    Diag(Temp->getLocation(), diag::note_referenced_class_template);\n    return ExprError();\n  }\n\n  return BuildTemplateIdExpr(SS, TemplateKWLoc, R, /*ADL*/ false, TemplateArgs);\n}\n\n/// Form a template name from a name that is syntactically required to name a\n/// template, either due to use of the 'template' keyword or because a name in\n/// this syntactic context is assumed to name a template (C++ [temp.names]p2-4).\n///\n/// This action forms a template name given the name of the template and its\n/// optional scope specifier. This is used when the 'template' keyword is used\n/// or when the parsing context unambiguously treats a following '<' as\n/// introducing a template argument list. Note that this may produce a\n/// non-dependent template name if we can perform the lookup now and identify\n/// the named template.\n///\n/// For example, given \"x.MetaFun::template apply\", the scope specifier\n/// \\p SS will be \"MetaFun::\", \\p TemplateKWLoc contains the location\n/// of the \"template\" keyword, and \"apply\" is the \\p Name.\nTemplateNameKind Sema::ActOnTemplateName(Scope *S,\n                                         CXXScopeSpec &SS,\n                                         SourceLocation TemplateKWLoc,\n                                         const UnqualifiedId &Name,\n                                         ParsedType ObjectType,\n                                         bool EnteringContext,\n                                         TemplateTy &Result,\n                                         bool AllowInjectedClassName) {\n  if (TemplateKWLoc.isValid() && S && !S->getTemplateParamParent())\n    Diag(TemplateKWLoc,\n         getLangOpts().CPlusPlus11 ?\n           diag::warn_cxx98_compat_template_outside_of_template :\n           diag::ext_template_outside_of_template)\n      << FixItHint::CreateRemoval(TemplateKWLoc);\n\n  if (SS.isInvalid())\n    return TNK_Non_template;\n\n  // Figure out where isTemplateName is going to look.\n  DeclContext *LookupCtx = nullptr;\n  if (SS.isNotEmpty())\n    LookupCtx = computeDeclContext(SS, EnteringContext);\n  else if (ObjectType)\n    LookupCtx = computeDeclContext(GetTypeFromParser(ObjectType));\n\n  // C++0x [temp.names]p5:\n  //   If a name prefixed by the keyword template is not the name of\n  //   a template, the program is ill-formed. [Note: the keyword\n  //   template may not be applied to non-template members of class\n  //   templates. -end note ] [ Note: as is the case with the\n  //   typename prefix, the template prefix is allowed in cases\n  //   where it is not strictly necessary; i.e., when the\n  //   nested-name-specifier or the expression on the left of the ->\n  //   or . is not dependent on a template-parameter, or the use\n  //   does not appear in the scope of a template. -end note]\n  //\n  // Note: C++03 was more strict here, because it banned the use of\n  // the \"template\" keyword prior to a template-name that was not a\n  // dependent name. C++ DR468 relaxed this requirement (the\n  // \"template\" keyword is now permitted). We follow the C++0x\n  // rules, even in C++03 mode with a warning, retroactively applying the DR.\n  bool MemberOfUnknownSpecialization;\n  TemplateNameKind TNK = isTemplateName(S, SS, TemplateKWLoc.isValid(), Name,\n                                        ObjectType, EnteringContext, Result,\n                                        MemberOfUnknownSpecialization);\n  if (TNK != TNK_Non_template) {\n    // We resolved this to a (non-dependent) template name. Return it.\n    auto *LookupRD = dyn_cast_or_null<CXXRecordDecl>(LookupCtx);\n    if (!AllowInjectedClassName && SS.isNotEmpty() && LookupRD &&\n        Name.getKind() == UnqualifiedIdKind::IK_Identifier &&\n        Name.Identifier && LookupRD->getIdentifier() == Name.Identifier) {\n      // C++14 [class.qual]p2:\n      //   In a lookup in which function names are not ignored and the\n      //   nested-name-specifier nominates a class C, if the name specified\n      //   [...] is the injected-class-name of C, [...] the name is instead\n      //   considered to name the constructor\n      //\n      // We don't get here if naming the constructor would be valid, so we\n      // just reject immediately and recover by treating the\n      // injected-class-name as naming the template.\n      Diag(Name.getBeginLoc(),\n           diag::ext_out_of_line_qualified_id_type_names_constructor)\n          << Name.Identifier\n          << 0 /*injected-class-name used as template name*/\n          << TemplateKWLoc.isValid();\n    }\n    return TNK;\n  }\n\n  if (!MemberOfUnknownSpecialization) {\n    // Didn't find a template name, and the lookup wasn't dependent.\n    // Do the lookup again to determine if this is a \"nothing found\" case or\n    // a \"not a template\" case. FIXME: Refactor isTemplateName so we don't\n    // need to do this.\n    DeclarationNameInfo DNI = GetNameFromUnqualifiedId(Name);\n    LookupResult R(*this, DNI.getName(), Name.getBeginLoc(),\n                   LookupOrdinaryName);\n    bool MOUS;\n    // Tell LookupTemplateName that we require a template so that it diagnoses\n    // cases where it finds a non-template.\n    RequiredTemplateKind RTK = TemplateKWLoc.isValid()\n                                   ? RequiredTemplateKind(TemplateKWLoc)\n                                   : TemplateNameIsRequired;\n    if (!LookupTemplateName(R, S, SS, ObjectType.get(), EnteringContext, MOUS,\n                            RTK, nullptr, /*AllowTypoCorrection=*/false) &&\n        !R.isAmbiguous()) {\n      if (LookupCtx)\n        Diag(Name.getBeginLoc(), diag::err_no_member)\n            << DNI.getName() << LookupCtx << SS.getRange();\n      else\n        Diag(Name.getBeginLoc(), diag::err_undeclared_use)\n            << DNI.getName() << SS.getRange();\n    }\n    return TNK_Non_template;\n  }\n\n  NestedNameSpecifier *Qualifier = SS.getScopeRep();\n\n  switch (Name.getKind()) {\n  case UnqualifiedIdKind::IK_Identifier:\n    Result = TemplateTy::make(\n        Context.getDependentTemplateName(Qualifier, Name.Identifier));\n    return TNK_Dependent_template_name;\n\n  case UnqualifiedIdKind::IK_OperatorFunctionId:\n    Result = TemplateTy::make(Context.getDependentTemplateName(\n        Qualifier, Name.OperatorFunctionId.Operator));\n    return TNK_Function_template;\n\n  case UnqualifiedIdKind::IK_LiteralOperatorId:\n    // This is a kind of template name, but can never occur in a dependent\n    // scope (literal operators can only be declared at namespace scope).\n    break;\n\n  default:\n    break;\n  }\n\n  // This name cannot possibly name a dependent template. Diagnose this now\n  // rather than building a dependent template name that can never be valid.\n  Diag(Name.getBeginLoc(),\n       diag::err_template_kw_refers_to_dependent_non_template)\n      << GetNameFromUnqualifiedId(Name).getName() << Name.getSourceRange()\n      << TemplateKWLoc.isValid() << TemplateKWLoc;\n  return TNK_Non_template;\n}\n\nbool Sema::CheckTemplateTypeArgument(TemplateTypeParmDecl *Param,\n                                     TemplateArgumentLoc &AL,\n                          SmallVectorImpl<TemplateArgument> &Converted) {\n  const TemplateArgument &Arg = AL.getArgument();\n  QualType ArgType;\n  TypeSourceInfo *TSI = nullptr;\n\n  // Check template type parameter.\n  switch(Arg.getKind()) {\n  case TemplateArgument::Type:\n    // C++ [temp.arg.type]p1:\n    //   A template-argument for a template-parameter which is a\n    //   type shall be a type-id.\n    ArgType = Arg.getAsType();\n    TSI = AL.getTypeSourceInfo();\n    break;\n  case TemplateArgument::Template:\n  case TemplateArgument::TemplateExpansion: {\n    // We have a template type parameter but the template argument\n    // is a template without any arguments.\n    SourceRange SR = AL.getSourceRange();\n    TemplateName Name = Arg.getAsTemplateOrTemplatePattern();\n    diagnoseMissingTemplateArguments(Name, SR.getEnd());\n    return true;\n  }\n  case TemplateArgument::Expression: {\n    // We have a template type parameter but the template argument is an\n    // expression; see if maybe it is missing the \"typename\" keyword.\n    CXXScopeSpec SS;\n    DeclarationNameInfo NameInfo;\n\n   if (DependentScopeDeclRefExpr *ArgExpr =\n               dyn_cast<DependentScopeDeclRefExpr>(Arg.getAsExpr())) {\n      SS.Adopt(ArgExpr->getQualifierLoc());\n      NameInfo = ArgExpr->getNameInfo();\n    } else if (CXXDependentScopeMemberExpr *ArgExpr =\n               dyn_cast<CXXDependentScopeMemberExpr>(Arg.getAsExpr())) {\n      if (ArgExpr->isImplicitAccess()) {\n        SS.Adopt(ArgExpr->getQualifierLoc());\n        NameInfo = ArgExpr->getMemberNameInfo();\n      }\n    }\n\n    if (auto *II = NameInfo.getName().getAsIdentifierInfo()) {\n      LookupResult Result(*this, NameInfo, LookupOrdinaryName);\n      LookupParsedName(Result, CurScope, &SS);\n\n      if (Result.getAsSingle<TypeDecl>() ||\n          Result.getResultKind() ==\n              LookupResult::NotFoundInCurrentInstantiation) {\n        assert(SS.getScopeRep() && \"dependent scope expr must has a scope!\");\n        // Suggest that the user add 'typename' before the NNS.\n        SourceLocation Loc = AL.getSourceRange().getBegin();\n        Diag(Loc, getLangOpts().MSVCCompat\n                      ? diag::ext_ms_template_type_arg_missing_typename\n                      : diag::err_template_arg_must_be_type_suggest)\n            << FixItHint::CreateInsertion(Loc, \"typename \");\n        Diag(Param->getLocation(), diag::note_template_param_here);\n\n        // Recover by synthesizing a type using the location information that we\n        // already have.\n        ArgType =\n            Context.getDependentNameType(ETK_Typename, SS.getScopeRep(), II);\n        TypeLocBuilder TLB;\n        DependentNameTypeLoc TL = TLB.push<DependentNameTypeLoc>(ArgType);\n        TL.setElaboratedKeywordLoc(SourceLocation(/*synthesized*/));\n        TL.setQualifierLoc(SS.getWithLocInContext(Context));\n        TL.setNameLoc(NameInfo.getLoc());\n        TSI = TLB.getTypeSourceInfo(Context, ArgType);\n\n        // Overwrite our input TemplateArgumentLoc so that we can recover\n        // properly.\n        AL = TemplateArgumentLoc(TemplateArgument(ArgType),\n                                 TemplateArgumentLocInfo(TSI));\n\n        break;\n      }\n    }\n    // fallthrough\n    LLVM_FALLTHROUGH;\n  }\n  default: {\n    // We have a template type parameter but the template argument\n    // is not a type.\n    SourceRange SR = AL.getSourceRange();\n    Diag(SR.getBegin(), diag::err_template_arg_must_be_type) << SR;\n    Diag(Param->getLocation(), diag::note_template_param_here);\n\n    return true;\n  }\n  }\n\n  if (CheckTemplateArgument(Param, TSI))\n    return true;\n\n  // Add the converted template type argument.\n  ArgType = Context.getCanonicalType(ArgType);\n\n  // Objective-C ARC:\n  //   If an explicitly-specified template argument type is a lifetime type\n  //   with no lifetime qualifier, the __strong lifetime qualifier is inferred.\n  if (getLangOpts().ObjCAutoRefCount &&\n      ArgType->isObjCLifetimeType() &&\n      !ArgType.getObjCLifetime()) {\n    Qualifiers Qs;\n    Qs.setObjCLifetime(Qualifiers::OCL_Strong);\n    ArgType = Context.getQualifiedType(ArgType, Qs);\n  }\n\n  Converted.push_back(TemplateArgument(ArgType));\n  return false;\n}\n\n/// Substitute template arguments into the default template argument for\n/// the given template type parameter.\n///\n/// \\param SemaRef the semantic analysis object for which we are performing\n/// the substitution.\n///\n/// \\param Template the template that we are synthesizing template arguments\n/// for.\n///\n/// \\param TemplateLoc the location of the template name that started the\n/// template-id we are checking.\n///\n/// \\param RAngleLoc the location of the right angle bracket ('>') that\n/// terminates the template-id.\n///\n/// \\param Param the template template parameter whose default we are\n/// substituting into.\n///\n/// \\param Converted the list of template arguments provided for template\n/// parameters that precede \\p Param in the template parameter list.\n/// \\returns the substituted template argument, or NULL if an error occurred.\nstatic TypeSourceInfo *\nSubstDefaultTemplateArgument(Sema &SemaRef,\n                             TemplateDecl *Template,\n                             SourceLocation TemplateLoc,\n                             SourceLocation RAngleLoc,\n                             TemplateTypeParmDecl *Param,\n                             SmallVectorImpl<TemplateArgument> &Converted) {\n  TypeSourceInfo *ArgType = Param->getDefaultArgumentInfo();\n\n  // If the argument type is dependent, instantiate it now based\n  // on the previously-computed template arguments.\n  if (ArgType->getType()->isInstantiationDependentType()) {\n    Sema::InstantiatingTemplate Inst(SemaRef, TemplateLoc,\n                                     Param, Template, Converted,\n                                     SourceRange(TemplateLoc, RAngleLoc));\n    if (Inst.isInvalid())\n      return nullptr;\n\n    TemplateArgumentList TemplateArgs(TemplateArgumentList::OnStack, Converted);\n\n    // Only substitute for the innermost template argument list.\n    MultiLevelTemplateArgumentList TemplateArgLists;\n    TemplateArgLists.addOuterTemplateArguments(&TemplateArgs);\n    for (unsigned i = 0, e = Param->getDepth(); i != e; ++i)\n      TemplateArgLists.addOuterTemplateArguments(None);\n\n    Sema::ContextRAII SavedContext(SemaRef, Template->getDeclContext());\n    ArgType =\n        SemaRef.SubstType(ArgType, TemplateArgLists,\n                          Param->getDefaultArgumentLoc(), Param->getDeclName());\n  }\n\n  return ArgType;\n}\n\n/// Substitute template arguments into the default template argument for\n/// the given non-type template parameter.\n///\n/// \\param SemaRef the semantic analysis object for which we are performing\n/// the substitution.\n///\n/// \\param Template the template that we are synthesizing template arguments\n/// for.\n///\n/// \\param TemplateLoc the location of the template name that started the\n/// template-id we are checking.\n///\n/// \\param RAngleLoc the location of the right angle bracket ('>') that\n/// terminates the template-id.\n///\n/// \\param Param the non-type template parameter whose default we are\n/// substituting into.\n///\n/// \\param Converted the list of template arguments provided for template\n/// parameters that precede \\p Param in the template parameter list.\n///\n/// \\returns the substituted template argument, or NULL if an error occurred.\nstatic ExprResult\nSubstDefaultTemplateArgument(Sema &SemaRef,\n                             TemplateDecl *Template,\n                             SourceLocation TemplateLoc,\n                             SourceLocation RAngleLoc,\n                             NonTypeTemplateParmDecl *Param,\n                        SmallVectorImpl<TemplateArgument> &Converted) {\n  Sema::InstantiatingTemplate Inst(SemaRef, TemplateLoc,\n                                   Param, Template, Converted,\n                                   SourceRange(TemplateLoc, RAngleLoc));\n  if (Inst.isInvalid())\n    return ExprError();\n\n  TemplateArgumentList TemplateArgs(TemplateArgumentList::OnStack, Converted);\n\n  // Only substitute for the innermost template argument list.\n  MultiLevelTemplateArgumentList TemplateArgLists;\n  TemplateArgLists.addOuterTemplateArguments(&TemplateArgs);\n  for (unsigned i = 0, e = Param->getDepth(); i != e; ++i)\n    TemplateArgLists.addOuterTemplateArguments(None);\n\n  Sema::ContextRAII SavedContext(SemaRef, Template->getDeclContext());\n  EnterExpressionEvaluationContext ConstantEvaluated(\n      SemaRef, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n  return SemaRef.SubstExpr(Param->getDefaultArgument(), TemplateArgLists);\n}\n\n/// Substitute template arguments into the default template argument for\n/// the given template template parameter.\n///\n/// \\param SemaRef the semantic analysis object for which we are performing\n/// the substitution.\n///\n/// \\param Template the template that we are synthesizing template arguments\n/// for.\n///\n/// \\param TemplateLoc the location of the template name that started the\n/// template-id we are checking.\n///\n/// \\param RAngleLoc the location of the right angle bracket ('>') that\n/// terminates the template-id.\n///\n/// \\param Param the template template parameter whose default we are\n/// substituting into.\n///\n/// \\param Converted the list of template arguments provided for template\n/// parameters that precede \\p Param in the template parameter list.\n///\n/// \\param QualifierLoc Will be set to the nested-name-specifier (with\n/// source-location information) that precedes the template name.\n///\n/// \\returns the substituted template argument, or NULL if an error occurred.\nstatic TemplateName\nSubstDefaultTemplateArgument(Sema &SemaRef,\n                             TemplateDecl *Template,\n                             SourceLocation TemplateLoc,\n                             SourceLocation RAngleLoc,\n                             TemplateTemplateParmDecl *Param,\n                       SmallVectorImpl<TemplateArgument> &Converted,\n                             NestedNameSpecifierLoc &QualifierLoc) {\n  Sema::InstantiatingTemplate Inst(\n      SemaRef, TemplateLoc, TemplateParameter(Param), Template, Converted,\n      SourceRange(TemplateLoc, RAngleLoc));\n  if (Inst.isInvalid())\n    return TemplateName();\n\n  TemplateArgumentList TemplateArgs(TemplateArgumentList::OnStack, Converted);\n\n  // Only substitute for the innermost template argument list.\n  MultiLevelTemplateArgumentList TemplateArgLists;\n  TemplateArgLists.addOuterTemplateArguments(&TemplateArgs);\n  for (unsigned i = 0, e = Param->getDepth(); i != e; ++i)\n    TemplateArgLists.addOuterTemplateArguments(None);\n\n  Sema::ContextRAII SavedContext(SemaRef, Template->getDeclContext());\n  // Substitute into the nested-name-specifier first,\n  QualifierLoc = Param->getDefaultArgument().getTemplateQualifierLoc();\n  if (QualifierLoc) {\n    QualifierLoc =\n        SemaRef.SubstNestedNameSpecifierLoc(QualifierLoc, TemplateArgLists);\n    if (!QualifierLoc)\n      return TemplateName();\n  }\n\n  return SemaRef.SubstTemplateName(\n             QualifierLoc,\n             Param->getDefaultArgument().getArgument().getAsTemplate(),\n             Param->getDefaultArgument().getTemplateNameLoc(),\n             TemplateArgLists);\n}\n\n/// If the given template parameter has a default template\n/// argument, substitute into that default template argument and\n/// return the corresponding template argument.\nTemplateArgumentLoc\nSema::SubstDefaultTemplateArgumentIfAvailable(TemplateDecl *Template,\n                                              SourceLocation TemplateLoc,\n                                              SourceLocation RAngleLoc,\n                                              Decl *Param,\n                                              SmallVectorImpl<TemplateArgument>\n                                                &Converted,\n                                              bool &HasDefaultArg) {\n  HasDefaultArg = false;\n\n  if (TemplateTypeParmDecl *TypeParm = dyn_cast<TemplateTypeParmDecl>(Param)) {\n    if (!hasVisibleDefaultArgument(TypeParm))\n      return TemplateArgumentLoc();\n\n    HasDefaultArg = true;\n    TypeSourceInfo *DI = SubstDefaultTemplateArgument(*this, Template,\n                                                      TemplateLoc,\n                                                      RAngleLoc,\n                                                      TypeParm,\n                                                      Converted);\n    if (DI)\n      return TemplateArgumentLoc(TemplateArgument(DI->getType()), DI);\n\n    return TemplateArgumentLoc();\n  }\n\n  if (NonTypeTemplateParmDecl *NonTypeParm\n        = dyn_cast<NonTypeTemplateParmDecl>(Param)) {\n    if (!hasVisibleDefaultArgument(NonTypeParm))\n      return TemplateArgumentLoc();\n\n    HasDefaultArg = true;\n    ExprResult Arg = SubstDefaultTemplateArgument(*this, Template,\n                                                  TemplateLoc,\n                                                  RAngleLoc,\n                                                  NonTypeParm,\n                                                  Converted);\n    if (Arg.isInvalid())\n      return TemplateArgumentLoc();\n\n    Expr *ArgE = Arg.getAs<Expr>();\n    return TemplateArgumentLoc(TemplateArgument(ArgE), ArgE);\n  }\n\n  TemplateTemplateParmDecl *TempTempParm\n    = cast<TemplateTemplateParmDecl>(Param);\n  if (!hasVisibleDefaultArgument(TempTempParm))\n    return TemplateArgumentLoc();\n\n  HasDefaultArg = true;\n  NestedNameSpecifierLoc QualifierLoc;\n  TemplateName TName = SubstDefaultTemplateArgument(*this, Template,\n                                                    TemplateLoc,\n                                                    RAngleLoc,\n                                                    TempTempParm,\n                                                    Converted,\n                                                    QualifierLoc);\n  if (TName.isNull())\n    return TemplateArgumentLoc();\n\n  return TemplateArgumentLoc(\n      Context, TemplateArgument(TName),\n      TempTempParm->getDefaultArgument().getTemplateQualifierLoc(),\n      TempTempParm->getDefaultArgument().getTemplateNameLoc());\n}\n\n/// Convert a template-argument that we parsed as a type into a template, if\n/// possible. C++ permits injected-class-names to perform dual service as\n/// template template arguments and as template type arguments.\nstatic TemplateArgumentLoc\nconvertTypeTemplateArgumentToTemplate(ASTContext &Context, TypeLoc TLoc) {\n  // Extract and step over any surrounding nested-name-specifier.\n  NestedNameSpecifierLoc QualLoc;\n  if (auto ETLoc = TLoc.getAs<ElaboratedTypeLoc>()) {\n    if (ETLoc.getTypePtr()->getKeyword() != ETK_None)\n      return TemplateArgumentLoc();\n\n    QualLoc = ETLoc.getQualifierLoc();\n    TLoc = ETLoc.getNamedTypeLoc();\n  }\n  // If this type was written as an injected-class-name, it can be used as a\n  // template template argument.\n  if (auto InjLoc = TLoc.getAs<InjectedClassNameTypeLoc>())\n    return TemplateArgumentLoc(Context, InjLoc.getTypePtr()->getTemplateName(),\n                               QualLoc, InjLoc.getNameLoc());\n\n  // If this type was written as an injected-class-name, it may have been\n  // converted to a RecordType during instantiation. If the RecordType is\n  // *not* wrapped in a TemplateSpecializationType and denotes a class\n  // template specialization, it must have come from an injected-class-name.\n  if (auto RecLoc = TLoc.getAs<RecordTypeLoc>())\n    if (auto *CTSD =\n            dyn_cast<ClassTemplateSpecializationDecl>(RecLoc.getDecl()))\n      return TemplateArgumentLoc(Context,\n                                 TemplateName(CTSD->getSpecializedTemplate()),\n                                 QualLoc, RecLoc.getNameLoc());\n\n  return TemplateArgumentLoc();\n}\n\n/// Check that the given template argument corresponds to the given\n/// template parameter.\n///\n/// \\param Param The template parameter against which the argument will be\n/// checked.\n///\n/// \\param Arg The template argument, which may be updated due to conversions.\n///\n/// \\param Template The template in which the template argument resides.\n///\n/// \\param TemplateLoc The location of the template name for the template\n/// whose argument list we're matching.\n///\n/// \\param RAngleLoc The location of the right angle bracket ('>') that closes\n/// the template argument list.\n///\n/// \\param ArgumentPackIndex The index into the argument pack where this\n/// argument will be placed. Only valid if the parameter is a parameter pack.\n///\n/// \\param Converted The checked, converted argument will be added to the\n/// end of this small vector.\n///\n/// \\param CTAK Describes how we arrived at this particular template argument:\n/// explicitly written, deduced, etc.\n///\n/// \\returns true on error, false otherwise.\nbool Sema::CheckTemplateArgument(NamedDecl *Param,\n                                 TemplateArgumentLoc &Arg,\n                                 NamedDecl *Template,\n                                 SourceLocation TemplateLoc,\n                                 SourceLocation RAngleLoc,\n                                 unsigned ArgumentPackIndex,\n                            SmallVectorImpl<TemplateArgument> &Converted,\n                                 CheckTemplateArgumentKind CTAK) {\n  // Check template type parameters.\n  if (TemplateTypeParmDecl *TTP = dyn_cast<TemplateTypeParmDecl>(Param))\n    return CheckTemplateTypeArgument(TTP, Arg, Converted);\n\n  // Check non-type template parameters.\n  if (NonTypeTemplateParmDecl *NTTP =dyn_cast<NonTypeTemplateParmDecl>(Param)) {\n    // Do substitution on the type of the non-type template parameter\n    // with the template arguments we've seen thus far.  But if the\n    // template has a dependent context then we cannot substitute yet.\n    QualType NTTPType = NTTP->getType();\n    if (NTTP->isParameterPack() && NTTP->isExpandedParameterPack())\n      NTTPType = NTTP->getExpansionType(ArgumentPackIndex);\n\n    if (NTTPType->isInstantiationDependentType() &&\n        !isa<TemplateTemplateParmDecl>(Template) &&\n        !Template->getDeclContext()->isDependentContext()) {\n      // Do substitution on the type of the non-type template parameter.\n      InstantiatingTemplate Inst(*this, TemplateLoc, Template,\n                                 NTTP, Converted,\n                                 SourceRange(TemplateLoc, RAngleLoc));\n      if (Inst.isInvalid())\n        return true;\n\n      TemplateArgumentList TemplateArgs(TemplateArgumentList::OnStack,\n                                        Converted);\n\n      // If the parameter is a pack expansion, expand this slice of the pack.\n      if (auto *PET = NTTPType->getAs<PackExpansionType>()) {\n        Sema::ArgumentPackSubstitutionIndexRAII SubstIndex(*this,\n                                                           ArgumentPackIndex);\n        NTTPType = SubstType(PET->getPattern(),\n                             MultiLevelTemplateArgumentList(TemplateArgs),\n                             NTTP->getLocation(),\n                             NTTP->getDeclName());\n      } else {\n        NTTPType = SubstType(NTTPType,\n                             MultiLevelTemplateArgumentList(TemplateArgs),\n                             NTTP->getLocation(),\n                             NTTP->getDeclName());\n      }\n\n      // If that worked, check the non-type template parameter type\n      // for validity.\n      if (!NTTPType.isNull())\n        NTTPType = CheckNonTypeTemplateParameterType(NTTPType,\n                                                     NTTP->getLocation());\n      if (NTTPType.isNull())\n        return true;\n    }\n\n    switch (Arg.getArgument().getKind()) {\n    case TemplateArgument::Null:\n      llvm_unreachable(\"Should never see a NULL template argument here\");\n\n    case TemplateArgument::Expression: {\n      TemplateArgument Result;\n      unsigned CurSFINAEErrors = NumSFINAEErrors;\n      ExprResult Res =\n        CheckTemplateArgument(NTTP, NTTPType, Arg.getArgument().getAsExpr(),\n                              Result, CTAK);\n      if (Res.isInvalid())\n        return true;\n      // If the current template argument causes an error, give up now.\n      if (CurSFINAEErrors < NumSFINAEErrors)\n        return true;\n\n      // If the resulting expression is new, then use it in place of the\n      // old expression in the template argument.\n      if (Res.get() != Arg.getArgument().getAsExpr()) {\n        TemplateArgument TA(Res.get());\n        Arg = TemplateArgumentLoc(TA, Res.get());\n      }\n\n      Converted.push_back(Result);\n      break;\n    }\n\n    case TemplateArgument::Declaration:\n    case TemplateArgument::Integral:\n    case TemplateArgument::NullPtr:\n      // We've already checked this template argument, so just copy\n      // it to the list of converted arguments.\n      Converted.push_back(Arg.getArgument());\n      break;\n\n    case TemplateArgument::Template:\n    case TemplateArgument::TemplateExpansion:\n      // We were given a template template argument. It may not be ill-formed;\n      // see below.\n      if (DependentTemplateName *DTN\n            = Arg.getArgument().getAsTemplateOrTemplatePattern()\n                                              .getAsDependentTemplateName()) {\n        // We have a template argument such as \\c T::template X, which we\n        // parsed as a template template argument. However, since we now\n        // know that we need a non-type template argument, convert this\n        // template name into an expression.\n\n        DeclarationNameInfo NameInfo(DTN->getIdentifier(),\n                                     Arg.getTemplateNameLoc());\n\n        CXXScopeSpec SS;\n        SS.Adopt(Arg.getTemplateQualifierLoc());\n        // FIXME: the template-template arg was a DependentTemplateName,\n        // so it was provided with a template keyword. However, its source\n        // location is not stored in the template argument structure.\n        SourceLocation TemplateKWLoc;\n        ExprResult E = DependentScopeDeclRefExpr::Create(\n            Context, SS.getWithLocInContext(Context), TemplateKWLoc, NameInfo,\n            nullptr);\n\n        // If we parsed the template argument as a pack expansion, create a\n        // pack expansion expression.\n        if (Arg.getArgument().getKind() == TemplateArgument::TemplateExpansion){\n          E = ActOnPackExpansion(E.get(), Arg.getTemplateEllipsisLoc());\n          if (E.isInvalid())\n            return true;\n        }\n\n        TemplateArgument Result;\n        E = CheckTemplateArgument(NTTP, NTTPType, E.get(), Result);\n        if (E.isInvalid())\n          return true;\n\n        Converted.push_back(Result);\n        break;\n      }\n\n      // We have a template argument that actually does refer to a class\n      // template, alias template, or template template parameter, and\n      // therefore cannot be a non-type template argument.\n      Diag(Arg.getLocation(), diag::err_template_arg_must_be_expr)\n        << Arg.getSourceRange();\n\n      Diag(Param->getLocation(), diag::note_template_param_here);\n      return true;\n\n    case TemplateArgument::Type: {\n      // We have a non-type template parameter but the template\n      // argument is a type.\n\n      // C++ [temp.arg]p2:\n      //   In a template-argument, an ambiguity between a type-id and\n      //   an expression is resolved to a type-id, regardless of the\n      //   form of the corresponding template-parameter.\n      //\n      // We warn specifically about this case, since it can be rather\n      // confusing for users.\n      QualType T = Arg.getArgument().getAsType();\n      SourceRange SR = Arg.getSourceRange();\n      if (T->isFunctionType())\n        Diag(SR.getBegin(), diag::err_template_arg_nontype_ambig) << SR << T;\n      else\n        Diag(SR.getBegin(), diag::err_template_arg_must_be_expr) << SR;\n      Diag(Param->getLocation(), diag::note_template_param_here);\n      return true;\n    }\n\n    case TemplateArgument::Pack:\n      llvm_unreachable(\"Caller must expand template argument packs\");\n    }\n\n    return false;\n  }\n\n\n  // Check template template parameters.\n  TemplateTemplateParmDecl *TempParm = cast<TemplateTemplateParmDecl>(Param);\n\n  TemplateParameterList *Params = TempParm->getTemplateParameters();\n  if (TempParm->isExpandedParameterPack())\n    Params = TempParm->getExpansionTemplateParameters(ArgumentPackIndex);\n\n  // Substitute into the template parameter list of the template\n  // template parameter, since previously-supplied template arguments\n  // may appear within the template template parameter.\n  //\n  // FIXME: Skip this if the parameters aren't instantiation-dependent.\n  {\n    // Set up a template instantiation context.\n    LocalInstantiationScope Scope(*this);\n    InstantiatingTemplate Inst(*this, TemplateLoc, Template,\n                               TempParm, Converted,\n                               SourceRange(TemplateLoc, RAngleLoc));\n    if (Inst.isInvalid())\n      return true;\n\n    TemplateArgumentList TemplateArgs(TemplateArgumentList::OnStack, Converted);\n    Params = SubstTemplateParams(Params, CurContext,\n                                 MultiLevelTemplateArgumentList(TemplateArgs));\n    if (!Params)\n      return true;\n  }\n\n  // C++1z [temp.local]p1: (DR1004)\n  //   When [the injected-class-name] is used [...] as a template-argument for\n  //   a template template-parameter [...] it refers to the class template\n  //   itself.\n  if (Arg.getArgument().getKind() == TemplateArgument::Type) {\n    TemplateArgumentLoc ConvertedArg = convertTypeTemplateArgumentToTemplate(\n        Context, Arg.getTypeSourceInfo()->getTypeLoc());\n    if (!ConvertedArg.getArgument().isNull())\n      Arg = ConvertedArg;\n  }\n\n  switch (Arg.getArgument().getKind()) {\n  case TemplateArgument::Null:\n    llvm_unreachable(\"Should never see a NULL template argument here\");\n\n  case TemplateArgument::Template:\n  case TemplateArgument::TemplateExpansion:\n    if (CheckTemplateTemplateArgument(TempParm, Params, Arg))\n      return true;\n\n    Converted.push_back(Arg.getArgument());\n    break;\n\n  case TemplateArgument::Expression:\n  case TemplateArgument::Type:\n    // We have a template template parameter but the template\n    // argument does not refer to a template.\n    Diag(Arg.getLocation(), diag::err_template_arg_must_be_template)\n      << getLangOpts().CPlusPlus11;\n    return true;\n\n  case TemplateArgument::Declaration:\n    llvm_unreachable(\"Declaration argument with template template parameter\");\n  case TemplateArgument::Integral:\n    llvm_unreachable(\"Integral argument with template template parameter\");\n  case TemplateArgument::NullPtr:\n    llvm_unreachable(\"Null pointer argument with template template parameter\");\n\n  case TemplateArgument::Pack:\n    llvm_unreachable(\"Caller must expand template argument packs\");\n  }\n\n  return false;\n}\n\n/// Diagnose a missing template argument.\ntemplate<typename TemplateParmDecl>\nstatic bool diagnoseMissingArgument(Sema &S, SourceLocation Loc,\n                                    TemplateDecl *TD,\n                                    const TemplateParmDecl *D,\n                                    TemplateArgumentListInfo &Args) {\n  // Dig out the most recent declaration of the template parameter; there may be\n  // declarations of the template that are more recent than TD.\n  D = cast<TemplateParmDecl>(cast<TemplateDecl>(TD->getMostRecentDecl())\n                                 ->getTemplateParameters()\n                                 ->getParam(D->getIndex()));\n\n  // If there's a default argument that's not visible, diagnose that we're\n  // missing a module import.\n  llvm::SmallVector<Module*, 8> Modules;\n  if (D->hasDefaultArgument() && !S.hasVisibleDefaultArgument(D, &Modules)) {\n    S.diagnoseMissingImport(Loc, cast<NamedDecl>(TD),\n                            D->getDefaultArgumentLoc(), Modules,\n                            Sema::MissingImportKind::DefaultArgument,\n                            /*Recover*/true);\n    return true;\n  }\n\n  // FIXME: If there's a more recent default argument that *is* visible,\n  // diagnose that it was declared too late.\n\n  TemplateParameterList *Params = TD->getTemplateParameters();\n\n  S.Diag(Loc, diag::err_template_arg_list_different_arity)\n    << /*not enough args*/0\n    << (int)S.getTemplateNameKindForDiagnostics(TemplateName(TD))\n    << TD;\n  S.Diag(TD->getLocation(), diag::note_template_decl_here)\n    << Params->getSourceRange();\n  return true;\n}\n\n/// Check that the given template argument list is well-formed\n/// for specializing the given template.\nbool Sema::CheckTemplateArgumentList(\n    TemplateDecl *Template, SourceLocation TemplateLoc,\n    TemplateArgumentListInfo &TemplateArgs, bool PartialTemplateArgs,\n    SmallVectorImpl<TemplateArgument> &Converted,\n    bool UpdateArgsWithConversions, bool *ConstraintsNotSatisfied) {\n\n  if (ConstraintsNotSatisfied)\n    *ConstraintsNotSatisfied = false;\n\n  // Make a copy of the template arguments for processing.  Only make the\n  // changes at the end when successful in matching the arguments to the\n  // template.\n  TemplateArgumentListInfo NewArgs = TemplateArgs;\n\n  // Make sure we get the template parameter list from the most\n  // recentdeclaration, since that is the only one that has is guaranteed to\n  // have all the default template argument information.\n  TemplateParameterList *Params =\n      cast<TemplateDecl>(Template->getMostRecentDecl())\n          ->getTemplateParameters();\n\n  SourceLocation RAngleLoc = NewArgs.getRAngleLoc();\n\n  // C++ [temp.arg]p1:\n  //   [...] The type and form of each template-argument specified in\n  //   a template-id shall match the type and form specified for the\n  //   corresponding parameter declared by the template in its\n  //   template-parameter-list.\n  bool isTemplateTemplateParameter = isa<TemplateTemplateParmDecl>(Template);\n  SmallVector<TemplateArgument, 2> ArgumentPack;\n  unsigned ArgIdx = 0, NumArgs = NewArgs.size();\n  LocalInstantiationScope InstScope(*this, true);\n  for (TemplateParameterList::iterator Param = Params->begin(),\n                                       ParamEnd = Params->end();\n       Param != ParamEnd; /* increment in loop */) {\n    // If we have an expanded parameter pack, make sure we don't have too\n    // many arguments.\n    if (Optional<unsigned> Expansions = getExpandedPackSize(*Param)) {\n      if (*Expansions == ArgumentPack.size()) {\n        // We're done with this parameter pack. Pack up its arguments and add\n        // them to the list.\n        Converted.push_back(\n            TemplateArgument::CreatePackCopy(Context, ArgumentPack));\n        ArgumentPack.clear();\n\n        // This argument is assigned to the next parameter.\n        ++Param;\n        continue;\n      } else if (ArgIdx == NumArgs && !PartialTemplateArgs) {\n        // Not enough arguments for this parameter pack.\n        Diag(TemplateLoc, diag::err_template_arg_list_different_arity)\n          << /*not enough args*/0\n          << (int)getTemplateNameKindForDiagnostics(TemplateName(Template))\n          << Template;\n        Diag(Template->getLocation(), diag::note_template_decl_here)\n          << Params->getSourceRange();\n        return true;\n      }\n    }\n\n    if (ArgIdx < NumArgs) {\n      // Check the template argument we were given.\n      if (CheckTemplateArgument(*Param, NewArgs[ArgIdx], Template,\n                                TemplateLoc, RAngleLoc,\n                                ArgumentPack.size(), Converted))\n        return true;\n\n      bool PackExpansionIntoNonPack =\n          NewArgs[ArgIdx].getArgument().isPackExpansion() &&\n          (!(*Param)->isTemplateParameterPack() || getExpandedPackSize(*Param));\n      if (PackExpansionIntoNonPack && (isa<TypeAliasTemplateDecl>(Template) ||\n                                       isa<ConceptDecl>(Template))) {\n        // Core issue 1430: we have a pack expansion as an argument to an\n        // alias template, and it's not part of a parameter pack. This\n        // can't be canonicalized, so reject it now.\n        // As for concepts - we cannot normalize constraints where this\n        // situation exists.\n        Diag(NewArgs[ArgIdx].getLocation(),\n             diag::err_template_expansion_into_fixed_list)\n          << (isa<ConceptDecl>(Template) ? 1 : 0)\n          << NewArgs[ArgIdx].getSourceRange();\n        Diag((*Param)->getLocation(), diag::note_template_param_here);\n        return true;\n      }\n\n      // We're now done with this argument.\n      ++ArgIdx;\n\n      if ((*Param)->isTemplateParameterPack()) {\n        // The template parameter was a template parameter pack, so take the\n        // deduced argument and place it on the argument pack. Note that we\n        // stay on the same template parameter so that we can deduce more\n        // arguments.\n        ArgumentPack.push_back(Converted.pop_back_val());\n      } else {\n        // Move to the next template parameter.\n        ++Param;\n      }\n\n      // If we just saw a pack expansion into a non-pack, then directly convert\n      // the remaining arguments, because we don't know what parameters they'll\n      // match up with.\n      if (PackExpansionIntoNonPack) {\n        if (!ArgumentPack.empty()) {\n          // If we were part way through filling in an expanded parameter pack,\n          // fall back to just producing individual arguments.\n          Converted.insert(Converted.end(),\n                           ArgumentPack.begin(), ArgumentPack.end());\n          ArgumentPack.clear();\n        }\n\n        while (ArgIdx < NumArgs) {\n          Converted.push_back(NewArgs[ArgIdx].getArgument());\n          ++ArgIdx;\n        }\n\n        return false;\n      }\n\n      continue;\n    }\n\n    // If we're checking a partial template argument list, we're done.\n    if (PartialTemplateArgs) {\n      if ((*Param)->isTemplateParameterPack() && !ArgumentPack.empty())\n        Converted.push_back(\n            TemplateArgument::CreatePackCopy(Context, ArgumentPack));\n      return false;\n    }\n\n    // If we have a template parameter pack with no more corresponding\n    // arguments, just break out now and we'll fill in the argument pack below.\n    if ((*Param)->isTemplateParameterPack()) {\n      assert(!getExpandedPackSize(*Param) &&\n             \"Should have dealt with this already\");\n\n      // A non-expanded parameter pack before the end of the parameter list\n      // only occurs for an ill-formed template parameter list, unless we've\n      // got a partial argument list for a function template, so just bail out.\n      if (Param + 1 != ParamEnd)\n        return true;\n\n      Converted.push_back(\n          TemplateArgument::CreatePackCopy(Context, ArgumentPack));\n      ArgumentPack.clear();\n\n      ++Param;\n      continue;\n    }\n\n    // Check whether we have a default argument.\n    TemplateArgumentLoc Arg;\n\n    // Retrieve the default template argument from the template\n    // parameter. For each kind of template parameter, we substitute the\n    // template arguments provided thus far and any \"outer\" template arguments\n    // (when the template parameter was part of a nested template) into\n    // the default argument.\n    if (TemplateTypeParmDecl *TTP = dyn_cast<TemplateTypeParmDecl>(*Param)) {\n      if (!hasVisibleDefaultArgument(TTP))\n        return diagnoseMissingArgument(*this, TemplateLoc, Template, TTP,\n                                       NewArgs);\n\n      TypeSourceInfo *ArgType = SubstDefaultTemplateArgument(*this,\n                                                             Template,\n                                                             TemplateLoc,\n                                                             RAngleLoc,\n                                                             TTP,\n                                                             Converted);\n      if (!ArgType)\n        return true;\n\n      Arg = TemplateArgumentLoc(TemplateArgument(ArgType->getType()),\n                                ArgType);\n    } else if (NonTypeTemplateParmDecl *NTTP\n                 = dyn_cast<NonTypeTemplateParmDecl>(*Param)) {\n      if (!hasVisibleDefaultArgument(NTTP))\n        return diagnoseMissingArgument(*this, TemplateLoc, Template, NTTP,\n                                       NewArgs);\n\n      ExprResult E = SubstDefaultTemplateArgument(*this, Template,\n                                                              TemplateLoc,\n                                                              RAngleLoc,\n                                                              NTTP,\n                                                              Converted);\n      if (E.isInvalid())\n        return true;\n\n      Expr *Ex = E.getAs<Expr>();\n      Arg = TemplateArgumentLoc(TemplateArgument(Ex), Ex);\n    } else {\n      TemplateTemplateParmDecl *TempParm\n        = cast<TemplateTemplateParmDecl>(*Param);\n\n      if (!hasVisibleDefaultArgument(TempParm))\n        return diagnoseMissingArgument(*this, TemplateLoc, Template, TempParm,\n                                       NewArgs);\n\n      NestedNameSpecifierLoc QualifierLoc;\n      TemplateName Name = SubstDefaultTemplateArgument(*this, Template,\n                                                       TemplateLoc,\n                                                       RAngleLoc,\n                                                       TempParm,\n                                                       Converted,\n                                                       QualifierLoc);\n      if (Name.isNull())\n        return true;\n\n      Arg = TemplateArgumentLoc(\n          Context, TemplateArgument(Name), QualifierLoc,\n          TempParm->getDefaultArgument().getTemplateNameLoc());\n    }\n\n    // Introduce an instantiation record that describes where we are using\n    // the default template argument. We're not actually instantiating a\n    // template here, we just create this object to put a note into the\n    // context stack.\n    InstantiatingTemplate Inst(*this, RAngleLoc, Template, *Param, Converted,\n                               SourceRange(TemplateLoc, RAngleLoc));\n    if (Inst.isInvalid())\n      return true;\n\n    // Check the default template argument.\n    if (CheckTemplateArgument(*Param, Arg, Template, TemplateLoc,\n                              RAngleLoc, 0, Converted))\n      return true;\n\n    // Core issue 150 (assumed resolution): if this is a template template\n    // parameter, keep track of the default template arguments from the\n    // template definition.\n    if (isTemplateTemplateParameter)\n      NewArgs.addArgument(Arg);\n\n    // Move to the next template parameter and argument.\n    ++Param;\n    ++ArgIdx;\n  }\n\n  // If we're performing a partial argument substitution, allow any trailing\n  // pack expansions; they might be empty. This can happen even if\n  // PartialTemplateArgs is false (the list of arguments is complete but\n  // still dependent).\n  if (ArgIdx < NumArgs && CurrentInstantiationScope &&\n      CurrentInstantiationScope->getPartiallySubstitutedPack()) {\n    while (ArgIdx < NumArgs && NewArgs[ArgIdx].getArgument().isPackExpansion())\n      Converted.push_back(NewArgs[ArgIdx++].getArgument());\n  }\n\n  // If we have any leftover arguments, then there were too many arguments.\n  // Complain and fail.\n  if (ArgIdx < NumArgs) {\n    Diag(TemplateLoc, diag::err_template_arg_list_different_arity)\n        << /*too many args*/1\n        << (int)getTemplateNameKindForDiagnostics(TemplateName(Template))\n        << Template\n        << SourceRange(NewArgs[ArgIdx].getLocation(), NewArgs.getRAngleLoc());\n    Diag(Template->getLocation(), diag::note_template_decl_here)\n        << Params->getSourceRange();\n    return true;\n  }\n\n  // No problems found with the new argument list, propagate changes back\n  // to caller.\n  if (UpdateArgsWithConversions)\n    TemplateArgs = std::move(NewArgs);\n\n  if (!PartialTemplateArgs &&\n      EnsureTemplateArgumentListConstraints(\n        Template, Converted, SourceRange(TemplateLoc,\n                                         TemplateArgs.getRAngleLoc()))) {\n    if (ConstraintsNotSatisfied)\n      *ConstraintsNotSatisfied = true;\n    return true;\n  }\n\n  return false;\n}\n\nnamespace {\n  class UnnamedLocalNoLinkageFinder\n    : public TypeVisitor<UnnamedLocalNoLinkageFinder, bool>\n  {\n    Sema &S;\n    SourceRange SR;\n\n    typedef TypeVisitor<UnnamedLocalNoLinkageFinder, bool> inherited;\n\n  public:\n    UnnamedLocalNoLinkageFinder(Sema &S, SourceRange SR) : S(S), SR(SR) { }\n\n    bool Visit(QualType T) {\n      return T.isNull() ? false : inherited::Visit(T.getTypePtr());\n    }\n\n#define TYPE(Class, Parent) \\\n    bool Visit##Class##Type(const Class##Type *);\n#define ABSTRACT_TYPE(Class, Parent) \\\n    bool Visit##Class##Type(const Class##Type *) { return false; }\n#define NON_CANONICAL_TYPE(Class, Parent) \\\n    bool Visit##Class##Type(const Class##Type *) { return false; }\n#include \"clang/AST/TypeNodes.inc\"\n\n    bool VisitTagDecl(const TagDecl *Tag);\n    bool VisitNestedNameSpecifier(NestedNameSpecifier *NNS);\n  };\n} // end anonymous namespace\n\nbool UnnamedLocalNoLinkageFinder::VisitBuiltinType(const BuiltinType*) {\n  return false;\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitComplexType(const ComplexType* T) {\n  return Visit(T->getElementType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitPointerType(const PointerType* T) {\n  return Visit(T->getPointeeType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitBlockPointerType(\n                                                    const BlockPointerType* T) {\n  return Visit(T->getPointeeType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitLValueReferenceType(\n                                                const LValueReferenceType* T) {\n  return Visit(T->getPointeeType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitRValueReferenceType(\n                                                const RValueReferenceType* T) {\n  return Visit(T->getPointeeType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitMemberPointerType(\n                                                  const MemberPointerType* T) {\n  return Visit(T->getPointeeType()) || Visit(QualType(T->getClass(), 0));\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitConstantArrayType(\n                                                  const ConstantArrayType* T) {\n  return Visit(T->getElementType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitIncompleteArrayType(\n                                                 const IncompleteArrayType* T) {\n  return Visit(T->getElementType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitVariableArrayType(\n                                                   const VariableArrayType* T) {\n  return Visit(T->getElementType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitDependentSizedArrayType(\n                                            const DependentSizedArrayType* T) {\n  return Visit(T->getElementType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitDependentSizedExtVectorType(\n                                         const DependentSizedExtVectorType* T) {\n  return Visit(T->getElementType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitDependentSizedMatrixType(\n    const DependentSizedMatrixType *T) {\n  return Visit(T->getElementType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitDependentAddressSpaceType(\n    const DependentAddressSpaceType *T) {\n  return Visit(T->getPointeeType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitVectorType(const VectorType* T) {\n  return Visit(T->getElementType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitDependentVectorType(\n    const DependentVectorType *T) {\n  return Visit(T->getElementType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitExtVectorType(const ExtVectorType* T) {\n  return Visit(T->getElementType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitConstantMatrixType(\n    const ConstantMatrixType *T) {\n  return Visit(T->getElementType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitFunctionProtoType(\n                                                  const FunctionProtoType* T) {\n  for (const auto &A : T->param_types()) {\n    if (Visit(A))\n      return true;\n  }\n\n  return Visit(T->getReturnType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitFunctionNoProtoType(\n                                               const FunctionNoProtoType* T) {\n  return Visit(T->getReturnType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitUnresolvedUsingType(\n                                                  const UnresolvedUsingType*) {\n  return false;\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitTypeOfExprType(const TypeOfExprType*) {\n  return false;\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitTypeOfType(const TypeOfType* T) {\n  return Visit(T->getUnderlyingType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitDecltypeType(const DecltypeType*) {\n  return false;\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitUnaryTransformType(\n                                                    const UnaryTransformType*) {\n  return false;\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitAutoType(const AutoType *T) {\n  return Visit(T->getDeducedType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitDeducedTemplateSpecializationType(\n    const DeducedTemplateSpecializationType *T) {\n  return Visit(T->getDeducedType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitRecordType(const RecordType* T) {\n  return VisitTagDecl(T->getDecl());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitEnumType(const EnumType* T) {\n  return VisitTagDecl(T->getDecl());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitTemplateTypeParmType(\n                                                 const TemplateTypeParmType*) {\n  return false;\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitSubstTemplateTypeParmPackType(\n                                        const SubstTemplateTypeParmPackType *) {\n  return false;\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitTemplateSpecializationType(\n                                            const TemplateSpecializationType*) {\n  return false;\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitInjectedClassNameType(\n                                              const InjectedClassNameType* T) {\n  return VisitTagDecl(T->getDecl());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitDependentNameType(\n                                                   const DependentNameType* T) {\n  return VisitNestedNameSpecifier(T->getQualifier());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitDependentTemplateSpecializationType(\n                                 const DependentTemplateSpecializationType* T) {\n  if (auto *Q = T->getQualifier())\n    return VisitNestedNameSpecifier(Q);\n  return false;\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitPackExpansionType(\n                                                   const PackExpansionType* T) {\n  return Visit(T->getPattern());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitObjCObjectType(const ObjCObjectType *) {\n  return false;\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitObjCInterfaceType(\n                                                   const ObjCInterfaceType *) {\n  return false;\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitObjCObjectPointerType(\n                                                const ObjCObjectPointerType *) {\n  return false;\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitAtomicType(const AtomicType* T) {\n  return Visit(T->getValueType());\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitPipeType(const PipeType* T) {\n  return false;\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitExtIntType(const ExtIntType *T) {\n  return false;\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitDependentExtIntType(\n    const DependentExtIntType *T) {\n  return false;\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitTagDecl(const TagDecl *Tag) {\n  if (Tag->getDeclContext()->isFunctionOrMethod()) {\n    S.Diag(SR.getBegin(),\n           S.getLangOpts().CPlusPlus11 ?\n             diag::warn_cxx98_compat_template_arg_local_type :\n             diag::ext_template_arg_local_type)\n      << S.Context.getTypeDeclType(Tag) << SR;\n    return true;\n  }\n\n  if (!Tag->hasNameForLinkage()) {\n    S.Diag(SR.getBegin(),\n           S.getLangOpts().CPlusPlus11 ?\n             diag::warn_cxx98_compat_template_arg_unnamed_type :\n             diag::ext_template_arg_unnamed_type) << SR;\n    S.Diag(Tag->getLocation(), diag::note_template_unnamed_type_here);\n    return true;\n  }\n\n  return false;\n}\n\nbool UnnamedLocalNoLinkageFinder::VisitNestedNameSpecifier(\n                                                    NestedNameSpecifier *NNS) {\n  assert(NNS);\n  if (NNS->getPrefix() && VisitNestedNameSpecifier(NNS->getPrefix()))\n    return true;\n\n  switch (NNS->getKind()) {\n  case NestedNameSpecifier::Identifier:\n  case NestedNameSpecifier::Namespace:\n  case NestedNameSpecifier::NamespaceAlias:\n  case NestedNameSpecifier::Global:\n  case NestedNameSpecifier::Super:\n    return false;\n\n  case NestedNameSpecifier::TypeSpec:\n  case NestedNameSpecifier::TypeSpecWithTemplate:\n    return Visit(QualType(NNS->getAsType(), 0));\n  }\n  llvm_unreachable(\"Invalid NestedNameSpecifier::Kind!\");\n}\n\n/// Check a template argument against its corresponding\n/// template type parameter.\n///\n/// This routine implements the semantics of C++ [temp.arg.type]. It\n/// returns true if an error occurred, and false otherwise.\nbool Sema::CheckTemplateArgument(TemplateTypeParmDecl *Param,\n                                 TypeSourceInfo *ArgInfo) {\n  assert(ArgInfo && \"invalid TypeSourceInfo\");\n  QualType Arg = ArgInfo->getType();\n  SourceRange SR = ArgInfo->getTypeLoc().getSourceRange();\n\n  if (Arg->isVariablyModifiedType()) {\n    return Diag(SR.getBegin(), diag::err_variably_modified_template_arg) << Arg;\n  } else if (Context.hasSameUnqualifiedType(Arg, Context.OverloadTy)) {\n    return Diag(SR.getBegin(), diag::err_template_arg_overload_type) << SR;\n  }\n\n  // C++03 [temp.arg.type]p2:\n  //   A local type, a type with no linkage, an unnamed type or a type\n  //   compounded from any of these types shall not be used as a\n  //   template-argument for a template type-parameter.\n  //\n  // C++11 allows these, and even in C++03 we allow them as an extension with\n  // a warning.\n  if (LangOpts.CPlusPlus11 || Arg->hasUnnamedOrLocalType()) {\n    UnnamedLocalNoLinkageFinder Finder(*this, SR);\n    (void)Finder.Visit(Context.getCanonicalType(Arg));\n  }\n\n  return false;\n}\n\nenum NullPointerValueKind {\n  NPV_NotNullPointer,\n  NPV_NullPointer,\n  NPV_Error\n};\n\n/// Determine whether the given template argument is a null pointer\n/// value of the appropriate type.\nstatic NullPointerValueKind\nisNullPointerValueTemplateArgument(Sema &S, NonTypeTemplateParmDecl *Param,\n                                   QualType ParamType, Expr *Arg,\n                                   Decl *Entity = nullptr) {\n  if (Arg->isValueDependent() || Arg->isTypeDependent())\n    return NPV_NotNullPointer;\n\n  // dllimport'd entities aren't constant but are available inside of template\n  // arguments.\n  if (Entity && Entity->hasAttr<DLLImportAttr>())\n    return NPV_NotNullPointer;\n\n  if (!S.isCompleteType(Arg->getExprLoc(), ParamType))\n    llvm_unreachable(\n        \"Incomplete parameter type in isNullPointerValueTemplateArgument!\");\n\n  if (!S.getLangOpts().CPlusPlus11)\n    return NPV_NotNullPointer;\n\n  // Determine whether we have a constant expression.\n  ExprResult ArgRV = S.DefaultFunctionArrayConversion(Arg);\n  if (ArgRV.isInvalid())\n    return NPV_Error;\n  Arg = ArgRV.get();\n\n  Expr::EvalResult EvalResult;\n  SmallVector<PartialDiagnosticAt, 8> Notes;\n  EvalResult.Diag = &Notes;\n  if (!Arg->EvaluateAsRValue(EvalResult, S.Context) ||\n      EvalResult.HasSideEffects) {\n    SourceLocation DiagLoc = Arg->getExprLoc();\n\n    // If our only note is the usual \"invalid subexpression\" note, just point\n    // the caret at its location rather than producing an essentially\n    // redundant note.\n    if (Notes.size() == 1 && Notes[0].second.getDiagID() ==\n        diag::note_invalid_subexpr_in_const_expr) {\n      DiagLoc = Notes[0].first;\n      Notes.clear();\n    }\n\n    S.Diag(DiagLoc, diag::err_template_arg_not_address_constant)\n      << Arg->getType() << Arg->getSourceRange();\n    for (unsigned I = 0, N = Notes.size(); I != N; ++I)\n      S.Diag(Notes[I].first, Notes[I].second);\n\n    S.Diag(Param->getLocation(), diag::note_template_param_here);\n    return NPV_Error;\n  }\n\n  // C++11 [temp.arg.nontype]p1:\n  //   - an address constant expression of type std::nullptr_t\n  if (Arg->getType()->isNullPtrType())\n    return NPV_NullPointer;\n\n  //   - a constant expression that evaluates to a null pointer value (4.10); or\n  //   - a constant expression that evaluates to a null member pointer value\n  //     (4.11); or\n  if ((EvalResult.Val.isLValue() && !EvalResult.Val.getLValueBase()) ||\n      (EvalResult.Val.isMemberPointer() &&\n       !EvalResult.Val.getMemberPointerDecl())) {\n    // If our expression has an appropriate type, we've succeeded.\n    bool ObjCLifetimeConversion;\n    if (S.Context.hasSameUnqualifiedType(Arg->getType(), ParamType) ||\n        S.IsQualificationConversion(Arg->getType(), ParamType, false,\n                                     ObjCLifetimeConversion))\n      return NPV_NullPointer;\n\n    // The types didn't match, but we know we got a null pointer; complain,\n    // then recover as if the types were correct.\n    S.Diag(Arg->getExprLoc(), diag::err_template_arg_wrongtype_null_constant)\n      << Arg->getType() << ParamType << Arg->getSourceRange();\n    S.Diag(Param->getLocation(), diag::note_template_param_here);\n    return NPV_NullPointer;\n  }\n\n  // If we don't have a null pointer value, but we do have a NULL pointer\n  // constant, suggest a cast to the appropriate type.\n  if (Arg->isNullPointerConstant(S.Context, Expr::NPC_NeverValueDependent)) {\n    std::string Code = \"static_cast<\" + ParamType.getAsString() + \">(\";\n    S.Diag(Arg->getExprLoc(), diag::err_template_arg_untyped_null_constant)\n        << ParamType << FixItHint::CreateInsertion(Arg->getBeginLoc(), Code)\n        << FixItHint::CreateInsertion(S.getLocForEndOfToken(Arg->getEndLoc()),\n                                      \")\");\n    S.Diag(Param->getLocation(), diag::note_template_param_here);\n    return NPV_NullPointer;\n  }\n\n  // FIXME: If we ever want to support general, address-constant expressions\n  // as non-type template arguments, we should return the ExprResult here to\n  // be interpreted by the caller.\n  return NPV_NotNullPointer;\n}\n\n/// Checks whether the given template argument is compatible with its\n/// template parameter.\nstatic bool CheckTemplateArgumentIsCompatibleWithParameter(\n    Sema &S, NonTypeTemplateParmDecl *Param, QualType ParamType, Expr *ArgIn,\n    Expr *Arg, QualType ArgType) {\n  bool ObjCLifetimeConversion;\n  if (ParamType->isPointerType() &&\n      !ParamType->castAs<PointerType>()->getPointeeType()->isFunctionType() &&\n      S.IsQualificationConversion(ArgType, ParamType, false,\n                                  ObjCLifetimeConversion)) {\n    // For pointer-to-object types, qualification conversions are\n    // permitted.\n  } else {\n    if (const ReferenceType *ParamRef = ParamType->getAs<ReferenceType>()) {\n      if (!ParamRef->getPointeeType()->isFunctionType()) {\n        // C++ [temp.arg.nontype]p5b3:\n        //   For a non-type template-parameter of type reference to\n        //   object, no conversions apply. The type referred to by the\n        //   reference may be more cv-qualified than the (otherwise\n        //   identical) type of the template- argument. The\n        //   template-parameter is bound directly to the\n        //   template-argument, which shall be an lvalue.\n\n        // FIXME: Other qualifiers?\n        unsigned ParamQuals = ParamRef->getPointeeType().getCVRQualifiers();\n        unsigned ArgQuals = ArgType.getCVRQualifiers();\n\n        if ((ParamQuals | ArgQuals) != ParamQuals) {\n          S.Diag(Arg->getBeginLoc(),\n                 diag::err_template_arg_ref_bind_ignores_quals)\n              << ParamType << Arg->getType() << Arg->getSourceRange();\n          S.Diag(Param->getLocation(), diag::note_template_param_here);\n          return true;\n        }\n      }\n    }\n\n    // At this point, the template argument refers to an object or\n    // function with external linkage. We now need to check whether the\n    // argument and parameter types are compatible.\n    if (!S.Context.hasSameUnqualifiedType(ArgType,\n                                          ParamType.getNonReferenceType())) {\n      // We can't perform this conversion or binding.\n      if (ParamType->isReferenceType())\n        S.Diag(Arg->getBeginLoc(), diag::err_template_arg_no_ref_bind)\n            << ParamType << ArgIn->getType() << Arg->getSourceRange();\n      else\n        S.Diag(Arg->getBeginLoc(), diag::err_template_arg_not_convertible)\n            << ArgIn->getType() << ParamType << Arg->getSourceRange();\n      S.Diag(Param->getLocation(), diag::note_template_param_here);\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/// Checks whether the given template argument is the address\n/// of an object or function according to C++ [temp.arg.nontype]p1.\nstatic bool\nCheckTemplateArgumentAddressOfObjectOrFunction(Sema &S,\n                                               NonTypeTemplateParmDecl *Param,\n                                               QualType ParamType,\n                                               Expr *ArgIn,\n                                               TemplateArgument &Converted) {\n  bool Invalid = false;\n  Expr *Arg = ArgIn;\n  QualType ArgType = Arg->getType();\n\n  bool AddressTaken = false;\n  SourceLocation AddrOpLoc;\n  if (S.getLangOpts().MicrosoftExt) {\n    // Microsoft Visual C++ strips all casts, allows an arbitrary number of\n    // dereference and address-of operators.\n    Arg = Arg->IgnoreParenCasts();\n\n    bool ExtWarnMSTemplateArg = false;\n    UnaryOperatorKind FirstOpKind;\n    SourceLocation FirstOpLoc;\n    while (UnaryOperator *UnOp = dyn_cast<UnaryOperator>(Arg)) {\n      UnaryOperatorKind UnOpKind = UnOp->getOpcode();\n      if (UnOpKind == UO_Deref)\n        ExtWarnMSTemplateArg = true;\n      if (UnOpKind == UO_AddrOf || UnOpKind == UO_Deref) {\n        Arg = UnOp->getSubExpr()->IgnoreParenCasts();\n        if (!AddrOpLoc.isValid()) {\n          FirstOpKind = UnOpKind;\n          FirstOpLoc = UnOp->getOperatorLoc();\n        }\n      } else\n        break;\n    }\n    if (FirstOpLoc.isValid()) {\n      if (ExtWarnMSTemplateArg)\n        S.Diag(ArgIn->getBeginLoc(), diag::ext_ms_deref_template_argument)\n            << ArgIn->getSourceRange();\n\n      if (FirstOpKind == UO_AddrOf)\n        AddressTaken = true;\n      else if (Arg->getType()->isPointerType()) {\n        // We cannot let pointers get dereferenced here, that is obviously not a\n        // constant expression.\n        assert(FirstOpKind == UO_Deref);\n        S.Diag(Arg->getBeginLoc(), diag::err_template_arg_not_decl_ref)\n            << Arg->getSourceRange();\n      }\n    }\n  } else {\n    // See through any implicit casts we added to fix the type.\n    Arg = Arg->IgnoreImpCasts();\n\n    // C++ [temp.arg.nontype]p1:\n    //\n    //   A template-argument for a non-type, non-template\n    //   template-parameter shall be one of: [...]\n    //\n    //     -- the address of an object or function with external\n    //        linkage, including function templates and function\n    //        template-ids but excluding non-static class members,\n    //        expressed as & id-expression where the & is optional if\n    //        the name refers to a function or array, or if the\n    //        corresponding template-parameter is a reference; or\n\n    // In C++98/03 mode, give an extension warning on any extra parentheses.\n    // See http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#773\n    bool ExtraParens = false;\n    while (ParenExpr *Parens = dyn_cast<ParenExpr>(Arg)) {\n      if (!Invalid && !ExtraParens) {\n        S.Diag(Arg->getBeginLoc(),\n               S.getLangOpts().CPlusPlus11\n                   ? diag::warn_cxx98_compat_template_arg_extra_parens\n                   : diag::ext_template_arg_extra_parens)\n            << Arg->getSourceRange();\n        ExtraParens = true;\n      }\n\n      Arg = Parens->getSubExpr();\n    }\n\n    while (SubstNonTypeTemplateParmExpr *subst =\n               dyn_cast<SubstNonTypeTemplateParmExpr>(Arg))\n      Arg = subst->getReplacement()->IgnoreImpCasts();\n\n    if (UnaryOperator *UnOp = dyn_cast<UnaryOperator>(Arg)) {\n      if (UnOp->getOpcode() == UO_AddrOf) {\n        Arg = UnOp->getSubExpr();\n        AddressTaken = true;\n        AddrOpLoc = UnOp->getOperatorLoc();\n      }\n    }\n\n    while (SubstNonTypeTemplateParmExpr *subst =\n               dyn_cast<SubstNonTypeTemplateParmExpr>(Arg))\n      Arg = subst->getReplacement()->IgnoreImpCasts();\n  }\n\n  ValueDecl *Entity = nullptr;\n  if (DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(Arg))\n    Entity = DRE->getDecl();\n  else if (CXXUuidofExpr *CUE = dyn_cast<CXXUuidofExpr>(Arg))\n    Entity = CUE->getGuidDecl();\n\n  // If our parameter has pointer type, check for a null template value.\n  if (ParamType->isPointerType() || ParamType->isNullPtrType()) {\n    switch (isNullPointerValueTemplateArgument(S, Param, ParamType, ArgIn,\n                                               Entity)) {\n    case NPV_NullPointer:\n      S.Diag(Arg->getExprLoc(), diag::warn_cxx98_compat_template_arg_null);\n      Converted = TemplateArgument(S.Context.getCanonicalType(ParamType),\n                                   /*isNullPtr=*/true);\n      return false;\n\n    case NPV_Error:\n      return true;\n\n    case NPV_NotNullPointer:\n      break;\n    }\n  }\n\n  // Stop checking the precise nature of the argument if it is value dependent,\n  // it should be checked when instantiated.\n  if (Arg->isValueDependent()) {\n    Converted = TemplateArgument(ArgIn);\n    return false;\n  }\n\n  if (!Entity) {\n    S.Diag(Arg->getBeginLoc(), diag::err_template_arg_not_decl_ref)\n        << Arg->getSourceRange();\n    S.Diag(Param->getLocation(), diag::note_template_param_here);\n    return true;\n  }\n\n  // Cannot refer to non-static data members\n  if (isa<FieldDecl>(Entity) || isa<IndirectFieldDecl>(Entity)) {\n    S.Diag(Arg->getBeginLoc(), diag::err_template_arg_field)\n        << Entity << Arg->getSourceRange();\n    S.Diag(Param->getLocation(), diag::note_template_param_here);\n    return true;\n  }\n\n  // Cannot refer to non-static member functions\n  if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(Entity)) {\n    if (!Method->isStatic()) {\n      S.Diag(Arg->getBeginLoc(), diag::err_template_arg_method)\n          << Method << Arg->getSourceRange();\n      S.Diag(Param->getLocation(), diag::note_template_param_here);\n      return true;\n    }\n  }\n\n  FunctionDecl *Func = dyn_cast<FunctionDecl>(Entity);\n  VarDecl *Var = dyn_cast<VarDecl>(Entity);\n  MSGuidDecl *Guid = dyn_cast<MSGuidDecl>(Entity);\n\n  // A non-type template argument must refer to an object or function.\n  if (!Func && !Var && !Guid) {\n    // We found something, but we don't know specifically what it is.\n    S.Diag(Arg->getBeginLoc(), diag::err_template_arg_not_object_or_func)\n        << Arg->getSourceRange();\n    S.Diag(Entity->getLocation(), diag::note_template_arg_refers_here);\n    return true;\n  }\n\n  // Address / reference template args must have external linkage in C++98.\n  if (Entity->getFormalLinkage() == InternalLinkage) {\n    S.Diag(Arg->getBeginLoc(),\n           S.getLangOpts().CPlusPlus11\n               ? diag::warn_cxx98_compat_template_arg_object_internal\n               : diag::ext_template_arg_object_internal)\n        << !Func << Entity << Arg->getSourceRange();\n    S.Diag(Entity->getLocation(), diag::note_template_arg_internal_object)\n      << !Func;\n  } else if (!Entity->hasLinkage()) {\n    S.Diag(Arg->getBeginLoc(), diag::err_template_arg_object_no_linkage)\n        << !Func << Entity << Arg->getSourceRange();\n    S.Diag(Entity->getLocation(), diag::note_template_arg_internal_object)\n      << !Func;\n    return true;\n  }\n\n  if (Var) {\n    // A value of reference type is not an object.\n    if (Var->getType()->isReferenceType()) {\n      S.Diag(Arg->getBeginLoc(), diag::err_template_arg_reference_var)\n          << Var->getType() << Arg->getSourceRange();\n      S.Diag(Param->getLocation(), diag::note_template_param_here);\n      return true;\n    }\n\n    // A template argument must have static storage duration.\n    if (Var->getTLSKind()) {\n      S.Diag(Arg->getBeginLoc(), diag::err_template_arg_thread_local)\n          << Arg->getSourceRange();\n      S.Diag(Var->getLocation(), diag::note_template_arg_refers_here);\n      return true;\n    }\n  }\n\n  if (AddressTaken && ParamType->isReferenceType()) {\n    // If we originally had an address-of operator, but the\n    // parameter has reference type, complain and (if things look\n    // like they will work) drop the address-of operator.\n    if (!S.Context.hasSameUnqualifiedType(Entity->getType(),\n                                          ParamType.getNonReferenceType())) {\n      S.Diag(AddrOpLoc, diag::err_template_arg_address_of_non_pointer)\n        << ParamType;\n      S.Diag(Param->getLocation(), diag::note_template_param_here);\n      return true;\n    }\n\n    S.Diag(AddrOpLoc, diag::err_template_arg_address_of_non_pointer)\n      << ParamType\n      << FixItHint::CreateRemoval(AddrOpLoc);\n    S.Diag(Param->getLocation(), diag::note_template_param_here);\n\n    ArgType = Entity->getType();\n  }\n\n  // If the template parameter has pointer type, either we must have taken the\n  // address or the argument must decay to a pointer.\n  if (!AddressTaken && ParamType->isPointerType()) {\n    if (Func) {\n      // Function-to-pointer decay.\n      ArgType = S.Context.getPointerType(Func->getType());\n    } else if (Entity->getType()->isArrayType()) {\n      // Array-to-pointer decay.\n      ArgType = S.Context.getArrayDecayedType(Entity->getType());\n    } else {\n      // If the template parameter has pointer type but the address of\n      // this object was not taken, complain and (possibly) recover by\n      // taking the address of the entity.\n      ArgType = S.Context.getPointerType(Entity->getType());\n      if (!S.Context.hasSameUnqualifiedType(ArgType, ParamType)) {\n        S.Diag(Arg->getBeginLoc(), diag::err_template_arg_not_address_of)\n          << ParamType;\n        S.Diag(Param->getLocation(), diag::note_template_param_here);\n        return true;\n      }\n\n      S.Diag(Arg->getBeginLoc(), diag::err_template_arg_not_address_of)\n        << ParamType << FixItHint::CreateInsertion(Arg->getBeginLoc(), \"&\");\n\n      S.Diag(Param->getLocation(), diag::note_template_param_here);\n    }\n  }\n\n  if (CheckTemplateArgumentIsCompatibleWithParameter(S, Param, ParamType, ArgIn,\n                                                     Arg, ArgType))\n    return true;\n\n  // Create the template argument.\n  Converted = TemplateArgument(cast<ValueDecl>(Entity->getCanonicalDecl()),\n                               S.Context.getCanonicalType(ParamType));\n  S.MarkAnyDeclReferenced(Arg->getBeginLoc(), Entity, false);\n  return false;\n}\n\n/// Checks whether the given template argument is a pointer to\n/// member constant according to C++ [temp.arg.nontype]p1.\nstatic bool CheckTemplateArgumentPointerToMember(Sema &S,\n                                                 NonTypeTemplateParmDecl *Param,\n                                                 QualType ParamType,\n                                                 Expr *&ResultArg,\n                                                 TemplateArgument &Converted) {\n  bool Invalid = false;\n\n  Expr *Arg = ResultArg;\n  bool ObjCLifetimeConversion;\n\n  // C++ [temp.arg.nontype]p1:\n  //\n  //   A template-argument for a non-type, non-template\n  //   template-parameter shall be one of: [...]\n  //\n  //     -- a pointer to member expressed as described in 5.3.1.\n  DeclRefExpr *DRE = nullptr;\n\n  // In C++98/03 mode, give an extension warning on any extra parentheses.\n  // See http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#773\n  bool ExtraParens = false;\n  while (ParenExpr *Parens = dyn_cast<ParenExpr>(Arg)) {\n    if (!Invalid && !ExtraParens) {\n      S.Diag(Arg->getBeginLoc(),\n             S.getLangOpts().CPlusPlus11\n                 ? diag::warn_cxx98_compat_template_arg_extra_parens\n                 : diag::ext_template_arg_extra_parens)\n          << Arg->getSourceRange();\n      ExtraParens = true;\n    }\n\n    Arg = Parens->getSubExpr();\n  }\n\n  while (SubstNonTypeTemplateParmExpr *subst =\n           dyn_cast<SubstNonTypeTemplateParmExpr>(Arg))\n    Arg = subst->getReplacement()->IgnoreImpCasts();\n\n  // A pointer-to-member constant written &Class::member.\n  if (UnaryOperator *UnOp = dyn_cast<UnaryOperator>(Arg)) {\n    if (UnOp->getOpcode() == UO_AddrOf) {\n      DRE = dyn_cast<DeclRefExpr>(UnOp->getSubExpr());\n      if (DRE && !DRE->getQualifier())\n        DRE = nullptr;\n    }\n  }\n  // A constant of pointer-to-member type.\n  else if ((DRE = dyn_cast<DeclRefExpr>(Arg))) {\n    ValueDecl *VD = DRE->getDecl();\n    if (VD->getType()->isMemberPointerType()) {\n      if (isa<NonTypeTemplateParmDecl>(VD)) {\n        if (Arg->isTypeDependent() || Arg->isValueDependent()) {\n          Converted = TemplateArgument(Arg);\n        } else {\n          VD = cast<ValueDecl>(VD->getCanonicalDecl());\n          Converted = TemplateArgument(VD, ParamType);\n        }\n        return Invalid;\n      }\n    }\n\n    DRE = nullptr;\n  }\n\n  ValueDecl *Entity = DRE ? DRE->getDecl() : nullptr;\n\n  // Check for a null pointer value.\n  switch (isNullPointerValueTemplateArgument(S, Param, ParamType, ResultArg,\n                                             Entity)) {\n  case NPV_Error:\n    return true;\n  case NPV_NullPointer:\n    S.Diag(ResultArg->getExprLoc(), diag::warn_cxx98_compat_template_arg_null);\n    Converted = TemplateArgument(S.Context.getCanonicalType(ParamType),\n                                 /*isNullPtr*/true);\n    return false;\n  case NPV_NotNullPointer:\n    break;\n  }\n\n  if (S.IsQualificationConversion(ResultArg->getType(),\n                                  ParamType.getNonReferenceType(), false,\n                                  ObjCLifetimeConversion)) {\n    ResultArg = S.ImpCastExprToType(ResultArg, ParamType, CK_NoOp,\n                                    ResultArg->getValueKind())\n                    .get();\n  } else if (!S.Context.hasSameUnqualifiedType(\n                 ResultArg->getType(), ParamType.getNonReferenceType())) {\n    // We can't perform this conversion.\n    S.Diag(ResultArg->getBeginLoc(), diag::err_template_arg_not_convertible)\n        << ResultArg->getType() << ParamType << ResultArg->getSourceRange();\n    S.Diag(Param->getLocation(), diag::note_template_param_here);\n    return true;\n  }\n\n  if (!DRE)\n    return S.Diag(Arg->getBeginLoc(),\n                  diag::err_template_arg_not_pointer_to_member_form)\n           << Arg->getSourceRange();\n\n  if (isa<FieldDecl>(DRE->getDecl()) ||\n      isa<IndirectFieldDecl>(DRE->getDecl()) ||\n      isa<CXXMethodDecl>(DRE->getDecl())) {\n    assert((isa<FieldDecl>(DRE->getDecl()) ||\n            isa<IndirectFieldDecl>(DRE->getDecl()) ||\n            !cast<CXXMethodDecl>(DRE->getDecl())->isStatic()) &&\n           \"Only non-static member pointers can make it here\");\n\n    // Okay: this is the address of a non-static member, and therefore\n    // a member pointer constant.\n    if (Arg->isTypeDependent() || Arg->isValueDependent()) {\n      Converted = TemplateArgument(Arg);\n    } else {\n      ValueDecl *D = cast<ValueDecl>(DRE->getDecl()->getCanonicalDecl());\n      Converted = TemplateArgument(D, S.Context.getCanonicalType(ParamType));\n    }\n    return Invalid;\n  }\n\n  // We found something else, but we don't know specifically what it is.\n  S.Diag(Arg->getBeginLoc(), diag::err_template_arg_not_pointer_to_member_form)\n      << Arg->getSourceRange();\n  S.Diag(DRE->getDecl()->getLocation(), diag::note_template_arg_refers_here);\n  return true;\n}\n\n/// Check a template argument against its corresponding\n/// non-type template parameter.\n///\n/// This routine implements the semantics of C++ [temp.arg.nontype].\n/// If an error occurred, it returns ExprError(); otherwise, it\n/// returns the converted template argument. \\p ParamType is the\n/// type of the non-type template parameter after it has been instantiated.\nExprResult Sema::CheckTemplateArgument(NonTypeTemplateParmDecl *Param,\n                                       QualType ParamType, Expr *Arg,\n                                       TemplateArgument &Converted,\n                                       CheckTemplateArgumentKind CTAK) {\n  SourceLocation StartLoc = Arg->getBeginLoc();\n\n  // If the parameter type somehow involves auto, deduce the type now.\n  DeducedType *DeducedT = ParamType->getContainedDeducedType();\n  if (getLangOpts().CPlusPlus17 && DeducedT && !DeducedT->isDeduced()) {\n    // During template argument deduction, we allow 'decltype(auto)' to\n    // match an arbitrary dependent argument.\n    // FIXME: The language rules don't say what happens in this case.\n    // FIXME: We get an opaque dependent type out of decltype(auto) if the\n    // expression is merely instantiation-dependent; is this enough?\n    if (CTAK == CTAK_Deduced && Arg->isTypeDependent()) {\n      auto *AT = dyn_cast<AutoType>(DeducedT);\n      if (AT && AT->isDecltypeAuto()) {\n        Converted = TemplateArgument(Arg);\n        return Arg;\n      }\n    }\n\n    // When checking a deduced template argument, deduce from its type even if\n    // the type is dependent, in order to check the types of non-type template\n    // arguments line up properly in partial ordering.\n    Optional<unsigned> Depth = Param->getDepth() + 1;\n    Expr *DeductionArg = Arg;\n    if (auto *PE = dyn_cast<PackExpansionExpr>(DeductionArg))\n      DeductionArg = PE->getPattern();\n    TypeSourceInfo *TSI =\n        Context.getTrivialTypeSourceInfo(ParamType, Param->getLocation());\n    if (isa<DeducedTemplateSpecializationType>(DeducedT)) {\n      InitializedEntity Entity =\n          InitializedEntity::InitializeTemplateParameter(ParamType, Param);\n      InitializationKind Kind = InitializationKind::CreateForInit(\n          DeductionArg->getBeginLoc(), /*DirectInit*/false, DeductionArg);\n      Expr *Inits[1] = {DeductionArg};\n      ParamType =\n          DeduceTemplateSpecializationFromInitializer(TSI, Entity, Kind, Inits);\n      if (ParamType.isNull())\n        return ExprError();\n    } else if (DeduceAutoType(\n                   TSI, DeductionArg, ParamType, Depth,\n                   // We do not check constraints right now because the\n                   // immediately-declared constraint of the auto type is also\n                   // an associated constraint, and will be checked along with\n                   // the other associated constraints after checking the\n                   // template argument list.\n                   /*IgnoreConstraints=*/true) == DAR_Failed) {\n      Diag(Arg->getExprLoc(),\n           diag::err_non_type_template_parm_type_deduction_failure)\n        << Param->getDeclName() << Param->getType() << Arg->getType()\n        << Arg->getSourceRange();\n      Diag(Param->getLocation(), diag::note_template_param_here);\n      return ExprError();\n    }\n    // CheckNonTypeTemplateParameterType will produce a diagnostic if there's\n    // an error. The error message normally references the parameter\n    // declaration, but here we'll pass the argument location because that's\n    // where the parameter type is deduced.\n    ParamType = CheckNonTypeTemplateParameterType(ParamType, Arg->getExprLoc());\n    if (ParamType.isNull()) {\n      Diag(Param->getLocation(), diag::note_template_param_here);\n      return ExprError();\n    }\n  }\n\n  // We should have already dropped all cv-qualifiers by now.\n  assert(!ParamType.hasQualifiers() &&\n         \"non-type template parameter type cannot be qualified\");\n\n  // FIXME: When Param is a reference, should we check that Arg is an lvalue?\n  if (CTAK == CTAK_Deduced &&\n      (ParamType->isReferenceType()\n           ? !Context.hasSameType(ParamType.getNonReferenceType(),\n                                  Arg->getType())\n           : !Context.hasSameUnqualifiedType(ParamType, Arg->getType()))) {\n    // FIXME: If either type is dependent, we skip the check. This isn't\n    // correct, since during deduction we're supposed to have replaced each\n    // template parameter with some unique (non-dependent) placeholder.\n    // FIXME: If the argument type contains 'auto', we carry on and fail the\n    // type check in order to force specific types to be more specialized than\n    // 'auto'. It's not clear how partial ordering with 'auto' is supposed to\n    // work. Similarly for CTAD, when comparing 'A<x>' against 'A'.\n    if ((ParamType->isDependentType() || Arg->isTypeDependent()) &&\n        !Arg->getType()->getContainedDeducedType()) {\n      Converted = TemplateArgument(Arg);\n      return Arg;\n    }\n    // FIXME: This attempts to implement C++ [temp.deduct.type]p17. Per DR1770,\n    // we should actually be checking the type of the template argument in P,\n    // not the type of the template argument deduced from A, against the\n    // template parameter type.\n    Diag(StartLoc, diag::err_deduced_non_type_template_arg_type_mismatch)\n      << Arg->getType()\n      << ParamType.getUnqualifiedType();\n    Diag(Param->getLocation(), diag::note_template_param_here);\n    return ExprError();\n  }\n\n  // If either the parameter has a dependent type or the argument is\n  // type-dependent, there's nothing we can check now. The argument only\n  // contains an unexpanded pack during partial ordering, and there's\n  // nothing more we can check in that case.\n  if (ParamType->isDependentType() || Arg->isTypeDependent() ||\n      Arg->containsUnexpandedParameterPack()) {\n    // Force the argument to the type of the parameter to maintain invariants.\n    auto *PE = dyn_cast<PackExpansionExpr>(Arg);\n    if (PE)\n      Arg = PE->getPattern();\n    ExprResult E = ImpCastExprToType(\n        Arg, ParamType.getNonLValueExprType(Context), CK_Dependent,\n        ParamType->isLValueReferenceType() ? VK_LValue :\n        ParamType->isRValueReferenceType() ? VK_XValue : VK_RValue);\n    if (E.isInvalid())\n      return ExprError();\n    if (PE) {\n      // Recreate a pack expansion if we unwrapped one.\n      E = new (Context)\n          PackExpansionExpr(E.get()->getType(), E.get(), PE->getEllipsisLoc(),\n                            PE->getNumExpansions());\n    }\n    Converted = TemplateArgument(E.get());\n    return E;\n  }\n\n  // The initialization of the parameter from the argument is\n  // a constant-evaluated context.\n  EnterExpressionEvaluationContext ConstantEvaluated(\n      *this, Sema::ExpressionEvaluationContext::ConstantEvaluated);\n\n  if (getLangOpts().CPlusPlus17) {\n    QualType CanonParamType = Context.getCanonicalType(ParamType);\n\n    // Avoid making a copy when initializing a template parameter of class type\n    // from a template parameter object of the same type. This is going beyond\n    // the standard, but is required for soundness: in\n    //   template<A a> struct X { X *p; X<a> *q; };\n    // ... we need p and q to have the same type.\n    //\n    // Similarly, don't inject a call to a copy constructor when initializing\n    // from a template parameter of the same type.\n    Expr *InnerArg = Arg->IgnoreParenImpCasts();\n    if (ParamType->isRecordType() && isa<DeclRefExpr>(InnerArg) &&\n        Context.hasSameUnqualifiedType(ParamType, InnerArg->getType())) {\n      NamedDecl *ND = cast<DeclRefExpr>(InnerArg)->getDecl();\n      if (auto *TPO = dyn_cast<TemplateParamObjectDecl>(ND)) {\n        Converted = TemplateArgument(TPO, CanonParamType);\n        return Arg;\n      }\n      if (isa<NonTypeTemplateParmDecl>(ND)) {\n        Converted = TemplateArgument(Arg);\n        return Arg;\n      }\n    }\n\n    // C++17 [temp.arg.nontype]p1:\n    //   A template-argument for a non-type template parameter shall be\n    //   a converted constant expression of the type of the template-parameter.\n    APValue Value;\n    ExprResult ArgResult = CheckConvertedConstantExpression(\n        Arg, ParamType, Value, CCEK_TemplateArg, Param);\n    if (ArgResult.isInvalid())\n      return ExprError();\n\n    // For a value-dependent argument, CheckConvertedConstantExpression is\n    // permitted (and expected) to be unable to determine a value.\n    if (ArgResult.get()->isValueDependent()) {\n      Converted = TemplateArgument(ArgResult.get());\n      return ArgResult;\n    }\n\n    // Convert the APValue to a TemplateArgument.\n    switch (Value.getKind()) {\n    case APValue::None:\n      assert(ParamType->isNullPtrType());\n      Converted = TemplateArgument(CanonParamType, /*isNullPtr*/true);\n      break;\n    case APValue::Indeterminate:\n      llvm_unreachable(\"result of constant evaluation should be initialized\");\n      break;\n    case APValue::Int:\n      assert(ParamType->isIntegralOrEnumerationType());\n      Converted = TemplateArgument(Context, Value.getInt(), CanonParamType);\n      break;\n    case APValue::MemberPointer: {\n      assert(ParamType->isMemberPointerType());\n\n      // FIXME: We need TemplateArgument representation and mangling for these.\n      if (!Value.getMemberPointerPath().empty()) {\n        Diag(Arg->getBeginLoc(),\n             diag::err_template_arg_member_ptr_base_derived_not_supported)\n            << Value.getMemberPointerDecl() << ParamType\n            << Arg->getSourceRange();\n        return ExprError();\n      }\n\n      auto *VD = const_cast<ValueDecl*>(Value.getMemberPointerDecl());\n      Converted = VD ? TemplateArgument(VD, CanonParamType)\n                     : TemplateArgument(CanonParamType, /*isNullPtr*/true);\n      break;\n    }\n    case APValue::LValue: {\n      //   For a non-type template-parameter of pointer or reference type,\n      //   the value of the constant expression shall not refer to\n      assert(ParamType->isPointerType() || ParamType->isReferenceType() ||\n             ParamType->isNullPtrType());\n      // -- a temporary object\n      // -- a string literal\n      // -- the result of a typeid expression, or\n      // -- a predefined __func__ variable\n      APValue::LValueBase Base = Value.getLValueBase();\n      auto *VD = const_cast<ValueDecl *>(Base.dyn_cast<const ValueDecl *>());\n      if (Base && (!VD || isa<LifetimeExtendedTemporaryDecl>(VD))) {\n        Diag(Arg->getBeginLoc(), diag::err_template_arg_not_decl_ref)\n            << Arg->getSourceRange();\n        return ExprError();\n      }\n      // -- a subobject\n      // FIXME: Until C++20\n      if (Value.hasLValuePath() && Value.getLValuePath().size() == 1 &&\n          VD && VD->getType()->isArrayType() &&\n          Value.getLValuePath()[0].getAsArrayIndex() == 0 &&\n          !Value.isLValueOnePastTheEnd() && ParamType->isPointerType()) {\n        // Per defect report (no number yet):\n        //   ... other than a pointer to the first element of a complete array\n        //       object.\n      } else if (!Value.hasLValuePath() || Value.getLValuePath().size() ||\n                 Value.isLValueOnePastTheEnd()) {\n        Diag(StartLoc, diag::err_non_type_template_arg_subobject)\n          << Value.getAsString(Context, ParamType);\n        return ExprError();\n      }\n      assert((VD || !ParamType->isReferenceType()) &&\n             \"null reference should not be a constant expression\");\n      assert((!VD || !ParamType->isNullPtrType()) &&\n             \"non-null value of type nullptr_t?\");\n      Converted = VD ? TemplateArgument(VD, CanonParamType)\n                     : TemplateArgument(CanonParamType, /*isNullPtr*/true);\n      break;\n    }\n    case APValue::Struct:\n    case APValue::Union:\n      // Get or create the corresponding template parameter object.\n      Converted = TemplateArgument(\n          Context.getTemplateParamObjectDecl(CanonParamType, Value),\n          CanonParamType);\n      break;\n    case APValue::AddrLabelDiff:\n      return Diag(StartLoc, diag::err_non_type_template_arg_addr_label_diff);\n    case APValue::FixedPoint:\n    case APValue::Float:\n    case APValue::ComplexInt:\n    case APValue::ComplexFloat:\n    case APValue::Vector:\n    case APValue::Array:\n      return Diag(StartLoc, diag::err_non_type_template_arg_unsupported)\n             << ParamType;\n    }\n\n    return ArgResult.get();\n  }\n\n  // C++ [temp.arg.nontype]p5:\n  //   The following conversions are performed on each expression used\n  //   as a non-type template-argument. If a non-type\n  //   template-argument cannot be converted to the type of the\n  //   corresponding template-parameter then the program is\n  //   ill-formed.\n  if (ParamType->isIntegralOrEnumerationType()) {\n    // C++11:\n    //   -- for a non-type template-parameter of integral or\n    //      enumeration type, conversions permitted in a converted\n    //      constant expression are applied.\n    //\n    // C++98:\n    //   -- for a non-type template-parameter of integral or\n    //      enumeration type, integral promotions (4.5) and integral\n    //      conversions (4.7) are applied.\n\n    if (getLangOpts().CPlusPlus11) {\n      // C++ [temp.arg.nontype]p1:\n      //   A template-argument for a non-type, non-template template-parameter\n      //   shall be one of:\n      //\n      //     -- for a non-type template-parameter of integral or enumeration\n      //        type, a converted constant expression of the type of the\n      //        template-parameter; or\n      llvm::APSInt Value;\n      ExprResult ArgResult =\n        CheckConvertedConstantExpression(Arg, ParamType, Value,\n                                         CCEK_TemplateArg);\n      if (ArgResult.isInvalid())\n        return ExprError();\n\n      // We can't check arbitrary value-dependent arguments.\n      if (ArgResult.get()->isValueDependent()) {\n        Converted = TemplateArgument(ArgResult.get());\n        return ArgResult;\n      }\n\n      // Widen the argument value to sizeof(parameter type). This is almost\n      // always a no-op, except when the parameter type is bool. In\n      // that case, this may extend the argument from 1 bit to 8 bits.\n      QualType IntegerType = ParamType;\n      if (const EnumType *Enum = IntegerType->getAs<EnumType>())\n        IntegerType = Enum->getDecl()->getIntegerType();\n      Value = Value.extOrTrunc(IntegerType->isExtIntType()\n                                   ? Context.getIntWidth(IntegerType)\n                                   : Context.getTypeSize(IntegerType));\n\n      Converted = TemplateArgument(Context, Value,\n                                   Context.getCanonicalType(ParamType));\n      return ArgResult;\n    }\n\n    ExprResult ArgResult = DefaultLvalueConversion(Arg);\n    if (ArgResult.isInvalid())\n      return ExprError();\n    Arg = ArgResult.get();\n\n    QualType ArgType = Arg->getType();\n\n    // C++ [temp.arg.nontype]p1:\n    //   A template-argument for a non-type, non-template\n    //   template-parameter shall be one of:\n    //\n    //     -- an integral constant-expression of integral or enumeration\n    //        type; or\n    //     -- the name of a non-type template-parameter; or\n    llvm::APSInt Value;\n    if (!ArgType->isIntegralOrEnumerationType()) {\n      Diag(Arg->getBeginLoc(), diag::err_template_arg_not_integral_or_enumeral)\n          << ArgType << Arg->getSourceRange();\n      Diag(Param->getLocation(), diag::note_template_param_here);\n      return ExprError();\n    } else if (!Arg->isValueDependent()) {\n      class TmplArgICEDiagnoser : public VerifyICEDiagnoser {\n        QualType T;\n\n      public:\n        TmplArgICEDiagnoser(QualType T) : T(T) { }\n\n        SemaDiagnosticBuilder diagnoseNotICE(Sema &S,\n                                             SourceLocation Loc) override {\n          return S.Diag(Loc, diag::err_template_arg_not_ice) << T;\n        }\n      } Diagnoser(ArgType);\n\n      Arg = VerifyIntegerConstantExpression(Arg, &Value, Diagnoser).get();\n      if (!Arg)\n        return ExprError();\n    }\n\n    // From here on out, all we care about is the unqualified form\n    // of the argument type.\n    ArgType = ArgType.getUnqualifiedType();\n\n    // Try to convert the argument to the parameter's type.\n    if (Context.hasSameType(ParamType, ArgType)) {\n      // Okay: no conversion necessary\n    } else if (ParamType->isBooleanType()) {\n      // This is an integral-to-boolean conversion.\n      Arg = ImpCastExprToType(Arg, ParamType, CK_IntegralToBoolean).get();\n    } else if (IsIntegralPromotion(Arg, ArgType, ParamType) ||\n               !ParamType->isEnumeralType()) {\n      // This is an integral promotion or conversion.\n      Arg = ImpCastExprToType(Arg, ParamType, CK_IntegralCast).get();\n    } else {\n      // We can't perform this conversion.\n      Diag(Arg->getBeginLoc(), diag::err_template_arg_not_convertible)\n          << Arg->getType() << ParamType << Arg->getSourceRange();\n      Diag(Param->getLocation(), diag::note_template_param_here);\n      return ExprError();\n    }\n\n    // Add the value of this argument to the list of converted\n    // arguments. We use the bitwidth and signedness of the template\n    // parameter.\n    if (Arg->isValueDependent()) {\n      // The argument is value-dependent. Create a new\n      // TemplateArgument with the converted expression.\n      Converted = TemplateArgument(Arg);\n      return Arg;\n    }\n\n    QualType IntegerType = Context.getCanonicalType(ParamType);\n    if (const EnumType *Enum = IntegerType->getAs<EnumType>())\n      IntegerType = Context.getCanonicalType(Enum->getDecl()->getIntegerType());\n\n    if (ParamType->isBooleanType()) {\n      // Value must be zero or one.\n      Value = Value != 0;\n      unsigned AllowedBits = Context.getTypeSize(IntegerType);\n      if (Value.getBitWidth() != AllowedBits)\n        Value = Value.extOrTrunc(AllowedBits);\n      Value.setIsSigned(IntegerType->isSignedIntegerOrEnumerationType());\n    } else {\n      llvm::APSInt OldValue = Value;\n\n      // Coerce the template argument's value to the value it will have\n      // based on the template parameter's type.\n      unsigned AllowedBits = IntegerType->isExtIntType()\n                                 ? Context.getIntWidth(IntegerType)\n                                 : Context.getTypeSize(IntegerType);\n      if (Value.getBitWidth() != AllowedBits)\n        Value = Value.extOrTrunc(AllowedBits);\n      Value.setIsSigned(IntegerType->isSignedIntegerOrEnumerationType());\n\n      // Complain if an unsigned parameter received a negative value.\n      if (IntegerType->isUnsignedIntegerOrEnumerationType()\n               && (OldValue.isSigned() && OldValue.isNegative())) {\n        Diag(Arg->getBeginLoc(), diag::warn_template_arg_negative)\n            << OldValue.toString(10) << Value.toString(10) << Param->getType()\n            << Arg->getSourceRange();\n        Diag(Param->getLocation(), diag::note_template_param_here);\n      }\n\n      // Complain if we overflowed the template parameter's type.\n      unsigned RequiredBits;\n      if (IntegerType->isUnsignedIntegerOrEnumerationType())\n        RequiredBits = OldValue.getActiveBits();\n      else if (OldValue.isUnsigned())\n        RequiredBits = OldValue.getActiveBits() + 1;\n      else\n        RequiredBits = OldValue.getMinSignedBits();\n      if (RequiredBits > AllowedBits) {\n        Diag(Arg->getBeginLoc(), diag::warn_template_arg_too_large)\n            << OldValue.toString(10) << Value.toString(10) << Param->getType()\n            << Arg->getSourceRange();\n        Diag(Param->getLocation(), diag::note_template_param_here);\n      }\n    }\n\n    Converted = TemplateArgument(Context, Value,\n                                 ParamType->isEnumeralType()\n                                   ? Context.getCanonicalType(ParamType)\n                                   : IntegerType);\n    return Arg;\n  }\n\n  QualType ArgType = Arg->getType();\n  DeclAccessPair FoundResult; // temporary for ResolveOverloadedFunction\n\n  // Handle pointer-to-function, reference-to-function, and\n  // pointer-to-member-function all in (roughly) the same way.\n  if (// -- For a non-type template-parameter of type pointer to\n      //    function, only the function-to-pointer conversion (4.3) is\n      //    applied. If the template-argument represents a set of\n      //    overloaded functions (or a pointer to such), the matching\n      //    function is selected from the set (13.4).\n      (ParamType->isPointerType() &&\n       ParamType->castAs<PointerType>()->getPointeeType()->isFunctionType()) ||\n      // -- For a non-type template-parameter of type reference to\n      //    function, no conversions apply. If the template-argument\n      //    represents a set of overloaded functions, the matching\n      //    function is selected from the set (13.4).\n      (ParamType->isReferenceType() &&\n       ParamType->castAs<ReferenceType>()->getPointeeType()->isFunctionType()) ||\n      // -- For a non-type template-parameter of type pointer to\n      //    member function, no conversions apply. If the\n      //    template-argument represents a set of overloaded member\n      //    functions, the matching member function is selected from\n      //    the set (13.4).\n      (ParamType->isMemberPointerType() &&\n       ParamType->castAs<MemberPointerType>()->getPointeeType()\n         ->isFunctionType())) {\n\n    if (Arg->getType() == Context.OverloadTy) {\n      if (FunctionDecl *Fn = ResolveAddressOfOverloadedFunction(Arg, ParamType,\n                                                                true,\n                                                                FoundResult)) {\n        if (DiagnoseUseOfDecl(Fn, Arg->getBeginLoc()))\n          return ExprError();\n\n        Arg = FixOverloadedFunctionReference(Arg, FoundResult, Fn);\n        ArgType = Arg->getType();\n      } else\n        return ExprError();\n    }\n\n    if (!ParamType->isMemberPointerType()) {\n      if (CheckTemplateArgumentAddressOfObjectOrFunction(*this, Param,\n                                                         ParamType,\n                                                         Arg, Converted))\n        return ExprError();\n      return Arg;\n    }\n\n    if (CheckTemplateArgumentPointerToMember(*this, Param, ParamType, Arg,\n                                             Converted))\n      return ExprError();\n    return Arg;\n  }\n\n  if (ParamType->isPointerType()) {\n    //   -- for a non-type template-parameter of type pointer to\n    //      object, qualification conversions (4.4) and the\n    //      array-to-pointer conversion (4.2) are applied.\n    // C++0x also allows a value of std::nullptr_t.\n    assert(ParamType->getPointeeType()->isIncompleteOrObjectType() &&\n           \"Only object pointers allowed here\");\n\n    if (CheckTemplateArgumentAddressOfObjectOrFunction(*this, Param,\n                                                       ParamType,\n                                                       Arg, Converted))\n      return ExprError();\n    return Arg;\n  }\n\n  if (const ReferenceType *ParamRefType = ParamType->getAs<ReferenceType>()) {\n    //   -- For a non-type template-parameter of type reference to\n    //      object, no conversions apply. The type referred to by the\n    //      reference may be more cv-qualified than the (otherwise\n    //      identical) type of the template-argument. The\n    //      template-parameter is bound directly to the\n    //      template-argument, which must be an lvalue.\n    assert(ParamRefType->getPointeeType()->isIncompleteOrObjectType() &&\n           \"Only object references allowed here\");\n\n    if (Arg->getType() == Context.OverloadTy) {\n      if (FunctionDecl *Fn = ResolveAddressOfOverloadedFunction(Arg,\n                                                 ParamRefType->getPointeeType(),\n                                                                true,\n                                                                FoundResult)) {\n        if (DiagnoseUseOfDecl(Fn, Arg->getBeginLoc()))\n          return ExprError();\n\n        Arg = FixOverloadedFunctionReference(Arg, FoundResult, Fn);\n        ArgType = Arg->getType();\n      } else\n        return ExprError();\n    }\n\n    if (CheckTemplateArgumentAddressOfObjectOrFunction(*this, Param,\n                                                       ParamType,\n                                                       Arg, Converted))\n      return ExprError();\n    return Arg;\n  }\n\n  // Deal with parameters of type std::nullptr_t.\n  if (ParamType->isNullPtrType()) {\n    if (Arg->isTypeDependent() || Arg->isValueDependent()) {\n      Converted = TemplateArgument(Arg);\n      return Arg;\n    }\n\n    switch (isNullPointerValueTemplateArgument(*this, Param, ParamType, Arg)) {\n    case NPV_NotNullPointer:\n      Diag(Arg->getExprLoc(), diag::err_template_arg_not_convertible)\n        << Arg->getType() << ParamType;\n      Diag(Param->getLocation(), diag::note_template_param_here);\n      return ExprError();\n\n    case NPV_Error:\n      return ExprError();\n\n    case NPV_NullPointer:\n      Diag(Arg->getExprLoc(), diag::warn_cxx98_compat_template_arg_null);\n      Converted = TemplateArgument(Context.getCanonicalType(ParamType),\n                                   /*isNullPtr*/true);\n      return Arg;\n    }\n  }\n\n  //     -- For a non-type template-parameter of type pointer to data\n  //        member, qualification conversions (4.4) are applied.\n  assert(ParamType->isMemberPointerType() && \"Only pointers to members remain\");\n\n  if (CheckTemplateArgumentPointerToMember(*this, Param, ParamType, Arg,\n                                           Converted))\n    return ExprError();\n  return Arg;\n}\n\nstatic void DiagnoseTemplateParameterListArityMismatch(\n    Sema &S, TemplateParameterList *New, TemplateParameterList *Old,\n    Sema::TemplateParameterListEqualKind Kind, SourceLocation TemplateArgLoc);\n\n/// Check a template argument against its corresponding\n/// template template parameter.\n///\n/// This routine implements the semantics of C++ [temp.arg.template].\n/// It returns true if an error occurred, and false otherwise.\nbool Sema::CheckTemplateTemplateArgument(TemplateTemplateParmDecl *Param,\n                                         TemplateParameterList *Params,\n                                         TemplateArgumentLoc &Arg) {\n  TemplateName Name = Arg.getArgument().getAsTemplateOrTemplatePattern();\n  TemplateDecl *Template = Name.getAsTemplateDecl();\n  if (!Template) {\n    // Any dependent template name is fine.\n    assert(Name.isDependent() && \"Non-dependent template isn't a declaration?\");\n    return false;\n  }\n\n  if (Template->isInvalidDecl())\n    return true;\n\n  // C++0x [temp.arg.template]p1:\n  //   A template-argument for a template template-parameter shall be\n  //   the name of a class template or an alias template, expressed as an\n  //   id-expression. When the template-argument names a class template, only\n  //   primary class templates are considered when matching the\n  //   template template argument with the corresponding parameter;\n  //   partial specializations are not considered even if their\n  //   parameter lists match that of the template template parameter.\n  //\n  // Note that we also allow template template parameters here, which\n  // will happen when we are dealing with, e.g., class template\n  // partial specializations.\n  if (!isa<ClassTemplateDecl>(Template) &&\n      !isa<TemplateTemplateParmDecl>(Template) &&\n      !isa<TypeAliasTemplateDecl>(Template) &&\n      !isa<BuiltinTemplateDecl>(Template)) {\n    assert(isa<FunctionTemplateDecl>(Template) &&\n           \"Only function templates are possible here\");\n    Diag(Arg.getLocation(), diag::err_template_arg_not_valid_template);\n    Diag(Template->getLocation(), diag::note_template_arg_refers_here_func)\n      << Template;\n  }\n\n  // C++1z [temp.arg.template]p3: (DR 150)\n  //   A template-argument matches a template template-parameter P when P\n  //   is at least as specialized as the template-argument A.\n  // FIXME: We should enable RelaxedTemplateTemplateArgs by default as it is a\n  //  defect report resolution from C++17 and shouldn't be introduced by\n  //  concepts.\n  if (getLangOpts().RelaxedTemplateTemplateArgs) {\n    // Quick check for the common case:\n    //   If P contains a parameter pack, then A [...] matches P if each of A's\n    //   template parameters matches the corresponding template parameter in\n    //   the template-parameter-list of P.\n    if (TemplateParameterListsAreEqual(\n            Template->getTemplateParameters(), Params, false,\n            TPL_TemplateTemplateArgumentMatch, Arg.getLocation()) &&\n        // If the argument has no associated constraints, then the parameter is\n        // definitely at least as specialized as the argument.\n        // Otherwise - we need a more thorough check.\n        !Template->hasAssociatedConstraints())\n      return false;\n\n    if (isTemplateTemplateParameterAtLeastAsSpecializedAs(Params, Template,\n                                                          Arg.getLocation())) {\n      // C++2a[temp.func.order]p2\n      //   [...] If both deductions succeed, the partial ordering selects the\n      //   more constrained template as described by the rules in\n      //   [temp.constr.order].\n      SmallVector<const Expr *, 3> ParamsAC, TemplateAC;\n      Params->getAssociatedConstraints(ParamsAC);\n      // C++2a[temp.arg.template]p3\n      //   [...] In this comparison, if P is unconstrained, the constraints on A\n      //   are not considered.\n      if (ParamsAC.empty())\n        return false;\n      Template->getAssociatedConstraints(TemplateAC);\n      bool IsParamAtLeastAsConstrained;\n      if (IsAtLeastAsConstrained(Param, ParamsAC, Template, TemplateAC,\n                                 IsParamAtLeastAsConstrained))\n        return true;\n      if (!IsParamAtLeastAsConstrained) {\n        Diag(Arg.getLocation(),\n             diag::err_template_template_parameter_not_at_least_as_constrained)\n            << Template << Param << Arg.getSourceRange();\n        Diag(Param->getLocation(), diag::note_entity_declared_at) << Param;\n        Diag(Template->getLocation(), diag::note_entity_declared_at)\n            << Template;\n        MaybeEmitAmbiguousAtomicConstraintsDiagnostic(Param, ParamsAC, Template,\n                                                      TemplateAC);\n        return true;\n      }\n      return false;\n    }\n    // FIXME: Produce better diagnostics for deduction failures.\n  }\n\n  return !TemplateParameterListsAreEqual(Template->getTemplateParameters(),\n                                         Params,\n                                         true,\n                                         TPL_TemplateTemplateArgumentMatch,\n                                         Arg.getLocation());\n}\n\n/// Given a non-type template argument that refers to a\n/// declaration and the type of its corresponding non-type template\n/// parameter, produce an expression that properly refers to that\n/// declaration.\nExprResult\nSema::BuildExpressionFromDeclTemplateArgument(const TemplateArgument &Arg,\n                                              QualType ParamType,\n                                              SourceLocation Loc) {\n  // C++ [temp.param]p8:\n  //\n  //   A non-type template-parameter of type \"array of T\" or\n  //   \"function returning T\" is adjusted to be of type \"pointer to\n  //   T\" or \"pointer to function returning T\", respectively.\n  if (ParamType->isArrayType())\n    ParamType = Context.getArrayDecayedType(ParamType);\n  else if (ParamType->isFunctionType())\n    ParamType = Context.getPointerType(ParamType);\n\n  // For a NULL non-type template argument, return nullptr casted to the\n  // parameter's type.\n  if (Arg.getKind() == TemplateArgument::NullPtr) {\n    return ImpCastExprToType(\n             new (Context) CXXNullPtrLiteralExpr(Context.NullPtrTy, Loc),\n                             ParamType,\n                             ParamType->getAs<MemberPointerType>()\n                               ? CK_NullToMemberPointer\n                               : CK_NullToPointer);\n  }\n  assert(Arg.getKind() == TemplateArgument::Declaration &&\n         \"Only declaration template arguments permitted here\");\n\n  ValueDecl *VD = Arg.getAsDecl();\n\n  CXXScopeSpec SS;\n  if (ParamType->isMemberPointerType()) {\n    // If this is a pointer to member, we need to use a qualified name to\n    // form a suitable pointer-to-member constant.\n    assert(VD->getDeclContext()->isRecord() &&\n           (isa<CXXMethodDecl>(VD) || isa<FieldDecl>(VD) ||\n            isa<IndirectFieldDecl>(VD)));\n    QualType ClassType\n      = Context.getTypeDeclType(cast<RecordDecl>(VD->getDeclContext()));\n    NestedNameSpecifier *Qualifier\n      = NestedNameSpecifier::Create(Context, nullptr, false,\n                                    ClassType.getTypePtr());\n    SS.MakeTrivial(Context, Qualifier, Loc);\n  }\n\n  ExprResult RefExpr = BuildDeclarationNameExpr(\n      SS, DeclarationNameInfo(VD->getDeclName(), Loc), VD);\n  if (RefExpr.isInvalid())\n    return ExprError();\n\n  // For a pointer, the argument declaration is the pointee. Take its address.\n  QualType ElemT(RefExpr.get()->getType()->getArrayElementTypeNoTypeQual(), 0);\n  if (ParamType->isPointerType() && !ElemT.isNull() &&\n      Context.hasSimilarType(ElemT, ParamType->getPointeeType())) {\n    // Decay an array argument if we want a pointer to its first element.\n    RefExpr = DefaultFunctionArrayConversion(RefExpr.get());\n    if (RefExpr.isInvalid())\n      return ExprError();\n  } else if (ParamType->isPointerType() || ParamType->isMemberPointerType()) {\n    // For any other pointer, take the address (or form a pointer-to-member).\n    RefExpr = CreateBuiltinUnaryOp(Loc, UO_AddrOf, RefExpr.get());\n    if (RefExpr.isInvalid())\n      return ExprError();\n  } else if (ParamType->isRecordType()) {\n    assert(isa<TemplateParamObjectDecl>(VD) &&\n           \"arg for class template param not a template parameter object\");\n    // No conversions apply in this case.\n    return RefExpr;\n  } else {\n    assert(ParamType->isReferenceType() &&\n           \"unexpected type for decl template argument\");\n  }\n\n  // At this point we should have the right value category.\n  assert(ParamType->isReferenceType() == RefExpr.get()->isLValue() &&\n         \"value kind mismatch for non-type template argument\");\n\n  // The type of the template parameter can differ from the type of the\n  // argument in various ways; convert it now if necessary.\n  QualType DestExprType = ParamType.getNonLValueExprType(Context);\n  if (!Context.hasSameType(RefExpr.get()->getType(), DestExprType)) {\n    CastKind CK;\n    QualType Ignored;\n    if (Context.hasSimilarType(RefExpr.get()->getType(), DestExprType) ||\n        IsFunctionConversion(RefExpr.get()->getType(), DestExprType, Ignored)) {\n      CK = CK_NoOp;\n    } else if (ParamType->isVoidPointerType() &&\n               RefExpr.get()->getType()->isPointerType()) {\n      CK = CK_BitCast;\n    } else {\n      // FIXME: Pointers to members can need conversion derived-to-base or\n      // base-to-derived conversions. We currently don't retain enough\n      // information to convert properly (we need to track a cast path or\n      // subobject number in the template argument).\n      llvm_unreachable(\n          \"unexpected conversion required for non-type template argument\");\n    }\n    RefExpr = ImpCastExprToType(RefExpr.get(), DestExprType, CK,\n                                RefExpr.get()->getValueKind());\n  }\n\n  return RefExpr;\n}\n\n/// Construct a new expression that refers to the given\n/// integral template argument with the given source-location\n/// information.\n///\n/// This routine takes care of the mapping from an integral template\n/// argument (which may have any integral type) to the appropriate\n/// literal value.\nExprResult\nSema::BuildExpressionFromIntegralTemplateArgument(const TemplateArgument &Arg,\n                                                  SourceLocation Loc) {\n  assert(Arg.getKind() == TemplateArgument::Integral &&\n         \"Operation is only valid for integral template arguments\");\n  QualType OrigT = Arg.getIntegralType();\n\n  // If this is an enum type that we're instantiating, we need to use an integer\n  // type the same size as the enumerator.  We don't want to build an\n  // IntegerLiteral with enum type.  The integer type of an enum type can be of\n  // any integral type with C++11 enum classes, make sure we create the right\n  // type of literal for it.\n  QualType T = OrigT;\n  if (const EnumType *ET = OrigT->getAs<EnumType>())\n    T = ET->getDecl()->getIntegerType();\n\n  Expr *E;\n  if (T->isAnyCharacterType()) {\n    CharacterLiteral::CharacterKind Kind;\n    if (T->isWideCharType())\n      Kind = CharacterLiteral::Wide;\n    else if (T->isChar8Type() && getLangOpts().Char8)\n      Kind = CharacterLiteral::UTF8;\n    else if (T->isChar16Type())\n      Kind = CharacterLiteral::UTF16;\n    else if (T->isChar32Type())\n      Kind = CharacterLiteral::UTF32;\n    else\n      Kind = CharacterLiteral::Ascii;\n\n    E = new (Context) CharacterLiteral(Arg.getAsIntegral().getZExtValue(),\n                                       Kind, T, Loc);\n  } else if (T->isBooleanType()) {\n    E = new (Context) CXXBoolLiteralExpr(Arg.getAsIntegral().getBoolValue(),\n                                         T, Loc);\n  } else if (T->isNullPtrType()) {\n    E = new (Context) CXXNullPtrLiteralExpr(Context.NullPtrTy, Loc);\n  } else {\n    E = IntegerLiteral::Create(Context, Arg.getAsIntegral(), T, Loc);\n  }\n\n  if (OrigT->isEnumeralType()) {\n    // FIXME: This is a hack. We need a better way to handle substituted\n    // non-type template parameters.\n    E = CStyleCastExpr::Create(Context, OrigT, VK_RValue, CK_IntegralCast, E,\n                               nullptr, CurFPFeatureOverrides(),\n                               Context.getTrivialTypeSourceInfo(OrigT, Loc),\n                               Loc, Loc);\n  }\n\n  return E;\n}\n\n/// Match two template parameters within template parameter lists.\nstatic bool MatchTemplateParameterKind(Sema &S, NamedDecl *New, NamedDecl *Old,\n                                       bool Complain,\n                                     Sema::TemplateParameterListEqualKind Kind,\n                                       SourceLocation TemplateArgLoc) {\n  // Check the actual kind (type, non-type, template).\n  if (Old->getKind() != New->getKind()) {\n    if (Complain) {\n      unsigned NextDiag = diag::err_template_param_different_kind;\n      if (TemplateArgLoc.isValid()) {\n        S.Diag(TemplateArgLoc, diag::err_template_arg_template_params_mismatch);\n        NextDiag = diag::note_template_param_different_kind;\n      }\n      S.Diag(New->getLocation(), NextDiag)\n        << (Kind != Sema::TPL_TemplateMatch);\n      S.Diag(Old->getLocation(), diag::note_template_prev_declaration)\n        << (Kind != Sema::TPL_TemplateMatch);\n    }\n\n    return false;\n  }\n\n  // Check that both are parameter packs or neither are parameter packs.\n  // However, if we are matching a template template argument to a\n  // template template parameter, the template template parameter can have\n  // a parameter pack where the template template argument does not.\n  if (Old->isTemplateParameterPack() != New->isTemplateParameterPack() &&\n      !(Kind == Sema::TPL_TemplateTemplateArgumentMatch &&\n        Old->isTemplateParameterPack())) {\n    if (Complain) {\n      unsigned NextDiag = diag::err_template_parameter_pack_non_pack;\n      if (TemplateArgLoc.isValid()) {\n        S.Diag(TemplateArgLoc,\n             diag::err_template_arg_template_params_mismatch);\n        NextDiag = diag::note_template_parameter_pack_non_pack;\n      }\n\n      unsigned ParamKind = isa<TemplateTypeParmDecl>(New)? 0\n                      : isa<NonTypeTemplateParmDecl>(New)? 1\n                      : 2;\n      S.Diag(New->getLocation(), NextDiag)\n        << ParamKind << New->isParameterPack();\n      S.Diag(Old->getLocation(), diag::note_template_parameter_pack_here)\n        << ParamKind << Old->isParameterPack();\n    }\n\n    return false;\n  }\n\n  // For non-type template parameters, check the type of the parameter.\n  if (NonTypeTemplateParmDecl *OldNTTP\n                                    = dyn_cast<NonTypeTemplateParmDecl>(Old)) {\n    NonTypeTemplateParmDecl *NewNTTP = cast<NonTypeTemplateParmDecl>(New);\n\n    // If we are matching a template template argument to a template\n    // template parameter and one of the non-type template parameter types\n    // is dependent, then we must wait until template instantiation time\n    // to actually compare the arguments.\n    if (Kind != Sema::TPL_TemplateTemplateArgumentMatch ||\n        (!OldNTTP->getType()->isDependentType() &&\n         !NewNTTP->getType()->isDependentType()))\n      if (!S.Context.hasSameType(OldNTTP->getType(), NewNTTP->getType())) {\n        if (Complain) {\n          unsigned NextDiag = diag::err_template_nontype_parm_different_type;\n          if (TemplateArgLoc.isValid()) {\n            S.Diag(TemplateArgLoc,\n                   diag::err_template_arg_template_params_mismatch);\n            NextDiag = diag::note_template_nontype_parm_different_type;\n          }\n          S.Diag(NewNTTP->getLocation(), NextDiag)\n            << NewNTTP->getType()\n            << (Kind != Sema::TPL_TemplateMatch);\n          S.Diag(OldNTTP->getLocation(),\n                 diag::note_template_nontype_parm_prev_declaration)\n            << OldNTTP->getType();\n        }\n\n        return false;\n      }\n  }\n  // For template template parameters, check the template parameter types.\n  // The template parameter lists of template template\n  // parameters must agree.\n  else if (TemplateTemplateParmDecl *OldTTP\n                                    = dyn_cast<TemplateTemplateParmDecl>(Old)) {\n    TemplateTemplateParmDecl *NewTTP = cast<TemplateTemplateParmDecl>(New);\n    if (!S.TemplateParameterListsAreEqual(NewTTP->getTemplateParameters(),\n                                          OldTTP->getTemplateParameters(),\n                                          Complain,\n                                        (Kind == Sema::TPL_TemplateMatch\n                                           ? Sema::TPL_TemplateTemplateParmMatch\n                                           : Kind),\n                                          TemplateArgLoc))\n      return false;\n  } else if (Kind != Sema::TPL_TemplateTemplateArgumentMatch) {\n    const Expr *NewC = nullptr, *OldC = nullptr;\n    if (const auto *TC = cast<TemplateTypeParmDecl>(New)->getTypeConstraint())\n      NewC = TC->getImmediatelyDeclaredConstraint();\n    if (const auto *TC = cast<TemplateTypeParmDecl>(Old)->getTypeConstraint())\n      OldC = TC->getImmediatelyDeclaredConstraint();\n\n    auto Diagnose = [&] {\n      S.Diag(NewC ? NewC->getBeginLoc() : New->getBeginLoc(),\n           diag::err_template_different_type_constraint);\n      S.Diag(OldC ? OldC->getBeginLoc() : Old->getBeginLoc(),\n           diag::note_template_prev_declaration) << /*declaration*/0;\n    };\n\n    if (!NewC != !OldC) {\n      if (Complain)\n        Diagnose();\n      return false;\n    }\n\n    if (NewC) {\n      llvm::FoldingSetNodeID OldCID, NewCID;\n      OldC->Profile(OldCID, S.Context, /*Canonical=*/true);\n      NewC->Profile(NewCID, S.Context, /*Canonical=*/true);\n      if (OldCID != NewCID) {\n        if (Complain)\n          Diagnose();\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/// Diagnose a known arity mismatch when comparing template argument\n/// lists.\nstatic\nvoid DiagnoseTemplateParameterListArityMismatch(Sema &S,\n                                                TemplateParameterList *New,\n                                                TemplateParameterList *Old,\n                                      Sema::TemplateParameterListEqualKind Kind,\n                                                SourceLocation TemplateArgLoc) {\n  unsigned NextDiag = diag::err_template_param_list_different_arity;\n  if (TemplateArgLoc.isValid()) {\n    S.Diag(TemplateArgLoc, diag::err_template_arg_template_params_mismatch);\n    NextDiag = diag::note_template_param_list_different_arity;\n  }\n  S.Diag(New->getTemplateLoc(), NextDiag)\n    << (New->size() > Old->size())\n    << (Kind != Sema::TPL_TemplateMatch)\n    << SourceRange(New->getTemplateLoc(), New->getRAngleLoc());\n  S.Diag(Old->getTemplateLoc(), diag::note_template_prev_declaration)\n    << (Kind != Sema::TPL_TemplateMatch)\n    << SourceRange(Old->getTemplateLoc(), Old->getRAngleLoc());\n}\n\n/// Determine whether the given template parameter lists are\n/// equivalent.\n///\n/// \\param New  The new template parameter list, typically written in the\n/// source code as part of a new template declaration.\n///\n/// \\param Old  The old template parameter list, typically found via\n/// name lookup of the template declared with this template parameter\n/// list.\n///\n/// \\param Complain  If true, this routine will produce a diagnostic if\n/// the template parameter lists are not equivalent.\n///\n/// \\param Kind describes how we are to match the template parameter lists.\n///\n/// \\param TemplateArgLoc If this source location is valid, then we\n/// are actually checking the template parameter list of a template\n/// argument (New) against the template parameter list of its\n/// corresponding template template parameter (Old). We produce\n/// slightly different diagnostics in this scenario.\n///\n/// \\returns True if the template parameter lists are equal, false\n/// otherwise.\nbool\nSema::TemplateParameterListsAreEqual(TemplateParameterList *New,\n                                     TemplateParameterList *Old,\n                                     bool Complain,\n                                     TemplateParameterListEqualKind Kind,\n                                     SourceLocation TemplateArgLoc) {\n  if (Old->size() != New->size() && Kind != TPL_TemplateTemplateArgumentMatch) {\n    if (Complain)\n      DiagnoseTemplateParameterListArityMismatch(*this, New, Old, Kind,\n                                                 TemplateArgLoc);\n\n    return false;\n  }\n\n  // C++0x [temp.arg.template]p3:\n  //   A template-argument matches a template template-parameter (call it P)\n  //   when each of the template parameters in the template-parameter-list of\n  //   the template-argument's corresponding class template or alias template\n  //   (call it A) matches the corresponding template parameter in the\n  //   template-parameter-list of P. [...]\n  TemplateParameterList::iterator NewParm = New->begin();\n  TemplateParameterList::iterator NewParmEnd = New->end();\n  for (TemplateParameterList::iterator OldParm = Old->begin(),\n                                    OldParmEnd = Old->end();\n       OldParm != OldParmEnd; ++OldParm) {\n    if (Kind != TPL_TemplateTemplateArgumentMatch ||\n        !(*OldParm)->isTemplateParameterPack()) {\n      if (NewParm == NewParmEnd) {\n        if (Complain)\n          DiagnoseTemplateParameterListArityMismatch(*this, New, Old, Kind,\n                                                     TemplateArgLoc);\n\n        return false;\n      }\n\n      if (!MatchTemplateParameterKind(*this, *NewParm, *OldParm, Complain,\n                                      Kind, TemplateArgLoc))\n        return false;\n\n      ++NewParm;\n      continue;\n    }\n\n    // C++0x [temp.arg.template]p3:\n    //   [...] When P's template- parameter-list contains a template parameter\n    //   pack (14.5.3), the template parameter pack will match zero or more\n    //   template parameters or template parameter packs in the\n    //   template-parameter-list of A with the same type and form as the\n    //   template parameter pack in P (ignoring whether those template\n    //   parameters are template parameter packs).\n    for (; NewParm != NewParmEnd; ++NewParm) {\n      if (!MatchTemplateParameterKind(*this, *NewParm, *OldParm, Complain,\n                                      Kind, TemplateArgLoc))\n        return false;\n    }\n  }\n\n  // Make sure we exhausted all of the arguments.\n  if (NewParm != NewParmEnd) {\n    if (Complain)\n      DiagnoseTemplateParameterListArityMismatch(*this, New, Old, Kind,\n                                                 TemplateArgLoc);\n\n    return false;\n  }\n\n  if (Kind != TPL_TemplateTemplateArgumentMatch) {\n    const Expr *NewRC = New->getRequiresClause();\n    const Expr *OldRC = Old->getRequiresClause();\n\n    auto Diagnose = [&] {\n      Diag(NewRC ? NewRC->getBeginLoc() : New->getTemplateLoc(),\n           diag::err_template_different_requires_clause);\n      Diag(OldRC ? OldRC->getBeginLoc() : Old->getTemplateLoc(),\n           diag::note_template_prev_declaration) << /*declaration*/0;\n    };\n\n    if (!NewRC != !OldRC) {\n      if (Complain)\n        Diagnose();\n      return false;\n    }\n\n    if (NewRC) {\n      llvm::FoldingSetNodeID OldRCID, NewRCID;\n      OldRC->Profile(OldRCID, Context, /*Canonical=*/true);\n      NewRC->Profile(NewRCID, Context, /*Canonical=*/true);\n      if (OldRCID != NewRCID) {\n        if (Complain)\n          Diagnose();\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/// Check whether a template can be declared within this scope.\n///\n/// If the template declaration is valid in this scope, returns\n/// false. Otherwise, issues a diagnostic and returns true.\nbool\nSema::CheckTemplateDeclScope(Scope *S, TemplateParameterList *TemplateParams) {\n  if (!S)\n    return false;\n\n  // Find the nearest enclosing declaration scope.\n  while ((S->getFlags() & Scope::DeclScope) == 0 ||\n         (S->getFlags() & Scope::TemplateParamScope) != 0)\n    S = S->getParent();\n\n  // C++ [temp.pre]p6: [P2096]\n  //   A template, explicit specialization, or partial specialization shall not\n  //   have C linkage.\n  DeclContext *Ctx = S->getEntity();\n  if (Ctx && Ctx->isExternCContext()) {\n    Diag(TemplateParams->getTemplateLoc(), diag::err_template_linkage)\n        << TemplateParams->getSourceRange();\n    if (const LinkageSpecDecl *LSD = Ctx->getExternCContext())\n      Diag(LSD->getExternLoc(), diag::note_extern_c_begins_here);\n    return true;\n  }\n  Ctx = Ctx ? Ctx->getRedeclContext() : nullptr;\n\n  // C++ [temp]p2:\n  //   A template-declaration can appear only as a namespace scope or\n  //   class scope declaration.\n  // C++ [temp.expl.spec]p3:\n  //   An explicit specialization may be declared in any scope in which the\n  //   corresponding primary template may be defined.\n  // C++ [temp.class.spec]p6: [P2096]\n  //   A partial specialization may be declared in any scope in which the\n  //   corresponding primary template may be defined.\n  if (Ctx) {\n    if (Ctx->isFileContext())\n      return false;\n    if (CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(Ctx)) {\n      // C++ [temp.mem]p2:\n      //   A local class shall not have member templates.\n      if (RD->isLocalClass())\n        return Diag(TemplateParams->getTemplateLoc(),\n                    diag::err_template_inside_local_class)\n          << TemplateParams->getSourceRange();\n      else\n        return false;\n    }\n  }\n\n  return Diag(TemplateParams->getTemplateLoc(),\n              diag::err_template_outside_namespace_or_class_scope)\n    << TemplateParams->getSourceRange();\n}\n\n/// Determine what kind of template specialization the given declaration\n/// is.\nstatic TemplateSpecializationKind getTemplateSpecializationKind(Decl *D) {\n  if (!D)\n    return TSK_Undeclared;\n\n  if (CXXRecordDecl *Record = dyn_cast<CXXRecordDecl>(D))\n    return Record->getTemplateSpecializationKind();\n  if (FunctionDecl *Function = dyn_cast<FunctionDecl>(D))\n    return Function->getTemplateSpecializationKind();\n  if (VarDecl *Var = dyn_cast<VarDecl>(D))\n    return Var->getTemplateSpecializationKind();\n\n  return TSK_Undeclared;\n}\n\n/// Check whether a specialization is well-formed in the current\n/// context.\n///\n/// This routine determines whether a template specialization can be declared\n/// in the current context (C++ [temp.expl.spec]p2).\n///\n/// \\param S the semantic analysis object for which this check is being\n/// performed.\n///\n/// \\param Specialized the entity being specialized or instantiated, which\n/// may be a kind of template (class template, function template, etc.) or\n/// a member of a class template (member function, static data member,\n/// member class).\n///\n/// \\param PrevDecl the previous declaration of this entity, if any.\n///\n/// \\param Loc the location of the explicit specialization or instantiation of\n/// this entity.\n///\n/// \\param IsPartialSpecialization whether this is a partial specialization of\n/// a class template.\n///\n/// \\returns true if there was an error that we cannot recover from, false\n/// otherwise.\nstatic bool CheckTemplateSpecializationScope(Sema &S,\n                                             NamedDecl *Specialized,\n                                             NamedDecl *PrevDecl,\n                                             SourceLocation Loc,\n                                             bool IsPartialSpecialization) {\n  // Keep these \"kind\" numbers in sync with the %select statements in the\n  // various diagnostics emitted by this routine.\n  int EntityKind = 0;\n  if (isa<ClassTemplateDecl>(Specialized))\n    EntityKind = IsPartialSpecialization? 1 : 0;\n  else if (isa<VarTemplateDecl>(Specialized))\n    EntityKind = IsPartialSpecialization ? 3 : 2;\n  else if (isa<FunctionTemplateDecl>(Specialized))\n    EntityKind = 4;\n  else if (isa<CXXMethodDecl>(Specialized))\n    EntityKind = 5;\n  else if (isa<VarDecl>(Specialized))\n    EntityKind = 6;\n  else if (isa<RecordDecl>(Specialized))\n    EntityKind = 7;\n  else if (isa<EnumDecl>(Specialized) && S.getLangOpts().CPlusPlus11)\n    EntityKind = 8;\n  else {\n    S.Diag(Loc, diag::err_template_spec_unknown_kind)\n      << S.getLangOpts().CPlusPlus11;\n    S.Diag(Specialized->getLocation(), diag::note_specialized_entity);\n    return true;\n  }\n\n  // C++ [temp.expl.spec]p2:\n  //   An explicit specialization may be declared in any scope in which\n  //   the corresponding primary template may be defined.\n  if (S.CurContext->getRedeclContext()->isFunctionOrMethod()) {\n    S.Diag(Loc, diag::err_template_spec_decl_function_scope)\n      << Specialized;\n    return true;\n  }\n\n  // C++ [temp.class.spec]p6:\n  //   A class template partial specialization may be declared in any\n  //   scope in which the primary template may be defined.\n  DeclContext *SpecializedContext =\n      Specialized->getDeclContext()->getRedeclContext();\n  DeclContext *DC = S.CurContext->getRedeclContext();\n\n  // Make sure that this redeclaration (or definition) occurs in the same\n  // scope or an enclosing namespace.\n  if (!(DC->isFileContext() ? DC->Encloses(SpecializedContext)\n                            : DC->Equals(SpecializedContext))) {\n    if (isa<TranslationUnitDecl>(SpecializedContext))\n      S.Diag(Loc, diag::err_template_spec_redecl_global_scope)\n        << EntityKind << Specialized;\n    else {\n      auto *ND = cast<NamedDecl>(SpecializedContext);\n      int Diag = diag::err_template_spec_redecl_out_of_scope;\n      if (S.getLangOpts().MicrosoftExt && !DC->isRecord())\n        Diag = diag::ext_ms_template_spec_redecl_out_of_scope;\n      S.Diag(Loc, Diag) << EntityKind << Specialized\n                        << ND << isa<CXXRecordDecl>(ND);\n    }\n\n    S.Diag(Specialized->getLocation(), diag::note_specialized_entity);\n\n    // Don't allow specializing in the wrong class during error recovery.\n    // Otherwise, things can go horribly wrong.\n    if (DC->isRecord())\n      return true;\n  }\n\n  return false;\n}\n\nstatic SourceRange findTemplateParameterInType(unsigned Depth, Expr *E) {\n  if (!E->isTypeDependent())\n    return SourceLocation();\n  DependencyChecker Checker(Depth, /*IgnoreNonTypeDependent*/true);\n  Checker.TraverseStmt(E);\n  if (Checker.MatchLoc.isInvalid())\n    return E->getSourceRange();\n  return Checker.MatchLoc;\n}\n\nstatic SourceRange findTemplateParameter(unsigned Depth, TypeLoc TL) {\n  if (!TL.getType()->isDependentType())\n    return SourceLocation();\n  DependencyChecker Checker(Depth, /*IgnoreNonTypeDependent*/true);\n  Checker.TraverseTypeLoc(TL);\n  if (Checker.MatchLoc.isInvalid())\n    return TL.getSourceRange();\n  return Checker.MatchLoc;\n}\n\n/// Subroutine of Sema::CheckTemplatePartialSpecializationArgs\n/// that checks non-type template partial specialization arguments.\nstatic bool CheckNonTypeTemplatePartialSpecializationArgs(\n    Sema &S, SourceLocation TemplateNameLoc, NonTypeTemplateParmDecl *Param,\n    const TemplateArgument *Args, unsigned NumArgs, bool IsDefaultArgument) {\n  for (unsigned I = 0; I != NumArgs; ++I) {\n    if (Args[I].getKind() == TemplateArgument::Pack) {\n      if (CheckNonTypeTemplatePartialSpecializationArgs(\n              S, TemplateNameLoc, Param, Args[I].pack_begin(),\n              Args[I].pack_size(), IsDefaultArgument))\n        return true;\n\n      continue;\n    }\n\n    if (Args[I].getKind() != TemplateArgument::Expression)\n      continue;\n\n    Expr *ArgExpr = Args[I].getAsExpr();\n\n    // We can have a pack expansion of any of the bullets below.\n    if (PackExpansionExpr *Expansion = dyn_cast<PackExpansionExpr>(ArgExpr))\n      ArgExpr = Expansion->getPattern();\n\n    // Strip off any implicit casts we added as part of type checking.\n    while (ImplicitCastExpr *ICE = dyn_cast<ImplicitCastExpr>(ArgExpr))\n      ArgExpr = ICE->getSubExpr();\n\n    // C++ [temp.class.spec]p8:\n    //   A non-type argument is non-specialized if it is the name of a\n    //   non-type parameter. All other non-type arguments are\n    //   specialized.\n    //\n    // Below, we check the two conditions that only apply to\n    // specialized non-type arguments, so skip any non-specialized\n    // arguments.\n    if (DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(ArgExpr))\n      if (isa<NonTypeTemplateParmDecl>(DRE->getDecl()))\n        continue;\n\n    // C++ [temp.class.spec]p9:\n    //   Within the argument list of a class template partial\n    //   specialization, the following restrictions apply:\n    //     -- A partially specialized non-type argument expression\n    //        shall not involve a template parameter of the partial\n    //        specialization except when the argument expression is a\n    //        simple identifier.\n    //     -- The type of a template parameter corresponding to a\n    //        specialized non-type argument shall not be dependent on a\n    //        parameter of the specialization.\n    // DR1315 removes the first bullet, leaving an incoherent set of rules.\n    // We implement a compromise between the original rules and DR1315:\n    //     --  A specialized non-type template argument shall not be\n    //         type-dependent and the corresponding template parameter\n    //         shall have a non-dependent type.\n    SourceRange ParamUseRange =\n        findTemplateParameterInType(Param->getDepth(), ArgExpr);\n    if (ParamUseRange.isValid()) {\n      if (IsDefaultArgument) {\n        S.Diag(TemplateNameLoc,\n               diag::err_dependent_non_type_arg_in_partial_spec);\n        S.Diag(ParamUseRange.getBegin(),\n               diag::note_dependent_non_type_default_arg_in_partial_spec)\n          << ParamUseRange;\n      } else {\n        S.Diag(ParamUseRange.getBegin(),\n               diag::err_dependent_non_type_arg_in_partial_spec)\n          << ParamUseRange;\n      }\n      return true;\n    }\n\n    ParamUseRange = findTemplateParameter(\n        Param->getDepth(), Param->getTypeSourceInfo()->getTypeLoc());\n    if (ParamUseRange.isValid()) {\n      S.Diag(IsDefaultArgument ? TemplateNameLoc : ArgExpr->getBeginLoc(),\n             diag::err_dependent_typed_non_type_arg_in_partial_spec)\n          << Param->getType();\n      S.Diag(Param->getLocation(), diag::note_template_param_here)\n        << (IsDefaultArgument ? ParamUseRange : SourceRange())\n        << ParamUseRange;\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/// Check the non-type template arguments of a class template\n/// partial specialization according to C++ [temp.class.spec]p9.\n///\n/// \\param TemplateNameLoc the location of the template name.\n/// \\param PrimaryTemplate the template parameters of the primary class\n///        template.\n/// \\param NumExplicit the number of explicitly-specified template arguments.\n/// \\param TemplateArgs the template arguments of the class template\n///        partial specialization.\n///\n/// \\returns \\c true if there was an error, \\c false otherwise.\nbool Sema::CheckTemplatePartialSpecializationArgs(\n    SourceLocation TemplateNameLoc, TemplateDecl *PrimaryTemplate,\n    unsigned NumExplicit, ArrayRef<TemplateArgument> TemplateArgs) {\n  // We have to be conservative when checking a template in a dependent\n  // context.\n  if (PrimaryTemplate->getDeclContext()->isDependentContext())\n    return false;\n\n  TemplateParameterList *TemplateParams =\n      PrimaryTemplate->getTemplateParameters();\n  for (unsigned I = 0, N = TemplateParams->size(); I != N; ++I) {\n    NonTypeTemplateParmDecl *Param\n      = dyn_cast<NonTypeTemplateParmDecl>(TemplateParams->getParam(I));\n    if (!Param)\n      continue;\n\n    if (CheckNonTypeTemplatePartialSpecializationArgs(*this, TemplateNameLoc,\n                                                      Param, &TemplateArgs[I],\n                                                      1, I >= NumExplicit))\n      return true;\n  }\n\n  return false;\n}\n\nDeclResult Sema::ActOnClassTemplateSpecialization(\n    Scope *S, unsigned TagSpec, TagUseKind TUK, SourceLocation KWLoc,\n    SourceLocation ModulePrivateLoc, CXXScopeSpec &SS,\n    TemplateIdAnnotation &TemplateId, const ParsedAttributesView &Attr,\n    MultiTemplateParamsArg TemplateParameterLists, SkipBodyInfo *SkipBody) {\n  assert(TUK != TUK_Reference && \"References are not specializations\");\n\n  // NOTE: KWLoc is the location of the tag keyword. This will instead\n  // store the location of the outermost template keyword in the declaration.\n  SourceLocation TemplateKWLoc = TemplateParameterLists.size() > 0\n    ? TemplateParameterLists[0]->getTemplateLoc() : KWLoc;\n  SourceLocation TemplateNameLoc = TemplateId.TemplateNameLoc;\n  SourceLocation LAngleLoc = TemplateId.LAngleLoc;\n  SourceLocation RAngleLoc = TemplateId.RAngleLoc;\n\n  // Find the class template we're specializing\n  TemplateName Name = TemplateId.Template.get();\n  ClassTemplateDecl *ClassTemplate\n    = dyn_cast_or_null<ClassTemplateDecl>(Name.getAsTemplateDecl());\n\n  if (!ClassTemplate) {\n    Diag(TemplateNameLoc, diag::err_not_class_template_specialization)\n      << (Name.getAsTemplateDecl() &&\n          isa<TemplateTemplateParmDecl>(Name.getAsTemplateDecl()));\n    return true;\n  }\n\n  bool isMemberSpecialization = false;\n  bool isPartialSpecialization = false;\n\n  // Check the validity of the template headers that introduce this\n  // template.\n  // FIXME: We probably shouldn't complain about these headers for\n  // friend declarations.\n  bool Invalid = false;\n  TemplateParameterList *TemplateParams =\n      MatchTemplateParametersToScopeSpecifier(\n          KWLoc, TemplateNameLoc, SS, &TemplateId,\n          TemplateParameterLists, TUK == TUK_Friend, isMemberSpecialization,\n          Invalid);\n  if (Invalid)\n    return true;\n\n  // Check that we can declare a template specialization here.\n  if (TemplateParams && CheckTemplateDeclScope(S, TemplateParams))\n    return true;\n\n  if (TemplateParams && TemplateParams->size() > 0) {\n    isPartialSpecialization = true;\n\n    if (TUK == TUK_Friend) {\n      Diag(KWLoc, diag::err_partial_specialization_friend)\n        << SourceRange(LAngleLoc, RAngleLoc);\n      return true;\n    }\n\n    // C++ [temp.class.spec]p10:\n    //   The template parameter list of a specialization shall not\n    //   contain default template argument values.\n    for (unsigned I = 0, N = TemplateParams->size(); I != N; ++I) {\n      Decl *Param = TemplateParams->getParam(I);\n      if (TemplateTypeParmDecl *TTP = dyn_cast<TemplateTypeParmDecl>(Param)) {\n        if (TTP->hasDefaultArgument()) {\n          Diag(TTP->getDefaultArgumentLoc(),\n               diag::err_default_arg_in_partial_spec);\n          TTP->removeDefaultArgument();\n        }\n      } else if (NonTypeTemplateParmDecl *NTTP\n                   = dyn_cast<NonTypeTemplateParmDecl>(Param)) {\n        if (Expr *DefArg = NTTP->getDefaultArgument()) {\n          Diag(NTTP->getDefaultArgumentLoc(),\n               diag::err_default_arg_in_partial_spec)\n            << DefArg->getSourceRange();\n          NTTP->removeDefaultArgument();\n        }\n      } else {\n        TemplateTemplateParmDecl *TTP = cast<TemplateTemplateParmDecl>(Param);\n        if (TTP->hasDefaultArgument()) {\n          Diag(TTP->getDefaultArgument().getLocation(),\n               diag::err_default_arg_in_partial_spec)\n            << TTP->getDefaultArgument().getSourceRange();\n          TTP->removeDefaultArgument();\n        }\n      }\n    }\n  } else if (TemplateParams) {\n    if (TUK == TUK_Friend)\n      Diag(KWLoc, diag::err_template_spec_friend)\n        << FixItHint::CreateRemoval(\n                                SourceRange(TemplateParams->getTemplateLoc(),\n                                            TemplateParams->getRAngleLoc()))\n        << SourceRange(LAngleLoc, RAngleLoc);\n  } else {\n    assert(TUK == TUK_Friend && \"should have a 'template<>' for this decl\");\n  }\n\n  // Check that the specialization uses the same tag kind as the\n  // original template.\n  TagTypeKind Kind = TypeWithKeyword::getTagTypeKindForTypeSpec(TagSpec);\n  assert(Kind != TTK_Enum && \"Invalid enum tag in class template spec!\");\n  if (!isAcceptableTagRedeclaration(ClassTemplate->getTemplatedDecl(),\n                                    Kind, TUK == TUK_Definition, KWLoc,\n                                    ClassTemplate->getIdentifier())) {\n    Diag(KWLoc, diag::err_use_with_wrong_tag)\n      << ClassTemplate\n      << FixItHint::CreateReplacement(KWLoc,\n                            ClassTemplate->getTemplatedDecl()->getKindName());\n    Diag(ClassTemplate->getTemplatedDecl()->getLocation(),\n         diag::note_previous_use);\n    Kind = ClassTemplate->getTemplatedDecl()->getTagKind();\n  }\n\n  // Translate the parser's template argument list in our AST format.\n  TemplateArgumentListInfo TemplateArgs =\n      makeTemplateArgumentListInfo(*this, TemplateId);\n\n  // Check for unexpanded parameter packs in any of the template arguments.\n  for (unsigned I = 0, N = TemplateArgs.size(); I != N; ++I)\n    if (DiagnoseUnexpandedParameterPack(TemplateArgs[I],\n                                        UPPC_PartialSpecialization))\n      return true;\n\n  // Check that the template argument list is well-formed for this\n  // template.\n  SmallVector<TemplateArgument, 4> Converted;\n  if (CheckTemplateArgumentList(ClassTemplate, TemplateNameLoc,\n                                TemplateArgs, false, Converted,\n                                /*UpdateArgsWithConversion=*/true))\n    return true;\n\n  // Find the class template (partial) specialization declaration that\n  // corresponds to these arguments.\n  if (isPartialSpecialization) {\n    if (CheckTemplatePartialSpecializationArgs(TemplateNameLoc, ClassTemplate,\n                                               TemplateArgs.size(), Converted))\n      return true;\n\n    // FIXME: Move this to CheckTemplatePartialSpecializationArgs so we\n    // also do it during instantiation.\n    if (!Name.isDependent() &&\n        !TemplateSpecializationType::anyDependentTemplateArguments(TemplateArgs,\n                                                                   Converted)) {\n      Diag(TemplateNameLoc, diag::err_partial_spec_fully_specialized)\n        << ClassTemplate->getDeclName();\n      isPartialSpecialization = false;\n    }\n  }\n\n  void *InsertPos = nullptr;\n  ClassTemplateSpecializationDecl *PrevDecl = nullptr;\n\n  if (isPartialSpecialization)\n    PrevDecl = ClassTemplate->findPartialSpecialization(Converted,\n                                                        TemplateParams,\n                                                        InsertPos);\n  else\n    PrevDecl = ClassTemplate->findSpecialization(Converted, InsertPos);\n\n  ClassTemplateSpecializationDecl *Specialization = nullptr;\n\n  // Check whether we can declare a class template specialization in\n  // the current scope.\n  if (TUK != TUK_Friend &&\n      CheckTemplateSpecializationScope(*this, ClassTemplate, PrevDecl,\n                                       TemplateNameLoc,\n                                       isPartialSpecialization))\n    return true;\n\n  // The canonical type\n  QualType CanonType;\n  if (isPartialSpecialization) {\n    // Build the canonical type that describes the converted template\n    // arguments of the class template partial specialization.\n    TemplateName CanonTemplate = Context.getCanonicalTemplateName(Name);\n    CanonType = Context.getTemplateSpecializationType(CanonTemplate,\n                                                      Converted);\n\n    if (Context.hasSameType(CanonType,\n                        ClassTemplate->getInjectedClassNameSpecialization()) &&\n        (!Context.getLangOpts().CPlusPlus20 ||\n         !TemplateParams->hasAssociatedConstraints())) {\n      // C++ [temp.class.spec]p9b3:\n      //\n      //   -- The argument list of the specialization shall not be identical\n      //      to the implicit argument list of the primary template.\n      //\n      // This rule has since been removed, because it's redundant given DR1495,\n      // but we keep it because it produces better diagnostics and recovery.\n      Diag(TemplateNameLoc, diag::err_partial_spec_args_match_primary_template)\n        << /*class template*/0 << (TUK == TUK_Definition)\n        << FixItHint::CreateRemoval(SourceRange(LAngleLoc, RAngleLoc));\n      return CheckClassTemplate(S, TagSpec, TUK, KWLoc, SS,\n                                ClassTemplate->getIdentifier(),\n                                TemplateNameLoc,\n                                Attr,\n                                TemplateParams,\n                                AS_none, /*ModulePrivateLoc=*/SourceLocation(),\n                                /*FriendLoc*/SourceLocation(),\n                                TemplateParameterLists.size() - 1,\n                                TemplateParameterLists.data());\n    }\n\n    // Create a new class template partial specialization declaration node.\n    ClassTemplatePartialSpecializationDecl *PrevPartial\n      = cast_or_null<ClassTemplatePartialSpecializationDecl>(PrevDecl);\n    ClassTemplatePartialSpecializationDecl *Partial\n      = ClassTemplatePartialSpecializationDecl::Create(Context, Kind,\n                                             ClassTemplate->getDeclContext(),\n                                                       KWLoc, TemplateNameLoc,\n                                                       TemplateParams,\n                                                       ClassTemplate,\n                                                       Converted,\n                                                       TemplateArgs,\n                                                       CanonType,\n                                                       PrevPartial);\n    SetNestedNameSpecifier(*this, Partial, SS);\n    if (TemplateParameterLists.size() > 1 && SS.isSet()) {\n      Partial->setTemplateParameterListsInfo(\n          Context, TemplateParameterLists.drop_back(1));\n    }\n\n    if (!PrevPartial)\n      ClassTemplate->AddPartialSpecialization(Partial, InsertPos);\n    Specialization = Partial;\n\n    // If we are providing an explicit specialization of a member class\n    // template specialization, make a note of that.\n    if (PrevPartial && PrevPartial->getInstantiatedFromMember())\n      PrevPartial->setMemberSpecialization();\n\n    CheckTemplatePartialSpecialization(Partial);\n  } else {\n    // Create a new class template specialization declaration node for\n    // this explicit specialization or friend declaration.\n    Specialization\n      = ClassTemplateSpecializationDecl::Create(Context, Kind,\n                                             ClassTemplate->getDeclContext(),\n                                                KWLoc, TemplateNameLoc,\n                                                ClassTemplate,\n                                                Converted,\n                                                PrevDecl);\n    SetNestedNameSpecifier(*this, Specialization, SS);\n    if (TemplateParameterLists.size() > 0) {\n      Specialization->setTemplateParameterListsInfo(Context,\n                                                    TemplateParameterLists);\n    }\n\n    if (!PrevDecl)\n      ClassTemplate->AddSpecialization(Specialization, InsertPos);\n\n    if (CurContext->isDependentContext()) {\n      TemplateName CanonTemplate = Context.getCanonicalTemplateName(Name);\n      CanonType = Context.getTemplateSpecializationType(\n          CanonTemplate, Converted);\n    } else {\n      CanonType = Context.getTypeDeclType(Specialization);\n    }\n  }\n\n  // C++ [temp.expl.spec]p6:\n  //   If a template, a member template or the member of a class template is\n  //   explicitly specialized then that specialization shall be declared\n  //   before the first use of that specialization that would cause an implicit\n  //   instantiation to take place, in every translation unit in which such a\n  //   use occurs; no diagnostic is required.\n  if (PrevDecl && PrevDecl->getPointOfInstantiation().isValid()) {\n    bool Okay = false;\n    for (Decl *Prev = PrevDecl; Prev; Prev = Prev->getPreviousDecl()) {\n      // Is there any previous explicit specialization declaration?\n      if (getTemplateSpecializationKind(Prev) == TSK_ExplicitSpecialization) {\n        Okay = true;\n        break;\n      }\n    }\n\n    if (!Okay) {\n      SourceRange Range(TemplateNameLoc, RAngleLoc);\n      Diag(TemplateNameLoc, diag::err_specialization_after_instantiation)\n        << Context.getTypeDeclType(Specialization) << Range;\n\n      Diag(PrevDecl->getPointOfInstantiation(),\n           diag::note_instantiation_required_here)\n        << (PrevDecl->getTemplateSpecializationKind()\n                                                != TSK_ImplicitInstantiation);\n      return true;\n    }\n  }\n\n  // If this is not a friend, note that this is an explicit specialization.\n  if (TUK != TUK_Friend)\n    Specialization->setSpecializationKind(TSK_ExplicitSpecialization);\n\n  // Check that this isn't a redefinition of this specialization.\n  if (TUK == TUK_Definition) {\n    RecordDecl *Def = Specialization->getDefinition();\n    NamedDecl *Hidden = nullptr;\n    if (Def && SkipBody && !hasVisibleDefinition(Def, &Hidden)) {\n      SkipBody->ShouldSkip = true;\n      SkipBody->Previous = Def;\n      makeMergedDefinitionVisible(Hidden);\n    } else if (Def) {\n      SourceRange Range(TemplateNameLoc, RAngleLoc);\n      Diag(TemplateNameLoc, diag::err_redefinition) << Specialization << Range;\n      Diag(Def->getLocation(), diag::note_previous_definition);\n      Specialization->setInvalidDecl();\n      return true;\n    }\n  }\n\n  ProcessDeclAttributeList(S, Specialization, Attr);\n\n  // Add alignment attributes if necessary; these attributes are checked when\n  // the ASTContext lays out the structure.\n  if (TUK == TUK_Definition && (!SkipBody || !SkipBody->ShouldSkip)) {\n    AddAlignmentAttributesForRecord(Specialization);\n    AddMsStructLayoutForRecord(Specialization);\n  }\n\n  if (ModulePrivateLoc.isValid())\n    Diag(Specialization->getLocation(), diag::err_module_private_specialization)\n      << (isPartialSpecialization? 1 : 0)\n      << FixItHint::CreateRemoval(ModulePrivateLoc);\n\n  // Build the fully-sugared type for this class template\n  // specialization as the user wrote in the specialization\n  // itself. This means that we'll pretty-print the type retrieved\n  // from the specialization's declaration the way that the user\n  // actually wrote the specialization, rather than formatting the\n  // name based on the \"canonical\" representation used to store the\n  // template arguments in the specialization.\n  TypeSourceInfo *WrittenTy\n    = Context.getTemplateSpecializationTypeInfo(Name, TemplateNameLoc,\n                                                TemplateArgs, CanonType);\n  if (TUK != TUK_Friend) {\n    Specialization->setTypeAsWritten(WrittenTy);\n    Specialization->setTemplateKeywordLoc(TemplateKWLoc);\n  }\n\n  // C++ [temp.expl.spec]p9:\n  //   A template explicit specialization is in the scope of the\n  //   namespace in which the template was defined.\n  //\n  // We actually implement this paragraph where we set the semantic\n  // context (in the creation of the ClassTemplateSpecializationDecl),\n  // but we also maintain the lexical context where the actual\n  // definition occurs.\n  Specialization->setLexicalDeclContext(CurContext);\n\n  // We may be starting the definition of this specialization.\n  if (TUK == TUK_Definition && (!SkipBody || !SkipBody->ShouldSkip))\n    Specialization->startDefinition();\n\n  if (TUK == TUK_Friend) {\n    FriendDecl *Friend = FriendDecl::Create(Context, CurContext,\n                                            TemplateNameLoc,\n                                            WrittenTy,\n                                            /*FIXME:*/KWLoc);\n    Friend->setAccess(AS_public);\n    CurContext->addDecl(Friend);\n  } else {\n    // Add the specialization into its lexical context, so that it can\n    // be seen when iterating through the list of declarations in that\n    // context. However, specializations are not found by name lookup.\n    CurContext->addDecl(Specialization);\n  }\n\n  if (SkipBody && SkipBody->ShouldSkip)\n    return SkipBody->Previous;\n\n  return Specialization;\n}\n\nDecl *Sema::ActOnTemplateDeclarator(Scope *S,\n                              MultiTemplateParamsArg TemplateParameterLists,\n                                    Declarator &D) {\n  Decl *NewDecl = HandleDeclarator(S, D, TemplateParameterLists);\n  ActOnDocumentableDecl(NewDecl);\n  return NewDecl;\n}\n\nDecl *Sema::ActOnConceptDefinition(Scope *S,\n                              MultiTemplateParamsArg TemplateParameterLists,\n                                   IdentifierInfo *Name, SourceLocation NameLoc,\n                                   Expr *ConstraintExpr) {\n  DeclContext *DC = CurContext;\n\n  if (!DC->getRedeclContext()->isFileContext()) {\n    Diag(NameLoc,\n      diag::err_concept_decls_may_only_appear_in_global_namespace_scope);\n    return nullptr;\n  }\n\n  if (TemplateParameterLists.size() > 1) {\n    Diag(NameLoc, diag::err_concept_extra_headers);\n    return nullptr;\n  }\n\n  if (TemplateParameterLists.front()->size() == 0) {\n    Diag(NameLoc, diag::err_concept_no_parameters);\n    return nullptr;\n  }\n\n  if (DiagnoseUnexpandedParameterPack(ConstraintExpr))\n    return nullptr;\n\n  ConceptDecl *NewDecl = ConceptDecl::Create(Context, DC, NameLoc, Name,\n                                             TemplateParameterLists.front(),\n                                             ConstraintExpr);\n\n  if (NewDecl->hasAssociatedConstraints()) {\n    // C++2a [temp.concept]p4:\n    // A concept shall not have associated constraints.\n    Diag(NameLoc, diag::err_concept_no_associated_constraints);\n    NewDecl->setInvalidDecl();\n  }\n\n  // Check for conflicting previous declaration.\n  DeclarationNameInfo NameInfo(NewDecl->getDeclName(), NameLoc);\n  LookupResult Previous(*this, NameInfo, LookupOrdinaryName,\n                        ForVisibleRedeclaration);\n  LookupName(Previous, S);\n\n  FilterLookupForScope(Previous, DC, S, /*ConsiderLinkage=*/false,\n                       /*AllowInlineNamespace*/false);\n  if (!Previous.empty()) {\n    auto *Old = Previous.getRepresentativeDecl();\n    Diag(NameLoc, isa<ConceptDecl>(Old) ? diag::err_redefinition :\n         diag::err_redefinition_different_kind) << NewDecl->getDeclName();\n    Diag(Old->getLocation(), diag::note_previous_definition);\n  }\n\n  ActOnDocumentableDecl(NewDecl);\n  PushOnScopeChains(NewDecl, S);\n  return NewDecl;\n}\n\n/// \\brief Strips various properties off an implicit instantiation\n/// that has just been explicitly specialized.\nstatic void StripImplicitInstantiation(NamedDecl *D) {\n  D->dropAttr<DLLImportAttr>();\n  D->dropAttr<DLLExportAttr>();\n\n  if (FunctionDecl *FD = dyn_cast<FunctionDecl>(D))\n    FD->setInlineSpecified(false);\n}\n\n/// Compute the diagnostic location for an explicit instantiation\n//  declaration or definition.\nstatic SourceLocation DiagLocForExplicitInstantiation(\n    NamedDecl* D, SourceLocation PointOfInstantiation) {\n  // Explicit instantiations following a specialization have no effect and\n  // hence no PointOfInstantiation. In that case, walk decl backwards\n  // until a valid name loc is found.\n  SourceLocation PrevDiagLoc = PointOfInstantiation;\n  for (Decl *Prev = D; Prev && !PrevDiagLoc.isValid();\n       Prev = Prev->getPreviousDecl()) {\n    PrevDiagLoc = Prev->getLocation();\n  }\n  assert(PrevDiagLoc.isValid() &&\n         \"Explicit instantiation without point of instantiation?\");\n  return PrevDiagLoc;\n}\n\n/// Diagnose cases where we have an explicit template specialization\n/// before/after an explicit template instantiation, producing diagnostics\n/// for those cases where they are required and determining whether the\n/// new specialization/instantiation will have any effect.\n///\n/// \\param NewLoc the location of the new explicit specialization or\n/// instantiation.\n///\n/// \\param NewTSK the kind of the new explicit specialization or instantiation.\n///\n/// \\param PrevDecl the previous declaration of the entity.\n///\n/// \\param PrevTSK the kind of the old explicit specialization or instantiatin.\n///\n/// \\param PrevPointOfInstantiation if valid, indicates where the previus\n/// declaration was instantiated (either implicitly or explicitly).\n///\n/// \\param HasNoEffect will be set to true to indicate that the new\n/// specialization or instantiation has no effect and should be ignored.\n///\n/// \\returns true if there was an error that should prevent the introduction of\n/// the new declaration into the AST, false otherwise.\nbool\nSema::CheckSpecializationInstantiationRedecl(SourceLocation NewLoc,\n                                             TemplateSpecializationKind NewTSK,\n                                             NamedDecl *PrevDecl,\n                                             TemplateSpecializationKind PrevTSK,\n                                        SourceLocation PrevPointOfInstantiation,\n                                             bool &HasNoEffect) {\n  HasNoEffect = false;\n\n  switch (NewTSK) {\n  case TSK_Undeclared:\n  case TSK_ImplicitInstantiation:\n    assert(\n        (PrevTSK == TSK_Undeclared || PrevTSK == TSK_ImplicitInstantiation) &&\n        \"previous declaration must be implicit!\");\n    return false;\n\n  case TSK_ExplicitSpecialization:\n    switch (PrevTSK) {\n    case TSK_Undeclared:\n    case TSK_ExplicitSpecialization:\n      // Okay, we're just specializing something that is either already\n      // explicitly specialized or has merely been mentioned without any\n      // instantiation.\n      return false;\n\n    case TSK_ImplicitInstantiation:\n      if (PrevPointOfInstantiation.isInvalid()) {\n        // The declaration itself has not actually been instantiated, so it is\n        // still okay to specialize it.\n        StripImplicitInstantiation(PrevDecl);\n        return false;\n      }\n      // Fall through\n      LLVM_FALLTHROUGH;\n\n    case TSK_ExplicitInstantiationDeclaration:\n    case TSK_ExplicitInstantiationDefinition:\n      assert((PrevTSK == TSK_ImplicitInstantiation ||\n              PrevPointOfInstantiation.isValid()) &&\n             \"Explicit instantiation without point of instantiation?\");\n\n      // C++ [temp.expl.spec]p6:\n      //   If a template, a member template or the member of a class template\n      //   is explicitly specialized then that specialization shall be declared\n      //   before the first use of that specialization that would cause an\n      //   implicit instantiation to take place, in every translation unit in\n      //   which such a use occurs; no diagnostic is required.\n      for (Decl *Prev = PrevDecl; Prev; Prev = Prev->getPreviousDecl()) {\n        // Is there any previous explicit specialization declaration?\n        if (getTemplateSpecializationKind(Prev) == TSK_ExplicitSpecialization)\n          return false;\n      }\n\n      Diag(NewLoc, diag::err_specialization_after_instantiation)\n        << PrevDecl;\n      Diag(PrevPointOfInstantiation, diag::note_instantiation_required_here)\n        << (PrevTSK != TSK_ImplicitInstantiation);\n\n      return true;\n    }\n    llvm_unreachable(\"The switch over PrevTSK must be exhaustive.\");\n\n  case TSK_ExplicitInstantiationDeclaration:\n    switch (PrevTSK) {\n    case TSK_ExplicitInstantiationDeclaration:\n      // This explicit instantiation declaration is redundant (that's okay).\n      HasNoEffect = true;\n      return false;\n\n    case TSK_Undeclared:\n    case TSK_ImplicitInstantiation:\n      // We're explicitly instantiating something that may have already been\n      // implicitly instantiated; that's fine.\n      return false;\n\n    case TSK_ExplicitSpecialization:\n      // C++0x [temp.explicit]p4:\n      //   For a given set of template parameters, if an explicit instantiation\n      //   of a template appears after a declaration of an explicit\n      //   specialization for that template, the explicit instantiation has no\n      //   effect.\n      HasNoEffect = true;\n      return false;\n\n    case TSK_ExplicitInstantiationDefinition:\n      // C++0x [temp.explicit]p10:\n      //   If an entity is the subject of both an explicit instantiation\n      //   declaration and an explicit instantiation definition in the same\n      //   translation unit, the definition shall follow the declaration.\n      Diag(NewLoc,\n           diag::err_explicit_instantiation_declaration_after_definition);\n\n      // Explicit instantiations following a specialization have no effect and\n      // hence no PrevPointOfInstantiation. In that case, walk decl backwards\n      // until a valid name loc is found.\n      Diag(DiagLocForExplicitInstantiation(PrevDecl, PrevPointOfInstantiation),\n           diag::note_explicit_instantiation_definition_here);\n      HasNoEffect = true;\n      return false;\n    }\n    llvm_unreachable(\"Unexpected TemplateSpecializationKind!\");\n\n  case TSK_ExplicitInstantiationDefinition:\n    switch (PrevTSK) {\n    case TSK_Undeclared:\n    case TSK_ImplicitInstantiation:\n      // We're explicitly instantiating something that may have already been\n      // implicitly instantiated; that's fine.\n      return false;\n\n    case TSK_ExplicitSpecialization:\n      // C++ DR 259, C++0x [temp.explicit]p4:\n      //   For a given set of template parameters, if an explicit\n      //   instantiation of a template appears after a declaration of\n      //   an explicit specialization for that template, the explicit\n      //   instantiation has no effect.\n      Diag(NewLoc, diag::warn_explicit_instantiation_after_specialization)\n        << PrevDecl;\n      Diag(PrevDecl->getLocation(),\n           diag::note_previous_template_specialization);\n      HasNoEffect = true;\n      return false;\n\n    case TSK_ExplicitInstantiationDeclaration:\n      // We're explicitly instantiating a definition for something for which we\n      // were previously asked to suppress instantiations. That's fine.\n\n      // C++0x [temp.explicit]p4:\n      //   For a given set of template parameters, if an explicit instantiation\n      //   of a template appears after a declaration of an explicit\n      //   specialization for that template, the explicit instantiation has no\n      //   effect.\n      for (Decl *Prev = PrevDecl; Prev; Prev = Prev->getPreviousDecl()) {\n        // Is there any previous explicit specialization declaration?\n        if (getTemplateSpecializationKind(Prev) == TSK_ExplicitSpecialization) {\n          HasNoEffect = true;\n          break;\n        }\n      }\n\n      return false;\n\n    case TSK_ExplicitInstantiationDefinition:\n      // C++0x [temp.spec]p5:\n      //   For a given template and a given set of template-arguments,\n      //     - an explicit instantiation definition shall appear at most once\n      //       in a program,\n\n      // MSVCCompat: MSVC silently ignores duplicate explicit instantiations.\n      Diag(NewLoc, (getLangOpts().MSVCCompat)\n                       ? diag::ext_explicit_instantiation_duplicate\n                       : diag::err_explicit_instantiation_duplicate)\n          << PrevDecl;\n      Diag(DiagLocForExplicitInstantiation(PrevDecl, PrevPointOfInstantiation),\n           diag::note_previous_explicit_instantiation);\n      HasNoEffect = true;\n      return false;\n    }\n  }\n\n  llvm_unreachable(\"Missing specialization/instantiation case?\");\n}\n\n/// Perform semantic analysis for the given dependent function\n/// template specialization.\n///\n/// The only possible way to get a dependent function template specialization\n/// is with a friend declaration, like so:\n///\n/// \\code\n///   template \\<class T> void foo(T);\n///   template \\<class T> class A {\n///     friend void foo<>(T);\n///   };\n/// \\endcode\n///\n/// There really isn't any useful analysis we can do here, so we\n/// just store the information.\nbool\nSema::CheckDependentFunctionTemplateSpecialization(FunctionDecl *FD,\n                   const TemplateArgumentListInfo &ExplicitTemplateArgs,\n                                                   LookupResult &Previous) {\n  // Remove anything from Previous that isn't a function template in\n  // the correct context.\n  DeclContext *FDLookupContext = FD->getDeclContext()->getRedeclContext();\n  LookupResult::Filter F = Previous.makeFilter();\n  enum DiscardReason { NotAFunctionTemplate, NotAMemberOfEnclosing };\n  SmallVector<std::pair<DiscardReason, Decl *>, 8> DiscardedCandidates;\n  while (F.hasNext()) {\n    NamedDecl *D = F.next()->getUnderlyingDecl();\n    if (!isa<FunctionTemplateDecl>(D)) {\n      F.erase();\n      DiscardedCandidates.push_back(std::make_pair(NotAFunctionTemplate, D));\n      continue;\n    }\n\n    if (!FDLookupContext->InEnclosingNamespaceSetOf(\n            D->getDeclContext()->getRedeclContext())) {\n      F.erase();\n      DiscardedCandidates.push_back(std::make_pair(NotAMemberOfEnclosing, D));\n      continue;\n    }\n  }\n  F.done();\n\n  if (Previous.empty()) {\n    Diag(FD->getLocation(),\n         diag::err_dependent_function_template_spec_no_match);\n    for (auto &P : DiscardedCandidates)\n      Diag(P.second->getLocation(),\n           diag::note_dependent_function_template_spec_discard_reason)\n          << P.first;\n    return true;\n  }\n\n  FD->setDependentTemplateSpecialization(Context, Previous.asUnresolvedSet(),\n                                         ExplicitTemplateArgs);\n  return false;\n}\n\n/// Perform semantic analysis for the given function template\n/// specialization.\n///\n/// This routine performs all of the semantic analysis required for an\n/// explicit function template specialization. On successful completion,\n/// the function declaration \\p FD will become a function template\n/// specialization.\n///\n/// \\param FD the function declaration, which will be updated to become a\n/// function template specialization.\n///\n/// \\param ExplicitTemplateArgs the explicitly-provided template arguments,\n/// if any. Note that this may be valid info even when 0 arguments are\n/// explicitly provided as in, e.g., \\c void sort<>(char*, char*);\n/// as it anyway contains info on the angle brackets locations.\n///\n/// \\param Previous the set of declarations that may be specialized by\n/// this function specialization.\n///\n/// \\param QualifiedFriend whether this is a lookup for a qualified friend\n/// declaration with no explicit template argument list that might be\n/// befriending a function template specialization.\nbool Sema::CheckFunctionTemplateSpecialization(\n    FunctionDecl *FD, TemplateArgumentListInfo *ExplicitTemplateArgs,\n    LookupResult &Previous, bool QualifiedFriend) {\n  // The set of function template specializations that could match this\n  // explicit function template specialization.\n  UnresolvedSet<8> Candidates;\n  TemplateSpecCandidateSet FailedCandidates(FD->getLocation(),\n                                            /*ForTakingAddress=*/false);\n\n  llvm::SmallDenseMap<FunctionDecl *, TemplateArgumentListInfo, 8>\n      ConvertedTemplateArgs;\n\n  DeclContext *FDLookupContext = FD->getDeclContext()->getRedeclContext();\n  for (LookupResult::iterator I = Previous.begin(), E = Previous.end();\n         I != E; ++I) {\n    NamedDecl *Ovl = (*I)->getUnderlyingDecl();\n    if (FunctionTemplateDecl *FunTmpl = dyn_cast<FunctionTemplateDecl>(Ovl)) {\n      // Only consider templates found within the same semantic lookup scope as\n      // FD.\n      if (!FDLookupContext->InEnclosingNamespaceSetOf(\n                                Ovl->getDeclContext()->getRedeclContext()))\n        continue;\n\n      // When matching a constexpr member function template specialization\n      // against the primary template, we don't yet know whether the\n      // specialization has an implicit 'const' (because we don't know whether\n      // it will be a static member function until we know which template it\n      // specializes), so adjust it now assuming it specializes this template.\n      QualType FT = FD->getType();\n      if (FD->isConstexpr()) {\n        CXXMethodDecl *OldMD =\n          dyn_cast<CXXMethodDecl>(FunTmpl->getTemplatedDecl());\n        if (OldMD && OldMD->isConst()) {\n          const FunctionProtoType *FPT = FT->castAs<FunctionProtoType>();\n          FunctionProtoType::ExtProtoInfo EPI = FPT->getExtProtoInfo();\n          EPI.TypeQuals.addConst();\n          FT = Context.getFunctionType(FPT->getReturnType(),\n                                       FPT->getParamTypes(), EPI);\n        }\n      }\n\n      TemplateArgumentListInfo Args;\n      if (ExplicitTemplateArgs)\n        Args = *ExplicitTemplateArgs;\n\n      // C++ [temp.expl.spec]p11:\n      //   A trailing template-argument can be left unspecified in the\n      //   template-id naming an explicit function template specialization\n      //   provided it can be deduced from the function argument type.\n      // Perform template argument deduction to determine whether we may be\n      // specializing this template.\n      // FIXME: It is somewhat wasteful to build\n      TemplateDeductionInfo Info(FailedCandidates.getLocation());\n      FunctionDecl *Specialization = nullptr;\n      if (TemplateDeductionResult TDK = DeduceTemplateArguments(\n              cast<FunctionTemplateDecl>(FunTmpl->getFirstDecl()),\n              ExplicitTemplateArgs ? &Args : nullptr, FT, Specialization,\n              Info)) {\n        // Template argument deduction failed; record why it failed, so\n        // that we can provide nifty diagnostics.\n        FailedCandidates.addCandidate().set(\n            I.getPair(), FunTmpl->getTemplatedDecl(),\n            MakeDeductionFailureInfo(Context, TDK, Info));\n        (void)TDK;\n        continue;\n      }\n\n      // Target attributes are part of the cuda function signature, so\n      // the deduced template's cuda target must match that of the\n      // specialization.  Given that C++ template deduction does not\n      // take target attributes into account, we reject candidates\n      // here that have a different target.\n      if (LangOpts.CUDA &&\n          IdentifyCUDATarget(Specialization,\n                             /* IgnoreImplicitHDAttr = */ true) !=\n              IdentifyCUDATarget(FD, /* IgnoreImplicitHDAttr = */ true)) {\n        FailedCandidates.addCandidate().set(\n            I.getPair(), FunTmpl->getTemplatedDecl(),\n            MakeDeductionFailureInfo(Context, TDK_CUDATargetMismatch, Info));\n        continue;\n      }\n\n      // Record this candidate.\n      if (ExplicitTemplateArgs)\n        ConvertedTemplateArgs[Specialization] = std::move(Args);\n      Candidates.addDecl(Specialization, I.getAccess());\n    }\n  }\n\n  // For a qualified friend declaration (with no explicit marker to indicate\n  // that a template specialization was intended), note all (template and\n  // non-template) candidates.\n  if (QualifiedFriend && Candidates.empty()) {\n    Diag(FD->getLocation(), diag::err_qualified_friend_no_match)\n        << FD->getDeclName() << FDLookupContext;\n    // FIXME: We should form a single candidate list and diagnose all\n    // candidates at once, to get proper sorting and limiting.\n    for (auto *OldND : Previous) {\n      if (auto *OldFD = dyn_cast<FunctionDecl>(OldND->getUnderlyingDecl()))\n        NoteOverloadCandidate(OldND, OldFD, CRK_None, FD->getType(), false);\n    }\n    FailedCandidates.NoteCandidates(*this, FD->getLocation());\n    return true;\n  }\n\n  // Find the most specialized function template.\n  UnresolvedSetIterator Result = getMostSpecialized(\n      Candidates.begin(), Candidates.end(), FailedCandidates, FD->getLocation(),\n      PDiag(diag::err_function_template_spec_no_match) << FD->getDeclName(),\n      PDiag(diag::err_function_template_spec_ambiguous)\n          << FD->getDeclName() << (ExplicitTemplateArgs != nullptr),\n      PDiag(diag::note_function_template_spec_matched));\n\n  if (Result == Candidates.end())\n    return true;\n\n  // Ignore access information;  it doesn't figure into redeclaration checking.\n  FunctionDecl *Specialization = cast<FunctionDecl>(*Result);\n\n  FunctionTemplateSpecializationInfo *SpecInfo\n    = Specialization->getTemplateSpecializationInfo();\n  assert(SpecInfo && \"Function template specialization info missing?\");\n\n  // Note: do not overwrite location info if previous template\n  // specialization kind was explicit.\n  TemplateSpecializationKind TSK = SpecInfo->getTemplateSpecializationKind();\n  if (TSK == TSK_Undeclared || TSK == TSK_ImplicitInstantiation) {\n    Specialization->setLocation(FD->getLocation());\n    Specialization->setLexicalDeclContext(FD->getLexicalDeclContext());\n    // C++11 [dcl.constexpr]p1: An explicit specialization of a constexpr\n    // function can differ from the template declaration with respect to\n    // the constexpr specifier.\n    // FIXME: We need an update record for this AST mutation.\n    // FIXME: What if there are multiple such prior declarations (for instance,\n    // from different modules)?\n    Specialization->setConstexprKind(FD->getConstexprKind());\n  }\n\n  // FIXME: Check if the prior specialization has a point of instantiation.\n  // If so, we have run afoul of .\n\n  // If this is a friend declaration, then we're not really declaring\n  // an explicit specialization.\n  bool isFriend = (FD->getFriendObjectKind() != Decl::FOK_None);\n\n  // Check the scope of this explicit specialization.\n  if (!isFriend &&\n      CheckTemplateSpecializationScope(*this,\n                                       Specialization->getPrimaryTemplate(),\n                                       Specialization, FD->getLocation(),\n                                       false))\n    return true;\n\n  // C++ [temp.expl.spec]p6:\n  //   If a template, a member template or the member of a class template is\n  //   explicitly specialized then that specialization shall be declared\n  //   before the first use of that specialization that would cause an implicit\n  //   instantiation to take place, in every translation unit in which such a\n  //   use occurs; no diagnostic is required.\n  bool HasNoEffect = false;\n  if (!isFriend &&\n      CheckSpecializationInstantiationRedecl(FD->getLocation(),\n                                             TSK_ExplicitSpecialization,\n                                             Specialization,\n                                   SpecInfo->getTemplateSpecializationKind(),\n                                         SpecInfo->getPointOfInstantiation(),\n                                             HasNoEffect))\n    return true;\n\n  // Mark the prior declaration as an explicit specialization, so that later\n  // clients know that this is an explicit specialization.\n  if (!isFriend) {\n    // Since explicit specializations do not inherit '=delete' from their\n    // primary function template - check if the 'specialization' that was\n    // implicitly generated (during template argument deduction for partial\n    // ordering) from the most specialized of all the function templates that\n    // 'FD' could have been specializing, has a 'deleted' definition.  If so,\n    // first check that it was implicitly generated during template argument\n    // deduction by making sure it wasn't referenced, and then reset the deleted\n    // flag to not-deleted, so that we can inherit that information from 'FD'.\n    if (Specialization->isDeleted() && !SpecInfo->isExplicitSpecialization() &&\n        !Specialization->getCanonicalDecl()->isReferenced()) {\n      // FIXME: This assert will not hold in the presence of modules.\n      assert(\n          Specialization->getCanonicalDecl() == Specialization &&\n          \"This must be the only existing declaration of this specialization\");\n      // FIXME: We need an update record for this AST mutation.\n      Specialization->setDeletedAsWritten(false);\n    }\n    // FIXME: We need an update record for this AST mutation.\n    SpecInfo->setTemplateSpecializationKind(TSK_ExplicitSpecialization);\n    MarkUnusedFileScopedDecl(Specialization);\n  }\n\n  // Turn the given function declaration into a function template\n  // specialization, with the template arguments from the previous\n  // specialization.\n  // Take copies of (semantic and syntactic) template argument lists.\n  const TemplateArgumentList* TemplArgs = new (Context)\n    TemplateArgumentList(Specialization->getTemplateSpecializationArgs());\n  FD->setFunctionTemplateSpecialization(\n      Specialization->getPrimaryTemplate(), TemplArgs, /*InsertPos=*/nullptr,\n      SpecInfo->getTemplateSpecializationKind(),\n      ExplicitTemplateArgs ? &ConvertedTemplateArgs[Specialization] : nullptr);\n\n  // A function template specialization inherits the target attributes\n  // of its template.  (We require the attributes explicitly in the\n  // code to match, but a template may have implicit attributes by\n  // virtue e.g. of being constexpr, and it passes these implicit\n  // attributes on to its specializations.)\n  if (LangOpts.CUDA)\n    inheritCUDATargetAttrs(FD, *Specialization->getPrimaryTemplate());\n\n  // The \"previous declaration\" for this function template specialization is\n  // the prior function template specialization.\n  Previous.clear();\n  Previous.addDecl(Specialization);\n  return false;\n}\n\n/// Perform semantic analysis for the given non-template member\n/// specialization.\n///\n/// This routine performs all of the semantic analysis required for an\n/// explicit member function specialization. On successful completion,\n/// the function declaration \\p FD will become a member function\n/// specialization.\n///\n/// \\param Member the member declaration, which will be updated to become a\n/// specialization.\n///\n/// \\param Previous the set of declarations, one of which may be specialized\n/// by this function specialization;  the set will be modified to contain the\n/// redeclared member.\nbool\nSema::CheckMemberSpecialization(NamedDecl *Member, LookupResult &Previous) {\n  assert(!isa<TemplateDecl>(Member) && \"Only for non-template members\");\n\n  // Try to find the member we are instantiating.\n  NamedDecl *FoundInstantiation = nullptr;\n  NamedDecl *Instantiation = nullptr;\n  NamedDecl *InstantiatedFrom = nullptr;\n  MemberSpecializationInfo *MSInfo = nullptr;\n\n  if (Previous.empty()) {\n    // Nowhere to look anyway.\n  } else if (FunctionDecl *Function = dyn_cast<FunctionDecl>(Member)) {\n    for (LookupResult::iterator I = Previous.begin(), E = Previous.end();\n           I != E; ++I) {\n      NamedDecl *D = (*I)->getUnderlyingDecl();\n      if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(D)) {\n        QualType Adjusted = Function->getType();\n        if (!hasExplicitCallingConv(Adjusted))\n          Adjusted = adjustCCAndNoReturn(Adjusted, Method->getType());\n        // This doesn't handle deduced return types, but both function\n        // declarations should be undeduced at this point.\n        if (Context.hasSameType(Adjusted, Method->getType())) {\n          FoundInstantiation = *I;\n          Instantiation = Method;\n          InstantiatedFrom = Method->getInstantiatedFromMemberFunction();\n          MSInfo = Method->getMemberSpecializationInfo();\n          break;\n        }\n      }\n    }\n  } else if (isa<VarDecl>(Member)) {\n    VarDecl *PrevVar;\n    if (Previous.isSingleResult() &&\n        (PrevVar = dyn_cast<VarDecl>(Previous.getFoundDecl())))\n      if (PrevVar->isStaticDataMember()) {\n        FoundInstantiation = Previous.getRepresentativeDecl();\n        Instantiation = PrevVar;\n        InstantiatedFrom = PrevVar->getInstantiatedFromStaticDataMember();\n        MSInfo = PrevVar->getMemberSpecializationInfo();\n      }\n  } else if (isa<RecordDecl>(Member)) {\n    CXXRecordDecl *PrevRecord;\n    if (Previous.isSingleResult() &&\n        (PrevRecord = dyn_cast<CXXRecordDecl>(Previous.getFoundDecl()))) {\n      FoundInstantiation = Previous.getRepresentativeDecl();\n      Instantiation = PrevRecord;\n      InstantiatedFrom = PrevRecord->getInstantiatedFromMemberClass();\n      MSInfo = PrevRecord->getMemberSpecializationInfo();\n    }\n  } else if (isa<EnumDecl>(Member)) {\n    EnumDecl *PrevEnum;\n    if (Previous.isSingleResult() &&\n        (PrevEnum = dyn_cast<EnumDecl>(Previous.getFoundDecl()))) {\n      FoundInstantiation = Previous.getRepresentativeDecl();\n      Instantiation = PrevEnum;\n      InstantiatedFrom = PrevEnum->getInstantiatedFromMemberEnum();\n      MSInfo = PrevEnum->getMemberSpecializationInfo();\n    }\n  }\n\n  if (!Instantiation) {\n    // There is no previous declaration that matches. Since member\n    // specializations are always out-of-line, the caller will complain about\n    // this mismatch later.\n    return false;\n  }\n\n  // A member specialization in a friend declaration isn't really declaring\n  // an explicit specialization, just identifying a specific (possibly implicit)\n  // specialization. Don't change the template specialization kind.\n  //\n  // FIXME: Is this really valid? Other compilers reject.\n  if (Member->getFriendObjectKind() != Decl::FOK_None) {\n    // Preserve instantiation information.\n    if (InstantiatedFrom && isa<CXXMethodDecl>(Member)) {\n      cast<CXXMethodDecl>(Member)->setInstantiationOfMemberFunction(\n                                      cast<CXXMethodDecl>(InstantiatedFrom),\n        cast<CXXMethodDecl>(Instantiation)->getTemplateSpecializationKind());\n    } else if (InstantiatedFrom && isa<CXXRecordDecl>(Member)) {\n      cast<CXXRecordDecl>(Member)->setInstantiationOfMemberClass(\n                                      cast<CXXRecordDecl>(InstantiatedFrom),\n        cast<CXXRecordDecl>(Instantiation)->getTemplateSpecializationKind());\n    }\n\n    Previous.clear();\n    Previous.addDecl(FoundInstantiation);\n    return false;\n  }\n\n  // Make sure that this is a specialization of a member.\n  if (!InstantiatedFrom) {\n    Diag(Member->getLocation(), diag::err_spec_member_not_instantiated)\n      << Member;\n    Diag(Instantiation->getLocation(), diag::note_specialized_decl);\n    return true;\n  }\n\n  // C++ [temp.expl.spec]p6:\n  //   If a template, a member template or the member of a class template is\n  //   explicitly specialized then that specialization shall be declared\n  //   before the first use of that specialization that would cause an implicit\n  //   instantiation to take place, in every translation unit in which such a\n  //   use occurs; no diagnostic is required.\n  assert(MSInfo && \"Member specialization info missing?\");\n\n  bool HasNoEffect = false;\n  if (CheckSpecializationInstantiationRedecl(Member->getLocation(),\n                                             TSK_ExplicitSpecialization,\n                                             Instantiation,\n                                     MSInfo->getTemplateSpecializationKind(),\n                                           MSInfo->getPointOfInstantiation(),\n                                             HasNoEffect))\n    return true;\n\n  // Check the scope of this explicit specialization.\n  if (CheckTemplateSpecializationScope(*this,\n                                       InstantiatedFrom,\n                                       Instantiation, Member->getLocation(),\n                                       false))\n    return true;\n\n  // Note that this member specialization is an \"instantiation of\" the\n  // corresponding member of the original template.\n  if (auto *MemberFunction = dyn_cast<FunctionDecl>(Member)) {\n    FunctionDecl *InstantiationFunction = cast<FunctionDecl>(Instantiation);\n    if (InstantiationFunction->getTemplateSpecializationKind() ==\n          TSK_ImplicitInstantiation) {\n      // Explicit specializations of member functions of class templates do not\n      // inherit '=delete' from the member function they are specializing.\n      if (InstantiationFunction->isDeleted()) {\n        // FIXME: This assert will not hold in the presence of modules.\n        assert(InstantiationFunction->getCanonicalDecl() ==\n               InstantiationFunction);\n        // FIXME: We need an update record for this AST mutation.\n        InstantiationFunction->setDeletedAsWritten(false);\n      }\n    }\n\n    MemberFunction->setInstantiationOfMemberFunction(\n        cast<CXXMethodDecl>(InstantiatedFrom), TSK_ExplicitSpecialization);\n  } else if (auto *MemberVar = dyn_cast<VarDecl>(Member)) {\n    MemberVar->setInstantiationOfStaticDataMember(\n        cast<VarDecl>(InstantiatedFrom), TSK_ExplicitSpecialization);\n  } else if (auto *MemberClass = dyn_cast<CXXRecordDecl>(Member)) {\n    MemberClass->setInstantiationOfMemberClass(\n        cast<CXXRecordDecl>(InstantiatedFrom), TSK_ExplicitSpecialization);\n  } else if (auto *MemberEnum = dyn_cast<EnumDecl>(Member)) {\n    MemberEnum->setInstantiationOfMemberEnum(\n        cast<EnumDecl>(InstantiatedFrom), TSK_ExplicitSpecialization);\n  } else {\n    llvm_unreachable(\"unknown member specialization kind\");\n  }\n\n  // Save the caller the trouble of having to figure out which declaration\n  // this specialization matches.\n  Previous.clear();\n  Previous.addDecl(FoundInstantiation);\n  return false;\n}\n\n/// Complete the explicit specialization of a member of a class template by\n/// updating the instantiated member to be marked as an explicit specialization.\n///\n/// \\param OrigD The member declaration instantiated from the template.\n/// \\param Loc The location of the explicit specialization of the member.\ntemplate<typename DeclT>\nstatic void completeMemberSpecializationImpl(Sema &S, DeclT *OrigD,\n                                             SourceLocation Loc) {\n  if (OrigD->getTemplateSpecializationKind() != TSK_ImplicitInstantiation)\n    return;\n\n  // FIXME: Inform AST mutation listeners of this AST mutation.\n  // FIXME: If there are multiple in-class declarations of the member (from\n  // multiple modules, or a declaration and later definition of a member type),\n  // should we update all of them?\n  OrigD->setTemplateSpecializationKind(TSK_ExplicitSpecialization);\n  OrigD->setLocation(Loc);\n}\n\nvoid Sema::CompleteMemberSpecialization(NamedDecl *Member,\n                                        LookupResult &Previous) {\n  NamedDecl *Instantiation = cast<NamedDecl>(Member->getCanonicalDecl());\n  if (Instantiation == Member)\n    return;\n\n  if (auto *Function = dyn_cast<CXXMethodDecl>(Instantiation))\n    completeMemberSpecializationImpl(*this, Function, Member->getLocation());\n  else if (auto *Var = dyn_cast<VarDecl>(Instantiation))\n    completeMemberSpecializationImpl(*this, Var, Member->getLocation());\n  else if (auto *Record = dyn_cast<CXXRecordDecl>(Instantiation))\n    completeMemberSpecializationImpl(*this, Record, Member->getLocation());\n  else if (auto *Enum = dyn_cast<EnumDecl>(Instantiation))\n    completeMemberSpecializationImpl(*this, Enum, Member->getLocation());\n  else\n    llvm_unreachable(\"unknown member specialization kind\");\n}\n\n/// Check the scope of an explicit instantiation.\n///\n/// \\returns true if a serious error occurs, false otherwise.\nstatic bool CheckExplicitInstantiationScope(Sema &S, NamedDecl *D,\n                                            SourceLocation InstLoc,\n                                            bool WasQualifiedName) {\n  DeclContext *OrigContext= D->getDeclContext()->getEnclosingNamespaceContext();\n  DeclContext *CurContext = S.CurContext->getRedeclContext();\n\n  if (CurContext->isRecord()) {\n    S.Diag(InstLoc, diag::err_explicit_instantiation_in_class)\n      << D;\n    return true;\n  }\n\n  // C++11 [temp.explicit]p3:\n  //   An explicit instantiation shall appear in an enclosing namespace of its\n  //   template. If the name declared in the explicit instantiation is an\n  //   unqualified name, the explicit instantiation shall appear in the\n  //   namespace where its template is declared or, if that namespace is inline\n  //   (7.3.1), any namespace from its enclosing namespace set.\n  //\n  // This is DR275, which we do not retroactively apply to C++98/03.\n  if (WasQualifiedName) {\n    if (CurContext->Encloses(OrigContext))\n      return false;\n  } else {\n    if (CurContext->InEnclosingNamespaceSetOf(OrigContext))\n      return false;\n  }\n\n  if (NamespaceDecl *NS = dyn_cast<NamespaceDecl>(OrigContext)) {\n    if (WasQualifiedName)\n      S.Diag(InstLoc,\n             S.getLangOpts().CPlusPlus11?\n               diag::err_explicit_instantiation_out_of_scope :\n               diag::warn_explicit_instantiation_out_of_scope_0x)\n        << D << NS;\n    else\n      S.Diag(InstLoc,\n             S.getLangOpts().CPlusPlus11?\n               diag::err_explicit_instantiation_unqualified_wrong_namespace :\n               diag::warn_explicit_instantiation_unqualified_wrong_namespace_0x)\n        << D << NS;\n  } else\n    S.Diag(InstLoc,\n           S.getLangOpts().CPlusPlus11?\n             diag::err_explicit_instantiation_must_be_global :\n             diag::warn_explicit_instantiation_must_be_global_0x)\n      << D;\n  S.Diag(D->getLocation(), diag::note_explicit_instantiation_here);\n  return false;\n}\n\n/// Common checks for whether an explicit instantiation of \\p D is valid.\nstatic bool CheckExplicitInstantiation(Sema &S, NamedDecl *D,\n                                       SourceLocation InstLoc,\n                                       bool WasQualifiedName,\n                                       TemplateSpecializationKind TSK) {\n  // C++ [temp.explicit]p13:\n  //   An explicit instantiation declaration shall not name a specialization of\n  //   a template with internal linkage.\n  if (TSK == TSK_ExplicitInstantiationDeclaration &&\n      D->getFormalLinkage() == InternalLinkage) {\n    S.Diag(InstLoc, diag::err_explicit_instantiation_internal_linkage) << D;\n    return true;\n  }\n\n  // C++11 [temp.explicit]p3: [DR 275]\n  //   An explicit instantiation shall appear in an enclosing namespace of its\n  //   template.\n  if (CheckExplicitInstantiationScope(S, D, InstLoc, WasQualifiedName))\n    return true;\n\n  return false;\n}\n\n/// Determine whether the given scope specifier has a template-id in it.\nstatic bool ScopeSpecifierHasTemplateId(const CXXScopeSpec &SS) {\n  if (!SS.isSet())\n    return false;\n\n  // C++11 [temp.explicit]p3:\n  //   If the explicit instantiation is for a member function, a member class\n  //   or a static data member of a class template specialization, the name of\n  //   the class template specialization in the qualified-id for the member\n  //   name shall be a simple-template-id.\n  //\n  // C++98 has the same restriction, just worded differently.\n  for (NestedNameSpecifier *NNS = SS.getScopeRep(); NNS;\n       NNS = NNS->getPrefix())\n    if (const Type *T = NNS->getAsType())\n      if (isa<TemplateSpecializationType>(T))\n        return true;\n\n  return false;\n}\n\n/// Make a dllexport or dllimport attr on a class template specialization take\n/// effect.\nstatic void dllExportImportClassTemplateSpecialization(\n    Sema &S, ClassTemplateSpecializationDecl *Def) {\n  auto *A = cast_or_null<InheritableAttr>(getDLLAttr(Def));\n  assert(A && \"dllExportImportClassTemplateSpecialization called \"\n              \"on Def without dllexport or dllimport\");\n\n  // We reject explicit instantiations in class scope, so there should\n  // never be any delayed exported classes to worry about.\n  assert(S.DelayedDllExportClasses.empty() &&\n         \"delayed exports present at explicit instantiation\");\n  S.checkClassLevelDLLAttribute(Def);\n\n  // Propagate attribute to base class templates.\n  for (auto &B : Def->bases()) {\n    if (auto *BT = dyn_cast_or_null<ClassTemplateSpecializationDecl>(\n            B.getType()->getAsCXXRecordDecl()))\n      S.propagateDLLAttrToBaseClassTemplate(Def, A, BT, B.getBeginLoc());\n  }\n\n  S.referenceDLLExportedClassMethods();\n}\n\n// Explicit instantiation of a class template specialization\nDeclResult Sema::ActOnExplicitInstantiation(\n    Scope *S, SourceLocation ExternLoc, SourceLocation TemplateLoc,\n    unsigned TagSpec, SourceLocation KWLoc, const CXXScopeSpec &SS,\n    TemplateTy TemplateD, SourceLocation TemplateNameLoc,\n    SourceLocation LAngleLoc, ASTTemplateArgsPtr TemplateArgsIn,\n    SourceLocation RAngleLoc, const ParsedAttributesView &Attr) {\n  // Find the class template we're specializing\n  TemplateName Name = TemplateD.get();\n  TemplateDecl *TD = Name.getAsTemplateDecl();\n  // Check that the specialization uses the same tag kind as the\n  // original template.\n  TagTypeKind Kind = TypeWithKeyword::getTagTypeKindForTypeSpec(TagSpec);\n  assert(Kind != TTK_Enum &&\n         \"Invalid enum tag in class template explicit instantiation!\");\n\n  ClassTemplateDecl *ClassTemplate = dyn_cast<ClassTemplateDecl>(TD);\n\n  if (!ClassTemplate) {\n    NonTagKind NTK = getNonTagTypeDeclKind(TD, Kind);\n    Diag(TemplateNameLoc, diag::err_tag_reference_non_tag) << TD << NTK << Kind;\n    Diag(TD->getLocation(), diag::note_previous_use);\n    return true;\n  }\n\n  if (!isAcceptableTagRedeclaration(ClassTemplate->getTemplatedDecl(),\n                                    Kind, /*isDefinition*/false, KWLoc,\n                                    ClassTemplate->getIdentifier())) {\n    Diag(KWLoc, diag::err_use_with_wrong_tag)\n      << ClassTemplate\n      << FixItHint::CreateReplacement(KWLoc,\n                            ClassTemplate->getTemplatedDecl()->getKindName());\n    Diag(ClassTemplate->getTemplatedDecl()->getLocation(),\n         diag::note_previous_use);\n    Kind = ClassTemplate->getTemplatedDecl()->getTagKind();\n  }\n\n  // C++0x [temp.explicit]p2:\n  //   There are two forms of explicit instantiation: an explicit instantiation\n  //   definition and an explicit instantiation declaration. An explicit\n  //   instantiation declaration begins with the extern keyword. [...]\n  TemplateSpecializationKind TSK = ExternLoc.isInvalid()\n                                       ? TSK_ExplicitInstantiationDefinition\n                                       : TSK_ExplicitInstantiationDeclaration;\n\n  if (TSK == TSK_ExplicitInstantiationDeclaration &&\n      !Context.getTargetInfo().getTriple().isWindowsGNUEnvironment()) {\n    // Check for dllexport class template instantiation declarations,\n    // except for MinGW mode.\n    for (const ParsedAttr &AL : Attr) {\n      if (AL.getKind() == ParsedAttr::AT_DLLExport) {\n        Diag(ExternLoc,\n             diag::warn_attribute_dllexport_explicit_instantiation_decl);\n        Diag(AL.getLoc(), diag::note_attribute);\n        break;\n      }\n    }\n\n    if (auto *A = ClassTemplate->getTemplatedDecl()->getAttr<DLLExportAttr>()) {\n      Diag(ExternLoc,\n           diag::warn_attribute_dllexport_explicit_instantiation_decl);\n      Diag(A->getLocation(), diag::note_attribute);\n    }\n  }\n\n  // In MSVC mode, dllimported explicit instantiation definitions are treated as\n  // instantiation declarations for most purposes.\n  bool DLLImportExplicitInstantiationDef = false;\n  if (TSK == TSK_ExplicitInstantiationDefinition &&\n      Context.getTargetInfo().getCXXABI().isMicrosoft()) {\n    // Check for dllimport class template instantiation definitions.\n    bool DLLImport =\n        ClassTemplate->getTemplatedDecl()->getAttr<DLLImportAttr>();\n    for (const ParsedAttr &AL : Attr) {\n      if (AL.getKind() == ParsedAttr::AT_DLLImport)\n        DLLImport = true;\n      if (AL.getKind() == ParsedAttr::AT_DLLExport) {\n        // dllexport trumps dllimport here.\n        DLLImport = false;\n        break;\n      }\n    }\n    if (DLLImport) {\n      TSK = TSK_ExplicitInstantiationDeclaration;\n      DLLImportExplicitInstantiationDef = true;\n    }\n  }\n\n  // Translate the parser's template argument list in our AST format.\n  TemplateArgumentListInfo TemplateArgs(LAngleLoc, RAngleLoc);\n  translateTemplateArguments(TemplateArgsIn, TemplateArgs);\n\n  // Check that the template argument list is well-formed for this\n  // template.\n  SmallVector<TemplateArgument, 4> Converted;\n  if (CheckTemplateArgumentList(ClassTemplate, TemplateNameLoc,\n                                TemplateArgs, false, Converted,\n                                /*UpdateArgsWithConversion=*/true))\n    return true;\n\n  // Find the class template specialization declaration that\n  // corresponds to these arguments.\n  void *InsertPos = nullptr;\n  ClassTemplateSpecializationDecl *PrevDecl\n    = ClassTemplate->findSpecialization(Converted, InsertPos);\n\n  TemplateSpecializationKind PrevDecl_TSK\n    = PrevDecl ? PrevDecl->getTemplateSpecializationKind() : TSK_Undeclared;\n\n  if (TSK == TSK_ExplicitInstantiationDefinition && PrevDecl != nullptr &&\n      Context.getTargetInfo().getTriple().isWindowsGNUEnvironment()) {\n    // Check for dllexport class template instantiation definitions in MinGW\n    // mode, if a previous declaration of the instantiation was seen.\n    for (const ParsedAttr &AL : Attr) {\n      if (AL.getKind() == ParsedAttr::AT_DLLExport) {\n        Diag(AL.getLoc(),\n             diag::warn_attribute_dllexport_explicit_instantiation_def);\n        break;\n      }\n    }\n  }\n\n  if (CheckExplicitInstantiation(*this, ClassTemplate, TemplateNameLoc,\n                                 SS.isSet(), TSK))\n    return true;\n\n  ClassTemplateSpecializationDecl *Specialization = nullptr;\n\n  bool HasNoEffect = false;\n  if (PrevDecl) {\n    if (CheckSpecializationInstantiationRedecl(TemplateNameLoc, TSK,\n                                               PrevDecl, PrevDecl_TSK,\n                                            PrevDecl->getPointOfInstantiation(),\n                                               HasNoEffect))\n      return PrevDecl;\n\n    // Even though HasNoEffect == true means that this explicit instantiation\n    // has no effect on semantics, we go on to put its syntax in the AST.\n\n    if (PrevDecl_TSK == TSK_ImplicitInstantiation ||\n        PrevDecl_TSK == TSK_Undeclared) {\n      // Since the only prior class template specialization with these\n      // arguments was referenced but not declared, reuse that\n      // declaration node as our own, updating the source location\n      // for the template name to reflect our new declaration.\n      // (Other source locations will be updated later.)\n      Specialization = PrevDecl;\n      Specialization->setLocation(TemplateNameLoc);\n      PrevDecl = nullptr;\n    }\n\n    if (PrevDecl_TSK == TSK_ExplicitInstantiationDeclaration &&\n        DLLImportExplicitInstantiationDef) {\n      // The new specialization might add a dllimport attribute.\n      HasNoEffect = false;\n    }\n  }\n\n  if (!Specialization) {\n    // Create a new class template specialization declaration node for\n    // this explicit specialization.\n    Specialization\n      = ClassTemplateSpecializationDecl::Create(Context, Kind,\n                                             ClassTemplate->getDeclContext(),\n                                                KWLoc, TemplateNameLoc,\n                                                ClassTemplate,\n                                                Converted,\n                                                PrevDecl);\n    SetNestedNameSpecifier(*this, Specialization, SS);\n\n    if (!HasNoEffect && !PrevDecl) {\n      // Insert the new specialization.\n      ClassTemplate->AddSpecialization(Specialization, InsertPos);\n    }\n  }\n\n  // Build the fully-sugared type for this explicit instantiation as\n  // the user wrote in the explicit instantiation itself. This means\n  // that we'll pretty-print the type retrieved from the\n  // specialization's declaration the way that the user actually wrote\n  // the explicit instantiation, rather than formatting the name based\n  // on the \"canonical\" representation used to store the template\n  // arguments in the specialization.\n  TypeSourceInfo *WrittenTy\n    = Context.getTemplateSpecializationTypeInfo(Name, TemplateNameLoc,\n                                                TemplateArgs,\n                                  Context.getTypeDeclType(Specialization));\n  Specialization->setTypeAsWritten(WrittenTy);\n\n  // Set source locations for keywords.\n  Specialization->setExternLoc(ExternLoc);\n  Specialization->setTemplateKeywordLoc(TemplateLoc);\n  Specialization->setBraceRange(SourceRange());\n\n  bool PreviouslyDLLExported = Specialization->hasAttr<DLLExportAttr>();\n  ProcessDeclAttributeList(S, Specialization, Attr);\n\n  // Add the explicit instantiation into its lexical context. However,\n  // since explicit instantiations are never found by name lookup, we\n  // just put it into the declaration context directly.\n  Specialization->setLexicalDeclContext(CurContext);\n  CurContext->addDecl(Specialization);\n\n  // Syntax is now OK, so return if it has no other effect on semantics.\n  if (HasNoEffect) {\n    // Set the template specialization kind.\n    Specialization->setTemplateSpecializationKind(TSK);\n    return Specialization;\n  }\n\n  // C++ [temp.explicit]p3:\n  //   A definition of a class template or class member template\n  //   shall be in scope at the point of the explicit instantiation of\n  //   the class template or class member template.\n  //\n  // This check comes when we actually try to perform the\n  // instantiation.\n  ClassTemplateSpecializationDecl *Def\n    = cast_or_null<ClassTemplateSpecializationDecl>(\n                                              Specialization->getDefinition());\n  if (!Def)\n    InstantiateClassTemplateSpecialization(TemplateNameLoc, Specialization, TSK);\n  else if (TSK == TSK_ExplicitInstantiationDefinition) {\n    MarkVTableUsed(TemplateNameLoc, Specialization, true);\n    Specialization->setPointOfInstantiation(Def->getPointOfInstantiation());\n  }\n\n  // Instantiate the members of this class template specialization.\n  Def = cast_or_null<ClassTemplateSpecializationDecl>(\n                                       Specialization->getDefinition());\n  if (Def) {\n    TemplateSpecializationKind Old_TSK = Def->getTemplateSpecializationKind();\n    // Fix a TSK_ExplicitInstantiationDeclaration followed by a\n    // TSK_ExplicitInstantiationDefinition\n    if (Old_TSK == TSK_ExplicitInstantiationDeclaration &&\n        (TSK == TSK_ExplicitInstantiationDefinition ||\n         DLLImportExplicitInstantiationDef)) {\n      // FIXME: Need to notify the ASTMutationListener that we did this.\n      Def->setTemplateSpecializationKind(TSK);\n\n      if (!getDLLAttr(Def) && getDLLAttr(Specialization) &&\n          (Context.getTargetInfo().shouldDLLImportComdatSymbols() &&\n           !Context.getTargetInfo().getTriple().isPS4CPU())) {\n        // An explicit instantiation definition can add a dll attribute to a\n        // template with a previous instantiation declaration. MinGW doesn't\n        // allow this.\n        auto *A = cast<InheritableAttr>(\n            getDLLAttr(Specialization)->clone(getASTContext()));\n        A->setInherited(true);\n        Def->addAttr(A);\n        dllExportImportClassTemplateSpecialization(*this, Def);\n      }\n    }\n\n    // Fix a TSK_ImplicitInstantiation followed by a\n    // TSK_ExplicitInstantiationDefinition\n    bool NewlyDLLExported =\n        !PreviouslyDLLExported && Specialization->hasAttr<DLLExportAttr>();\n    if (Old_TSK == TSK_ImplicitInstantiation && NewlyDLLExported &&\n        (Context.getTargetInfo().shouldDLLImportComdatSymbols() &&\n         !Context.getTargetInfo().getTriple().isPS4CPU())) {\n      // An explicit instantiation definition can add a dll attribute to a\n      // template with a previous implicit instantiation. MinGW doesn't allow\n      // this. We limit clang to only adding dllexport, to avoid potentially\n      // strange codegen behavior. For example, if we extend this conditional\n      // to dllimport, and we have a source file calling a method on an\n      // implicitly instantiated template class instance and then declaring a\n      // dllimport explicit instantiation definition for the same template\n      // class, the codegen for the method call will not respect the dllimport,\n      // while it will with cl. The Def will already have the DLL attribute,\n      // since the Def and Specialization will be the same in the case of\n      // Old_TSK == TSK_ImplicitInstantiation, and we already added the\n      // attribute to the Specialization; we just need to make it take effect.\n      assert(Def == Specialization &&\n             \"Def and Specialization should match for implicit instantiation\");\n      dllExportImportClassTemplateSpecialization(*this, Def);\n    }\n\n    // In MinGW mode, export the template instantiation if the declaration\n    // was marked dllexport.\n    if (PrevDecl_TSK == TSK_ExplicitInstantiationDeclaration &&\n        Context.getTargetInfo().getTriple().isWindowsGNUEnvironment() &&\n        PrevDecl->hasAttr<DLLExportAttr>()) {\n      dllExportImportClassTemplateSpecialization(*this, Def);\n    }\n\n    if (Def->hasAttr<MSInheritanceAttr>()) {\n      Specialization->addAttr(Def->getAttr<MSInheritanceAttr>());\n      Consumer.AssignInheritanceModel(Specialization);\n    }\n\n    // Set the template specialization kind. Make sure it is set before\n    // instantiating the members which will trigger ASTConsumer callbacks.\n    Specialization->setTemplateSpecializationKind(TSK);\n    InstantiateClassTemplateSpecializationMembers(TemplateNameLoc, Def, TSK);\n  } else {\n\n    // Set the template specialization kind.\n    Specialization->setTemplateSpecializationKind(TSK);\n  }\n\n  return Specialization;\n}\n\n// Explicit instantiation of a member class of a class template.\nDeclResult\nSema::ActOnExplicitInstantiation(Scope *S, SourceLocation ExternLoc,\n                                 SourceLocation TemplateLoc, unsigned TagSpec,\n                                 SourceLocation KWLoc, CXXScopeSpec &SS,\n                                 IdentifierInfo *Name, SourceLocation NameLoc,\n                                 const ParsedAttributesView &Attr) {\n\n  bool Owned = false;\n  bool IsDependent = false;\n  Decl *TagD = ActOnTag(S, TagSpec, Sema::TUK_Reference,\n                        KWLoc, SS, Name, NameLoc, Attr, AS_none,\n                        /*ModulePrivateLoc=*/SourceLocation(),\n                        MultiTemplateParamsArg(), Owned, IsDependent,\n                        SourceLocation(), false, TypeResult(),\n                        /*IsTypeSpecifier*/false,\n                        /*IsTemplateParamOrArg*/false);\n  assert(!IsDependent && \"explicit instantiation of dependent name not yet handled\");\n\n  if (!TagD)\n    return true;\n\n  TagDecl *Tag = cast<TagDecl>(TagD);\n  assert(!Tag->isEnum() && \"shouldn't see enumerations here\");\n\n  if (Tag->isInvalidDecl())\n    return true;\n\n  CXXRecordDecl *Record = cast<CXXRecordDecl>(Tag);\n  CXXRecordDecl *Pattern = Record->getInstantiatedFromMemberClass();\n  if (!Pattern) {\n    Diag(TemplateLoc, diag::err_explicit_instantiation_nontemplate_type)\n      << Context.getTypeDeclType(Record);\n    Diag(Record->getLocation(), diag::note_nontemplate_decl_here);\n    return true;\n  }\n\n  // C++0x [temp.explicit]p2:\n  //   If the explicit instantiation is for a class or member class, the\n  //   elaborated-type-specifier in the declaration shall include a\n  //   simple-template-id.\n  //\n  // C++98 has the same restriction, just worded differently.\n  if (!ScopeSpecifierHasTemplateId(SS))\n    Diag(TemplateLoc, diag::ext_explicit_instantiation_without_qualified_id)\n      << Record << SS.getRange();\n\n  // C++0x [temp.explicit]p2:\n  //   There are two forms of explicit instantiation: an explicit instantiation\n  //   definition and an explicit instantiation declaration. An explicit\n  //   instantiation declaration begins with the extern keyword. [...]\n  TemplateSpecializationKind TSK\n    = ExternLoc.isInvalid()? TSK_ExplicitInstantiationDefinition\n                           : TSK_ExplicitInstantiationDeclaration;\n\n  CheckExplicitInstantiation(*this, Record, NameLoc, true, TSK);\n\n  // Verify that it is okay to explicitly instantiate here.\n  CXXRecordDecl *PrevDecl\n    = cast_or_null<CXXRecordDecl>(Record->getPreviousDecl());\n  if (!PrevDecl && Record->getDefinition())\n    PrevDecl = Record;\n  if (PrevDecl) {\n    MemberSpecializationInfo *MSInfo = PrevDecl->getMemberSpecializationInfo();\n    bool HasNoEffect = false;\n    assert(MSInfo && \"No member specialization information?\");\n    if (CheckSpecializationInstantiationRedecl(TemplateLoc, TSK,\n                                               PrevDecl,\n                                        MSInfo->getTemplateSpecializationKind(),\n                                             MSInfo->getPointOfInstantiation(),\n                                               HasNoEffect))\n      return true;\n    if (HasNoEffect)\n      return TagD;\n  }\n\n  CXXRecordDecl *RecordDef\n    = cast_or_null<CXXRecordDecl>(Record->getDefinition());\n  if (!RecordDef) {\n    // C++ [temp.explicit]p3:\n    //   A definition of a member class of a class template shall be in scope\n    //   at the point of an explicit instantiation of the member class.\n    CXXRecordDecl *Def\n      = cast_or_null<CXXRecordDecl>(Pattern->getDefinition());\n    if (!Def) {\n      Diag(TemplateLoc, diag::err_explicit_instantiation_undefined_member)\n        << 0 << Record->getDeclName() << Record->getDeclContext();\n      Diag(Pattern->getLocation(), diag::note_forward_declaration)\n        << Pattern;\n      return true;\n    } else {\n      if (InstantiateClass(NameLoc, Record, Def,\n                           getTemplateInstantiationArgs(Record),\n                           TSK))\n        return true;\n\n      RecordDef = cast_or_null<CXXRecordDecl>(Record->getDefinition());\n      if (!RecordDef)\n        return true;\n    }\n  }\n\n  // Instantiate all of the members of the class.\n  InstantiateClassMembers(NameLoc, RecordDef,\n                          getTemplateInstantiationArgs(Record), TSK);\n\n  if (TSK == TSK_ExplicitInstantiationDefinition)\n    MarkVTableUsed(NameLoc, RecordDef, true);\n\n  // FIXME: We don't have any representation for explicit instantiations of\n  // member classes. Such a representation is not needed for compilation, but it\n  // should be available for clients that want to see all of the declarations in\n  // the source code.\n  return TagD;\n}\n\nDeclResult Sema::ActOnExplicitInstantiation(Scope *S,\n                                            SourceLocation ExternLoc,\n                                            SourceLocation TemplateLoc,\n                                            Declarator &D) {\n  // Explicit instantiations always require a name.\n  // TODO: check if/when DNInfo should replace Name.\n  DeclarationNameInfo NameInfo = GetNameForDeclarator(D);\n  DeclarationName Name = NameInfo.getName();\n  if (!Name) {\n    if (!D.isInvalidType())\n      Diag(D.getDeclSpec().getBeginLoc(),\n           diag::err_explicit_instantiation_requires_name)\n          << D.getDeclSpec().getSourceRange() << D.getSourceRange();\n\n    return true;\n  }\n\n  // The scope passed in may not be a decl scope.  Zip up the scope tree until\n  // we find one that is.\n  while ((S->getFlags() & Scope::DeclScope) == 0 ||\n         (S->getFlags() & Scope::TemplateParamScope) != 0)\n    S = S->getParent();\n\n  // Determine the type of the declaration.\n  TypeSourceInfo *T = GetTypeForDeclarator(D, S);\n  QualType R = T->getType();\n  if (R.isNull())\n    return true;\n\n  // C++ [dcl.stc]p1:\n  //   A storage-class-specifier shall not be specified in [...] an explicit\n  //   instantiation (14.7.2) directive.\n  if (D.getDeclSpec().getStorageClassSpec() == DeclSpec::SCS_typedef) {\n    Diag(D.getIdentifierLoc(), diag::err_explicit_instantiation_of_typedef)\n      << Name;\n    return true;\n  } else if (D.getDeclSpec().getStorageClassSpec()\n                                                != DeclSpec::SCS_unspecified) {\n    // Complain about then remove the storage class specifier.\n    Diag(D.getIdentifierLoc(), diag::err_explicit_instantiation_storage_class)\n      << FixItHint::CreateRemoval(D.getDeclSpec().getStorageClassSpecLoc());\n\n    D.getMutableDeclSpec().ClearStorageClassSpecs();\n  }\n\n  // C++0x [temp.explicit]p1:\n  //   [...] An explicit instantiation of a function template shall not use the\n  //   inline or constexpr specifiers.\n  // Presumably, this also applies to member functions of class templates as\n  // well.\n  if (D.getDeclSpec().isInlineSpecified())\n    Diag(D.getDeclSpec().getInlineSpecLoc(),\n         getLangOpts().CPlusPlus11 ?\n           diag::err_explicit_instantiation_inline :\n           diag::warn_explicit_instantiation_inline_0x)\n      << FixItHint::CreateRemoval(D.getDeclSpec().getInlineSpecLoc());\n  if (D.getDeclSpec().hasConstexprSpecifier() && R->isFunctionType())\n    // FIXME: Add a fix-it to remove the 'constexpr' and add a 'const' if one is\n    // not already specified.\n    Diag(D.getDeclSpec().getConstexprSpecLoc(),\n         diag::err_explicit_instantiation_constexpr);\n\n  // A deduction guide is not on the list of entities that can be explicitly\n  // instantiated.\n  if (Name.getNameKind() == DeclarationName::CXXDeductionGuideName) {\n    Diag(D.getDeclSpec().getBeginLoc(), diag::err_deduction_guide_specialized)\n        << /*explicit instantiation*/ 0;\n    return true;\n  }\n\n  // C++0x [temp.explicit]p2:\n  //   There are two forms of explicit instantiation: an explicit instantiation\n  //   definition and an explicit instantiation declaration. An explicit\n  //   instantiation declaration begins with the extern keyword. [...]\n  TemplateSpecializationKind TSK\n    = ExternLoc.isInvalid()? TSK_ExplicitInstantiationDefinition\n                           : TSK_ExplicitInstantiationDeclaration;\n\n  LookupResult Previous(*this, NameInfo, LookupOrdinaryName);\n  LookupParsedName(Previous, S, &D.getCXXScopeSpec());\n\n  if (!R->isFunctionType()) {\n    // C++ [temp.explicit]p1:\n    //   A [...] static data member of a class template can be explicitly\n    //   instantiated from the member definition associated with its class\n    //   template.\n    // C++1y [temp.explicit]p1:\n    //   A [...] variable [...] template specialization can be explicitly\n    //   instantiated from its template.\n    if (Previous.isAmbiguous())\n      return true;\n\n    VarDecl *Prev = Previous.getAsSingle<VarDecl>();\n    VarTemplateDecl *PrevTemplate = Previous.getAsSingle<VarTemplateDecl>();\n\n    if (!PrevTemplate) {\n      if (!Prev || !Prev->isStaticDataMember()) {\n        // We expect to see a static data member here.\n        Diag(D.getIdentifierLoc(), diag::err_explicit_instantiation_not_known)\n            << Name;\n        for (LookupResult::iterator P = Previous.begin(), PEnd = Previous.end();\n             P != PEnd; ++P)\n          Diag((*P)->getLocation(), diag::note_explicit_instantiation_here);\n        return true;\n      }\n\n      if (!Prev->getInstantiatedFromStaticDataMember()) {\n        // FIXME: Check for explicit specialization?\n        Diag(D.getIdentifierLoc(),\n             diag::err_explicit_instantiation_data_member_not_instantiated)\n            << Prev;\n        Diag(Prev->getLocation(), diag::note_explicit_instantiation_here);\n        // FIXME: Can we provide a note showing where this was declared?\n        return true;\n      }\n    } else {\n      // Explicitly instantiate a variable template.\n\n      // C++1y [dcl.spec.auto]p6:\n      //   ... A program that uses auto or decltype(auto) in a context not\n      //   explicitly allowed in this section is ill-formed.\n      //\n      // This includes auto-typed variable template instantiations.\n      if (R->isUndeducedType()) {\n        Diag(T->getTypeLoc().getBeginLoc(),\n             diag::err_auto_not_allowed_var_inst);\n        return true;\n      }\n\n      if (D.getName().getKind() != UnqualifiedIdKind::IK_TemplateId) {\n        // C++1y [temp.explicit]p3:\n        //   If the explicit instantiation is for a variable, the unqualified-id\n        //   in the declaration shall be a template-id.\n        Diag(D.getIdentifierLoc(),\n             diag::err_explicit_instantiation_without_template_id)\n          << PrevTemplate;\n        Diag(PrevTemplate->getLocation(),\n             diag::note_explicit_instantiation_here);\n        return true;\n      }\n\n      // Translate the parser's template argument list into our AST format.\n      TemplateArgumentListInfo TemplateArgs =\n          makeTemplateArgumentListInfo(*this, *D.getName().TemplateId);\n\n      DeclResult Res = CheckVarTemplateId(PrevTemplate, TemplateLoc,\n                                          D.getIdentifierLoc(), TemplateArgs);\n      if (Res.isInvalid())\n        return true;\n\n      if (!Res.isUsable()) {\n        // We somehow specified dependent template arguments in an explicit\n        // instantiation. This should probably only happen during error\n        // recovery.\n        Diag(D.getIdentifierLoc(), diag::err_explicit_instantiation_dependent);\n        return true;\n      }\n\n      // Ignore access control bits, we don't need them for redeclaration\n      // checking.\n      Prev = cast<VarDecl>(Res.get());\n    }\n\n    // C++0x [temp.explicit]p2:\n    //   If the explicit instantiation is for a member function, a member class\n    //   or a static data member of a class template specialization, the name of\n    //   the class template specialization in the qualified-id for the member\n    //   name shall be a simple-template-id.\n    //\n    // C++98 has the same restriction, just worded differently.\n    //\n    // This does not apply to variable template specializations, where the\n    // template-id is in the unqualified-id instead.\n    if (!ScopeSpecifierHasTemplateId(D.getCXXScopeSpec()) && !PrevTemplate)\n      Diag(D.getIdentifierLoc(),\n           diag::ext_explicit_instantiation_without_qualified_id)\n        << Prev << D.getCXXScopeSpec().getRange();\n\n    CheckExplicitInstantiation(*this, Prev, D.getIdentifierLoc(), true, TSK);\n\n    // Verify that it is okay to explicitly instantiate here.\n    TemplateSpecializationKind PrevTSK = Prev->getTemplateSpecializationKind();\n    SourceLocation POI = Prev->getPointOfInstantiation();\n    bool HasNoEffect = false;\n    if (CheckSpecializationInstantiationRedecl(D.getIdentifierLoc(), TSK, Prev,\n                                               PrevTSK, POI, HasNoEffect))\n      return true;\n\n    if (!HasNoEffect) {\n      // Instantiate static data member or variable template.\n      Prev->setTemplateSpecializationKind(TSK, D.getIdentifierLoc());\n      // Merge attributes.\n      ProcessDeclAttributeList(S, Prev, D.getDeclSpec().getAttributes());\n      if (TSK == TSK_ExplicitInstantiationDefinition)\n        InstantiateVariableDefinition(D.getIdentifierLoc(), Prev);\n    }\n\n    // Check the new variable specialization against the parsed input.\n    if (PrevTemplate && Prev && !Context.hasSameType(Prev->getType(), R)) {\n      Diag(T->getTypeLoc().getBeginLoc(),\n           diag::err_invalid_var_template_spec_type)\n          << 0 << PrevTemplate << R << Prev->getType();\n      Diag(PrevTemplate->getLocation(), diag::note_template_declared_here)\n          << 2 << PrevTemplate->getDeclName();\n      return true;\n    }\n\n    // FIXME: Create an ExplicitInstantiation node?\n    return (Decl*) nullptr;\n  }\n\n  // If the declarator is a template-id, translate the parser's template\n  // argument list into our AST format.\n  bool HasExplicitTemplateArgs = false;\n  TemplateArgumentListInfo TemplateArgs;\n  if (D.getName().getKind() == UnqualifiedIdKind::IK_TemplateId) {\n    TemplateArgs = makeTemplateArgumentListInfo(*this, *D.getName().TemplateId);\n    HasExplicitTemplateArgs = true;\n  }\n\n  // C++ [temp.explicit]p1:\n  //   A [...] function [...] can be explicitly instantiated from its template.\n  //   A member function [...] of a class template can be explicitly\n  //  instantiated from the member definition associated with its class\n  //  template.\n  UnresolvedSet<8> TemplateMatches;\n  FunctionDecl *NonTemplateMatch = nullptr;\n  TemplateSpecCandidateSet FailedCandidates(D.getIdentifierLoc());\n  for (LookupResult::iterator P = Previous.begin(), PEnd = Previous.end();\n       P != PEnd; ++P) {\n    NamedDecl *Prev = *P;\n    if (!HasExplicitTemplateArgs) {\n      if (CXXMethodDecl *Method = dyn_cast<CXXMethodDecl>(Prev)) {\n        QualType Adjusted = adjustCCAndNoReturn(R, Method->getType(),\n                                                /*AdjustExceptionSpec*/true);\n        if (Context.hasSameUnqualifiedType(Method->getType(), Adjusted)) {\n          if (Method->getPrimaryTemplate()) {\n            TemplateMatches.addDecl(Method, P.getAccess());\n          } else {\n            // FIXME: Can this assert ever happen?  Needs a test.\n            assert(!NonTemplateMatch && \"Multiple NonTemplateMatches\");\n            NonTemplateMatch = Method;\n          }\n        }\n      }\n    }\n\n    FunctionTemplateDecl *FunTmpl = dyn_cast<FunctionTemplateDecl>(Prev);\n    if (!FunTmpl)\n      continue;\n\n    TemplateDeductionInfo Info(FailedCandidates.getLocation());\n    FunctionDecl *Specialization = nullptr;\n    if (TemplateDeductionResult TDK\n          = DeduceTemplateArguments(FunTmpl,\n                               (HasExplicitTemplateArgs ? &TemplateArgs\n                                                        : nullptr),\n                                    R, Specialization, Info)) {\n      // Keep track of almost-matches.\n      FailedCandidates.addCandidate()\n          .set(P.getPair(), FunTmpl->getTemplatedDecl(),\n               MakeDeductionFailureInfo(Context, TDK, Info));\n      (void)TDK;\n      continue;\n    }\n\n    // Target attributes are part of the cuda function signature, so\n    // the cuda target of the instantiated function must match that of its\n    // template.  Given that C++ template deduction does not take\n    // target attributes into account, we reject candidates here that\n    // have a different target.\n    if (LangOpts.CUDA &&\n        IdentifyCUDATarget(Specialization,\n                           /* IgnoreImplicitHDAttr = */ true) !=\n            IdentifyCUDATarget(D.getDeclSpec().getAttributes())) {\n      FailedCandidates.addCandidate().set(\n          P.getPair(), FunTmpl->getTemplatedDecl(),\n          MakeDeductionFailureInfo(Context, TDK_CUDATargetMismatch, Info));\n      continue;\n    }\n\n    TemplateMatches.addDecl(Specialization, P.getAccess());\n  }\n\n  FunctionDecl *Specialization = NonTemplateMatch;\n  if (!Specialization) {\n    // Find the most specialized function template specialization.\n    UnresolvedSetIterator Result = getMostSpecialized(\n        TemplateMatches.begin(), TemplateMatches.end(), FailedCandidates,\n        D.getIdentifierLoc(),\n        PDiag(diag::err_explicit_instantiation_not_known) << Name,\n        PDiag(diag::err_explicit_instantiation_ambiguous) << Name,\n        PDiag(diag::note_explicit_instantiation_candidate));\n\n    if (Result == TemplateMatches.end())\n      return true;\n\n    // Ignore access control bits, we don't need them for redeclaration checking.\n    Specialization = cast<FunctionDecl>(*Result);\n  }\n\n  // C++11 [except.spec]p4\n  // In an explicit instantiation an exception-specification may be specified,\n  // but is not required.\n  // If an exception-specification is specified in an explicit instantiation\n  // directive, it shall be compatible with the exception-specifications of\n  // other declarations of that function.\n  if (auto *FPT = R->getAs<FunctionProtoType>())\n    if (FPT->hasExceptionSpec()) {\n      unsigned DiagID =\n          diag::err_mismatched_exception_spec_explicit_instantiation;\n      if (getLangOpts().MicrosoftExt)\n        DiagID = diag::ext_mismatched_exception_spec_explicit_instantiation;\n      bool Result = CheckEquivalentExceptionSpec(\n          PDiag(DiagID) << Specialization->getType(),\n          PDiag(diag::note_explicit_instantiation_here),\n          Specialization->getType()->getAs<FunctionProtoType>(),\n          Specialization->getLocation(), FPT, D.getBeginLoc());\n      // In Microsoft mode, mismatching exception specifications just cause a\n      // warning.\n      if (!getLangOpts().MicrosoftExt && Result)\n        return true;\n    }\n\n  if (Specialization->getTemplateSpecializationKind() == TSK_Undeclared) {\n    Diag(D.getIdentifierLoc(),\n         diag::err_explicit_instantiation_member_function_not_instantiated)\n      << Specialization\n      << (Specialization->getTemplateSpecializationKind() ==\n          TSK_ExplicitSpecialization);\n    Diag(Specialization->getLocation(), diag::note_explicit_instantiation_here);\n    return true;\n  }\n\n  FunctionDecl *PrevDecl = Specialization->getPreviousDecl();\n  if (!PrevDecl && Specialization->isThisDeclarationADefinition())\n    PrevDecl = Specialization;\n\n  if (PrevDecl) {\n    bool HasNoEffect = false;\n    if (CheckSpecializationInstantiationRedecl(D.getIdentifierLoc(), TSK,\n                                               PrevDecl,\n                                     PrevDecl->getTemplateSpecializationKind(),\n                                          PrevDecl->getPointOfInstantiation(),\n                                               HasNoEffect))\n      return true;\n\n    // FIXME: We may still want to build some representation of this\n    // explicit specialization.\n    if (HasNoEffect)\n      return (Decl*) nullptr;\n  }\n\n  // HACK: libc++ has a bug where it attempts to explicitly instantiate the\n  // functions\n  //     valarray<size_t>::valarray(size_t) and\n  //     valarray<size_t>::~valarray()\n  // that it declared to have internal linkage with the internal_linkage\n  // attribute. Ignore the explicit instantiation declaration in this case.\n  if (Specialization->hasAttr<InternalLinkageAttr>() &&\n      TSK == TSK_ExplicitInstantiationDeclaration) {\n    if (auto *RD = dyn_cast<CXXRecordDecl>(Specialization->getDeclContext()))\n      if (RD->getIdentifier() && RD->getIdentifier()->isStr(\"valarray\") &&\n          RD->isInStdNamespace())\n        return (Decl*) nullptr;\n  }\n\n  ProcessDeclAttributeList(S, Specialization, D.getDeclSpec().getAttributes());\n\n  // In MSVC mode, dllimported explicit instantiation definitions are treated as\n  // instantiation declarations.\n  if (TSK == TSK_ExplicitInstantiationDefinition &&\n      Specialization->hasAttr<DLLImportAttr>() &&\n      Context.getTargetInfo().getCXXABI().isMicrosoft())\n    TSK = TSK_ExplicitInstantiationDeclaration;\n\n  Specialization->setTemplateSpecializationKind(TSK, D.getIdentifierLoc());\n\n  if (Specialization->isDefined()) {\n    // Let the ASTConsumer know that this function has been explicitly\n    // instantiated now, and its linkage might have changed.\n    Consumer.HandleTopLevelDecl(DeclGroupRef(Specialization));\n  } else if (TSK == TSK_ExplicitInstantiationDefinition)\n    InstantiateFunctionDefinition(D.getIdentifierLoc(), Specialization);\n\n  // C++0x [temp.explicit]p2:\n  //   If the explicit instantiation is for a member function, a member class\n  //   or a static data member of a class template specialization, the name of\n  //   the class template specialization in the qualified-id for the member\n  //   name shall be a simple-template-id.\n  //\n  // C++98 has the same restriction, just worded differently.\n  FunctionTemplateDecl *FunTmpl = Specialization->getPrimaryTemplate();\n  if (D.getName().getKind() != UnqualifiedIdKind::IK_TemplateId && !FunTmpl &&\n      D.getCXXScopeSpec().isSet() &&\n      !ScopeSpecifierHasTemplateId(D.getCXXScopeSpec()))\n    Diag(D.getIdentifierLoc(),\n         diag::ext_explicit_instantiation_without_qualified_id)\n    << Specialization << D.getCXXScopeSpec().getRange();\n\n  CheckExplicitInstantiation(\n      *this,\n      FunTmpl ? (NamedDecl *)FunTmpl\n              : Specialization->getInstantiatedFromMemberFunction(),\n      D.getIdentifierLoc(), D.getCXXScopeSpec().isSet(), TSK);\n\n  // FIXME: Create some kind of ExplicitInstantiationDecl here.\n  return (Decl*) nullptr;\n}\n\nTypeResult\nSema::ActOnDependentTag(Scope *S, unsigned TagSpec, TagUseKind TUK,\n                        const CXXScopeSpec &SS, IdentifierInfo *Name,\n                        SourceLocation TagLoc, SourceLocation NameLoc) {\n  // This has to hold, because SS is expected to be defined.\n  assert(Name && \"Expected a name in a dependent tag\");\n\n  NestedNameSpecifier *NNS = SS.getScopeRep();\n  if (!NNS)\n    return true;\n\n  TagTypeKind Kind = TypeWithKeyword::getTagTypeKindForTypeSpec(TagSpec);\n\n  if (TUK == TUK_Declaration || TUK == TUK_Definition) {\n    Diag(NameLoc, diag::err_dependent_tag_decl)\n      << (TUK == TUK_Definition) << Kind << SS.getRange();\n    return true;\n  }\n\n  // Create the resulting type.\n  ElaboratedTypeKeyword Kwd = TypeWithKeyword::getKeywordForTagTypeKind(Kind);\n  QualType Result = Context.getDependentNameType(Kwd, NNS, Name);\n\n  // Create type-source location information for this type.\n  TypeLocBuilder TLB;\n  DependentNameTypeLoc TL = TLB.push<DependentNameTypeLoc>(Result);\n  TL.setElaboratedKeywordLoc(TagLoc);\n  TL.setQualifierLoc(SS.getWithLocInContext(Context));\n  TL.setNameLoc(NameLoc);\n  return CreateParsedType(Result, TLB.getTypeSourceInfo(Context, Result));\n}\n\nTypeResult\nSema::ActOnTypenameType(Scope *S, SourceLocation TypenameLoc,\n                        const CXXScopeSpec &SS, const IdentifierInfo &II,\n                        SourceLocation IdLoc) {\n  if (SS.isInvalid())\n    return true;\n\n  if (TypenameLoc.isValid() && S && !S->getTemplateParamParent())\n    Diag(TypenameLoc,\n         getLangOpts().CPlusPlus11 ?\n           diag::warn_cxx98_compat_typename_outside_of_template :\n           diag::ext_typename_outside_of_template)\n      << FixItHint::CreateRemoval(TypenameLoc);\n\n  NestedNameSpecifierLoc QualifierLoc = SS.getWithLocInContext(Context);\n  TypeSourceInfo *TSI = nullptr;\n  QualType T = CheckTypenameType(TypenameLoc.isValid()? ETK_Typename : ETK_None,\n                                 TypenameLoc, QualifierLoc, II, IdLoc, &TSI,\n                                 /*DeducedTSTContext=*/true);\n  if (T.isNull())\n    return true;\n  return CreateParsedType(T, TSI);\n}\n\nTypeResult\nSema::ActOnTypenameType(Scope *S,\n                        SourceLocation TypenameLoc,\n                        const CXXScopeSpec &SS,\n                        SourceLocation TemplateKWLoc,\n                        TemplateTy TemplateIn,\n                        IdentifierInfo *TemplateII,\n                        SourceLocation TemplateIILoc,\n                        SourceLocation LAngleLoc,\n                        ASTTemplateArgsPtr TemplateArgsIn,\n                        SourceLocation RAngleLoc) {\n  if (TypenameLoc.isValid() && S && !S->getTemplateParamParent())\n    Diag(TypenameLoc,\n         getLangOpts().CPlusPlus11 ?\n           diag::warn_cxx98_compat_typename_outside_of_template :\n           diag::ext_typename_outside_of_template)\n      << FixItHint::CreateRemoval(TypenameLoc);\n\n  // Strangely, non-type results are not ignored by this lookup, so the\n  // program is ill-formed if it finds an injected-class-name.\n  if (TypenameLoc.isValid()) {\n    auto *LookupRD =\n        dyn_cast_or_null<CXXRecordDecl>(computeDeclContext(SS, false));\n    if (LookupRD && LookupRD->getIdentifier() == TemplateII) {\n      Diag(TemplateIILoc,\n           diag::ext_out_of_line_qualified_id_type_names_constructor)\n        << TemplateII << 0 /*injected-class-name used as template name*/\n        << (TemplateKWLoc.isValid() ? 1 : 0 /*'template'/'typename' keyword*/);\n    }\n  }\n\n  // Translate the parser's template argument list in our AST format.\n  TemplateArgumentListInfo TemplateArgs(LAngleLoc, RAngleLoc);\n  translateTemplateArguments(TemplateArgsIn, TemplateArgs);\n\n  TemplateName Template = TemplateIn.get();\n  if (DependentTemplateName *DTN = Template.getAsDependentTemplateName()) {\n    // Construct a dependent template specialization type.\n    assert(DTN && \"dependent template has non-dependent name?\");\n    assert(DTN->getQualifier() == SS.getScopeRep());\n    QualType T = Context.getDependentTemplateSpecializationType(ETK_Typename,\n                                                          DTN->getQualifier(),\n                                                          DTN->getIdentifier(),\n                                                                TemplateArgs);\n\n    // Create source-location information for this type.\n    TypeLocBuilder Builder;\n    DependentTemplateSpecializationTypeLoc SpecTL\n    = Builder.push<DependentTemplateSpecializationTypeLoc>(T);\n    SpecTL.setElaboratedKeywordLoc(TypenameLoc);\n    SpecTL.setQualifierLoc(SS.getWithLocInContext(Context));\n    SpecTL.setTemplateKeywordLoc(TemplateKWLoc);\n    SpecTL.setTemplateNameLoc(TemplateIILoc);\n    SpecTL.setLAngleLoc(LAngleLoc);\n    SpecTL.setRAngleLoc(RAngleLoc);\n    for (unsigned I = 0, N = TemplateArgs.size(); I != N; ++I)\n      SpecTL.setArgLocInfo(I, TemplateArgs[I].getLocInfo());\n    return CreateParsedType(T, Builder.getTypeSourceInfo(Context, T));\n  }\n\n  QualType T = CheckTemplateIdType(Template, TemplateIILoc, TemplateArgs);\n  if (T.isNull())\n    return true;\n\n  // Provide source-location information for the template specialization type.\n  TypeLocBuilder Builder;\n  TemplateSpecializationTypeLoc SpecTL\n    = Builder.push<TemplateSpecializationTypeLoc>(T);\n  SpecTL.setTemplateKeywordLoc(TemplateKWLoc);\n  SpecTL.setTemplateNameLoc(TemplateIILoc);\n  SpecTL.setLAngleLoc(LAngleLoc);\n  SpecTL.setRAngleLoc(RAngleLoc);\n  for (unsigned I = 0, N = TemplateArgs.size(); I != N; ++I)\n    SpecTL.setArgLocInfo(I, TemplateArgs[I].getLocInfo());\n\n  T = Context.getElaboratedType(ETK_Typename, SS.getScopeRep(), T);\n  ElaboratedTypeLoc TL = Builder.push<ElaboratedTypeLoc>(T);\n  TL.setElaboratedKeywordLoc(TypenameLoc);\n  TL.setQualifierLoc(SS.getWithLocInContext(Context));\n\n  TypeSourceInfo *TSI = Builder.getTypeSourceInfo(Context, T);\n  return CreateParsedType(T, TSI);\n}\n\n\n/// Determine whether this failed name lookup should be treated as being\n/// disabled by a usage of std::enable_if.\nstatic bool isEnableIf(NestedNameSpecifierLoc NNS, const IdentifierInfo &II,\n                       SourceRange &CondRange, Expr *&Cond) {\n  // We must be looking for a ::type...\n  if (!II.isStr(\"type\"))\n    return false;\n\n  // ... within an explicitly-written template specialization...\n  if (!NNS || !NNS.getNestedNameSpecifier()->getAsType())\n    return false;\n  TypeLoc EnableIfTy = NNS.getTypeLoc();\n  TemplateSpecializationTypeLoc EnableIfTSTLoc =\n      EnableIfTy.getAs<TemplateSpecializationTypeLoc>();\n  if (!EnableIfTSTLoc || EnableIfTSTLoc.getNumArgs() == 0)\n    return false;\n  const TemplateSpecializationType *EnableIfTST = EnableIfTSTLoc.getTypePtr();\n\n  // ... which names a complete class template declaration...\n  const TemplateDecl *EnableIfDecl =\n    EnableIfTST->getTemplateName().getAsTemplateDecl();\n  if (!EnableIfDecl || EnableIfTST->isIncompleteType())\n    return false;\n\n  // ... called \"enable_if\".\n  const IdentifierInfo *EnableIfII =\n    EnableIfDecl->getDeclName().getAsIdentifierInfo();\n  if (!EnableIfII || !EnableIfII->isStr(\"enable_if\"))\n    return false;\n\n  // Assume the first template argument is the condition.\n  CondRange = EnableIfTSTLoc.getArgLoc(0).getSourceRange();\n\n  // Dig out the condition.\n  Cond = nullptr;\n  if (EnableIfTSTLoc.getArgLoc(0).getArgument().getKind()\n        != TemplateArgument::Expression)\n    return true;\n\n  Cond = EnableIfTSTLoc.getArgLoc(0).getSourceExpression();\n\n  // Ignore Boolean literals; they add no value.\n  if (isa<CXXBoolLiteralExpr>(Cond->IgnoreParenCasts()))\n    Cond = nullptr;\n\n  return true;\n}\n\nQualType\nSema::CheckTypenameType(ElaboratedTypeKeyword Keyword,\n                        SourceLocation KeywordLoc,\n                        NestedNameSpecifierLoc QualifierLoc,\n                        const IdentifierInfo &II,\n                        SourceLocation IILoc,\n                        TypeSourceInfo **TSI,\n                        bool DeducedTSTContext) {\n  QualType T = CheckTypenameType(Keyword, KeywordLoc, QualifierLoc, II, IILoc,\n                                 DeducedTSTContext);\n  if (T.isNull())\n    return QualType();\n\n  *TSI = Context.CreateTypeSourceInfo(T);\n  if (isa<DependentNameType>(T)) {\n    DependentNameTypeLoc TL =\n        (*TSI)->getTypeLoc().castAs<DependentNameTypeLoc>();\n    TL.setElaboratedKeywordLoc(KeywordLoc);\n    TL.setQualifierLoc(QualifierLoc);\n    TL.setNameLoc(IILoc);\n  } else {\n    ElaboratedTypeLoc TL = (*TSI)->getTypeLoc().castAs<ElaboratedTypeLoc>();\n    TL.setElaboratedKeywordLoc(KeywordLoc);\n    TL.setQualifierLoc(QualifierLoc);\n    TL.getNamedTypeLoc().castAs<TypeSpecTypeLoc>().setNameLoc(IILoc);\n  }\n  return T;\n}\n\n/// Build the type that describes a C++ typename specifier,\n/// e.g., \"typename T::type\".\nQualType\nSema::CheckTypenameType(ElaboratedTypeKeyword Keyword,\n                        SourceLocation KeywordLoc,\n                        NestedNameSpecifierLoc QualifierLoc,\n                        const IdentifierInfo &II,\n                        SourceLocation IILoc, bool DeducedTSTContext) {\n  CXXScopeSpec SS;\n  SS.Adopt(QualifierLoc);\n\n  DeclContext *Ctx = nullptr;\n  if (QualifierLoc) {\n    Ctx = computeDeclContext(SS);\n    if (!Ctx) {\n      // If the nested-name-specifier is dependent and couldn't be\n      // resolved to a type, build a typename type.\n      assert(QualifierLoc.getNestedNameSpecifier()->isDependent());\n      return Context.getDependentNameType(Keyword,\n                                          QualifierLoc.getNestedNameSpecifier(),\n                                          &II);\n    }\n\n    // If the nested-name-specifier refers to the current instantiation,\n    // the \"typename\" keyword itself is superfluous. In C++03, the\n    // program is actually ill-formed. However, DR 382 (in C++0x CD1)\n    // allows such extraneous \"typename\" keywords, and we retroactively\n    // apply this DR to C++03 code with only a warning. In any case we continue.\n\n    if (RequireCompleteDeclContext(SS, Ctx))\n      return QualType();\n  }\n\n  DeclarationName Name(&II);\n  LookupResult Result(*this, Name, IILoc, LookupOrdinaryName);\n  if (Ctx)\n    LookupQualifiedName(Result, Ctx, SS);\n  else\n    LookupName(Result, CurScope);\n  unsigned DiagID = 0;\n  Decl *Referenced = nullptr;\n  switch (Result.getResultKind()) {\n  case LookupResult::NotFound: {\n    // If we're looking up 'type' within a template named 'enable_if', produce\n    // a more specific diagnostic.\n    SourceRange CondRange;\n    Expr *Cond = nullptr;\n    if (Ctx && isEnableIf(QualifierLoc, II, CondRange, Cond)) {\n      // If we have a condition, narrow it down to the specific failed\n      // condition.\n      if (Cond) {\n        Expr *FailedCond;\n        std::string FailedDescription;\n        std::tie(FailedCond, FailedDescription) =\n          findFailedBooleanCondition(Cond);\n\n        Diag(FailedCond->getExprLoc(),\n             diag::err_typename_nested_not_found_requirement)\n          << FailedDescription\n          << FailedCond->getSourceRange();\n        return QualType();\n      }\n\n      Diag(CondRange.getBegin(),\n           diag::err_typename_nested_not_found_enable_if)\n          << Ctx << CondRange;\n      return QualType();\n    }\n\n    DiagID = Ctx ? diag::err_typename_nested_not_found\n                 : diag::err_unknown_typename;\n    break;\n  }\n\n  case LookupResult::FoundUnresolvedValue: {\n    // We found a using declaration that is a value. Most likely, the using\n    // declaration itself is meant to have the 'typename' keyword.\n    SourceRange FullRange(KeywordLoc.isValid() ? KeywordLoc : SS.getBeginLoc(),\n                          IILoc);\n    Diag(IILoc, diag::err_typename_refers_to_using_value_decl)\n      << Name << Ctx << FullRange;\n    if (UnresolvedUsingValueDecl *Using\n          = dyn_cast<UnresolvedUsingValueDecl>(Result.getRepresentativeDecl())){\n      SourceLocation Loc = Using->getQualifierLoc().getBeginLoc();\n      Diag(Loc, diag::note_using_value_decl_missing_typename)\n        << FixItHint::CreateInsertion(Loc, \"typename \");\n    }\n  }\n  // Fall through to create a dependent typename type, from which we can recover\n  // better.\n  LLVM_FALLTHROUGH;\n\n  case LookupResult::NotFoundInCurrentInstantiation:\n    // Okay, it's a member of an unknown instantiation.\n    return Context.getDependentNameType(Keyword,\n                                        QualifierLoc.getNestedNameSpecifier(),\n                                        &II);\n\n  case LookupResult::Found:\n    if (TypeDecl *Type = dyn_cast<TypeDecl>(Result.getFoundDecl())) {\n      // C++ [class.qual]p2:\n      //   In a lookup in which function names are not ignored and the\n      //   nested-name-specifier nominates a class C, if the name specified\n      //   after the nested-name-specifier, when looked up in C, is the\n      //   injected-class-name of C [...] then the name is instead considered\n      //   to name the constructor of class C.\n      //\n      // Unlike in an elaborated-type-specifier, function names are not ignored\n      // in typename-specifier lookup. However, they are ignored in all the\n      // contexts where we form a typename type with no keyword (that is, in\n      // mem-initializer-ids, base-specifiers, and elaborated-type-specifiers).\n      //\n      // FIXME: That's not strictly true: mem-initializer-id lookup does not\n      // ignore functions, but that appears to be an oversight.\n      auto *LookupRD = dyn_cast_or_null<CXXRecordDecl>(Ctx);\n      auto *FoundRD = dyn_cast<CXXRecordDecl>(Type);\n      if (Keyword == ETK_Typename && LookupRD && FoundRD &&\n          FoundRD->isInjectedClassName() &&\n          declaresSameEntity(LookupRD, cast<Decl>(FoundRD->getParent())))\n        Diag(IILoc, diag::ext_out_of_line_qualified_id_type_names_constructor)\n            << &II << 1 << 0 /*'typename' keyword used*/;\n\n      // We found a type. Build an ElaboratedType, since the\n      // typename-specifier was just sugar.\n      MarkAnyDeclReferenced(Type->getLocation(), Type, /*OdrUse=*/false);\n      return Context.getElaboratedType(Keyword,\n                                       QualifierLoc.getNestedNameSpecifier(),\n                                       Context.getTypeDeclType(Type));\n    }\n\n    // C++ [dcl.type.simple]p2:\n    //   A type-specifier of the form\n    //     typename[opt] nested-name-specifier[opt] template-name\n    //   is a placeholder for a deduced class type [...].\n    if (getLangOpts().CPlusPlus17) {\n      if (auto *TD = getAsTypeTemplateDecl(Result.getFoundDecl())) {\n        if (!DeducedTSTContext) {\n          QualType T(QualifierLoc\n                         ? QualifierLoc.getNestedNameSpecifier()->getAsType()\n                         : nullptr, 0);\n          if (!T.isNull())\n            Diag(IILoc, diag::err_dependent_deduced_tst)\n              << (int)getTemplateNameKindForDiagnostics(TemplateName(TD)) << T;\n          else\n            Diag(IILoc, diag::err_deduced_tst)\n              << (int)getTemplateNameKindForDiagnostics(TemplateName(TD));\n          Diag(TD->getLocation(), diag::note_template_decl_here);\n          return QualType();\n        }\n        return Context.getElaboratedType(\n            Keyword, QualifierLoc.getNestedNameSpecifier(),\n            Context.getDeducedTemplateSpecializationType(TemplateName(TD),\n                                                         QualType(), false));\n      }\n    }\n\n    DiagID = Ctx ? diag::err_typename_nested_not_type\n                 : diag::err_typename_not_type;\n    Referenced = Result.getFoundDecl();\n    break;\n\n  case LookupResult::FoundOverloaded:\n    DiagID = Ctx ? diag::err_typename_nested_not_type\n                 : diag::err_typename_not_type;\n    Referenced = *Result.begin();\n    break;\n\n  case LookupResult::Ambiguous:\n    return QualType();\n  }\n\n  // If we get here, it's because name lookup did not find a\n  // type. Emit an appropriate diagnostic and return an error.\n  SourceRange FullRange(KeywordLoc.isValid() ? KeywordLoc : SS.getBeginLoc(),\n                        IILoc);\n  if (Ctx)\n    Diag(IILoc, DiagID) << FullRange << Name << Ctx;\n  else\n    Diag(IILoc, DiagID) << FullRange << Name;\n  if (Referenced)\n    Diag(Referenced->getLocation(),\n         Ctx ? diag::note_typename_member_refers_here\n             : diag::note_typename_refers_here)\n      << Name;\n  return QualType();\n}\n\nnamespace {\n  // See Sema::RebuildTypeInCurrentInstantiation\n  class CurrentInstantiationRebuilder\n    : public TreeTransform<CurrentInstantiationRebuilder> {\n    SourceLocation Loc;\n    DeclarationName Entity;\n\n  public:\n    typedef TreeTransform<CurrentInstantiationRebuilder> inherited;\n\n    CurrentInstantiationRebuilder(Sema &SemaRef,\n                                  SourceLocation Loc,\n                                  DeclarationName Entity)\n    : TreeTransform<CurrentInstantiationRebuilder>(SemaRef),\n      Loc(Loc), Entity(Entity) { }\n\n    /// Determine whether the given type \\p T has already been\n    /// transformed.\n    ///\n    /// For the purposes of type reconstruction, a type has already been\n    /// transformed if it is NULL or if it is not dependent.\n    bool AlreadyTransformed(QualType T) {\n      return T.isNull() || !T->isInstantiationDependentType();\n    }\n\n    /// Returns the location of the entity whose type is being\n    /// rebuilt.\n    SourceLocation getBaseLocation() { return Loc; }\n\n    /// Returns the name of the entity whose type is being rebuilt.\n    DeclarationName getBaseEntity() { return Entity; }\n\n    /// Sets the \"base\" location and entity when that\n    /// information is known based on another transformation.\n    void setBase(SourceLocation Loc, DeclarationName Entity) {\n      this->Loc = Loc;\n      this->Entity = Entity;\n    }\n\n    ExprResult TransformLambdaExpr(LambdaExpr *E) {\n      // Lambdas never need to be transformed.\n      return E;\n    }\n  };\n} // end anonymous namespace\n\n/// Rebuilds a type within the context of the current instantiation.\n///\n/// The type \\p T is part of the type of an out-of-line member definition of\n/// a class template (or class template partial specialization) that was parsed\n/// and constructed before we entered the scope of the class template (or\n/// partial specialization thereof). This routine will rebuild that type now\n/// that we have entered the declarator's scope, which may produce different\n/// canonical types, e.g.,\n///\n/// \\code\n/// template<typename T>\n/// struct X {\n///   typedef T* pointer;\n///   pointer data();\n/// };\n///\n/// template<typename T>\n/// typename X<T>::pointer X<T>::data() { ... }\n/// \\endcode\n///\n/// Here, the type \"typename X<T>::pointer\" will be created as a DependentNameType,\n/// since we do not know that we can look into X<T> when we parsed the type.\n/// This function will rebuild the type, performing the lookup of \"pointer\"\n/// in X<T> and returning an ElaboratedType whose canonical type is the same\n/// as the canonical type of T*, allowing the return types of the out-of-line\n/// definition and the declaration to match.\nTypeSourceInfo *Sema::RebuildTypeInCurrentInstantiation(TypeSourceInfo *T,\n                                                        SourceLocation Loc,\n                                                        DeclarationName Name) {\n  if (!T || !T->getType()->isInstantiationDependentType())\n    return T;\n\n  CurrentInstantiationRebuilder Rebuilder(*this, Loc, Name);\n  return Rebuilder.TransformType(T);\n}\n\nExprResult Sema::RebuildExprInCurrentInstantiation(Expr *E) {\n  CurrentInstantiationRebuilder Rebuilder(*this, E->getExprLoc(),\n                                          DeclarationName());\n  return Rebuilder.TransformExpr(E);\n}\n\nbool Sema::RebuildNestedNameSpecifierInCurrentInstantiation(CXXScopeSpec &SS) {\n  if (SS.isInvalid())\n    return true;\n\n  NestedNameSpecifierLoc QualifierLoc = SS.getWithLocInContext(Context);\n  CurrentInstantiationRebuilder Rebuilder(*this, SS.getRange().getBegin(),\n                                          DeclarationName());\n  NestedNameSpecifierLoc Rebuilt\n    = Rebuilder.TransformNestedNameSpecifierLoc(QualifierLoc);\n  if (!Rebuilt)\n    return true;\n\n  SS.Adopt(Rebuilt);\n  return false;\n}\n\n/// Rebuild the template parameters now that we know we're in a current\n/// instantiation.\nbool Sema::RebuildTemplateParamsInCurrentInstantiation(\n                                               TemplateParameterList *Params) {\n  for (unsigned I = 0, N = Params->size(); I != N; ++I) {\n    Decl *Param = Params->getParam(I);\n\n    // There is nothing to rebuild in a type parameter.\n    if (isa<TemplateTypeParmDecl>(Param))\n      continue;\n\n    // Rebuild the template parameter list of a template template parameter.\n    if (TemplateTemplateParmDecl *TTP\n        = dyn_cast<TemplateTemplateParmDecl>(Param)) {\n      if (RebuildTemplateParamsInCurrentInstantiation(\n            TTP->getTemplateParameters()))\n        return true;\n\n      continue;\n    }\n\n    // Rebuild the type of a non-type template parameter.\n    NonTypeTemplateParmDecl *NTTP = cast<NonTypeTemplateParmDecl>(Param);\n    TypeSourceInfo *NewTSI\n      = RebuildTypeInCurrentInstantiation(NTTP->getTypeSourceInfo(),\n                                          NTTP->getLocation(),\n                                          NTTP->getDeclName());\n    if (!NewTSI)\n      return true;\n\n    if (NewTSI->getType()->isUndeducedType()) {\n      // C++17 [temp.dep.expr]p3:\n      //   An id-expression is type-dependent if it contains\n      //    - an identifier associated by name lookup with a non-type\n      //      template-parameter declared with a type that contains a\n      //      placeholder type (7.1.7.4),\n      NewTSI = SubstAutoTypeSourceInfo(NewTSI, Context.DependentTy);\n    }\n\n    if (NewTSI != NTTP->getTypeSourceInfo()) {\n      NTTP->setTypeSourceInfo(NewTSI);\n      NTTP->setType(NewTSI->getType());\n    }\n  }\n\n  return false;\n}\n\n/// Produces a formatted string that describes the binding of\n/// template parameters to template arguments.\nstd::string\nSema::getTemplateArgumentBindingsText(const TemplateParameterList *Params,\n                                      const TemplateArgumentList &Args) {\n  return getTemplateArgumentBindingsText(Params, Args.data(), Args.size());\n}\n\nstd::string\nSema::getTemplateArgumentBindingsText(const TemplateParameterList *Params,\n                                      const TemplateArgument *Args,\n                                      unsigned NumArgs) {\n  SmallString<128> Str;\n  llvm::raw_svector_ostream Out(Str);\n\n  if (!Params || Params->size() == 0 || NumArgs == 0)\n    return std::string();\n\n  for (unsigned I = 0, N = Params->size(); I != N; ++I) {\n    if (I >= NumArgs)\n      break;\n\n    if (I == 0)\n      Out << \"[with \";\n    else\n      Out << \", \";\n\n    if (const IdentifierInfo *Id = Params->getParam(I)->getIdentifier()) {\n      Out << Id->getName();\n    } else {\n      Out << '$' << I;\n    }\n\n    Out << \" = \";\n    Args[I].print(getPrintingPolicy(), Out);\n  }\n\n  Out << ']';\n  return std::string(Out.str());\n}\n\nvoid Sema::MarkAsLateParsedTemplate(FunctionDecl *FD, Decl *FnD,\n                                    CachedTokens &Toks) {\n  if (!FD)\n    return;\n\n  auto LPT = std::make_unique<LateParsedTemplate>();\n\n  // Take tokens to avoid allocations\n  LPT->Toks.swap(Toks);\n  LPT->D = FnD;\n  LateParsedTemplateMap.insert(std::make_pair(FD, std::move(LPT)));\n\n  FD->setLateTemplateParsed(true);\n}\n\nvoid Sema::UnmarkAsLateParsedTemplate(FunctionDecl *FD) {\n  if (!FD)\n    return;\n  FD->setLateTemplateParsed(false);\n}\n\nbool Sema::IsInsideALocalClassWithinATemplateFunction() {\n  DeclContext *DC = CurContext;\n\n  while (DC) {\n    if (CXXRecordDecl *RD = dyn_cast<CXXRecordDecl>(CurContext)) {\n      const FunctionDecl *FD = RD->isLocalClass();\n      return (FD && FD->getTemplatedKind() != FunctionDecl::TK_NonTemplate);\n    } else if (DC->isTranslationUnit() || DC->isNamespace())\n      return false;\n\n    DC = DC->getParent();\n  }\n  return false;\n}\n\nnamespace {\n/// Walk the path from which a declaration was instantiated, and check\n/// that every explicit specialization along that path is visible. This enforces\n/// C++ [temp.expl.spec]/6:\n///\n///   If a template, a member template or a member of a class template is\n///   explicitly specialized then that specialization shall be declared before\n///   the first use of that specialization that would cause an implicit\n///   instantiation to take place, in every translation unit in which such a\n///   use occurs; no diagnostic is required.\n///\n/// and also C++ [temp.class.spec]/1:\n///\n///   A partial specialization shall be declared before the first use of a\n///   class template specialization that would make use of the partial\n///   specialization as the result of an implicit or explicit instantiation\n///   in every translation unit in which such a use occurs; no diagnostic is\n///   required.\nclass ExplicitSpecializationVisibilityChecker {\n  Sema &S;\n  SourceLocation Loc;\n  llvm::SmallVector<Module *, 8> Modules;\n\npublic:\n  ExplicitSpecializationVisibilityChecker(Sema &S, SourceLocation Loc)\n      : S(S), Loc(Loc) {}\n\n  void check(NamedDecl *ND) {\n    if (auto *FD = dyn_cast<FunctionDecl>(ND))\n      return checkImpl(FD);\n    if (auto *RD = dyn_cast<CXXRecordDecl>(ND))\n      return checkImpl(RD);\n    if (auto *VD = dyn_cast<VarDecl>(ND))\n      return checkImpl(VD);\n    if (auto *ED = dyn_cast<EnumDecl>(ND))\n      return checkImpl(ED);\n  }\n\nprivate:\n  void diagnose(NamedDecl *D, bool IsPartialSpec) {\n    auto Kind = IsPartialSpec ? Sema::MissingImportKind::PartialSpecialization\n                              : Sema::MissingImportKind::ExplicitSpecialization;\n    const bool Recover = true;\n\n    // If we got a custom set of modules (because only a subset of the\n    // declarations are interesting), use them, otherwise let\n    // diagnoseMissingImport intelligently pick some.\n    if (Modules.empty())\n      S.diagnoseMissingImport(Loc, D, Kind, Recover);\n    else\n      S.diagnoseMissingImport(Loc, D, D->getLocation(), Modules, Kind, Recover);\n  }\n\n  // Check a specific declaration. There are three problematic cases:\n  //\n  //  1) The declaration is an explicit specialization of a template\n  //     specialization.\n  //  2) The declaration is an explicit specialization of a member of an\n  //     templated class.\n  //  3) The declaration is an instantiation of a template, and that template\n  //     is an explicit specialization of a member of a templated class.\n  //\n  // We don't need to go any deeper than that, as the instantiation of the\n  // surrounding class / etc is not triggered by whatever triggered this\n  // instantiation, and thus should be checked elsewhere.\n  template<typename SpecDecl>\n  void checkImpl(SpecDecl *Spec) {\n    bool IsHiddenExplicitSpecialization = false;\n    if (Spec->getTemplateSpecializationKind() == TSK_ExplicitSpecialization) {\n      IsHiddenExplicitSpecialization =\n          Spec->getMemberSpecializationInfo()\n              ? !S.hasVisibleMemberSpecialization(Spec, &Modules)\n              : !S.hasVisibleExplicitSpecialization(Spec, &Modules);\n    } else {\n      checkInstantiated(Spec);\n    }\n\n    if (IsHiddenExplicitSpecialization)\n      diagnose(Spec->getMostRecentDecl(), false);\n  }\n\n  void checkInstantiated(FunctionDecl *FD) {\n    if (auto *TD = FD->getPrimaryTemplate())\n      checkTemplate(TD);\n  }\n\n  void checkInstantiated(CXXRecordDecl *RD) {\n    auto *SD = dyn_cast<ClassTemplateSpecializationDecl>(RD);\n    if (!SD)\n      return;\n\n    auto From = SD->getSpecializedTemplateOrPartial();\n    if (auto *TD = From.dyn_cast<ClassTemplateDecl *>())\n      checkTemplate(TD);\n    else if (auto *TD =\n                 From.dyn_cast<ClassTemplatePartialSpecializationDecl *>()) {\n      if (!S.hasVisibleDeclaration(TD))\n        diagnose(TD, true);\n      checkTemplate(TD);\n    }\n  }\n\n  void checkInstantiated(VarDecl *RD) {\n    auto *SD = dyn_cast<VarTemplateSpecializationDecl>(RD);\n    if (!SD)\n      return;\n\n    auto From = SD->getSpecializedTemplateOrPartial();\n    if (auto *TD = From.dyn_cast<VarTemplateDecl *>())\n      checkTemplate(TD);\n    else if (auto *TD =\n                 From.dyn_cast<VarTemplatePartialSpecializationDecl *>()) {\n      if (!S.hasVisibleDeclaration(TD))\n        diagnose(TD, true);\n      checkTemplate(TD);\n    }\n  }\n\n  void checkInstantiated(EnumDecl *FD) {}\n\n  template<typename TemplDecl>\n  void checkTemplate(TemplDecl *TD) {\n    if (TD->isMemberSpecialization()) {\n      if (!S.hasVisibleMemberSpecialization(TD, &Modules))\n        diagnose(TD->getMostRecentDecl(), false);\n    }\n  }\n};\n} // end anonymous namespace\n\nvoid Sema::checkSpecializationVisibility(SourceLocation Loc, NamedDecl *Spec) {\n  if (!getLangOpts().Modules)\n    return;\n\n  ExplicitSpecializationVisibilityChecker(*this, Loc).check(Spec);\n}\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 44, "line": 75}, "message": "'MultiLevelTemplateArgumentList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Template.h", "reportHash": "91685a3969651ff225483d79e0474a75", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 2064}, "message": "'ExtractTypeForDeductionGuide' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplate.cpp", "reportHash": "876356809cb05940be0a13fff9c253f4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 45, "line": 2872}, "message": "'DependencyChecker' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplate.cpp", "reportHash": "fb4dffac7fc45ce5e24e4f2b343e8329", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 3554}, "message": "'FailedBooleanConditionPrinterHelper' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Sema/SemaTemplate.cpp", "reportHash": "9e1a426a24996b40f497a2b166258c9a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
