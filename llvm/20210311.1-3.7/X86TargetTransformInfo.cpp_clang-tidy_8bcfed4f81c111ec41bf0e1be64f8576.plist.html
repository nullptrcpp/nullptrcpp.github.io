<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h", "content": "//===- TargetTransformInfo.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This pass exposes codegen information to IR-level passes. Every\n/// transformation that uses codegen information is broken into three parts:\n/// 1. The IR-level analysis pass.\n/// 2. The IR-level transformation interface which provides the needed\n///    information.\n/// 3. Codegen-level implementation which uses target-specific hooks.\n///\n/// This file defines #2, which is the interface that IR-level transformations\n/// use for querying the codegen.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_TARGETTRANSFORMINFO_H\n#define LLVM_ANALYSIS_TARGETTRANSFORMINFO_H\n\n#include \"llvm/Analysis/IVDescriptors.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/InstructionCost.h\"\n#include <functional>\n\nnamespace llvm {\n\nnamespace Intrinsic {\ntypedef unsigned ID;\n}\n\nclass AssumptionCache;\nclass BlockFrequencyInfo;\nclass DominatorTree;\nclass BranchInst;\nclass CallBase;\nclass ExtractElementInst;\nclass Function;\nclass GlobalValue;\nclass InstCombiner;\nclass IntrinsicInst;\nclass LoadInst;\nclass LoopAccessInfo;\nclass Loop;\nclass LoopInfo;\nclass ProfileSummaryInfo;\nclass SCEV;\nclass ScalarEvolution;\nclass StoreInst;\nclass SwitchInst;\nclass TargetLibraryInfo;\nclass Type;\nclass User;\nclass Value;\nstruct KnownBits;\ntemplate <typename T> class Optional;\n\n/// Information about a load/store intrinsic defined by the target.\nstruct MemIntrinsicInfo {\n  /// This is the pointer that the intrinsic is loading from or storing to.\n  /// If this is non-null, then analysis/optimization passes can assume that\n  /// this intrinsic is functionally equivalent to a load/store from this\n  /// pointer.\n  Value *PtrVal = nullptr;\n\n  // Ordering for atomic operations.\n  AtomicOrdering Ordering = AtomicOrdering::NotAtomic;\n\n  // Same Id is set by the target for corresponding load/store intrinsics.\n  unsigned short MatchingId = 0;\n\n  bool ReadMem = false;\n  bool WriteMem = false;\n  bool IsVolatile = false;\n\n  bool isUnordered() const {\n    return (Ordering == AtomicOrdering::NotAtomic ||\n            Ordering == AtomicOrdering::Unordered) &&\n           !IsVolatile;\n  }\n};\n\n/// Attributes of a target dependent hardware loop.\nstruct HardwareLoopInfo {\n  HardwareLoopInfo() = delete;\n  HardwareLoopInfo(Loop *L) : L(L) {}\n  Loop *L = nullptr;\n  BasicBlock *ExitBlock = nullptr;\n  BranchInst *ExitBranch = nullptr;\n  const SCEV *TripCount = nullptr;\n  IntegerType *CountType = nullptr;\n  Value *LoopDecrement = nullptr; // Decrement the loop counter by this\n                                  // value in every iteration.\n  bool IsNestingLegal = false;    // Can a hardware loop be a parent to\n                                  // another hardware loop?\n  bool CounterInReg = false;      // Should loop counter be updated in\n                                  // the loop via a phi?\n  bool PerformEntryTest = false;  // Generate the intrinsic which also performs\n                                  // icmp ne zero on the loop counter value and\n                                  // produces an i1 to guard the loop entry.\n  bool isHardwareLoopCandidate(ScalarEvolution &SE, LoopInfo &LI,\n                               DominatorTree &DT, bool ForceNestedLoop = false,\n                               bool ForceHardwareLoopPHI = false);\n  bool canAnalyze(LoopInfo &LI);\n};\n\nclass IntrinsicCostAttributes {\n  const IntrinsicInst *II = nullptr;\n  Type *RetTy = nullptr;\n  Intrinsic::ID IID;\n  SmallVector<Type *, 4> ParamTys;\n  SmallVector<const Value *, 4> Arguments;\n  FastMathFlags FMF;\n  // If ScalarizationCost is UINT_MAX, the cost of scalarizing the\n  // arguments and the return value will be computed based on types.\n  unsigned ScalarizationCost = std::numeric_limits<unsigned>::max();\n\npublic:\n  IntrinsicCostAttributes(\n      Intrinsic::ID Id, const CallBase &CI,\n      unsigned ScalarizationCost = std::numeric_limits<unsigned>::max());\n\n  IntrinsicCostAttributes(\n      Intrinsic::ID Id, Type *RTy, ArrayRef<Type *> Tys,\n      FastMathFlags Flags = FastMathFlags(), const IntrinsicInst *I = nullptr,\n      unsigned ScalarCost = std::numeric_limits<unsigned>::max());\n\n  IntrinsicCostAttributes(Intrinsic::ID Id, Type *RTy,\n                          ArrayRef<const Value *> Args);\n\n  IntrinsicCostAttributes(\n      Intrinsic::ID Id, Type *RTy, ArrayRef<const Value *> Args,\n      ArrayRef<Type *> Tys, FastMathFlags Flags = FastMathFlags(),\n      const IntrinsicInst *I = nullptr,\n      unsigned ScalarCost = std::numeric_limits<unsigned>::max());\n\n  Intrinsic::ID getID() const { return IID; }\n  const IntrinsicInst *getInst() const { return II; }\n  Type *getReturnType() const { return RetTy; }\n  FastMathFlags getFlags() const { return FMF; }\n  unsigned getScalarizationCost() const { return ScalarizationCost; }\n  const SmallVectorImpl<const Value *> &getArgs() const { return Arguments; }\n  const SmallVectorImpl<Type *> &getArgTypes() const { return ParamTys; }\n\n  bool isTypeBasedOnly() const {\n    return Arguments.empty();\n  }\n\n  bool skipScalarizationCost() const {\n    return ScalarizationCost != std::numeric_limits<unsigned>::max();\n  }\n};\n\nclass TargetTransformInfo;\ntypedef TargetTransformInfo TTI;\n\n/// This pass provides access to the codegen interfaces that are needed\n/// for IR-level transformations.\nclass TargetTransformInfo {\npublic:\n  /// Construct a TTI object using a type implementing the \\c Concept\n  /// API below.\n  ///\n  /// This is used by targets to construct a TTI wrapping their target-specific\n  /// implementation that encodes appropriate costs for their target.\n  template <typename T> TargetTransformInfo(T Impl);\n\n  /// Construct a baseline TTI object using a minimal implementation of\n  /// the \\c Concept API below.\n  ///\n  /// The TTI implementation will reflect the information in the DataLayout\n  /// provided if non-null.\n  explicit TargetTransformInfo(const DataLayout &DL);\n\n  // Provide move semantics.\n  TargetTransformInfo(TargetTransformInfo &&Arg);\n  TargetTransformInfo &operator=(TargetTransformInfo &&RHS);\n\n  // We need to define the destructor out-of-line to define our sub-classes\n  // out-of-line.\n  ~TargetTransformInfo();\n\n  /// Handle the invalidation of this information.\n  ///\n  /// When used as a result of \\c TargetIRAnalysis this method will be called\n  /// when the function this was computed for changes. When it returns false,\n  /// the information is preserved across those changes.\n  bool invalidate(Function &, const PreservedAnalyses &,\n                  FunctionAnalysisManager::Invalidator &) {\n    // FIXME: We should probably in some way ensure that the subtarget\n    // information for a function hasn't changed.\n    return false;\n  }\n\n  /// \\name Generic Target Information\n  /// @{\n\n  /// The kind of cost model.\n  ///\n  /// There are several different cost models that can be customized by the\n  /// target. The normalization of each cost model may be target specific.\n  enum TargetCostKind {\n    TCK_RecipThroughput, ///< Reciprocal throughput.\n    TCK_Latency,         ///< The latency of instruction.\n    TCK_CodeSize,        ///< Instruction code size.\n    TCK_SizeAndLatency   ///< The weighted sum of size and latency.\n  };\n\n  /// Query the cost of a specified instruction.\n  ///\n  /// Clients should use this interface to query the cost of an existing\n  /// instruction. The instruction must have a valid parent (basic block).\n  ///\n  /// Note, this method does not cache the cost calculation and it\n  /// can be expensive in some cases.\n  InstructionCost getInstructionCost(const Instruction *I,\n                                     enum TargetCostKind kind) const {\n    InstructionCost Cost;\n    switch (kind) {\n    case TCK_RecipThroughput:\n      Cost = getInstructionThroughput(I);\n      break;\n    case TCK_Latency:\n      Cost = getInstructionLatency(I);\n      break;\n    case TCK_CodeSize:\n    case TCK_SizeAndLatency:\n      Cost = getUserCost(I, kind);\n      break;\n    }\n    if (Cost == -1)\n      Cost.setInvalid();\n    return Cost;\n  }\n\n  /// Underlying constants for 'cost' values in this interface.\n  ///\n  /// Many APIs in this interface return a cost. This enum defines the\n  /// fundamental values that should be used to interpret (and produce) those\n  /// costs. The costs are returned as an int rather than a member of this\n  /// enumeration because it is expected that the cost of one IR instruction\n  /// may have a multiplicative factor to it or otherwise won't fit directly\n  /// into the enum. Moreover, it is common to sum or average costs which works\n  /// better as simple integral values. Thus this enum only provides constants.\n  /// Also note that the returned costs are signed integers to make it natural\n  /// to add, subtract, and test with zero (a common boundary condition). It is\n  /// not expected that 2^32 is a realistic cost to be modeling at any point.\n  ///\n  /// Note that these costs should usually reflect the intersection of code-size\n  /// cost and execution cost. A free instruction is typically one that folds\n  /// into another instruction. For example, reg-to-reg moves can often be\n  /// skipped by renaming the registers in the CPU, but they still are encoded\n  /// and thus wouldn't be considered 'free' here.\n  enum TargetCostConstants {\n    TCC_Free = 0,     ///< Expected to fold away in lowering.\n    TCC_Basic = 1,    ///< The cost of a typical 'add' instruction.\n    TCC_Expensive = 4 ///< The cost of a 'div' instruction on x86.\n  };\n\n  /// Estimate the cost of a GEP operation when lowered.\n  int getGEPCost(Type *PointeeType, const Value *Ptr,\n                 ArrayRef<const Value *> Operands,\n                 TargetCostKind CostKind = TCK_SizeAndLatency) const;\n\n  /// \\returns A value by which our inlining threshold should be multiplied.\n  /// This is primarily used to bump up the inlining threshold wholesale on\n  /// targets where calls are unusually expensive.\n  ///\n  /// TODO: This is a rather blunt instrument.  Perhaps altering the costs of\n  /// individual classes of instructions would be better.\n  unsigned getInliningThresholdMultiplier() const;\n\n  /// \\returns A value to be added to the inlining threshold.\n  unsigned adjustInliningThreshold(const CallBase *CB) const;\n\n  /// \\returns Vector bonus in percent.\n  ///\n  /// Vector bonuses: We want to more aggressively inline vector-dense kernels\n  /// and apply this bonus based on the percentage of vector instructions. A\n  /// bonus is applied if the vector instructions exceed 50% and half that\n  /// amount is applied if it exceeds 10%. Note that these bonuses are some what\n  /// arbitrary and evolved over time by accident as much as because they are\n  /// principled bonuses.\n  /// FIXME: It would be nice to base the bonus values on something more\n  /// scientific. A target may has no bonus on vector instructions.\n  int getInlinerVectorBonusPercent() const;\n\n  /// \\return the expected cost of a memcpy, which could e.g. depend on the\n  /// source/destination type and alignment and the number of bytes copied.\n  int getMemcpyCost(const Instruction *I) const;\n\n  /// \\return The estimated number of case clusters when lowering \\p 'SI'.\n  /// \\p JTSize Set a jump table size only when \\p SI is suitable for a jump\n  /// table.\n  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,\n                                            unsigned &JTSize,\n                                            ProfileSummaryInfo *PSI,\n                                            BlockFrequencyInfo *BFI) const;\n\n  /// Estimate the cost of a given IR user when lowered.\n  ///\n  /// This can estimate the cost of either a ConstantExpr or Instruction when\n  /// lowered.\n  ///\n  /// \\p Operands is a list of operands which can be a result of transformations\n  /// of the current operands. The number of the operands on the list must equal\n  /// to the number of the current operands the IR user has. Their order on the\n  /// list must be the same as the order of the current operands the IR user\n  /// has.\n  ///\n  /// The returned cost is defined in terms of \\c TargetCostConstants, see its\n  /// comments for a detailed explanation of the cost values.\n  int getUserCost(const User *U, ArrayRef<const Value *> Operands,\n                  TargetCostKind CostKind) const;\n\n  /// This is a helper function which calls the two-argument getUserCost\n  /// with \\p Operands which are the current operands U has.\n  int getUserCost(const User *U, TargetCostKind CostKind) const {\n    SmallVector<const Value *, 4> Operands(U->operand_values());\n    return getUserCost(U, Operands, CostKind);\n  }\n\n  /// Return true if branch divergence exists.\n  ///\n  /// Branch divergence has a significantly negative impact on GPU performance\n  /// when threads in the same wavefront take different paths due to conditional\n  /// branches.\n  bool hasBranchDivergence() const;\n\n  /// Return true if the target prefers to use GPU divergence analysis to\n  /// replace the legacy version.\n  bool useGPUDivergenceAnalysis() const;\n\n  /// Returns whether V is a source of divergence.\n  ///\n  /// This function provides the target-dependent information for\n  /// the target-independent LegacyDivergenceAnalysis. LegacyDivergenceAnalysis\n  /// first builds the dependency graph, and then runs the reachability\n  /// algorithm starting with the sources of divergence.\n  bool isSourceOfDivergence(const Value *V) const;\n\n  // Returns true for the target specific\n  // set of operations which produce uniform result\n  // even taking non-uniform arguments\n  bool isAlwaysUniform(const Value *V) const;\n\n  /// Returns the address space ID for a target's 'flat' address space. Note\n  /// this is not necessarily the same as addrspace(0), which LLVM sometimes\n  /// refers to as the generic address space. The flat address space is a\n  /// generic address space that can be used access multiple segments of memory\n  /// with different address spaces. Access of a memory location through a\n  /// pointer with this address space is expected to be legal but slower\n  /// compared to the same memory location accessed through a pointer with a\n  /// different address space.\n  //\n  /// This is for targets with different pointer representations which can\n  /// be converted with the addrspacecast instruction. If a pointer is converted\n  /// to this address space, optimizations should attempt to replace the access\n  /// with the source address space.\n  ///\n  /// \\returns ~0u if the target does not have such a flat address space to\n  /// optimize away.\n  unsigned getFlatAddressSpace() const;\n\n  /// Return any intrinsic address operand indexes which may be rewritten if\n  /// they use a flat address space pointer.\n  ///\n  /// \\returns true if the intrinsic was handled.\n  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,\n                                  Intrinsic::ID IID) const;\n\n  bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const;\n\n  unsigned getAssumedAddrSpace(const Value *V) const;\n\n  /// Rewrite intrinsic call \\p II such that \\p OldV will be replaced with \\p\n  /// NewV, which has a different address space. This should happen for every\n  /// operand index that collectFlatAddressOperands returned for the intrinsic.\n  /// \\returns nullptr if the intrinsic was not handled. Otherwise, returns the\n  /// new value (which may be the original \\p II with modified operands).\n  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,\n                                          Value *NewV) const;\n\n  /// Test whether calls to a function lower to actual program function\n  /// calls.\n  ///\n  /// The idea is to test whether the program is likely to require a 'call'\n  /// instruction or equivalent in order to call the given function.\n  ///\n  /// FIXME: It's not clear that this is a good or useful query API. Client's\n  /// should probably move to simpler cost metrics using the above.\n  /// Alternatively, we could split the cost interface into distinct code-size\n  /// and execution-speed costs. This would allow modelling the core of this\n  /// query more accurately as a call is a single small instruction, but\n  /// incurs significant execution cost.\n  bool isLoweredToCall(const Function *F) const;\n\n  struct LSRCost {\n    /// TODO: Some of these could be merged. Also, a lexical ordering\n    /// isn't always optimal.\n    unsigned Insns;\n    unsigned NumRegs;\n    unsigned AddRecCost;\n    unsigned NumIVMuls;\n    unsigned NumBaseAdds;\n    unsigned ImmCost;\n    unsigned SetupCost;\n    unsigned ScaleCost;\n  };\n\n  /// Parameters that control the generic loop unrolling transformation.\n  struct UnrollingPreferences {\n    /// The cost threshold for the unrolled loop. Should be relative to the\n    /// getUserCost values returned by this API, and the expectation is that\n    /// the unrolled loop's instructions when run through that interface should\n    /// not exceed this cost. However, this is only an estimate. Also, specific\n    /// loops may be unrolled even with a cost above this threshold if deemed\n    /// profitable. Set this to UINT_MAX to disable the loop body cost\n    /// restriction.\n    unsigned Threshold;\n    /// If complete unrolling will reduce the cost of the loop, we will boost\n    /// the Threshold by a certain percent to allow more aggressive complete\n    /// unrolling. This value provides the maximum boost percentage that we\n    /// can apply to Threshold (The value should be no less than 100).\n    /// BoostedThreshold = Threshold * min(RolledCost / UnrolledCost,\n    ///                                    MaxPercentThresholdBoost / 100)\n    /// E.g. if complete unrolling reduces the loop execution time by 50%\n    /// then we boost the threshold by the factor of 2x. If unrolling is not\n    /// expected to reduce the running time, then we do not increase the\n    /// threshold.\n    unsigned MaxPercentThresholdBoost;\n    /// The cost threshold for the unrolled loop when optimizing for size (set\n    /// to UINT_MAX to disable).\n    unsigned OptSizeThreshold;\n    /// The cost threshold for the unrolled loop, like Threshold, but used\n    /// for partial/runtime unrolling (set to UINT_MAX to disable).\n    unsigned PartialThreshold;\n    /// The cost threshold for the unrolled loop when optimizing for size, like\n    /// OptSizeThreshold, but used for partial/runtime unrolling (set to\n    /// UINT_MAX to disable).\n    unsigned PartialOptSizeThreshold;\n    /// A forced unrolling factor (the number of concatenated bodies of the\n    /// original loop in the unrolled loop body). When set to 0, the unrolling\n    /// transformation will select an unrolling factor based on the current cost\n    /// threshold and other factors.\n    unsigned Count;\n    /// Default unroll count for loops with run-time trip count.\n    unsigned DefaultUnrollRuntimeCount;\n    // Set the maximum unrolling factor. The unrolling factor may be selected\n    // using the appropriate cost threshold, but may not exceed this number\n    // (set to UINT_MAX to disable). This does not apply in cases where the\n    // loop is being fully unrolled.\n    unsigned MaxCount;\n    /// Set the maximum unrolling factor for full unrolling. Like MaxCount, but\n    /// applies even if full unrolling is selected. This allows a target to fall\n    /// back to Partial unrolling if full unrolling is above FullUnrollMaxCount.\n    unsigned FullUnrollMaxCount;\n    // Represents number of instructions optimized when \"back edge\"\n    // becomes \"fall through\" in unrolled loop.\n    // For now we count a conditional branch on a backedge and a comparison\n    // feeding it.\n    unsigned BEInsns;\n    /// Allow partial unrolling (unrolling of loops to expand the size of the\n    /// loop body, not only to eliminate small constant-trip-count loops).\n    bool Partial;\n    /// Allow runtime unrolling (unrolling of loops to expand the size of the\n    /// loop body even when the number of loop iterations is not known at\n    /// compile time).\n    bool Runtime;\n    /// Allow generation of a loop remainder (extra iterations after unroll).\n    bool AllowRemainder;\n    /// Allow emitting expensive instructions (such as divisions) when computing\n    /// the trip count of a loop for runtime unrolling.\n    bool AllowExpensiveTripCount;\n    /// Apply loop unroll on any kind of loop\n    /// (mainly to loops that fail runtime unrolling).\n    bool Force;\n    /// Allow using trip count upper bound to unroll loops.\n    bool UpperBound;\n    /// Allow unrolling of all the iterations of the runtime loop remainder.\n    bool UnrollRemainder;\n    /// Allow unroll and jam. Used to enable unroll and jam for the target.\n    bool UnrollAndJam;\n    /// Threshold for unroll and jam, for inner loop size. The 'Threshold'\n    /// value above is used during unroll and jam for the outer loop size.\n    /// This value is used in the same manner to limit the size of the inner\n    /// loop.\n    unsigned UnrollAndJamInnerLoopThreshold;\n    /// Don't allow loop unrolling to simulate more than this number of\n    /// iterations when checking full unroll profitability\n    unsigned MaxIterationsCountToAnalyze;\n  };\n\n  /// Get target-customized preferences for the generic loop unrolling\n  /// transformation. The caller will initialize UP with the current\n  /// target-independent defaults.\n  void getUnrollingPreferences(Loop *L, ScalarEvolution &,\n                               UnrollingPreferences &UP) const;\n\n  /// Query the target whether it would be profitable to convert the given loop\n  /// into a hardware loop.\n  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,\n                                AssumptionCache &AC, TargetLibraryInfo *LibInfo,\n                                HardwareLoopInfo &HWLoopInfo) const;\n\n  /// Query the target whether it would be prefered to create a predicated\n  /// vector loop, which can avoid the need to emit a scalar epilogue loop.\n  bool preferPredicateOverEpilogue(Loop *L, LoopInfo *LI, ScalarEvolution &SE,\n                                   AssumptionCache &AC, TargetLibraryInfo *TLI,\n                                   DominatorTree *DT,\n                                   const LoopAccessInfo *LAI) const;\n\n  /// Query the target whether lowering of the llvm.get.active.lane.mask\n  /// intrinsic is supported.\n  bool emitGetActiveLaneMask() const;\n\n  // Parameters that control the loop peeling transformation\n  struct PeelingPreferences {\n    /// A forced peeling factor (the number of bodied of the original loop\n    /// that should be peeled off before the loop body). When set to 0, the\n    /// a peeling factor based on profile information and other factors.\n    unsigned PeelCount;\n    /// Allow peeling off loop iterations.\n    bool AllowPeeling;\n    /// Allow peeling off loop iterations for loop nests.\n    bool AllowLoopNestsPeeling;\n    /// Allow peeling basing on profile. Uses to enable peeling off all\n    /// iterations basing on provided profile.\n    /// If the value is true the peeling cost model can decide to peel only\n    /// some iterations and in this case it will set this to false.\n    bool PeelProfiledIterations;\n  };\n\n  /// Get target-customized preferences for the generic loop peeling\n  /// transformation. The caller will initialize \\p PP with the current\n  /// target-independent defaults with information from \\p L and \\p SE.\n  void getPeelingPreferences(Loop *L, ScalarEvolution &SE,\n                             PeelingPreferences &PP) const;\n\n  /// Targets can implement their own combinations for target-specific\n  /// intrinsics. This function will be called from the InstCombine pass every\n  /// time a target-specific intrinsic is encountered.\n  ///\n  /// \\returns None to not do anything target specific or a value that will be\n  /// returned from the InstCombiner. It is possible to return null and stop\n  /// further processing of the intrinsic by returning nullptr.\n  Optional<Instruction *> instCombineIntrinsic(InstCombiner &IC,\n                                               IntrinsicInst &II) const;\n  /// Can be used to implement target-specific instruction combining.\n  /// \\see instCombineIntrinsic\n  Optional<Value *>\n  simplifyDemandedUseBitsIntrinsic(InstCombiner &IC, IntrinsicInst &II,\n                                   APInt DemandedMask, KnownBits &Known,\n                                   bool &KnownBitsComputed) const;\n  /// Can be used to implement target-specific instruction combining.\n  /// \\see instCombineIntrinsic\n  Optional<Value *> simplifyDemandedVectorEltsIntrinsic(\n      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts, APInt &UndefElts,\n      APInt &UndefElts2, APInt &UndefElts3,\n      std::function<void(Instruction *, unsigned, APInt, APInt &)>\n          SimplifyAndSetOp) const;\n  /// @}\n\n  /// \\name Scalar Target Information\n  /// @{\n\n  /// Flags indicating the kind of support for population count.\n  ///\n  /// Compared to the SW implementation, HW support is supposed to\n  /// significantly boost the performance when the population is dense, and it\n  /// may or may not degrade performance if the population is sparse. A HW\n  /// support is considered as \"Fast\" if it can outperform, or is on a par\n  /// with, SW implementation when the population is sparse; otherwise, it is\n  /// considered as \"Slow\".\n  enum PopcntSupportKind { PSK_Software, PSK_SlowHardware, PSK_FastHardware };\n\n  /// Return true if the specified immediate is legal add immediate, that\n  /// is the target has add instructions which can add a register with the\n  /// immediate without having to materialize the immediate into a register.\n  bool isLegalAddImmediate(int64_t Imm) const;\n\n  /// Return true if the specified immediate is legal icmp immediate,\n  /// that is the target has icmp instructions which can compare a register\n  /// against the immediate without having to materialize the immediate into a\n  /// register.\n  bool isLegalICmpImmediate(int64_t Imm) const;\n\n  /// Return true if the addressing mode represented by AM is legal for\n  /// this target, for a load/store of the specified type.\n  /// The type may be VoidTy, in which case only return true if the addressing\n  /// mode is legal for a load/store of any legal type.\n  /// If target returns true in LSRWithInstrQueries(), I may be valid.\n  /// TODO: Handle pre/postinc as well.\n  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,\n                             bool HasBaseReg, int64_t Scale,\n                             unsigned AddrSpace = 0,\n                             Instruction *I = nullptr) const;\n\n  /// Return true if LSR cost of C1 is lower than C1.\n  bool isLSRCostLess(TargetTransformInfo::LSRCost &C1,\n                     TargetTransformInfo::LSRCost &C2) const;\n\n  /// Return true if LSR major cost is number of registers. Targets which\n  /// implement their own isLSRCostLess and unset number of registers as major\n  /// cost should return false, otherwise return true.\n  bool isNumRegsMajorCostOfLSR() const;\n\n  /// \\returns true if LSR should not optimize a chain that includes \\p I.\n  bool isProfitableLSRChainElement(Instruction *I) const;\n\n  /// Return true if the target can fuse a compare and branch.\n  /// Loop-strength-reduction (LSR) uses that knowledge to adjust its cost\n  /// calculation for the instructions in a loop.\n  bool canMacroFuseCmp() const;\n\n  /// Return true if the target can save a compare for loop count, for example\n  /// hardware loop saves a compare.\n  bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE, LoopInfo *LI,\n                  DominatorTree *DT, AssumptionCache *AC,\n                  TargetLibraryInfo *LibInfo) const;\n\n  enum AddressingModeKind {\n    AMK_PreIndexed,\n    AMK_PostIndexed,\n    AMK_None\n  };\n\n  /// Return the preferred addressing mode LSR should make efforts to generate.\n  AddressingModeKind getPreferredAddressingMode(const Loop *L,\n                                                ScalarEvolution *SE) const;\n\n  /// Return true if the target supports masked store.\n  bool isLegalMaskedStore(Type *DataType, Align Alignment) const;\n  /// Return true if the target supports masked load.\n  bool isLegalMaskedLoad(Type *DataType, Align Alignment) const;\n\n  /// Return true if the target supports nontemporal store.\n  bool isLegalNTStore(Type *DataType, Align Alignment) const;\n  /// Return true if the target supports nontemporal load.\n  bool isLegalNTLoad(Type *DataType, Align Alignment) const;\n\n  /// Return true if the target supports masked scatter.\n  bool isLegalMaskedScatter(Type *DataType, Align Alignment) const;\n  /// Return true if the target supports masked gather.\n  bool isLegalMaskedGather(Type *DataType, Align Alignment) const;\n\n  /// Return true if the target supports masked compress store.\n  bool isLegalMaskedCompressStore(Type *DataType) const;\n  /// Return true if the target supports masked expand load.\n  bool isLegalMaskedExpandLoad(Type *DataType) const;\n\n  /// Return true if the target has a unified operation to calculate division\n  /// and remainder. If so, the additional implicit multiplication and\n  /// subtraction required to calculate a remainder from division are free. This\n  /// can enable more aggressive transformations for division and remainder than\n  /// would typically be allowed using throughput or size cost models.\n  bool hasDivRemOp(Type *DataType, bool IsSigned) const;\n\n  /// Return true if the given instruction (assumed to be a memory access\n  /// instruction) has a volatile variant. If that's the case then we can avoid\n  /// addrspacecast to generic AS for volatile loads/stores. Default\n  /// implementation returns false, which prevents address space inference for\n  /// volatile loads/stores.\n  bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) const;\n\n  /// Return true if target doesn't mind addresses in vectors.\n  bool prefersVectorizedAddressing() const;\n\n  /// Return the cost of the scaling factor used in the addressing\n  /// mode represented by AM for this target, for a load/store\n  /// of the specified type.\n  /// If the AM is supported, the return value must be >= 0.\n  /// If the AM is not supported, it returns a negative value.\n  /// TODO: Handle pre/postinc as well.\n  int getScalingFactorCost(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,\n                           bool HasBaseReg, int64_t Scale,\n                           unsigned AddrSpace = 0) const;\n\n  /// Return true if the loop strength reduce pass should make\n  /// Instruction* based TTI queries to isLegalAddressingMode(). This is\n  /// needed on SystemZ, where e.g. a memcpy can only have a 12 bit unsigned\n  /// immediate offset and no index register.\n  bool LSRWithInstrQueries() const;\n\n  /// Return true if it's free to truncate a value of type Ty1 to type\n  /// Ty2. e.g. On x86 it's free to truncate a i32 value in register EAX to i16\n  /// by referencing its sub-register AX.\n  bool isTruncateFree(Type *Ty1, Type *Ty2) const;\n\n  /// Return true if it is profitable to hoist instruction in the\n  /// then/else to before if.\n  bool isProfitableToHoist(Instruction *I) const;\n\n  bool useAA() const;\n\n  /// Return true if this type is legal.\n  bool isTypeLegal(Type *Ty) const;\n\n  /// Returns the estimated number of registers required to represent \\p Ty.\n  unsigned getRegUsageForType(Type *Ty) const;\n\n  /// Return true if switches should be turned into lookup tables for the\n  /// target.\n  bool shouldBuildLookupTables() const;\n\n  /// Return true if switches should be turned into lookup tables\n  /// containing this constant value for the target.\n  bool shouldBuildLookupTablesForConstant(Constant *C) const;\n\n  /// Return true if the input function which is cold at all call sites,\n  ///  should use coldcc calling convention.\n  bool useColdCCForColdCall(Function &F) const;\n\n  /// Estimate the overhead of scalarizing an instruction. Insert and Extract\n  /// are set if the demanded result elements need to be inserted and/or\n  /// extracted from vectors.\n  unsigned getScalarizationOverhead(VectorType *Ty, const APInt &DemandedElts,\n                                    bool Insert, bool Extract) const;\n\n  /// Estimate the overhead of scalarizing an instructions unique\n  /// non-constant operands. The (potentially vector) types to use for each of\n  /// argument are passes via Tys.\n  unsigned getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,\n                                            ArrayRef<Type *> Tys) const;\n\n  /// If target has efficient vector element load/store instructions, it can\n  /// return true here so that insertion/extraction costs are not added to\n  /// the scalarization cost of a load/store.\n  bool supportsEfficientVectorElementLoadStore() const;\n\n  /// Don't restrict interleaved unrolling to small loops.\n  bool enableAggressiveInterleaving(bool LoopHasReductions) const;\n\n  /// Returns options for expansion of memcmp. IsZeroCmp is\n  // true if this is the expansion of memcmp(p1, p2, s) == 0.\n  struct MemCmpExpansionOptions {\n    // Return true if memcmp expansion is enabled.\n    operator bool() const { return MaxNumLoads > 0; }\n\n    // Maximum number of load operations.\n    unsigned MaxNumLoads = 0;\n\n    // The list of available load sizes (in bytes), sorted in decreasing order.\n    SmallVector<unsigned, 8> LoadSizes;\n\n    // For memcmp expansion when the memcmp result is only compared equal or\n    // not-equal to 0, allow up to this number of load pairs per block. As an\n    // example, this may allow 'memcmp(a, b, 3) == 0' in a single block:\n    //   a0 = load2bytes &a[0]\n    //   b0 = load2bytes &b[0]\n    //   a2 = load1byte  &a[2]\n    //   b2 = load1byte  &b[2]\n    //   r  = cmp eq (a0 ^ b0 | a2 ^ b2), 0\n    unsigned NumLoadsPerBlock = 1;\n\n    // Set to true to allow overlapping loads. For example, 7-byte compares can\n    // be done with two 4-byte compares instead of 4+2+1-byte compares. This\n    // requires all loads in LoadSizes to be doable in an unaligned way.\n    bool AllowOverlappingLoads = false;\n  };\n  MemCmpExpansionOptions enableMemCmpExpansion(bool OptSize,\n                                               bool IsZeroCmp) const;\n\n  /// Enable matching of interleaved access groups.\n  bool enableInterleavedAccessVectorization() const;\n\n  /// Enable matching of interleaved access groups that contain predicated\n  /// accesses or gaps and therefore vectorized using masked\n  /// vector loads/stores.\n  bool enableMaskedInterleavedAccessVectorization() const;\n\n  /// Indicate that it is potentially unsafe to automatically vectorize\n  /// floating-point operations because the semantics of vector and scalar\n  /// floating-point semantics may differ. For example, ARM NEON v7 SIMD math\n  /// does not support IEEE-754 denormal numbers, while depending on the\n  /// platform, scalar floating-point math does.\n  /// This applies to floating-point math operations and calls, not memory\n  /// operations, shuffles, or casts.\n  bool isFPVectorizationPotentiallyUnsafe() const;\n\n  /// Determine if the target supports unaligned memory accesses.\n  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,\n                                      unsigned AddressSpace = 0,\n                                      Align Alignment = Align(1),\n                                      bool *Fast = nullptr) const;\n\n  /// Return hardware support for population count.\n  PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) const;\n\n  /// Return true if the hardware has a fast square-root instruction.\n  bool haveFastSqrt(Type *Ty) const;\n\n  /// Return true if it is faster to check if a floating-point value is NaN\n  /// (or not-NaN) versus a comparison against a constant FP zero value.\n  /// Targets should override this if materializing a 0.0 for comparison is\n  /// generally as cheap as checking for ordered/unordered.\n  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) const;\n\n  /// Return the expected cost of supporting the floating point operation\n  /// of the specified type.\n  int getFPOpCost(Type *Ty) const;\n\n  /// Return the expected cost of materializing for the given integer\n  /// immediate of the specified type.\n  int getIntImmCost(const APInt &Imm, Type *Ty, TargetCostKind CostKind) const;\n\n  /// Return the expected cost of materialization for the given integer\n  /// immediate of the specified type for a given instruction. The cost can be\n  /// zero if the immediate can be folded into the specified instruction.\n  int getIntImmCostInst(unsigned Opc, unsigned Idx, const APInt &Imm, Type *Ty,\n                        TargetCostKind CostKind,\n                        Instruction *Inst = nullptr) const;\n  int getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx, const APInt &Imm,\n                          Type *Ty, TargetCostKind CostKind) const;\n\n  /// Return the expected cost for the given integer when optimising\n  /// for size. This is different than the other integer immediate cost\n  /// functions in that it is subtarget agnostic. This is useful when you e.g.\n  /// target one ISA such as Aarch32 but smaller encodings could be possible\n  /// with another such as Thumb. This return value is used as a penalty when\n  /// the total costs for a constant is calculated (the bigger the cost, the\n  /// more beneficial constant hoisting is).\n  int getIntImmCodeSizeCost(unsigned Opc, unsigned Idx, const APInt &Imm,\n                            Type *Ty) const;\n  /// @}\n\n  /// \\name Vector Target Information\n  /// @{\n\n  /// The various kinds of shuffle patterns for vector queries.\n  enum ShuffleKind {\n    SK_Broadcast,        ///< Broadcast element 0 to all other elements.\n    SK_Reverse,          ///< Reverse the order of the vector.\n    SK_Select,           ///< Selects elements from the corresponding lane of\n                         ///< either source operand. This is equivalent to a\n                         ///< vector select with a constant condition operand.\n    SK_Transpose,        ///< Transpose two vectors.\n    SK_InsertSubvector,  ///< InsertSubvector. Index indicates start offset.\n    SK_ExtractSubvector, ///< ExtractSubvector Index indicates start offset.\n    SK_PermuteTwoSrc,    ///< Merge elements from two source vectors into one\n                         ///< with any shuffle mask.\n    SK_PermuteSingleSrc  ///< Shuffle elements of single source vector with any\n                         ///< shuffle mask.\n  };\n\n  /// Kind of the reduction data.\n  enum ReductionKind {\n    RK_None,           /// Not a reduction.\n    RK_Arithmetic,     /// Binary reduction data.\n    RK_MinMax,         /// Min/max reduction data.\n    RK_UnsignedMinMax, /// Unsigned min/max reduction data.\n  };\n\n  /// Contains opcode + LHS/RHS parts of the reduction operations.\n  struct ReductionData {\n    ReductionData() = delete;\n    ReductionData(ReductionKind Kind, unsigned Opcode, Value *LHS, Value *RHS)\n        : Opcode(Opcode), LHS(LHS), RHS(RHS), Kind(Kind) {\n      assert(Kind != RK_None && \"expected binary or min/max reduction only.\");\n    }\n    unsigned Opcode = 0;\n    Value *LHS = nullptr;\n    Value *RHS = nullptr;\n    ReductionKind Kind = RK_None;\n    bool hasSameData(ReductionData &RD) const {\n      return Kind == RD.Kind && Opcode == RD.Opcode;\n    }\n  };\n\n  static ReductionKind matchPairwiseReduction(\n    const ExtractElementInst *ReduxRoot, unsigned &Opcode, VectorType *&Ty);\n\n  static ReductionKind matchVectorSplittingReduction(\n    const ExtractElementInst *ReduxRoot, unsigned &Opcode, VectorType *&Ty);\n\n  static ReductionKind matchVectorReduction(const ExtractElementInst *ReduxRoot,\n                                            unsigned &Opcode, VectorType *&Ty,\n                                            bool &IsPairwise);\n\n  /// Additional information about an operand's possible values.\n  enum OperandValueKind {\n    OK_AnyValue,               // Operand can have any value.\n    OK_UniformValue,           // Operand is uniform (splat of a value).\n    OK_UniformConstantValue,   // Operand is uniform constant.\n    OK_NonUniformConstantValue // Operand is a non uniform constant value.\n  };\n\n  /// Additional properties of an operand's values.\n  enum OperandValueProperties { OP_None = 0, OP_PowerOf2 = 1 };\n\n  /// \\return the number of registers in the target-provided register class.\n  unsigned getNumberOfRegisters(unsigned ClassID) const;\n\n  /// \\return the target-provided register class ID for the provided type,\n  /// accounting for type promotion and other type-legalization techniques that\n  /// the target might apply. However, it specifically does not account for the\n  /// scalarization or splitting of vector types. Should a vector type require\n  /// scalarization or splitting into multiple underlying vector registers, that\n  /// type should be mapped to a register class containing no registers.\n  /// Specifically, this is designed to provide a simple, high-level view of the\n  /// register allocation later performed by the backend. These register classes\n  /// don't necessarily map onto the register classes used by the backend.\n  /// FIXME: It's not currently possible to determine how many registers\n  /// are used by the provided type.\n  unsigned getRegisterClassForType(bool Vector, Type *Ty = nullptr) const;\n\n  /// \\return the target-provided register class name\n  const char *getRegisterClassName(unsigned ClassID) const;\n\n  /// \\return The width of the largest scalar or vector register type.\n  unsigned getRegisterBitWidth(bool Vector) const;\n\n  /// \\return The width of the smallest vector register type.\n  unsigned getMinVectorRegisterBitWidth() const;\n\n  /// \\return The maximum value of vscale if the target specifies an\n  ///  architectural maximum vector length, and None otherwise.\n  Optional<unsigned> getMaxVScale() const;\n\n  /// \\return True if the vectorization factor should be chosen to\n  /// make the vector of the smallest element type match the size of a\n  /// vector register. For wider element types, this could result in\n  /// creating vectors that span multiple vector registers.\n  /// If false, the vectorization factor will be chosen based on the\n  /// size of the widest element type.\n  bool shouldMaximizeVectorBandwidth(bool OptSize) const;\n\n  /// \\return The minimum vectorization factor for types of given element\n  /// bit width, or 0 if there is no minimum VF. The returned value only\n  /// applies when shouldMaximizeVectorBandwidth returns true.\n  /// If IsScalable is true, the returned ElementCount must be a scalable VF.\n  ElementCount getMinimumVF(unsigned ElemWidth, bool IsScalable) const;\n\n  /// \\return The maximum vectorization factor for types of given element\n  /// bit width and opcode, or 0 if there is no maximum VF.\n  /// Currently only used by the SLP vectorizer.\n  unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const;\n\n  /// \\return True if it should be considered for address type promotion.\n  /// \\p AllowPromotionWithoutCommonHeader Set true if promoting \\p I is\n  /// profitable without finding other extensions fed by the same input.\n  bool shouldConsiderAddressTypePromotion(\n      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) const;\n\n  /// \\return The size of a cache line in bytes.\n  unsigned getCacheLineSize() const;\n\n  /// The possible cache levels\n  enum class CacheLevel {\n    L1D, // The L1 data cache\n    L2D, // The L2 data cache\n\n    // We currently do not model L3 caches, as their sizes differ widely between\n    // microarchitectures. Also, we currently do not have a use for L3 cache\n    // size modeling yet.\n  };\n\n  /// \\return The size of the cache level in bytes, if available.\n  Optional<unsigned> getCacheSize(CacheLevel Level) const;\n\n  /// \\return The associativity of the cache level, if available.\n  Optional<unsigned> getCacheAssociativity(CacheLevel Level) const;\n\n  /// \\return How much before a load we should place the prefetch\n  /// instruction.  This is currently measured in number of\n  /// instructions.\n  unsigned getPrefetchDistance() const;\n\n  /// Some HW prefetchers can handle accesses up to a certain constant stride.\n  /// Sometimes prefetching is beneficial even below the HW prefetcher limit,\n  /// and the arguments provided are meant to serve as a basis for deciding this\n  /// for a particular loop.\n  ///\n  /// \\param NumMemAccesses        Number of memory accesses in the loop.\n  /// \\param NumStridedMemAccesses Number of the memory accesses that\n  ///                              ScalarEvolution could find a known stride\n  ///                              for.\n  /// \\param NumPrefetches         Number of software prefetches that will be\n  ///                              emitted as determined by the addresses\n  ///                              involved and the cache line size.\n  /// \\param HasCall               True if the loop contains a call.\n  ///\n  /// \\return This is the minimum stride in bytes where it makes sense to start\n  ///         adding SW prefetches. The default is 1, i.e. prefetch with any\n  ///         stride.\n  unsigned getMinPrefetchStride(unsigned NumMemAccesses,\n                                unsigned NumStridedMemAccesses,\n                                unsigned NumPrefetches, bool HasCall) const;\n\n  /// \\return The maximum number of iterations to prefetch ahead.  If\n  /// the required number of iterations is more than this number, no\n  /// prefetching is performed.\n  unsigned getMaxPrefetchIterationsAhead() const;\n\n  /// \\return True if prefetching should also be done for writes.\n  bool enableWritePrefetching() const;\n\n  /// \\return The maximum interleave factor that any transform should try to\n  /// perform for this target. This number depends on the level of parallelism\n  /// and the number of execution units in the CPU.\n  unsigned getMaxInterleaveFactor(unsigned VF) const;\n\n  /// Collect properties of V used in cost analysis, e.g. OP_PowerOf2.\n  static OperandValueKind getOperandInfo(const Value *V,\n                                         OperandValueProperties &OpProps);\n\n  /// This is an approximation of reciprocal throughput of a math/logic op.\n  /// A higher cost indicates less expected throughput.\n  /// From Agner Fog's guides, reciprocal throughput is \"the average number of\n  /// clock cycles per instruction when the instructions are not part of a\n  /// limiting dependency chain.\"\n  /// Therefore, costs should be scaled to account for multiple execution units\n  /// on the target that can process this type of instruction. For example, if\n  /// there are 5 scalar integer units and 2 vector integer units that can\n  /// calculate an 'add' in a single cycle, this model should indicate that the\n  /// cost of the vector add instruction is 2.5 times the cost of the scalar\n  /// add instruction.\n  /// \\p Args is an optional argument which holds the instruction operands\n  /// values so the TTI can analyze those values searching for special\n  /// cases or optimizations based on those values.\n  /// \\p CxtI is the optional original context instruction, if one exists, to\n  /// provide even more information.\n  int getArithmeticInstrCost(\n      unsigned Opcode, Type *Ty,\n      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,\n      OperandValueKind Opd1Info = OK_AnyValue,\n      OperandValueKind Opd2Info = OK_AnyValue,\n      OperandValueProperties Opd1PropInfo = OP_None,\n      OperandValueProperties Opd2PropInfo = OP_None,\n      ArrayRef<const Value *> Args = ArrayRef<const Value *>(),\n      const Instruction *CxtI = nullptr) const;\n\n  /// \\return The cost of a shuffle instruction of kind Kind and of type Tp.\n  /// The index and subtype parameters are used by the subvector insertion and\n  /// extraction shuffle kinds to show the insert/extract point and the type of\n  /// the subvector being inserted/extracted.\n  /// NOTE: For subvector extractions Tp represents the source type.\n  int getShuffleCost(ShuffleKind Kind, VectorType *Tp, int Index = 0,\n                     VectorType *SubTp = nullptr) const;\n\n  /// Represents a hint about the context in which a cast is used.\n  ///\n  /// For zext/sext, the context of the cast is the operand, which must be a\n  /// load of some kind. For trunc, the context is of the cast is the single\n  /// user of the instruction, which must be a store of some kind.\n  ///\n  /// This enum allows the vectorizer to give getCastInstrCost an idea of the\n  /// type of cast it's dealing with, as not every cast is equal. For instance,\n  /// the zext of a load may be free, but the zext of an interleaving load can\n  //// be (very) expensive!\n  ///\n  /// See \\c getCastContextHint to compute a CastContextHint from a cast\n  /// Instruction*. Callers can use it if they don't need to override the\n  /// context and just want it to be calculated from the instruction.\n  ///\n  /// FIXME: This handles the types of load/store that the vectorizer can\n  /// produce, which are the cases where the context instruction is most\n  /// likely to be incorrect. There are other situations where that can happen\n  /// too, which might be handled here but in the long run a more general\n  /// solution of costing multiple instructions at the same times may be better.\n  enum class CastContextHint : uint8_t {\n    None,          ///< The cast is not used with a load/store of any kind.\n    Normal,        ///< The cast is used with a normal load/store.\n    Masked,        ///< The cast is used with a masked load/store.\n    GatherScatter, ///< The cast is used with a gather/scatter.\n    Interleave,    ///< The cast is used with an interleaved load/store.\n    Reversed,      ///< The cast is used with a reversed load/store.\n  };\n\n  /// Calculates a CastContextHint from \\p I.\n  /// This should be used by callers of getCastInstrCost if they wish to\n  /// determine the context from some instruction.\n  /// \\returns the CastContextHint for ZExt/SExt/Trunc, None if \\p I is nullptr,\n  /// or if it's another type of cast.\n  static CastContextHint getCastContextHint(const Instruction *I);\n\n  /// \\return The expected cost of cast instructions, such as bitcast, trunc,\n  /// zext, etc. If there is an existing instruction that holds Opcode, it\n  /// may be passed in the 'I' parameter.\n  int getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,\n                       TTI::CastContextHint CCH,\n                       TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency,\n                       const Instruction *I = nullptr) const;\n\n  /// \\return The expected cost of a sign- or zero-extended vector extract. Use\n  /// -1 to indicate that there is no information about the index value.\n  int getExtractWithExtendCost(unsigned Opcode, Type *Dst, VectorType *VecTy,\n                               unsigned Index = -1) const;\n\n  /// \\return The expected cost of control-flow related instructions such as\n  /// Phi, Ret, Br.\n  int getCFInstrCost(unsigned Opcode,\n                     TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency) const;\n\n  /// \\returns The expected cost of compare and select instructions. If there\n  /// is an existing instruction that holds Opcode, it may be passed in the\n  /// 'I' parameter. The \\p VecPred parameter can be used to indicate the select\n  /// is using a compare with the specified predicate as condition. When vector\n  /// types are passed, \\p VecPred must be used for all lanes.\n  int getCmpSelInstrCost(\n      unsigned Opcode, Type *ValTy, Type *CondTy = nullptr,\n      CmpInst::Predicate VecPred = CmpInst::BAD_ICMP_PREDICATE,\n      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,\n      const Instruction *I = nullptr) const;\n\n  /// \\return The expected cost of vector Insert and Extract.\n  /// Use -1 to indicate that there is no information on the index value.\n  int getVectorInstrCost(unsigned Opcode, Type *Val, unsigned Index = -1) const;\n\n  /// \\return The cost of Load and Store instructions.\n  int getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,\n                      unsigned AddressSpace,\n                      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,\n                      const Instruction *I = nullptr) const;\n\n  /// \\return The cost of masked Load and Store instructions.\n  int getMaskedMemoryOpCost(\n      unsigned Opcode, Type *Src, Align Alignment, unsigned AddressSpace,\n      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;\n\n  /// \\return The cost of Gather or Scatter operation\n  /// \\p Opcode - is a type of memory access Load or Store\n  /// \\p DataTy - a vector type of the data to be loaded or stored\n  /// \\p Ptr - pointer [or vector of pointers] - address[es] in memory\n  /// \\p VariableMask - true when the memory access is predicated with a mask\n  ///                   that is not a compile-time constant\n  /// \\p Alignment - alignment of single element\n  /// \\p I - the optional original context instruction, if one exists, e.g. the\n  ///        load/store to transform or the call to the gather/scatter intrinsic\n  int getGatherScatterOpCost(\n      unsigned Opcode, Type *DataTy, const Value *Ptr, bool VariableMask,\n      Align Alignment, TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,\n      const Instruction *I = nullptr) const;\n\n  /// \\return The cost of the interleaved memory operation.\n  /// \\p Opcode is the memory operation code\n  /// \\p VecTy is the vector type of the interleaved access.\n  /// \\p Factor is the interleave factor\n  /// \\p Indices is the indices for interleaved load members (as interleaved\n  ///    load allows gaps)\n  /// \\p Alignment is the alignment of the memory operation\n  /// \\p AddressSpace is address space of the pointer.\n  /// \\p UseMaskForCond indicates if the memory access is predicated.\n  /// \\p UseMaskForGaps indicates if gaps should be masked.\n  int getInterleavedMemoryOpCost(\n      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,\n      Align Alignment, unsigned AddressSpace,\n      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,\n      bool UseMaskForCond = false, bool UseMaskForGaps = false) const;\n\n  /// Calculate the cost of performing a vector reduction.\n  ///\n  /// This is the cost of reducing the vector value of type \\p Ty to a scalar\n  /// value using the operation denoted by \\p Opcode. The form of the reduction\n  /// can either be a pairwise reduction or a reduction that splits the vector\n  /// at every reduction level.\n  ///\n  /// Pairwise:\n  ///  (v0, v1, v2, v3)\n  ///  ((v0+v1), (v2+v3), undef, undef)\n  /// Split:\n  ///  (v0, v1, v2, v3)\n  ///  ((v0+v2), (v1+v3), undef, undef)\n  int getArithmeticReductionCost(\n    unsigned Opcode, VectorType *Ty, bool IsPairwiseForm,\n    TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;\n\n  int getMinMaxReductionCost(\n    VectorType *Ty, VectorType *CondTy, bool IsPairwiseForm, bool IsUnsigned,\n    TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;\n\n  /// Calculate the cost of an extended reduction pattern, similar to\n  /// getArithmeticReductionCost of an Add reduction with an extension and\n  /// optional multiply. This is the cost of as:\n  /// ResTy vecreduce.add(ext(Ty A)), or if IsMLA flag is set then:\n  /// ResTy vecreduce.add(mul(ext(Ty A), ext(Ty B)). The reduction happens\n  /// on a VectorType with ResTy elements and Ty lanes.\n  InstructionCost getExtendedAddReductionCost(\n      bool IsMLA, bool IsUnsigned, Type *ResTy, VectorType *Ty,\n      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const;\n\n  /// \\returns The cost of Intrinsic instructions. Analyses the real arguments.\n  /// Three cases are handled: 1. scalar instruction 2. vector instruction\n  /// 3. scalar instruction which is to be vectorized.\n  int getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,\n                            TTI::TargetCostKind CostKind) const;\n\n  /// \\returns The cost of Call instructions.\n  int getCallInstrCost(Function *F, Type *RetTy, ArrayRef<Type *> Tys,\n                 TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency) const;\n\n  /// \\returns The number of pieces into which the provided type must be\n  /// split during legalization. Zero is returned when the answer is unknown.\n  unsigned getNumberOfParts(Type *Tp) const;\n\n  /// \\returns The cost of the address computation. For most targets this can be\n  /// merged into the instruction indexing mode. Some targets might want to\n  /// distinguish between address computation for memory operations on vector\n  /// types and scalar types. Such targets should override this function.\n  /// The 'SE' parameter holds pointer for the scalar evolution object which\n  /// is used in order to get the Ptr step value in case of constant stride.\n  /// The 'Ptr' parameter holds SCEV of the access pointer.\n  int getAddressComputationCost(Type *Ty, ScalarEvolution *SE = nullptr,\n                                const SCEV *Ptr = nullptr) const;\n\n  /// \\returns The cost, if any, of keeping values of the given types alive\n  /// over a callsite.\n  ///\n  /// Some types may require the use of register classes that do not have\n  /// any callee-saved registers, so would require a spill and fill.\n  unsigned getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) const;\n\n  /// \\returns True if the intrinsic is a supported memory intrinsic.  Info\n  /// will contain additional information - whether the intrinsic may write\n  /// or read to memory, volatility and the pointer.  Info is undefined\n  /// if false is returned.\n  bool getTgtMemIntrinsic(IntrinsicInst *Inst, MemIntrinsicInfo &Info) const;\n\n  /// \\returns The maximum element size, in bytes, for an element\n  /// unordered-atomic memory intrinsic.\n  unsigned getAtomicMemIntrinsicMaxElementSize() const;\n\n  /// \\returns A value which is the result of the given memory intrinsic.  New\n  /// instructions may be created to extract the result from the given intrinsic\n  /// memory operation.  Returns nullptr if the target cannot create a result\n  /// from the given intrinsic.\n  Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,\n                                           Type *ExpectedType) const;\n\n  /// \\returns The type to use in a loop expansion of a memcpy call.\n  Type *getMemcpyLoopLoweringType(LLVMContext &Context, Value *Length,\n                                  unsigned SrcAddrSpace, unsigned DestAddrSpace,\n                                  unsigned SrcAlign, unsigned DestAlign) const;\n\n  /// \\param[out] OpsOut The operand types to copy RemainingBytes of memory.\n  /// \\param RemainingBytes The number of bytes to copy.\n  ///\n  /// Calculates the operand types to use when copying \\p RemainingBytes of\n  /// memory, where source and destination alignments are \\p SrcAlign and\n  /// \\p DestAlign respectively.\n  void getMemcpyLoopResidualLoweringType(\n      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,\n      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,\n      unsigned SrcAlign, unsigned DestAlign) const;\n\n  /// \\returns True if the two functions have compatible attributes for inlining\n  /// purposes.\n  bool areInlineCompatible(const Function *Caller,\n                           const Function *Callee) const;\n\n  /// \\returns True if the caller and callee agree on how \\p Args will be passed\n  /// to the callee.\n  /// \\param[out] Args The list of compatible arguments.  The implementation may\n  /// filter out any incompatible args from this list.\n  bool areFunctionArgsABICompatible(const Function *Caller,\n                                    const Function *Callee,\n                                    SmallPtrSetImpl<Argument *> &Args) const;\n\n  /// The type of load/store indexing.\n  enum MemIndexedMode {\n    MIM_Unindexed, ///< No indexing.\n    MIM_PreInc,    ///< Pre-incrementing.\n    MIM_PreDec,    ///< Pre-decrementing.\n    MIM_PostInc,   ///< Post-incrementing.\n    MIM_PostDec    ///< Post-decrementing.\n  };\n\n  /// \\returns True if the specified indexed load for the given type is legal.\n  bool isIndexedLoadLegal(enum MemIndexedMode Mode, Type *Ty) const;\n\n  /// \\returns True if the specified indexed store for the given type is legal.\n  bool isIndexedStoreLegal(enum MemIndexedMode Mode, Type *Ty) const;\n\n  /// \\returns The bitwidth of the largest vector type that should be used to\n  /// load/store in the given address space.\n  unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const;\n\n  /// \\returns True if the load instruction is legal to vectorize.\n  bool isLegalToVectorizeLoad(LoadInst *LI) const;\n\n  /// \\returns True if the store instruction is legal to vectorize.\n  bool isLegalToVectorizeStore(StoreInst *SI) const;\n\n  /// \\returns True if it is legal to vectorize the given load chain.\n  bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes, Align Alignment,\n                                   unsigned AddrSpace) const;\n\n  /// \\returns True if it is legal to vectorize the given store chain.\n  bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes, Align Alignment,\n                                    unsigned AddrSpace) const;\n\n  /// \\returns True if it is legal to vectorize the given reduction kind.\n  bool isLegalToVectorizeReduction(RecurrenceDescriptor RdxDesc,\n                                   ElementCount VF) const;\n\n  /// \\returns The new vector factor value if the target doesn't support \\p\n  /// SizeInBytes loads or has a better vector factor.\n  unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,\n                               unsigned ChainSizeInBytes,\n                               VectorType *VecTy) const;\n\n  /// \\returns The new vector factor value if the target doesn't support \\p\n  /// SizeInBytes stores or has a better vector factor.\n  unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,\n                                unsigned ChainSizeInBytes,\n                                VectorType *VecTy) const;\n\n  /// Flags describing the kind of vector reduction.\n  struct ReductionFlags {\n    ReductionFlags() : IsMaxOp(false), IsSigned(false), NoNaN(false) {}\n    bool IsMaxOp;  ///< If the op a min/max kind, true if it's a max operation.\n    bool IsSigned; ///< Whether the operation is a signed int reduction.\n    bool NoNaN;    ///< If op is an fp min/max, whether NaNs may be present.\n  };\n\n  /// \\returns True if the target prefers reductions in loop.\n  bool preferInLoopReduction(unsigned Opcode, Type *Ty,\n                             ReductionFlags Flags) const;\n\n  /// \\returns True if the target prefers reductions select kept in the loop\n  /// when tail folding. i.e.\n  /// loop:\n  ///   p = phi (0, s)\n  ///   a = add (p, x)\n  ///   s = select (mask, a, p)\n  /// vecreduce.add(s)\n  ///\n  /// As opposed to the normal scheme of p = phi (0, a) which allows the select\n  /// to be pulled out of the loop. If the select(.., add, ..) can be predicated\n  /// by the target, this can lead to cleaner code generation.\n  bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,\n                                       ReductionFlags Flags) const;\n\n  /// \\returns True if the target wants to expand the given reduction intrinsic\n  /// into a shuffle sequence.\n  bool shouldExpandReduction(const IntrinsicInst *II) const;\n\n  /// \\returns the size cost of rematerializing a GlobalValue address relative\n  /// to a stack reload.\n  unsigned getGISelRematGlobalCost() const;\n\n  /// \\returns True if the target supports scalable vectors.\n  bool supportsScalableVectors() const;\n\n  /// \\name Vector Predication Information\n  /// @{\n  /// Whether the target supports the %evl parameter of VP intrinsic efficiently\n  /// in hardware. (see LLVM Language Reference - \"Vector Predication\n  /// Intrinsics\") Use of %evl is discouraged when that is not the case.\n  bool hasActiveVectorLength() const;\n\n  /// @}\n\n  /// @}\n\nprivate:\n  /// Estimate the latency of specified instruction.\n  /// Returns 1 as the default value.\n  int getInstructionLatency(const Instruction *I) const;\n\n  /// Returns the expected throughput cost of the instruction.\n  /// Returns -1 if the cost is unknown.\n  int getInstructionThroughput(const Instruction *I) const;\n\n  /// The abstract base class used to type erase specific TTI\n  /// implementations.\n  class Concept;\n\n  /// The template model for the base class which wraps a concrete\n  /// implementation in a type erased interface.\n  template <typename T> class Model;\n\n  std::unique_ptr<Concept> TTIImpl;\n};\n\nclass TargetTransformInfo::Concept {\npublic:\n  virtual ~Concept() = 0;\n  virtual const DataLayout &getDataLayout() const = 0;\n  virtual int getGEPCost(Type *PointeeType, const Value *Ptr,\n                         ArrayRef<const Value *> Operands,\n                         TTI::TargetCostKind CostKind) = 0;\n  virtual unsigned getInliningThresholdMultiplier() = 0;\n  virtual unsigned adjustInliningThreshold(const CallBase *CB) = 0;\n  virtual int getInlinerVectorBonusPercent() = 0;\n  virtual int getMemcpyCost(const Instruction *I) = 0;\n  virtual unsigned\n  getEstimatedNumberOfCaseClusters(const SwitchInst &SI, unsigned &JTSize,\n                                   ProfileSummaryInfo *PSI,\n                                   BlockFrequencyInfo *BFI) = 0;\n  virtual int getUserCost(const User *U, ArrayRef<const Value *> Operands,\n                          TargetCostKind CostKind) = 0;\n  virtual bool hasBranchDivergence() = 0;\n  virtual bool useGPUDivergenceAnalysis() = 0;\n  virtual bool isSourceOfDivergence(const Value *V) = 0;\n  virtual bool isAlwaysUniform(const Value *V) = 0;\n  virtual unsigned getFlatAddressSpace() = 0;\n  virtual bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,\n                                          Intrinsic::ID IID) const = 0;\n  virtual bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const = 0;\n  virtual unsigned getAssumedAddrSpace(const Value *V) const = 0;\n  virtual Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II,\n                                                  Value *OldV,\n                                                  Value *NewV) const = 0;\n  virtual bool isLoweredToCall(const Function *F) = 0;\n  virtual void getUnrollingPreferences(Loop *L, ScalarEvolution &,\n                                       UnrollingPreferences &UP) = 0;\n  virtual void getPeelingPreferences(Loop *L, ScalarEvolution &SE,\n                                     PeelingPreferences &PP) = 0;\n  virtual bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,\n                                        AssumptionCache &AC,\n                                        TargetLibraryInfo *LibInfo,\n                                        HardwareLoopInfo &HWLoopInfo) = 0;\n  virtual bool\n  preferPredicateOverEpilogue(Loop *L, LoopInfo *LI, ScalarEvolution &SE,\n                              AssumptionCache &AC, TargetLibraryInfo *TLI,\n                              DominatorTree *DT, const LoopAccessInfo *LAI) = 0;\n  virtual bool emitGetActiveLaneMask() = 0;\n  virtual Optional<Instruction *> instCombineIntrinsic(InstCombiner &IC,\n                                                       IntrinsicInst &II) = 0;\n  virtual Optional<Value *>\n  simplifyDemandedUseBitsIntrinsic(InstCombiner &IC, IntrinsicInst &II,\n                                   APInt DemandedMask, KnownBits &Known,\n                                   bool &KnownBitsComputed) = 0;\n  virtual Optional<Value *> simplifyDemandedVectorEltsIntrinsic(\n      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts, APInt &UndefElts,\n      APInt &UndefElts2, APInt &UndefElts3,\n      std::function<void(Instruction *, unsigned, APInt, APInt &)>\n          SimplifyAndSetOp) = 0;\n  virtual bool isLegalAddImmediate(int64_t Imm) = 0;\n  virtual bool isLegalICmpImmediate(int64_t Imm) = 0;\n  virtual bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV,\n                                     int64_t BaseOffset, bool HasBaseReg,\n                                     int64_t Scale, unsigned AddrSpace,\n                                     Instruction *I) = 0;\n  virtual bool isLSRCostLess(TargetTransformInfo::LSRCost &C1,\n                             TargetTransformInfo::LSRCost &C2) = 0;\n  virtual bool isNumRegsMajorCostOfLSR() = 0;\n  virtual bool isProfitableLSRChainElement(Instruction *I) = 0;\n  virtual bool canMacroFuseCmp() = 0;\n  virtual bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE,\n                          LoopInfo *LI, DominatorTree *DT, AssumptionCache *AC,\n                          TargetLibraryInfo *LibInfo) = 0;\n  virtual AddressingModeKind\n    getPreferredAddressingMode(const Loop *L, ScalarEvolution *SE) const = 0;\n  virtual bool isLegalMaskedStore(Type *DataType, Align Alignment) = 0;\n  virtual bool isLegalMaskedLoad(Type *DataType, Align Alignment) = 0;\n  virtual bool isLegalNTStore(Type *DataType, Align Alignment) = 0;\n  virtual bool isLegalNTLoad(Type *DataType, Align Alignment) = 0;\n  virtual bool isLegalMaskedScatter(Type *DataType, Align Alignment) = 0;\n  virtual bool isLegalMaskedGather(Type *DataType, Align Alignment) = 0;\n  virtual bool isLegalMaskedCompressStore(Type *DataType) = 0;\n  virtual bool isLegalMaskedExpandLoad(Type *DataType) = 0;\n  virtual bool hasDivRemOp(Type *DataType, bool IsSigned) = 0;\n  virtual bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) = 0;\n  virtual bool prefersVectorizedAddressing() = 0;\n  virtual int getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,\n                                   int64_t BaseOffset, bool HasBaseReg,\n                                   int64_t Scale, unsigned AddrSpace) = 0;\n  virtual bool LSRWithInstrQueries() = 0;\n  virtual bool isTruncateFree(Type *Ty1, Type *Ty2) = 0;\n  virtual bool isProfitableToHoist(Instruction *I) = 0;\n  virtual bool useAA() = 0;\n  virtual bool isTypeLegal(Type *Ty) = 0;\n  virtual unsigned getRegUsageForType(Type *Ty) = 0;\n  virtual bool shouldBuildLookupTables() = 0;\n  virtual bool shouldBuildLookupTablesForConstant(Constant *C) = 0;\n  virtual bool useColdCCForColdCall(Function &F) = 0;\n  virtual unsigned getScalarizationOverhead(VectorType *Ty,\n                                            const APInt &DemandedElts,\n                                            bool Insert, bool Extract) = 0;\n  virtual unsigned\n  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,\n                                   ArrayRef<Type *> Tys) = 0;\n  virtual bool supportsEfficientVectorElementLoadStore() = 0;\n  virtual bool enableAggressiveInterleaving(bool LoopHasReductions) = 0;\n  virtual MemCmpExpansionOptions\n  enableMemCmpExpansion(bool OptSize, bool IsZeroCmp) const = 0;\n  virtual bool enableInterleavedAccessVectorization() = 0;\n  virtual bool enableMaskedInterleavedAccessVectorization() = 0;\n  virtual bool isFPVectorizationPotentiallyUnsafe() = 0;\n  virtual bool allowsMisalignedMemoryAccesses(LLVMContext &Context,\n                                              unsigned BitWidth,\n                                              unsigned AddressSpace,\n                                              Align Alignment,\n                                              bool *Fast) = 0;\n  virtual PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) = 0;\n  virtual bool haveFastSqrt(Type *Ty) = 0;\n  virtual bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) = 0;\n  virtual int getFPOpCost(Type *Ty) = 0;\n  virtual int getIntImmCodeSizeCost(unsigned Opc, unsigned Idx,\n                                    const APInt &Imm, Type *Ty) = 0;\n  virtual int getIntImmCost(const APInt &Imm, Type *Ty,\n                            TargetCostKind CostKind) = 0;\n  virtual int getIntImmCostInst(unsigned Opc, unsigned Idx, const APInt &Imm,\n                                Type *Ty, TargetCostKind CostKind,\n                                Instruction *Inst = nullptr) = 0;\n  virtual int getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,\n                                  const APInt &Imm, Type *Ty,\n                                  TargetCostKind CostKind) = 0;\n  virtual unsigned getNumberOfRegisters(unsigned ClassID) const = 0;\n  virtual unsigned getRegisterClassForType(bool Vector,\n                                           Type *Ty = nullptr) const = 0;\n  virtual const char *getRegisterClassName(unsigned ClassID) const = 0;\n  virtual unsigned getRegisterBitWidth(bool Vector) const = 0;\n  virtual unsigned getMinVectorRegisterBitWidth() = 0;\n  virtual Optional<unsigned> getMaxVScale() const = 0;\n  virtual bool shouldMaximizeVectorBandwidth(bool OptSize) const = 0;\n  virtual ElementCount getMinimumVF(unsigned ElemWidth,\n                                    bool IsScalable) const = 0;\n  virtual unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const = 0;\n  virtual bool shouldConsiderAddressTypePromotion(\n      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) = 0;\n  virtual unsigned getCacheLineSize() const = 0;\n  virtual Optional<unsigned> getCacheSize(CacheLevel Level) const = 0;\n  virtual Optional<unsigned> getCacheAssociativity(CacheLevel Level) const = 0;\n\n  /// \\return How much before a load we should place the prefetch\n  /// instruction.  This is currently measured in number of\n  /// instructions.\n  virtual unsigned getPrefetchDistance() const = 0;\n\n  /// \\return Some HW prefetchers can handle accesses up to a certain\n  /// constant stride.  This is the minimum stride in bytes where it\n  /// makes sense to start adding SW prefetches.  The default is 1,\n  /// i.e. prefetch with any stride.  Sometimes prefetching is beneficial\n  /// even below the HW prefetcher limit, and the arguments provided are\n  /// meant to serve as a basis for deciding this for a particular loop.\n  virtual unsigned getMinPrefetchStride(unsigned NumMemAccesses,\n                                        unsigned NumStridedMemAccesses,\n                                        unsigned NumPrefetches,\n                                        bool HasCall) const = 0;\n\n  /// \\return The maximum number of iterations to prefetch ahead.  If\n  /// the required number of iterations is more than this number, no\n  /// prefetching is performed.\n  virtual unsigned getMaxPrefetchIterationsAhead() const = 0;\n\n  /// \\return True if prefetching should also be done for writes.\n  virtual bool enableWritePrefetching() const = 0;\n\n  virtual unsigned getMaxInterleaveFactor(unsigned VF) = 0;\n  virtual unsigned getArithmeticInstrCost(\n      unsigned Opcode, Type *Ty,\n      TTI::TargetCostKind CostKind,\n      OperandValueKind Opd1Info,\n      OperandValueKind Opd2Info, OperandValueProperties Opd1PropInfo,\n      OperandValueProperties Opd2PropInfo, ArrayRef<const Value *> Args,\n      const Instruction *CxtI = nullptr) = 0;\n  virtual int getShuffleCost(ShuffleKind Kind, VectorType *Tp, int Index,\n                             VectorType *SubTp) = 0;\n  virtual int getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,\n                               CastContextHint CCH,\n                               TTI::TargetCostKind CostKind,\n                               const Instruction *I) = 0;\n  virtual int getExtractWithExtendCost(unsigned Opcode, Type *Dst,\n                                       VectorType *VecTy, unsigned Index) = 0;\n  virtual int getCFInstrCost(unsigned Opcode,\n                             TTI::TargetCostKind CostKind) = 0;\n  virtual int getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,\n                                 CmpInst::Predicate VecPred,\n                                 TTI::TargetCostKind CostKind,\n                                 const Instruction *I) = 0;\n  virtual int getVectorInstrCost(unsigned Opcode, Type *Val,\n                                 unsigned Index) = 0;\n  virtual int getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,\n                              unsigned AddressSpace,\n                              TTI::TargetCostKind CostKind,\n                              const Instruction *I) = 0;\n  virtual int getMaskedMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,\n                                    unsigned AddressSpace,\n                                    TTI::TargetCostKind CostKind) = 0;\n  virtual int getGatherScatterOpCost(unsigned Opcode, Type *DataTy,\n                                     const Value *Ptr, bool VariableMask,\n                                     Align Alignment,\n                                     TTI::TargetCostKind CostKind,\n                                     const Instruction *I = nullptr) = 0;\n\n  virtual int getInterleavedMemoryOpCost(\n      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,\n      Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,\n      bool UseMaskForCond = false, bool UseMaskForGaps = false) = 0;\n  virtual int getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,\n                                         bool IsPairwiseForm,\n                                         TTI::TargetCostKind CostKind) = 0;\n  virtual int getMinMaxReductionCost(VectorType *Ty, VectorType *CondTy,\n                                     bool IsPairwiseForm, bool IsUnsigned,\n                                     TTI::TargetCostKind CostKind) = 0;\n  virtual InstructionCost getExtendedAddReductionCost(\n      bool IsMLA, bool IsUnsigned, Type *ResTy, VectorType *Ty,\n      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) = 0;\n  virtual int getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,\n                                    TTI::TargetCostKind CostKind) = 0;\n  virtual int getCallInstrCost(Function *F, Type *RetTy,\n                               ArrayRef<Type *> Tys,\n                               TTI::TargetCostKind CostKind) = 0;\n  virtual unsigned getNumberOfParts(Type *Tp) = 0;\n  virtual int getAddressComputationCost(Type *Ty, ScalarEvolution *SE,\n                                        const SCEV *Ptr) = 0;\n  virtual unsigned getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) = 0;\n  virtual bool getTgtMemIntrinsic(IntrinsicInst *Inst,\n                                  MemIntrinsicInfo &Info) = 0;\n  virtual unsigned getAtomicMemIntrinsicMaxElementSize() const = 0;\n  virtual Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,\n                                                   Type *ExpectedType) = 0;\n  virtual Type *getMemcpyLoopLoweringType(LLVMContext &Context, Value *Length,\n                                          unsigned SrcAddrSpace,\n                                          unsigned DestAddrSpace,\n                                          unsigned SrcAlign,\n                                          unsigned DestAlign) const = 0;\n  virtual void getMemcpyLoopResidualLoweringType(\n      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,\n      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,\n      unsigned SrcAlign, unsigned DestAlign) const = 0;\n  virtual bool areInlineCompatible(const Function *Caller,\n                                   const Function *Callee) const = 0;\n  virtual bool\n  areFunctionArgsABICompatible(const Function *Caller, const Function *Callee,\n                               SmallPtrSetImpl<Argument *> &Args) const = 0;\n  virtual bool isIndexedLoadLegal(MemIndexedMode Mode, Type *Ty) const = 0;\n  virtual bool isIndexedStoreLegal(MemIndexedMode Mode, Type *Ty) const = 0;\n  virtual unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const = 0;\n  virtual bool isLegalToVectorizeLoad(LoadInst *LI) const = 0;\n  virtual bool isLegalToVectorizeStore(StoreInst *SI) const = 0;\n  virtual bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes,\n                                           Align Alignment,\n                                           unsigned AddrSpace) const = 0;\n  virtual bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes,\n                                            Align Alignment,\n                                            unsigned AddrSpace) const = 0;\n  virtual bool isLegalToVectorizeReduction(RecurrenceDescriptor RdxDesc,\n                                           ElementCount VF) const = 0;\n  virtual unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,\n                                       unsigned ChainSizeInBytes,\n                                       VectorType *VecTy) const = 0;\n  virtual unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,\n                                        unsigned ChainSizeInBytes,\n                                        VectorType *VecTy) const = 0;\n  virtual bool preferInLoopReduction(unsigned Opcode, Type *Ty,\n                                     ReductionFlags) const = 0;\n  virtual bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,\n                                               ReductionFlags) const = 0;\n  virtual bool shouldExpandReduction(const IntrinsicInst *II) const = 0;\n  virtual unsigned getGISelRematGlobalCost() const = 0;\n  virtual bool supportsScalableVectors() const = 0;\n  virtual bool hasActiveVectorLength() const = 0;\n  virtual int getInstructionLatency(const Instruction *I) = 0;\n};\n\ntemplate <typename T>\nclass TargetTransformInfo::Model final : public TargetTransformInfo::Concept {\n  T Impl;\n\npublic:\n  Model(T Impl) : Impl(std::move(Impl)) {}\n  ~Model() override {}\n\n  const DataLayout &getDataLayout() const override {\n    return Impl.getDataLayout();\n  }\n\n  int getGEPCost(Type *PointeeType, const Value *Ptr,\n                 ArrayRef<const Value *> Operands,\n                 enum TargetTransformInfo::TargetCostKind CostKind) override {\n    return Impl.getGEPCost(PointeeType, Ptr, Operands);\n  }\n  unsigned getInliningThresholdMultiplier() override {\n    return Impl.getInliningThresholdMultiplier();\n  }\n  unsigned adjustInliningThreshold(const CallBase *CB) override {\n    return Impl.adjustInliningThreshold(CB);\n  }\n  int getInlinerVectorBonusPercent() override {\n    return Impl.getInlinerVectorBonusPercent();\n  }\n  int getMemcpyCost(const Instruction *I) override {\n    return Impl.getMemcpyCost(I);\n  }\n  int getUserCost(const User *U, ArrayRef<const Value *> Operands,\n                  TargetCostKind CostKind) override {\n    return Impl.getUserCost(U, Operands, CostKind);\n  }\n  bool hasBranchDivergence() override { return Impl.hasBranchDivergence(); }\n  bool useGPUDivergenceAnalysis() override {\n    return Impl.useGPUDivergenceAnalysis();\n  }\n  bool isSourceOfDivergence(const Value *V) override {\n    return Impl.isSourceOfDivergence(V);\n  }\n\n  bool isAlwaysUniform(const Value *V) override {\n    return Impl.isAlwaysUniform(V);\n  }\n\n  unsigned getFlatAddressSpace() override { return Impl.getFlatAddressSpace(); }\n\n  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,\n                                  Intrinsic::ID IID) const override {\n    return Impl.collectFlatAddressOperands(OpIndexes, IID);\n  }\n\n  bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const override {\n    return Impl.isNoopAddrSpaceCast(FromAS, ToAS);\n  }\n\n  unsigned getAssumedAddrSpace(const Value *V) const override {\n    return Impl.getAssumedAddrSpace(V);\n  }\n\n  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,\n                                          Value *NewV) const override {\n    return Impl.rewriteIntrinsicWithAddressSpace(II, OldV, NewV);\n  }\n\n  bool isLoweredToCall(const Function *F) override {\n    return Impl.isLoweredToCall(F);\n  }\n  void getUnrollingPreferences(Loop *L, ScalarEvolution &SE,\n                               UnrollingPreferences &UP) override {\n    return Impl.getUnrollingPreferences(L, SE, UP);\n  }\n  void getPeelingPreferences(Loop *L, ScalarEvolution &SE,\n                             PeelingPreferences &PP) override {\n    return Impl.getPeelingPreferences(L, SE, PP);\n  }\n  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,\n                                AssumptionCache &AC, TargetLibraryInfo *LibInfo,\n                                HardwareLoopInfo &HWLoopInfo) override {\n    return Impl.isHardwareLoopProfitable(L, SE, AC, LibInfo, HWLoopInfo);\n  }\n  bool preferPredicateOverEpilogue(Loop *L, LoopInfo *LI, ScalarEvolution &SE,\n                                   AssumptionCache &AC, TargetLibraryInfo *TLI,\n                                   DominatorTree *DT,\n                                   const LoopAccessInfo *LAI) override {\n    return Impl.preferPredicateOverEpilogue(L, LI, SE, AC, TLI, DT, LAI);\n  }\n  bool emitGetActiveLaneMask() override {\n    return Impl.emitGetActiveLaneMask();\n  }\n  Optional<Instruction *> instCombineIntrinsic(InstCombiner &IC,\n                                               IntrinsicInst &II) override {\n    return Impl.instCombineIntrinsic(IC, II);\n  }\n  Optional<Value *>\n  simplifyDemandedUseBitsIntrinsic(InstCombiner &IC, IntrinsicInst &II,\n                                   APInt DemandedMask, KnownBits &Known,\n                                   bool &KnownBitsComputed) override {\n    return Impl.simplifyDemandedUseBitsIntrinsic(IC, II, DemandedMask, Known,\n                                                 KnownBitsComputed);\n  }\n  Optional<Value *> simplifyDemandedVectorEltsIntrinsic(\n      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts, APInt &UndefElts,\n      APInt &UndefElts2, APInt &UndefElts3,\n      std::function<void(Instruction *, unsigned, APInt, APInt &)>\n          SimplifyAndSetOp) override {\n    return Impl.simplifyDemandedVectorEltsIntrinsic(\n        IC, II, DemandedElts, UndefElts, UndefElts2, UndefElts3,\n        SimplifyAndSetOp);\n  }\n  bool isLegalAddImmediate(int64_t Imm) override {\n    return Impl.isLegalAddImmediate(Imm);\n  }\n  bool isLegalICmpImmediate(int64_t Imm) override {\n    return Impl.isLegalICmpImmediate(Imm);\n  }\n  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,\n                             bool HasBaseReg, int64_t Scale, unsigned AddrSpace,\n                             Instruction *I) override {\n    return Impl.isLegalAddressingMode(Ty, BaseGV, BaseOffset, HasBaseReg, Scale,\n                                      AddrSpace, I);\n  }\n  bool isLSRCostLess(TargetTransformInfo::LSRCost &C1,\n                     TargetTransformInfo::LSRCost &C2) override {\n    return Impl.isLSRCostLess(C1, C2);\n  }\n  bool isNumRegsMajorCostOfLSR() override {\n    return Impl.isNumRegsMajorCostOfLSR();\n  }\n  bool isProfitableLSRChainElement(Instruction *I) override {\n    return Impl.isProfitableLSRChainElement(I);\n  }\n  bool canMacroFuseCmp() override { return Impl.canMacroFuseCmp(); }\n  bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE, LoopInfo *LI,\n                  DominatorTree *DT, AssumptionCache *AC,\n                  TargetLibraryInfo *LibInfo) override {\n    return Impl.canSaveCmp(L, BI, SE, LI, DT, AC, LibInfo);\n  }\n  AddressingModeKind\n    getPreferredAddressingMode(const Loop *L,\n                               ScalarEvolution *SE) const override {\n    return Impl.getPreferredAddressingMode(L, SE);\n  }\n  bool isLegalMaskedStore(Type *DataType, Align Alignment) override {\n    return Impl.isLegalMaskedStore(DataType, Alignment);\n  }\n  bool isLegalMaskedLoad(Type *DataType, Align Alignment) override {\n    return Impl.isLegalMaskedLoad(DataType, Alignment);\n  }\n  bool isLegalNTStore(Type *DataType, Align Alignment) override {\n    return Impl.isLegalNTStore(DataType, Alignment);\n  }\n  bool isLegalNTLoad(Type *DataType, Align Alignment) override {\n    return Impl.isLegalNTLoad(DataType, Alignment);\n  }\n  bool isLegalMaskedScatter(Type *DataType, Align Alignment) override {\n    return Impl.isLegalMaskedScatter(DataType, Alignment);\n  }\n  bool isLegalMaskedGather(Type *DataType, Align Alignment) override {\n    return Impl.isLegalMaskedGather(DataType, Alignment);\n  }\n  bool isLegalMaskedCompressStore(Type *DataType) override {\n    return Impl.isLegalMaskedCompressStore(DataType);\n  }\n  bool isLegalMaskedExpandLoad(Type *DataType) override {\n    return Impl.isLegalMaskedExpandLoad(DataType);\n  }\n  bool hasDivRemOp(Type *DataType, bool IsSigned) override {\n    return Impl.hasDivRemOp(DataType, IsSigned);\n  }\n  bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) override {\n    return Impl.hasVolatileVariant(I, AddrSpace);\n  }\n  bool prefersVectorizedAddressing() override {\n    return Impl.prefersVectorizedAddressing();\n  }\n  int getScalingFactorCost(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,\n                           bool HasBaseReg, int64_t Scale,\n                           unsigned AddrSpace) override {\n    return Impl.getScalingFactorCost(Ty, BaseGV, BaseOffset, HasBaseReg, Scale,\n                                     AddrSpace);\n  }\n  bool LSRWithInstrQueries() override { return Impl.LSRWithInstrQueries(); }\n  bool isTruncateFree(Type *Ty1, Type *Ty2) override {\n    return Impl.isTruncateFree(Ty1, Ty2);\n  }\n  bool isProfitableToHoist(Instruction *I) override {\n    return Impl.isProfitableToHoist(I);\n  }\n  bool useAA() override { return Impl.useAA(); }\n  bool isTypeLegal(Type *Ty) override { return Impl.isTypeLegal(Ty); }\n  unsigned getRegUsageForType(Type *Ty) override {\n    return Impl.getRegUsageForType(Ty);\n  }\n  bool shouldBuildLookupTables() override {\n    return Impl.shouldBuildLookupTables();\n  }\n  bool shouldBuildLookupTablesForConstant(Constant *C) override {\n    return Impl.shouldBuildLookupTablesForConstant(C);\n  }\n  bool useColdCCForColdCall(Function &F) override {\n    return Impl.useColdCCForColdCall(F);\n  }\n\n  unsigned getScalarizationOverhead(VectorType *Ty, const APInt &DemandedElts,\n                                    bool Insert, bool Extract) override {\n    return Impl.getScalarizationOverhead(Ty, DemandedElts, Insert, Extract);\n  }\n  unsigned getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,\n                                            ArrayRef<Type *> Tys) override {\n    return Impl.getOperandsScalarizationOverhead(Args, Tys);\n  }\n\n  bool supportsEfficientVectorElementLoadStore() override {\n    return Impl.supportsEfficientVectorElementLoadStore();\n  }\n\n  bool enableAggressiveInterleaving(bool LoopHasReductions) override {\n    return Impl.enableAggressiveInterleaving(LoopHasReductions);\n  }\n  MemCmpExpansionOptions enableMemCmpExpansion(bool OptSize,\n                                               bool IsZeroCmp) const override {\n    return Impl.enableMemCmpExpansion(OptSize, IsZeroCmp);\n  }\n  bool enableInterleavedAccessVectorization() override {\n    return Impl.enableInterleavedAccessVectorization();\n  }\n  bool enableMaskedInterleavedAccessVectorization() override {\n    return Impl.enableMaskedInterleavedAccessVectorization();\n  }\n  bool isFPVectorizationPotentiallyUnsafe() override {\n    return Impl.isFPVectorizationPotentiallyUnsafe();\n  }\n  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,\n                                      unsigned AddressSpace, Align Alignment,\n                                      bool *Fast) override {\n    return Impl.allowsMisalignedMemoryAccesses(Context, BitWidth, AddressSpace,\n                                               Alignment, Fast);\n  }\n  PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) override {\n    return Impl.getPopcntSupport(IntTyWidthInBit);\n  }\n  bool haveFastSqrt(Type *Ty) override { return Impl.haveFastSqrt(Ty); }\n\n  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) override {\n    return Impl.isFCmpOrdCheaperThanFCmpZero(Ty);\n  }\n\n  int getFPOpCost(Type *Ty) override { return Impl.getFPOpCost(Ty); }\n\n  int getIntImmCodeSizeCost(unsigned Opc, unsigned Idx, const APInt &Imm,\n                            Type *Ty) override {\n    return Impl.getIntImmCodeSizeCost(Opc, Idx, Imm, Ty);\n  }\n  int getIntImmCost(const APInt &Imm, Type *Ty,\n                    TargetCostKind CostKind) override {\n    return Impl.getIntImmCost(Imm, Ty, CostKind);\n  }\n  int getIntImmCostInst(unsigned Opc, unsigned Idx, const APInt &Imm, Type *Ty,\n                        TargetCostKind CostKind,\n                        Instruction *Inst = nullptr) override {\n    return Impl.getIntImmCostInst(Opc, Idx, Imm, Ty, CostKind, Inst);\n  }\n  int getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx, const APInt &Imm,\n                          Type *Ty, TargetCostKind CostKind) override {\n    return Impl.getIntImmCostIntrin(IID, Idx, Imm, Ty, CostKind);\n  }\n  unsigned getNumberOfRegisters(unsigned ClassID) const override {\n    return Impl.getNumberOfRegisters(ClassID);\n  }\n  unsigned getRegisterClassForType(bool Vector,\n                                   Type *Ty = nullptr) const override {\n    return Impl.getRegisterClassForType(Vector, Ty);\n  }\n  const char *getRegisterClassName(unsigned ClassID) const override {\n    return Impl.getRegisterClassName(ClassID);\n  }\n  unsigned getRegisterBitWidth(bool Vector) const override {\n    return Impl.getRegisterBitWidth(Vector);\n  }\n  unsigned getMinVectorRegisterBitWidth() override {\n    return Impl.getMinVectorRegisterBitWidth();\n  }\n  Optional<unsigned> getMaxVScale() const override {\n    return Impl.getMaxVScale();\n  }\n  bool shouldMaximizeVectorBandwidth(bool OptSize) const override {\n    return Impl.shouldMaximizeVectorBandwidth(OptSize);\n  }\n  ElementCount getMinimumVF(unsigned ElemWidth,\n                            bool IsScalable) const override {\n    return Impl.getMinimumVF(ElemWidth, IsScalable);\n  }\n  unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const override {\n    return Impl.getMaximumVF(ElemWidth, Opcode);\n  }\n  bool shouldConsiderAddressTypePromotion(\n      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) override {\n    return Impl.shouldConsiderAddressTypePromotion(\n        I, AllowPromotionWithoutCommonHeader);\n  }\n  unsigned getCacheLineSize() const override { return Impl.getCacheLineSize(); }\n  Optional<unsigned> getCacheSize(CacheLevel Level) const override {\n    return Impl.getCacheSize(Level);\n  }\n  Optional<unsigned> getCacheAssociativity(CacheLevel Level) const override {\n    return Impl.getCacheAssociativity(Level);\n  }\n\n  /// Return the preferred prefetch distance in terms of instructions.\n  ///\n  unsigned getPrefetchDistance() const override {\n    return Impl.getPrefetchDistance();\n  }\n\n  /// Return the minimum stride necessary to trigger software\n  /// prefetching.\n  ///\n  unsigned getMinPrefetchStride(unsigned NumMemAccesses,\n                                unsigned NumStridedMemAccesses,\n                                unsigned NumPrefetches,\n                                bool HasCall) const override {\n    return Impl.getMinPrefetchStride(NumMemAccesses, NumStridedMemAccesses,\n                                     NumPrefetches, HasCall);\n  }\n\n  /// Return the maximum prefetch distance in terms of loop\n  /// iterations.\n  ///\n  unsigned getMaxPrefetchIterationsAhead() const override {\n    return Impl.getMaxPrefetchIterationsAhead();\n  }\n\n  /// \\return True if prefetching should also be done for writes.\n  bool enableWritePrefetching() const override {\n    return Impl.enableWritePrefetching();\n  }\n\n  unsigned getMaxInterleaveFactor(unsigned VF) override {\n    return Impl.getMaxInterleaveFactor(VF);\n  }\n  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,\n                                            unsigned &JTSize,\n                                            ProfileSummaryInfo *PSI,\n                                            BlockFrequencyInfo *BFI) override {\n    return Impl.getEstimatedNumberOfCaseClusters(SI, JTSize, PSI, BFI);\n  }\n  unsigned getArithmeticInstrCost(unsigned Opcode, Type *Ty,\n                                  TTI::TargetCostKind CostKind,\n                                  OperandValueKind Opd1Info,\n                                  OperandValueKind Opd2Info,\n                                  OperandValueProperties Opd1PropInfo,\n                                  OperandValueProperties Opd2PropInfo,\n                                  ArrayRef<const Value *> Args,\n                                  const Instruction *CxtI = nullptr) override {\n    return Impl.getArithmeticInstrCost(Opcode, Ty, CostKind, Opd1Info, Opd2Info,\n                                       Opd1PropInfo, Opd2PropInfo, Args, CxtI);\n  }\n  int getShuffleCost(ShuffleKind Kind, VectorType *Tp, int Index,\n                     VectorType *SubTp) override {\n    return Impl.getShuffleCost(Kind, Tp, Index, SubTp);\n  }\n  int getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,\n                       CastContextHint CCH, TTI::TargetCostKind CostKind,\n                       const Instruction *I) override {\n    return Impl.getCastInstrCost(Opcode, Dst, Src, CCH, CostKind, I);\n  }\n  int getExtractWithExtendCost(unsigned Opcode, Type *Dst, VectorType *VecTy,\n                               unsigned Index) override {\n    return Impl.getExtractWithExtendCost(Opcode, Dst, VecTy, Index);\n  }\n  int getCFInstrCost(unsigned Opcode, TTI::TargetCostKind CostKind) override {\n    return Impl.getCFInstrCost(Opcode, CostKind);\n  }\n  int getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,\n                         CmpInst::Predicate VecPred,\n                         TTI::TargetCostKind CostKind,\n                         const Instruction *I) override {\n    return Impl.getCmpSelInstrCost(Opcode, ValTy, CondTy, VecPred, CostKind, I);\n  }\n  int getVectorInstrCost(unsigned Opcode, Type *Val, unsigned Index) override {\n    return Impl.getVectorInstrCost(Opcode, Val, Index);\n  }\n  int getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,\n                      unsigned AddressSpace, TTI::TargetCostKind CostKind,\n                      const Instruction *I) override {\n    return Impl.getMemoryOpCost(Opcode, Src, Alignment, AddressSpace,\n                                CostKind, I);\n  }\n  int getMaskedMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,\n                            unsigned AddressSpace,\n                            TTI::TargetCostKind CostKind) override {\n    return Impl.getMaskedMemoryOpCost(Opcode, Src, Alignment, AddressSpace,\n                                      CostKind);\n  }\n  int getGatherScatterOpCost(unsigned Opcode, Type *DataTy, const Value *Ptr,\n                             bool VariableMask, Align Alignment,\n                             TTI::TargetCostKind CostKind,\n                             const Instruction *I = nullptr) override {\n    return Impl.getGatherScatterOpCost(Opcode, DataTy, Ptr, VariableMask,\n                                       Alignment, CostKind, I);\n  }\n  int getInterleavedMemoryOpCost(unsigned Opcode, Type *VecTy, unsigned Factor,\n                                 ArrayRef<unsigned> Indices, Align Alignment,\n                                 unsigned AddressSpace,\n                                 TTI::TargetCostKind CostKind,\n                                 bool UseMaskForCond,\n                                 bool UseMaskForGaps) override {\n    return Impl.getInterleavedMemoryOpCost(Opcode, VecTy, Factor, Indices,\n                                           Alignment, AddressSpace, CostKind,\n                                           UseMaskForCond, UseMaskForGaps);\n  }\n  int getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,\n                                 bool IsPairwiseForm,\n                                 TTI::TargetCostKind CostKind) override {\n    return Impl.getArithmeticReductionCost(Opcode, Ty, IsPairwiseForm,\n                                           CostKind);\n  }\n  int getMinMaxReductionCost(VectorType *Ty, VectorType *CondTy,\n                             bool IsPairwiseForm, bool IsUnsigned,\n                             TTI::TargetCostKind CostKind) override {\n    return Impl.getMinMaxReductionCost(Ty, CondTy, IsPairwiseForm, IsUnsigned,\n                                       CostKind);\n  }\n  InstructionCost getExtendedAddReductionCost(\n      bool IsMLA, bool IsUnsigned, Type *ResTy, VectorType *Ty,\n      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) override {\n    return Impl.getExtendedAddReductionCost(IsMLA, IsUnsigned, ResTy, Ty,\n                                            CostKind);\n  }\n  int getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,\n                            TTI::TargetCostKind CostKind) override {\n    return Impl.getIntrinsicInstrCost(ICA, CostKind);\n  }\n  int getCallInstrCost(Function *F, Type *RetTy,\n                       ArrayRef<Type *> Tys,\n                       TTI::TargetCostKind CostKind) override {\n    return Impl.getCallInstrCost(F, RetTy, Tys, CostKind);\n  }\n  unsigned getNumberOfParts(Type *Tp) override {\n    return Impl.getNumberOfParts(Tp);\n  }\n  int getAddressComputationCost(Type *Ty, ScalarEvolution *SE,\n                                const SCEV *Ptr) override {\n    return Impl.getAddressComputationCost(Ty, SE, Ptr);\n  }\n  unsigned getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) override {\n    return Impl.getCostOfKeepingLiveOverCall(Tys);\n  }\n  bool getTgtMemIntrinsic(IntrinsicInst *Inst,\n                          MemIntrinsicInfo &Info) override {\n    return Impl.getTgtMemIntrinsic(Inst, Info);\n  }\n  unsigned getAtomicMemIntrinsicMaxElementSize() const override {\n    return Impl.getAtomicMemIntrinsicMaxElementSize();\n  }\n  Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,\n                                           Type *ExpectedType) override {\n    return Impl.getOrCreateResultFromMemIntrinsic(Inst, ExpectedType);\n  }\n  Type *getMemcpyLoopLoweringType(LLVMContext &Context, Value *Length,\n                                  unsigned SrcAddrSpace, unsigned DestAddrSpace,\n                                  unsigned SrcAlign,\n                                  unsigned DestAlign) const override {\n    return Impl.getMemcpyLoopLoweringType(Context, Length, SrcAddrSpace,\n                                          DestAddrSpace, SrcAlign, DestAlign);\n  }\n  void getMemcpyLoopResidualLoweringType(\n      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,\n      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,\n      unsigned SrcAlign, unsigned DestAlign) const override {\n    Impl.getMemcpyLoopResidualLoweringType(OpsOut, Context, RemainingBytes,\n                                           SrcAddrSpace, DestAddrSpace,\n                                           SrcAlign, DestAlign);\n  }\n  bool areInlineCompatible(const Function *Caller,\n                           const Function *Callee) const override {\n    return Impl.areInlineCompatible(Caller, Callee);\n  }\n  bool areFunctionArgsABICompatible(\n      const Function *Caller, const Function *Callee,\n      SmallPtrSetImpl<Argument *> &Args) const override {\n    return Impl.areFunctionArgsABICompatible(Caller, Callee, Args);\n  }\n  bool isIndexedLoadLegal(MemIndexedMode Mode, Type *Ty) const override {\n    return Impl.isIndexedLoadLegal(Mode, Ty, getDataLayout());\n  }\n  bool isIndexedStoreLegal(MemIndexedMode Mode, Type *Ty) const override {\n    return Impl.isIndexedStoreLegal(Mode, Ty, getDataLayout());\n  }\n  unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const override {\n    return Impl.getLoadStoreVecRegBitWidth(AddrSpace);\n  }\n  bool isLegalToVectorizeLoad(LoadInst *LI) const override {\n    return Impl.isLegalToVectorizeLoad(LI);\n  }\n  bool isLegalToVectorizeStore(StoreInst *SI) const override {\n    return Impl.isLegalToVectorizeStore(SI);\n  }\n  bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes, Align Alignment,\n                                   unsigned AddrSpace) const override {\n    return Impl.isLegalToVectorizeLoadChain(ChainSizeInBytes, Alignment,\n                                            AddrSpace);\n  }\n  bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes, Align Alignment,\n                                    unsigned AddrSpace) const override {\n    return Impl.isLegalToVectorizeStoreChain(ChainSizeInBytes, Alignment,\n                                             AddrSpace);\n  }\n  bool isLegalToVectorizeReduction(RecurrenceDescriptor RdxDesc,\n                                   ElementCount VF) const override {\n    return Impl.isLegalToVectorizeReduction(RdxDesc, VF);\n  }\n  unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,\n                               unsigned ChainSizeInBytes,\n                               VectorType *VecTy) const override {\n    return Impl.getLoadVectorFactor(VF, LoadSize, ChainSizeInBytes, VecTy);\n  }\n  unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,\n                                unsigned ChainSizeInBytes,\n                                VectorType *VecTy) const override {\n    return Impl.getStoreVectorFactor(VF, StoreSize, ChainSizeInBytes, VecTy);\n  }\n  bool preferInLoopReduction(unsigned Opcode, Type *Ty,\n                             ReductionFlags Flags) const override {\n    return Impl.preferInLoopReduction(Opcode, Ty, Flags);\n  }\n  bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,\n                                       ReductionFlags Flags) const override {\n    return Impl.preferPredicatedReductionSelect(Opcode, Ty, Flags);\n  }\n  bool shouldExpandReduction(const IntrinsicInst *II) const override {\n    return Impl.shouldExpandReduction(II);\n  }\n\n  unsigned getGISelRematGlobalCost() const override {\n    return Impl.getGISelRematGlobalCost();\n  }\n\n  bool supportsScalableVectors() const override {\n    return Impl.supportsScalableVectors();\n  }\n\n  bool hasActiveVectorLength() const override {\n    return Impl.hasActiveVectorLength();\n  }\n\n  int getInstructionLatency(const Instruction *I) override {\n    return Impl.getInstructionLatency(I);\n  }\n};\n\ntemplate <typename T>\nTargetTransformInfo::TargetTransformInfo(T Impl)\n    : TTIImpl(new Model<T>(Impl)) {}\n\n/// Analysis pass providing the \\c TargetTransformInfo.\n///\n/// The core idea of the TargetIRAnalysis is to expose an interface through\n/// which LLVM targets can analyze and provide information about the middle\n/// end's target-independent IR. This supports use cases such as target-aware\n/// cost modeling of IR constructs.\n///\n/// This is a function analysis because much of the cost modeling for targets\n/// is done in a subtarget specific way and LLVM supports compiling different\n/// functions targeting different subtargets in order to support runtime\n/// dispatch according to the observed subtarget.\nclass TargetIRAnalysis : public AnalysisInfoMixin<TargetIRAnalysis> {\npublic:\n  typedef TargetTransformInfo Result;\n\n  /// Default construct a target IR analysis.\n  ///\n  /// This will use the module's datalayout to construct a baseline\n  /// conservative TTI result.\n  TargetIRAnalysis();\n\n  /// Construct an IR analysis pass around a target-provide callback.\n  ///\n  /// The callback will be called with a particular function for which the TTI\n  /// is needed and must return a TTI object for that function.\n  TargetIRAnalysis(std::function<Result(const Function &)> TTICallback);\n\n  // Value semantics. We spell out the constructors for MSVC.\n  TargetIRAnalysis(const TargetIRAnalysis &Arg)\n      : TTICallback(Arg.TTICallback) {}\n  TargetIRAnalysis(TargetIRAnalysis &&Arg)\n      : TTICallback(std::move(Arg.TTICallback)) {}\n  TargetIRAnalysis &operator=(const TargetIRAnalysis &RHS) {\n    TTICallback = RHS.TTICallback;\n    return *this;\n  }\n  TargetIRAnalysis &operator=(TargetIRAnalysis &&RHS) {\n    TTICallback = std::move(RHS.TTICallback);\n    return *this;\n  }\n\n  Result run(const Function &F, FunctionAnalysisManager &);\n\nprivate:\n  friend AnalysisInfoMixin<TargetIRAnalysis>;\n  static AnalysisKey Key;\n\n  /// The callback used to produce a result.\n  ///\n  /// We use a completely opaque callback so that targets can provide whatever\n  /// mechanism they desire for constructing the TTI for a given function.\n  ///\n  /// FIXME: Should we really use std::function? It's relatively inefficient.\n  /// It might be possible to arrange for even stateful callbacks to outlive\n  /// the analysis and thus use a function_ref which would be lighter weight.\n  /// This may also be less error prone as the callback is likely to reference\n  /// the external TargetMachine, and that reference needs to never dangle.\n  std::function<Result(const Function &)> TTICallback;\n\n  /// Helper function used as the callback in the default constructor.\n  static Result getDefaultTTI(const Function &F);\n};\n\n/// Wrapper pass for TargetTransformInfo.\n///\n/// This pass can be constructed from a TTI object which it stores internally\n/// and is queried by passes.\nclass TargetTransformInfoWrapperPass : public ImmutablePass {\n  TargetIRAnalysis TIRA;\n  Optional<TargetTransformInfo> TTI;\n\n  virtual void anchor();\n\npublic:\n  static char ID;\n\n  /// We must provide a default constructor for the pass but it should\n  /// never be used.\n  ///\n  /// Use the constructor below or call one of the creation routines.\n  TargetTransformInfoWrapperPass();\n\n  explicit TargetTransformInfoWrapperPass(TargetIRAnalysis TIRA);\n\n  TargetTransformInfo &getTTI(const Function &F);\n};\n\n/// Create an analysis pass wrapper around a TTI object.\n///\n/// This analysis pass just holds the TTI instance and makes it available to\n/// clients.\nImmutablePass *createTargetTransformInfoWrapperPass(TargetIRAnalysis TIRA);\n\n} // namespace llvm\n\n#endif\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h", "content": "//===- TargetTransformInfoImpl.h --------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This file provides helpers for the implementation of\n/// a TargetTransformInfo-conforming class.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_TARGETTRANSFORMINFOIMPL_H\n#define LLVM_ANALYSIS_TARGETTRANSFORMINFOIMPL_H\n\n#include \"llvm/Analysis/ScalarEvolutionExpressions.h\"\n#include \"llvm/Analysis/TargetTransformInfo.h\"\n#include \"llvm/Analysis/VectorUtils.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/GetElementPtrTypeIterator.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/PatternMatch.h\"\n#include \"llvm/IR/Type.h\"\n\nusing namespace llvm::PatternMatch;\n\nnamespace llvm {\n\n/// Base class for use as a mix-in that aids implementing\n/// a TargetTransformInfo-compatible class.\nclass TargetTransformInfoImplBase {\nprotected:\n  typedef TargetTransformInfo TTI;\n\n  const DataLayout &DL;\n\n  explicit TargetTransformInfoImplBase(const DataLayout &DL) : DL(DL) {}\n\npublic:\n  // Provide value semantics. MSVC requires that we spell all of these out.\n  TargetTransformInfoImplBase(const TargetTransformInfoImplBase &Arg)\n      : DL(Arg.DL) {}\n  TargetTransformInfoImplBase(TargetTransformInfoImplBase &&Arg) : DL(Arg.DL) {}\n\n  const DataLayout &getDataLayout() const { return DL; }\n\n  int getGEPCost(Type *PointeeType, const Value *Ptr,\n                 ArrayRef<const Value *> Operands,\n                 TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency) const {\n    // In the basic model, we just assume that all-constant GEPs will be folded\n    // into their uses via addressing modes.\n    for (unsigned Idx = 0, Size = Operands.size(); Idx != Size; ++Idx)\n      if (!isa<Constant>(Operands[Idx]))\n        return TTI::TCC_Basic;\n\n    return TTI::TCC_Free;\n  }\n\n  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,\n                                            unsigned &JTSize,\n                                            ProfileSummaryInfo *PSI,\n                                            BlockFrequencyInfo *BFI) const {\n    (void)PSI;\n    (void)BFI;\n    JTSize = 0;\n    return SI.getNumCases();\n  }\n\n  unsigned getInliningThresholdMultiplier() const { return 1; }\n  unsigned adjustInliningThreshold(const CallBase *CB) const { return 0; }\n\n  int getInlinerVectorBonusPercent() const { return 150; }\n\n  unsigned getMemcpyCost(const Instruction *I) const {\n    return TTI::TCC_Expensive;\n  }\n\n  bool hasBranchDivergence() const { return false; }\n\n  bool useGPUDivergenceAnalysis() const { return false; }\n\n  bool isSourceOfDivergence(const Value *V) const { return false; }\n\n  bool isAlwaysUniform(const Value *V) const { return false; }\n\n  unsigned getFlatAddressSpace() const { return -1; }\n\n  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,\n                                  Intrinsic::ID IID) const {\n    return false;\n  }\n\n  bool isNoopAddrSpaceCast(unsigned, unsigned) const { return false; }\n\n  unsigned getAssumedAddrSpace(const Value *V) const { return -1; }\n\n  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,\n                                          Value *NewV) const {\n    return nullptr;\n  }\n\n  bool isLoweredToCall(const Function *F) const {\n    assert(F && \"A concrete function must be provided to this routine.\");\n\n    // FIXME: These should almost certainly not be handled here, and instead\n    // handled with the help of TLI or the target itself. This was largely\n    // ported from existing analysis heuristics here so that such refactorings\n    // can take place in the future.\n\n    if (F->isIntrinsic())\n      return false;\n\n    if (F->hasLocalLinkage() || !F->hasName())\n      return true;\n\n    StringRef Name = F->getName();\n\n    // These will all likely lower to a single selection DAG node.\n    if (Name == \"copysign\" || Name == \"copysignf\" || Name == \"copysignl\" ||\n        Name == \"fabs\" || Name == \"fabsf\" || Name == \"fabsl\" || Name == \"sin\" ||\n        Name == \"fmin\" || Name == \"fminf\" || Name == \"fminl\" ||\n        Name == \"fmax\" || Name == \"fmaxf\" || Name == \"fmaxl\" ||\n        Name == \"sinf\" || Name == \"sinl\" || Name == \"cos\" || Name == \"cosf\" ||\n        Name == \"cosl\" || Name == \"sqrt\" || Name == \"sqrtf\" || Name == \"sqrtl\")\n      return false;\n\n    // These are all likely to be optimized into something smaller.\n    if (Name == \"pow\" || Name == \"powf\" || Name == \"powl\" || Name == \"exp2\" ||\n        Name == \"exp2l\" || Name == \"exp2f\" || Name == \"floor\" ||\n        Name == \"floorf\" || Name == \"ceil\" || Name == \"round\" ||\n        Name == \"ffs\" || Name == \"ffsl\" || Name == \"abs\" || Name == \"labs\" ||\n        Name == \"llabs\")\n      return false;\n\n    return true;\n  }\n\n  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,\n                                AssumptionCache &AC, TargetLibraryInfo *LibInfo,\n                                HardwareLoopInfo &HWLoopInfo) const {\n    return false;\n  }\n\n  bool preferPredicateOverEpilogue(Loop *L, LoopInfo *LI, ScalarEvolution &SE,\n                                   AssumptionCache &AC, TargetLibraryInfo *TLI,\n                                   DominatorTree *DT,\n                                   const LoopAccessInfo *LAI) const {\n    return false;\n  }\n\n  bool emitGetActiveLaneMask() const {\n    return false;\n  }\n\n  Optional<Instruction *> instCombineIntrinsic(InstCombiner &IC,\n                                               IntrinsicInst &II) const {\n    return None;\n  }\n\n  Optional<Value *>\n  simplifyDemandedUseBitsIntrinsic(InstCombiner &IC, IntrinsicInst &II,\n                                   APInt DemandedMask, KnownBits &Known,\n                                   bool &KnownBitsComputed) const {\n    return None;\n  }\n\n  Optional<Value *> simplifyDemandedVectorEltsIntrinsic(\n      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts, APInt &UndefElts,\n      APInt &UndefElts2, APInt &UndefElts3,\n      std::function<void(Instruction *, unsigned, APInt, APInt &)>\n          SimplifyAndSetOp) const {\n    return None;\n  }\n\n  void getUnrollingPreferences(Loop *, ScalarEvolution &,\n                               TTI::UnrollingPreferences &) const {}\n\n  void getPeelingPreferences(Loop *, ScalarEvolution &,\n                             TTI::PeelingPreferences &) const {}\n\n  bool isLegalAddImmediate(int64_t Imm) const { return false; }\n\n  bool isLegalICmpImmediate(int64_t Imm) const { return false; }\n\n  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,\n                             bool HasBaseReg, int64_t Scale, unsigned AddrSpace,\n                             Instruction *I = nullptr) const {\n    // Guess that only reg and reg+reg addressing is allowed. This heuristic is\n    // taken from the implementation of LSR.\n    return !BaseGV && BaseOffset == 0 && (Scale == 0 || Scale == 1);\n  }\n\n  bool isLSRCostLess(TTI::LSRCost &C1, TTI::LSRCost &C2) const {\n    return std::tie(C1.NumRegs, C1.AddRecCost, C1.NumIVMuls, C1.NumBaseAdds,\n                    C1.ScaleCost, C1.ImmCost, C1.SetupCost) <\n           std::tie(C2.NumRegs, C2.AddRecCost, C2.NumIVMuls, C2.NumBaseAdds,\n                    C2.ScaleCost, C2.ImmCost, C2.SetupCost);\n  }\n\n  bool isNumRegsMajorCostOfLSR() const { return true; }\n\n  bool isProfitableLSRChainElement(Instruction *I) const { return false; }\n\n  bool canMacroFuseCmp() const { return false; }\n\n  bool canSaveCmp(Loop *L, BranchInst **BI, ScalarEvolution *SE, LoopInfo *LI,\n                  DominatorTree *DT, AssumptionCache *AC,\n                  TargetLibraryInfo *LibInfo) const {\n    return false;\n  }\n\n  TTI::AddressingModeKind\n    getPreferredAddressingMode(const Loop *L, ScalarEvolution *SE) const {\n    return TTI::AMK_None;\n  }\n\n  bool isLegalMaskedStore(Type *DataType, Align Alignment) const {\n    return false;\n  }\n\n  bool isLegalMaskedLoad(Type *DataType, Align Alignment) const {\n    return false;\n  }\n\n  bool isLegalNTStore(Type *DataType, Align Alignment) const {\n    // By default, assume nontemporal memory stores are available for stores\n    // that are aligned and have a size that is a power of 2.\n    unsigned DataSize = DL.getTypeStoreSize(DataType);\n    return Alignment >= DataSize && isPowerOf2_32(DataSize);\n  }\n\n  bool isLegalNTLoad(Type *DataType, Align Alignment) const {\n    // By default, assume nontemporal memory loads are available for loads that\n    // are aligned and have a size that is a power of 2.\n    unsigned DataSize = DL.getTypeStoreSize(DataType);\n    return Alignment >= DataSize && isPowerOf2_32(DataSize);\n  }\n\n  bool isLegalMaskedScatter(Type *DataType, Align Alignment) const {\n    return false;\n  }\n\n  bool isLegalMaskedGather(Type *DataType, Align Alignment) const {\n    return false;\n  }\n\n  bool isLegalMaskedCompressStore(Type *DataType) const { return false; }\n\n  bool isLegalMaskedExpandLoad(Type *DataType) const { return false; }\n\n  bool hasDivRemOp(Type *DataType, bool IsSigned) const { return false; }\n\n  bool hasVolatileVariant(Instruction *I, unsigned AddrSpace) const {\n    return false;\n  }\n\n  bool prefersVectorizedAddressing() const { return true; }\n\n  int getScalingFactorCost(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,\n                           bool HasBaseReg, int64_t Scale,\n                           unsigned AddrSpace) const {\n    // Guess that all legal addressing mode are free.\n    if (isLegalAddressingMode(Ty, BaseGV, BaseOffset, HasBaseReg, Scale,\n                              AddrSpace))\n      return 0;\n    return -1;\n  }\n\n  bool LSRWithInstrQueries() const { return false; }\n\n  bool isTruncateFree(Type *Ty1, Type *Ty2) const { return false; }\n\n  bool isProfitableToHoist(Instruction *I) const { return true; }\n\n  bool useAA() const { return false; }\n\n  bool isTypeLegal(Type *Ty) const { return false; }\n\n  unsigned getRegUsageForType(Type *Ty) const { return 1; }\n\n  bool shouldBuildLookupTables() const { return true; }\n  bool shouldBuildLookupTablesForConstant(Constant *C) const { return true; }\n\n  bool useColdCCForColdCall(Function &F) const { return false; }\n\n  unsigned getScalarizationOverhead(VectorType *Ty, const APInt &DemandedElts,\n                                    bool Insert, bool Extract) const {\n    return 0;\n  }\n\n  unsigned getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,\n                                            ArrayRef<Type *> Tys) const {\n    return 0;\n  }\n\n  bool supportsEfficientVectorElementLoadStore() const { return false; }\n\n  bool enableAggressiveInterleaving(bool LoopHasReductions) const {\n    return false;\n  }\n\n  TTI::MemCmpExpansionOptions enableMemCmpExpansion(bool OptSize,\n                                                    bool IsZeroCmp) const {\n    return {};\n  }\n\n  bool enableInterleavedAccessVectorization() const { return false; }\n\n  bool enableMaskedInterleavedAccessVectorization() const { return false; }\n\n  bool isFPVectorizationPotentiallyUnsafe() const { return false; }\n\n  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,\n                                      unsigned AddressSpace, Align Alignment,\n                                      bool *Fast) const {\n    return false;\n  }\n\n  TTI::PopcntSupportKind getPopcntSupport(unsigned IntTyWidthInBit) const {\n    return TTI::PSK_Software;\n  }\n\n  bool haveFastSqrt(Type *Ty) const { return false; }\n\n  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) const { return true; }\n\n  unsigned getFPOpCost(Type *Ty) const {\n    return TargetTransformInfo::TCC_Basic;\n  }\n\n  int getIntImmCodeSizeCost(unsigned Opcode, unsigned Idx, const APInt &Imm,\n                            Type *Ty) const {\n    return 0;\n  }\n\n  unsigned getIntImmCost(const APInt &Imm, Type *Ty,\n                         TTI::TargetCostKind CostKind) const {\n    return TTI::TCC_Basic;\n  }\n\n  unsigned getIntImmCostInst(unsigned Opcode, unsigned Idx, const APInt &Imm,\n                             Type *Ty, TTI::TargetCostKind CostKind,\n                             Instruction *Inst = nullptr) const {\n    return TTI::TCC_Free;\n  }\n\n  unsigned getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx,\n                               const APInt &Imm, Type *Ty,\n                               TTI::TargetCostKind CostKind) const {\n    return TTI::TCC_Free;\n  }\n\n  unsigned getNumberOfRegisters(unsigned ClassID) const { return 8; }\n\n  unsigned getRegisterClassForType(bool Vector, Type *Ty = nullptr) const {\n    return Vector ? 1 : 0;\n  };\n\n  const char *getRegisterClassName(unsigned ClassID) const {\n    switch (ClassID) {\n    default:\n      return \"Generic::Unknown Register Class\";\n    case 0:\n      return \"Generic::ScalarRC\";\n    case 1:\n      return \"Generic::VectorRC\";\n    }\n  }\n\n  unsigned getRegisterBitWidth(bool Vector) const { return 32; }\n\n  unsigned getMinVectorRegisterBitWidth() const { return 128; }\n\n  Optional<unsigned> getMaxVScale() const { return None; }\n\n  bool shouldMaximizeVectorBandwidth(bool OptSize) const { return false; }\n\n  ElementCount getMinimumVF(unsigned ElemWidth, bool IsScalable) const {\n    return ElementCount::get(0, IsScalable);\n  }\n\n  unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const { return 0; }\n\n  bool shouldConsiderAddressTypePromotion(\n      const Instruction &I, bool &AllowPromotionWithoutCommonHeader) const {\n    AllowPromotionWithoutCommonHeader = false;\n    return false;\n  }\n\n  unsigned getCacheLineSize() const { return 0; }\n\n  llvm::Optional<unsigned>\n  getCacheSize(TargetTransformInfo::CacheLevel Level) const {\n    switch (Level) {\n    case TargetTransformInfo::CacheLevel::L1D:\n      LLVM_FALLTHROUGH;\n    case TargetTransformInfo::CacheLevel::L2D:\n      return llvm::Optional<unsigned>();\n    }\n    llvm_unreachable(\"Unknown TargetTransformInfo::CacheLevel\");\n  }\n\n  llvm::Optional<unsigned>\n  getCacheAssociativity(TargetTransformInfo::CacheLevel Level) const {\n    switch (Level) {\n    case TargetTransformInfo::CacheLevel::L1D:\n      LLVM_FALLTHROUGH;\n    case TargetTransformInfo::CacheLevel::L2D:\n      return llvm::Optional<unsigned>();\n    }\n\n    llvm_unreachable(\"Unknown TargetTransformInfo::CacheLevel\");\n  }\n\n  unsigned getPrefetchDistance() const { return 0; }\n  unsigned getMinPrefetchStride(unsigned NumMemAccesses,\n                                unsigned NumStridedMemAccesses,\n                                unsigned NumPrefetches, bool HasCall) const {\n    return 1;\n  }\n  unsigned getMaxPrefetchIterationsAhead() const { return UINT_MAX; }\n  bool enableWritePrefetching() const { return false; }\n\n  unsigned getMaxInterleaveFactor(unsigned VF) const { return 1; }\n\n  unsigned getArithmeticInstrCost(unsigned Opcode, Type *Ty,\n                                  TTI::TargetCostKind CostKind,\n                                  TTI::OperandValueKind Opd1Info,\n                                  TTI::OperandValueKind Opd2Info,\n                                  TTI::OperandValueProperties Opd1PropInfo,\n                                  TTI::OperandValueProperties Opd2PropInfo,\n                                  ArrayRef<const Value *> Args,\n                                  const Instruction *CxtI = nullptr) const {\n    // FIXME: A number of transformation tests seem to require these values\n    // which seems a little odd for how arbitary there are.\n    switch (Opcode) {\n    default:\n      break;\n    case Instruction::FDiv:\n    case Instruction::FRem:\n    case Instruction::SDiv:\n    case Instruction::SRem:\n    case Instruction::UDiv:\n    case Instruction::URem:\n      // FIXME: Unlikely to be true for CodeSize.\n      return TTI::TCC_Expensive;\n    }\n    return 1;\n  }\n\n  unsigned getShuffleCost(TTI::ShuffleKind Kind, VectorType *Ty, int Index,\n                          VectorType *SubTp) const {\n    return 1;\n  }\n\n  unsigned getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,\n                            TTI::CastContextHint CCH,\n                            TTI::TargetCostKind CostKind,\n                            const Instruction *I) const {\n    switch (Opcode) {\n    default:\n      break;\n    case Instruction::IntToPtr: {\n      unsigned SrcSize = Src->getScalarSizeInBits();\n      if (DL.isLegalInteger(SrcSize) &&\n          SrcSize <= DL.getPointerTypeSizeInBits(Dst))\n        return 0;\n      break;\n    }\n    case Instruction::PtrToInt: {\n      unsigned DstSize = Dst->getScalarSizeInBits();\n      if (DL.isLegalInteger(DstSize) &&\n          DstSize >= DL.getPointerTypeSizeInBits(Src))\n        return 0;\n      break;\n    }\n    case Instruction::BitCast:\n      if (Dst == Src || (Dst->isPointerTy() && Src->isPointerTy()))\n        // Identity and pointer-to-pointer casts are free.\n        return 0;\n      break;\n    case Instruction::Trunc: {\n      // trunc to a native type is free (assuming the target has compare and\n      // shift-right of the same width).\n      TypeSize DstSize = DL.getTypeSizeInBits(Dst);\n      if (!DstSize.isScalable() && DL.isLegalInteger(DstSize.getFixedSize()))\n        return 0;\n      break;\n    }\n    }\n    return 1;\n  }\n\n  unsigned getExtractWithExtendCost(unsigned Opcode, Type *Dst,\n                                    VectorType *VecTy, unsigned Index) const {\n    return 1;\n  }\n\n  unsigned getCFInstrCost(unsigned Opcode, TTI::TargetCostKind CostKind) const {\n    // A phi would be free, unless we're costing the throughput because it\n    // will require a register.\n    if (Opcode == Instruction::PHI && CostKind != TTI::TCK_RecipThroughput)\n      return 0;\n    return 1;\n  }\n\n  unsigned getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,\n                              CmpInst::Predicate VecPred,\n                              TTI::TargetCostKind CostKind,\n                              const Instruction *I) const {\n    return 1;\n  }\n\n  unsigned getVectorInstrCost(unsigned Opcode, Type *Val,\n                              unsigned Index) const {\n    return 1;\n  }\n\n  unsigned getMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,\n                           unsigned AddressSpace, TTI::TargetCostKind CostKind,\n                           const Instruction *I) const {\n    return 1;\n  }\n\n  unsigned getMaskedMemoryOpCost(unsigned Opcode, Type *Src, Align Alignment,\n                                 unsigned AddressSpace,\n                                 TTI::TargetCostKind CostKind) const {\n    return 1;\n  }\n\n  unsigned getGatherScatterOpCost(unsigned Opcode, Type *DataTy,\n                                  const Value *Ptr, bool VariableMask,\n                                  Align Alignment, TTI::TargetCostKind CostKind,\n                                  const Instruction *I = nullptr) const {\n    return 1;\n  }\n\n  unsigned getInterleavedMemoryOpCost(\n      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,\n      Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,\n      bool UseMaskForCond, bool UseMaskForGaps) const {\n    return 1;\n  }\n\n  unsigned getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,\n                                 TTI::TargetCostKind CostKind) const {\n    switch (ICA.getID()) {\n    default:\n      break;\n    case Intrinsic::annotation:\n    case Intrinsic::assume:\n    case Intrinsic::sideeffect:\n    case Intrinsic::pseudoprobe:\n    case Intrinsic::dbg_declare:\n    case Intrinsic::dbg_value:\n    case Intrinsic::dbg_label:\n    case Intrinsic::invariant_start:\n    case Intrinsic::invariant_end:\n    case Intrinsic::launder_invariant_group:\n    case Intrinsic::strip_invariant_group:\n    case Intrinsic::is_constant:\n    case Intrinsic::lifetime_start:\n    case Intrinsic::lifetime_end:\n    case Intrinsic::experimental_noalias_scope_decl:\n    case Intrinsic::objectsize:\n    case Intrinsic::ptr_annotation:\n    case Intrinsic::var_annotation:\n    case Intrinsic::experimental_gc_result:\n    case Intrinsic::experimental_gc_relocate:\n    case Intrinsic::coro_alloc:\n    case Intrinsic::coro_begin:\n    case Intrinsic::coro_free:\n    case Intrinsic::coro_end:\n    case Intrinsic::coro_frame:\n    case Intrinsic::coro_size:\n    case Intrinsic::coro_suspend:\n    case Intrinsic::coro_param:\n    case Intrinsic::coro_subfn_addr:\n      // These intrinsics don't actually represent code after lowering.\n      return 0;\n    }\n    return 1;\n  }\n\n  unsigned getCallInstrCost(Function *F, Type *RetTy, ArrayRef<Type *> Tys,\n                            TTI::TargetCostKind CostKind) const {\n    return 1;\n  }\n\n  unsigned getNumberOfParts(Type *Tp) const { return 0; }\n\n  unsigned getAddressComputationCost(Type *Tp, ScalarEvolution *,\n                                     const SCEV *) const {\n    return 0;\n  }\n\n  unsigned getArithmeticReductionCost(unsigned, VectorType *, bool,\n                                      TTI::TargetCostKind) const {\n    return 1;\n  }\n\n  unsigned getMinMaxReductionCost(VectorType *, VectorType *, bool, bool,\n                                  TTI::TargetCostKind) const {\n    return 1;\n  }\n\n  InstructionCost getExtendedAddReductionCost(\n      bool IsMLA, bool IsUnsigned, Type *ResTy, VectorType *Ty,\n      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput) const {\n    return 1;\n  }\n\n  unsigned getCostOfKeepingLiveOverCall(ArrayRef<Type *> Tys) const {\n    return 0;\n  }\n\n  bool getTgtMemIntrinsic(IntrinsicInst *Inst, MemIntrinsicInfo &Info) const {\n    return false;\n  }\n\n  unsigned getAtomicMemIntrinsicMaxElementSize() const {\n    // Note for overrides: You must ensure for all element unordered-atomic\n    // memory intrinsics that all power-of-2 element sizes up to, and\n    // including, the return value of this method have a corresponding\n    // runtime lib call. These runtime lib call definitions can be found\n    // in RuntimeLibcalls.h\n    return 0;\n  }\n\n  Value *getOrCreateResultFromMemIntrinsic(IntrinsicInst *Inst,\n                                           Type *ExpectedType) const {\n    return nullptr;\n  }\n\n  Type *getMemcpyLoopLoweringType(LLVMContext &Context, Value *Length,\n                                  unsigned SrcAddrSpace, unsigned DestAddrSpace,\n                                  unsigned SrcAlign, unsigned DestAlign) const {\n    return Type::getInt8Ty(Context);\n  }\n\n  void getMemcpyLoopResidualLoweringType(\n      SmallVectorImpl<Type *> &OpsOut, LLVMContext &Context,\n      unsigned RemainingBytes, unsigned SrcAddrSpace, unsigned DestAddrSpace,\n      unsigned SrcAlign, unsigned DestAlign) const {\n    for (unsigned i = 0; i != RemainingBytes; ++i)\n      OpsOut.push_back(Type::getInt8Ty(Context));\n  }\n\n  bool areInlineCompatible(const Function *Caller,\n                           const Function *Callee) const {\n    return (Caller->getFnAttribute(\"target-cpu\") ==\n            Callee->getFnAttribute(\"target-cpu\")) &&\n           (Caller->getFnAttribute(\"target-features\") ==\n            Callee->getFnAttribute(\"target-features\"));\n  }\n\n  bool areFunctionArgsABICompatible(const Function *Caller,\n                                    const Function *Callee,\n                                    SmallPtrSetImpl<Argument *> &Args) const {\n    return (Caller->getFnAttribute(\"target-cpu\") ==\n            Callee->getFnAttribute(\"target-cpu\")) &&\n           (Caller->getFnAttribute(\"target-features\") ==\n            Callee->getFnAttribute(\"target-features\"));\n  }\n\n  bool isIndexedLoadLegal(TTI::MemIndexedMode Mode, Type *Ty,\n                          const DataLayout &DL) const {\n    return false;\n  }\n\n  bool isIndexedStoreLegal(TTI::MemIndexedMode Mode, Type *Ty,\n                           const DataLayout &DL) const {\n    return false;\n  }\n\n  unsigned getLoadStoreVecRegBitWidth(unsigned AddrSpace) const { return 128; }\n\n  bool isLegalToVectorizeLoad(LoadInst *LI) const { return true; }\n\n  bool isLegalToVectorizeStore(StoreInst *SI) const { return true; }\n\n  bool isLegalToVectorizeLoadChain(unsigned ChainSizeInBytes, Align Alignment,\n                                   unsigned AddrSpace) const {\n    return true;\n  }\n\n  bool isLegalToVectorizeStoreChain(unsigned ChainSizeInBytes, Align Alignment,\n                                    unsigned AddrSpace) const {\n    return true;\n  }\n\n  bool isLegalToVectorizeReduction(RecurrenceDescriptor RdxDesc,\n                                   ElementCount VF) const {\n    return true;\n  }\n\n  unsigned getLoadVectorFactor(unsigned VF, unsigned LoadSize,\n                               unsigned ChainSizeInBytes,\n                               VectorType *VecTy) const {\n    return VF;\n  }\n\n  unsigned getStoreVectorFactor(unsigned VF, unsigned StoreSize,\n                                unsigned ChainSizeInBytes,\n                                VectorType *VecTy) const {\n    return VF;\n  }\n\n  bool preferInLoopReduction(unsigned Opcode, Type *Ty,\n                             TTI::ReductionFlags Flags) const {\n    return false;\n  }\n\n  bool preferPredicatedReductionSelect(unsigned Opcode, Type *Ty,\n                                       TTI::ReductionFlags Flags) const {\n    return false;\n  }\n\n  bool shouldExpandReduction(const IntrinsicInst *II) const { return true; }\n\n  unsigned getGISelRematGlobalCost() const { return 1; }\n\n  bool supportsScalableVectors() const { return false; }\n\n  bool hasActiveVectorLength() const { return false; }\n\nprotected:\n  // Obtain the minimum required size to hold the value (without the sign)\n  // In case of a vector it returns the min required size for one element.\n  unsigned minRequiredElementSize(const Value *Val, bool &isSigned) const {\n    if (isa<ConstantDataVector>(Val) || isa<ConstantVector>(Val)) {\n      const auto *VectorValue = cast<Constant>(Val);\n\n      // In case of a vector need to pick the max between the min\n      // required size for each element\n      auto *VT = cast<FixedVectorType>(Val->getType());\n\n      // Assume unsigned elements\n      isSigned = false;\n\n      // The max required size is the size of the vector element type\n      unsigned MaxRequiredSize =\n          VT->getElementType()->getPrimitiveSizeInBits().getFixedSize();\n\n      unsigned MinRequiredSize = 0;\n      for (unsigned i = 0, e = VT->getNumElements(); i < e; ++i) {\n        if (auto *IntElement =\n                dyn_cast<ConstantInt>(VectorValue->getAggregateElement(i))) {\n          bool signedElement = IntElement->getValue().isNegative();\n          // Get the element min required size.\n          unsigned ElementMinRequiredSize =\n              IntElement->getValue().getMinSignedBits() - 1;\n          // In case one element is signed then all the vector is signed.\n          isSigned |= signedElement;\n          // Save the max required bit size between all the elements.\n          MinRequiredSize = std::max(MinRequiredSize, ElementMinRequiredSize);\n        } else {\n          // not an int constant element\n          return MaxRequiredSize;\n        }\n      }\n      return MinRequiredSize;\n    }\n\n    if (const auto *CI = dyn_cast<ConstantInt>(Val)) {\n      isSigned = CI->getValue().isNegative();\n      return CI->getValue().getMinSignedBits() - 1;\n    }\n\n    if (const auto *Cast = dyn_cast<SExtInst>(Val)) {\n      isSigned = true;\n      return Cast->getSrcTy()->getScalarSizeInBits() - 1;\n    }\n\n    if (const auto *Cast = dyn_cast<ZExtInst>(Val)) {\n      isSigned = false;\n      return Cast->getSrcTy()->getScalarSizeInBits();\n    }\n\n    isSigned = false;\n    return Val->getType()->getScalarSizeInBits();\n  }\n\n  bool isStridedAccess(const SCEV *Ptr) const {\n    return Ptr && isa<SCEVAddRecExpr>(Ptr);\n  }\n\n  const SCEVConstant *getConstantStrideStep(ScalarEvolution *SE,\n                                            const SCEV *Ptr) const {\n    if (!isStridedAccess(Ptr))\n      return nullptr;\n    const SCEVAddRecExpr *AddRec = cast<SCEVAddRecExpr>(Ptr);\n    return dyn_cast<SCEVConstant>(AddRec->getStepRecurrence(*SE));\n  }\n\n  bool isConstantStridedAccessLessThan(ScalarEvolution *SE, const SCEV *Ptr,\n                                       int64_t MergeDistance) const {\n    const SCEVConstant *Step = getConstantStrideStep(SE, Ptr);\n    if (!Step)\n      return false;\n    APInt StrideVal = Step->getAPInt();\n    if (StrideVal.getBitWidth() > 64)\n      return false;\n    // FIXME: Need to take absolute value for negative stride case.\n    return StrideVal.getSExtValue() < MergeDistance;\n  }\n};\n\n/// CRTP base class for use as a mix-in that aids implementing\n/// a TargetTransformInfo-compatible class.\ntemplate <typename T>\nclass TargetTransformInfoImplCRTPBase : public TargetTransformInfoImplBase {\nprivate:\n  typedef TargetTransformInfoImplBase BaseT;\n\nprotected:\n  explicit TargetTransformInfoImplCRTPBase(const DataLayout &DL) : BaseT(DL) {}\n\npublic:\n  using BaseT::getGEPCost;\n\n  int getGEPCost(Type *PointeeType, const Value *Ptr,\n                 ArrayRef<const Value *> Operands,\n                 TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency) {\n    assert(PointeeType && Ptr && \"can't get GEPCost of nullptr\");\n    // TODO: will remove this when pointers have an opaque type.\n    assert(Ptr->getType()->getScalarType()->getPointerElementType() ==\n               PointeeType &&\n           \"explicit pointee type doesn't match operand's pointee type\");\n    auto *BaseGV = dyn_cast<GlobalValue>(Ptr->stripPointerCasts());\n    bool HasBaseReg = (BaseGV == nullptr);\n\n    auto PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr->getType());\n    APInt BaseOffset(PtrSizeBits, 0);\n    int64_t Scale = 0;\n\n    auto GTI = gep_type_begin(PointeeType, Operands);\n    Type *TargetType = nullptr;\n\n    // Handle the case where the GEP instruction has a single operand,\n    // the basis, therefore TargetType is a nullptr.\n    if (Operands.empty())\n      return !BaseGV ? TTI::TCC_Free : TTI::TCC_Basic;\n\n    for (auto I = Operands.begin(); I != Operands.end(); ++I, ++GTI) {\n      TargetType = GTI.getIndexedType();\n      // We assume that the cost of Scalar GEP with constant index and the\n      // cost of Vector GEP with splat constant index are the same.\n      const ConstantInt *ConstIdx = dyn_cast<ConstantInt>(*I);\n      if (!ConstIdx)\n        if (auto Splat = getSplatValue(*I))\n          ConstIdx = dyn_cast<ConstantInt>(Splat);\n      if (StructType *STy = GTI.getStructTypeOrNull()) {\n        // For structures the index is always splat or scalar constant\n        assert(ConstIdx && \"Unexpected GEP index\");\n        uint64_t Field = ConstIdx->getZExtValue();\n        BaseOffset += DL.getStructLayout(STy)->getElementOffset(Field);\n      } else {\n        // If this operand is a scalable type, bail out early.\n        // TODO: handle scalable vectors\n        if (isa<ScalableVectorType>(TargetType))\n          return TTI::TCC_Basic;\n        int64_t ElementSize =\n            DL.getTypeAllocSize(GTI.getIndexedType()).getFixedSize();\n        if (ConstIdx) {\n          BaseOffset +=\n              ConstIdx->getValue().sextOrTrunc(PtrSizeBits) * ElementSize;\n        } else {\n          // Needs scale register.\n          if (Scale != 0)\n            // No addressing mode takes two scale registers.\n            return TTI::TCC_Basic;\n          Scale = ElementSize;\n        }\n      }\n    }\n\n    if (static_cast<T *>(this)->isLegalAddressingMode(\n            TargetType, const_cast<GlobalValue *>(BaseGV),\n            BaseOffset.sextOrTrunc(64).getSExtValue(), HasBaseReg, Scale,\n            Ptr->getType()->getPointerAddressSpace()))\n      return TTI::TCC_Free;\n    return TTI::TCC_Basic;\n  }\n\n  int getUserCost(const User *U, ArrayRef<const Value *> Operands,\n                  TTI::TargetCostKind CostKind) {\n    auto *TargetTTI = static_cast<T *>(this);\n    // Handle non-intrinsic calls, invokes, and callbr.\n    // FIXME: Unlikely to be true for anything but CodeSize.\n    auto *CB = dyn_cast<CallBase>(U);\n    if (CB && !isa<IntrinsicInst>(U)) {\n      if (const Function *F = CB->getCalledFunction()) {\n        if (!TargetTTI->isLoweredToCall(F))\n          return TTI::TCC_Basic; // Give a basic cost if it will be lowered\n\n        return TTI::TCC_Basic * (F->getFunctionType()->getNumParams() + 1);\n      }\n      // For indirect or other calls, scale cost by number of arguments.\n      return TTI::TCC_Basic * (CB->arg_size() + 1);\n    }\n\n    Type *Ty = U->getType();\n    Type *OpTy =\n      U->getNumOperands() == 1 ? U->getOperand(0)->getType() : nullptr;\n    unsigned Opcode = Operator::getOpcode(U);\n    auto *I = dyn_cast<Instruction>(U);\n    switch (Opcode) {\n    default:\n      break;\n    case Instruction::Call: {\n      assert(isa<IntrinsicInst>(U) && \"Unexpected non-intrinsic call\");\n      auto *Intrinsic = cast<IntrinsicInst>(U);\n      IntrinsicCostAttributes CostAttrs(Intrinsic->getIntrinsicID(), *CB);\n      return TargetTTI->getIntrinsicInstrCost(CostAttrs, CostKind);\n    }\n    case Instruction::Br:\n    case Instruction::Ret:\n    case Instruction::PHI:\n      return TargetTTI->getCFInstrCost(Opcode, CostKind);\n    case Instruction::ExtractValue:\n    case Instruction::Freeze:\n      return TTI::TCC_Free;\n    case Instruction::Alloca:\n      if (cast<AllocaInst>(U)->isStaticAlloca())\n        return TTI::TCC_Free;\n      break;\n    case Instruction::GetElementPtr: {\n      const GEPOperator *GEP = cast<GEPOperator>(U);\n      return TargetTTI->getGEPCost(GEP->getSourceElementType(),\n                                   GEP->getPointerOperand(),\n                                   Operands.drop_front());\n    }\n    case Instruction::Add:\n    case Instruction::FAdd:\n    case Instruction::Sub:\n    case Instruction::FSub:\n    case Instruction::Mul:\n    case Instruction::FMul:\n    case Instruction::UDiv:\n    case Instruction::SDiv:\n    case Instruction::FDiv:\n    case Instruction::URem:\n    case Instruction::SRem:\n    case Instruction::FRem:\n    case Instruction::Shl:\n    case Instruction::LShr:\n    case Instruction::AShr:\n    case Instruction::And:\n    case Instruction::Or:\n    case Instruction::Xor:\n    case Instruction::FNeg: {\n      TTI::OperandValueProperties Op1VP = TTI::OP_None;\n      TTI::OperandValueProperties Op2VP = TTI::OP_None;\n      TTI::OperandValueKind Op1VK =\n        TTI::getOperandInfo(U->getOperand(0), Op1VP);\n      TTI::OperandValueKind Op2VK = Opcode != Instruction::FNeg ?\n        TTI::getOperandInfo(U->getOperand(1), Op2VP) : TTI::OK_AnyValue;\n      SmallVector<const Value *, 2> Operands(U->operand_values());\n      return TargetTTI->getArithmeticInstrCost(Opcode, Ty, CostKind,\n                                               Op1VK, Op2VK,\n                                               Op1VP, Op2VP, Operands, I);\n    }\n    case Instruction::IntToPtr:\n    case Instruction::PtrToInt:\n    case Instruction::SIToFP:\n    case Instruction::UIToFP:\n    case Instruction::FPToUI:\n    case Instruction::FPToSI:\n    case Instruction::Trunc:\n    case Instruction::FPTrunc:\n    case Instruction::BitCast:\n    case Instruction::FPExt:\n    case Instruction::SExt:\n    case Instruction::ZExt:\n    case Instruction::AddrSpaceCast:\n      return TargetTTI->getCastInstrCost(\n          Opcode, Ty, OpTy, TTI::getCastContextHint(I), CostKind, I);\n    case Instruction::Store: {\n      auto *SI = cast<StoreInst>(U);\n      Type *ValTy = U->getOperand(0)->getType();\n      return TargetTTI->getMemoryOpCost(Opcode, ValTy, SI->getAlign(),\n                                        SI->getPointerAddressSpace(),\n                                        CostKind, I);\n    }\n    case Instruction::Load: {\n      auto *LI = cast<LoadInst>(U);\n      return TargetTTI->getMemoryOpCost(Opcode, U->getType(), LI->getAlign(),\n                                        LI->getPointerAddressSpace(),\n                                        CostKind, I);\n    }\n    case Instruction::Select: {\n      const Value *Op0, *Op1;\n      if (match(U, m_LogicalAnd(m_Value(Op0), m_Value(Op1))) ||\n          match(U, m_LogicalOr(m_Value(Op0), m_Value(Op1)))) {\n        // select x, y, false --> x & y\n        // select x, true, y --> x | y\n        TTI::OperandValueProperties Op1VP = TTI::OP_None;\n        TTI::OperandValueProperties Op2VP = TTI::OP_None;\n        TTI::OperandValueKind Op1VK = TTI::getOperandInfo(Op0, Op1VP);\n        TTI::OperandValueKind Op2VK = TTI::getOperandInfo(Op1, Op2VP);\n        assert(Op0->getType()->getScalarSizeInBits() == 1 &&\n               Op1->getType()->getScalarSizeInBits() == 1);\n\n        SmallVector<const Value *, 2> Operands{Op0, Op1};\n        return TargetTTI->getArithmeticInstrCost(\n            match(U, m_LogicalOr()) ? Instruction::Or : Instruction::And, Ty,\n            CostKind, Op1VK, Op2VK, Op1VP, Op2VP, Operands, I);\n      }\n      Type *CondTy = U->getOperand(0)->getType();\n      return TargetTTI->getCmpSelInstrCost(Opcode, U->getType(), CondTy,\n                                           CmpInst::BAD_ICMP_PREDICATE,\n                                           CostKind, I);\n    }\n    case Instruction::ICmp:\n    case Instruction::FCmp: {\n      Type *ValTy = U->getOperand(0)->getType();\n      // TODO: Also handle ICmp/FCmp constant expressions.\n      return TargetTTI->getCmpSelInstrCost(Opcode, ValTy, U->getType(),\n                                           I ? cast<CmpInst>(I)->getPredicate()\n                                             : CmpInst::BAD_ICMP_PREDICATE,\n                                           CostKind, I);\n    }\n    case Instruction::InsertElement: {\n      auto *IE = dyn_cast<InsertElementInst>(U);\n      if (!IE)\n        return TTI::TCC_Basic; // FIXME\n      auto *CI = dyn_cast<ConstantInt>(IE->getOperand(2));\n      unsigned Idx = CI ? CI->getZExtValue() : -1;\n      return TargetTTI->getVectorInstrCost(Opcode, Ty, Idx);\n    }\n    case Instruction::ShuffleVector: {\n      auto *Shuffle = dyn_cast<ShuffleVectorInst>(U);\n      if (!Shuffle)\n        return TTI::TCC_Basic; // FIXME\n      auto *VecTy = cast<VectorType>(U->getType());\n      auto *VecSrcTy = cast<VectorType>(U->getOperand(0)->getType());\n\n      // TODO: Identify and add costs for insert subvector, etc.\n      int SubIndex;\n      if (Shuffle->isExtractSubvectorMask(SubIndex))\n        return TargetTTI->getShuffleCost(TTI::SK_ExtractSubvector, VecSrcTy,\n                                         SubIndex, VecTy);\n      else if (Shuffle->changesLength())\n        return CostKind == TTI::TCK_RecipThroughput ? -1 : 1;\n      else if (Shuffle->isIdentity())\n        return 0;\n      else if (Shuffle->isReverse())\n        return TargetTTI->getShuffleCost(TTI::SK_Reverse, VecTy, 0, nullptr);\n      else if (Shuffle->isSelect())\n        return TargetTTI->getShuffleCost(TTI::SK_Select, VecTy, 0, nullptr);\n      else if (Shuffle->isTranspose())\n        return TargetTTI->getShuffleCost(TTI::SK_Transpose, VecTy, 0, nullptr);\n      else if (Shuffle->isZeroEltSplat())\n        return TargetTTI->getShuffleCost(TTI::SK_Broadcast, VecTy, 0, nullptr);\n      else if (Shuffle->isSingleSource())\n        return TargetTTI->getShuffleCost(TTI::SK_PermuteSingleSrc, VecTy, 0,\n                                         nullptr);\n\n      return TargetTTI->getShuffleCost(TTI::SK_PermuteTwoSrc, VecTy, 0,\n                                       nullptr);\n    }\n    case Instruction::ExtractElement: {\n      unsigned Idx = -1;\n      auto *EEI = dyn_cast<ExtractElementInst>(U);\n      if (!EEI)\n        return TTI::TCC_Basic; // FIXME\n\n      auto *CI = dyn_cast<ConstantInt>(EEI->getOperand(1));\n      if (CI)\n        Idx = CI->getZExtValue();\n\n      // Try to match a reduction (a series of shufflevector and vector ops\n      // followed by an extractelement).\n      unsigned RdxOpcode;\n      VectorType *RdxType;\n      bool IsPairwise;\n      switch (TTI::matchVectorReduction(EEI, RdxOpcode, RdxType, IsPairwise)) {\n      case TTI::RK_Arithmetic:\n        return TargetTTI->getArithmeticReductionCost(RdxOpcode, RdxType,\n                                                     IsPairwise, CostKind);\n      case TTI::RK_MinMax:\n        return TargetTTI->getMinMaxReductionCost(\n            RdxType, cast<VectorType>(CmpInst::makeCmpResultType(RdxType)),\n            IsPairwise, /*IsUnsigned=*/false, CostKind);\n      case TTI::RK_UnsignedMinMax:\n        return TargetTTI->getMinMaxReductionCost(\n            RdxType, cast<VectorType>(CmpInst::makeCmpResultType(RdxType)),\n            IsPairwise, /*IsUnsigned=*/true, CostKind);\n      case TTI::RK_None:\n        break;\n      }\n      return TargetTTI->getVectorInstrCost(Opcode, U->getOperand(0)->getType(),\n                                           Idx);\n    }\n    }\n    // By default, just classify everything as 'basic'.\n    return TTI::TCC_Basic;\n  }\n\n  int getInstructionLatency(const Instruction *I) {\n    SmallVector<const Value *, 4> Operands(I->operand_values());\n    if (getUserCost(I, Operands, TTI::TCK_Latency) == TTI::TCC_Free)\n      return 0;\n\n    if (isa<LoadInst>(I))\n      return 4;\n\n    Type *DstTy = I->getType();\n\n    // Usually an intrinsic is a simple instruction.\n    // A real function call is much slower.\n    if (auto *CI = dyn_cast<CallInst>(I)) {\n      const Function *F = CI->getCalledFunction();\n      if (!F || static_cast<T *>(this)->isLoweredToCall(F))\n        return 40;\n      // Some intrinsics return a value and a flag, we use the value type\n      // to decide its latency.\n      if (StructType *StructTy = dyn_cast<StructType>(DstTy))\n        DstTy = StructTy->getElementType(0);\n      // Fall through to simple instructions.\n    }\n\n    if (VectorType *VectorTy = dyn_cast<VectorType>(DstTy))\n      DstTy = VectorTy->getElementType();\n    if (DstTy->isFloatingPointTy())\n      return 3;\n\n    return 1;\n  }\n};\n} // namespace llvm\n\n#endif\n"}, "53": {"id": 53, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h", "content": "//===- llvm/CodeGen/TargetLowering.h - Target Lowering Info -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file describes how to lower LLVM code to machine code.  This has two\n/// main components:\n///\n///  1. Which ValueTypes are natively supported by the target.\n///  2. Which operations are supported for supported ValueTypes.\n///  3. Cost thresholds for alternative implementations of certain operations.\n///\n/// In addition it has a few other components, like information about FP\n/// immediates.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_TARGETLOWERING_H\n#define LLVM_CODEGEN_TARGETLOWERING_H\n\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/CodeGen/DAGCombine.h\"\n#include \"llvm/CodeGen/ISDOpcodes.h\"\n#include \"llvm/CodeGen/RuntimeLibcalls.h\"\n#include \"llvm/CodeGen/SelectionDAG.h\"\n#include \"llvm/CodeGen/SelectionDAGNodes.h\"\n#include \"llvm/CodeGen/TargetCallingConv.h\"\n#include \"llvm/CodeGen/ValueTypes.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/CallingConv.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/InlineAsm.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MachineValueType.h\"\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cstdint>\n#include <iterator>\n#include <map>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass BranchProbability;\nclass CCState;\nclass CCValAssign;\nclass Constant;\nclass FastISel;\nclass FunctionLoweringInfo;\nclass GlobalValue;\nclass GISelKnownBits;\nclass IntrinsicInst;\nstruct KnownBits;\nclass LegacyDivergenceAnalysis;\nclass LLVMContext;\nclass MachineBasicBlock;\nclass MachineFunction;\nclass MachineInstr;\nclass MachineJumpTableInfo;\nclass MachineLoop;\nclass MachineRegisterInfo;\nclass MCContext;\nclass MCExpr;\nclass Module;\nclass ProfileSummaryInfo;\nclass TargetLibraryInfo;\nclass TargetMachine;\nclass TargetRegisterClass;\nclass TargetRegisterInfo;\nclass TargetTransformInfo;\nclass Value;\n\nnamespace Sched {\n\n  enum Preference {\n    None,             // No preference\n    Source,           // Follow source order.\n    RegPressure,      // Scheduling for lowest register pressure.\n    Hybrid,           // Scheduling for both latency and register pressure.\n    ILP,              // Scheduling for ILP in low register pressure mode.\n    VLIW              // Scheduling for VLIW targets.\n  };\n\n} // end namespace Sched\n\n// MemOp models a memory operation, either memset or memcpy/memmove.\nstruct MemOp {\nprivate:\n  // Shared\n  uint64_t Size;\n  bool DstAlignCanChange; // true if destination alignment can satisfy any\n                          // constraint.\n  Align DstAlign;         // Specified alignment of the memory operation.\n\n  bool AllowOverlap;\n  // memset only\n  bool IsMemset;   // If setthis memory operation is a memset.\n  bool ZeroMemset; // If set clears out memory with zeros.\n  // memcpy only\n  bool MemcpyStrSrc; // Indicates whether the memcpy source is an in-register\n                     // constant so it does not need to be loaded.\n  Align SrcAlign;    // Inferred alignment of the source or default value if the\n                     // memory operation does not need to load the value.\npublic:\n  static MemOp Copy(uint64_t Size, bool DstAlignCanChange, Align DstAlign,\n                    Align SrcAlign, bool IsVolatile,\n                    bool MemcpyStrSrc = false) {\n    MemOp Op;\n    Op.Size = Size;\n    Op.DstAlignCanChange = DstAlignCanChange;\n    Op.DstAlign = DstAlign;\n    Op.AllowOverlap = !IsVolatile;\n    Op.IsMemset = false;\n    Op.ZeroMemset = false;\n    Op.MemcpyStrSrc = MemcpyStrSrc;\n    Op.SrcAlign = SrcAlign;\n    return Op;\n  }\n\n  static MemOp Set(uint64_t Size, bool DstAlignCanChange, Align DstAlign,\n                   bool IsZeroMemset, bool IsVolatile) {\n    MemOp Op;\n    Op.Size = Size;\n    Op.DstAlignCanChange = DstAlignCanChange;\n    Op.DstAlign = DstAlign;\n    Op.AllowOverlap = !IsVolatile;\n    Op.IsMemset = true;\n    Op.ZeroMemset = IsZeroMemset;\n    Op.MemcpyStrSrc = false;\n    return Op;\n  }\n\n  uint64_t size() const { return Size; }\n  Align getDstAlign() const {\n    assert(!DstAlignCanChange);\n    return DstAlign;\n  }\n  bool isFixedDstAlign() const { return !DstAlignCanChange; }\n  bool allowOverlap() const { return AllowOverlap; }\n  bool isMemset() const { return IsMemset; }\n  bool isMemcpy() const { return !IsMemset; }\n  bool isMemcpyWithFixedDstAlign() const {\n    return isMemcpy() && !DstAlignCanChange;\n  }\n  bool isZeroMemset() const { return isMemset() && ZeroMemset; }\n  bool isMemcpyStrSrc() const {\n    assert(isMemcpy() && \"Must be a memcpy\");\n    return MemcpyStrSrc;\n  }\n  Align getSrcAlign() const {\n    assert(isMemcpy() && \"Must be a memcpy\");\n    return SrcAlign;\n  }\n  bool isSrcAligned(Align AlignCheck) const {\n    return isMemset() || llvm::isAligned(AlignCheck, SrcAlign.value());\n  }\n  bool isDstAligned(Align AlignCheck) const {\n    return DstAlignCanChange || llvm::isAligned(AlignCheck, DstAlign.value());\n  }\n  bool isAligned(Align AlignCheck) const {\n    return isSrcAligned(AlignCheck) && isDstAligned(AlignCheck);\n  }\n};\n\n/// This base class for TargetLowering contains the SelectionDAG-independent\n/// parts that can be used from the rest of CodeGen.\nclass TargetLoweringBase {\npublic:\n  /// This enum indicates whether operations are valid for a target, and if not,\n  /// what action should be used to make them valid.\n  enum LegalizeAction : uint8_t {\n    Legal,      // The target natively supports this operation.\n    Promote,    // This operation should be executed in a larger type.\n    Expand,     // Try to expand this to other ops, otherwise use a libcall.\n    LibCall,    // Don't try to expand this to other ops, always use a libcall.\n    Custom      // Use the LowerOperation hook to implement custom lowering.\n  };\n\n  /// This enum indicates whether a types are legal for a target, and if not,\n  /// what action should be used to make them valid.\n  enum LegalizeTypeAction : uint8_t {\n    TypeLegal,           // The target natively supports this type.\n    TypePromoteInteger,  // Replace this integer with a larger one.\n    TypeExpandInteger,   // Split this integer into two of half the size.\n    TypeSoftenFloat,     // Convert this float to a same size integer type.\n    TypeExpandFloat,     // Split this float into two of half the size.\n    TypeScalarizeVector, // Replace this one-element vector with its element.\n    TypeSplitVector,     // Split this vector into two of half the size.\n    TypeWidenVector,     // This vector should be widened into a larger vector.\n    TypePromoteFloat,    // Replace this float with a larger one.\n    TypeSoftPromoteHalf, // Soften half to i16 and use float to do arithmetic.\n    TypeScalarizeScalableVector, // This action is explicitly left unimplemented.\n                                 // While it is theoretically possible to\n                                 // legalize operations on scalable types with a\n                                 // loop that handles the vscale * #lanes of the\n                                 // vector, this is non-trivial at SelectionDAG\n                                 // level and these types are better to be\n                                 // widened or promoted.\n  };\n\n  /// LegalizeKind holds the legalization kind that needs to happen to EVT\n  /// in order to type-legalize it.\n  using LegalizeKind = std::pair<LegalizeTypeAction, EVT>;\n\n  /// Enum that describes how the target represents true/false values.\n  enum BooleanContent {\n    UndefinedBooleanContent,    // Only bit 0 counts, the rest can hold garbage.\n    ZeroOrOneBooleanContent,        // All bits zero except for bit 0.\n    ZeroOrNegativeOneBooleanContent // All bits equal to bit 0.\n  };\n\n  /// Enum that describes what type of support for selects the target has.\n  enum SelectSupportKind {\n    ScalarValSelect,      // The target supports scalar selects (ex: cmov).\n    ScalarCondVectorVal,  // The target supports selects with a scalar condition\n                          // and vector values (ex: cmov).\n    VectorMaskSelect      // The target supports vector selects with a vector\n                          // mask (ex: x86 blends).\n  };\n\n  /// Enum that specifies what an atomic load/AtomicRMWInst is expanded\n  /// to, if at all. Exists because different targets have different levels of\n  /// support for these atomic instructions, and also have different options\n  /// w.r.t. what they should expand to.\n  enum class AtomicExpansionKind {\n    None,    // Don't expand the instruction.\n    LLSC,    // Expand the instruction into loadlinked/storeconditional; used\n             // by ARM/AArch64.\n    LLOnly,  // Expand the (load) instruction into just a load-linked, which has\n             // greater atomic guarantees than a normal load.\n    CmpXChg, // Expand the instruction into cmpxchg; used by at least X86.\n    MaskedIntrinsic, // Use a target-specific intrinsic for the LL/SC loop.\n  };\n\n  /// Enum that specifies when a multiplication should be expanded.\n  enum class MulExpansionKind {\n    Always,            // Always expand the instruction.\n    OnlyLegalOrCustom, // Only expand when the resulting instructions are legal\n                       // or custom.\n  };\n\n  /// Enum that specifies when a float negation is beneficial.\n  enum class NegatibleCost {\n    Cheaper = 0,    // Negated expression is cheaper.\n    Neutral = 1,    // Negated expression has the same cost.\n    Expensive = 2   // Negated expression is more expensive.\n  };\n\n  class ArgListEntry {\n  public:\n    Value *Val = nullptr;\n    SDValue Node = SDValue();\n    Type *Ty = nullptr;\n    bool IsSExt : 1;\n    bool IsZExt : 1;\n    bool IsInReg : 1;\n    bool IsSRet : 1;\n    bool IsNest : 1;\n    bool IsByVal : 1;\n    bool IsByRef : 1;\n    bool IsInAlloca : 1;\n    bool IsPreallocated : 1;\n    bool IsReturned : 1;\n    bool IsSwiftSelf : 1;\n    bool IsSwiftError : 1;\n    bool IsCFGuardTarget : 1;\n    MaybeAlign Alignment = None;\n    Type *ByValType = nullptr;\n    Type *PreallocatedType = nullptr;\n\n    ArgListEntry()\n        : IsSExt(false), IsZExt(false), IsInReg(false), IsSRet(false),\n          IsNest(false), IsByVal(false), IsByRef(false), IsInAlloca(false),\n          IsPreallocated(false), IsReturned(false), IsSwiftSelf(false),\n          IsSwiftError(false), IsCFGuardTarget(false) {}\n\n    void setAttributes(const CallBase *Call, unsigned ArgIdx);\n  };\n  using ArgListTy = std::vector<ArgListEntry>;\n\n  virtual void markLibCallAttributes(MachineFunction *MF, unsigned CC,\n                                     ArgListTy &Args) const {};\n\n  static ISD::NodeType getExtendForContent(BooleanContent Content) {\n    switch (Content) {\n    case UndefinedBooleanContent:\n      // Extend by adding rubbish bits.\n      return ISD::ANY_EXTEND;\n    case ZeroOrOneBooleanContent:\n      // Extend by adding zero bits.\n      return ISD::ZERO_EXTEND;\n    case ZeroOrNegativeOneBooleanContent:\n      // Extend by copying the sign bit.\n      return ISD::SIGN_EXTEND;\n    }\n    llvm_unreachable(\"Invalid content kind\");\n  }\n\n  explicit TargetLoweringBase(const TargetMachine &TM);\n  TargetLoweringBase(const TargetLoweringBase &) = delete;\n  TargetLoweringBase &operator=(const TargetLoweringBase &) = delete;\n  virtual ~TargetLoweringBase() = default;\n\n  /// Return true if the target support strict float operation\n  bool isStrictFPEnabled() const {\n    return IsStrictFPEnabled;\n  }\n\nprotected:\n  /// Initialize all of the actions to default values.\n  void initActions();\n\npublic:\n  const TargetMachine &getTargetMachine() const { return TM; }\n\n  virtual bool useSoftFloat() const { return false; }\n\n  /// Return the pointer type for the given address space, defaults to\n  /// the pointer type from the data layout.\n  /// FIXME: The default needs to be removed once all the code is updated.\n  virtual MVT getPointerTy(const DataLayout &DL, uint32_t AS = 0) const {\n    return MVT::getIntegerVT(DL.getPointerSizeInBits(AS));\n  }\n\n  /// Return the in-memory pointer type for the given address space, defaults to\n  /// the pointer type from the data layout.  FIXME: The default needs to be\n  /// removed once all the code is updated.\n  MVT getPointerMemTy(const DataLayout &DL, uint32_t AS = 0) const {\n    return MVT::getIntegerVT(DL.getPointerSizeInBits(AS));\n  }\n\n  /// Return the type for frame index, which is determined by\n  /// the alloca address space specified through the data layout.\n  MVT getFrameIndexTy(const DataLayout &DL) const {\n    return getPointerTy(DL, DL.getAllocaAddrSpace());\n  }\n\n  /// Return the type for code pointers, which is determined by the program\n  /// address space specified through the data layout.\n  MVT getProgramPointerTy(const DataLayout &DL) const {\n    return getPointerTy(DL, DL.getProgramAddressSpace());\n  }\n\n  /// Return the type for operands of fence.\n  /// TODO: Let fence operands be of i32 type and remove this.\n  virtual MVT getFenceOperandTy(const DataLayout &DL) const {\n    return getPointerTy(DL);\n  }\n\n  /// EVT is not used in-tree, but is used by out-of-tree target.\n  /// A documentation for this function would be nice...\n  virtual MVT getScalarShiftAmountTy(const DataLayout &, EVT) const;\n\n  EVT getShiftAmountTy(EVT LHSTy, const DataLayout &DL,\n                       bool LegalTypes = true) const;\n\n  /// Return the preferred type to use for a shift opcode, given the shifted\n  /// amount type is \\p ShiftValueTy.\n  LLVM_READONLY\n  virtual LLT getPreferredShiftAmountTy(LLT ShiftValueTy) const {\n    return ShiftValueTy;\n  }\n\n  /// Returns the type to be used for the index operand of:\n  /// ISD::INSERT_VECTOR_ELT, ISD::EXTRACT_VECTOR_ELT,\n  /// ISD::INSERT_SUBVECTOR, and ISD::EXTRACT_SUBVECTOR\n  virtual MVT getVectorIdxTy(const DataLayout &DL) const {\n    return getPointerTy(DL);\n  }\n\n  /// This callback is used to inspect load/store instructions and add\n  /// target-specific MachineMemOperand flags to them.  The default\n  /// implementation does nothing.\n  virtual MachineMemOperand::Flags getTargetMMOFlags(const Instruction &I) const {\n    return MachineMemOperand::MONone;\n  }\n\n  MachineMemOperand::Flags getLoadMemOperandFlags(const LoadInst &LI,\n                                                  const DataLayout &DL) const;\n  MachineMemOperand::Flags getStoreMemOperandFlags(const StoreInst &SI,\n                                                   const DataLayout &DL) const;\n  MachineMemOperand::Flags getAtomicMemOperandFlags(const Instruction &AI,\n                                                    const DataLayout &DL) const;\n\n  virtual bool isSelectSupported(SelectSupportKind /*kind*/) const {\n    return true;\n  }\n\n  /// Return true if it is profitable to convert a select of FP constants into\n  /// a constant pool load whose address depends on the select condition. The\n  /// parameter may be used to differentiate a select with FP compare from\n  /// integer compare.\n  virtual bool reduceSelectOfFPConstantLoads(EVT CmpOpVT) const {\n    return true;\n  }\n\n  /// Return true if multiple condition registers are available.\n  bool hasMultipleConditionRegisters() const {\n    return HasMultipleConditionRegisters;\n  }\n\n  /// Return true if the target has BitExtract instructions.\n  bool hasExtractBitsInsn() const { return HasExtractBitsInsn; }\n\n  /// Return the preferred vector type legalization action.\n  virtual TargetLoweringBase::LegalizeTypeAction\n  getPreferredVectorAction(MVT VT) const {\n    // The default action for one element vectors is to scalarize\n    if (VT.getVectorElementCount().isScalar())\n      return TypeScalarizeVector;\n    // The default action for an odd-width vector is to widen.\n    if (!VT.isPow2VectorType())\n      return TypeWidenVector;\n    // The default action for other vectors is to promote\n    return TypePromoteInteger;\n  }\n\n  // Return true if the half type should be passed around as i16, but promoted\n  // to float around arithmetic. The default behavior is to pass around as\n  // float and convert around loads/stores/bitcasts and other places where\n  // the size matters.\n  virtual bool softPromoteHalfType() const { return false; }\n\n  // There are two general methods for expanding a BUILD_VECTOR node:\n  //  1. Use SCALAR_TO_VECTOR on the defined scalar values and then shuffle\n  //     them together.\n  //  2. Build the vector on the stack and then load it.\n  // If this function returns true, then method (1) will be used, subject to\n  // the constraint that all of the necessary shuffles are legal (as determined\n  // by isShuffleMaskLegal). If this function returns false, then method (2) is\n  // always used. The vector type, and the number of defined values, are\n  // provided.\n  virtual bool\n  shouldExpandBuildVectorWithShuffles(EVT /* VT */,\n                                      unsigned DefinedValues) const {\n    return DefinedValues < 3;\n  }\n\n  /// Return true if integer divide is usually cheaper than a sequence of\n  /// several shifts, adds, and multiplies for this target.\n  /// The definition of \"cheaper\" may depend on whether we're optimizing\n  /// for speed or for size.\n  virtual bool isIntDivCheap(EVT VT, AttributeList Attr) const { return false; }\n\n  /// Return true if the target can handle a standalone remainder operation.\n  virtual bool hasStandaloneRem(EVT VT) const {\n    return true;\n  }\n\n  /// Return true if SQRT(X) shouldn't be replaced with X*RSQRT(X).\n  virtual bool isFsqrtCheap(SDValue X, SelectionDAG &DAG) const {\n    // Default behavior is to replace SQRT(X) with X*RSQRT(X).\n    return false;\n  }\n\n  /// Reciprocal estimate status values used by the functions below.\n  enum ReciprocalEstimate : int {\n    Unspecified = -1,\n    Disabled = 0,\n    Enabled = 1\n  };\n\n  /// Return a ReciprocalEstimate enum value for a square root of the given type\n  /// based on the function's attributes. If the operation is not overridden by\n  /// the function's attributes, \"Unspecified\" is returned and target defaults\n  /// are expected to be used for instruction selection.\n  int getRecipEstimateSqrtEnabled(EVT VT, MachineFunction &MF) const;\n\n  /// Return a ReciprocalEstimate enum value for a division of the given type\n  /// based on the function's attributes. If the operation is not overridden by\n  /// the function's attributes, \"Unspecified\" is returned and target defaults\n  /// are expected to be used for instruction selection.\n  int getRecipEstimateDivEnabled(EVT VT, MachineFunction &MF) const;\n\n  /// Return the refinement step count for a square root of the given type based\n  /// on the function's attributes. If the operation is not overridden by\n  /// the function's attributes, \"Unspecified\" is returned and target defaults\n  /// are expected to be used for instruction selection.\n  int getSqrtRefinementSteps(EVT VT, MachineFunction &MF) const;\n\n  /// Return the refinement step count for a division of the given type based\n  /// on the function's attributes. If the operation is not overridden by\n  /// the function's attributes, \"Unspecified\" is returned and target defaults\n  /// are expected to be used for instruction selection.\n  int getDivRefinementSteps(EVT VT, MachineFunction &MF) const;\n\n  /// Returns true if target has indicated at least one type should be bypassed.\n  bool isSlowDivBypassed() const { return !BypassSlowDivWidths.empty(); }\n\n  /// Returns map of slow types for division or remainder with corresponding\n  /// fast types\n  const DenseMap<unsigned int, unsigned int> &getBypassSlowDivWidths() const {\n    return BypassSlowDivWidths;\n  }\n\n  /// Return true if Flow Control is an expensive operation that should be\n  /// avoided.\n  bool isJumpExpensive() const { return JumpIsExpensive; }\n\n  /// Return true if selects are only cheaper than branches if the branch is\n  /// unlikely to be predicted right.\n  bool isPredictableSelectExpensive() const {\n    return PredictableSelectIsExpensive;\n  }\n\n  virtual bool fallBackToDAGISel(const Instruction &Inst) const {\n    return false;\n  }\n\n  /// If a branch or a select condition is skewed in one direction by more than\n  /// this factor, it is very likely to be predicted correctly.\n  virtual BranchProbability getPredictableBranchThreshold() const;\n\n  /// Return true if the following transform is beneficial:\n  /// fold (conv (load x)) -> (load (conv*)x)\n  /// On architectures that don't natively support some vector loads\n  /// efficiently, casting the load to a smaller vector of larger types and\n  /// loading is more efficient, however, this can be undone by optimizations in\n  /// dag combiner.\n  virtual bool isLoadBitCastBeneficial(EVT LoadVT, EVT BitcastVT,\n                                       const SelectionDAG &DAG,\n                                       const MachineMemOperand &MMO) const {\n    // Don't do if we could do an indexed load on the original type, but not on\n    // the new one.\n    if (!LoadVT.isSimple() || !BitcastVT.isSimple())\n      return true;\n\n    MVT LoadMVT = LoadVT.getSimpleVT();\n\n    // Don't bother doing this if it's just going to be promoted again later, as\n    // doing so might interfere with other combines.\n    if (getOperationAction(ISD::LOAD, LoadMVT) == Promote &&\n        getTypeToPromoteTo(ISD::LOAD, LoadMVT) == BitcastVT.getSimpleVT())\n      return false;\n\n    bool Fast = false;\n    return allowsMemoryAccess(*DAG.getContext(), DAG.getDataLayout(), BitcastVT,\n                              MMO, &Fast) && Fast;\n  }\n\n  /// Return true if the following transform is beneficial:\n  /// (store (y (conv x)), y*)) -> (store x, (x*))\n  virtual bool isStoreBitCastBeneficial(EVT StoreVT, EVT BitcastVT,\n                                        const SelectionDAG &DAG,\n                                        const MachineMemOperand &MMO) const {\n    // Default to the same logic as loads.\n    return isLoadBitCastBeneficial(StoreVT, BitcastVT, DAG, MMO);\n  }\n\n  /// Return true if it is expected to be cheaper to do a store of a non-zero\n  /// vector constant with the given size and type for the address space than to\n  /// store the individual scalar element constants.\n  virtual bool storeOfVectorConstantIsCheap(EVT MemVT,\n                                            unsigned NumElem,\n                                            unsigned AddrSpace) const {\n    return false;\n  }\n\n  /// Allow store merging for the specified type after legalization in addition\n  /// to before legalization. This may transform stores that do not exist\n  /// earlier (for example, stores created from intrinsics).\n  virtual bool mergeStoresAfterLegalization(EVT MemVT) const {\n    return true;\n  }\n\n  /// Returns if it's reasonable to merge stores to MemVT size.\n  virtual bool canMergeStoresTo(unsigned AS, EVT MemVT,\n                                const SelectionDAG &DAG) const {\n    return true;\n  }\n\n  /// Return true if it is cheap to speculate a call to intrinsic cttz.\n  virtual bool isCheapToSpeculateCttz() const {\n    return false;\n  }\n\n  /// Return true if it is cheap to speculate a call to intrinsic ctlz.\n  virtual bool isCheapToSpeculateCtlz() const {\n    return false;\n  }\n\n  /// Return true if ctlz instruction is fast.\n  virtual bool isCtlzFast() const {\n    return false;\n  }\n\n  /// Return the maximum number of \"x & (x - 1)\" operations that can be done\n  /// instead of deferring to a custom CTPOP.\n  virtual unsigned getCustomCtpopCost(EVT VT, ISD::CondCode Cond) const {\n    return 1;\n  }\n\n  /// Return true if instruction generated for equality comparison is folded\n  /// with instruction generated for signed comparison.\n  virtual bool isEqualityCmpFoldedWithSignedCmp() const { return true; }\n\n  /// Return true if it is safe to transform an integer-domain bitwise operation\n  /// into the equivalent floating-point operation. This should be set to true\n  /// if the target has IEEE-754-compliant fabs/fneg operations for the input\n  /// type.\n  virtual bool hasBitPreservingFPLogic(EVT VT) const {\n    return false;\n  }\n\n  /// Return true if it is cheaper to split the store of a merged int val\n  /// from a pair of smaller values into multiple stores.\n  virtual bool isMultiStoresCheaperThanBitsMerge(EVT LTy, EVT HTy) const {\n    return false;\n  }\n\n  /// Return if the target supports combining a\n  /// chain like:\n  /// \\code\n  ///   %andResult = and %val1, #mask\n  ///   %icmpResult = icmp %andResult, 0\n  /// \\endcode\n  /// into a single machine instruction of a form like:\n  /// \\code\n  ///   cc = test %register, #mask\n  /// \\endcode\n  virtual bool isMaskAndCmp0FoldingBeneficial(const Instruction &AndI) const {\n    return false;\n  }\n\n  /// Use bitwise logic to make pairs of compares more efficient. For example:\n  /// and (seteq A, B), (seteq C, D) --> seteq (or (xor A, B), (xor C, D)), 0\n  /// This should be true when it takes more than one instruction to lower\n  /// setcc (cmp+set on x86 scalar), when bitwise ops are faster than logic on\n  /// condition bits (crand on PowerPC), and/or when reducing cmp+br is a win.\n  virtual bool convertSetCCLogicToBitwiseLogic(EVT VT) const {\n    return false;\n  }\n\n  /// Return the preferred operand type if the target has a quick way to compare\n  /// integer values of the given size. Assume that any legal integer type can\n  /// be compared efficiently. Targets may override this to allow illegal wide\n  /// types to return a vector type if there is support to compare that type.\n  virtual MVT hasFastEqualityCompare(unsigned NumBits) const {\n    MVT VT = MVT::getIntegerVT(NumBits);\n    return isTypeLegal(VT) ? VT : MVT::INVALID_SIMPLE_VALUE_TYPE;\n  }\n\n  /// Return true if the target should transform:\n  /// (X & Y) == Y ---> (~X & Y) == 0\n  /// (X & Y) != Y ---> (~X & Y) != 0\n  ///\n  /// This may be profitable if the target has a bitwise and-not operation that\n  /// sets comparison flags. A target may want to limit the transformation based\n  /// on the type of Y or if Y is a constant.\n  ///\n  /// Note that the transform will not occur if Y is known to be a power-of-2\n  /// because a mask and compare of a single bit can be handled by inverting the\n  /// predicate, for example:\n  /// (X & 8) == 8 ---> (X & 8) != 0\n  virtual bool hasAndNotCompare(SDValue Y) const {\n    return false;\n  }\n\n  /// Return true if the target has a bitwise and-not operation:\n  /// X = ~A & B\n  /// This can be used to simplify select or other instructions.\n  virtual bool hasAndNot(SDValue X) const {\n    // If the target has the more complex version of this operation, assume that\n    // it has this operation too.\n    return hasAndNotCompare(X);\n  }\n\n  /// Return true if the target has a bit-test instruction:\n  ///   (X & (1 << Y)) ==/!= 0\n  /// This knowledge can be used to prevent breaking the pattern,\n  /// or creating it if it could be recognized.\n  virtual bool hasBitTest(SDValue X, SDValue Y) const { return false; }\n\n  /// There are two ways to clear extreme bits (either low or high):\n  /// Mask:    x &  (-1 << y)  (the instcombine canonical form)\n  /// Shifts:  x >> y << y\n  /// Return true if the variant with 2 variable shifts is preferred.\n  /// Return false if there is no preference.\n  virtual bool shouldFoldMaskToVariableShiftPair(SDValue X) const {\n    // By default, let's assume that no one prefers shifts.\n    return false;\n  }\n\n  /// Return true if it is profitable to fold a pair of shifts into a mask.\n  /// This is usually true on most targets. But some targets, like Thumb1,\n  /// have immediate shift instructions, but no immediate \"and\" instruction;\n  /// this makes the fold unprofitable.\n  virtual bool shouldFoldConstantShiftPairToMask(const SDNode *N,\n                                                 CombineLevel Level) const {\n    return true;\n  }\n\n  /// Should we tranform the IR-optimal check for whether given truncation\n  /// down into KeptBits would be truncating or not:\n  ///   (add %x, (1 << (KeptBits-1))) srccond (1 << KeptBits)\n  /// Into it's more traditional form:\n  ///   ((%x << C) a>> C) dstcond %x\n  /// Return true if we should transform.\n  /// Return false if there is no preference.\n  virtual bool shouldTransformSignedTruncationCheck(EVT XVT,\n                                                    unsigned KeptBits) const {\n    // By default, let's assume that no one prefers shifts.\n    return false;\n  }\n\n  /// Given the pattern\n  ///   (X & (C l>>/<< Y)) ==/!= 0\n  /// return true if it should be transformed into:\n  ///   ((X <</l>> Y) & C) ==/!= 0\n  /// WARNING: if 'X' is a constant, the fold may deadlock!\n  /// FIXME: we could avoid passing XC, but we can't use isConstOrConstSplat()\n  ///        here because it can end up being not linked in.\n  virtual bool shouldProduceAndByConstByHoistingConstFromShiftsLHSOfAnd(\n      SDValue X, ConstantSDNode *XC, ConstantSDNode *CC, SDValue Y,\n      unsigned OldShiftOpcode, unsigned NewShiftOpcode,\n      SelectionDAG &DAG) const {\n    if (hasBitTest(X, Y)) {\n      // One interesting pattern that we'd want to form is 'bit test':\n      //   ((1 << Y) & C) ==/!= 0\n      // But we also need to be careful not to try to reverse that fold.\n\n      // Is this '1 << Y' ?\n      if (OldShiftOpcode == ISD::SHL && CC->isOne())\n        return false; // Keep the 'bit test' pattern.\n\n      // Will it be '1 << Y' after the transform ?\n      if (XC && NewShiftOpcode == ISD::SHL && XC->isOne())\n        return true; // Do form the 'bit test' pattern.\n    }\n\n    // If 'X' is a constant, and we transform, then we will immediately\n    // try to undo the fold, thus causing endless combine loop.\n    // So by default, let's assume everyone prefers the fold\n    // iff 'X' is not a constant.\n    return !XC;\n  }\n\n  /// These two forms are equivalent:\n  ///   sub %y, (xor %x, -1)\n  ///   add (add %x, 1), %y\n  /// The variant with two add's is IR-canonical.\n  /// Some targets may prefer one to the other.\n  virtual bool preferIncOfAddToSubOfNot(EVT VT) const {\n    // By default, let's assume that everyone prefers the form with two add's.\n    return true;\n  }\n\n  /// Return true if the target wants to use the optimization that\n  /// turns ext(promotableInst1(...(promotableInstN(load)))) into\n  /// promotedInst1(...(promotedInstN(ext(load)))).\n  bool enableExtLdPromotion() const { return EnableExtLdPromotion; }\n\n  /// Return true if the target can combine store(extractelement VectorTy,\n  /// Idx).\n  /// \\p Cost[out] gives the cost of that transformation when this is true.\n  virtual bool canCombineStoreAndExtract(Type *VectorTy, Value *Idx,\n                                         unsigned &Cost) const {\n    return false;\n  }\n\n  /// Return true if inserting a scalar into a variable element of an undef\n  /// vector is more efficiently handled by splatting the scalar instead.\n  virtual bool shouldSplatInsEltVarIndex(EVT) const {\n    return false;\n  }\n\n  /// Return true if target always beneficiates from combining into FMA for a\n  /// given value type. This must typically return false on targets where FMA\n  /// takes more cycles to execute than FADD.\n  virtual bool enableAggressiveFMAFusion(EVT VT) const {\n    return false;\n  }\n\n  /// Return the ValueType of the result of SETCC operations.\n  virtual EVT getSetCCResultType(const DataLayout &DL, LLVMContext &Context,\n                                 EVT VT) const;\n\n  /// Return the ValueType for comparison libcalls. Comparions libcalls include\n  /// floating point comparion calls, and Ordered/Unordered check calls on\n  /// floating point numbers.\n  virtual\n  MVT::SimpleValueType getCmpLibcallReturnType() const;\n\n  /// For targets without i1 registers, this gives the nature of the high-bits\n  /// of boolean values held in types wider than i1.\n  ///\n  /// \"Boolean values\" are special true/false values produced by nodes like\n  /// SETCC and consumed (as the condition) by nodes like SELECT and BRCOND.\n  /// Not to be confused with general values promoted from i1.  Some cpus\n  /// distinguish between vectors of boolean and scalars; the isVec parameter\n  /// selects between the two kinds.  For example on X86 a scalar boolean should\n  /// be zero extended from i1, while the elements of a vector of booleans\n  /// should be sign extended from i1.\n  ///\n  /// Some cpus also treat floating point types the same way as they treat\n  /// vectors instead of the way they treat scalars.\n  BooleanContent getBooleanContents(bool isVec, bool isFloat) const {\n    if (isVec)\n      return BooleanVectorContents;\n    return isFloat ? BooleanFloatContents : BooleanContents;\n  }\n\n  BooleanContent getBooleanContents(EVT Type) const {\n    return getBooleanContents(Type.isVector(), Type.isFloatingPoint());\n  }\n\n  /// Return target scheduling preference.\n  Sched::Preference getSchedulingPreference() const {\n    return SchedPreferenceInfo;\n  }\n\n  /// Some scheduler, e.g. hybrid, can switch to different scheduling heuristics\n  /// for different nodes. This function returns the preference (or none) for\n  /// the given node.\n  virtual Sched::Preference getSchedulingPreference(SDNode *) const {\n    return Sched::None;\n  }\n\n  /// Return the register class that should be used for the specified value\n  /// type.\n  virtual const TargetRegisterClass *getRegClassFor(MVT VT, bool isDivergent = false) const {\n    (void)isDivergent;\n    const TargetRegisterClass *RC = RegClassForVT[VT.SimpleTy];\n    assert(RC && \"This value type is not natively supported!\");\n    return RC;\n  }\n\n  /// Allows target to decide about the register class of the\n  /// specific value that is live outside the defining block.\n  /// Returns true if the value needs uniform register class.\n  virtual bool requiresUniformRegister(MachineFunction &MF,\n                                       const Value *) const {\n    return false;\n  }\n\n  /// Return the 'representative' register class for the specified value\n  /// type.\n  ///\n  /// The 'representative' register class is the largest legal super-reg\n  /// register class for the register class of the value type.  For example, on\n  /// i386 the rep register class for i8, i16, and i32 are GR32; while the rep\n  /// register class is GR64 on x86_64.\n  virtual const TargetRegisterClass *getRepRegClassFor(MVT VT) const {\n    const TargetRegisterClass *RC = RepRegClassForVT[VT.SimpleTy];\n    return RC;\n  }\n\n  /// Return the cost of the 'representative' register class for the specified\n  /// value type.\n  virtual uint8_t getRepRegClassCostFor(MVT VT) const {\n    return RepRegClassCostForVT[VT.SimpleTy];\n  }\n\n  /// Return true if SHIFT instructions should be expanded to SHIFT_PARTS\n  /// instructions, and false if a library call is preferred (e.g for code-size\n  /// reasons).\n  virtual bool shouldExpandShift(SelectionDAG &DAG, SDNode *N) const {\n    return true;\n  }\n\n  /// Return true if the target has native support for the specified value type.\n  /// This means that it has a register that directly holds it without\n  /// promotions or expansions.\n  bool isTypeLegal(EVT VT) const {\n    assert(!VT.isSimple() ||\n           (unsigned)VT.getSimpleVT().SimpleTy < array_lengthof(RegClassForVT));\n    return VT.isSimple() && RegClassForVT[VT.getSimpleVT().SimpleTy] != nullptr;\n  }\n\n  class ValueTypeActionImpl {\n    /// ValueTypeActions - For each value type, keep a LegalizeTypeAction enum\n    /// that indicates how instruction selection should deal with the type.\n    LegalizeTypeAction ValueTypeActions[MVT::LAST_VALUETYPE];\n\n  public:\n    ValueTypeActionImpl() {\n      std::fill(std::begin(ValueTypeActions), std::end(ValueTypeActions),\n                TypeLegal);\n    }\n\n    LegalizeTypeAction getTypeAction(MVT VT) const {\n      return ValueTypeActions[VT.SimpleTy];\n    }\n\n    void setTypeAction(MVT VT, LegalizeTypeAction Action) {\n      ValueTypeActions[VT.SimpleTy] = Action;\n    }\n  };\n\n  const ValueTypeActionImpl &getValueTypeActions() const {\n    return ValueTypeActions;\n  }\n\n  /// Return how we should legalize values of this type, either it is already\n  /// legal (return 'Legal') or we need to promote it to a larger type (return\n  /// 'Promote'), or we need to expand it into multiple registers of smaller\n  /// integer type (return 'Expand').  'Custom' is not an option.\n  LegalizeTypeAction getTypeAction(LLVMContext &Context, EVT VT) const {\n    return getTypeConversion(Context, VT).first;\n  }\n  LegalizeTypeAction getTypeAction(MVT VT) const {\n    return ValueTypeActions.getTypeAction(VT);\n  }\n\n  /// For types supported by the target, this is an identity function.  For\n  /// types that must be promoted to larger types, this returns the larger type\n  /// to promote to.  For integer types that are larger than the largest integer\n  /// register, this contains one step in the expansion to get to the smaller\n  /// register. For illegal floating point types, this returns the integer type\n  /// to transform to.\n  EVT getTypeToTransformTo(LLVMContext &Context, EVT VT) const {\n    return getTypeConversion(Context, VT).second;\n  }\n\n  /// For types supported by the target, this is an identity function.  For\n  /// types that must be expanded (i.e. integer types that are larger than the\n  /// largest integer register or illegal floating point types), this returns\n  /// the largest legal type it will be expanded to.\n  EVT getTypeToExpandTo(LLVMContext &Context, EVT VT) const {\n    assert(!VT.isVector());\n    while (true) {\n      switch (getTypeAction(Context, VT)) {\n      case TypeLegal:\n        return VT;\n      case TypeExpandInteger:\n        VT = getTypeToTransformTo(Context, VT);\n        break;\n      default:\n        llvm_unreachable(\"Type is not legal nor is it to be expanded!\");\n      }\n    }\n  }\n\n  /// Vector types are broken down into some number of legal first class types.\n  /// For example, EVT::v8f32 maps to 2 EVT::v4f32 with Altivec or SSE1, or 8\n  /// promoted EVT::f64 values with the X86 FP stack.  Similarly, EVT::v2i64\n  /// turns into 4 EVT::i32 values with both PPC and X86.\n  ///\n  /// This method returns the number of registers needed, and the VT for each\n  /// register.  It also returns the VT and quantity of the intermediate values\n  /// before they are promoted/expanded.\n  unsigned getVectorTypeBreakdown(LLVMContext &Context, EVT VT,\n                                  EVT &IntermediateVT,\n                                  unsigned &NumIntermediates,\n                                  MVT &RegisterVT) const;\n\n  /// Certain targets such as MIPS require that some types such as vectors are\n  /// always broken down into scalars in some contexts. This occurs even if the\n  /// vector type is legal.\n  virtual unsigned getVectorTypeBreakdownForCallingConv(\n      LLVMContext &Context, CallingConv::ID CC, EVT VT, EVT &IntermediateVT,\n      unsigned &NumIntermediates, MVT &RegisterVT) const {\n    return getVectorTypeBreakdown(Context, VT, IntermediateVT, NumIntermediates,\n                                  RegisterVT);\n  }\n\n  struct IntrinsicInfo {\n    unsigned     opc = 0;          // target opcode\n    EVT          memVT;            // memory VT\n\n    // value representing memory location\n    PointerUnion<const Value *, const PseudoSourceValue *> ptrVal;\n\n    int          offset = 0;       // offset off of ptrVal\n    uint64_t     size = 0;         // the size of the memory location\n                                   // (taken from memVT if zero)\n    MaybeAlign align = Align(1);   // alignment\n\n    MachineMemOperand::Flags flags = MachineMemOperand::MONone;\n    IntrinsicInfo() = default;\n  };\n\n  /// Given an intrinsic, checks if on the target the intrinsic will need to map\n  /// to a MemIntrinsicNode (touches memory). If this is the case, it returns\n  /// true and store the intrinsic information into the IntrinsicInfo that was\n  /// passed to the function.\n  virtual bool getTgtMemIntrinsic(IntrinsicInfo &, const CallInst &,\n                                  MachineFunction &,\n                                  unsigned /*Intrinsic*/) const {\n    return false;\n  }\n\n  /// Returns true if the target can instruction select the specified FP\n  /// immediate natively. If false, the legalizer will materialize the FP\n  /// immediate as a load from a constant pool.\n  virtual bool isFPImmLegal(const APFloat & /*Imm*/, EVT /*VT*/,\n                            bool ForCodeSize = false) const {\n    return false;\n  }\n\n  /// Targets can use this to indicate that they only support *some*\n  /// VECTOR_SHUFFLE operations, those with specific masks.  By default, if a\n  /// target supports the VECTOR_SHUFFLE node, all mask values are assumed to be\n  /// legal.\n  virtual bool isShuffleMaskLegal(ArrayRef<int> /*Mask*/, EVT /*VT*/) const {\n    return true;\n  }\n\n  /// Returns true if the operation can trap for the value type.\n  ///\n  /// VT must be a legal type. By default, we optimistically assume most\n  /// operations don't trap except for integer divide and remainder.\n  virtual bool canOpTrap(unsigned Op, EVT VT) const;\n\n  /// Similar to isShuffleMaskLegal. Targets can use this to indicate if there\n  /// is a suitable VECTOR_SHUFFLE that can be used to replace a VAND with a\n  /// constant pool entry.\n  virtual bool isVectorClearMaskLegal(ArrayRef<int> /*Mask*/,\n                                      EVT /*VT*/) const {\n    return false;\n  }\n\n  /// Return how this operation should be treated: either it is legal, needs to\n  /// be promoted to a larger size, needs to be expanded to some other code\n  /// sequence, or the target has a custom expander for it.\n  LegalizeAction getOperationAction(unsigned Op, EVT VT) const {\n    if (VT.isExtended()) return Expand;\n    // If a target-specific SDNode requires legalization, require the target\n    // to provide custom legalization for it.\n    if (Op >= array_lengthof(OpActions[0])) return Custom;\n    return OpActions[(unsigned)VT.getSimpleVT().SimpleTy][Op];\n  }\n\n  /// Custom method defined by each target to indicate if an operation which\n  /// may require a scale is supported natively by the target.\n  /// If not, the operation is illegal.\n  virtual bool isSupportedFixedPointOperation(unsigned Op, EVT VT,\n                                              unsigned Scale) const {\n    return false;\n  }\n\n  /// Some fixed point operations may be natively supported by the target but\n  /// only for specific scales. This method allows for checking\n  /// if the width is supported by the target for a given operation that may\n  /// depend on scale.\n  LegalizeAction getFixedPointOperationAction(unsigned Op, EVT VT,\n                                              unsigned Scale) const {\n    auto Action = getOperationAction(Op, VT);\n    if (Action != Legal)\n      return Action;\n\n    // This operation is supported in this type but may only work on specific\n    // scales.\n    bool Supported;\n    switch (Op) {\n    default:\n      llvm_unreachable(\"Unexpected fixed point operation.\");\n    case ISD::SMULFIX:\n    case ISD::SMULFIXSAT:\n    case ISD::UMULFIX:\n    case ISD::UMULFIXSAT:\n    case ISD::SDIVFIX:\n    case ISD::SDIVFIXSAT:\n    case ISD::UDIVFIX:\n    case ISD::UDIVFIXSAT:\n      Supported = isSupportedFixedPointOperation(Op, VT, Scale);\n      break;\n    }\n\n    return Supported ? Action : Expand;\n  }\n\n  // If Op is a strict floating-point operation, return the result\n  // of getOperationAction for the equivalent non-strict operation.\n  LegalizeAction getStrictFPOperationAction(unsigned Op, EVT VT) const {\n    unsigned EqOpc;\n    switch (Op) {\n      default: llvm_unreachable(\"Unexpected FP pseudo-opcode\");\n#define DAG_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \\\n      case ISD::STRICT_##DAGN: EqOpc = ISD::DAGN; break;\n#define CMP_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \\\n      case ISD::STRICT_##DAGN: EqOpc = ISD::SETCC; break;\n#include \"llvm/IR/ConstrainedOps.def\"\n    }\n\n    return getOperationAction(EqOpc, VT);\n  }\n\n  /// Return true if the specified operation is legal on this target or can be\n  /// made legal with custom lowering. This is used to help guide high-level\n  /// lowering decisions. LegalOnly is an optional convenience for code paths\n  /// traversed pre and post legalisation.\n  bool isOperationLegalOrCustom(unsigned Op, EVT VT,\n                                bool LegalOnly = false) const {\n    if (LegalOnly)\n      return isOperationLegal(Op, VT);\n\n    return (VT == MVT::Other || isTypeLegal(VT)) &&\n      (getOperationAction(Op, VT) == Legal ||\n       getOperationAction(Op, VT) == Custom);\n  }\n\n  /// Return true if the specified operation is legal on this target or can be\n  /// made legal using promotion. This is used to help guide high-level lowering\n  /// decisions. LegalOnly is an optional convenience for code paths traversed\n  /// pre and post legalisation.\n  bool isOperationLegalOrPromote(unsigned Op, EVT VT,\n                                 bool LegalOnly = false) const {\n    if (LegalOnly)\n      return isOperationLegal(Op, VT);\n\n    return (VT == MVT::Other || isTypeLegal(VT)) &&\n      (getOperationAction(Op, VT) == Legal ||\n       getOperationAction(Op, VT) == Promote);\n  }\n\n  /// Return true if the specified operation is legal on this target or can be\n  /// made legal with custom lowering or using promotion. This is used to help\n  /// guide high-level lowering decisions. LegalOnly is an optional convenience\n  /// for code paths traversed pre and post legalisation.\n  bool isOperationLegalOrCustomOrPromote(unsigned Op, EVT VT,\n                                         bool LegalOnly = false) const {\n    if (LegalOnly)\n      return isOperationLegal(Op, VT);\n\n    return (VT == MVT::Other || isTypeLegal(VT)) &&\n      (getOperationAction(Op, VT) == Legal ||\n       getOperationAction(Op, VT) == Custom ||\n       getOperationAction(Op, VT) == Promote);\n  }\n\n  /// Return true if the operation uses custom lowering, regardless of whether\n  /// the type is legal or not.\n  bool isOperationCustom(unsigned Op, EVT VT) const {\n    return getOperationAction(Op, VT) == Custom;\n  }\n\n  /// Return true if lowering to a jump table is allowed.\n  virtual bool areJTsAllowed(const Function *Fn) const {\n    if (Fn->getFnAttribute(\"no-jump-tables\").getValueAsString() == \"true\")\n      return false;\n\n    return isOperationLegalOrCustom(ISD::BR_JT, MVT::Other) ||\n           isOperationLegalOrCustom(ISD::BRIND, MVT::Other);\n  }\n\n  /// Check whether the range [Low,High] fits in a machine word.\n  bool rangeFitsInWord(const APInt &Low, const APInt &High,\n                       const DataLayout &DL) const {\n    // FIXME: Using the pointer type doesn't seem ideal.\n    uint64_t BW = DL.getIndexSizeInBits(0u);\n    uint64_t Range = (High - Low).getLimitedValue(UINT64_MAX - 1) + 1;\n    return Range <= BW;\n  }\n\n  /// Return true if lowering to a jump table is suitable for a set of case\n  /// clusters which may contain \\p NumCases cases, \\p Range range of values.\n  virtual bool isSuitableForJumpTable(const SwitchInst *SI, uint64_t NumCases,\n                                      uint64_t Range, ProfileSummaryInfo *PSI,\n                                      BlockFrequencyInfo *BFI) const;\n\n  /// Return true if lowering to a bit test is suitable for a set of case\n  /// clusters which contains \\p NumDests unique destinations, \\p Low and\n  /// \\p High as its lowest and highest case values, and expects \\p NumCmps\n  /// case value comparisons. Check if the number of destinations, comparison\n  /// metric, and range are all suitable.\n  bool isSuitableForBitTests(unsigned NumDests, unsigned NumCmps,\n                             const APInt &Low, const APInt &High,\n                             const DataLayout &DL) const {\n    // FIXME: I don't think NumCmps is the correct metric: a single case and a\n    // range of cases both require only one branch to lower. Just looking at the\n    // number of clusters and destinations should be enough to decide whether to\n    // build bit tests.\n\n    // To lower a range with bit tests, the range must fit the bitwidth of a\n    // machine word.\n    if (!rangeFitsInWord(Low, High, DL))\n      return false;\n\n    // Decide whether it's profitable to lower this range with bit tests. Each\n    // destination requires a bit test and branch, and there is an overall range\n    // check branch. For a small number of clusters, separate comparisons might\n    // be cheaper, and for many destinations, splitting the range might be\n    // better.\n    return (NumDests == 1 && NumCmps >= 3) || (NumDests == 2 && NumCmps >= 5) ||\n           (NumDests == 3 && NumCmps >= 6);\n  }\n\n  /// Return true if the specified operation is illegal on this target or\n  /// unlikely to be made legal with custom lowering. This is used to help guide\n  /// high-level lowering decisions.\n  bool isOperationExpand(unsigned Op, EVT VT) const {\n    return (!isTypeLegal(VT) || getOperationAction(Op, VT) == Expand);\n  }\n\n  /// Return true if the specified operation is legal on this target.\n  bool isOperationLegal(unsigned Op, EVT VT) const {\n    return (VT == MVT::Other || isTypeLegal(VT)) &&\n           getOperationAction(Op, VT) == Legal;\n  }\n\n  /// Return how this load with extension should be treated: either it is legal,\n  /// needs to be promoted to a larger size, needs to be expanded to some other\n  /// code sequence, or the target has a custom expander for it.\n  LegalizeAction getLoadExtAction(unsigned ExtType, EVT ValVT,\n                                  EVT MemVT) const {\n    if (ValVT.isExtended() || MemVT.isExtended()) return Expand;\n    unsigned ValI = (unsigned) ValVT.getSimpleVT().SimpleTy;\n    unsigned MemI = (unsigned) MemVT.getSimpleVT().SimpleTy;\n    assert(ExtType < ISD::LAST_LOADEXT_TYPE && ValI < MVT::LAST_VALUETYPE &&\n           MemI < MVT::LAST_VALUETYPE && \"Table isn't big enough!\");\n    unsigned Shift = 4 * ExtType;\n    return (LegalizeAction)((LoadExtActions[ValI][MemI] >> Shift) & 0xf);\n  }\n\n  /// Return true if the specified load with extension is legal on this target.\n  bool isLoadExtLegal(unsigned ExtType, EVT ValVT, EVT MemVT) const {\n    return getLoadExtAction(ExtType, ValVT, MemVT) == Legal;\n  }\n\n  /// Return true if the specified load with extension is legal or custom\n  /// on this target.\n  bool isLoadExtLegalOrCustom(unsigned ExtType, EVT ValVT, EVT MemVT) const {\n    return getLoadExtAction(ExtType, ValVT, MemVT) == Legal ||\n           getLoadExtAction(ExtType, ValVT, MemVT) == Custom;\n  }\n\n  /// Return how this store with truncation should be treated: either it is\n  /// legal, needs to be promoted to a larger size, needs to be expanded to some\n  /// other code sequence, or the target has a custom expander for it.\n  LegalizeAction getTruncStoreAction(EVT ValVT, EVT MemVT) const {\n    if (ValVT.isExtended() || MemVT.isExtended()) return Expand;\n    unsigned ValI = (unsigned) ValVT.getSimpleVT().SimpleTy;\n    unsigned MemI = (unsigned) MemVT.getSimpleVT().SimpleTy;\n    assert(ValI < MVT::LAST_VALUETYPE && MemI < MVT::LAST_VALUETYPE &&\n           \"Table isn't big enough!\");\n    return TruncStoreActions[ValI][MemI];\n  }\n\n  /// Return true if the specified store with truncation is legal on this\n  /// target.\n  bool isTruncStoreLegal(EVT ValVT, EVT MemVT) const {\n    return isTypeLegal(ValVT) && getTruncStoreAction(ValVT, MemVT) == Legal;\n  }\n\n  /// Return true if the specified store with truncation has solution on this\n  /// target.\n  bool isTruncStoreLegalOrCustom(EVT ValVT, EVT MemVT) const {\n    return isTypeLegal(ValVT) &&\n      (getTruncStoreAction(ValVT, MemVT) == Legal ||\n       getTruncStoreAction(ValVT, MemVT) == Custom);\n  }\n\n  /// Return how the indexed load should be treated: either it is legal, needs\n  /// to be promoted to a larger size, needs to be expanded to some other code\n  /// sequence, or the target has a custom expander for it.\n  LegalizeAction getIndexedLoadAction(unsigned IdxMode, MVT VT) const {\n    return getIndexedModeAction(IdxMode, VT, IMAB_Load);\n  }\n\n  /// Return true if the specified indexed load is legal on this target.\n  bool isIndexedLoadLegal(unsigned IdxMode, EVT VT) const {\n    return VT.isSimple() &&\n      (getIndexedLoadAction(IdxMode, VT.getSimpleVT()) == Legal ||\n       getIndexedLoadAction(IdxMode, VT.getSimpleVT()) == Custom);\n  }\n\n  /// Return how the indexed store should be treated: either it is legal, needs\n  /// to be promoted to a larger size, needs to be expanded to some other code\n  /// sequence, or the target has a custom expander for it.\n  LegalizeAction getIndexedStoreAction(unsigned IdxMode, MVT VT) const {\n    return getIndexedModeAction(IdxMode, VT, IMAB_Store);\n  }\n\n  /// Return true if the specified indexed load is legal on this target.\n  bool isIndexedStoreLegal(unsigned IdxMode, EVT VT) const {\n    return VT.isSimple() &&\n      (getIndexedStoreAction(IdxMode, VT.getSimpleVT()) == Legal ||\n       getIndexedStoreAction(IdxMode, VT.getSimpleVT()) == Custom);\n  }\n\n  /// Return how the indexed load should be treated: either it is legal, needs\n  /// to be promoted to a larger size, needs to be expanded to some other code\n  /// sequence, or the target has a custom expander for it.\n  LegalizeAction getIndexedMaskedLoadAction(unsigned IdxMode, MVT VT) const {\n    return getIndexedModeAction(IdxMode, VT, IMAB_MaskedLoad);\n  }\n\n  /// Return true if the specified indexed load is legal on this target.\n  bool isIndexedMaskedLoadLegal(unsigned IdxMode, EVT VT) const {\n    return VT.isSimple() &&\n           (getIndexedMaskedLoadAction(IdxMode, VT.getSimpleVT()) == Legal ||\n            getIndexedMaskedLoadAction(IdxMode, VT.getSimpleVT()) == Custom);\n  }\n\n  /// Return how the indexed store should be treated: either it is legal, needs\n  /// to be promoted to a larger size, needs to be expanded to some other code\n  /// sequence, or the target has a custom expander for it.\n  LegalizeAction getIndexedMaskedStoreAction(unsigned IdxMode, MVT VT) const {\n    return getIndexedModeAction(IdxMode, VT, IMAB_MaskedStore);\n  }\n\n  /// Return true if the specified indexed load is legal on this target.\n  bool isIndexedMaskedStoreLegal(unsigned IdxMode, EVT VT) const {\n    return VT.isSimple() &&\n           (getIndexedMaskedStoreAction(IdxMode, VT.getSimpleVT()) == Legal ||\n            getIndexedMaskedStoreAction(IdxMode, VT.getSimpleVT()) == Custom);\n  }\n\n  /// Returns true if the index type for a masked gather/scatter requires\n  /// extending\n  virtual bool shouldExtendGSIndex(EVT VT, EVT &EltTy) const { return false; }\n\n  // Returns true if VT is a legal index type for masked gathers/scatters\n  // on this target\n  virtual bool shouldRemoveExtendFromGSIndex(EVT VT) const { return false; }\n\n  /// Return how the condition code should be treated: either it is legal, needs\n  /// to be expanded to some other code sequence, or the target has a custom\n  /// expander for it.\n  LegalizeAction\n  getCondCodeAction(ISD::CondCode CC, MVT VT) const {\n    assert((unsigned)CC < array_lengthof(CondCodeActions) &&\n           ((unsigned)VT.SimpleTy >> 3) < array_lengthof(CondCodeActions[0]) &&\n           \"Table isn't big enough!\");\n    // See setCondCodeAction for how this is encoded.\n    uint32_t Shift = 4 * (VT.SimpleTy & 0x7);\n    uint32_t Value = CondCodeActions[CC][VT.SimpleTy >> 3];\n    LegalizeAction Action = (LegalizeAction) ((Value >> Shift) & 0xF);\n    assert(Action != Promote && \"Can't promote condition code!\");\n    return Action;\n  }\n\n  /// Return true if the specified condition code is legal on this target.\n  bool isCondCodeLegal(ISD::CondCode CC, MVT VT) const {\n    return getCondCodeAction(CC, VT) == Legal;\n  }\n\n  /// Return true if the specified condition code is legal or custom on this\n  /// target.\n  bool isCondCodeLegalOrCustom(ISD::CondCode CC, MVT VT) const {\n    return getCondCodeAction(CC, VT) == Legal ||\n           getCondCodeAction(CC, VT) == Custom;\n  }\n\n  /// If the action for this operation is to promote, this method returns the\n  /// ValueType to promote to.\n  MVT getTypeToPromoteTo(unsigned Op, MVT VT) const {\n    assert(getOperationAction(Op, VT) == Promote &&\n           \"This operation isn't promoted!\");\n\n    // See if this has an explicit type specified.\n    std::map<std::pair<unsigned, MVT::SimpleValueType>,\n             MVT::SimpleValueType>::const_iterator PTTI =\n      PromoteToType.find(std::make_pair(Op, VT.SimpleTy));\n    if (PTTI != PromoteToType.end()) return PTTI->second;\n\n    assert((VT.isInteger() || VT.isFloatingPoint()) &&\n           \"Cannot autopromote this type, add it with AddPromotedToType.\");\n\n    MVT NVT = VT;\n    do {\n      NVT = (MVT::SimpleValueType)(NVT.SimpleTy+1);\n      assert(NVT.isInteger() == VT.isInteger() && NVT != MVT::isVoid &&\n             \"Didn't find type to promote to!\");\n    } while (!isTypeLegal(NVT) ||\n              getOperationAction(Op, NVT) == Promote);\n    return NVT;\n  }\n\n  /// Return the EVT corresponding to this LLVM type.  This is fixed by the LLVM\n  /// operations except for the pointer size.  If AllowUnknown is true, this\n  /// will return MVT::Other for types with no EVT counterpart (e.g. structs),\n  /// otherwise it will assert.\n  EVT getValueType(const DataLayout &DL, Type *Ty,\n                   bool AllowUnknown = false) const {\n    // Lower scalar pointers to native pointer types.\n    if (auto *PTy = dyn_cast<PointerType>(Ty))\n      return getPointerTy(DL, PTy->getAddressSpace());\n\n    if (auto *VTy = dyn_cast<VectorType>(Ty)) {\n      Type *EltTy = VTy->getElementType();\n      // Lower vectors of pointers to native pointer types.\n      if (auto *PTy = dyn_cast<PointerType>(EltTy)) {\n        EVT PointerTy(getPointerTy(DL, PTy->getAddressSpace()));\n        EltTy = PointerTy.getTypeForEVT(Ty->getContext());\n      }\n      return EVT::getVectorVT(Ty->getContext(), EVT::getEVT(EltTy, false),\n                              VTy->getElementCount());\n    }\n\n    return EVT::getEVT(Ty, AllowUnknown);\n  }\n\n  EVT getMemValueType(const DataLayout &DL, Type *Ty,\n                      bool AllowUnknown = false) const {\n    // Lower scalar pointers to native pointer types.\n    if (PointerType *PTy = dyn_cast<PointerType>(Ty))\n      return getPointerMemTy(DL, PTy->getAddressSpace());\n    else if (VectorType *VTy = dyn_cast<VectorType>(Ty)) {\n      Type *Elm = VTy->getElementType();\n      if (PointerType *PT = dyn_cast<PointerType>(Elm)) {\n        EVT PointerTy(getPointerMemTy(DL, PT->getAddressSpace()));\n        Elm = PointerTy.getTypeForEVT(Ty->getContext());\n      }\n      return EVT::getVectorVT(Ty->getContext(), EVT::getEVT(Elm, false),\n                              VTy->getElementCount());\n    }\n\n    return getValueType(DL, Ty, AllowUnknown);\n  }\n\n\n  /// Return the MVT corresponding to this LLVM type. See getValueType.\n  MVT getSimpleValueType(const DataLayout &DL, Type *Ty,\n                         bool AllowUnknown = false) const {\n    return getValueType(DL, Ty, AllowUnknown).getSimpleVT();\n  }\n\n  /// Return the desired alignment for ByVal or InAlloca aggregate function\n  /// arguments in the caller parameter area.  This is the actual alignment, not\n  /// its logarithm.\n  virtual unsigned getByValTypeAlignment(Type *Ty, const DataLayout &DL) const;\n\n  /// Return the type of registers that this ValueType will eventually require.\n  MVT getRegisterType(MVT VT) const {\n    assert((unsigned)VT.SimpleTy < array_lengthof(RegisterTypeForVT));\n    return RegisterTypeForVT[VT.SimpleTy];\n  }\n\n  /// Return the type of registers that this ValueType will eventually require.\n  MVT getRegisterType(LLVMContext &Context, EVT VT) const {\n    if (VT.isSimple()) {\n      assert((unsigned)VT.getSimpleVT().SimpleTy <\n                array_lengthof(RegisterTypeForVT));\n      return RegisterTypeForVT[VT.getSimpleVT().SimpleTy];\n    }\n    if (VT.isVector()) {\n      EVT VT1;\n      MVT RegisterVT;\n      unsigned NumIntermediates;\n      (void)getVectorTypeBreakdown(Context, VT, VT1,\n                                   NumIntermediates, RegisterVT);\n      return RegisterVT;\n    }\n    if (VT.isInteger()) {\n      return getRegisterType(Context, getTypeToTransformTo(Context, VT));\n    }\n    llvm_unreachable(\"Unsupported extended type!\");\n  }\n\n  /// Return the number of registers that this ValueType will eventually\n  /// require.\n  ///\n  /// This is one for any types promoted to live in larger registers, but may be\n  /// more than one for types (like i64) that are split into pieces.  For types\n  /// like i140, which are first promoted then expanded, it is the number of\n  /// registers needed to hold all the bits of the original type.  For an i140\n  /// on a 32 bit machine this means 5 registers.\n  unsigned getNumRegisters(LLVMContext &Context, EVT VT) const {\n    if (VT.isSimple()) {\n      assert((unsigned)VT.getSimpleVT().SimpleTy <\n                array_lengthof(NumRegistersForVT));\n      return NumRegistersForVT[VT.getSimpleVT().SimpleTy];\n    }\n    if (VT.isVector()) {\n      EVT VT1;\n      MVT VT2;\n      unsigned NumIntermediates;\n      return getVectorTypeBreakdown(Context, VT, VT1, NumIntermediates, VT2);\n    }\n    if (VT.isInteger()) {\n      unsigned BitWidth = VT.getSizeInBits();\n      unsigned RegWidth = getRegisterType(Context, VT).getSizeInBits();\n      return (BitWidth + RegWidth - 1) / RegWidth;\n    }\n    llvm_unreachable(\"Unsupported extended type!\");\n  }\n\n  /// Certain combinations of ABIs, Targets and features require that types\n  /// are legal for some operations and not for other operations.\n  /// For MIPS all vector types must be passed through the integer register set.\n  virtual MVT getRegisterTypeForCallingConv(LLVMContext &Context,\n                                            CallingConv::ID CC, EVT VT) const {\n    return getRegisterType(Context, VT);\n  }\n\n  /// Certain targets require unusual breakdowns of certain types. For MIPS,\n  /// this occurs when a vector type is used, as vector are passed through the\n  /// integer register set.\n  virtual unsigned getNumRegistersForCallingConv(LLVMContext &Context,\n                                                 CallingConv::ID CC,\n                                                 EVT VT) const {\n    return getNumRegisters(Context, VT);\n  }\n\n  /// Certain targets have context senstive alignment requirements, where one\n  /// type has the alignment requirement of another type.\n  virtual Align getABIAlignmentForCallingConv(Type *ArgTy,\n                                              DataLayout DL) const {\n    return DL.getABITypeAlign(ArgTy);\n  }\n\n  /// If true, then instruction selection should seek to shrink the FP constant\n  /// of the specified type to a smaller type in order to save space and / or\n  /// reduce runtime.\n  virtual bool ShouldShrinkFPConstant(EVT) const { return true; }\n\n  /// Return true if it is profitable to reduce a load to a smaller type.\n  /// Example: (i16 (trunc (i32 (load x))) -> i16 load x\n  virtual bool shouldReduceLoadWidth(SDNode *Load, ISD::LoadExtType ExtTy,\n                                     EVT NewVT) const {\n    // By default, assume that it is cheaper to extract a subvector from a wide\n    // vector load rather than creating multiple narrow vector loads.\n    if (NewVT.isVector() && !Load->hasOneUse())\n      return false;\n\n    return true;\n  }\n\n  /// When splitting a value of the specified type into parts, does the Lo\n  /// or Hi part come first?  This usually follows the endianness, except\n  /// for ppcf128, where the Hi part always comes first.\n  bool hasBigEndianPartOrdering(EVT VT, const DataLayout &DL) const {\n    return DL.isBigEndian() || VT == MVT::ppcf128;\n  }\n\n  /// If true, the target has custom DAG combine transformations that it can\n  /// perform for the specified node.\n  bool hasTargetDAGCombine(ISD::NodeType NT) const {\n    assert(unsigned(NT >> 3) < array_lengthof(TargetDAGCombineArray));\n    return TargetDAGCombineArray[NT >> 3] & (1 << (NT&7));\n  }\n\n  unsigned getGatherAllAliasesMaxDepth() const {\n    return GatherAllAliasesMaxDepth;\n  }\n\n  /// Returns the size of the platform's va_list object.\n  virtual unsigned getVaListSizeInBits(const DataLayout &DL) const {\n    return getPointerTy(DL).getSizeInBits();\n  }\n\n  /// Get maximum # of store operations permitted for llvm.memset\n  ///\n  /// This function returns the maximum number of store operations permitted\n  /// to replace a call to llvm.memset. The value is set by the target at the\n  /// performance threshold for such a replacement. If OptSize is true,\n  /// return the limit for functions that have OptSize attribute.\n  unsigned getMaxStoresPerMemset(bool OptSize) const {\n    return OptSize ? MaxStoresPerMemsetOptSize : MaxStoresPerMemset;\n  }\n\n  /// Get maximum # of store operations permitted for llvm.memcpy\n  ///\n  /// This function returns the maximum number of store operations permitted\n  /// to replace a call to llvm.memcpy. The value is set by the target at the\n  /// performance threshold for such a replacement. If OptSize is true,\n  /// return the limit for functions that have OptSize attribute.\n  unsigned getMaxStoresPerMemcpy(bool OptSize) const {\n    return OptSize ? MaxStoresPerMemcpyOptSize : MaxStoresPerMemcpy;\n  }\n\n  /// \\brief Get maximum # of store operations to be glued together\n  ///\n  /// This function returns the maximum number of store operations permitted\n  /// to glue together during lowering of llvm.memcpy. The value is set by\n  //  the target at the performance threshold for such a replacement.\n  virtual unsigned getMaxGluedStoresPerMemcpy() const {\n    return MaxGluedStoresPerMemcpy;\n  }\n\n  /// Get maximum # of load operations permitted for memcmp\n  ///\n  /// This function returns the maximum number of load operations permitted\n  /// to replace a call to memcmp. The value is set by the target at the\n  /// performance threshold for such a replacement. If OptSize is true,\n  /// return the limit for functions that have OptSize attribute.\n  unsigned getMaxExpandSizeMemcmp(bool OptSize) const {\n    return OptSize ? MaxLoadsPerMemcmpOptSize : MaxLoadsPerMemcmp;\n  }\n\n  /// Get maximum # of store operations permitted for llvm.memmove\n  ///\n  /// This function returns the maximum number of store operations permitted\n  /// to replace a call to llvm.memmove. The value is set by the target at the\n  /// performance threshold for such a replacement. If OptSize is true,\n  /// return the limit for functions that have OptSize attribute.\n  unsigned getMaxStoresPerMemmove(bool OptSize) const {\n    return OptSize ? MaxStoresPerMemmoveOptSize : MaxStoresPerMemmove;\n  }\n\n  /// Determine if the target supports unaligned memory accesses.\n  ///\n  /// This function returns true if the target allows unaligned memory accesses\n  /// of the specified type in the given address space. If true, it also returns\n  /// whether the unaligned memory access is \"fast\" in the last argument by\n  /// reference. This is used, for example, in situations where an array\n  /// copy/move/set is converted to a sequence of store operations. Its use\n  /// helps to ensure that such replacements don't generate code that causes an\n  /// alignment error (trap) on the target machine.\n  virtual bool allowsMisalignedMemoryAccesses(\n      EVT, unsigned AddrSpace = 0, Align Alignment = Align(1),\n      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,\n      bool * /*Fast*/ = nullptr) const {\n    return false;\n  }\n\n  /// LLT handling variant.\n  virtual bool allowsMisalignedMemoryAccesses(\n      LLT, unsigned AddrSpace = 0, Align Alignment = Align(1),\n      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,\n      bool * /*Fast*/ = nullptr) const {\n    return false;\n  }\n\n  /// This function returns true if the memory access is aligned or if the\n  /// target allows this specific unaligned memory access. If the access is\n  /// allowed, the optional final parameter returns if the access is also fast\n  /// (as defined by the target).\n  bool allowsMemoryAccessForAlignment(\n      LLVMContext &Context, const DataLayout &DL, EVT VT,\n      unsigned AddrSpace = 0, Align Alignment = Align(1),\n      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,\n      bool *Fast = nullptr) const;\n\n  /// Return true if the memory access of this type is aligned or if the target\n  /// allows this specific unaligned access for the given MachineMemOperand.\n  /// If the access is allowed, the optional final parameter returns if the\n  /// access is also fast (as defined by the target).\n  bool allowsMemoryAccessForAlignment(LLVMContext &Context,\n                                      const DataLayout &DL, EVT VT,\n                                      const MachineMemOperand &MMO,\n                                      bool *Fast = nullptr) const;\n\n  /// Return true if the target supports a memory access of this type for the\n  /// given address space and alignment. If the access is allowed, the optional\n  /// final parameter returns if the access is also fast (as defined by the\n  /// target).\n  virtual bool\n  allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, EVT VT,\n                     unsigned AddrSpace = 0, Align Alignment = Align(1),\n                     MachineMemOperand::Flags Flags = MachineMemOperand::MONone,\n                     bool *Fast = nullptr) const;\n\n  /// Return true if the target supports a memory access of this type for the\n  /// given MachineMemOperand. If the access is allowed, the optional\n  /// final parameter returns if the access is also fast (as defined by the\n  /// target).\n  bool allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, EVT VT,\n                          const MachineMemOperand &MMO,\n                          bool *Fast = nullptr) const;\n\n  /// LLT handling variant.\n  bool allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, LLT Ty,\n                          const MachineMemOperand &MMO,\n                          bool *Fast = nullptr) const;\n\n  /// Returns the target specific optimal type for load and store operations as\n  /// a result of memset, memcpy, and memmove lowering.\n  /// It returns EVT::Other if the type should be determined using generic\n  /// target-independent logic.\n  virtual EVT\n  getOptimalMemOpType(const MemOp &Op,\n                      const AttributeList & /*FuncAttributes*/) const {\n    return MVT::Other;\n  }\n\n  /// LLT returning variant.\n  virtual LLT\n  getOptimalMemOpLLT(const MemOp &Op,\n                     const AttributeList & /*FuncAttributes*/) const {\n    return LLT();\n  }\n\n  /// Returns true if it's safe to use load / store of the specified type to\n  /// expand memcpy / memset inline.\n  ///\n  /// This is mostly true for all types except for some special cases. For\n  /// example, on X86 targets without SSE2 f64 load / store are done with fldl /\n  /// fstpl which also does type conversion. Note the specified type doesn't\n  /// have to be legal as the hook is used before type legalization.\n  virtual bool isSafeMemOpType(MVT /*VT*/) const { return true; }\n\n  /// Return lower limit for number of blocks in a jump table.\n  virtual unsigned getMinimumJumpTableEntries() const;\n\n  /// Return lower limit of the density in a jump table.\n  unsigned getMinimumJumpTableDensity(bool OptForSize) const;\n\n  /// Return upper limit for number of entries in a jump table.\n  /// Zero if no limit.\n  unsigned getMaximumJumpTableSize() const;\n\n  virtual bool isJumpTableRelative() const;\n\n  /// If a physical register, this specifies the register that\n  /// llvm.savestack/llvm.restorestack should save and restore.\n  Register getStackPointerRegisterToSaveRestore() const {\n    return StackPointerRegisterToSaveRestore;\n  }\n\n  /// If a physical register, this returns the register that receives the\n  /// exception address on entry to an EH pad.\n  virtual Register\n  getExceptionPointerRegister(const Constant *PersonalityFn) const {\n    return Register();\n  }\n\n  /// If a physical register, this returns the register that receives the\n  /// exception typeid on entry to a landing pad.\n  virtual Register\n  getExceptionSelectorRegister(const Constant *PersonalityFn) const {\n    return Register();\n  }\n\n  virtual bool needsFixedCatchObjects() const {\n    report_fatal_error(\"Funclet EH is not implemented for this target\");\n  }\n\n  /// Return the minimum stack alignment of an argument.\n  Align getMinStackArgumentAlignment() const {\n    return MinStackArgumentAlignment;\n  }\n\n  /// Return the minimum function alignment.\n  Align getMinFunctionAlignment() const { return MinFunctionAlignment; }\n\n  /// Return the preferred function alignment.\n  Align getPrefFunctionAlignment() const { return PrefFunctionAlignment; }\n\n  /// Return the preferred loop alignment.\n  virtual Align getPrefLoopAlignment(MachineLoop *ML = nullptr) const {\n    return PrefLoopAlignment;\n  }\n\n  /// Should loops be aligned even when the function is marked OptSize (but not\n  /// MinSize).\n  virtual bool alignLoopsWithOptSize() const {\n    return false;\n  }\n\n  /// If the target has a standard location for the stack protector guard,\n  /// returns the address of that location. Otherwise, returns nullptr.\n  /// DEPRECATED: please override useLoadStackGuardNode and customize\n  ///             LOAD_STACK_GUARD, or customize \\@llvm.stackguard().\n  virtual Value *getIRStackGuard(IRBuilder<> &IRB) const;\n\n  /// Inserts necessary declarations for SSP (stack protection) purpose.\n  /// Should be used only when getIRStackGuard returns nullptr.\n  virtual void insertSSPDeclarations(Module &M) const;\n\n  /// Return the variable that's previously inserted by insertSSPDeclarations,\n  /// if any, otherwise return nullptr. Should be used only when\n  /// getIRStackGuard returns nullptr.\n  virtual Value *getSDagStackGuard(const Module &M) const;\n\n  /// If this function returns true, stack protection checks should XOR the\n  /// frame pointer (or whichever pointer is used to address locals) into the\n  /// stack guard value before checking it. getIRStackGuard must return nullptr\n  /// if this returns true.\n  virtual bool useStackGuardXorFP() const { return false; }\n\n  /// If the target has a standard stack protection check function that\n  /// performs validation and error handling, returns the function. Otherwise,\n  /// returns nullptr. Must be previously inserted by insertSSPDeclarations.\n  /// Should be used only when getIRStackGuard returns nullptr.\n  virtual Function *getSSPStackGuardCheck(const Module &M) const;\n\nprotected:\n  Value *getDefaultSafeStackPointerLocation(IRBuilder<> &IRB,\n                                            bool UseTLS) const;\n\npublic:\n  /// Returns the target-specific address of the unsafe stack pointer.\n  virtual Value *getSafeStackPointerLocation(IRBuilder<> &IRB) const;\n\n  /// Returns the name of the symbol used to emit stack probes or the empty\n  /// string if not applicable.\n  virtual bool hasStackProbeSymbol(MachineFunction &MF) const { return false; }\n\n  virtual bool hasInlineStackProbe(MachineFunction &MF) const { return false; }\n\n  virtual StringRef getStackProbeSymbolName(MachineFunction &MF) const {\n    return \"\";\n  }\n\n  /// Returns true if a cast from SrcAS to DestAS is \"cheap\", such that e.g. we\n  /// are happy to sink it into basic blocks. A cast may be free, but not\n  /// necessarily a no-op. e.g. a free truncate from a 64-bit to 32-bit pointer.\n  virtual bool isFreeAddrSpaceCast(unsigned SrcAS, unsigned DestAS) const;\n\n  /// Return true if the pointer arguments to CI should be aligned by aligning\n  /// the object whose address is being passed. If so then MinSize is set to the\n  /// minimum size the object must be to be aligned and PrefAlign is set to the\n  /// preferred alignment.\n  virtual bool shouldAlignPointerArgs(CallInst * /*CI*/, unsigned & /*MinSize*/,\n                                      unsigned & /*PrefAlign*/) const {\n    return false;\n  }\n\n  //===--------------------------------------------------------------------===//\n  /// \\name Helpers for TargetTransformInfo implementations\n  /// @{\n\n  /// Get the ISD node that corresponds to the Instruction class opcode.\n  int InstructionOpcodeToISD(unsigned Opcode) const;\n\n  /// Estimate the cost of type-legalization and the legalized type.\n  std::pair<int, MVT> getTypeLegalizationCost(const DataLayout &DL,\n                                              Type *Ty) const;\n\n  /// @}\n\n  //===--------------------------------------------------------------------===//\n  /// \\name Helpers for atomic expansion.\n  /// @{\n\n  /// Returns the maximum atomic operation size (in bits) supported by\n  /// the backend. Atomic operations greater than this size (as well\n  /// as ones that are not naturally aligned), will be expanded by\n  /// AtomicExpandPass into an __atomic_* library call.\n  unsigned getMaxAtomicSizeInBitsSupported() const {\n    return MaxAtomicSizeInBitsSupported;\n  }\n\n  /// Returns the size of the smallest cmpxchg or ll/sc instruction\n  /// the backend supports.  Any smaller operations are widened in\n  /// AtomicExpandPass.\n  ///\n  /// Note that *unlike* operations above the maximum size, atomic ops\n  /// are still natively supported below the minimum; they just\n  /// require a more complex expansion.\n  unsigned getMinCmpXchgSizeInBits() const { return MinCmpXchgSizeInBits; }\n\n  /// Whether the target supports unaligned atomic operations.\n  bool supportsUnalignedAtomics() const { return SupportsUnalignedAtomics; }\n\n  /// Whether AtomicExpandPass should automatically insert fences and reduce\n  /// ordering for this atomic. This should be true for most architectures with\n  /// weak memory ordering. Defaults to false.\n  virtual bool shouldInsertFencesForAtomic(const Instruction *I) const {\n    return false;\n  }\n\n  /// Perform a load-linked operation on Addr, returning a \"Value *\" with the\n  /// corresponding pointee type. This may entail some non-trivial operations to\n  /// truncate or reconstruct types that will be illegal in the backend. See\n  /// ARMISelLowering for an example implementation.\n  virtual Value *emitLoadLinked(IRBuilder<> &Builder, Value *Addr,\n                                AtomicOrdering Ord) const {\n    llvm_unreachable(\"Load linked unimplemented on this target\");\n  }\n\n  /// Perform a store-conditional operation to Addr. Return the status of the\n  /// store. This should be 0 if the store succeeded, non-zero otherwise.\n  virtual Value *emitStoreConditional(IRBuilder<> &Builder, Value *Val,\n                                      Value *Addr, AtomicOrdering Ord) const {\n    llvm_unreachable(\"Store conditional unimplemented on this target\");\n  }\n\n  /// Perform a masked atomicrmw using a target-specific intrinsic. This\n  /// represents the core LL/SC loop which will be lowered at a late stage by\n  /// the backend.\n  virtual Value *emitMaskedAtomicRMWIntrinsic(IRBuilder<> &Builder,\n                                              AtomicRMWInst *AI,\n                                              Value *AlignedAddr, Value *Incr,\n                                              Value *Mask, Value *ShiftAmt,\n                                              AtomicOrdering Ord) const {\n    llvm_unreachable(\"Masked atomicrmw expansion unimplemented on this target\");\n  }\n\n  /// Perform a masked cmpxchg using a target-specific intrinsic. This\n  /// represents the core LL/SC loop which will be lowered at a late stage by\n  /// the backend.\n  virtual Value *emitMaskedAtomicCmpXchgIntrinsic(\n      IRBuilder<> &Builder, AtomicCmpXchgInst *CI, Value *AlignedAddr,\n      Value *CmpVal, Value *NewVal, Value *Mask, AtomicOrdering Ord) const {\n    llvm_unreachable(\"Masked cmpxchg expansion unimplemented on this target\");\n  }\n\n  /// Inserts in the IR a target-specific intrinsic specifying a fence.\n  /// It is called by AtomicExpandPass before expanding an\n  ///   AtomicRMW/AtomicCmpXchg/AtomicStore/AtomicLoad\n  ///   if shouldInsertFencesForAtomic returns true.\n  ///\n  /// Inst is the original atomic instruction, prior to other expansions that\n  /// may be performed.\n  ///\n  /// This function should either return a nullptr, or a pointer to an IR-level\n  ///   Instruction*. Even complex fence sequences can be represented by a\n  ///   single Instruction* through an intrinsic to be lowered later.\n  /// Backends should override this method to produce target-specific intrinsic\n  ///   for their fences.\n  /// FIXME: Please note that the default implementation here in terms of\n  ///   IR-level fences exists for historical/compatibility reasons and is\n  ///   *unsound* ! Fences cannot, in general, be used to restore sequential\n  ///   consistency. For example, consider the following example:\n  /// atomic<int> x = y = 0;\n  /// int r1, r2, r3, r4;\n  /// Thread 0:\n  ///   x.store(1);\n  /// Thread 1:\n  ///   y.store(1);\n  /// Thread 2:\n  ///   r1 = x.load();\n  ///   r2 = y.load();\n  /// Thread 3:\n  ///   r3 = y.load();\n  ///   r4 = x.load();\n  ///  r1 = r3 = 1 and r2 = r4 = 0 is impossible as long as the accesses are all\n  ///  seq_cst. But if they are lowered to monotonic accesses, no amount of\n  ///  IR-level fences can prevent it.\n  /// @{\n  virtual Instruction *emitLeadingFence(IRBuilder<> &Builder, Instruction *Inst,\n                                        AtomicOrdering Ord) const {\n    if (isReleaseOrStronger(Ord) && Inst->hasAtomicStore())\n      return Builder.CreateFence(Ord);\n    else\n      return nullptr;\n  }\n\n  virtual Instruction *emitTrailingFence(IRBuilder<> &Builder,\n                                         Instruction *Inst,\n                                         AtomicOrdering Ord) const {\n    if (isAcquireOrStronger(Ord))\n      return Builder.CreateFence(Ord);\n    else\n      return nullptr;\n  }\n  /// @}\n\n  // Emits code that executes when the comparison result in the ll/sc\n  // expansion of a cmpxchg instruction is such that the store-conditional will\n  // not execute.  This makes it possible to balance out the load-linked with\n  // a dedicated instruction, if desired.\n  // E.g., on ARM, if ldrex isn't followed by strex, the exclusive monitor would\n  // be unnecessarily held, except if clrex, inserted by this hook, is executed.\n  virtual void emitAtomicCmpXchgNoStoreLLBalance(IRBuilder<> &Builder) const {}\n\n  /// Returns true if the given (atomic) store should be expanded by the\n  /// IR-level AtomicExpand pass into an \"atomic xchg\" which ignores its input.\n  virtual bool shouldExpandAtomicStoreInIR(StoreInst *SI) const {\n    return false;\n  }\n\n  /// Returns true if arguments should be sign-extended in lib calls.\n  virtual bool shouldSignExtendTypeInLibCall(EVT Type, bool IsSigned) const {\n    return IsSigned;\n  }\n\n  /// Returns true if arguments should be extended in lib calls.\n  virtual bool shouldExtendTypeInLibCall(EVT Type) const {\n    return true;\n  }\n\n  /// Returns how the given (atomic) load should be expanded by the\n  /// IR-level AtomicExpand pass.\n  virtual AtomicExpansionKind shouldExpandAtomicLoadInIR(LoadInst *LI) const {\n    return AtomicExpansionKind::None;\n  }\n\n  /// Returns how the given atomic cmpxchg should be expanded by the IR-level\n  /// AtomicExpand pass.\n  virtual AtomicExpansionKind\n  shouldExpandAtomicCmpXchgInIR(AtomicCmpXchgInst *AI) const {\n    return AtomicExpansionKind::None;\n  }\n\n  /// Returns how the IR-level AtomicExpand pass should expand the given\n  /// AtomicRMW, if at all. Default is to never expand.\n  virtual AtomicExpansionKind shouldExpandAtomicRMWInIR(AtomicRMWInst *RMW) const {\n    return RMW->isFloatingPointOperation() ?\n      AtomicExpansionKind::CmpXChg : AtomicExpansionKind::None;\n  }\n\n  /// On some platforms, an AtomicRMW that never actually modifies the value\n  /// (such as fetch_add of 0) can be turned into a fence followed by an\n  /// atomic load. This may sound useless, but it makes it possible for the\n  /// processor to keep the cacheline shared, dramatically improving\n  /// performance. And such idempotent RMWs are useful for implementing some\n  /// kinds of locks, see for example (justification + benchmarks):\n  /// http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf\n  /// This method tries doing that transformation, returning the atomic load if\n  /// it succeeds, and nullptr otherwise.\n  /// If shouldExpandAtomicLoadInIR returns true on that load, it will undergo\n  /// another round of expansion.\n  virtual LoadInst *\n  lowerIdempotentRMWIntoFencedLoad(AtomicRMWInst *RMWI) const {\n    return nullptr;\n  }\n\n  /// Returns how the platform's atomic operations are extended (ZERO_EXTEND,\n  /// SIGN_EXTEND, or ANY_EXTEND).\n  virtual ISD::NodeType getExtendForAtomicOps() const {\n    return ISD::ZERO_EXTEND;\n  }\n\n  /// Returns how the platform's atomic compare and swap expects its comparison\n  /// value to be extended (ZERO_EXTEND, SIGN_EXTEND, or ANY_EXTEND). This is\n  /// separate from getExtendForAtomicOps, which is concerned with the\n  /// sign-extension of the instruction's output, whereas here we are concerned\n  /// with the sign-extension of the input. For targets with compare-and-swap\n  /// instructions (or sub-word comparisons in their LL/SC loop expansions),\n  /// the input can be ANY_EXTEND, but the output will still have a specific\n  /// extension.\n  virtual ISD::NodeType getExtendForAtomicCmpSwapArg() const {\n    return ISD::ANY_EXTEND;\n  }\n\n  /// @}\n\n  /// Returns true if we should normalize\n  /// select(N0&N1, X, Y) => select(N0, select(N1, X, Y), Y) and\n  /// select(N0|N1, X, Y) => select(N0, select(N1, X, Y, Y)) if it is likely\n  /// that it saves us from materializing N0 and N1 in an integer register.\n  /// Targets that are able to perform and/or on flags should return false here.\n  virtual bool shouldNormalizeToSelectSequence(LLVMContext &Context,\n                                               EVT VT) const {\n    // If a target has multiple condition registers, then it likely has logical\n    // operations on those registers.\n    if (hasMultipleConditionRegisters())\n      return false;\n    // Only do the transform if the value won't be split into multiple\n    // registers.\n    LegalizeTypeAction Action = getTypeAction(Context, VT);\n    return Action != TypeExpandInteger && Action != TypeExpandFloat &&\n      Action != TypeSplitVector;\n  }\n\n  virtual bool isProfitableToCombineMinNumMaxNum(EVT VT) const { return true; }\n\n  /// Return true if a select of constants (select Cond, C1, C2) should be\n  /// transformed into simple math ops with the condition value. For example:\n  /// select Cond, C1, C1-1 --> add (zext Cond), C1-1\n  virtual bool convertSelectOfConstantsToMath(EVT VT) const {\n    return false;\n  }\n\n  /// Return true if it is profitable to transform an integer\n  /// multiplication-by-constant into simpler operations like shifts and adds.\n  /// This may be true if the target does not directly support the\n  /// multiplication operation for the specified type or the sequence of simpler\n  /// ops is faster than the multiply.\n  virtual bool decomposeMulByConstant(LLVMContext &Context,\n                                      EVT VT, SDValue C) const {\n    return false;\n  }\n\n  /// Return true if it is more correct/profitable to use strict FP_TO_INT\n  /// conversion operations - canonicalizing the FP source value instead of\n  /// converting all cases and then selecting based on value.\n  /// This may be true if the target throws exceptions for out of bounds\n  /// conversions or has fast FP CMOV.\n  virtual bool shouldUseStrictFP_TO_INT(EVT FpVT, EVT IntVT,\n                                        bool IsSigned) const {\n    return false;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // TargetLowering Configuration Methods - These methods should be invoked by\n  // the derived class constructor to configure this object for the target.\n  //\nprotected:\n  /// Specify how the target extends the result of integer and floating point\n  /// boolean values from i1 to a wider type.  See getBooleanContents.\n  void setBooleanContents(BooleanContent Ty) {\n    BooleanContents = Ty;\n    BooleanFloatContents = Ty;\n  }\n\n  /// Specify how the target extends the result of integer and floating point\n  /// boolean values from i1 to a wider type.  See getBooleanContents.\n  void setBooleanContents(BooleanContent IntTy, BooleanContent FloatTy) {\n    BooleanContents = IntTy;\n    BooleanFloatContents = FloatTy;\n  }\n\n  /// Specify how the target extends the result of a vector boolean value from a\n  /// vector of i1 to a wider type.  See getBooleanContents.\n  void setBooleanVectorContents(BooleanContent Ty) {\n    BooleanVectorContents = Ty;\n  }\n\n  /// Specify the target scheduling preference.\n  void setSchedulingPreference(Sched::Preference Pref) {\n    SchedPreferenceInfo = Pref;\n  }\n\n  /// Indicate the minimum number of blocks to generate jump tables.\n  void setMinimumJumpTableEntries(unsigned Val);\n\n  /// Indicate the maximum number of entries in jump tables.\n  /// Set to zero to generate unlimited jump tables.\n  void setMaximumJumpTableSize(unsigned);\n\n  /// If set to a physical register, this specifies the register that\n  /// llvm.savestack/llvm.restorestack should save and restore.\n  void setStackPointerRegisterToSaveRestore(Register R) {\n    StackPointerRegisterToSaveRestore = R;\n  }\n\n  /// Tells the code generator that the target has multiple (allocatable)\n  /// condition registers that can be used to store the results of comparisons\n  /// for use by selects and conditional branches. With multiple condition\n  /// registers, the code generator will not aggressively sink comparisons into\n  /// the blocks of their users.\n  void setHasMultipleConditionRegisters(bool hasManyRegs = true) {\n    HasMultipleConditionRegisters = hasManyRegs;\n  }\n\n  /// Tells the code generator that the target has BitExtract instructions.\n  /// The code generator will aggressively sink \"shift\"s into the blocks of\n  /// their users if the users will generate \"and\" instructions which can be\n  /// combined with \"shift\" to BitExtract instructions.\n  void setHasExtractBitsInsn(bool hasExtractInsn = true) {\n    HasExtractBitsInsn = hasExtractInsn;\n  }\n\n  /// Tells the code generator not to expand logic operations on comparison\n  /// predicates into separate sequences that increase the amount of flow\n  /// control.\n  void setJumpIsExpensive(bool isExpensive = true);\n\n  /// Tells the code generator which bitwidths to bypass.\n  void addBypassSlowDiv(unsigned int SlowBitWidth, unsigned int FastBitWidth) {\n    BypassSlowDivWidths[SlowBitWidth] = FastBitWidth;\n  }\n\n  /// Add the specified register class as an available regclass for the\n  /// specified value type. This indicates the selector can handle values of\n  /// that class natively.\n  void addRegisterClass(MVT VT, const TargetRegisterClass *RC) {\n    assert((unsigned)VT.SimpleTy < array_lengthof(RegClassForVT));\n    RegClassForVT[VT.SimpleTy] = RC;\n  }\n\n  /// Return the largest legal super-reg register class of the register class\n  /// for the specified type and its associated \"cost\".\n  virtual std::pair<const TargetRegisterClass *, uint8_t>\n  findRepresentativeClass(const TargetRegisterInfo *TRI, MVT VT) const;\n\n  /// Once all of the register classes are added, this allows us to compute\n  /// derived properties we expose.\n  void computeRegisterProperties(const TargetRegisterInfo *TRI);\n\n  /// Indicate that the specified operation does not work with the specified\n  /// type and indicate what to do about it. Note that VT may refer to either\n  /// the type of a result or that of an operand of Op.\n  void setOperationAction(unsigned Op, MVT VT,\n                          LegalizeAction Action) {\n    assert(Op < array_lengthof(OpActions[0]) && \"Table isn't big enough!\");\n    OpActions[(unsigned)VT.SimpleTy][Op] = Action;\n  }\n\n  /// Indicate that the specified load with extension does not work with the\n  /// specified type and indicate what to do about it.\n  void setLoadExtAction(unsigned ExtType, MVT ValVT, MVT MemVT,\n                        LegalizeAction Action) {\n    assert(ExtType < ISD::LAST_LOADEXT_TYPE && ValVT.isValid() &&\n           MemVT.isValid() && \"Table isn't big enough!\");\n    assert((unsigned)Action < 0x10 && \"too many bits for bitfield array\");\n    unsigned Shift = 4 * ExtType;\n    LoadExtActions[ValVT.SimpleTy][MemVT.SimpleTy] &= ~((uint16_t)0xF << Shift);\n    LoadExtActions[ValVT.SimpleTy][MemVT.SimpleTy] |= (uint16_t)Action << Shift;\n  }\n\n  /// Indicate that the specified truncating store does not work with the\n  /// specified type and indicate what to do about it.\n  void setTruncStoreAction(MVT ValVT, MVT MemVT,\n                           LegalizeAction Action) {\n    assert(ValVT.isValid() && MemVT.isValid() && \"Table isn't big enough!\");\n    TruncStoreActions[(unsigned)ValVT.SimpleTy][MemVT.SimpleTy] = Action;\n  }\n\n  /// Indicate that the specified indexed load does or does not work with the\n  /// specified type and indicate what to do abort it.\n  ///\n  /// NOTE: All indexed mode loads are initialized to Expand in\n  /// TargetLowering.cpp\n  void setIndexedLoadAction(unsigned IdxMode, MVT VT, LegalizeAction Action) {\n    setIndexedModeAction(IdxMode, VT, IMAB_Load, Action);\n  }\n\n  /// Indicate that the specified indexed store does or does not work with the\n  /// specified type and indicate what to do about it.\n  ///\n  /// NOTE: All indexed mode stores are initialized to Expand in\n  /// TargetLowering.cpp\n  void setIndexedStoreAction(unsigned IdxMode, MVT VT, LegalizeAction Action) {\n    setIndexedModeAction(IdxMode, VT, IMAB_Store, Action);\n  }\n\n  /// Indicate that the specified indexed masked load does or does not work with\n  /// the specified type and indicate what to do about it.\n  ///\n  /// NOTE: All indexed mode masked loads are initialized to Expand in\n  /// TargetLowering.cpp\n  void setIndexedMaskedLoadAction(unsigned IdxMode, MVT VT,\n                                  LegalizeAction Action) {\n    setIndexedModeAction(IdxMode, VT, IMAB_MaskedLoad, Action);\n  }\n\n  /// Indicate that the specified indexed masked store does or does not work\n  /// with the specified type and indicate what to do about it.\n  ///\n  /// NOTE: All indexed mode masked stores are initialized to Expand in\n  /// TargetLowering.cpp\n  void setIndexedMaskedStoreAction(unsigned IdxMode, MVT VT,\n                                   LegalizeAction Action) {\n    setIndexedModeAction(IdxMode, VT, IMAB_MaskedStore, Action);\n  }\n\n  /// Indicate that the specified condition code is or isn't supported on the\n  /// target and indicate what to do about it.\n  void setCondCodeAction(ISD::CondCode CC, MVT VT,\n                         LegalizeAction Action) {\n    assert(VT.isValid() && (unsigned)CC < array_lengthof(CondCodeActions) &&\n           \"Table isn't big enough!\");\n    assert((unsigned)Action < 0x10 && \"too many bits for bitfield array\");\n    /// The lower 3 bits of the SimpleTy index into Nth 4bit set from the 32-bit\n    /// value and the upper 29 bits index into the second dimension of the array\n    /// to select what 32-bit value to use.\n    uint32_t Shift = 4 * (VT.SimpleTy & 0x7);\n    CondCodeActions[CC][VT.SimpleTy >> 3] &= ~((uint32_t)0xF << Shift);\n    CondCodeActions[CC][VT.SimpleTy >> 3] |= (uint32_t)Action << Shift;\n  }\n\n  /// If Opc/OrigVT is specified as being promoted, the promotion code defaults\n  /// to trying a larger integer/fp until it can find one that works. If that\n  /// default is insufficient, this method can be used by the target to override\n  /// the default.\n  void AddPromotedToType(unsigned Opc, MVT OrigVT, MVT DestVT) {\n    PromoteToType[std::make_pair(Opc, OrigVT.SimpleTy)] = DestVT.SimpleTy;\n  }\n\n  /// Convenience method to set an operation to Promote and specify the type\n  /// in a single call.\n  void setOperationPromotedToType(unsigned Opc, MVT OrigVT, MVT DestVT) {\n    setOperationAction(Opc, OrigVT, Promote);\n    AddPromotedToType(Opc, OrigVT, DestVT);\n  }\n\n  /// Targets should invoke this method for each target independent node that\n  /// they want to provide a custom DAG combiner for by implementing the\n  /// PerformDAGCombine virtual method.\n  void setTargetDAGCombine(ISD::NodeType NT) {\n    assert(unsigned(NT >> 3) < array_lengthof(TargetDAGCombineArray));\n    TargetDAGCombineArray[NT >> 3] |= 1 << (NT&7);\n  }\n\n  /// Set the target's minimum function alignment.\n  void setMinFunctionAlignment(Align Alignment) {\n    MinFunctionAlignment = Alignment;\n  }\n\n  /// Set the target's preferred function alignment.  This should be set if\n  /// there is a performance benefit to higher-than-minimum alignment\n  void setPrefFunctionAlignment(Align Alignment) {\n    PrefFunctionAlignment = Alignment;\n  }\n\n  /// Set the target's preferred loop alignment. Default alignment is one, it\n  /// means the target does not care about loop alignment. The target may also\n  /// override getPrefLoopAlignment to provide per-loop values.\n  void setPrefLoopAlignment(Align Alignment) { PrefLoopAlignment = Alignment; }\n\n  /// Set the minimum stack alignment of an argument.\n  void setMinStackArgumentAlignment(Align Alignment) {\n    MinStackArgumentAlignment = Alignment;\n  }\n\n  /// Set the maximum atomic operation size supported by the\n  /// backend. Atomic operations greater than this size (as well as\n  /// ones that are not naturally aligned), will be expanded by\n  /// AtomicExpandPass into an __atomic_* library call.\n  void setMaxAtomicSizeInBitsSupported(unsigned SizeInBits) {\n    MaxAtomicSizeInBitsSupported = SizeInBits;\n  }\n\n  /// Sets the minimum cmpxchg or ll/sc size supported by the backend.\n  void setMinCmpXchgSizeInBits(unsigned SizeInBits) {\n    MinCmpXchgSizeInBits = SizeInBits;\n  }\n\n  /// Sets whether unaligned atomic operations are supported.\n  void setSupportsUnalignedAtomics(bool UnalignedSupported) {\n    SupportsUnalignedAtomics = UnalignedSupported;\n  }\n\npublic:\n  //===--------------------------------------------------------------------===//\n  // Addressing mode description hooks (used by LSR etc).\n  //\n\n  /// CodeGenPrepare sinks address calculations into the same BB as Load/Store\n  /// instructions reading the address. This allows as much computation as\n  /// possible to be done in the address mode for that operand. This hook lets\n  /// targets also pass back when this should be done on intrinsics which\n  /// load/store.\n  virtual bool getAddrModeArguments(IntrinsicInst * /*I*/,\n                                    SmallVectorImpl<Value*> &/*Ops*/,\n                                    Type *&/*AccessTy*/) const {\n    return false;\n  }\n\n  /// This represents an addressing mode of:\n  ///    BaseGV + BaseOffs + BaseReg + Scale*ScaleReg\n  /// If BaseGV is null,  there is no BaseGV.\n  /// If BaseOffs is zero, there is no base offset.\n  /// If HasBaseReg is false, there is no base register.\n  /// If Scale is zero, there is no ScaleReg.  Scale of 1 indicates a reg with\n  /// no scale.\n  struct AddrMode {\n    GlobalValue *BaseGV = nullptr;\n    int64_t      BaseOffs = 0;\n    bool         HasBaseReg = false;\n    int64_t      Scale = 0;\n    AddrMode() = default;\n  };\n\n  /// Return true if the addressing mode represented by AM is legal for this\n  /// target, for a load/store of the specified type.\n  ///\n  /// The type may be VoidTy, in which case only return true if the addressing\n  /// mode is legal for a load/store of any legal type.  TODO: Handle\n  /// pre/postinc as well.\n  ///\n  /// If the address space cannot be determined, it will be -1.\n  ///\n  /// TODO: Remove default argument\n  virtual bool isLegalAddressingMode(const DataLayout &DL, const AddrMode &AM,\n                                     Type *Ty, unsigned AddrSpace,\n                                     Instruction *I = nullptr) const;\n\n  /// Return the cost of the scaling factor used in the addressing mode\n  /// represented by AM for this target, for a load/store of the specified type.\n  ///\n  /// If the AM is supported, the return value must be >= 0.\n  /// If the AM is not supported, it returns a negative value.\n  /// TODO: Handle pre/postinc as well.\n  /// TODO: Remove default argument\n  virtual int getScalingFactorCost(const DataLayout &DL, const AddrMode &AM,\n                                   Type *Ty, unsigned AS = 0) const {\n    // Default: assume that any scaling factor used in a legal AM is free.\n    if (isLegalAddressingMode(DL, AM, Ty, AS))\n      return 0;\n    return -1;\n  }\n\n  /// Return true if the specified immediate is legal icmp immediate, that is\n  /// the target has icmp instructions which can compare a register against the\n  /// immediate without having to materialize the immediate into a register.\n  virtual bool isLegalICmpImmediate(int64_t) const {\n    return true;\n  }\n\n  /// Return true if the specified immediate is legal add immediate, that is the\n  /// target has add instructions which can add a register with the immediate\n  /// without having to materialize the immediate into a register.\n  virtual bool isLegalAddImmediate(int64_t) const {\n    return true;\n  }\n\n  /// Return true if the specified immediate is legal for the value input of a\n  /// store instruction.\n  virtual bool isLegalStoreImmediate(int64_t Value) const {\n    // Default implementation assumes that at least 0 works since it is likely\n    // that a zero register exists or a zero immediate is allowed.\n    return Value == 0;\n  }\n\n  /// Return true if it's significantly cheaper to shift a vector by a uniform\n  /// scalar than by an amount which will vary across each lane. On x86 before\n  /// AVX2 for example, there is a \"psllw\" instruction for the former case, but\n  /// no simple instruction for a general \"a << b\" operation on vectors.\n  /// This should also apply to lowering for vector funnel shifts (rotates).\n  virtual bool isVectorShiftByScalarCheap(Type *Ty) const {\n    return false;\n  }\n\n  /// Given a shuffle vector SVI representing a vector splat, return a new\n  /// scalar type of size equal to SVI's scalar type if the new type is more\n  /// profitable. Returns nullptr otherwise. For example under MVE float splats\n  /// are converted to integer to prevent the need to move from SPR to GPR\n  /// registers.\n  virtual Type* shouldConvertSplatType(ShuffleVectorInst* SVI) const {\n    return nullptr;\n  }\n\n  /// Given a set in interconnected phis of type 'From' that are loaded/stored\n  /// or bitcast to type 'To', return true if the set should be converted to\n  /// 'To'.\n  virtual bool shouldConvertPhiType(Type *From, Type *To) const {\n    return (From->isIntegerTy() || From->isFloatingPointTy()) &&\n           (To->isIntegerTy() || To->isFloatingPointTy());\n  }\n\n  /// Returns true if the opcode is a commutative binary operation.\n  virtual bool isCommutativeBinOp(unsigned Opcode) const {\n    // FIXME: This should get its info from the td file.\n    switch (Opcode) {\n    case ISD::ADD:\n    case ISD::SMIN:\n    case ISD::SMAX:\n    case ISD::UMIN:\n    case ISD::UMAX:\n    case ISD::MUL:\n    case ISD::MULHU:\n    case ISD::MULHS:\n    case ISD::SMUL_LOHI:\n    case ISD::UMUL_LOHI:\n    case ISD::FADD:\n    case ISD::FMUL:\n    case ISD::AND:\n    case ISD::OR:\n    case ISD::XOR:\n    case ISD::SADDO:\n    case ISD::UADDO:\n    case ISD::ADDC:\n    case ISD::ADDE:\n    case ISD::SADDSAT:\n    case ISD::UADDSAT:\n    case ISD::FMINNUM:\n    case ISD::FMAXNUM:\n    case ISD::FMINNUM_IEEE:\n    case ISD::FMAXNUM_IEEE:\n    case ISD::FMINIMUM:\n    case ISD::FMAXIMUM:\n      return true;\n    default: return false;\n    }\n  }\n\n  /// Return true if the node is a math/logic binary operator.\n  virtual bool isBinOp(unsigned Opcode) const {\n    // A commutative binop must be a binop.\n    if (isCommutativeBinOp(Opcode))\n      return true;\n    // These are non-commutative binops.\n    switch (Opcode) {\n    case ISD::SUB:\n    case ISD::SHL:\n    case ISD::SRL:\n    case ISD::SRA:\n    case ISD::SDIV:\n    case ISD::UDIV:\n    case ISD::SREM:\n    case ISD::UREM:\n    case ISD::FSUB:\n    case ISD::FDIV:\n    case ISD::FREM:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  /// Return true if it's free to truncate a value of type FromTy to type\n  /// ToTy. e.g. On x86 it's free to truncate a i32 value in register EAX to i16\n  /// by referencing its sub-register AX.\n  /// Targets must return false when FromTy <= ToTy.\n  virtual bool isTruncateFree(Type *FromTy, Type *ToTy) const {\n    return false;\n  }\n\n  /// Return true if a truncation from FromTy to ToTy is permitted when deciding\n  /// whether a call is in tail position. Typically this means that both results\n  /// would be assigned to the same register or stack slot, but it could mean\n  /// the target performs adequate checks of its own before proceeding with the\n  /// tail call.  Targets must return false when FromTy <= ToTy.\n  virtual bool allowTruncateForTailCall(Type *FromTy, Type *ToTy) const {\n    return false;\n  }\n\n  virtual bool isTruncateFree(EVT FromVT, EVT ToVT) const {\n    return false;\n  }\n\n  virtual bool isProfitableToHoist(Instruction *I) const { return true; }\n\n  /// Return true if the extension represented by \\p I is free.\n  /// Unlikely the is[Z|FP]ExtFree family which is based on types,\n  /// this method can use the context provided by \\p I to decide\n  /// whether or not \\p I is free.\n  /// This method extends the behavior of the is[Z|FP]ExtFree family.\n  /// In other words, if is[Z|FP]Free returns true, then this method\n  /// returns true as well. The converse is not true.\n  /// The target can perform the adequate checks by overriding isExtFreeImpl.\n  /// \\pre \\p I must be a sign, zero, or fp extension.\n  bool isExtFree(const Instruction *I) const {\n    switch (I->getOpcode()) {\n    case Instruction::FPExt:\n      if (isFPExtFree(EVT::getEVT(I->getType()),\n                      EVT::getEVT(I->getOperand(0)->getType())))\n        return true;\n      break;\n    case Instruction::ZExt:\n      if (isZExtFree(I->getOperand(0)->getType(), I->getType()))\n        return true;\n      break;\n    case Instruction::SExt:\n      break;\n    default:\n      llvm_unreachable(\"Instruction is not an extension\");\n    }\n    return isExtFreeImpl(I);\n  }\n\n  /// Return true if \\p Load and \\p Ext can form an ExtLoad.\n  /// For example, in AArch64\n  ///   %L = load i8, i8* %ptr\n  ///   %E = zext i8 %L to i32\n  /// can be lowered into one load instruction\n  ///   ldrb w0, [x0]\n  bool isExtLoad(const LoadInst *Load, const Instruction *Ext,\n                 const DataLayout &DL) const {\n    EVT VT = getValueType(DL, Ext->getType());\n    EVT LoadVT = getValueType(DL, Load->getType());\n\n    // If the load has other users and the truncate is not free, the ext\n    // probably isn't free.\n    if (!Load->hasOneUse() && (isTypeLegal(LoadVT) || !isTypeLegal(VT)) &&\n        !isTruncateFree(Ext->getType(), Load->getType()))\n      return false;\n\n    // Check whether the target supports casts folded into loads.\n    unsigned LType;\n    if (isa<ZExtInst>(Ext))\n      LType = ISD::ZEXTLOAD;\n    else {\n      assert(isa<SExtInst>(Ext) && \"Unexpected ext type!\");\n      LType = ISD::SEXTLOAD;\n    }\n\n    return isLoadExtLegal(LType, VT, LoadVT);\n  }\n\n  /// Return true if any actual instruction that defines a value of type FromTy\n  /// implicitly zero-extends the value to ToTy in the result register.\n  ///\n  /// The function should return true when it is likely that the truncate can\n  /// be freely folded with an instruction defining a value of FromTy. If\n  /// the defining instruction is unknown (because you're looking at a\n  /// function argument, PHI, etc.) then the target may require an\n  /// explicit truncate, which is not necessarily free, but this function\n  /// does not deal with those cases.\n  /// Targets must return false when FromTy >= ToTy.\n  virtual bool isZExtFree(Type *FromTy, Type *ToTy) const {\n    return false;\n  }\n\n  virtual bool isZExtFree(EVT FromTy, EVT ToTy) const {\n    return false;\n  }\n\n  /// Return true if sign-extension from FromTy to ToTy is cheaper than\n  /// zero-extension.\n  virtual bool isSExtCheaperThanZExt(EVT FromTy, EVT ToTy) const {\n    return false;\n  }\n\n  /// Return true if sinking I's operands to the same basic block as I is\n  /// profitable, e.g. because the operands can be folded into a target\n  /// instruction during instruction selection. After calling the function\n  /// \\p Ops contains the Uses to sink ordered by dominance (dominating users\n  /// come first).\n  virtual bool shouldSinkOperands(Instruction *I,\n                                  SmallVectorImpl<Use *> &Ops) const {\n    return false;\n  }\n\n  /// Return true if the target supplies and combines to a paired load\n  /// two loaded values of type LoadedType next to each other in memory.\n  /// RequiredAlignment gives the minimal alignment constraints that must be met\n  /// to be able to select this paired load.\n  ///\n  /// This information is *not* used to generate actual paired loads, but it is\n  /// used to generate a sequence of loads that is easier to combine into a\n  /// paired load.\n  /// For instance, something like this:\n  /// a = load i64* addr\n  /// b = trunc i64 a to i32\n  /// c = lshr i64 a, 32\n  /// d = trunc i64 c to i32\n  /// will be optimized into:\n  /// b = load i32* addr1\n  /// d = load i32* addr2\n  /// Where addr1 = addr2 +/- sizeof(i32).\n  ///\n  /// In other words, unless the target performs a post-isel load combining,\n  /// this information should not be provided because it will generate more\n  /// loads.\n  virtual bool hasPairedLoad(EVT /*LoadedType*/,\n                             Align & /*RequiredAlignment*/) const {\n    return false;\n  }\n\n  /// Return true if the target has a vector blend instruction.\n  virtual bool hasVectorBlend() const { return false; }\n\n  /// Get the maximum supported factor for interleaved memory accesses.\n  /// Default to be the minimum interleave factor: 2.\n  virtual unsigned getMaxSupportedInterleaveFactor() const { return 2; }\n\n  /// Lower an interleaved load to target specific intrinsics. Return\n  /// true on success.\n  ///\n  /// \\p LI is the vector load instruction.\n  /// \\p Shuffles is the shufflevector list to DE-interleave the loaded vector.\n  /// \\p Indices is the corresponding indices for each shufflevector.\n  /// \\p Factor is the interleave factor.\n  virtual bool lowerInterleavedLoad(LoadInst *LI,\n                                    ArrayRef<ShuffleVectorInst *> Shuffles,\n                                    ArrayRef<unsigned> Indices,\n                                    unsigned Factor) const {\n    return false;\n  }\n\n  /// Lower an interleaved store to target specific intrinsics. Return\n  /// true on success.\n  ///\n  /// \\p SI is the vector store instruction.\n  /// \\p SVI is the shufflevector to RE-interleave the stored vector.\n  /// \\p Factor is the interleave factor.\n  virtual bool lowerInterleavedStore(StoreInst *SI, ShuffleVectorInst *SVI,\n                                     unsigned Factor) const {\n    return false;\n  }\n\n  /// Return true if zero-extending the specific node Val to type VT2 is free\n  /// (either because it's implicitly zero-extended such as ARM ldrb / ldrh or\n  /// because it's folded such as X86 zero-extending loads).\n  virtual bool isZExtFree(SDValue Val, EVT VT2) const {\n    return isZExtFree(Val.getValueType(), VT2);\n  }\n\n  /// Return true if an fpext operation is free (for instance, because\n  /// single-precision floating-point numbers are implicitly extended to\n  /// double-precision).\n  virtual bool isFPExtFree(EVT DestVT, EVT SrcVT) const {\n    assert(SrcVT.isFloatingPoint() && DestVT.isFloatingPoint() &&\n           \"invalid fpext types\");\n    return false;\n  }\n\n  /// Return true if an fpext operation input to an \\p Opcode operation is free\n  /// (for instance, because half-precision floating-point numbers are\n  /// implicitly extended to float-precision) for an FMA instruction.\n  virtual bool isFPExtFoldable(const SelectionDAG &DAG, unsigned Opcode,\n                               EVT DestVT, EVT SrcVT) const {\n    assert(DestVT.isFloatingPoint() && SrcVT.isFloatingPoint() &&\n           \"invalid fpext types\");\n    return isFPExtFree(DestVT, SrcVT);\n  }\n\n  /// Return true if folding a vector load into ExtVal (a sign, zero, or any\n  /// extend node) is profitable.\n  virtual bool isVectorLoadExtDesirable(SDValue ExtVal) const { return false; }\n\n  /// Return true if an fneg operation is free to the point where it is never\n  /// worthwhile to replace it with a bitwise operation.\n  virtual bool isFNegFree(EVT VT) const {\n    assert(VT.isFloatingPoint());\n    return false;\n  }\n\n  /// Return true if an fabs operation is free to the point where it is never\n  /// worthwhile to replace it with a bitwise operation.\n  virtual bool isFAbsFree(EVT VT) const {\n    assert(VT.isFloatingPoint());\n    return false;\n  }\n\n  /// Return true if an FMA operation is faster than a pair of fmul and fadd\n  /// instructions. fmuladd intrinsics will be expanded to FMAs when this method\n  /// returns true, otherwise fmuladd is expanded to fmul + fadd.\n  ///\n  /// NOTE: This may be called before legalization on types for which FMAs are\n  /// not legal, but should return true if those types will eventually legalize\n  /// to types that support FMAs. After legalization, it will only be called on\n  /// types that support FMAs (via Legal or Custom actions)\n  virtual bool isFMAFasterThanFMulAndFAdd(const MachineFunction &MF,\n                                          EVT) const {\n    return false;\n  }\n\n  /// IR version\n  virtual bool isFMAFasterThanFMulAndFAdd(const Function &F, Type *) const {\n    return false;\n  }\n\n  /// Returns true if be combined with to form an ISD::FMAD. \\p N may be an\n  /// ISD::FADD, ISD::FSUB, or an ISD::FMUL which will be distributed into an\n  /// fadd/fsub.\n  virtual bool isFMADLegal(const SelectionDAG &DAG, const SDNode *N) const {\n    assert((N->getOpcode() == ISD::FADD || N->getOpcode() == ISD::FSUB ||\n            N->getOpcode() == ISD::FMUL) &&\n           \"unexpected node in FMAD forming combine\");\n    return isOperationLegal(ISD::FMAD, N->getValueType(0));\n  }\n\n  // Return true when the decision to generate FMA's (or FMS, FMLA etc) rather\n  // than FMUL and ADD is delegated to the machine combiner.\n  virtual bool generateFMAsInMachineCombiner(EVT VT,\n                                             CodeGenOpt::Level OptLevel) const {\n    return false;\n  }\n\n  /// Return true if it's profitable to narrow operations of type VT1 to\n  /// VT2. e.g. on x86, it's profitable to narrow from i32 to i8 but not from\n  /// i32 to i16.\n  virtual bool isNarrowingProfitable(EVT /*VT1*/, EVT /*VT2*/) const {\n    return false;\n  }\n\n  /// Return true if it is beneficial to convert a load of a constant to\n  /// just the constant itself.\n  /// On some targets it might be more efficient to use a combination of\n  /// arithmetic instructions to materialize the constant instead of loading it\n  /// from a constant pool.\n  virtual bool shouldConvertConstantLoadToIntImm(const APInt &Imm,\n                                                 Type *Ty) const {\n    return false;\n  }\n\n  /// Return true if EXTRACT_SUBVECTOR is cheap for extracting this result type\n  /// from this source type with this index. This is needed because\n  /// EXTRACT_SUBVECTOR usually has custom lowering that depends on the index of\n  /// the first element, and only the target knows which lowering is cheap.\n  virtual bool isExtractSubvectorCheap(EVT ResVT, EVT SrcVT,\n                                       unsigned Index) const {\n    return false;\n  }\n\n  /// Try to convert an extract element of a vector binary operation into an\n  /// extract element followed by a scalar operation.\n  virtual bool shouldScalarizeBinop(SDValue VecOp) const {\n    return false;\n  }\n\n  /// Return true if extraction of a scalar element from the given vector type\n  /// at the given index is cheap. For example, if scalar operations occur on\n  /// the same register file as vector operations, then an extract element may\n  /// be a sub-register rename rather than an actual instruction.\n  virtual bool isExtractVecEltCheap(EVT VT, unsigned Index) const {\n    return false;\n  }\n\n  /// Try to convert math with an overflow comparison into the corresponding DAG\n  /// node operation. Targets may want to override this independently of whether\n  /// the operation is legal/custom for the given type because it may obscure\n  /// matching of other patterns.\n  virtual bool shouldFormOverflowOp(unsigned Opcode, EVT VT,\n                                    bool MathUsed) const {\n    // TODO: The default logic is inherited from code in CodeGenPrepare.\n    // The opcode should not make a difference by default?\n    if (Opcode != ISD::UADDO)\n      return false;\n\n    // Allow the transform as long as we have an integer type that is not\n    // obviously illegal and unsupported and if the math result is used\n    // besides the overflow check. On some targets (e.g. SPARC), it is\n    // not profitable to form on overflow op if the math result has no\n    // concrete users.\n    if (VT.isVector())\n      return false;\n    return MathUsed && (VT.isSimple() || !isOperationExpand(Opcode, VT));\n  }\n\n  // Return true if it is profitable to use a scalar input to a BUILD_VECTOR\n  // even if the vector itself has multiple uses.\n  virtual bool aggressivelyPreferBuildVectorSources(EVT VecVT) const {\n    return false;\n  }\n\n  // Return true if CodeGenPrepare should consider splitting large offset of a\n  // GEP to make the GEP fit into the addressing mode and can be sunk into the\n  // same blocks of its users.\n  virtual bool shouldConsiderGEPOffsetSplit() const { return false; }\n\n  /// Return true if creating a shift of the type by the given\n  /// amount is not profitable.\n  virtual bool shouldAvoidTransformToShift(EVT VT, unsigned Amount) const {\n    return false;\n  }\n\n  /// Does this target require the clearing of high-order bits in a register\n  /// passed to the fp16 to fp conversion library function.\n  virtual bool shouldKeepZExtForFP16Conv() const { return false; }\n\n  //===--------------------------------------------------------------------===//\n  // Runtime Library hooks\n  //\n\n  /// Rename the default libcall routine name for the specified libcall.\n  void setLibcallName(RTLIB::Libcall Call, const char *Name) {\n    LibcallRoutineNames[Call] = Name;\n  }\n\n  /// Get the libcall routine name for the specified libcall.\n  const char *getLibcallName(RTLIB::Libcall Call) const {\n    return LibcallRoutineNames[Call];\n  }\n\n  /// Override the default CondCode to be used to test the result of the\n  /// comparison libcall against zero.\n  void setCmpLibcallCC(RTLIB::Libcall Call, ISD::CondCode CC) {\n    CmpLibcallCCs[Call] = CC;\n  }\n\n  /// Get the CondCode that's to be used to test the result of the comparison\n  /// libcall against zero.\n  ISD::CondCode getCmpLibcallCC(RTLIB::Libcall Call) const {\n    return CmpLibcallCCs[Call];\n  }\n\n  /// Set the CallingConv that should be used for the specified libcall.\n  void setLibcallCallingConv(RTLIB::Libcall Call, CallingConv::ID CC) {\n    LibcallCallingConvs[Call] = CC;\n  }\n\n  /// Get the CallingConv that should be used for the specified libcall.\n  CallingConv::ID getLibcallCallingConv(RTLIB::Libcall Call) const {\n    return LibcallCallingConvs[Call];\n  }\n\n  /// Execute target specific actions to finalize target lowering.\n  /// This is used to set extra flags in MachineFrameInformation and freezing\n  /// the set of reserved registers.\n  /// The default implementation just freezes the set of reserved registers.\n  virtual void finalizeLowering(MachineFunction &MF) const;\n\n  //===----------------------------------------------------------------------===//\n  //  GlobalISel Hooks\n  //===----------------------------------------------------------------------===//\n  /// Check whether or not \\p MI needs to be moved close to its uses.\n  virtual bool shouldLocalize(const MachineInstr &MI, const TargetTransformInfo *TTI) const;\n\n\nprivate:\n  const TargetMachine &TM;\n\n  /// Tells the code generator that the target has multiple (allocatable)\n  /// condition registers that can be used to store the results of comparisons\n  /// for use by selects and conditional branches. With multiple condition\n  /// registers, the code generator will not aggressively sink comparisons into\n  /// the blocks of their users.\n  bool HasMultipleConditionRegisters;\n\n  /// Tells the code generator that the target has BitExtract instructions.\n  /// The code generator will aggressively sink \"shift\"s into the blocks of\n  /// their users if the users will generate \"and\" instructions which can be\n  /// combined with \"shift\" to BitExtract instructions.\n  bool HasExtractBitsInsn;\n\n  /// Tells the code generator to bypass slow divide or remainder\n  /// instructions. For example, BypassSlowDivWidths[32,8] tells the code\n  /// generator to bypass 32-bit integer div/rem with an 8-bit unsigned integer\n  /// div/rem when the operands are positive and less than 256.\n  DenseMap <unsigned int, unsigned int> BypassSlowDivWidths;\n\n  /// Tells the code generator that it shouldn't generate extra flow control\n  /// instructions and should attempt to combine flow control instructions via\n  /// predication.\n  bool JumpIsExpensive;\n\n  /// Information about the contents of the high-bits in boolean values held in\n  /// a type wider than i1. See getBooleanContents.\n  BooleanContent BooleanContents;\n\n  /// Information about the contents of the high-bits in boolean values held in\n  /// a type wider than i1. See getBooleanContents.\n  BooleanContent BooleanFloatContents;\n\n  /// Information about the contents of the high-bits in boolean vector values\n  /// when the element type is wider than i1. See getBooleanContents.\n  BooleanContent BooleanVectorContents;\n\n  /// The target scheduling preference: shortest possible total cycles or lowest\n  /// register usage.\n  Sched::Preference SchedPreferenceInfo;\n\n  /// The minimum alignment that any argument on the stack needs to have.\n  Align MinStackArgumentAlignment;\n\n  /// The minimum function alignment (used when optimizing for size, and to\n  /// prevent explicitly provided alignment from leading to incorrect code).\n  Align MinFunctionAlignment;\n\n  /// The preferred function alignment (used when alignment unspecified and\n  /// optimizing for speed).\n  Align PrefFunctionAlignment;\n\n  /// The preferred loop alignment (in log2 bot in bytes).\n  Align PrefLoopAlignment;\n\n  /// Size in bits of the maximum atomics size the backend supports.\n  /// Accesses larger than this will be expanded by AtomicExpandPass.\n  unsigned MaxAtomicSizeInBitsSupported;\n\n  /// Size in bits of the minimum cmpxchg or ll/sc operation the\n  /// backend supports.\n  unsigned MinCmpXchgSizeInBits;\n\n  /// This indicates if the target supports unaligned atomic operations.\n  bool SupportsUnalignedAtomics;\n\n  /// If set to a physical register, this specifies the register that\n  /// llvm.savestack/llvm.restorestack should save and restore.\n  Register StackPointerRegisterToSaveRestore;\n\n  /// This indicates the default register class to use for each ValueType the\n  /// target supports natively.\n  const TargetRegisterClass *RegClassForVT[MVT::LAST_VALUETYPE];\n  uint16_t NumRegistersForVT[MVT::LAST_VALUETYPE];\n  MVT RegisterTypeForVT[MVT::LAST_VALUETYPE];\n\n  /// This indicates the \"representative\" register class to use for each\n  /// ValueType the target supports natively. This information is used by the\n  /// scheduler to track register pressure. By default, the representative\n  /// register class is the largest legal super-reg register class of the\n  /// register class of the specified type. e.g. On x86, i8, i16, and i32's\n  /// representative class would be GR32.\n  const TargetRegisterClass *RepRegClassForVT[MVT::LAST_VALUETYPE];\n\n  /// This indicates the \"cost\" of the \"representative\" register class for each\n  /// ValueType. The cost is used by the scheduler to approximate register\n  /// pressure.\n  uint8_t RepRegClassCostForVT[MVT::LAST_VALUETYPE];\n\n  /// For any value types we are promoting or expanding, this contains the value\n  /// type that we are changing to.  For Expanded types, this contains one step\n  /// of the expand (e.g. i64 -> i32), even if there are multiple steps required\n  /// (e.g. i64 -> i16).  For types natively supported by the system, this holds\n  /// the same type (e.g. i32 -> i32).\n  MVT TransformToType[MVT::LAST_VALUETYPE];\n\n  /// For each operation and each value type, keep a LegalizeAction that\n  /// indicates how instruction selection should deal with the operation.  Most\n  /// operations are Legal (aka, supported natively by the target), but\n  /// operations that are not should be described.  Note that operations on\n  /// non-legal value types are not described here.\n  LegalizeAction OpActions[MVT::LAST_VALUETYPE][ISD::BUILTIN_OP_END];\n\n  /// For each load extension type and each value type, keep a LegalizeAction\n  /// that indicates how instruction selection should deal with a load of a\n  /// specific value type and extension type. Uses 4-bits to store the action\n  /// for each of the 4 load ext types.\n  uint16_t LoadExtActions[MVT::LAST_VALUETYPE][MVT::LAST_VALUETYPE];\n\n  /// For each value type pair keep a LegalizeAction that indicates whether a\n  /// truncating store of a specific value type and truncating type is legal.\n  LegalizeAction TruncStoreActions[MVT::LAST_VALUETYPE][MVT::LAST_VALUETYPE];\n\n  /// For each indexed mode and each value type, keep a quad of LegalizeAction\n  /// that indicates how instruction selection should deal with the load /\n  /// store / maskedload / maskedstore.\n  ///\n  /// The first dimension is the value_type for the reference. The second\n  /// dimension represents the various modes for load store.\n  uint16_t IndexedModeActions[MVT::LAST_VALUETYPE][ISD::LAST_INDEXED_MODE];\n\n  /// For each condition code (ISD::CondCode) keep a LegalizeAction that\n  /// indicates how instruction selection should deal with the condition code.\n  ///\n  /// Because each CC action takes up 4 bits, we need to have the array size be\n  /// large enough to fit all of the value types. This can be done by rounding\n  /// up the MVT::LAST_VALUETYPE value to the next multiple of 8.\n  uint32_t CondCodeActions[ISD::SETCC_INVALID][(MVT::LAST_VALUETYPE + 7) / 8];\n\n  ValueTypeActionImpl ValueTypeActions;\n\nprivate:\n  LegalizeKind getTypeConversion(LLVMContext &Context, EVT VT) const;\n\n  /// Targets can specify ISD nodes that they would like PerformDAGCombine\n  /// callbacks for by calling setTargetDAGCombine(), which sets a bit in this\n  /// array.\n  unsigned char\n  TargetDAGCombineArray[(ISD::BUILTIN_OP_END+CHAR_BIT-1)/CHAR_BIT];\n\n  /// For operations that must be promoted to a specific type, this holds the\n  /// destination type.  This map should be sparse, so don't hold it as an\n  /// array.\n  ///\n  /// Targets add entries to this map with AddPromotedToType(..), clients access\n  /// this with getTypeToPromoteTo(..).\n  std::map<std::pair<unsigned, MVT::SimpleValueType>, MVT::SimpleValueType>\n    PromoteToType;\n\n  /// Stores the name each libcall.\n  const char *LibcallRoutineNames[RTLIB::UNKNOWN_LIBCALL + 1];\n\n  /// The ISD::CondCode that should be used to test the result of each of the\n  /// comparison libcall against zero.\n  ISD::CondCode CmpLibcallCCs[RTLIB::UNKNOWN_LIBCALL];\n\n  /// Stores the CallingConv that should be used for each libcall.\n  CallingConv::ID LibcallCallingConvs[RTLIB::UNKNOWN_LIBCALL];\n\n  /// Set default libcall names and calling conventions.\n  void InitLibcalls(const Triple &TT);\n\n  /// The bits of IndexedModeActions used to store the legalisation actions\n  /// We store the data as   | ML | MS |  L |  S | each taking 4 bits.\n  enum IndexedModeActionsBits {\n    IMAB_Store = 0,\n    IMAB_Load = 4,\n    IMAB_MaskedStore = 8,\n    IMAB_MaskedLoad = 12\n  };\n\n  void setIndexedModeAction(unsigned IdxMode, MVT VT, unsigned Shift,\n                            LegalizeAction Action) {\n    assert(VT.isValid() && IdxMode < ISD::LAST_INDEXED_MODE &&\n           (unsigned)Action < 0xf && \"Table isn't big enough!\");\n    unsigned Ty = (unsigned)VT.SimpleTy;\n    IndexedModeActions[Ty][IdxMode] &= ~(0xf << Shift);\n    IndexedModeActions[Ty][IdxMode] |= ((uint16_t)Action) << Shift;\n  }\n\n  LegalizeAction getIndexedModeAction(unsigned IdxMode, MVT VT,\n                                      unsigned Shift) const {\n    assert(IdxMode < ISD::LAST_INDEXED_MODE && VT.isValid() &&\n           \"Table isn't big enough!\");\n    unsigned Ty = (unsigned)VT.SimpleTy;\n    return (LegalizeAction)((IndexedModeActions[Ty][IdxMode] >> Shift) & 0xf);\n  }\n\nprotected:\n  /// Return true if the extension represented by \\p I is free.\n  /// \\pre \\p I is a sign, zero, or fp extension and\n  ///      is[Z|FP]ExtFree of the related types is not true.\n  virtual bool isExtFreeImpl(const Instruction *I) const { return false; }\n\n  /// Depth that GatherAllAliases should should continue looking for chain\n  /// dependencies when trying to find a more preferable chain. As an\n  /// approximation, this should be more than the number of consecutive stores\n  /// expected to be merged.\n  unsigned GatherAllAliasesMaxDepth;\n\n  /// \\brief Specify maximum number of store instructions per memset call.\n  ///\n  /// When lowering \\@llvm.memset this field specifies the maximum number of\n  /// store operations that may be substituted for the call to memset. Targets\n  /// must set this value based on the cost threshold for that target. Targets\n  /// should assume that the memset will be done using as many of the largest\n  /// store operations first, followed by smaller ones, if necessary, per\n  /// alignment restrictions. For example, storing 9 bytes on a 32-bit machine\n  /// with 16-bit alignment would result in four 2-byte stores and one 1-byte\n  /// store.  This only applies to setting a constant array of a constant size.\n  unsigned MaxStoresPerMemset;\n  /// Likewise for functions with the OptSize attribute.\n  unsigned MaxStoresPerMemsetOptSize;\n\n  /// \\brief Specify maximum number of store instructions per memcpy call.\n  ///\n  /// When lowering \\@llvm.memcpy this field specifies the maximum number of\n  /// store operations that may be substituted for a call to memcpy. Targets\n  /// must set this value based on the cost threshold for that target. Targets\n  /// should assume that the memcpy will be done using as many of the largest\n  /// store operations first, followed by smaller ones, if necessary, per\n  /// alignment restrictions. For example, storing 7 bytes on a 32-bit machine\n  /// with 32-bit alignment would result in one 4-byte store, a one 2-byte store\n  /// and one 1-byte store. This only applies to copying a constant array of\n  /// constant size.\n  unsigned MaxStoresPerMemcpy;\n  /// Likewise for functions with the OptSize attribute.\n  unsigned MaxStoresPerMemcpyOptSize;\n  /// \\brief Specify max number of store instructions to glue in inlined memcpy.\n  ///\n  /// When memcpy is inlined based on MaxStoresPerMemcpy, specify maximum number\n  /// of store instructions to keep together. This helps in pairing and\n  //  vectorization later on.\n  unsigned MaxGluedStoresPerMemcpy = 0;\n\n  /// \\brief Specify maximum number of load instructions per memcmp call.\n  ///\n  /// When lowering \\@llvm.memcmp this field specifies the maximum number of\n  /// pairs of load operations that may be substituted for a call to memcmp.\n  /// Targets must set this value based on the cost threshold for that target.\n  /// Targets should assume that the memcmp will be done using as many of the\n  /// largest load operations first, followed by smaller ones, if necessary, per\n  /// alignment restrictions. For example, loading 7 bytes on a 32-bit machine\n  /// with 32-bit alignment would result in one 4-byte load, a one 2-byte load\n  /// and one 1-byte load. This only applies to copying a constant array of\n  /// constant size.\n  unsigned MaxLoadsPerMemcmp;\n  /// Likewise for functions with the OptSize attribute.\n  unsigned MaxLoadsPerMemcmpOptSize;\n\n  /// \\brief Specify maximum number of store instructions per memmove call.\n  ///\n  /// When lowering \\@llvm.memmove this field specifies the maximum number of\n  /// store instructions that may be substituted for a call to memmove. Targets\n  /// must set this value based on the cost threshold for that target. Targets\n  /// should assume that the memmove will be done using as many of the largest\n  /// store operations first, followed by smaller ones, if necessary, per\n  /// alignment restrictions. For example, moving 9 bytes on a 32-bit machine\n  /// with 8-bit alignment would result in nine 1-byte stores.  This only\n  /// applies to copying a constant array of constant size.\n  unsigned MaxStoresPerMemmove;\n  /// Likewise for functions with the OptSize attribute.\n  unsigned MaxStoresPerMemmoveOptSize;\n\n  /// Tells the code generator that select is more expensive than a branch if\n  /// the branch is usually predicted right.\n  bool PredictableSelectIsExpensive;\n\n  /// \\see enableExtLdPromotion.\n  bool EnableExtLdPromotion;\n\n  /// Return true if the value types that can be represented by the specified\n  /// register class are all legal.\n  bool isLegalRC(const TargetRegisterInfo &TRI,\n                 const TargetRegisterClass &RC) const;\n\n  /// Replace/modify any TargetFrameIndex operands with a targte-dependent\n  /// sequence of memory operands that is recognized by PrologEpilogInserter.\n  MachineBasicBlock *emitPatchPoint(MachineInstr &MI,\n                                    MachineBasicBlock *MBB) const;\n\n  bool IsStrictFPEnabled;\n};\n\n/// This class defines information used to lower LLVM code to legal SelectionDAG\n/// operators that the target instruction selector can accept natively.\n///\n/// This class also defines callbacks that targets must implement to lower\n/// target-specific constructs to SelectionDAG operators.\nclass TargetLowering : public TargetLoweringBase {\npublic:\n  struct DAGCombinerInfo;\n  struct MakeLibCallOptions;\n\n  TargetLowering(const TargetLowering &) = delete;\n  TargetLowering &operator=(const TargetLowering &) = delete;\n\n  explicit TargetLowering(const TargetMachine &TM);\n\n  bool isPositionIndependent() const;\n\n  virtual bool isSDNodeSourceOfDivergence(const SDNode *N,\n                                          FunctionLoweringInfo *FLI,\n                                          LegacyDivergenceAnalysis *DA) const {\n    return false;\n  }\n\n  virtual bool isSDNodeAlwaysUniform(const SDNode * N) const {\n    return false;\n  }\n\n  /// Returns true by value, base pointer and offset pointer and addressing mode\n  /// by reference if the node's address can be legally represented as\n  /// pre-indexed load / store address.\n  virtual bool getPreIndexedAddressParts(SDNode * /*N*/, SDValue &/*Base*/,\n                                         SDValue &/*Offset*/,\n                                         ISD::MemIndexedMode &/*AM*/,\n                                         SelectionDAG &/*DAG*/) const {\n    return false;\n  }\n\n  /// Returns true by value, base pointer and offset pointer and addressing mode\n  /// by reference if this node can be combined with a load / store to form a\n  /// post-indexed load / store.\n  virtual bool getPostIndexedAddressParts(SDNode * /*N*/, SDNode * /*Op*/,\n                                          SDValue &/*Base*/,\n                                          SDValue &/*Offset*/,\n                                          ISD::MemIndexedMode &/*AM*/,\n                                          SelectionDAG &/*DAG*/) const {\n    return false;\n  }\n\n  /// Returns true if the specified base+offset is a legal indexed addressing\n  /// mode for this target. \\p MI is the load or store instruction that is being\n  /// considered for transformation.\n  virtual bool isIndexingLegal(MachineInstr &MI, Register Base, Register Offset,\n                               bool IsPre, MachineRegisterInfo &MRI) const {\n    return false;\n  }\n\n  /// Return the entry encoding for a jump table in the current function.  The\n  /// returned value is a member of the MachineJumpTableInfo::JTEntryKind enum.\n  virtual unsigned getJumpTableEncoding() const;\n\n  virtual const MCExpr *\n  LowerCustomJumpTableEntry(const MachineJumpTableInfo * /*MJTI*/,\n                            const MachineBasicBlock * /*MBB*/, unsigned /*uid*/,\n                            MCContext &/*Ctx*/) const {\n    llvm_unreachable(\"Need to implement this hook if target has custom JTIs\");\n  }\n\n  /// Returns relocation base for the given PIC jumptable.\n  virtual SDValue getPICJumpTableRelocBase(SDValue Table,\n                                           SelectionDAG &DAG) const;\n\n  /// This returns the relocation base for the given PIC jumptable, the same as\n  /// getPICJumpTableRelocBase, but as an MCExpr.\n  virtual const MCExpr *\n  getPICJumpTableRelocBaseExpr(const MachineFunction *MF,\n                               unsigned JTI, MCContext &Ctx) const;\n\n  /// Return true if folding a constant offset with the given GlobalAddress is\n  /// legal.  It is frequently not legal in PIC relocation models.\n  virtual bool isOffsetFoldingLegal(const GlobalAddressSDNode *GA) const;\n\n  bool isInTailCallPosition(SelectionDAG &DAG, SDNode *Node,\n                            SDValue &Chain) const;\n\n  void softenSetCCOperands(SelectionDAG &DAG, EVT VT, SDValue &NewLHS,\n                           SDValue &NewRHS, ISD::CondCode &CCCode,\n                           const SDLoc &DL, const SDValue OldLHS,\n                           const SDValue OldRHS) const;\n\n  void softenSetCCOperands(SelectionDAG &DAG, EVT VT, SDValue &NewLHS,\n                           SDValue &NewRHS, ISD::CondCode &CCCode,\n                           const SDLoc &DL, const SDValue OldLHS,\n                           const SDValue OldRHS, SDValue &Chain,\n                           bool IsSignaling = false) const;\n\n  /// Returns a pair of (return value, chain).\n  /// It is an error to pass RTLIB::UNKNOWN_LIBCALL as \\p LC.\n  std::pair<SDValue, SDValue> makeLibCall(SelectionDAG &DAG, RTLIB::Libcall LC,\n                                          EVT RetVT, ArrayRef<SDValue> Ops,\n                                          MakeLibCallOptions CallOptions,\n                                          const SDLoc &dl,\n                                          SDValue Chain = SDValue()) const;\n\n  /// Check whether parameters to a call that are passed in callee saved\n  /// registers are the same as from the calling function.  This needs to be\n  /// checked for tail call eligibility.\n  bool parametersInCSRMatch(const MachineRegisterInfo &MRI,\n      const uint32_t *CallerPreservedMask,\n      const SmallVectorImpl<CCValAssign> &ArgLocs,\n      const SmallVectorImpl<SDValue> &OutVals) const;\n\n  //===--------------------------------------------------------------------===//\n  // TargetLowering Optimization Methods\n  //\n\n  /// A convenience struct that encapsulates a DAG, and two SDValues for\n  /// returning information from TargetLowering to its clients that want to\n  /// combine.\n  struct TargetLoweringOpt {\n    SelectionDAG &DAG;\n    bool LegalTys;\n    bool LegalOps;\n    SDValue Old;\n    SDValue New;\n\n    explicit TargetLoweringOpt(SelectionDAG &InDAG,\n                               bool LT, bool LO) :\n      DAG(InDAG), LegalTys(LT), LegalOps(LO) {}\n\n    bool LegalTypes() const { return LegalTys; }\n    bool LegalOperations() const { return LegalOps; }\n\n    bool CombineTo(SDValue O, SDValue N) {\n      Old = O;\n      New = N;\n      return true;\n    }\n  };\n\n  /// Determines the optimal series of memory ops to replace the memset / memcpy.\n  /// Return true if the number of memory ops is below the threshold (Limit).\n  /// It returns the types of the sequence of memory ops to perform\n  /// memset / memcpy by reference.\n  bool findOptimalMemOpLowering(std::vector<EVT> &MemOps, unsigned Limit,\n                                const MemOp &Op, unsigned DstAS, unsigned SrcAS,\n                                const AttributeList &FuncAttributes) const;\n\n  /// Check to see if the specified operand of the specified instruction is a\n  /// constant integer.  If so, check to see if there are any bits set in the\n  /// constant that are not demanded.  If so, shrink the constant and return\n  /// true.\n  bool ShrinkDemandedConstant(SDValue Op, const APInt &DemandedBits,\n                              const APInt &DemandedElts,\n                              TargetLoweringOpt &TLO) const;\n\n  /// Helper wrapper around ShrinkDemandedConstant, demanding all elements.\n  bool ShrinkDemandedConstant(SDValue Op, const APInt &DemandedBits,\n                              TargetLoweringOpt &TLO) const;\n\n  // Target hook to do target-specific const optimization, which is called by\n  // ShrinkDemandedConstant. This function should return true if the target\n  // doesn't want ShrinkDemandedConstant to further optimize the constant.\n  virtual bool targetShrinkDemandedConstant(SDValue Op,\n                                            const APInt &DemandedBits,\n                                            const APInt &DemandedElts,\n                                            TargetLoweringOpt &TLO) const {\n    return false;\n  }\n\n  /// Convert x+y to (VT)((SmallVT)x+(SmallVT)y) if the casts are free.  This\n  /// uses isZExtFree and ZERO_EXTEND for the widening cast, but it could be\n  /// generalized for targets with other types of implicit widening casts.\n  bool ShrinkDemandedOp(SDValue Op, unsigned BitWidth, const APInt &Demanded,\n                        TargetLoweringOpt &TLO) const;\n\n  /// Look at Op.  At this point, we know that only the DemandedBits bits of the\n  /// result of Op are ever used downstream.  If we can use this information to\n  /// simplify Op, create a new simplified DAG node and return true, returning\n  /// the original and new nodes in Old and New.  Otherwise, analyze the\n  /// expression and return a mask of KnownOne and KnownZero bits for the\n  /// expression (used to simplify the caller).  The KnownZero/One bits may only\n  /// be accurate for those bits in the Demanded masks.\n  /// \\p AssumeSingleUse When this parameter is true, this function will\n  ///    attempt to simplify \\p Op even if there are multiple uses.\n  ///    Callers are responsible for correctly updating the DAG based on the\n  ///    results of this function, because simply replacing replacing TLO.Old\n  ///    with TLO.New will be incorrect when this parameter is true and TLO.Old\n  ///    has multiple uses.\n  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,\n                            const APInt &DemandedElts, KnownBits &Known,\n                            TargetLoweringOpt &TLO, unsigned Depth = 0,\n                            bool AssumeSingleUse = false) const;\n\n  /// Helper wrapper around SimplifyDemandedBits, demanding all elements.\n  /// Adds Op back to the worklist upon success.\n  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,\n                            KnownBits &Known, TargetLoweringOpt &TLO,\n                            unsigned Depth = 0,\n                            bool AssumeSingleUse = false) const;\n\n  /// Helper wrapper around SimplifyDemandedBits.\n  /// Adds Op back to the worklist upon success.\n  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,\n                            DAGCombinerInfo &DCI) const;\n\n  /// More limited version of SimplifyDemandedBits that can be used to \"look\n  /// through\" ops that don't contribute to the DemandedBits/DemandedElts -\n  /// bitwise ops etc.\n  SDValue SimplifyMultipleUseDemandedBits(SDValue Op, const APInt &DemandedBits,\n                                          const APInt &DemandedElts,\n                                          SelectionDAG &DAG,\n                                          unsigned Depth) const;\n\n  /// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all\n  /// elements.\n  SDValue SimplifyMultipleUseDemandedBits(SDValue Op, const APInt &DemandedBits,\n                                          SelectionDAG &DAG,\n                                          unsigned Depth = 0) const;\n\n  /// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all\n  /// bits from only some vector elements.\n  SDValue SimplifyMultipleUseDemandedVectorElts(SDValue Op,\n                                                const APInt &DemandedElts,\n                                                SelectionDAG &DAG,\n                                                unsigned Depth = 0) const;\n\n  /// Look at Vector Op. At this point, we know that only the DemandedElts\n  /// elements of the result of Op are ever used downstream.  If we can use\n  /// this information to simplify Op, create a new simplified DAG node and\n  /// return true, storing the original and new nodes in TLO.\n  /// Otherwise, analyze the expression and return a mask of KnownUndef and\n  /// KnownZero elements for the expression (used to simplify the caller).\n  /// The KnownUndef/Zero elements may only be accurate for those bits\n  /// in the DemandedMask.\n  /// \\p AssumeSingleUse When this parameter is true, this function will\n  ///    attempt to simplify \\p Op even if there are multiple uses.\n  ///    Callers are responsible for correctly updating the DAG based on the\n  ///    results of this function, because simply replacing replacing TLO.Old\n  ///    with TLO.New will be incorrect when this parameter is true and TLO.Old\n  ///    has multiple uses.\n  bool SimplifyDemandedVectorElts(SDValue Op, const APInt &DemandedEltMask,\n                                  APInt &KnownUndef, APInt &KnownZero,\n                                  TargetLoweringOpt &TLO, unsigned Depth = 0,\n                                  bool AssumeSingleUse = false) const;\n\n  /// Helper wrapper around SimplifyDemandedVectorElts.\n  /// Adds Op back to the worklist upon success.\n  bool SimplifyDemandedVectorElts(SDValue Op, const APInt &DemandedElts,\n                                  APInt &KnownUndef, APInt &KnownZero,\n                                  DAGCombinerInfo &DCI) const;\n\n  /// Determine which of the bits specified in Mask are known to be either zero\n  /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts\n  /// argument allows us to only collect the known bits that are shared by the\n  /// requested vector elements.\n  virtual void computeKnownBitsForTargetNode(const SDValue Op,\n                                             KnownBits &Known,\n                                             const APInt &DemandedElts,\n                                             const SelectionDAG &DAG,\n                                             unsigned Depth = 0) const;\n\n  /// Determine which of the bits specified in Mask are known to be either zero\n  /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts\n  /// argument allows us to only collect the known bits that are shared by the\n  /// requested vector elements. This is for GISel.\n  virtual void computeKnownBitsForTargetInstr(GISelKnownBits &Analysis,\n                                              Register R, KnownBits &Known,\n                                              const APInt &DemandedElts,\n                                              const MachineRegisterInfo &MRI,\n                                              unsigned Depth = 0) const;\n\n  /// Determine the known alignment for the pointer value \\p R. This is can\n  /// typically be inferred from the number of low known 0 bits. However, for a\n  /// pointer with a non-integral address space, the alignment value may be\n  /// independent from the known low bits.\n  virtual Align computeKnownAlignForTargetInstr(GISelKnownBits &Analysis,\n                                                Register R,\n                                                const MachineRegisterInfo &MRI,\n                                                unsigned Depth = 0) const;\n\n  /// Determine which of the bits of FrameIndex \\p FIOp are known to be 0.\n  /// Default implementation computes low bits based on alignment\n  /// information. This should preserve known bits passed into it.\n  virtual void computeKnownBitsForFrameIndex(int FIOp,\n                                             KnownBits &Known,\n                                             const MachineFunction &MF) const;\n\n  /// This method can be implemented by targets that want to expose additional\n  /// information about sign bits to the DAG Combiner. The DemandedElts\n  /// argument allows us to only collect the minimum sign bits that are shared\n  /// by the requested vector elements.\n  virtual unsigned ComputeNumSignBitsForTargetNode(SDValue Op,\n                                                   const APInt &DemandedElts,\n                                                   const SelectionDAG &DAG,\n                                                   unsigned Depth = 0) const;\n\n  /// This method can be implemented by targets that want to expose additional\n  /// information about sign bits to GlobalISel combiners. The DemandedElts\n  /// argument allows us to only collect the minimum sign bits that are shared\n  /// by the requested vector elements.\n  virtual unsigned computeNumSignBitsForTargetInstr(GISelKnownBits &Analysis,\n                                                    Register R,\n                                                    const APInt &DemandedElts,\n                                                    const MachineRegisterInfo &MRI,\n                                                    unsigned Depth = 0) const;\n\n  /// Attempt to simplify any target nodes based on the demanded vector\n  /// elements, returning true on success. Otherwise, analyze the expression and\n  /// return a mask of KnownUndef and KnownZero elements for the expression\n  /// (used to simplify the caller). The KnownUndef/Zero elements may only be\n  /// accurate for those bits in the DemandedMask.\n  virtual bool SimplifyDemandedVectorEltsForTargetNode(\n      SDValue Op, const APInt &DemandedElts, APInt &KnownUndef,\n      APInt &KnownZero, TargetLoweringOpt &TLO, unsigned Depth = 0) const;\n\n  /// Attempt to simplify any target nodes based on the demanded bits/elts,\n  /// returning true on success. Otherwise, analyze the\n  /// expression and return a mask of KnownOne and KnownZero bits for the\n  /// expression (used to simplify the caller).  The KnownZero/One bits may only\n  /// be accurate for those bits in the Demanded masks.\n  virtual bool SimplifyDemandedBitsForTargetNode(SDValue Op,\n                                                 const APInt &DemandedBits,\n                                                 const APInt &DemandedElts,\n                                                 KnownBits &Known,\n                                                 TargetLoweringOpt &TLO,\n                                                 unsigned Depth = 0) const;\n\n  /// More limited version of SimplifyDemandedBits that can be used to \"look\n  /// through\" ops that don't contribute to the DemandedBits/DemandedElts -\n  /// bitwise ops etc.\n  virtual SDValue SimplifyMultipleUseDemandedBitsForTargetNode(\n      SDValue Op, const APInt &DemandedBits, const APInt &DemandedElts,\n      SelectionDAG &DAG, unsigned Depth) const;\n\n  /// Tries to build a legal vector shuffle using the provided parameters\n  /// or equivalent variations. The Mask argument maybe be modified as the\n  /// function tries different variations.\n  /// Returns an empty SDValue if the operation fails.\n  SDValue buildLegalVectorShuffle(EVT VT, const SDLoc &DL, SDValue N0,\n                                  SDValue N1, MutableArrayRef<int> Mask,\n                                  SelectionDAG &DAG) const;\n\n  /// This method returns the constant pool value that will be loaded by LD.\n  /// NOTE: You must check for implicit extensions of the constant by LD.\n  virtual const Constant *getTargetConstantFromLoad(LoadSDNode *LD) const;\n\n  /// If \\p SNaN is false, \\returns true if \\p Op is known to never be any\n  /// NaN. If \\p sNaN is true, returns if \\p Op is known to never be a signaling\n  /// NaN.\n  virtual bool isKnownNeverNaNForTargetNode(SDValue Op,\n                                            const SelectionDAG &DAG,\n                                            bool SNaN = false,\n                                            unsigned Depth = 0) const;\n  struct DAGCombinerInfo {\n    void *DC;  // The DAG Combiner object.\n    CombineLevel Level;\n    bool CalledByLegalizer;\n\n  public:\n    SelectionDAG &DAG;\n\n    DAGCombinerInfo(SelectionDAG &dag, CombineLevel level,  bool cl, void *dc)\n      : DC(dc), Level(level), CalledByLegalizer(cl), DAG(dag) {}\n\n    bool isBeforeLegalize() const { return Level == BeforeLegalizeTypes; }\n    bool isBeforeLegalizeOps() const { return Level < AfterLegalizeVectorOps; }\n    bool isAfterLegalizeDAG() const { return Level >= AfterLegalizeDAG; }\n    CombineLevel getDAGCombineLevel() { return Level; }\n    bool isCalledByLegalizer() const { return CalledByLegalizer; }\n\n    void AddToWorklist(SDNode *N);\n    SDValue CombineTo(SDNode *N, ArrayRef<SDValue> To, bool AddTo = true);\n    SDValue CombineTo(SDNode *N, SDValue Res, bool AddTo = true);\n    SDValue CombineTo(SDNode *N, SDValue Res0, SDValue Res1, bool AddTo = true);\n\n    bool recursivelyDeleteUnusedNodes(SDNode *N);\n\n    void CommitTargetLoweringOpt(const TargetLoweringOpt &TLO);\n  };\n\n  /// Return if the N is a constant or constant vector equal to the true value\n  /// from getBooleanContents().\n  bool isConstTrueVal(const SDNode *N) const;\n\n  /// Return if the N is a constant or constant vector equal to the false value\n  /// from getBooleanContents().\n  bool isConstFalseVal(const SDNode *N) const;\n\n  /// Return if \\p N is a True value when extended to \\p VT.\n  bool isExtendedTrueVal(const ConstantSDNode *N, EVT VT, bool SExt) const;\n\n  /// Try to simplify a setcc built with the specified operands and cc. If it is\n  /// unable to simplify it, return a null SDValue.\n  SDValue SimplifySetCC(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,\n                        bool foldBooleans, DAGCombinerInfo &DCI,\n                        const SDLoc &dl) const;\n\n  // For targets which wrap address, unwrap for analysis.\n  virtual SDValue unwrapAddress(SDValue N) const { return N; }\n\n  /// Returns true (and the GlobalValue and the offset) if the node is a\n  /// GlobalAddress + offset.\n  virtual bool\n  isGAPlusOffset(SDNode *N, const GlobalValue* &GA, int64_t &Offset) const;\n\n  /// This method will be invoked for all target nodes and for any\n  /// target-independent nodes that the target has registered with invoke it\n  /// for.\n  ///\n  /// The semantics are as follows:\n  /// Return Value:\n  ///   SDValue.Val == 0   - No change was made\n  ///   SDValue.Val == N   - N was replaced, is dead, and is already handled.\n  ///   otherwise          - N should be replaced by the returned Operand.\n  ///\n  /// In addition, methods provided by DAGCombinerInfo may be used to perform\n  /// more complex transformations.\n  ///\n  virtual SDValue PerformDAGCombine(SDNode *N, DAGCombinerInfo &DCI) const;\n\n  /// Return true if it is profitable to move this shift by a constant amount\n  /// though its operand, adjusting any immediate operands as necessary to\n  /// preserve semantics. This transformation may not be desirable if it\n  /// disrupts a particularly auspicious target-specific tree (e.g. bitfield\n  /// extraction in AArch64). By default, it returns true.\n  ///\n  /// @param N the shift node\n  /// @param Level the current DAGCombine legalization level.\n  virtual bool isDesirableToCommuteWithShift(const SDNode *N,\n                                             CombineLevel Level) const {\n    return true;\n  }\n\n  /// Return true if the target has native support for the specified value type\n  /// and it is 'desirable' to use the type for the given node type. e.g. On x86\n  /// i16 is legal, but undesirable since i16 instruction encodings are longer\n  /// and some i16 instructions are slow.\n  virtual bool isTypeDesirableForOp(unsigned /*Opc*/, EVT VT) const {\n    // By default, assume all legal types are desirable.\n    return isTypeLegal(VT);\n  }\n\n  /// Return true if it is profitable for dag combiner to transform a floating\n  /// point op of specified opcode to a equivalent op of an integer\n  /// type. e.g. f32 load -> i32 load can be profitable on ARM.\n  virtual bool isDesirableToTransformToIntegerOp(unsigned /*Opc*/,\n                                                 EVT /*VT*/) const {\n    return false;\n  }\n\n  /// This method query the target whether it is beneficial for dag combiner to\n  /// promote the specified node. If true, it should return the desired\n  /// promotion type by reference.\n  virtual bool IsDesirableToPromoteOp(SDValue /*Op*/, EVT &/*PVT*/) const {\n    return false;\n  }\n\n  /// Return true if the target supports swifterror attribute. It optimizes\n  /// loads and stores to reading and writing a specific register.\n  virtual bool supportSwiftError() const {\n    return false;\n  }\n\n  /// Return true if the target supports that a subset of CSRs for the given\n  /// machine function is handled explicitly via copies.\n  virtual bool supportSplitCSR(MachineFunction *MF) const {\n    return false;\n  }\n\n  /// Perform necessary initialization to handle a subset of CSRs explicitly\n  /// via copies. This function is called at the beginning of instruction\n  /// selection.\n  virtual void initializeSplitCSR(MachineBasicBlock *Entry) const {\n    llvm_unreachable(\"Not Implemented\");\n  }\n\n  /// Insert explicit copies in entry and exit blocks. We copy a subset of\n  /// CSRs to virtual registers in the entry block, and copy them back to\n  /// physical registers in the exit blocks. This function is called at the end\n  /// of instruction selection.\n  virtual void insertCopiesSplitCSR(\n      MachineBasicBlock *Entry,\n      const SmallVectorImpl<MachineBasicBlock *> &Exits) const {\n    llvm_unreachable(\"Not Implemented\");\n  }\n\n  /// Return the newly negated expression if the cost is not expensive and\n  /// set the cost in \\p Cost to indicate that if it is cheaper or neutral to\n  /// do the negation.\n  virtual SDValue getNegatedExpression(SDValue Op, SelectionDAG &DAG,\n                                       bool LegalOps, bool OptForSize,\n                                       NegatibleCost &Cost,\n                                       unsigned Depth = 0) const;\n\n  /// This is the helper function to return the newly negated expression only\n  /// when the cost is cheaper.\n  SDValue getCheaperNegatedExpression(SDValue Op, SelectionDAG &DAG,\n                                      bool LegalOps, bool OptForSize,\n                                      unsigned Depth = 0) const {\n    NegatibleCost Cost = NegatibleCost::Expensive;\n    SDValue Neg =\n        getNegatedExpression(Op, DAG, LegalOps, OptForSize, Cost, Depth);\n    if (Neg && Cost == NegatibleCost::Cheaper)\n      return Neg;\n    // Remove the new created node to avoid the side effect to the DAG.\n    if (Neg && Neg.getNode()->use_empty())\n      DAG.RemoveDeadNode(Neg.getNode());\n    return SDValue();\n  }\n\n  /// This is the helper function to return the newly negated expression if\n  /// the cost is not expensive.\n  SDValue getNegatedExpression(SDValue Op, SelectionDAG &DAG, bool LegalOps,\n                               bool OptForSize, unsigned Depth = 0) const {\n    NegatibleCost Cost = NegatibleCost::Expensive;\n    return getNegatedExpression(Op, DAG, LegalOps, OptForSize, Cost, Depth);\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Lowering methods - These methods must be implemented by targets so that\n  // the SelectionDAGBuilder code knows how to lower these.\n  //\n\n  /// Target-specific splitting of values into parts that fit a register\n  /// storing a legal type\n  virtual bool splitValueIntoRegisterParts(SelectionDAG &DAG, const SDLoc &DL,\n                                           SDValue Val, SDValue *Parts,\n                                           unsigned NumParts, MVT PartVT,\n                                           Optional<CallingConv::ID> CC) const {\n    return false;\n  }\n\n  /// Target-specific combining of register parts into its original value\n  virtual SDValue\n  joinRegisterPartsIntoValue(SelectionDAG &DAG, const SDLoc &DL,\n                             const SDValue *Parts, unsigned NumParts,\n                             MVT PartVT, EVT ValueVT,\n                             Optional<CallingConv::ID> CC) const {\n    return SDValue();\n  }\n\n  /// This hook must be implemented to lower the incoming (formal) arguments,\n  /// described by the Ins array, into the specified DAG. The implementation\n  /// should fill in the InVals array with legal-type argument values, and\n  /// return the resulting token chain value.\n  virtual SDValue LowerFormalArguments(\n      SDValue /*Chain*/, CallingConv::ID /*CallConv*/, bool /*isVarArg*/,\n      const SmallVectorImpl<ISD::InputArg> & /*Ins*/, const SDLoc & /*dl*/,\n      SelectionDAG & /*DAG*/, SmallVectorImpl<SDValue> & /*InVals*/) const {\n    llvm_unreachable(\"Not Implemented\");\n  }\n\n  /// This structure contains all information that is necessary for lowering\n  /// calls. It is passed to TLI::LowerCallTo when the SelectionDAG builder\n  /// needs to lower a call, and targets will see this struct in their LowerCall\n  /// implementation.\n  struct CallLoweringInfo {\n    SDValue Chain;\n    Type *RetTy = nullptr;\n    bool RetSExt           : 1;\n    bool RetZExt           : 1;\n    bool IsVarArg          : 1;\n    bool IsInReg           : 1;\n    bool DoesNotReturn     : 1;\n    bool IsReturnValueUsed : 1;\n    bool IsConvergent      : 1;\n    bool IsPatchPoint      : 1;\n    bool IsPreallocated : 1;\n    bool NoMerge           : 1;\n\n    // IsTailCall should be modified by implementations of\n    // TargetLowering::LowerCall that perform tail call conversions.\n    bool IsTailCall = false;\n\n    // Is Call lowering done post SelectionDAG type legalization.\n    bool IsPostTypeLegalization = false;\n\n    unsigned NumFixedArgs = -1;\n    CallingConv::ID CallConv = CallingConv::C;\n    SDValue Callee;\n    ArgListTy Args;\n    SelectionDAG &DAG;\n    SDLoc DL;\n    const CallBase *CB = nullptr;\n    SmallVector<ISD::OutputArg, 32> Outs;\n    SmallVector<SDValue, 32> OutVals;\n    SmallVector<ISD::InputArg, 32> Ins;\n    SmallVector<SDValue, 4> InVals;\n\n    CallLoweringInfo(SelectionDAG &DAG)\n        : RetSExt(false), RetZExt(false), IsVarArg(false), IsInReg(false),\n          DoesNotReturn(false), IsReturnValueUsed(true), IsConvergent(false),\n          IsPatchPoint(false), IsPreallocated(false), NoMerge(false),\n          DAG(DAG) {}\n\n    CallLoweringInfo &setDebugLoc(const SDLoc &dl) {\n      DL = dl;\n      return *this;\n    }\n\n    CallLoweringInfo &setChain(SDValue InChain) {\n      Chain = InChain;\n      return *this;\n    }\n\n    // setCallee with target/module-specific attributes\n    CallLoweringInfo &setLibCallee(CallingConv::ID CC, Type *ResultType,\n                                   SDValue Target, ArgListTy &&ArgsList) {\n      RetTy = ResultType;\n      Callee = Target;\n      CallConv = CC;\n      NumFixedArgs = ArgsList.size();\n      Args = std::move(ArgsList);\n\n      DAG.getTargetLoweringInfo().markLibCallAttributes(\n          &(DAG.getMachineFunction()), CC, Args);\n      return *this;\n    }\n\n    CallLoweringInfo &setCallee(CallingConv::ID CC, Type *ResultType,\n                                SDValue Target, ArgListTy &&ArgsList) {\n      RetTy = ResultType;\n      Callee = Target;\n      CallConv = CC;\n      NumFixedArgs = ArgsList.size();\n      Args = std::move(ArgsList);\n      return *this;\n    }\n\n    CallLoweringInfo &setCallee(Type *ResultType, FunctionType *FTy,\n                                SDValue Target, ArgListTy &&ArgsList,\n                                const CallBase &Call) {\n      RetTy = ResultType;\n\n      IsInReg = Call.hasRetAttr(Attribute::InReg);\n      DoesNotReturn =\n          Call.doesNotReturn() ||\n          (!isa<InvokeInst>(Call) && isa<UnreachableInst>(Call.getNextNode()));\n      IsVarArg = FTy->isVarArg();\n      IsReturnValueUsed = !Call.use_empty();\n      RetSExt = Call.hasRetAttr(Attribute::SExt);\n      RetZExt = Call.hasRetAttr(Attribute::ZExt);\n      NoMerge = Call.hasFnAttr(Attribute::NoMerge);\n      \n      Callee = Target;\n\n      CallConv = Call.getCallingConv();\n      NumFixedArgs = FTy->getNumParams();\n      Args = std::move(ArgsList);\n\n      CB = &Call;\n\n      return *this;\n    }\n\n    CallLoweringInfo &setInRegister(bool Value = true) {\n      IsInReg = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setNoReturn(bool Value = true) {\n      DoesNotReturn = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setVarArg(bool Value = true) {\n      IsVarArg = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setTailCall(bool Value = true) {\n      IsTailCall = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setDiscardResult(bool Value = true) {\n      IsReturnValueUsed = !Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setConvergent(bool Value = true) {\n      IsConvergent = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setSExtResult(bool Value = true) {\n      RetSExt = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setZExtResult(bool Value = true) {\n      RetZExt = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setIsPatchPoint(bool Value = true) {\n      IsPatchPoint = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setIsPreallocated(bool Value = true) {\n      IsPreallocated = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setIsPostTypeLegalization(bool Value=true) {\n      IsPostTypeLegalization = Value;\n      return *this;\n    }\n\n    ArgListTy &getArgs() {\n      return Args;\n    }\n  };\n\n  /// This structure is used to pass arguments to makeLibCall function.\n  struct MakeLibCallOptions {\n    // By passing type list before soften to makeLibCall, the target hook\n    // shouldExtendTypeInLibCall can get the original type before soften.\n    ArrayRef<EVT> OpsVTBeforeSoften;\n    EVT RetVTBeforeSoften;\n    bool IsSExt : 1;\n    bool DoesNotReturn : 1;\n    bool IsReturnValueUsed : 1;\n    bool IsPostTypeLegalization : 1;\n    bool IsSoften : 1;\n\n    MakeLibCallOptions()\n        : IsSExt(false), DoesNotReturn(false), IsReturnValueUsed(true),\n          IsPostTypeLegalization(false), IsSoften(false) {}\n\n    MakeLibCallOptions &setSExt(bool Value = true) {\n      IsSExt = Value;\n      return *this;\n    }\n\n    MakeLibCallOptions &setNoReturn(bool Value = true) {\n      DoesNotReturn = Value;\n      return *this;\n    }\n\n    MakeLibCallOptions &setDiscardResult(bool Value = true) {\n      IsReturnValueUsed = !Value;\n      return *this;\n    }\n\n    MakeLibCallOptions &setIsPostTypeLegalization(bool Value = true) {\n      IsPostTypeLegalization = Value;\n      return *this;\n    }\n\n    MakeLibCallOptions &setTypeListBeforeSoften(ArrayRef<EVT> OpsVT, EVT RetVT,\n                                                bool Value = true) {\n      OpsVTBeforeSoften = OpsVT;\n      RetVTBeforeSoften = RetVT;\n      IsSoften = Value;\n      return *this;\n    }\n  };\n\n  /// This function lowers an abstract call to a function into an actual call.\n  /// This returns a pair of operands.  The first element is the return value\n  /// for the function (if RetTy is not VoidTy).  The second element is the\n  /// outgoing token chain. It calls LowerCall to do the actual lowering.\n  std::pair<SDValue, SDValue> LowerCallTo(CallLoweringInfo &CLI) const;\n\n  /// This hook must be implemented to lower calls into the specified\n  /// DAG. The outgoing arguments to the call are described by the Outs array,\n  /// and the values to be returned by the call are described by the Ins\n  /// array. The implementation should fill in the InVals array with legal-type\n  /// return values from the call, and return the resulting token chain value.\n  virtual SDValue\n    LowerCall(CallLoweringInfo &/*CLI*/,\n              SmallVectorImpl<SDValue> &/*InVals*/) const {\n    llvm_unreachable(\"Not Implemented\");\n  }\n\n  /// Target-specific cleanup for formal ByVal parameters.\n  virtual void HandleByVal(CCState *, unsigned &, Align) const {}\n\n  /// This hook should be implemented to check whether the return values\n  /// described by the Outs array can fit into the return registers.  If false\n  /// is returned, an sret-demotion is performed.\n  virtual bool CanLowerReturn(CallingConv::ID /*CallConv*/,\n                              MachineFunction &/*MF*/, bool /*isVarArg*/,\n               const SmallVectorImpl<ISD::OutputArg> &/*Outs*/,\n               LLVMContext &/*Context*/) const\n  {\n    // Return true by default to get preexisting behavior.\n    return true;\n  }\n\n  /// This hook must be implemented to lower outgoing return values, described\n  /// by the Outs array, into the specified DAG. The implementation should\n  /// return the resulting token chain value.\n  virtual SDValue LowerReturn(SDValue /*Chain*/, CallingConv::ID /*CallConv*/,\n                              bool /*isVarArg*/,\n                              const SmallVectorImpl<ISD::OutputArg> & /*Outs*/,\n                              const SmallVectorImpl<SDValue> & /*OutVals*/,\n                              const SDLoc & /*dl*/,\n                              SelectionDAG & /*DAG*/) const {\n    llvm_unreachable(\"Not Implemented\");\n  }\n\n  /// Return true if result of the specified node is used by a return node\n  /// only. It also compute and return the input chain for the tail call.\n  ///\n  /// This is used to determine whether it is possible to codegen a libcall as\n  /// tail call at legalization time.\n  virtual bool isUsedByReturnOnly(SDNode *, SDValue &/*Chain*/) const {\n    return false;\n  }\n\n  /// Return true if the target may be able emit the call instruction as a tail\n  /// call. This is used by optimization passes to determine if it's profitable\n  /// to duplicate return instructions to enable tailcall optimization.\n  virtual bool mayBeEmittedAsTailCall(const CallInst *) const {\n    return false;\n  }\n\n  /// Return the builtin name for the __builtin___clear_cache intrinsic\n  /// Default is to invoke the clear cache library call\n  virtual const char * getClearCacheBuiltinName() const {\n    return \"__clear_cache\";\n  }\n\n  /// Return the register ID of the name passed in. Used by named register\n  /// global variables extension. There is no target-independent behaviour\n  /// so the default action is to bail.\n  virtual Register getRegisterByName(const char* RegName, LLT Ty,\n                                     const MachineFunction &MF) const {\n    report_fatal_error(\"Named registers not implemented for this target\");\n  }\n\n  /// Return the type that should be used to zero or sign extend a\n  /// zeroext/signext integer return value.  FIXME: Some C calling conventions\n  /// require the return type to be promoted, but this is not true all the time,\n  /// e.g. i1/i8/i16 on x86/x86_64. It is also not necessary for non-C calling\n  /// conventions. The frontend should handle this and include all of the\n  /// necessary information.\n  virtual EVT getTypeForExtReturn(LLVMContext &Context, EVT VT,\n                                       ISD::NodeType /*ExtendKind*/) const {\n    EVT MinVT = getRegisterType(Context, MVT::i32);\n    return VT.bitsLT(MinVT) ? MinVT : VT;\n  }\n\n  /// For some targets, an LLVM struct type must be broken down into multiple\n  /// simple types, but the calling convention specifies that the entire struct\n  /// must be passed in a block of consecutive registers.\n  virtual bool\n  functionArgumentNeedsConsecutiveRegisters(Type *Ty, CallingConv::ID CallConv,\n                                            bool isVarArg) const {\n    return false;\n  }\n\n  /// For most targets, an LLVM type must be broken down into multiple\n  /// smaller types. Usually the halves are ordered according to the endianness\n  /// but for some platform that would break. So this method will default to\n  /// matching the endianness but can be overridden.\n  virtual bool\n  shouldSplitFunctionArgumentsAsLittleEndian(const DataLayout &DL) const {\n    return DL.isLittleEndian();\n  }\n\n  /// Returns a 0 terminated array of registers that can be safely used as\n  /// scratch registers.\n  virtual const MCPhysReg *getScratchRegisters(CallingConv::ID CC) const {\n    return nullptr;\n  }\n\n  /// This callback is used to prepare for a volatile or atomic load.\n  /// It takes a chain node as input and returns the chain for the load itself.\n  ///\n  /// Having a callback like this is necessary for targets like SystemZ,\n  /// which allows a CPU to reuse the result of a previous load indefinitely,\n  /// even if a cache-coherent store is performed by another CPU.  The default\n  /// implementation does nothing.\n  virtual SDValue prepareVolatileOrAtomicLoad(SDValue Chain, const SDLoc &DL,\n                                              SelectionDAG &DAG) const {\n    return Chain;\n  }\n\n  /// Should SelectionDAG lower an atomic store of the given kind as a normal\n  /// StoreSDNode (as opposed to an AtomicSDNode)?  NOTE: The intention is to\n  /// eventually migrate all targets to the using StoreSDNodes, but porting is\n  /// being done target at a time.\n  virtual bool lowerAtomicStoreAsStoreSDNode(const StoreInst &SI) const {\n    assert(SI.isAtomic() && \"violated precondition\");\n    return false;\n  }\n\n  /// Should SelectionDAG lower an atomic load of the given kind as a normal\n  /// LoadSDNode (as opposed to an AtomicSDNode)?  NOTE: The intention is to\n  /// eventually migrate all targets to the using LoadSDNodes, but porting is\n  /// being done target at a time.\n  virtual bool lowerAtomicLoadAsLoadSDNode(const LoadInst &LI) const {\n    assert(LI.isAtomic() && \"violated precondition\");\n    return false;\n  }\n\n\n  /// This callback is invoked by the type legalizer to legalize nodes with an\n  /// illegal operand type but legal result types.  It replaces the\n  /// LowerOperation callback in the type Legalizer.  The reason we can not do\n  /// away with LowerOperation entirely is that LegalizeDAG isn't yet ready to\n  /// use this callback.\n  ///\n  /// TODO: Consider merging with ReplaceNodeResults.\n  ///\n  /// The target places new result values for the node in Results (their number\n  /// and types must exactly match those of the original return values of\n  /// the node), or leaves Results empty, which indicates that the node is not\n  /// to be custom lowered after all.\n  /// The default implementation calls LowerOperation.\n  virtual void LowerOperationWrapper(SDNode *N,\n                                     SmallVectorImpl<SDValue> &Results,\n                                     SelectionDAG &DAG) const;\n\n  /// This callback is invoked for operations that are unsupported by the\n  /// target, which are registered to use 'custom' lowering, and whose defined\n  /// values are all legal.  If the target has no operations that require custom\n  /// lowering, it need not implement this.  The default implementation of this\n  /// aborts.\n  virtual SDValue LowerOperation(SDValue Op, SelectionDAG &DAG) const;\n\n  /// This callback is invoked when a node result type is illegal for the\n  /// target, and the operation was registered to use 'custom' lowering for that\n  /// result type.  The target places new result values for the node in Results\n  /// (their number and types must exactly match those of the original return\n  /// values of the node), or leaves Results empty, which indicates that the\n  /// node is not to be custom lowered after all.\n  ///\n  /// If the target has no operations that require custom lowering, it need not\n  /// implement this.  The default implementation aborts.\n  virtual void ReplaceNodeResults(SDNode * /*N*/,\n                                  SmallVectorImpl<SDValue> &/*Results*/,\n                                  SelectionDAG &/*DAG*/) const {\n    llvm_unreachable(\"ReplaceNodeResults not implemented for this target!\");\n  }\n\n  /// This method returns the name of a target specific DAG node.\n  virtual const char *getTargetNodeName(unsigned Opcode) const;\n\n  /// This method returns a target specific FastISel object, or null if the\n  /// target does not support \"fast\" ISel.\n  virtual FastISel *createFastISel(FunctionLoweringInfo &,\n                                   const TargetLibraryInfo *) const {\n    return nullptr;\n  }\n\n  bool verifyReturnAddressArgumentIsConstant(SDValue Op,\n                                             SelectionDAG &DAG) const;\n\n  //===--------------------------------------------------------------------===//\n  // Inline Asm Support hooks\n  //\n\n  /// This hook allows the target to expand an inline asm call to be explicit\n  /// llvm code if it wants to.  This is useful for turning simple inline asms\n  /// into LLVM intrinsics, which gives the compiler more information about the\n  /// behavior of the code.\n  virtual bool ExpandInlineAsm(CallInst *) const {\n    return false;\n  }\n\n  enum ConstraintType {\n    C_Register,            // Constraint represents specific register(s).\n    C_RegisterClass,       // Constraint represents any of register(s) in class.\n    C_Memory,              // Memory constraint.\n    C_Immediate,           // Requires an immediate.\n    C_Other,               // Something else.\n    C_Unknown              // Unsupported constraint.\n  };\n\n  enum ConstraintWeight {\n    // Generic weights.\n    CW_Invalid  = -1,     // No match.\n    CW_Okay     = 0,      // Acceptable.\n    CW_Good     = 1,      // Good weight.\n    CW_Better   = 2,      // Better weight.\n    CW_Best     = 3,      // Best weight.\n\n    // Well-known weights.\n    CW_SpecificReg  = CW_Okay,    // Specific register operands.\n    CW_Register     = CW_Good,    // Register operands.\n    CW_Memory       = CW_Better,  // Memory operands.\n    CW_Constant     = CW_Best,    // Constant operand.\n    CW_Default      = CW_Okay     // Default or don't know type.\n  };\n\n  /// This contains information for each constraint that we are lowering.\n  struct AsmOperandInfo : public InlineAsm::ConstraintInfo {\n    /// This contains the actual string for the code, like \"m\".  TargetLowering\n    /// picks the 'best' code from ConstraintInfo::Codes that most closely\n    /// matches the operand.\n    std::string ConstraintCode;\n\n    /// Information about the constraint code, e.g. Register, RegisterClass,\n    /// Memory, Other, Unknown.\n    TargetLowering::ConstraintType ConstraintType = TargetLowering::C_Unknown;\n\n    /// If this is the result output operand or a clobber, this is null,\n    /// otherwise it is the incoming operand to the CallInst.  This gets\n    /// modified as the asm is processed.\n    Value *CallOperandVal = nullptr;\n\n    /// The ValueType for the operand value.\n    MVT ConstraintVT = MVT::Other;\n\n    /// Copy constructor for copying from a ConstraintInfo.\n    AsmOperandInfo(InlineAsm::ConstraintInfo Info)\n        : InlineAsm::ConstraintInfo(std::move(Info)) {}\n\n    /// Return true of this is an input operand that is a matching constraint\n    /// like \"4\".\n    bool isMatchingInputConstraint() const;\n\n    /// If this is an input matching constraint, this method returns the output\n    /// operand it matches.\n    unsigned getMatchedOperand() const;\n  };\n\n  using AsmOperandInfoVector = std::vector<AsmOperandInfo>;\n\n  /// Split up the constraint string from the inline assembly value into the\n  /// specific constraints and their prefixes, and also tie in the associated\n  /// operand values.  If this returns an empty vector, and if the constraint\n  /// string itself isn't empty, there was an error parsing.\n  virtual AsmOperandInfoVector ParseConstraints(const DataLayout &DL,\n                                                const TargetRegisterInfo *TRI,\n                                                const CallBase &Call) const;\n\n  /// Examine constraint type and operand type and determine a weight value.\n  /// The operand object must already have been set up with the operand type.\n  virtual ConstraintWeight getMultipleConstraintMatchWeight(\n      AsmOperandInfo &info, int maIndex) const;\n\n  /// Examine constraint string and operand type and determine a weight value.\n  /// The operand object must already have been set up with the operand type.\n  virtual ConstraintWeight getSingleConstraintMatchWeight(\n      AsmOperandInfo &info, const char *constraint) const;\n\n  /// Determines the constraint code and constraint type to use for the specific\n  /// AsmOperandInfo, setting OpInfo.ConstraintCode and OpInfo.ConstraintType.\n  /// If the actual operand being passed in is available, it can be passed in as\n  /// Op, otherwise an empty SDValue can be passed.\n  virtual void ComputeConstraintToUse(AsmOperandInfo &OpInfo,\n                                      SDValue Op,\n                                      SelectionDAG *DAG = nullptr) const;\n\n  /// Given a constraint, return the type of constraint it is for this target.\n  virtual ConstraintType getConstraintType(StringRef Constraint) const;\n\n  /// Given a physical register constraint (e.g.  {edx}), return the register\n  /// number and the register class for the register.\n  ///\n  /// Given a register class constraint, like 'r', if this corresponds directly\n  /// to an LLVM register class, return a register of 0 and the register class\n  /// pointer.\n  ///\n  /// This should only be used for C_Register constraints.  On error, this\n  /// returns a register number of 0 and a null register class pointer.\n  virtual std::pair<unsigned, const TargetRegisterClass *>\n  getRegForInlineAsmConstraint(const TargetRegisterInfo *TRI,\n                               StringRef Constraint, MVT VT) const;\n\n  virtual unsigned getInlineAsmMemConstraint(StringRef ConstraintCode) const {\n    if (ConstraintCode == \"m\")\n      return InlineAsm::Constraint_m;\n    return InlineAsm::Constraint_Unknown;\n  }\n\n  /// Try to replace an X constraint, which matches anything, with another that\n  /// has more specific requirements based on the type of the corresponding\n  /// operand.  This returns null if there is no replacement to make.\n  virtual const char *LowerXConstraint(EVT ConstraintVT) const;\n\n  /// Lower the specified operand into the Ops vector.  If it is invalid, don't\n  /// add anything to Ops.\n  virtual void LowerAsmOperandForConstraint(SDValue Op, std::string &Constraint,\n                                            std::vector<SDValue> &Ops,\n                                            SelectionDAG &DAG) const;\n\n  // Lower custom output constraints. If invalid, return SDValue().\n  virtual SDValue LowerAsmOutputForConstraint(SDValue &Chain, SDValue &Flag,\n                                              const SDLoc &DL,\n                                              const AsmOperandInfo &OpInfo,\n                                              SelectionDAG &DAG) const;\n\n  //===--------------------------------------------------------------------===//\n  // Div utility functions\n  //\n  SDValue BuildSDIV(SDNode *N, SelectionDAG &DAG, bool IsAfterLegalization,\n                    SmallVectorImpl<SDNode *> &Created) const;\n  SDValue BuildUDIV(SDNode *N, SelectionDAG &DAG, bool IsAfterLegalization,\n                    SmallVectorImpl<SDNode *> &Created) const;\n\n  /// Targets may override this function to provide custom SDIV lowering for\n  /// power-of-2 denominators.  If the target returns an empty SDValue, LLVM\n  /// assumes SDIV is expensive and replaces it with a series of other integer\n  /// operations.\n  virtual SDValue BuildSDIVPow2(SDNode *N, const APInt &Divisor,\n                                SelectionDAG &DAG,\n                                SmallVectorImpl<SDNode *> &Created) const;\n\n  /// Indicate whether this target prefers to combine FDIVs with the same\n  /// divisor. If the transform should never be done, return zero. If the\n  /// transform should be done, return the minimum number of divisor uses\n  /// that must exist.\n  virtual unsigned combineRepeatedFPDivisors() const {\n    return 0;\n  }\n\n  /// Hooks for building estimates in place of slower divisions and square\n  /// roots.\n\n  /// Return either a square root or its reciprocal estimate value for the input\n  /// operand.\n  /// \\p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or\n  /// 'Enabled' as set by a potential default override attribute.\n  /// If \\p RefinementSteps is 'Unspecified', the number of Newton-Raphson\n  /// refinement iterations required to generate a sufficient (though not\n  /// necessarily IEEE-754 compliant) estimate is returned in that parameter.\n  /// The boolean UseOneConstNR output is used to select a Newton-Raphson\n  /// algorithm implementation that uses either one or two constants.\n  /// The boolean Reciprocal is used to select whether the estimate is for the\n  /// square root of the input operand or the reciprocal of its square root.\n  /// A target may choose to implement its own refinement within this function.\n  /// If that's true, then return '0' as the number of RefinementSteps to avoid\n  /// any further refinement of the estimate.\n  /// An empty SDValue return means no estimate sequence can be created.\n  virtual SDValue getSqrtEstimate(SDValue Operand, SelectionDAG &DAG,\n                                  int Enabled, int &RefinementSteps,\n                                  bool &UseOneConstNR, bool Reciprocal) const {\n    return SDValue();\n  }\n\n  /// Return a reciprocal estimate value for the input operand.\n  /// \\p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or\n  /// 'Enabled' as set by a potential default override attribute.\n  /// If \\p RefinementSteps is 'Unspecified', the number of Newton-Raphson\n  /// refinement iterations required to generate a sufficient (though not\n  /// necessarily IEEE-754 compliant) estimate is returned in that parameter.\n  /// A target may choose to implement its own refinement within this function.\n  /// If that's true, then return '0' as the number of RefinementSteps to avoid\n  /// any further refinement of the estimate.\n  /// An empty SDValue return means no estimate sequence can be created.\n  virtual SDValue getRecipEstimate(SDValue Operand, SelectionDAG &DAG,\n                                   int Enabled, int &RefinementSteps) const {\n    return SDValue();\n  }\n\n  /// Return a target-dependent comparison result if the input operand is\n  /// suitable for use with a square root estimate calculation. For example, the\n  /// comparison may check if the operand is NAN, INF, zero, normal, etc. The\n  /// result should be used as the condition operand for a select or branch.\n  virtual SDValue getSqrtInputTest(SDValue Operand, SelectionDAG &DAG,\n                                   const DenormalMode &Mode) const;\n\n  /// Return a target-dependent result if the input operand is not suitable for\n  /// use with a square root estimate calculation.\n  virtual SDValue getSqrtResultForDenormInput(SDValue Operand,\n                                              SelectionDAG &DAG) const {\n    return DAG.getConstantFP(0.0, SDLoc(Operand), Operand.getValueType());\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Legalization utility functions\n  //\n\n  /// Expand a MUL or [US]MUL_LOHI of n-bit values into two or four nodes,\n  /// respectively, each computing an n/2-bit part of the result.\n  /// \\param Result A vector that will be filled with the parts of the result\n  ///        in little-endian order.\n  /// \\param LL Low bits of the LHS of the MUL.  You can use this parameter\n  ///        if you want to control how low bits are extracted from the LHS.\n  /// \\param LH High bits of the LHS of the MUL.  See LL for meaning.\n  /// \\param RL Low bits of the RHS of the MUL.  See LL for meaning\n  /// \\param RH High bits of the RHS of the MUL.  See LL for meaning.\n  /// \\returns true if the node has been expanded, false if it has not\n  bool expandMUL_LOHI(unsigned Opcode, EVT VT, const SDLoc &dl, SDValue LHS,\n                      SDValue RHS, SmallVectorImpl<SDValue> &Result, EVT HiLoVT,\n                      SelectionDAG &DAG, MulExpansionKind Kind,\n                      SDValue LL = SDValue(), SDValue LH = SDValue(),\n                      SDValue RL = SDValue(), SDValue RH = SDValue()) const;\n\n  /// Expand a MUL into two nodes.  One that computes the high bits of\n  /// the result and one that computes the low bits.\n  /// \\param HiLoVT The value type to use for the Lo and Hi nodes.\n  /// \\param LL Low bits of the LHS of the MUL.  You can use this parameter\n  ///        if you want to control how low bits are extracted from the LHS.\n  /// \\param LH High bits of the LHS of the MUL.  See LL for meaning.\n  /// \\param RL Low bits of the RHS of the MUL.  See LL for meaning\n  /// \\param RH High bits of the RHS of the MUL.  See LL for meaning.\n  /// \\returns true if the node has been expanded. false if it has not\n  bool expandMUL(SDNode *N, SDValue &Lo, SDValue &Hi, EVT HiLoVT,\n                 SelectionDAG &DAG, MulExpansionKind Kind,\n                 SDValue LL = SDValue(), SDValue LH = SDValue(),\n                 SDValue RL = SDValue(), SDValue RH = SDValue()) const;\n\n  /// Expand funnel shift.\n  /// \\param N Node to expand\n  /// \\param Result output after conversion\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandFunnelShift(SDNode *N, SDValue &Result, SelectionDAG &DAG) const;\n\n  /// Expand rotations.\n  /// \\param N Node to expand\n  /// \\param AllowVectorOps expand vector rotate, this should only be performed\n  ///        if the legalization is happening outside of LegalizeVectorOps\n  /// \\param Result output after conversion\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandROT(SDNode *N, bool AllowVectorOps, SDValue &Result,\n                 SelectionDAG &DAG) const;\n\n  /// Expand float(f32) to SINT(i64) conversion\n  /// \\param N Node to expand\n  /// \\param Result output after conversion\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandFP_TO_SINT(SDNode *N, SDValue &Result, SelectionDAG &DAG) const;\n\n  /// Expand float to UINT conversion\n  /// \\param N Node to expand\n  /// \\param Result output after conversion\n  /// \\param Chain output chain after conversion\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandFP_TO_UINT(SDNode *N, SDValue &Result, SDValue &Chain,\n                        SelectionDAG &DAG) const;\n\n  /// Expand UINT(i64) to double(f64) conversion\n  /// \\param N Node to expand\n  /// \\param Result output after conversion\n  /// \\param Chain output chain after conversion\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandUINT_TO_FP(SDNode *N, SDValue &Result, SDValue &Chain,\n                        SelectionDAG &DAG) const;\n\n  /// Expand fminnum/fmaxnum into fminnum_ieee/fmaxnum_ieee with quieted inputs.\n  SDValue expandFMINNUM_FMAXNUM(SDNode *N, SelectionDAG &DAG) const;\n\n  /// Expand FP_TO_[US]INT_SAT into FP_TO_[US]INT and selects or min/max.\n  /// \\param N Node to expand\n  /// \\returns The expansion result\n  SDValue expandFP_TO_INT_SAT(SDNode *N, SelectionDAG &DAG) const;\n\n  /// Expand CTPOP nodes. Expands vector/scalar CTPOP nodes,\n  /// vector nodes can only succeed if all operations are legal/custom.\n  /// \\param N Node to expand\n  /// \\param Result output after conversion\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandCTPOP(SDNode *N, SDValue &Result, SelectionDAG &DAG) const;\n\n  /// Expand CTLZ/CTLZ_ZERO_UNDEF nodes. Expands vector/scalar CTLZ nodes,\n  /// vector nodes can only succeed if all operations are legal/custom.\n  /// \\param N Node to expand\n  /// \\param Result output after conversion\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandCTLZ(SDNode *N, SDValue &Result, SelectionDAG &DAG) const;\n\n  /// Expand CTTZ/CTTZ_ZERO_UNDEF nodes. Expands vector/scalar CTTZ nodes,\n  /// vector nodes can only succeed if all operations are legal/custom.\n  /// \\param N Node to expand\n  /// \\param Result output after conversion\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandCTTZ(SDNode *N, SDValue &Result, SelectionDAG &DAG) const;\n\n  /// Expand ABS nodes. Expands vector/scalar ABS nodes,\n  /// vector nodes can only succeed if all operations are legal/custom.\n  /// (ABS x) -> (XOR (ADD x, (SRA x, type_size)), (SRA x, type_size))\n  /// \\param N Node to expand\n  /// \\param Result output after conversion\n  /// \\param IsNegative indicate negated abs\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandABS(SDNode *N, SDValue &Result, SelectionDAG &DAG,\n                 bool IsNegative = false) const;\n\n  /// Expand BSWAP nodes. Expands scalar/vector BSWAP nodes with i16/i32/i64\n  /// scalar types. Returns SDValue() if expand fails.\n  /// \\param N Node to expand\n  /// \\returns The expansion result or SDValue() if it fails.\n  SDValue expandBSWAP(SDNode *N, SelectionDAG &DAG) const;\n\n  /// Expand BITREVERSE nodes. Expands scalar/vector BITREVERSE nodes.\n  /// Returns SDValue() if expand fails.\n  /// \\param N Node to expand\n  /// \\returns The expansion result or SDValue() if it fails.\n  SDValue expandBITREVERSE(SDNode *N, SelectionDAG &DAG) const;\n\n  /// Turn load of vector type into a load of the individual elements.\n  /// \\param LD load to expand\n  /// \\returns BUILD_VECTOR and TokenFactor nodes.\n  std::pair<SDValue, SDValue> scalarizeVectorLoad(LoadSDNode *LD,\n                                                  SelectionDAG &DAG) const;\n\n  // Turn a store of a vector type into stores of the individual elements.\n  /// \\param ST Store with a vector value type\n  /// \\returns TokenFactor of the individual store chains.\n  SDValue scalarizeVectorStore(StoreSDNode *ST, SelectionDAG &DAG) const;\n\n  /// Expands an unaligned load to 2 half-size loads for an integer, and\n  /// possibly more for vectors.\n  std::pair<SDValue, SDValue> expandUnalignedLoad(LoadSDNode *LD,\n                                                  SelectionDAG &DAG) const;\n\n  /// Expands an unaligned store to 2 half-size stores for integer values, and\n  /// possibly more for vectors.\n  SDValue expandUnalignedStore(StoreSDNode *ST, SelectionDAG &DAG) const;\n\n  /// Increments memory address \\p Addr according to the type of the value\n  /// \\p DataVT that should be stored. If the data is stored in compressed\n  /// form, the memory address should be incremented according to the number of\n  /// the stored elements. This number is equal to the number of '1's bits\n  /// in the \\p Mask.\n  /// \\p DataVT is a vector type. \\p Mask is a vector value.\n  /// \\p DataVT and \\p Mask have the same number of vector elements.\n  SDValue IncrementMemoryAddress(SDValue Addr, SDValue Mask, const SDLoc &DL,\n                                 EVT DataVT, SelectionDAG &DAG,\n                                 bool IsCompressedMemory) const;\n\n  /// Get a pointer to vector element \\p Idx located in memory for a vector of\n  /// type \\p VecVT starting at a base address of \\p VecPtr. If \\p Idx is out of\n  /// bounds the returned pointer is unspecified, but will be within the vector\n  /// bounds.\n  SDValue getVectorElementPointer(SelectionDAG &DAG, SDValue VecPtr, EVT VecVT,\n                                  SDValue Index) const;\n\n  /// Method for building the DAG expansion of ISD::[US][MIN|MAX]. This\n  /// method accepts integers as its arguments.\n  SDValue expandIntMINMAX(SDNode *Node, SelectionDAG &DAG) const;\n\n  /// Method for building the DAG expansion of ISD::[US][ADD|SUB]SAT. This\n  /// method accepts integers as its arguments.\n  SDValue expandAddSubSat(SDNode *Node, SelectionDAG &DAG) const;\n\n  /// Method for building the DAG expansion of ISD::[US]SHLSAT. This\n  /// method accepts integers as its arguments.\n  SDValue expandShlSat(SDNode *Node, SelectionDAG &DAG) const;\n\n  /// Method for building the DAG expansion of ISD::[U|S]MULFIX[SAT]. This\n  /// method accepts integers as its arguments.\n  SDValue expandFixedPointMul(SDNode *Node, SelectionDAG &DAG) const;\n\n  /// Method for building the DAG expansion of ISD::[US]DIVFIX[SAT]. This\n  /// method accepts integers as its arguments.\n  /// Note: This method may fail if the division could not be performed\n  /// within the type. Clients must retry with a wider type if this happens.\n  SDValue expandFixedPointDiv(unsigned Opcode, const SDLoc &dl,\n                              SDValue LHS, SDValue RHS,\n                              unsigned Scale, SelectionDAG &DAG) const;\n\n  /// Method for building the DAG expansion of ISD::U(ADD|SUB)O. Expansion\n  /// always suceeds and populates the Result and Overflow arguments.\n  void expandUADDSUBO(SDNode *Node, SDValue &Result, SDValue &Overflow,\n                      SelectionDAG &DAG) const;\n\n  /// Method for building the DAG expansion of ISD::S(ADD|SUB)O. Expansion\n  /// always suceeds and populates the Result and Overflow arguments.\n  void expandSADDSUBO(SDNode *Node, SDValue &Result, SDValue &Overflow,\n                      SelectionDAG &DAG) const;\n\n  /// Method for building the DAG expansion of ISD::[US]MULO. Returns whether\n  /// expansion was successful and populates the Result and Overflow arguments.\n  bool expandMULO(SDNode *Node, SDValue &Result, SDValue &Overflow,\n                  SelectionDAG &DAG) const;\n\n  /// Expand a VECREDUCE_* into an explicit calculation. If Count is specified,\n  /// only the first Count elements of the vector are used.\n  SDValue expandVecReduce(SDNode *Node, SelectionDAG &DAG) const;\n\n  /// Expand a VECREDUCE_SEQ_* into an explicit ordered calculation.\n  SDValue expandVecReduceSeq(SDNode *Node, SelectionDAG &DAG) const;\n\n  /// Expand an SREM or UREM using SDIV/UDIV or SDIVREM/UDIVREM, if legal.\n  /// Returns true if the expansion was successful.\n  bool expandREM(SDNode *Node, SDValue &Result, SelectionDAG &DAG) const;\n\n  /// Method for building the DAG expansion of ISD::VECTOR_SPLICE. This\n  /// method accepts vectors as its arguments.\n  SDValue expandVectorSplice(SDNode *Node, SelectionDAG &DAG) const;\n\n  //===--------------------------------------------------------------------===//\n  // Instruction Emitting Hooks\n  //\n\n  /// This method should be implemented by targets that mark instructions with\n  /// the 'usesCustomInserter' flag.  These instructions are special in various\n  /// ways, which require special support to insert.  The specified MachineInstr\n  /// is created but not inserted into any basic blocks, and this method is\n  /// called to expand it into a sequence of instructions, potentially also\n  /// creating new basic blocks and control flow.\n  /// As long as the returned basic block is different (i.e., we created a new\n  /// one), the custom inserter is free to modify the rest of \\p MBB.\n  virtual MachineBasicBlock *\n  EmitInstrWithCustomInserter(MachineInstr &MI, MachineBasicBlock *MBB) const;\n\n  /// This method should be implemented by targets that mark instructions with\n  /// the 'hasPostISelHook' flag. These instructions must be adjusted after\n  /// instruction selection by target hooks.  e.g. To fill in optional defs for\n  /// ARM 's' setting instructions.\n  virtual void AdjustInstrPostInstrSelection(MachineInstr &MI,\n                                             SDNode *Node) const;\n\n  /// If this function returns true, SelectionDAGBuilder emits a\n  /// LOAD_STACK_GUARD node when it is lowering Intrinsic::stackprotector.\n  virtual bool useLoadStackGuardNode() const {\n    return false;\n  }\n\n  virtual SDValue emitStackGuardXorFP(SelectionDAG &DAG, SDValue Val,\n                                      const SDLoc &DL) const {\n    llvm_unreachable(\"not implemented for this target\");\n  }\n\n  /// Lower TLS global address SDNode for target independent emulated TLS model.\n  virtual SDValue LowerToTLSEmulatedModel(const GlobalAddressSDNode *GA,\n                                          SelectionDAG &DAG) const;\n\n  /// Expands target specific indirect branch for the case of JumpTable\n  /// expanasion.\n  virtual SDValue expandIndirectJTBranch(const SDLoc& dl, SDValue Value, SDValue Addr,\n                                         SelectionDAG &DAG) const {\n    return DAG.getNode(ISD::BRIND, dl, MVT::Other, Value, Addr);\n  }\n\n  // seteq(x, 0) -> truncate(srl(ctlz(zext(x)), log2(#bits)))\n  // If we're comparing for equality to zero and isCtlzFast is true, expose the\n  // fact that this can be implemented as a ctlz/srl pair, so that the dag\n  // combiner can fold the new nodes.\n  SDValue lowerCmpEqZeroToCtlzSrl(SDValue Op, SelectionDAG &DAG) const;\n\n  /// Give targets the chance to reduce the number of distinct addresing modes.\n  ISD::MemIndexType getCanonicalIndexType(ISD::MemIndexType IndexType,\n                                          EVT MemVT, SDValue Offsets) const;\n\nprivate:\n  SDValue foldSetCCWithAnd(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,\n                           const SDLoc &DL, DAGCombinerInfo &DCI) const;\n  SDValue foldSetCCWithBinOp(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,\n                             const SDLoc &DL, DAGCombinerInfo &DCI) const;\n\n  SDValue optimizeSetCCOfSignedTruncationCheck(EVT SCCVT, SDValue N0,\n                                               SDValue N1, ISD::CondCode Cond,\n                                               DAGCombinerInfo &DCI,\n                                               const SDLoc &DL) const;\n\n  // (X & (C l>>/<< Y)) ==/!= 0  -->  ((X <</l>> Y) & C) ==/!= 0\n  SDValue optimizeSetCCByHoistingAndByConstFromLogicalShift(\n      EVT SCCVT, SDValue N0, SDValue N1C, ISD::CondCode Cond,\n      DAGCombinerInfo &DCI, const SDLoc &DL) const;\n\n  SDValue prepareUREMEqFold(EVT SETCCVT, SDValue REMNode,\n                            SDValue CompTargetNode, ISD::CondCode Cond,\n                            DAGCombinerInfo &DCI, const SDLoc &DL,\n                            SmallVectorImpl<SDNode *> &Created) const;\n  SDValue buildUREMEqFold(EVT SETCCVT, SDValue REMNode, SDValue CompTargetNode,\n                          ISD::CondCode Cond, DAGCombinerInfo &DCI,\n                          const SDLoc &DL) const;\n\n  SDValue prepareSREMEqFold(EVT SETCCVT, SDValue REMNode,\n                            SDValue CompTargetNode, ISD::CondCode Cond,\n                            DAGCombinerInfo &DCI, const SDLoc &DL,\n                            SmallVectorImpl<SDNode *> &Created) const;\n  SDValue buildSREMEqFold(EVT SETCCVT, SDValue REMNode, SDValue CompTargetNode,\n                          ISD::CondCode Cond, DAGCombinerInfo &DCI,\n                          const SDLoc &DL) const;\n};\n\n/// Given an LLVM IR type and return type attributes, compute the return value\n/// EVTs and flags, and optionally also the offsets, if the return value is\n/// being lowered to memory.\nvoid GetReturnInfo(CallingConv::ID CC, Type *ReturnType, AttributeList attr,\n                   SmallVectorImpl<ISD::OutputArg> &Outs,\n                   const TargetLowering &TLI, const DataLayout &DL);\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_TARGETLOWERING_H\n"}, "114": {"id": 114, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.h", "content": "//===-- X86TargetTransformInfo.h - X86 specific TTI -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This file a TargetTransformInfo::Concept conforming object specific to the\n/// X86 target machine. It uses the target's detailed information to\n/// provide more precise answers to certain TTI queries, while letting the\n/// target independent and default TTI implementations handle the rest.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_TARGET_X86_X86TARGETTRANSFORMINFO_H\n#define LLVM_LIB_TARGET_X86_X86TARGETTRANSFORMINFO_H\n\n#include \"X86TargetMachine.h\"\n#include \"llvm/Analysis/TargetTransformInfo.h\"\n#include \"llvm/CodeGen/BasicTTIImpl.h\"\n\nnamespace llvm {\n\nclass InstCombiner;\n\nclass X86TTIImpl : public BasicTTIImplBase<X86TTIImpl> {\n  typedef BasicTTIImplBase<X86TTIImpl> BaseT;\n  typedef TargetTransformInfo TTI;\n  friend BaseT;\n\n  const X86Subtarget *ST;\n  const X86TargetLowering *TLI;\n\n  const X86Subtarget *getST() const { return ST; }\n  const X86TargetLowering *getTLI() const { return TLI; }\n\n  const FeatureBitset InlineFeatureIgnoreList = {\n      // This indicates the CPU is 64 bit capable not that we are in 64-bit\n      // mode.\n      X86::Feature64Bit,\n\n      // These features don't have any intrinsics or ABI effect.\n      X86::FeatureNOPL,\n      X86::FeatureCMPXCHG16B,\n      X86::FeatureLAHFSAHF,\n\n      // Codegen control options.\n      X86::FeatureFast11ByteNOP,\n      X86::FeatureFast15ByteNOP,\n      X86::FeatureFastBEXTR,\n      X86::FeatureFastHorizontalOps,\n      X86::FeatureFastLZCNT,\n      X86::FeatureFastScalarFSQRT,\n      X86::FeatureFastSHLDRotate,\n      X86::FeatureFastScalarShiftMasks,\n      X86::FeatureFastVectorShiftMasks,\n      X86::FeatureFastVariableShuffle,\n      X86::FeatureFastVectorFSQRT,\n      X86::FeatureLEAForSP,\n      X86::FeatureLEAUsesAG,\n      X86::FeatureLZCNTFalseDeps,\n      X86::FeatureBranchFusion,\n      X86::FeatureMacroFusion,\n      X86::FeaturePadShortFunctions,\n      X86::FeaturePOPCNTFalseDeps,\n      X86::FeatureSSEUnalignedMem,\n      X86::FeatureSlow3OpsLEA,\n      X86::FeatureSlowDivide32,\n      X86::FeatureSlowDivide64,\n      X86::FeatureSlowIncDec,\n      X86::FeatureSlowLEA,\n      X86::FeatureSlowPMADDWD,\n      X86::FeatureSlowPMULLD,\n      X86::FeatureSlowSHLD,\n      X86::FeatureSlowTwoMemOps,\n      X86::FeatureSlowUAMem16,\n      X86::FeaturePreferMaskRegisters,\n      X86::FeatureInsertVZEROUPPER,\n      X86::FeatureUseGLMDivSqrtCosts,\n\n      // Perf-tuning flags.\n      X86::FeatureHasFastGather,\n      X86::FeatureSlowUAMem32,\n\n      // Based on whether user set the -mprefer-vector-width command line.\n      X86::FeaturePrefer128Bit,\n      X86::FeaturePrefer256Bit,\n\n      // CPU name enums. These just follow CPU string.\n      X86::ProcIntelAtom,\n      X86::ProcIntelSLM,\n  };\n\npublic:\n  explicit X86TTIImpl(const X86TargetMachine *TM, const Function &F)\n      : BaseT(TM, F.getParent()->getDataLayout()), ST(TM->getSubtargetImpl(F)),\n        TLI(ST->getTargetLowering()) {}\n\n  /// \\name Scalar TTI Implementations\n  /// @{\n  TTI::PopcntSupportKind getPopcntSupport(unsigned TyWidth);\n\n  /// @}\n\n  /// \\name Cache TTI Implementation\n  /// @{\n  llvm::Optional<unsigned> getCacheSize(\n    TargetTransformInfo::CacheLevel Level) const override;\n  llvm::Optional<unsigned> getCacheAssociativity(\n    TargetTransformInfo::CacheLevel Level) const override;\n  /// @}\n\n  /// \\name Vector TTI Implementations\n  /// @{\n\n  unsigned getNumberOfRegisters(unsigned ClassID) const;\n  unsigned getRegisterBitWidth(bool Vector) const;\n  unsigned getLoadStoreVecRegBitWidth(unsigned AS) const;\n  unsigned getMaxInterleaveFactor(unsigned VF);\n  int getArithmeticInstrCost(\n      unsigned Opcode, Type *Ty,\n      TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput,\n      TTI::OperandValueKind Opd1Info = TTI::OK_AnyValue,\n      TTI::OperandValueKind Opd2Info = TTI::OK_AnyValue,\n      TTI::OperandValueProperties Opd1PropInfo = TTI::OP_None,\n      TTI::OperandValueProperties Opd2PropInfo = TTI::OP_None,\n      ArrayRef<const Value *> Args = ArrayRef<const Value *>(),\n      const Instruction *CxtI = nullptr);\n  int getShuffleCost(TTI::ShuffleKind Kind, VectorType *Tp, int Index,\n                     VectorType *SubTp);\n  int getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,\n                       TTI::CastContextHint CCH, TTI::TargetCostKind CostKind,\n                       const Instruction *I = nullptr);\n  int getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,\n                         CmpInst::Predicate VecPred,\n                         TTI::TargetCostKind CostKind,\n                         const Instruction *I = nullptr);\n  int getVectorInstrCost(unsigned Opcode, Type *Val, unsigned Index);\n  unsigned getScalarizationOverhead(VectorType *Ty, const APInt &DemandedElts,\n                                    bool Insert, bool Extract);\n  int getMemoryOpCost(unsigned Opcode, Type *Src, MaybeAlign Alignment,\n                      unsigned AddressSpace,\n                      TTI::TargetCostKind CostKind,\n                      const Instruction *I = nullptr);\n  int getMaskedMemoryOpCost(\n      unsigned Opcode, Type *Src, Align Alignment, unsigned AddressSpace,\n      TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency);\n  int getGatherScatterOpCost(unsigned Opcode, Type *DataTy, const Value *Ptr,\n                             bool VariableMask, Align Alignment,\n                             TTI::TargetCostKind CostKind,\n                             const Instruction *I);\n  int getAddressComputationCost(Type *PtrTy, ScalarEvolution *SE,\n                                const SCEV *Ptr);\n\n  Optional<Instruction *> instCombineIntrinsic(InstCombiner &IC,\n                                               IntrinsicInst &II) const;\n  Optional<Value *>\n  simplifyDemandedUseBitsIntrinsic(InstCombiner &IC, IntrinsicInst &II,\n                                   APInt DemandedMask, KnownBits &Known,\n                                   bool &KnownBitsComputed) const;\n  Optional<Value *> simplifyDemandedVectorEltsIntrinsic(\n      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts, APInt &UndefElts,\n      APInt &UndefElts2, APInt &UndefElts3,\n      std::function<void(Instruction *, unsigned, APInt, APInt &)>\n          SimplifyAndSetOp) const;\n\n  unsigned getAtomicMemIntrinsicMaxElementSize() const;\n\n  int getTypeBasedIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,\n                                     TTI::TargetCostKind CostKind);\n  int getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,\n                            TTI::TargetCostKind CostKind);\n\n  int getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,\n                                 bool IsPairwiseForm,\n                                 TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency);\n\n  int getMinMaxCost(Type *Ty, Type *CondTy, bool IsUnsigned);\n\n  int getMinMaxReductionCost(VectorType *Ty, VectorType *CondTy,\n                             bool IsPairwiseForm, bool IsUnsigned,\n                             TTI::TargetCostKind CostKind);\n\n  int getInterleavedMemoryOpCost(\n      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,\n      Align Alignment, unsigned AddressSpace,\n      TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency,\n      bool UseMaskForCond = false, bool UseMaskForGaps = false);\n  int getInterleavedMemoryOpCostAVX512(\n      unsigned Opcode, FixedVectorType *VecTy, unsigned Factor,\n      ArrayRef<unsigned> Indices, Align Alignment, unsigned AddressSpace,\n      TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency,\n      bool UseMaskForCond = false, bool UseMaskForGaps = false);\n  int getInterleavedMemoryOpCostAVX2(\n      unsigned Opcode, FixedVectorType *VecTy, unsigned Factor,\n      ArrayRef<unsigned> Indices, Align Alignment, unsigned AddressSpace,\n      TTI::TargetCostKind CostKind = TTI::TCK_SizeAndLatency,\n      bool UseMaskForCond = false, bool UseMaskForGaps = false);\n\n  int getIntImmCost(int64_t);\n\n  int getIntImmCost(const APInt &Imm, Type *Ty, TTI::TargetCostKind CostKind);\n\n  unsigned getCFInstrCost(unsigned Opcode, TTI::TargetCostKind CostKind);\n\n  int getIntImmCostInst(unsigned Opcode, unsigned Idx, const APInt &Imm,\n                        Type *Ty, TTI::TargetCostKind CostKind,\n                        Instruction *Inst = nullptr);\n  int getIntImmCostIntrin(Intrinsic::ID IID, unsigned Idx, const APInt &Imm,\n                          Type *Ty, TTI::TargetCostKind CostKind);\n  bool isLSRCostLess(TargetTransformInfo::LSRCost &C1,\n                     TargetTransformInfo::LSRCost &C2);\n  bool canMacroFuseCmp();\n  bool isLegalMaskedLoad(Type *DataType, Align Alignment);\n  bool isLegalMaskedStore(Type *DataType, Align Alignment);\n  bool isLegalNTLoad(Type *DataType, Align Alignment);\n  bool isLegalNTStore(Type *DataType, Align Alignment);\n  bool isLegalMaskedGather(Type *DataType, Align Alignment);\n  bool isLegalMaskedScatter(Type *DataType, Align Alignment);\n  bool isLegalMaskedExpandLoad(Type *DataType);\n  bool isLegalMaskedCompressStore(Type *DataType);\n  bool hasDivRemOp(Type *DataType, bool IsSigned);\n  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty);\n  bool areInlineCompatible(const Function *Caller,\n                           const Function *Callee) const;\n  bool areFunctionArgsABICompatible(const Function *Caller,\n                                    const Function *Callee,\n                                    SmallPtrSetImpl<Argument *> &Args) const;\n  TTI::MemCmpExpansionOptions enableMemCmpExpansion(bool OptSize,\n                                                    bool IsZeroCmp) const;\n  bool enableInterleavedAccessVectorization();\n\nprivate:\n  int getGSScalarCost(unsigned Opcode, Type *DataTy, bool VariableMask,\n                      Align Alignment, unsigned AddressSpace);\n  int getGSVectorCost(unsigned Opcode, Type *DataTy, const Value *Ptr,\n                      Align Alignment, unsigned AddressSpace);\n\n  int getGatherOverhead() const;\n  int getScatterOverhead() const;\n\n  /// @}\n};\n\n} // end namespace llvm\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 35, "line": 115}, "message": "'IntrinsicCostAttributes' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h", "reportHash": "87e2dff37d07c8bf9f4713f7b3f5ba74", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 36, "line": 46}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 36, "line": 46}, "message": "'TargetTransformInfoImplBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h", "reportHash": "aeac304bb824d354b332538434556d90", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 53, "line": 2325}, "message": "'AddrMode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h", "reportHash": "a55f19e794ce41f2938db93122fad898", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 114, "line": 27}, "message": "'X86TTIImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.h", "reportHash": "a9fa6d805808a46c0e1dd280ef9ae075", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
